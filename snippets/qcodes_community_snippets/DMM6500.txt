To connect to a DMM6500 using Qcodes Community, you can use the following Python script:

```python
from qcodes.instrument.visa import VisaInstrument
from qcodes.instrument.channel import InstrumentChannel
from qcodes.utils.validators import Numbers
from functools import partial
from .Keithley_2000_Scan import Keithley_2000_Scan_Channel


class Keithley_Sense(InstrumentChannel):
    def __init__(self, parent: VisaInstrument, name: str, channel: str) -> None:
        valid_channels = ['VOLT', 'CURR', 'RES', 'FRES', 'TEMP']
        if channel.upper() not in valid_channels:
            raise ValueError(f"Channel must be one of the following: {', '.join(valid_channels)}")
        super().__init__(parent, name)

        self.add_parameter('measure',
                           unit=self._get_unit(channel),
                           label=self._get_label(channel),
                           get_parser=float,
                           get_cmd=partial(self.parent._measure, channel),
                           docstring="Measure value of chosen quantity (Current/Voltage/Resistance/Temperature)."
                           )

        self.add_parameter('nplc',
                           label='NPLC',
                           get_parser=float,
                           get_cmd=f"SENS:{channel}:NPLC?",
                           set_cmd=f"SENS:{channel}:NPLC {{:.4f}}",
                           vals=Numbers(0.0005, 12),
                           docstring="Integration rate (Number of Power Line Cycles)"
                           )

    @staticmethod
    def _get_unit(quantity: str) -> str:
        channel_units = {'VOLT': 'V', 'CURR': 'A', 'RES': 'Ohm', 'FRES': 'Ohm', 'TEMP': 'C'}
        return channel_units[quantity]

    @staticmethod
    def _get_label(quantity: str) -> str:
        channel_labels = {'VOLT': 'Measured voltage.',
                          'CURR': 'Measured current.',
                          'RES': 'Measured resistance',
                          'FRES': 'Measured resistance (4w)',
                          'TEMP': 'Measured temperature'}
        return channel_labels[quantity]


class Keithley_6500(VisaInstrument):
    def __init__(self, name: str, address: str, terminator="\n", **kwargs):
        super().__init__(name, address, terminator=terminator, **kwargs)
        for quantity in ['VOLT', 'CURR', 'RES', 'FRES', 'TEMP']:
            channel = Keithley_Sense(self, quantity.lower(), quantity)
            self.add_submodule(quantity.lower(), channel)

        self.add_parameter('active_terminal',
                           label='active terminal',
                           get_cmd="ROUTe:TERMinals?",
                           docstring="Active terminal of instrument. Can only be switched via knob on front panel.")

        self.add_parameter('resistance',
                           unit='Ohm',
                           label='Measured resistance',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'RES'),
                           )

        self.add_parameter('resistance_4w',
                           unit='Ohm',
                           label='Measured resistance',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'FRES')
                           )

        self.add_parameter('voltage_dc',
                           unit='V',
                           label='Measured DC voltage',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'VOLT')
                           )

        self.add_parameter('current_dc',
                           unit='A',
                           label='Measured DC current',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'CURR')
                           )

        self.add_parameter('temperature',
                           unit='C',
                           label='Measured temperature',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'TEMP')
                           )

        self.connect_message()

    def _measure(self, quantity: str) -> str:
        if self.active_terminal.get() == 'FRON':
            return self.ask(f"MEAS:{quantity}?")
        else:
            raise RuntimeError("Rear terminal is active instead of front terminal.")
```

This script defines two classes: `Keithley_Sense` and `Keithley_6500`. The `Keithley_Sense` class represents a measurement channel, while the `Keithley_6500` class is the driver for the Keithley DMM6500 digital multimeter.

To connect to the DMM6500, you can create an instance of the `Keithley_6500` class and provide the name and address of the instrument. For example:

```python
dmm = Keithley_6500(name='dmm', address='TCPIP0::192.168.1.1::inst0::INSTR')
```

Replace `'TCPIP0::192.168.1.1::inst0::INSTR'` with the actual address of your DMM6500.

Once connected, you can access the measurement channels and parameters of the DMM6500 using the instance `dmm`. For example, to measure the voltage, you can use:

```python
voltage = dmm.voltage_dc()
```

This will return the measured DC voltage as a float value.

Note that you may need to install the necessary dependencies (`qcodes`, `pyvisa`, etc.) before running this script.