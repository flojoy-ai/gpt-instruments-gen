,Device datasheet (PDF),Category description link,Device picture,"Yearly revenue (millions, USD)",Vendor headquarters,Vendor logo URL,Device Description,Device Description Link,Device,Field 1,Device Category,Category Description,Vendor wikipedia or cruncbase description,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Library,Python docs link,Vendor,Vendor logo,Vendor website,Image URL,Corrected device name,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,QA Notes,docstring
4,https://www.lakeshore.com/docs/default-source/product-downloads/421_manual.pdf?sfvrsn=df2b523_1,https://en.wikipedia.org/wiki/Magnetometer,"[OrderedDict([('id', 'attfRIGys26mJGLmT'), ('width', 673), ('height', 349), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OeJqiTgNcRRYERiVbIdGfg/ebB46l1uF2WVsOxjvBmfJcYi5RBRZqxpTgth05Kc9IkHWeM_Wn83iXiiuPSn_x5MCh5Kq8Ump30vtIgP9zJ1hVQrUIFElmEY7aQgrBs2X9Y/hAUxUNGz8nvot6vv4fY4xu-1DVnMiYyVwqPIfk5KZCU'), ('filename', 'image.png'), ('size', 131267), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xCzH-nKhyefoFQ5T67n45g/Y5e2-PYTEFLfVZa7KlnxWNBThFu-7Nsa6ElbKyDbgU0XwfPlihHzCJAmmYpwP32B90D6NKug6O0j4iTWwqTxYQ/_xrH4hXrTD_JY85-M6grJNG3aBeehGJOBN-0pqt-zh0'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zTHb7DCVvEofcfMpq_tjlA/L6Td5ds5Vx75NDs60PqukZsR_U0PAb8aKMewV_C_VwFlhoRCdsQvL_1TA8hmGcg89VF7z5jl2iZYGaFIl6Qrmg/kcl6iF0WoZjx_UVcZZCXgOPbHWShccKbCjIlAKhYC0Y'), ('width', 673), ('height', 349)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/c5XY0ZSyZVC9pHNhoNZ79Q/f9oWh6TxmFb4nfwG0JANoZCZLBWX78yPdzK5xLoMT-1DAgdhiFRObfOeZuyHoYaYtl4WMjGOQ5oU9aWczTvg1Q/IYEZbz5NJvx2oCrevR13xdGkRgavD-8z4dldmrCLSRA'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"Flexible probe configurations to suit your application.
Several sensor types available with different performance characteristics.
Most suited for field levels from earth field to very large electromagnets.
Application-specific probe customization available.",https://www.lakeshore.com/products/categories/overview/magnetic-products/hall-probes/400-series-hall-probes,Lakeshore 421,354.0,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore421.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore421.html,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782424/Instruments/Power%20Meters/Lakeshore-421/Lakeshore-421.png,Lakeshore 421,Write a Python script that uses Pymeasure to connect to a Lakeshore 421 Power Meters,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set

import numpy as np
from time import time, sleep


class LakeShore421(Instrument):
    """"""
    Represents the Lake Shore 421 Gaussmeter and provides a high-level interface for interacting
    with the instrument.

    .. code-block:: python

        gaussmeter = LakeShore421(""COM1"")
        gaussmeter.unit = ""T""               # Set units to Tesla
        gaussmeter.auto_range = True        # Turn on auto-range
        gaussmeter.fast_mode = True         # Turn on fast-mode


    A delay of 50 ms is ensured between subsequent writes, as the instrument cannot correctly
    handle writes any faster.
    """"""

    MULTIPLIERS = {1e3: 'k', 1: '', 1e-3: 'm', 1e-6: 'n'}
    PROBE_TYPES = {""High Sensitivity"": 0,
                   ""High Stability"": 1,
                   ""Ultra-High Sensitivity"": 2}
    RANGES = [30e3, 3e3, 300, 30]  # in Gauss
    RANGE_MULTIPLIER_PROBE = [1, 10, 0.01]
    RANGE_MULTIPLIER_UNIT = {'G': 1, 'T': 1e-4}
    UNITS = ['G', 'T']
    WRITE_DELAY = 0.05

    def __init__(self, adapter, name=""Lake Shore 421 Gaussmeter"", baud_rate=9600, **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'baud_rate': baud_rate, 'data_bits': 7, 'stop_bits': 10, 'parity': 1},
            read_termination='\r',
            write_termination='\n',
            **kwargs
        )
        self.last_write_time = time()

    def _raw_to_field(self, field_raw, multiplier_name):
        if not field_raw == ""OL"":
            multiplier = getattr(self, multiplier_name)
            field = multiplier * field_raw
        else:
            field = np.nan

        return field

    def _field_to_raw(self, field, multiplier_name):
        multiplier = getattr(self, multiplier_name)
        return field / multiplier

    field_raw = Instrument.measurement(
        ""FIELD?"",
        """""" Returns the field in the current units and multiplier
        """""",
    )

    field_multiplier = Instrument.measurement(
        ""FIELDM?"",
        """""" Returns the field multiplier for the returned magnetic field.
        """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def field(self):
        """""" Returns the field in the current units. This property takes into
        account the field multiplier. Returns np.nan if field is out of range.
        """"""
        return self._raw_to_field(self.field_raw, ""field_multiplier"")

    unit = Instrument.control(
        ""UNIT?"", ""UNIT %s"",
        """""" A string property that controls the units used by the gaussmeter.
        Valid values are G (Gauss), T (Tesla). """""",
        validator=strict_discrete_set,
        values=UNITS,
    )

    field_range_raw = Instrument.control(
        ""RANGE?"", ""RANGE %d"",
        """""" A integer property that controls the field range of the
        meter. Valid values are 0 (highest) to 3 (lowest). """""",
        validator=truncated_discrete_set,
        values=range(4),
        cast=int,
    )

    @property
    def field_range(self):
        """""" A floating point property that controls the field range of the
        meter in the current unit (G or T). Valid values are 30e3, 3e3, 300,
        30 (when in Gauss), or 0.003, 0.03, 0.3, and 3 (when in Tesla).
        """"""
        probe_multiplier = self.RANGE_MULTIPLIER_PROBE[self.PROBE_TYPES[self.probe_type]]
        unit_multiplier = self.RANGE_MULTIPLIER_UNIT[self.unit]
        range = self.RANGES[self.field_range_raw]
        return np.round(range * probe_multiplier * unit_multiplier, 3)

    @field_range.setter
    def field_range(self, range):
        probe_multiplier = self.RANGE_MULTIPLIER_PROBE[self.PROBE_TYPES[self.probe_type]]
        unit_multiplier = self.RANGE_MULTIPLIER_UNIT[self.unit]
        ranges = np.array(self.RANGES) * probe_multiplier * unit_multiplier
        range = truncated_discrete_set(range, values=ranges)
        range = np.round(range / (probe_multiplier * unit_multiplier), 3)

        self.field_range_raw = self.RANGES.index(range)

    auto_range = Instrument.control(
        ""AUTO?"", ""AUTO %d"",
        """""" A boolean property that controls the auto-range option of the
        meter. Valid values are True and False. Note that the auto-range is
        relatively slow and might not suffice for rapid measurements.
        """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    fast_mode = Instrument.control(
        ""FAST?"", ""FAST %d"",
        """""" A boolean property that controls the fast-mode option of the
        meter. Valid values are True and False. When enabled, the relative
        mode, Max Hold mode, alarms, and autorange are disabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    field_mode = Instrument.control(
        ""ACDC?"", ""ACDC %d"",
        """""" A string property that controls whether the gaussmeter measures
        AC or DC magnetic fields. Valid values are ""AC"" and ""DC"". """""",
        validator=strict_discrete_set,
        values={""DC"": 0, ""AC"": 1},
        map_values=True,
    )

    def zero_probe(self, wait=True):
        """""" Reset the probe value to 0. It is normally used with a zero gauss
        chamber, but may also be used with an open probe to cancel the Earth
        magnetic field. To cancel larger magnetic fields, the relative mode
        should be used.

        :param bool wait:
            Wait for 20 seconds after issuing the command to allow the
            resetting to finish.

        """"""
        self.write(""ZCAL"")
        if wait:
            sleep(20)

    probe_type = Instrument.measurement(
        ""TYPE?"",
        """""" Returns type of field-probe used with the gaussmeter. Possible
        values are High Sensitivity, High Stability, or Ultra-High Sensitivity.
        """""",
        values=PROBE_TYPES,
        map_values=True,
    )

    serial_number = Instrument.measurement(
        ""SNUM?"",
        """""" Returns the serial number of the probe. """"""
    )

    display_filter_enabled = Instrument.control(
        ""FILT?"", ""FILT %d"",
        """""" A boolean property that controls the display filter to make it
        more readable when the probe is exposed to a noisy field. The filter
        function makes a linear average of 8 readings and settles in
        approximately 2 seconds. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    front_panel_locked = Instrument.control(
        ""LOCK?"", ""LOCK %d"",
        """""" A boolean property that locks or unlocks all front panel entries
        except pressing the Alarm key to silence alarms. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    front_panel_brightness = Instrument.control(
        ""BRIGT?"", ""BRIGT %d"",
        """""" An integer property that controls the brightness of the from panel
        display. Valid values are 0 (dimmest) to 7 (brightest). """""",
        validator=strict_discrete_set,
        values=range(8),
    )

    # MAX HOLD
    max_hold_enabled = Instrument.control(
        ""MAX?"", ""MAX %d"",
        """""" A boolean property that enables or disables the Max Hold function to
        store the largest field since the last reset (with max_hold_reset). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    max_hold_field_raw = Instrument.measurement(
        ""MAXR?"",
        """""" Returns the largest field since the last reset in the current units
        and multiplier.
        """""",
    )

    max_hold_multiplier = Instrument.measurement(
        ""FIELDM?"",
        """""" Returns the multiplier for the returned max hold field.
        """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def max_hold_field(self):
        """""" Returns the largest field since the last reset in the current units.
        This property takes into account the field multiplier. Returns np.nan if
        field is out of range.
        """"""
        return self._raw_to_field(self.max_hold_field_raw, ""max_hold_multiplier"")

    def max_hold_reset(self):
        """""" Clears the stored Max Hold value. """"""
        self.write(""MAXC"")

    # RELATIVE MODE
    relative_mode_enabled = Instrument.control(
        ""REL?"", ""REL %d"",
        """""" A boolean property that enables or disables the relative mode to
        see small variations with respect to a given setpoint. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    relative_field_raw = Instrument.measurement(
        ""RELR?"",
        """""" Returns the relative field in the current units and the current
        multiplier. """""",
    )

    relative_multiplier = Instrument.measurement(
        ""RELRM?"",
        """""" Returns the relative field multiplier for the returned magnetic
        field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def relative_field(self):
        """""" Returns the relative field in the current units. This property
        takes into account the field multiplier. Returns np.nan if field is
        out of range.
        """"""
        return self._raw_to_field(self.relative_field_raw, ""relative_multiplier"")

    relative_setpoint_raw = Instrument.control(
        ""RELS?"", ""RELS %g"",
        """""" Property that controls the setpoint for the relative field mode in
        the current units and multiplier. """""",
    )

    relative_setpoint_multiplier = Instrument.measurement(
        ""RELRM?"",
        """""" Returns the multiplier for the setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def relative_setpoint(self):
        """""" Property that controls the setpoint for the relative field mode in
        the current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.relative_setpoint_raw, ""relative_setpoint_multiplier"")

    @relative_setpoint.setter
    def relative_setpoint(self, value):
        self.relative_setpoint_raw = self._field_to_raw(value, ""relative_setpoint_multiplier"")

    # ALARM MODE
    alarm_mode_enabled = Instrument.control(
        ""ALARM?"", ""ALARM %d"",
        """""" A boolean property that enables or disables the alarm mode. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_audible = Instrument.control(
        ""ALMB?"", ""ALMB %d"",
        """""" A boolean property that enables or disables the audible alarm
        beeper. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_in_out = Instrument.control(
        ""ALMB?"", ""ALMB %d"",
        """""" A string property that controls whether an active alarm is caused
        when the field reading is inside (""Inside"") or outside (""Outside"") of
        the high and low setpoint values. """""",
        validator=strict_discrete_set,
        values={""Inside"": 1, ""Outside"": 0},
        map_values=True,
    )

    alarm_active = Instrument.measurement(
        ""ALMS?"",
        """""" A boolean property that returns whether the alarm is triggered. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_sort_enabled = Instrument.control(
        ""ALMSORT?"", ""ALMSORT %d"",
        """""" A boolean property that enables or disables the alarm Sort Pass/Fail
        function. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_low_raw = Instrument.measurement(
        ""ALML?"", ""ALML %g"",
        """""" Property that controls the lower setpoint for the alarm mode in the
        current units and multiplier. """""",
    )

    alarm_low_multiplier = Instrument.measurement(
        ""ALMLM?"",
        """""" Returns the multiplier for the lower alarm setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def alarm_low(self):
        """""" Property that controls the lower setpoint for the alarm mode in the
        current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.alarm_low_raw, ""alarm_low_multiplier"")

    @alarm_low.setter
    def alarm_low(self, value):
        self.alarm_low_raw = self._field_to_raw(value, ""alarm_low_multiplier"")

    alarm_high_raw = Instrument.measurement(
        ""ALMH?"", ""ALMH %g"",
        """""" Property that controls the upper setpoint for the alarm mode in the
        current unit and multiplier. """""",
    )

    alarm_high_multiplier = Instrument.measurement(
        ""ALMHM?"",
        """""" Returns the multiplier for the upper alarm setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def alarm_high(self):
        """""" Property that controls the upper setpoint for the alarm mode in the
        current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.alarm_high_raw, ""alarm_high_multiplier"")

    @alarm_high.setter
    def alarm_high(self, value):
        self.alarm_high_raw = self._field_to_raw(value, ""alarm_high_multiplier"")

    def shutdown(self):
        """""" Closes the serial connection to the system. """"""
        self.adapter.connection.close()
        super().shutdown()

    ###################################################
    # Redefined methods to ensure time between writes #
    ###################################################

    def delay_write(self):
        if self.WRITE_DELAY is None:
            return

        while time() - self.last_write_time < self.WRITE_DELAY:
            sleep(self.WRITE_DELAY / 10)

        self.last_write_time = time()

    def write(self, command):
        self.delay_write()
        super().write(command)
"
6,https://www.thinksrs.com/downloads/pdfs/catalog/SR570c.pdf,"https://en.wikipedia.org/wiki/Preamplifier#:~:text=A%20preamplifier%2C%20also%20known%20as,power%20amplifier%20and%20a%20loudspeaker.","[OrderedDict([('id', 'atthbLSs7aLIhAPMD'), ('width', 2630), ('height', 1420), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biT6AhDUCHdfaDz8wxT4Qw/oJjykM2ZYSr3bGa1nq4YzXr12q-ZoSWPJTfGq6qkiVie5QOfTAFpVatJBMnwbIjEQ7QNBiNUmljXpEDi6sNQcfz_S32hB8DYRojlA-H0eVU/69uhrvZGiNz2rDeGLYLANmxSu97TCxQcBLo_RNsGN0o'), ('filename', 'SR570 MainPic.jpg'), ('size', 543919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/dILBWHC82YQsw9Meji6noQ/XRy4IaY_sGoP4wgjBeM8rasZO6wiPv4UxbW6cmi9_s708IPIAi1J2q1SNfOwBxjbn4ffcgXtvx3krxXWDInpzw/OZVe4ZClZkixqcgT8HeIHPCvD7KutkzOrdtN3KiNtMY'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0fBZyOsMG12V8W7Il2Xatw/mT38rd63YaQrmNS3GsQmN64YhlIHZuoEJTk29ylRONEV-wTicrBgiTZlByHySOa3Y-dtxnb_WnrFHrp0Tckqcg/TFGsrMNJ8mlYFjg28zL5SPNYtHBV5yrQEUp4D8HdjFs'), ('width', 948), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xJmPjGDe0-LgD2LorktF4Q/NytNSCHwS-iXUlHDEY40GLp1pPVpAQCvn9VGtxWSOTFPKwyFxnXS6zc0KDqQm1DtpRIq-3WpbVYucMlmmaCCtA/kiQl15Kv_tP-VAaC-CktTJLfVbkaz0no34Wzaq4kdv0'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"The SR570 is a low-noise current preamplifier capable of current gains as large as 1 pA/V. High gain and bandwidth, low noise, and many convenient features make the SR570 ideal for a variety of photonic, low temperature and other measurements.",https://www.thinksrs.com/products/sr570.html,SR 570,520.0,['Preamplifier'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker. Without this, the final signal would be noisy or distorted. They are typically used to amplify signals from analog sensors such as microphones and pickups. Because of this, the preamplifier is often placed close to the sensor to reduce the effects of noise and interference.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr570.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr570.html,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782426/Instruments/Preamplifier/SR-570/SR-570.jpg,SR 570,Write a Python script that uses Pymeasure to connect to a SR 570 Preamplifier,2750.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range


class SR570(Instrument):

    def __init__(self, adapter, name=""Stanford Research Systems SR570 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    SENSITIVITIES = [
        1e-12, 2e-12, 5e-12, 10e-12, 20e-12, 50e-12, 100e-12, 200e-12, 500e-12,
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9, 500e-9,
        1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6, 200e-6, 500e-6,
        1e-3
    ]

    FREQUENCIES = [
        0.03, 0.1, 0.3, 1, 3, 10, 30, 100, 300, 1e3, 3e3, 1e4, 3e4,
        1e5, 3e5, 1e6
    ]

    FILT_TYPES = ['6dB Highpass', '12dB Highpass', '6dB Bandpass',
                  '6dB Lowpass', '12dB Lowpass', 'none']

    BIAS_LIMITS = [-5, 5]

    OFFSET_CURRENTS = [
        1e-12, 2e-12, 5e-12, 10e-12, 20e-12, 50e-12, 100e-12, 200e-12, 500e-12,
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9, 500e-9,
        1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6, 200e-6, 500e-6,
        1e-3, 2e-3, 5e-3
    ]

    GAIN_MODES = [
        'Low Noise', 'High Bandwidth', 'Low Drift'
    ]

    sensitivity = Instrument.setting(
        ""SENS %d"",
        """""" A floating point value that sets the sensitivity of the
        amplifier, which takes discrete values in a 1-2-5 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 1 pA/V to 1 mA/V."""""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True)

    filter_type = Instrument.setting(
        ""FLTT %d"",
        """""" A string that sets the filter type.
        Allowed values are: {}"""""".format(FILT_TYPES),
        validator=truncated_discrete_set,
        values=FILT_TYPES,
        map_values=True)

    low_freq = Instrument.setting(
        ""LFRQ %d"",
        """""" A floating point value that sets the lowpass frequency of the
        amplifier, which takes a discrete value in a 1-3 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 0.03 Hz to 1 MHz."""""",
        validator=truncated_discrete_set,
        values=FREQUENCIES,
        map_values=True)

    high_freq = Instrument.setting(
        ""HFRQ %d"",
        """""" A floating point value that sets the highpass frequency of the
        amplifier, which takes a discrete value in a 1-3 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 0.03 Hz to 1 MHz."""""",
        validator=truncated_discrete_set,
        values=FREQUENCIES,
        map_values=True)

    bias_level = Instrument.setting(
        ""BSLV %g"",
        """""" A floating point value in V that sets the bias voltage level of the
        amplifier, in the [-5V,+5V] limits.
        The values are up to 1 mV precision level."""""",
        validator=truncated_range,
        values=BIAS_LIMITS,
        set_process=lambda v: int(1000 * v))

    offset_current = Instrument.setting(
        ""BSLV %f"",
        """""" A floating point value in A that sets the absolute value
        of the offset current of the amplifier, in the [1pA,5mA] limits.
        The offset current takes discrete values in a 1-2-5 sequence.
        Values are truncated to the closest allowed value if not exact. """""",
        validator=truncated_discrete_set,
        values=OFFSET_CURRENTS,
        map_values=True)

    offset_current_sign = Instrument.setting(
        ""IOSN %d"",
        """""" An string that sets the offset current sign.
        Allowed values are: 'positive' and 'negative'. """""",
        validator=strict_discrete_set,
        values={'positive': 1, 'negative': 0},
        map_values=True)

    gain_mode = Instrument.setting(
        ""GNMD %d"",
        """""" A string that sets the gain mode.
        Allowed values are: {}"""""".format(GAIN_MODES),
        validator=truncated_discrete_set,
        values=GAIN_MODES,
        map_values=True)

    invert_signal_sign = Instrument.setting(
        ""INVT %d"",
        """""" An boolean sets the signal invert sense.
        Allowed values are: True (inverted) and False (not inverted). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    bias_enabled = Instrument.setting(
        ""BSON %d"",
        """""" Boolean that turns the bias on or off.
        Allowed values are: True (bias on) and False (bias off)"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    offset_current_enabled = Instrument.setting(
        ""IOON %d"",
        """""" Boolean that turns the offset current on or off.
        Allowed values are: True (current on) and False (current off)."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    front_blanked = Instrument.setting(
        ""BLNK %d"",
        """""" Boolean that blanks(True) or un-blanks (False) the front panel"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    signal_inverted = Instrument.setting(
        ""INVT %d"",
        """""" Boolean that inverts the signal if True"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    ####################
    # Methods        #
    ####################

    def enable_bias(self):
        """"""Turns the bias voltage on""""""
        self.bias_enabled = True

    def disable_bias(self):
        """"""Turns the bias voltage off""""""
        self.bias_enabled = False

    def enable_offset_current(self):
        """"""""Enables the offset current """"""
        self.offset_current_enabled = True

    def disable_offset_current(self):
        """"""""Disables the offset current """"""
        self.offset_current_enabled = False

    def clear_overload(self):
        """"""""Reset the filter capacitors to clear an overload condition""""""
        self.write(""ROLD"")

    def blank_front(self):
        """"""""Blanks the frontend output of the device""""""
        self.front_blanked = True

    def unblank_front(self):
        """"""Un-blanks the frontend output of the device""""""
        self.front_blanked = False
"
8,https://maximinstruments.com/pdf_files/TEMPTRONIC_ATS_545M_Datasheet.pdf,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.","[OrderedDict([('id', 'att4PXmbvfTpdbZAZ'), ('width', 250), ('height', 537), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZyyhN-vy3OqFjbyiAct9vA/BmmixvK4devi8LvsekteHt-TONKqx9cEmsE4g__xbqN0dM5s8pzM3l00gamUnhYGO4zy3jDrWAMS1-n8fiTCkwr_ddz8fDVpoFJRCj8Y1ynehsmpPW0iSiTYq-M1YZS0/k8yLpgz4EVxAbOY_aDgQFiNOqpxuUaAYp7L0hzNhqAs'), ('filename', 'ThermoStream-ATS-710-250.webp'), ('size', 11590), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7QmpEEJmUQtDVYktb2eLbQ/lvyXYPXWY4SCo9BzD5kxKrKKToqnuE1oWPrp7KT6Ra2AuWftptw3dbK8HjBchVUL8CCw-Vq7yIIAFJxfEsW6nNyGuw25U_AbKnQjcC0S0O0/NCI2lqulS5FpFLjOu6O0f65qPpxCDeJ2xUe_9aP5DF4'), ('width', 17), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bSyu_yxh248pRRVWnAJ-tA/smHrCmZkOfbSiFtuU3373SM7dfpt14G7I6UZn7LMFiWuDJ7fzbNyb-3O6Qe-hBpq0O5eD2LbrLkC0FgSxN6VXr_e7cBYPllTI_Sdx6QJb1E/2pNKzwocPNYnul0HkywPE5Ukh1MYoSWRNprfjMzt_kU'), ('width', 250), ('height', 537)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kUR53Sqw6iEKQRuBQa9_cA/wALDRGO6mj2zTxMgi22wfF53oVtHdgFHImOlgZgH1YXTh6MEXyWw-8OuHT8rhBLCLbFtQkxiFrSwSIzQxFxafPZJQlyjFDAZmDsryS9J0sY/-4moCT1Wl5zdvVsknVNRXTSjKLRC8kSQmppDfBg9Yt0'), ('width', 3000), ('height', 3000)]))]))])]",19.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125985/Instruments/Vendor%20Logos/Temptronic.png,"Advanced Temperature Source for fast and precise thermal conditioning of components, parts, hybrids, modules, sub-assemblies, and printed circuit boards.",https://maximinstruments.com/products/temptronic_ats_545_m_thermostream__80_to_225c,ATS 545,589.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_ats545.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_ats545.html,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XkJOd2Fwd9vcwCxlWHYuVQ/Mj4zcFto3BrPOFLOgDiJd0bpi2u3YU2gCJWyUK3OqmTSUMrQ3zJmguf6SjcB-3KXYD8TAEHYL4zaFUeLJFcBoggEqNz3w2DZsgNzGWOK-GPmzprqI71Kb-SSJoeT1OzR/3bmPScz9e0R01o5_F4ME4BwK3P4G8DsmouH8CdiESg0'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lgs8naZZFDDY_xgAouIDeA/1nfEKPkT-AFUq5MmcJ2mRR9XvszzohqDjknqySo9xmsgWJlaCBqO3LGEnL_81Cjk8cXTdCEo_sfkYiyl2E91og/9RRq8Xvxs0cMV-sW6njjL5o0u7Z-BsAdpMP3bCqaCN8'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YHM46j4C5UJtnJFaW4kxGw/fKqMItDmtOQJJHgRnWPFZoWiNzcyh3ZA4f8YfzCA_Pw8VH-WuUimbE8EtU7rniTK-kZSc8_j5nLwl6-D4cI9Dw/d3ZvtW1XBgsk6-SbAhezCQqjZ0DgtKSleP1_wZRKgrU'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U-hY1Sy2d_2OHAR_2IFmeg/pzM0ALGEDOXV1Dc6iR6hSv-RKOkda5QWdCGKwOssrylOUa3LXbMGyo_LdusCw53TFwdtbLggMgBXRVdG7xJV9A/GLMlL87L8YChOOgVU1B6Rlif7NwNoQPHCvw_Vf96jTE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782427/Instruments/Temperature%20Controllers/ATS-545/ATS-545.webp,ATS 545,Write a Python script that uses Pymeasure to connect to a ATS 545 Temperature Controllers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ATS-545 & -645
THERMOSTREAM
Interface & Applications Manual
Revision B
November, 2015
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase


class ATS545(ATSBase):
    """"""Represents the TemptronicATS545 instrument.

    Coding example

    .. code-block:: python

        ts = ATS545('ASRL3::INSTR')  # replace adapter address
        ts.configure()  # basic configuration (defaults to T-DUT)
        ts.start()  # starts flow (head position not changed)
        ts.set_temperature(25)  # sets temperature to 25 degC
        ts.wait_for_settling()  # blocks script execution and polls for settling
        ts.shutdown(head=False)  # disables thermostream, keeps head down

    """"""

    temperature_limit_air_low_values = [-80, 25]

    mode_values = {'manual': 10,    # 5 in ATSbase
                   'program': 0,    # 6 in ATSbase
                   'initial': 63},  # after power up, reading is 63

    def next_setpoint(self):
        """"""not implemented in ATS545

        set ``self.set_point_number`` instead
        """"""
        raise NotImplementedError

    def __init__(self, adapter, name=""Temptronic ATS-545 Thermostream"", **kwargs):
        super().__init__(adapter, name, **kwargs)
"
17,https://cdn.tmi.yokogawa.com/IM7651-01E.is.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attI6RnDjug8zxuhg'), ('width', 800), ('height', 502), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rC5dEo2WiNl5ac9oO43ZVQ/zRLOMxIV2jLzUfnYL298NTXE2JBrgIak-4TJZy5kPZj0q2-33KkWHL5O_-x3NyoGy5EnUj8nG2REtpEt2osPymbBoRe78VGcqytuYkjgdVo/jDWkxytsI5eCHMGtZzfrX3-wzojiCDtYmfEljwzT_5g'), ('filename', '7651_lg.jpg'), ('size', 302628), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/i0a5kFK5IDdV4EnwpGnSHw/lV7_0nBe_75r_piGeedrmloylAr4-GU5_VPN2E5lTr6oTHSCvNkgmmOP8cOKJ6hYxVH7V8FaKzaniwS2GsTJjg/z3bs7s39hWpFG_URpCRj5Z93y14AzybbKARL7xwYut4'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GidQoq8jVZvKJZbnaSgPZw/jq0Fpnu7wSb8c3amt0hVjDtbE-eK1YSH2ogZaH_TG5heAdgR91KZQs89XwEwW4rWgSrP3RB8zWrj72Wp_rUOSQ/EIAcvEd5V5ztEKg0h57eA8hMapneiyycjZ5ZWwes6-Q'), ('width', 800), ('height', 502)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DS5o_csPBUJfGvwvFIA1GQ/W7v7XA4wImrHLaUCZGyFe2jwu5JJnQhAQAvGKd4UIGx8ViXtXRZh7a2E8Ah1wadhkiwi6BW3BdoR0J3LbppDmA/ScKVdyKzDYrkP1qplBl4Wk9mIEVE5w9InQTz6R6ARak'), ('width', 3000), ('height', 3000)]))]))])]",318.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125993/Instruments/Vendor%20Logos/Yokogawa.png,"The 7651 is a general-purpose DC source developed on YOKOGAWA's state-of-the-art DC standard technology. The dual multiplying D/A converter has enabled the compatibility of high-speed response and high resolution. The 7651 also provides high accuracy and stability. In addition to the source function (current supply), the sink function (current absorption) is also available, so the 7651 can be used as not only DC voltage/current source but also high-precision electronic load. Further, a series of powerful functions to meet the system use such as the programming function up to 50 steps, the IC memory card capable of storing 7 patterns of programs, and GP-IB interface are provided as standard. This 7651 can be used for a wide range of fields from R & D to production line, service and maintenance.",https://tmi.yokogawa.com/ca/solutions/discontinued/7651-programmable-dc-source/,Yokogawa 7651,639.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/yokogawa/yokogawa7651.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/yokogawa/yokogawa7651.html,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/91EkiaJqR32pXT_9j2ikkA/EA8IX6bgJJ5AWHxSJn_XsjdpYAbFM-YDdqUbrZWF93R43aeTp5aElLydj7HEdEh8wo2jzLCFOTdCKUYUpJSqs1zbr_NokqlVS5aCZUEOXdQ/4kbrVwXBbGOLMD1hKLvO7wdukSK2boAdCxBHEMhRvXw'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mLKN3BYMkiZUdn2rlRmVtw/cw3TDV5BlW5jr47wsWYGUsjqEQZbKDvc2mw_Lv9aXzgXtFoYC1bkplw5NhTSdUeNveYCSzsYG9fK-1b24lGzfQ/umhRd2RrT6tf47pL7QQ-NfYCvL9z9J5dB71Th5o0jzE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/a3VAY9DVGC-aEBfsilZ3xw/8a9ejY3MgpFLh3YMiQ-k86blOpOc7VPmtTlcvVeTvXbTwq9ckonmesZx3cT_rNdybRDFFOAT9g5kdq8SOraK_Q/uf6rR_lz7JMeO4cE-hHB-59T8gCRIwI7dhqfDVgASSo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EXvJLqLv0Q1zEcaZ4OYDWw/W05CyYIR7E-TtqueHjX1znSLYTjKMcUW9Z2jdHtLIXhVcPktYi-xnoq2dtrhqqf6FOnJ9gLxlUF3R1y-zUaZzw/5MptEU6yLCcaC2jBAtxU_UfVh58yJurgp_UIp0qIdX8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782436/Instruments/Power%20Supplies/Yokogawa-7651/Yokogawa-7651.jpg,Yokogawa 7651,Write a Python script that uses Pymeasure to connect to a Yokogawa 7651 Power Supplies,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging
from time import sleep
import re

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    truncated_discrete_set, strict_discrete_set,
    truncated_range
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Yokogawa7651(Instrument):
    """""" Represents the Yokogawa 7651 Programmable DC Source
    and provides a high-level for interacting with the instrument.

    .. code-block:: python

        yoko = Yokogawa7651(""GPIB::1"")

        yoko.apply_current()                # Sets up to source current
        yoko.source_current_range = 10e-3   # Sets the current range to 10 mA
        yoko.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        yoko.source_current = 0             # Sets the source current to 0 mA

        yoko.enable_source()                # Enables the current output
        yoko.ramp_to_current(5e-3)          # Ramps the current to 5 mA

        yoko.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    @staticmethod
    def _find(v, key):
        """""" Returns a value by parsing a current panel setting output
        string array, which is returned with a call to ""OS;E"". This
        is used for Instrument.control methods, and should not be
        called directly by the user.
        """"""
        status = ''.join(v.split(""\r\n\n"")[1:-1])
        keys = re.findall(r'[^\dE+.-]+', status)
        values = re.findall(r'[\dE+.-]+', status)
        if key not in keys:
            raise ValueError(""Invalid key used to search for status of Yokogawa 7561"")
        else:
            return values[keys.index(key)]

    source_voltage = Instrument.control(
        ""OD;E"", ""S%g;E"",
        """""" A floating point property that controls the source voltage
        in Volts, if that mode is active. """"""
    )
    source_current = Instrument.control(
        ""OD;E"", ""S%g;E"",
        """""" A floating point property that controls the source current
        in Amps, if that mode is active. """"""
    )
    source_voltage_range = Instrument.control(
        ""OS;E"", ""R%d;E"",
        """""" A floating point property that sets the source voltage range
        in Volts, which can take values: 10 mV, 100 mV, 1 V, 10 V, and 30 V.
        Voltages are truncted to an appropriate value if needed. """""",
        validator=truncated_discrete_set,
        values={10e-3: 2, 100e-3: 3, 1: 4, 10: 5, 30: 6},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'R'))
    )
    source_current_range = Instrument.control(
        ""OS;E"", ""R%d;E"",
        """""" A floating point property that sets the current voltage range
        in Amps, which can take values: 1 mA, 10 mA, and 100 mA.
        Currents are truncted to an appropriate value if needed. """""",
        validator=truncated_discrete_set,
        values={1e-3: 4, 10e-3: 5, 100e-3: 6},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'R'))
    )
    source_mode = Instrument.control(
        ""OS;E"", ""F%d;E"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Yokogawa7651.apply_current` and :meth:`~.Yokogawa7651.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 5, 'voltage': 1},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'F'))
    )
    compliance_voltage = Instrument.control(
        ""OS;E"", ""LV%g;E"",
        """""" A floating point property that sets the compliance voltage
        in Volts, which can take values between 1 and 30 V. """""",
        validator=truncated_range,
        values=[1, 30],
        get_process=lambda v: int(Yokogawa7651._find(v, 'LV'))
    )
    compliance_current = Instrument.control(
        ""OS;E"", ""LA%g;E"",
        """""" A floating point property that sets the compliance current
        in Amps, which can take values from 5 to 120 mA. """""",
        validator=truncated_range,
        values=[5e-3, 120e-3],
        get_process=lambda v: float(Yokogawa7651._find(v, 'LA')) * 1e-3,  # converts A to mA
        set_process=lambda v: v * 1e3,  # converts mA to A
    )

    def __init__(self, adapter, name=""Yokogawa 7651 Programmable DC Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

        self.write(""H0;E"")  # Set no header in output data

    @property
    def id(self):
        """""" Returns the identification of the instrument """"""
        return self.ask(""OS;E"").split('\r\n\n')[0]

    @property
    def source_enabled(self):
        """""" Reads a boolean value that is True if the source is enabled,
        determined by checking if the 5th bit of the OC flag is a binary 1.
        """"""
        oc = int(self.ask(""OC;E"")[5:])
        return oc & 0b10000

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""O1;E"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""O0;E"")

    def apply_current(self, max_current=1e-3, compliance_voltage=1):
        """""" Configures the instrument to apply a source current, which can
        take optional parameters that defer to the :attr:`~.Yokogawa7651.source_current_range`
        and :attr:`~.Yokogawa7651.compliance_voltage` properties. """"""
        self.source_mode = 'current'
        self.source_current_range = max_current
        self.compliance_voltage = compliance_voltage

    def apply_voltage(self, max_voltage=1, compliance_current=10e-3):
        """""" Configures the instrument to apply a source voltage, which can
        take optional parameters that defer to the :attr:`~.Yokogawa7651.source_voltage_range`
        and :attr:`~.Yokogawa7651.compliance_current` properties. """"""
        self.source_mode = 'voltage'
        self.source_voltage_range = max_voltage
        self.compliance_current = compliance_current

    def ramp_to_current(self, current, steps=25, duration=0.5):
        """""" Ramps the current to a value in Amps by traversing a linear spacing
        of current steps over a duration, defined in seconds.

        :param steps: A number of linear steps to traverse
        :param duration: A time in seconds over which to ramp
        """"""
        start_current = self.source_current
        stop_current = current
        pause = duration / steps
        if (start_current != stop_current):
            currents = np.linspace(start_current, stop_current, steps)
            for current in currents:
                self.source_current = current
                sleep(pause)

    def ramp_to_voltage(self, voltage, steps=25, duration=0.5):
        """""" Ramps the voltage to a value in Volts by traversing a linear spacing
        of voltage steps over a duration, defined in seconds.

        :param steps: A number of linear steps to traverse
        :param duration: A time in seconds over which to ramp
        """"""
        start_voltage = self.source_voltage
        stop_voltage = voltage
        pause = duration / steps
        if (start_voltage != stop_voltage):
            voltages = np.linspace(start_voltage, stop_voltage, steps)
            for voltage in voltages:
                self.source_voltage = voltage
                sleep(pause)

    def shutdown(self):
        """""" Shuts down the instrument, and ramps the current or voltage to zero
        before disabling the source. """"""

        # Since voltage and current are set the same way, this
        # ramps either the current or voltage to zero
        self.ramp_to_current(0.0, steps=25)
        self.source_current = 0.0
        self.disable_source()
        super().shutdown()
"
21,https://maximinstruments.com/pdf_files/TEMPTRONIC_ATS_525_Datasheet.pdf,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.","[OrderedDict([('id', 'attdbKRRzLVR858Iu'), ('width', 1269), ('height', 2224), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CdBAR3SIeCLZcI6I_Sfyng/GSz88Ii0RcndvOs1tO1y_u6lQ7KUGSuz13X-xypH3BS5361a_lll9RMSDhOElK10gAhRKlLAMrmesKjC8fSr72_3XQmzzwLm72COZiZi5x0/nK4dXrbspboPdlp_l1zuay3w3mXQJrXpMvgDHZJMsEM'), ('filename', 'ATS-525.jpg'), ('size', 942152), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WoiVgxtLZJi0TGyLT4Uq1g/obKbKpytGSu6yELgPnwqciiZp-hWYC3lOoUTZFn22oNL2AG9_3RKB2u0G0XxfJHSWbhPDgbAA9RgtxlAeMIXuA/f_6OLLpYfN_5OD81mQm1CreLmAoGf5S4nWoylV7RRNQ'), ('width', 21), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kO-h9a0SBwSLSAtJ_oOF1g/dqYJ0Bw13UzPyY_ZlxNKPHfrapk_0d32VrQwqngoJCcWtQE6m5hR-CCr8BlZg72yZ1sMsx3I9ljLxjzDq9Iq1g/Aut9EF6CRIjk8bsI0BCfhPmFrkoBhEGPYfppmd_qdCU'), ('width', 512), ('height', 897)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5-SSo6DDxDx1bJh3B10zxA/cgzYP4sASsWVl2YMtU_aCxtO53JtggJ8sWt3SoUzGaeKyXEMsbOHT6qdAJ3jTnUB6IBchOJ2hMvaIzCV9lMo6w/cO2ky8VtvM7CWbEfMQYyi2KzfhCcTLrgOeqg7_HpNjI'), ('width', 3000), ('height', 3000)]))]))])]",19.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125985/Instruments/Vendor%20Logos/Temptronic.png,"Temptronic ATS-525 Thermostream -60° to +225°C
",https://maximinstruments.com/products/temptronic_ats_525_thermostream__60_to_225c,ATS 525,588.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_ats525.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_ats525.html,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XkJOd2Fwd9vcwCxlWHYuVQ/Mj4zcFto3BrPOFLOgDiJd0bpi2u3YU2gCJWyUK3OqmTSUMrQ3zJmguf6SjcB-3KXYD8TAEHYL4zaFUeLJFcBoggEqNz3w2DZsgNzGWOK-GPmzprqI71Kb-SSJoeT1OzR/3bmPScz9e0R01o5_F4ME4BwK3P4G8DsmouH8CdiESg0'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lgs8naZZFDDY_xgAouIDeA/1nfEKPkT-AFUq5MmcJ2mRR9XvszzohqDjknqySo9xmsgWJlaCBqO3LGEnL_81Cjk8cXTdCEo_sfkYiyl2E91og/9RRq8Xvxs0cMV-sW6njjL5o0u7Z-BsAdpMP3bCqaCN8'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YHM46j4C5UJtnJFaW4kxGw/fKqMItDmtOQJJHgRnWPFZoWiNzcyh3ZA4f8YfzCA_Pw8VH-WuUimbE8EtU7rniTK-kZSc8_j5nLwl6-D4cI9Dw/d3ZvtW1XBgsk6-SbAhezCQqjZ0DgtKSleP1_wZRKgrU'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U-hY1Sy2d_2OHAR_2IFmeg/pzM0ALGEDOXV1Dc6iR6hSv-RKOkda5QWdCGKwOssrylOUa3LXbMGyo_LdusCw53TFwdtbLggMgBXRVdG7xJV9A/GLMlL87L8YChOOgVU1B6Rlif7NwNoQPHCvw_Vf96jTE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782438/Instruments/Temperature%20Controllers/ATS-525/ATS-525.jpg,ATS 525,Write a Python script that uses Pymeasure to connect to a ATS 525 Temperature Controllers,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ATS-515/615, ATS 525/625 & ATS 535/635 ThermoStream® Systems
Interface & Applications Manual
Revision E
September, 2019
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase
from pymeasure.instruments.instrument import Instrument


class ATS525(ATSBase):
    """"""Represent the TemptronicATS525 instruments.
    """"""

    temperature_limit_air_low_values = [-60, 25]

    system_current = Instrument.measurement(
        ""AMPS?"",
        """"""Operating current.
        """""",
    )

    def __init__(self, adapter, name=""Temptronic ATS-525 Thermostream"", **kwargs):
        super().__init__(adapter, name, **kwargs)
"
27,,,,110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,,,Buffer,251.0,['Miscellaneous'],Miscellaneous,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/buffer.py,Pymeasure,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/buffer.py,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,,Buffer,Write a Python script that uses Pymeasure to connect to a Buffer Miscellaneous,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from time import sleep, time

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range
from pymeasure.adapters import PrologixAdapter

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class KeithleyBuffer:
    """""" Implements the basic buffering capability found in
    many Keithley instruments. """"""

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[2, 1024],
        cast=int
    )

    def config_buffer(self, points=64, delay=0):
        """""" Configures the measurement buffer for a number of points, to be
        taken with a specified delay.

        :param points: The number of points in the buffer.
        :param delay: The delay time in seconds.
        """"""
        # Enable measurement status bit
        # Enable buffer full measurement bit
        self.write("":STAT:PRES;*CLS;*SRE 1;:STAT:MEAS:ENAB 512;"")
        self.write("":TRAC:CLEAR;"")
        self.buffer_points = points
        self.trigger_count = points
        self.trigger_delay = delay
        self.write("":TRAC:FEED SENSE;:TRAC:FEED:CONT NEXT;"")
        self.check_errors()

    def is_buffer_full(self):
        """""" Returns True if the buffer is full of measurements. """"""
        status_bit = int(self.ask(""*STB?""))
        return status_bit == 65

    def wait_for_buffer(self, should_stop=lambda: False,
                        timeout=60, interval=0.1):
        """""" Blocks the program, waiting for a full buffer. This function
        returns early if the :code:`should_stop` function returns True or
        the timeout is reached before the buffer is full.

        :param should_stop: A function that returns True when this function should return early
        :param timeout: A time in seconds after which this function should return early
        :param interval: A time in seconds for how often to check if the buffer is full
        """"""
        # TODO: Use SRQ initially instead of constant polling
        # self.adapter.wait_for_srq()
        t = time()
        while not self.is_buffer_full():
            sleep(interval)
            if should_stop():
                return
            if (time() - t) > timeout:
                raise Exception(""Timed out waiting for Keithley buffer to fill."")

    @property
    def buffer_data(self):
        """""" Returns a numpy array of values from the buffer. """"""
        self.write("":FORM:DATA ASCII"")
        return np.array(self.values("":TRAC:DATA?""), dtype=np.float64)

    def start_buffer(self):
        """""" Starts the buffer. """"""
        self.write("":INIT"")

    def reset_buffer(self):
        """""" Resets the buffer. """"""
        self.write("":STAT:PRES;*CLS;:TRAC:CLEAR;:TRAC:FEED:CONT NEXT;"")

    def stop_buffer(self):
        """""" Aborts the buffering measurement, by stopping the measurement
        arming and triggering sequence. If possible, a Selected Device
        Clear (SDC) is used. """"""
        if type(self.adapter) is PrologixAdapter:
            self.write(""++clr"")
        else:
            self.write("":ABOR"")

    def disable_buffer(self):
        """""" Disables the connection between measurements and the
        buffer, but does not abort the measurement process.
        """"""
        self.write("":TRAC:FEED:CONT NEV"")
"
31,https://www.intestthermal.com/temptronic/brochure-request?brochure_title=ATS-605%20THERMOSTREAM%C2%AE%20DATASHEET%20AND%20SPECIFICATIONS&brand_interest=Temptronic&brand_sub_folder=temptronic&file_name=TemperatureForcing_ATS605.pdf&product=ThermoStream&hsLang=en,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.","[OrderedDict([('id', 'attyo4eqCkUStqLEV'), ('width', 250), ('height', 537), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/E5W6GixWQhBtlLvehlDMcA/3DEBiepLeyfBkWiSQBEiXxEdXzdIhE50yEVLt0Ol9Rzse9eg8lSWDIAnLhyUr1Plc3X5nyXaur_CVA2qjfooZmNLDp27grX8LdjdwWSPD3AxqPzfFJr_X7hDjO84O6IY/3IpR0k6vuoA5Z3F5fJ7NWUBOzK1G3_YKfvkCQNf-L_4'), ('filename', 'ThermoStream-ATS-710-250.webp'), ('size', 11590), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/v-CZCCRdbKjpv6LUgXIQpg/OLu8t558bIBm-BZ0m_qfvMl_-wqrooicpMlrAsmZhsSuHClInDb2ZjvOE26s2oBd3GDogl4P7beiPdbNx7J_UKU68XW1vF3VYOAhSHJwD20/UCgqPgF9JMlIYcirpbENWSa_IYh4HXeiPRE1tMAXo2c'), ('width', 17), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/v2hN6LDhT83ouizFz-G95A/GKCxiMpIJtpoOW5sXXPi3ODoQ96uknOeUOcZWPafBEtOw7KczgKa62GI1RyM2iuj0qRXS0LIYlwo3nHeT6O0kJai6mgl2mnRky3poJCdMVM/66rINE62L-_aJw-zwOruqcHCPlnePKRpN3xDTQ5HlJI'), ('width', 250), ('height', 537)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HDpbtBCyg3bZTp0_vNOLyw/xxrgZXev_c9LUFaySWGZzzlkuZFBHL36ye2gxkO76HEF1WBzW2uzNDJ5Ciw97SMoA6KTxq0ba0G85hd5iEUy80YRUV7hf0lNJeYg7Rs9-Qs/cW2mZM2Fu4PdCYwFYRm5K-WI2A7JGByH8VqjBrBS5Xk'), ('width', 3000), ('height', 3000)]))]))])]",19.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125985/Instruments/Vendor%20Logos/Temptronic.png,"Temptronic ThermoStreams are portable systems that deliver clean dry air for precision temperature testing or conditioning of electronics (ICs, MEMS, transceivers, or circuits) and materials. No other systems can bring your test subjects to temperature faster with precise control",https://www.intestthermal.com/temptronic/thermostream,Ats_base,586.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_base.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_base.html,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XkJOd2Fwd9vcwCxlWHYuVQ/Mj4zcFto3BrPOFLOgDiJd0bpi2u3YU2gCJWyUK3OqmTSUMrQ3zJmguf6SjcB-3KXYD8TAEHYL4zaFUeLJFcBoggEqNz3w2DZsgNzGWOK-GPmzprqI71Kb-SSJoeT1OzR/3bmPScz9e0R01o5_F4ME4BwK3P4G8DsmouH8CdiESg0'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lgs8naZZFDDY_xgAouIDeA/1nfEKPkT-AFUq5MmcJ2mRR9XvszzohqDjknqySo9xmsgWJlaCBqO3LGEnL_81Cjk8cXTdCEo_sfkYiyl2E91og/9RRq8Xvxs0cMV-sW6njjL5o0u7Z-BsAdpMP3bCqaCN8'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YHM46j4C5UJtnJFaW4kxGw/fKqMItDmtOQJJHgRnWPFZoWiNzcyh3ZA4f8YfzCA_Pw8VH-WuUimbE8EtU7rniTK-kZSc8_j5nLwl6-D4cI9Dw/d3ZvtW1XBgsk6-SbAhezCQqjZ0DgtKSleP1_wZRKgrU'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U-hY1Sy2d_2OHAR_2IFmeg/pzM0ALGEDOXV1Dc6iR6hSv-RKOkda5QWdCGKwOssrylOUa3LXbMGyo_LdusCw53TFwdtbLggMgBXRVdG7xJV9A/GLMlL87L8YChOOgVU1B6Rlif7NwNoQPHCvw_Vf96jTE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782446/Instruments/Temperature%20Controllers/Thermostream-ATS-Series/Thermostream-ATS-Series.webp,Thermostream ATS Series,Write a Python script that uses Pymeasure to connect to a Thermostream ATS Series Temperature Controllers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""Implementation of an interface driver for ThermoStream® (TS) Systems devices.

# Reference Document for implementation:
ATS-515/615, ATS 525/625 & ATS 535/635 ThermoStream® Systems
Interface & Applications Manual
Revision E
September, 2019

# Safety hints
In case of script error, make sure thermostream will be shut down.
This can be established by e.g. means of try, finally statements.
Another way is by polling ``error_code`` integer status flags.
No automatic safety measures are part of this driver implementation.

""""""
import logging
import time
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              truncated_range,
                                              strict_range
                                              )

from enum import IntFlag

log = logging.getLogger(__name__)  # https://docs.python.org/3/howto/logging.html#library-config
log.addHandler(logging.NullHandler())


class TemperatureStatusCode(IntFlag):
    """"""Temperature status enums based on ``IntFlag``

    Used in conjunction with :attr:`~.temperature_condition_status_code`.

        ======  ======
        Value   Enum
        ======  ======
        32      CYCLING_STOPPED
        16      END_OF_ALL_CYCLES
        8       END_OF_ONE_CYCLE
        4       END_OF_TEST
        2       NOT_AT_TEMPERATURE
        1       AT_TEMPERATURE
        0       NO_STATUS
        ======  ======

    """"""

    CYCLING_STOPPED = 32  # bit 5 -- cycling stopped(""stop on fail"" signal was received)
    END_OF_ALL_CYCLES = 16  # bit 4 -- end of all cycles
    END_OF_ONE_CYCLE = 8   # bit 3 -- end of one cycle
    END_OF_TEST = 4   # bit 2 -- end of test (test time has elapsed)
    NOT_AT_TEMPERATURE = 2   # bit 1 -- not at temperature
    AT_TEMPERATURE = 1   # bit 0 -- at temperature (soak time has elapsed)
    NO_STATUS = 0   # bit 0 -- no temperature status indication


class ErrorCode(IntFlag):
    """"""Error code enums based on ``IntFlag``.

    Used in conjunction with :attr:`~.error_code`.

        ======  ======
        Value   Enum
        ======  ======
        16384   NO_DUT_SENSOR_SELECTED
        4096    BVRAM_FAULT
        2048    NVRAM_FAULT
        1024    NO_LINE_SENSE
        512     FLOW_SENSOR_HARDWARE_ERROR
        128     INTERNAL_ERROR
        32      AIR_SENSOR_OPEN
        16      LOW_INPUT_AIR_PRESSURE
        8       LOW_FLOW
        2       AIR_OPEN_LOOP
        1       OVERHEAT
        0       OK
        ======  ======

    """"""
    # bit 15 – reserved
    NO_DUT_SENSOR_SELECTED = 16384  # bit 14 – no DUT sensor selected
    # bit 13 – reserved
    BVRAM_FAULT = 4096   # bit 12 – BVRAM fault
    NVRAM_FAULT = 2048   # bit 11 – NVRAM fault
    NO_LINE_SENSE = 1024   # bit 10 – No Line Sense
    FLOW_SENSOR_HARDWARE_ERROR = 512    # bit 9  – flow sensor hardware error
    # bit 8  – reserved
    INTERNAL_ERROR = 128    # bit 7  – internal error
    # bit 6  – reserved
    AIR_SENSOR_OPEN = 32     # bit 5  – air sensor open
    LOW_INPUT_AIR_PRESSURE = 16     # bit 4  – low input air pressure
    LOW_FLOW = 8      # bit 3  – low flow
    # bit 2  – reserved
    AIR_OPEN_LOOP = 2      # bit 1  – air open loop
    OVERHEAT = 1      # bit 0  – overheat
    OK = 0  # ok state


class ATSBase(Instrument):
    """"""The base class for Temptronic ATSXXX instruments.
    """"""

    remote_mode = Instrument.setting(
        ""%s"",
        """"""``True`` disables TS GUI but displays a “Return to local"" switch."""""",
        validator=strict_discrete_set,
        values={True: ""%RM"", False: r""%GL""},
        map_values=True
    )

    maximum_test_time = Instrument.control(
        ""TTIM?"", ""TTIM %g"",
        """"""Control maximum allowed test time (s).

        :type: float

        This prevents TS from staying at a single temperature forever.
        Valid range: 0 to 9999
        """""",
        validator=truncated_range,
        values=[0, 9999]
    )

    dut_mode = Instrument.control(
        ""DUTM?"", ""DUTM %g"",
        """""" ``On`` enables DUT mode, ``OFF`` enables air mode

        :type: string

        """""",
        validator=strict_discrete_set,
        values={'ON': 1, 'OFF': 0},
        map_values=True
    )

    dut_type = Instrument.control(
        ""DSNS?"", ""DSNS %g"",
        """"""Control DUT sensor type.

        :type: string

        Possible values are:

        ======  ======
        String  Meaning
        ======  ======
        ''      no DUT
        'T'     T-DUT
        'K'     K-DUT
        ======  ======

        Warning: If in DUT mode without DUT being connected, TS flags DUT error

        """""",
        validator=strict_discrete_set,
        values={None: 0, 'T': 1, 'K': 2},
        map_values=True
    )

    dut_constant = Instrument.control(
        ""DUTC?"", ""DUTC %g"",
        """"""Control thermal constant (default 100) of DUT.

        :type: float

        Lower values indicate lower thermal mass, higher values indicate higher
        thermal mass respectively.
        """""",
        validator=truncated_range,
        values=[20, 500]
    )

    head = Instrument.control(
        ""HEAD?"", ""HEAD %s"",
        """"""Control TS head position.

        :type: string

        ``down``: transfer head to lower position
        ``up``:   transfer head to elevated position
        """""",
        validator=strict_discrete_set,
        values={'up': 0, 'down': 1},
        map_values=True
    )

    enable_air_flow = Instrument.setting(
        ""FLOW %g"",
        """"""Set TS air flow.

        ``True`` enables air flow, ``False`` disables it

        :type: bool

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    temperature_limit_air_low = Instrument.control(
        ""LLIM?"", ""LLIM %g"",
        """"""Control lower air temperature limit.

        :type: float

        Valid range between -99 to 25 (°C). Setpoints below current value cause
        “out of range” error in TS.
        """""",
        validator=truncated_range,
        values=[-99, 25],
        dynamic=True
    )

    temperature_limit_air_high = Instrument.control(
        ""ULIM?"", ""ULIM %g"",
        """"""upper air temperature limit.

        :type: float

        Valid range between 25 to 255 (°C). Setpoints above current value cause
        “out of range” error in TS.
        """""",
        validator=truncated_range,
        values=[25, 225]
    )

    temperature_limit_air_dut = Instrument.control(
        ""ADMD?"", ""ADMD %g"",
        """"""Air to DUT temperature limit.

        :type: float

        Allowed difference between nozzle air and DUT temperature during
        settling. Valid range between 10 to 300 °C in 1 degree increments.
        """""",
        validator=truncated_range,
        values=[10, 300]
    )

    temperature_setpoint = Instrument.control(
        ""SETP?"", ""SETP %g"",
        """"""Set or get selected setpoint's temperature.

        :type: float

        Valid range is -99.9 to 225.0 (°C) or as indicated by
        :attr:`~.temperature_limit_air_high`
        and :attr:`~.temperature_limit_air_low`.
        Use convenience function :meth:`~ATSBase.set_temperature`
        to prevent unexpected behavior.
        """""",
        validator=truncated_range,
        values=[-99.9, 225]
    )

    temperature_setpoint_window = Instrument.control(
        ""WNDW?"", ""WNDW %g"",
        """"""Setpoint's temperature window.

        :type: float

        Valid range is between 0.1 to 9.9 (°C). Temperature status register
        flags ``at temperature`` in case soak time elapsed while temperature
        stays in between bounds given by this value around the current setpoint.
        """""",
        validator=truncated_range,
        values=[0.1, 9.9]
    )

    temperature_soak_time = Instrument.control(
        ""SOAK?"", ""SOAK %g"",
        """"""
        Set the soak time for the currently selected setpoint.

        :type: float

        Valid range is between  0 to 9999 (s). Lower values shorten cycle times.
        Higher values increase cycle times, but may reduce settling errors.
        See :attr:`~.temperature_setpoint_window` for further information.
        """""",
        validator=truncated_range,
        values=[0.0, 9999]
    )

    temperature = Instrument.measurement(
        ""TEMP?"",
        """"""Read current temperature with 0.1 °C resolution.

        :type: float

        Temperature readings origin depends on :attr:`dut_mode` setting.
        Reading higher than 400 (°C) indicates invalidity.
        """"""
    )

    temperature_condition_status_code = Instrument.measurement(
        ""TECR?"",
        """"""Temperature condition status register.

        :type: :class:`.TemperatureStatusCode`
        """""",
        values=[0, 255],
        get_process=lambda v: TemperatureStatusCode(int(v)),
    )

    set_point_number = Instrument.control(
        ""SETN?"", ""SETN %g"",
        """"""Select a setpoint to be the current setpoint.

        :type: int

        Valid range is 0 to 17 when on the Cycle screen or
        or 0 to 2 in case of operator screen (0=hot, 1=ambient, 2=cold).
        """""",
        validator=truncated_range,
        values=[0, 17]
    )

    local_lockout = Instrument.setting(
        ""%s"",
        """"""``True`` disables TS GUI, ``False`` enables it.
        """""",
        validator=strict_discrete_set,
        values={True: r""%LL"", False: r""%GL""},
        map_values=True
    )

    auxiliary_condition_code = Instrument.measurement(
        ""AUXC?"",
        """"""Read out auxiliary condition status register.

        :type: int

        Relevant flags are:

        ======  ======
        Bit     Meaning
        ======  ======
        10      None
         9      Ramp mode
         8      Mode: 0 programming, 1 manual
         7      None
         6      TS status: 0 start-up, 1 ready
         5      Flow: 0 off, 1 on
         4      Sense mode: 0 air, 1 DUT
         3      Compressor: 0 on, 1 off (heating possible)
         2      Head: 0 lower, upper
         1      None
         0      None
        ======  ======

        Refere to chapter 4 in the manual

        """""",
    )

    copy_active_setup_file = Instrument.setting(
        ""CFIL %g"",
        """"""Copy active setup file (0) to setup n (1 - 12).

        :type: int
        """""",
        validator=strict_range,
        values=[1, 12]
    )

    compressor_enable = Instrument.setting(
        ""COOL %g"",
        """""" ``True`` enables compressors, ``False`` disables it.

        :type: Boolean

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    total_cycle_count = Instrument.control(
        ""CYCC?"", ""CYCC %g"",
        """"""Set or read current cycle count (1 - 9999).

        :type: int

        Sending 0 will stop cycling

        """""",
        validator=truncated_range,
        values=[0, 9999]
    )

    cycling_enable = Instrument.setting(
        ""CYCL %g"",
        """"""CYCL Start/stop cycling.

        :type: bool

        cycling_enable = True  (start cycling)
        cycling_enable = False (stop cycling)
        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    current_cycle_count = Instrument.measurement(
        ""CYCL?"",
        """"""Read the number of cycles to do

        :type: int

        """""",
    )

    error_code = Instrument.measurement(
        ""EROR?"",  # it is indeed EROR
        """"""Read the device-specific error register (16 bits).

        :type: :class:`ErrorCode`
        """""",
        get_process=lambda v: ErrorCode(int(v)),
    )

    nozzle_air_flow_rate = Instrument.measurement(
        ""FLWR?"",
        """"""Read main nozzle air flow rate in scfm.
        """"""
    )

    main_air_flow_rate = Instrument.measurement(
        ""FLRL?"",
        """"""Read main nozzle air flow rate in liters/sec.
        """"""
    )

    learn_mode = Instrument.control(
        ""LRNM?"", ""LRNM %g"",
        """"""Control DUT automatic tuning (learning).

        :type: bool
            ``False``: off
            ``True``:  automatic tuning on

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    ramp_rate = Instrument.control(
        ""RAMP?"", ""RAMP %g"",
        """"""Control ramp rate (K / min).

        :type: float

        allowed values:
        nn.n: 0 to 99.9 in 0.1 K per minute steps.
        nnnn: 100 to 9999 in 1 K per minute steps.
        """""",
        validator=strict_discrete_set,
        values={i/10 for i in range(1000)} | {i for i in range(100, 10000)}
    )

    dynamic_temperature_setpoint = Instrument.measurement(
        ""SETD?"",
        """"""Read the dynamic temperature setpoint.

        :type: float
        """"""
    )

    load_setup_file = Instrument.setting(
        ""SFIL %g"",
        """"""loads setup file SFIL.

        Valid range is between 1 to 12.

        :type: int
        """""",
        validator=strict_range,
        values=[1, 12]
    )

    temperature_event_status = Instrument.measurement(
        ""TESR?"",
        """""" temperature event status register.

        :type: :class:`.TemperatureStatusCode`

        Hint: Reading will clear register content.

        """""",
    )

    air_temperature = Instrument.measurement(
        ""TMPA?"",
        """"""Read air temperature in 0.1 °C increments.

        :type: float
        """"""
    )

    dut_temperature = Instrument.measurement(
        ""TMPD?"",
        """"""Read DUT temperature, in 0.1 °C increments.

        :type: float

        """"""
    )

    mode = Instrument.measurement(
        ""WHAT?"",
        """"""Returns a string indicating what the system is doing at the time the query is processed.

        :type: string

        """""",
        values={'manual': 5,
                'program': 6,
                },
        map_values=True,
        dynamic=True
    )

    def __init__(self, adapter, name=""ATSBase"", **kwargs):
        super().__init__(adapter, name=name, query_delay=0.05, **kwargs)

    def reset(self):
        """"""Reset (force) the System to the Operator screen.

        :returns: self

        """"""
        self.write(""RSTO"")

        return self

    def enter_cycle(self):
        """"""Enter Cycle by sending ``RMPC 1``.

        :returns: self

        """"""
        self.write(""RMPC 1"")

        return self

    def enter_ramp(self):
        """"""Enter Ramp by sending ``RMPS 0``.

        :returns: self
        """"""
        self.write(""RMPS 0"")

        return self

    def clear(self):
        """"""Clear device-specific errors.

        See :attr:`~.error_code` for further information.
        """"""
        self.write(""CLER"")

        return self

    def next_setpoint(self):
        """"""Step to the next setpoint during temperature cycling.
        """"""
        self.write(""NEXT"")

    def configure(self,
                  temp_window=1,
                  dut_type='T',
                  soak_time=30,
                  dut_constant=100,
                  temp_limit_air_low=-60,
                  temp_limit_air_high=220,
                  temp_limit_air_dut=50,
                  maximum_test_time=1000
                  ):
        """"""Convenience method for most relevant configuration properties.

        :param dut_type:
            string: indicating which DUT type to use
        :param soak_time:
            float: elapsed time in soak_window before settling is indicated
        :param soak_window:
            float: Soak window size or temperature settlings bounds (K)
        :param dut_constant:
            float: time constant of DUT, higher values indicate higher thermal mass
        :param temp_limit_air_low:
            float: minimum flow temperature limit (°C)
        :param temp_limit_air_high:
            float: maximum flow temperature limit (°C)
        :param temp_limit_air_dut:
            float: allowed temperature difference (K) between DUT and Flow
        :param maximum_test_time:
            float: maximum test time (seconds) for a single temperature point (safety)

        :returns: self
        """"""

        self.temperature_setpoint_window = temp_window

        self.temperature_limit_air_low = temp_limit_air_low

        self.temperature_limit_air_high = temp_limit_air_high

        self.dut_type = dut_type

        self.maximum_test_time = maximum_test_time

        if dut_type is None:
            self.dut_mode = 'OFF'
        else:
            self.dut_constant = dut_constant
            self.dut_mode = 'ON'

        self.temperature_limit_air_dut = temp_limit_air_dut

        self.temperature_soak_time = soak_time

        # logging:

        wd = self.temperature_setpoint_window

        airflwlimlow = self.temperature_limit_air_low

        airflwlimhigh = self.temperature_limit_air_high

        dut = self.dut_type

        tst_time = self.maximum_test_time

        airdutlim = self.temperature_limit_air_dut

        sktime = self.temperature_soak_time

        message = (
            ""Configuring TS finished, reading back:\n""
            f""DUT type: {dut}\n""
            f""Temperature Window: {wd} K\n""
            f""Maximum test time: {tst_time} s\n""
            f""Air flow temperature limit low: {airflwlimlow:.1f} K\n""
            f""Air flow temperature limit high: {airflwlimhigh:.1f} K\n""
            f""Air to DUT temperature limit: {airdutlim} degC\n""
            f""Soak time {sktime} s\n""
        )

        log.info(message)

        return self

    def set_temperature(self, set_temp):
        """"""sweep to a specified setpoint.

        :param set_temp:
            target temperature for DUT (float)

        :returns: self
        """"""
        if self.mode == 'manual':
            message = f""new set point temperature: {set_temp:.1f} Deg""
            log.info(message)

            if set_temp <= 20:
                self.set_point_number = 2  # cold
            elif set_temp < 30:
                self.set_point_number = 1  # ambient
            elif set_temp >= 30:
                self.set_point_number = 0  # hot
            else:
                raise ValueError(f""Temperature {set_temp} is impossible to set!"")

        self.temperature_setpoint = set_temp  # fixed typo in attr name

        return self

    def wait_for_settling(self, time_limit=300):
        """"""block script execution until TS is settled.

        :param time_limit:
            set the maximum blocking time within TS has to settle (float).

        :returns: self

        Script execution is blocked until either TS has settled
        or time_limit has been exceeded (float).
        """"""

        time.sleep(1)
        t = 0
        t_start = time.time()
        while not self.at_temperature():  # assert at temperature
            time.sleep(1)
            t = time.time() - t_start

            tstatus = self.temperature_condition_status_code

            message = (""temp_set= %4.1f deg, ""
                       ""temp= %4.1f deg, ""
                       ""time= %.2f s, ""
                       ""status= %s""
                       )

            log.info(message,
                     self.temperature_setpoint,
                     self.temperature,
                     t,
                     tstatus)

            if t > time_limit:
                log.info('no settling achieved')
                break
        log.info('finished this temperature point')

        return self

    def shutdown(self, head=False):
        """"""Turn down TS (flow and remote operation).

        :param head: Lift head if ``True``

        :returns: self
        """"""

        self.enable_air_flow = 0
        self.remote_mode = False
        if head:
            self.head = 'up'
        super().shutdown()

        return self

    def start(self, enable_air_flow=True):
        """"""start TS in remote mode.

        :param enable_air_flow: flow starts if ``True``

        :returns: self
        """"""

        self.remote_mode = 1
        self.enable_air_flow = enable_air_flow  # enable TS

        return self

    def error_status(self):
        """"""Returns error status code (maybe used for logging).

        :returns: :class:`ErrorCode`
        """"""
        code = self.error_code
        if not code == 0:
            log.warning('%s', code)
        return code

    def cycling_stopped(self):
        """""":returns: ``True`` if cycling has stopped.
        """"""
        return TemperatureStatusCode.CYCLING_STOPPED in self.temperature_condition_status_code

    def end_of_all_cycles(self):
        """""":returns: ``True`` if cycling has stopped.
        """"""
        return TemperatureStatusCode.END_OF_ALL_CYCLES in self.temperature_condition_status_code

    def end_of_one_cycle(self):
        """""":returns: ``True`` if TS is at end of one cycle.
        """"""
        return TemperatureStatusCode.END_OF_ONE_CYCLE in self.temperature_condition_status_code

    def end_of_test(self):
        """""":returns: ``True`` if TS is at end of test.
        """"""
        return TemperatureStatusCode.END_OF_TEST in self.temperature_condition_status_code

    def not_at_temperature(self):
        """""":returns: ``True`` if not at temperature.
        """"""
        return TemperatureStatusCode.NOT_AT_TEMPERATURE in self.temperature_condition_status_code

    def at_temperature(self):
        """""":returns: ``True`` if at temperature.
        """"""
        return TemperatureStatusCode.AT_TEMPERATURE in self.temperature_condition_status_code
"
32,https://www.keysight.com/us/en/assets/9018-03334/technical-specifications/9018-03334.pdf,https://www.keysight.com/us/en/products/spectrum-analyzers-signal-analyzers.html,"[OrderedDict([('id', 'attOfX0N01dkZoP6V'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hGg0cm7tXaKSLnAiGnAVNg/ydJe5mfnpphNuFBUMdojReTVQ8S4QeisoxG2TXV87j4GBKZOonJ280hw5SDNGOfHOSzaBsIvC4PngNGacS8fBlVJfGTYpzS6918MHcJsqv8/5kSbg7EOECA7wR-77B2cU3LvJUqsTIherwjKonY4q1E'), ('filename', 'E4408B.webp'), ('size', 15404), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6h9uhOXzXB34l_o8q2r_Jw/2SeGg40Yoo1X07LR5WkqosJy2AEkUJYxzeruKeYzOKGc1i8mGWIx_06y3NhXAVfKcCJ0hJ6uNCPCJqBaDpfgEW_590FN6esSz3JmqjRoJDI/GMu9umRWPtFFUcS2q_9B1TqGDPaicgf_94GFghZk0RI'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3WhrFEmWfecOw2syp9Lz7g/5_wahduw7HELV9JyYOfoXbOEYVmggiWdZ5BAEKvkL90Uzt0FGFjQuiM4SO5pDKbAJpsWEdR25fcieAjS1caKW7wB-y0voqS337QrxfV57qA/rFcO08YudnZMJpCxO5SazfggQObfjFgcZ2HsCJpQ8Tk'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5HvUP26YxG__4yPF730kMg/OWmA5unRf94y3oyzqRfddCYnUJ0OvAJAhzYvlK4PmDXaBs4KdyzTrgDUIaT9iomgbWtJEuGiLZqjJ_CwwaILOD1581DPPAIAc-qHtGln7_s/PuyDfEIyFywBrBIWV2WZ1Be_Gx51G7I3PFj3xhO6nLY'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,"E4408B ESA-L Basic Spectrum Analyzer, 9 kHz to 26.5 GHz",https://www.keysight.com/us/en/product/E4408B/esa-l-basic-spectrum-analyzer-9khz-26-5ghz.html,Agilent 4408 B,5.0,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals.,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilentE4408B.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentE4408B.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782447/Instruments/Spectrum%20Analyzers/Keysight-E4408B-ESA-L/Keysight-E4408B-ESA-L.webp,Keysight E4408B ESA-L,Write a Python script that uses Pymeasure to connect to a Keysight E4408B ESA-L Spectrum Analyzers,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

from io import StringIO
import numpy as np
import pandas as pd


class AgilentE4408B(Instrument):
    """""" Represents the AgilentE4408B Spectrum Analyzer
    and provides a high-level interface for taking scans of
    high-frequency spectrums
    """"""

    start_frequency = Instrument.control(
        "":SENS:FREQ:STAR?;"", "":SENS:FREQ:STAR %e Hz;"",
        """""" A floating point property that represents the start frequency
        in Hz. This property can be set.
        """"""
    )
    stop_frequency = Instrument.control(
        "":SENS:FREQ:STOP?;"", "":SENS:FREQ:STOP %e Hz;"",
        """""" A floating point property that represents the stop frequency
        in Hz. This property can be set.
        """"""
    )
    frequency_points = Instrument.control(
        "":SENSe:SWEEp:POINts?;"", "":SENSe:SWEEp:POINts %d;"",
        """""" An integer property that represents the number of frequency
        points in the sweep. This property can take values from 101 to 8192.
        """""",
        validator=truncated_range,
        values=[101, 8192],
        cast=int
    )
    frequency_step = Instrument.control(
        "":SENS:FREQ:CENT:STEP:INCR?;"", "":SENS:FREQ:CENT:STEP:INCR %g Hz;"",
        """""" A floating point property that represents the frequency step
        in Hz. This property can be set.
        """"""
    )
    center_frequency = Instrument.control(
        "":SENS:FREQ:CENT?;"", "":SENS:FREQ:CENT %e Hz;"",
        """""" A floating point property that represents the center frequency
        in Hz. This property can be set.
        """"""
    )
    sweep_time = Instrument.control(
        "":SENS:SWE:TIME?;"", "":SENS:SWE:TIME %.2e;"",
        """""" A floating point property that represents the sweep time
        in seconds. This property can be set.
        """"""
    )

    def __init__(self, adapter, name=""Agilent E4408B Spectrum Analyzer"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    @property
    def frequencies(self):
        """""" Returns a numpy array of frequencies in Hz that
        correspond to the current settings of the instrument.
        """"""
        return np.linspace(
            self.start_frequency,
            self.stop_frequency,
            self.frequency_points,
            dtype=np.float64
        )

    def trace(self, number=1):
        """""" Returns a numpy array of the data for a particular trace
        based on the trace number (1, 2, or 3).
        """"""
        self.write("":FORMat:TRACe:DATA ASCII;"")
        data = np.loadtxt(
            StringIO(self.ask("":TRACE:DATA? TRACE%d;"" % number)),
            delimiter=',',
            dtype=np.float64
        )
        return data

    def trace_df(self, number=1):
        """""" Returns a pandas DataFrame containing the frequency
        and peak data for a particular trace, based on the
        trace number (1, 2, or 3).
        """"""
        return pd.DataFrame({
            'Frequency (GHz)': self.frequencies * 1e-9,
            'Peak (dB)': self.trace(number)
        })
"
38,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ITC503.pdf,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attrty3FFFzJUtuMr'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qibwwm-B2RWplylc8T92Qg/8ErRMqyjrOd3oAmUDMqlLZsWz22souca8pYc4AZh1dl6tqlh_uUjlc_MU7xdsmYUQQL2rF_aBc9G-G-z3I3CUUoTjiPq5nqNwhsktlSuw5Q/hSQMn_2HAcNrGwCd5P4UYcJoZxMlVTI_h180yinqeM0'), ('filename', 's-l1600.jpg'), ('size', 266225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iFPmSkvVVxcr6n-ejdM37w/YrUCvZsFARH6Ks8MZpCTXebMX13A3_t2ku-zXcku-d-5mI5IIfpZ2X6e5dW7ooL9FTPHtDIKJeBWpQuijPBKKA/tJlBeeSTFy-2_tlrAywMF65-Rn95yJm72JQwdrO9ROc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/4j5DHeCC4vFQjkwaczldGA/YZ-bvD6MPwy3FqpMwuquavAiYgo0DRsXX8-iTD0Ee7MSGsvrXXxtWxEi5oB43kKfTj4l6ePW85bwynK5L9eUeA/YowZpkBSsw_FdZjeHKBs8xe30odL6o4OQohhRV_ZyFQ'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xD6za_XoziL5NdA3-5kkLQ/l3CdAUIEgQ8u-hrCZ4F133jliu_UMcifvot8dJGorYGDx7AT0OQC4op3h5tlkR2Yl1kG4gSNxhJlbDYXbKh3Vg/B0z7dsuSmtGp00HENs28V9KbD8-ikHO_cB4aRZQFPFQ'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125988/Instruments/Vendor%20Logos/Oxford_Instruments.png,"Oxford Intelligent Temperature Controller ITC 502. Oxford Instruments ITC502 Intelligent Temperature Controller (Model 611-968) is a three term controller. It has the capability of monitoring up to three thermometers at the same time, and supplying heat to control the temperature of one part of the cryostat. The sensor interface can be configured to suit a wide range of thermometers (typically within the temperature range of 0.25 to 500 K).",https://picclick.com/Oxford-Intelligent-Temperature-Controller-ITC-502-132299188022.html,ITC 503,404.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/oxfordinstruments/itc503.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/oxfordinstruments/ITC503.html,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TmODz0hi9OJUWi8T_d03Sg/Z2IpZm1otBFaV4dd1Z-YtqnyJyVrn1XmjrAJ-f5S_iVw7bPjL7yB9-iP7oED2Apt8U7BWIgETKyocFr_7AB4ANlqGjCMDVi0jOaDoDmBEeY/fb6Rw-KSmBuKxPZBvzrwQHM2Od5u72NtOxyRcoYmp1k'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wLs8zjCAwM09gWDMI3xu8Q/oeHC2OPJ20vnWtvfKmZUu5tq6Qs8soCa05gu5GwUon7E_fXVQPnVlYkLXr8b89l5PSrYNLwdT0-CaM0qfQxfkQ/-ax23cOalgUh6YtKYQnXV1PHde7iBMdvwmUkMoLyC4g'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jgZc4LIcvZHeQFduBTSAqA/Ekyj1R3Uue0-wDCxuF4HJMJgjIi6LufK6pQen9vYQvrGtTJ02DFBb9vf_SftJYHGiiKwYcBl1y0ZxBQRsYc_9g/zsDCrHyIVVMco4QM3Ug2jLafjuWb_kNyFMD1jMv7l3E'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PhngqIRF78CMgJpGxBi3aA/Q4c_1vbgbHc9v_mECxRUCccMTG-Ca72dEMwKqczOB_oBg3yhQVaWSPj9-Cyp88i9XS_-NvyHrb6FmV0sZXsnhg/yJDJjhkTUYCH-6uR2EfIACKa09g3qImdFcMG16-hnng'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782452/Instruments/Temperature%20Controllers/ITC-503/ITC-503.jpg,ITC 503,Write a Python script that uses Pymeasure to connect to a ITC 503 Temperature Controllers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging
from time import sleep, time
import numpy
from enum import IntFlag

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_range, strict_range

from .base import OxfordInstrumentsBase


# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def pointer_validator(value, values):
    """""" Provides a validator function that ensures the passed value is
    a tuple or a list with a length of 2 and passes every item through
    the strict_range validator.

    :param value: A value to test
    :param values: A range of values (passed to strict_range)
    :raises: TypeError if the value is not a tuple or a list
    :raises: IndexError if the value is not of length 2
    """"""

    if not isinstance(value, (list, tuple)):
        raise TypeError('{:g} is not a list or tuple'.format(value))
    if not len(value) == 2:
        raise IndexError('{:g} is not of length 2'.format(value))
    return tuple(strict_range(v, values) for v in value)


class ITC503(OxfordInstrumentsBase):
    """"""Represents the Oxford Intelligent Temperature Controller 503.

    .. code-block:: python

        itc = ITC503(""GPIB::24"")        # Default channel for the ITC503

        itc.control_mode = ""RU""         # Set the control mode to remote
        itc.heater_gas_mode = ""AUTO""    # Turn on auto heater and flow
        itc.auto_pid = True             # Turn on auto-pid

        print(itc.temperature_setpoint) # Print the current set-point
        itc.temperature_setpoint = 300  # Change the set-point to 300 K
        itc.wait_for_temperature()      # Wait for the temperature to stabilize
        print(itc.temperature_1)        # Print the temperature at sensor 1

    """"""

    def __init__(self,
                 adapter,
                 name=""Oxford ITC503"",
                 clear_buffer=True,
                 min_temperature=0,
                 max_temperature=1677.7,
                 **kwargs):

        super().__init__(
            adapter=adapter,
            name=name,
            **kwargs,
        )

        # Clear the buffer in order to prevent communication problems
        if clear_buffer:
            self.adapter.connection.clear()

        self.temperature_setpoint_values = [min_temperature, max_temperature]

    class FLOW_CONTROL_STATUS(IntFlag):
        """""" IntFlag class for decoding the flow control status. Contains the following
        flags:

        === ======================  ==============================================
        bit flag                    meaning
        === ======================  ==============================================
        4   HEATER_ERROR_SIGN       Sign of heater-error; True means negative
        3   TEMPERATURE_ERROR_SIGN  Sign of temperature-error; True means negative
        2   SLOW_VALVE_ACTION       Slow valve action occurring
        1   COOLDOWN_TERMINATION    Cooldown-termination occurring
        0   FAST_COOLDOWN           Fast-cooldown occurring
        === ======================  ==============================================

        """"""
        HEATER_ERROR_SIGN = 16
        TEMPERATURE_ERROR_SIGN = 8
        SLOW_VALVE_ACTION = 4
        COOLDOWN_TERMINATION = 2
        FAST_COOLDOWN = 1

    version = Instrument.measurement(
        ""V"",
        """""" A string property that returns the version of the IPS. """""",
        preprocess_reply=lambda v: v,
    )

    control_mode = Instrument.control(
        ""X"", ""C%d"",
        """""" A string property that sets the ITC in `local` or `remote` and `locked`
        or `unlocked`, locking the LOC/REM button. Allowed values are:

        =====   =================
        value   state
        =====   =================
        LL      local & locked
        RL      remote & locked
        LU      local & unlocked
        RU      remote & unlocked
        =====   =================
        """""",
        preprocess_reply=lambda v: v[5:6],
        cast=int,
        validator=strict_discrete_set,
        values={""LL"": 0, ""RL"": 1, ""LU"": 2, ""RU"": 3},
        map_values=True,
    )

    heater_gas_mode = Instrument.control(
        ""X"", ""A%d"",
        """""" A string property that sets the heater and gas flow control to
        `auto` or `manual`. Allowed values are:

        ======   =======================
        value    state
        ======   =======================
        MANUAL   heater & gas manual
        AM       heater auto, gas manual
        MA       heater manual, gas auto
        AUTO     heater & gas auto
        ======   =======================
        """""",
        preprocess_reply=lambda v: v[3:4],
        cast=int,
        validator=strict_discrete_set,
        values={""MANUAL"": 0, ""AM"": 1, ""MA"": 2, ""AUTO"": 3},
        map_values=True,
    )

    heater = Instrument.control(
        ""R5"", ""O%f"",
        """""" A floating point property that represents the heater output power
        as a percentage of the maximum voltage. Can be set if the heater is in
        manual mode. Valid values are in range 0 [off] to 99.9 [%]. """""",
        validator=truncated_range,
        values=[0, 99.9]
    )

    heater_voltage = Instrument.measurement(
        ""R6"",
        """""" A floating point property that represents the heater output power
        in volts. For controlling the heater, use the :class:`ITC503.heater`
        property. """""",
    )

    gasflow = Instrument.control(
        ""R7"", ""G%f"",
        """""" A floating point property that controls gas flow when in manual
        mode. The value is expressed as a percentage of the maximum gas flow.
        Valid values are in range 0 [off] to 99.9 [%]. """""",
        validator=truncated_range,
        values=[0, 99.9]
    )

    proportional_band = Instrument.control(
        ""R8"", ""P%f"",
        """""" A floating point property that controls the proportional band
        for the PID controller in Kelvin. Can be set if the PID controller
        is in manual mode. Valid values are 0 [K] to 1677.7 [K]. """""",
        validator=truncated_range,
        values=[0, 1677.7]
    )

    integral_action_time = Instrument.control(
        ""R9"", ""I%f"",
        """""" A floating point property that controls the integral action time
        for the PID controller in minutes. Can be set if the PID controller
        is in manual mode. Valid values are 0 [min.] to 140 [min.]. """""",
        validator=truncated_range,
        values=[0, 140]
    )

    derivative_action_time = Instrument.control(
        ""R10"", ""D%f"",
        """""" A floating point property that controls the derivative action time
        for the PID controller in minutes. Can be set if the PID controller
        is in manual mode. Valid values are 0 [min.] to 273 [min.]. """""",
        validator=truncated_range,
        values=[0, 273]
    )

    auto_pid = Instrument.control(
        ""X"", ""L%d"",
        """""" A boolean property that sets the Auto-PID mode on (True) or off (False).
        """""",
        preprocess_reply=lambda v: v[12:13],
        cast=int,
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    sweep_status = Instrument.control(
        ""X"", ""S%d"",
        """""" An integer property that sets the sweep status. Values are:

        =========   =========================================
        value       meaning
        =========   =========================================
        0           Sweep not running
        1           Start sweep / sweeping to first set-point
        2P - 1      Sweeping to set-point P
        2P          Holding at set-point P
        =========   =========================================
        """""",
        preprocess_reply=lambda v: v[7:9],
        cast=int,
        validator=strict_range,
        values=[0, 32]
    )

    temperature_setpoint = Instrument.control(
        ""R0"", ""T%f"",
        """""" A floating point property that controls the temperature set-point of
        the ITC in kelvin. """""",
        validator=truncated_range,
        values=[0, 1677.7],  # Kelvin, 0 - 1677.7K is the maximum range of the instrument
        dynamic=True,
    )

    temperature_1 = Instrument.measurement(
        ""R1"",
        """""" Reads the temperature of the sensor 1 in Kelvin. """""",
    )

    temperature_2 = Instrument.measurement(
        ""R2"",
        """""" Reads the temperature of the sensor 2 in Kelvin. """""",
    )

    temperature_3 = Instrument.measurement(
        ""R3"",
        """""" Reads the temperature of the sensor 3 in Kelvin. """""",
    )

    temperature_error = Instrument.measurement(
        ""R4"",
        """""" Reads the difference between the set-point and the measured
        temperature in Kelvin. Positive when set-point is larger than
        measured. """""",
    )

    front_panel_display = Instrument.setting(
        ""F%d"",
        """""" A string property that controls what value is displayed on
        the front panel of the ITC. Valid values are:
        'temperature setpoint', 'temperature 1', 'temperature 2',
        'temperature 3', 'temperature error', 'heater', 'heater voltage',
        'gasflow', 'proportional band', 'integral action time',
        'derivative action time', 'channel 1 freq/4', 'channel 2 freq/4',
        'channel 3 freq/4'.
        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={
            ""temperature setpoint"": 0,
            ""temperature 1"": 1,
            ""temperature 2"": 2,
            ""temperature 3"": 3,
            ""temperature error"": 4,
            ""heater"": 5,
            ""heater voltage"": 6,
            ""gasflow"": 7,
            ""proportional band"": 8,
            ""integral action time"": 9,
            ""derivative action time"": 10,
            ""channel 1 freq/4"": 11,
            ""channel 2 freq/4"": 12,
            ""channel 3 freq/4"": 13,
        },
    )

    x_pointer = Instrument.setting(
        ""x%d"",
        """""" An integer property to set pointers into tables for loading and
        examining values in the table. The significance and valid values for
        the pointer depends on what property is to be read or set. """""",
        validator=strict_range,
        values=[0, 128]
    )

    y_pointer = Instrument.setting(
        ""y%d"",
        """""" An integer property to set pointers into tables for loading and
        examining values in the table. The significance and valid values for
        the pointer depends on what property is to be read or set. """""",
        validator=strict_range,
        values=[0, 128]
    )

    pointer = Instrument.setting(
        ""$x%d\r$y%d"",
        """""" A tuple property to set pointers into tables for loading and
        examining values in the table, of format (x, y). The significance
        and valid values for the pointer depends on what property is to be
        read or set. The value for x and y can be in the range 0 to 128. """""",
        validator=pointer_validator,
        values=[0, 128]
    )

    sweep_table = Instrument.control(
        ""r"", ""s%f"",
        """""" A property that controls values in the sweep table. Relies on
        :class:`ITC503.x_pointer` and :class:`ITC503.y_pointer` (or
        :class:`ITC503.pointer`) to point at the location in the table that is
        to be set or read.

        The x-pointer selects the step of the sweep (1 to 16); the y-pointer
        selects the parameter:

        =========   =======================
        y-pointer   parameter
        =========   =======================
        1           set-point temperature
        2           sweep-time to set-point
        3           hold-time at set-point
        =========   =======================
        """""",
    )

    auto_pid_table = Instrument.control(
        ""q"", ""p%f"",
        """""" A property that controls values in the auto-pid table. Relies on
        :class:`ITC503.x_pointer` and :class:`ITC503.y_pointer` (or
        :class:`ITC503.pointer`) to point at the location in the table that
        is to be set or read.

        The x-pointer selects the table entry (1 to 16); the y-pointer
        selects the parameter:

        =========   =======================
        y-pointer   parameter
        =========   =======================
        1           upper temperature limit
        2           proportional band
        3           integral action time
        4           derivative action time
        =========   =======================
        """""",
    )

    target_voltage_table = Instrument.control(
        ""t"", ""v%f"",
        """""" A property that controls values in the target heater voltage table.
        Relies on the :class:`ITC503.x_pointer` to select the entry in the table
        that is to be set or read (1 to 64).
        """""",
    )

    gasflow_configuration_parameter = Instrument.control(
        ""d"", ""c%f"",
        """""" A property that controls the gas flow configuration parameters.
        Relies on the :class:`ITC503.x_pointer` to select which parameter
        is set or read:

        =========   =====================================
        x-pointer   parameter
        =========   =====================================
        1           valve gearing
        2           target table & features configuration
        3           gas flow scaling
        4           temperature error sensitivity
        5           heater voltage error sensitivity
        6           minimum gas valve in auto
        =========   =====================================
        """""",
    )

    gasflow_control_status = Instrument.measurement(
        ""m"",
        """""" A property that reads the gas-flow control status. Returns
        the status in the form of a :class:`ITC503.FLOW_CONTROL_STATUS`
        IntFlag. """""",
        cast=int,
        get_process=lambda v: ITC503.FLOW_CONTROL_STATUS(v),
    )

    target_voltage = Instrument.measurement(
        ""n"",
        """""" A float property that reads the current heater target voltage
        with which the actual heater voltage is being compared. Only valid
        if gas-flow in auto mode. """""",
    )

    valve_scaling = Instrument.measurement(
        ""o"",
        """""" A float property that reads the valve scaling parameter. Only
        valid if gas-flow in auto mode. """""",
    )

    def wait_for_temperature(self,
                             error=0.01,
                             timeout=3600,
                             check_interval=0.5,
                             stability_interval=10,
                             thermalize_interval=300,
                             should_stop=lambda: False,
                             ):
        """"""
        Wait for the ITC to reach the set-point temperature.

        :param error: The maximum error in Kelvin under which the temperature
                      is considered at set-point
        :param timeout: The maximum time the waiting is allowed to take. If
                        timeout is exceeded, a TimeoutError is raised. If
                        timeout is None, no timeout will be used.
        :param check_interval: The time between temperature queries to the ITC.
        :param stability_interval: The time over which the temperature_error is
                                   to be below error to be considered stable.
        :param thermalize_interval: The time to wait after stabilizing for the
                                    system to thermalize.
        :param should_stop: Optional function (returning a bool) to allow the
                            waiting to be stopped before its end.
        """"""

        number_of_intervals = int(stability_interval / check_interval)
        stable_intervals = 0
        attempt = 0

        t0 = time()
        while True:
            temp_error = self.temperature_error
            if abs(temp_error) < error:
                stable_intervals += 1
            else:
                stable_intervals = 0
                attempt += 1

            if stable_intervals >= number_of_intervals:
                break

            if timeout is not None and (time() - t0) > timeout:
                raise TimeoutError(
                    ""Timeout expired while waiting for the Oxford ITC305 to ""
                    ""reach the set-point temperature""
                )

            if should_stop():
                return

            sleep(check_interval)

        if attempt == 0:
            return

        t1 = time() + thermalize_interval
        while time() < t1:
            sleep(check_interval)
            if should_stop():
                return

        return

    def program_sweep(self, temperatures, sweep_time, hold_time, steps=None):
        """"""
        Program a temperature sweep in the controller. Stops any running sweep.
        After programming the sweep, it can be started using
        OxfordITC503.sweep_status = 1.

        :param temperatures: An array containing the temperatures for the sweep
        :param sweep_time: The time (or an array of times) to sweep to a
                           set-point in minutes (between 0 and 1339.9).
        :param hold_time: The time (or an array of times) to hold at a
                          set-point in minutes (between 0 and 1339.9).
        :param steps: The number of steps in the sweep, if given, the
                      temperatures, sweep_time and hold_time will be
                      interpolated into (approximately) equal segments
        """"""
        # Check if in remote control
        if not self.control_mode.startswith(""R""):
            raise AttributeError(
                ""Oxford ITC503 not in remote control mode""
            )

        # Stop sweep if running to be able to write the program
        self.sweep_status = 0

        # Convert input np.ndarrays
        temperatures = numpy.array(temperatures, ndmin=1)
        sweep_time = numpy.array(sweep_time, ndmin=1)
        hold_time = numpy.array(hold_time, ndmin=1)

        # Make steps array
        if steps is None:
            steps = temperatures.size
        steps = numpy.linspace(1, steps, steps)

        # Create interpolated arrays
        interpolator = numpy.round(
            numpy.linspace(1, steps.size, temperatures.size))
        temperatures = numpy.interp(steps, interpolator, temperatures)

        interpolator = numpy.round(
            numpy.linspace(1, steps.size, sweep_time.size))
        sweep_time = numpy.interp(steps, interpolator, sweep_time)

        interpolator = numpy.round(
            numpy.linspace(1, steps.size, hold_time.size))
        hold_time = numpy.interp(steps, interpolator, hold_time)

        # Pad with zeros to wipe unused steps (total 16) of the sweep program
        padding = 16 - temperatures.size
        temperatures = numpy.pad(temperatures, (0, padding), 'constant',
                                 constant_values=temperatures[-1])
        sweep_time = numpy.pad(sweep_time, (0, padding), 'constant')
        hold_time = numpy.pad(hold_time, (0, padding), 'constant')

        # Setting the arrays to the controller
        for line, (setpoint, sweep, hold) in \
                enumerate(zip(temperatures, sweep_time, hold_time), 1):
            self.pointer = (line, 1)
            self.sweep_table = setpoint

            self.pointer = (line, 2)
            self.sweep_table = sweep

            self.pointer = (line, 3)
            self.sweep_table = hold

    def wipe_sweep_table(self):
        """""" Wipe the currently programmed sweep table. """"""
        self.write(""w"")
"
43,https://www.equipx.net/uploads/Newport/NewportESP300.pdf,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'attHUDXWzAcLoQk6L'), ('width', 290), ('height', 174), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/l5GDzhRb4t8ItUGMNKLpkw/0DU_IlTBROi_u3DqYqtuOhpZ_qrMAqzVPMB2vewkJSJTr9vG6RbfL_Io8htzdFKF3qYQ_Alt9HlT-HFNQWZFv93dsPzWafDs4efbwq1o1Jo/1vqKmklh9BoGlYh6ne2_X3wAbiNqiTJkvKkkTREhybM'), ('filename', 'download.jpg'), ('size', 4725), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UbhG2_1_qS0a_U05Rf65gA/NBknEXCPozNPv-2ZXo_LKU8liSz3g9Qa_GYr-rdVHrLZVWnWYBo9hcz0b1G9SVsSXzRw4P9uUxz8Qoviod0rZA/lxNu_IPbZ-vVXo5u1J4cme6030MJfPv-jRO-GYVOf8U'), ('width', 60), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/54fkJouRBwe0XQpK-jJmRg/vi2dUJNjyA8qXfeSpuF5UdL1L6_VH8U0JgEAGYCrpc1zN2_G9gOlAF4OJLw12IOx2FVs9as9q-ZznRRbMaVBEg/jWgER2lDhF1MeiJ2R0Id7qgJbracN0dN4VosrOQwgLo'), ('width', 290), ('height', 174)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rIUxi7trmxJVKozo0shlzA/qHsuye3QnCzbjT4XDTPAp09DzER9bbSoKCu4pRl7W6dN4m9T3kv4k6N6gEQUCP5aPMHm8EXXYPQ0O9-CBoDn9Q/tIAsy-Y3PeMqevZvOVRCW0nqhIaPV_agmvGNAs4OghY'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125992/Instruments/Vendor%20Logos/Newport.png,"This is a Newport ESP300 1 Axis Motion Controller, Model number ESP300-1NN111. It has a 150 Watt power supply and the driver module is rated at 3 amps. This is Newport's most universal motion controller, as it will drive most of Newports actuators and motorized stages. If your Newport stage is an ESP model, this controller will recognize it on power up, and allow you to drive it right away- basically a plug-and-play operation! This unit has been tested and is working correctly.",http://www.lightglassoptics.com/Newport-ESP300-One-Axis-Motion-Controller-ESP300-1NN111_p_1241.html,ESP 300,387.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/newport/esp300.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/newport/esp300.html,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A0ml-NxjRgjFMnT2OxccPw/1mW4u7x4sDOVjqFo-I7U02tzWVHPLp1sfmFa4OXhWSNnMmZCtMXFU-dYDq7uKnO2gtw6iJw15LRZHgq_Xw1_61ZLxkrMTbW60rLV_Y-z_tk/YFckzDzFg1kSGBz2ByCgNmkoQ1EMkcXCLM1uGRyJaQ0'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hUXbHAboUli_i-oSftfgJQ/TfBDoPK41Z2g7rl99W2l9mnW8JhTF8FnZLDpwRN6bva85-D913rt3IeiyI1SDXsrPoX6p3rmimM9Sl7B_VCweg/kDUvSyH1OPMoPpN64SNPA6SYrguHpSkFNsccPlcLYyI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/maoZV_jxcvbCk6BugdSl-g/WAU35z0pYqZV02t6jiXL2iAQMaI_O2JUo-dRWutq4DjedRYdZnv2Mqu7EaBnw4slsgCZo1KkopC4gfQ-UMW3wg/BW4gpoZ6ehZ0DCDMmUcrq8ICYsmXXWW8Wjf8T-IPwUE'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/biSW5Qxhf0KKWrZN3FxOVw/ZbP728ZlvPTiLAgTZMFOYFGRKeVSo3BInrcyJJ88lctUxyV5TLY4pr4gYQcO_heqiM_Gadn6WkyW39rce7QjEg/TQhOrdR6jFiaBFVgzg827EVGfDgN7n9oY2uq5_tgiCk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782457/Instruments/Positional%20Controller/ESP-300/ESP-300.jpg,ESP 300,Write a Python script that uses Pymeasure to connect to a ESP 300 Positional Controller,1630.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from time import sleep

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set


class AxisError(Exception):
    """""" Raised when a particular axis causes an error for
    the Newport ESP300. """"""

    MESSAGES = {
        '00': 'MOTOR TYPE NOT DEFINED',
        '01': 'PARAMETER OUT OF RANGE',
        '02': 'AMPLIFIER FAULT DETECTED',
        '03': 'FOLLOWING ERROR THRESHOLD EXCEEDED',
        '04': 'POSITIVE HARDWARE LIMIT DETECTED',
        '05': 'NEGATIVE HARDWARE LIMIT DETECTED',
        '06': 'POSITIVE SOFTWARE LIMIT DETECTED',
        '07': 'NEGATIVE SOFTWARE LIMIT DETECTED',
        '08': 'MOTOR / STAGE NOT CONNECTED',
        '09': 'FEEDBACK SIGNAL FAULT DETECTED',
        '10': 'MAXIMUM VELOCITY EXCEEDED',
        '11': 'MAXIMUM ACCELERATION EXCEEDED',
        '12': 'Reserved for future use',
        '13': 'MOTOR NOT ENABLED',
        '14': 'Reserved for future use',
        '15': 'MAXIMUM JERK EXCEEDED',
        '16': 'MAXIMUM DAC OFFSET EXCEEDED',
        '17': 'ESP CRITICAL SETTINGS ARE PROTECTED',
        '18': 'ESP STAGE DEVICE ERROR',
        '19': 'ESP STAGE DATA INVALID',
        '20': 'HOMING ABORTED',
        '21': 'MOTOR CURRENT NOT DEFINED',
        '22': 'UNIDRIVE COMMUNICATIONS ERROR',
        '23': 'UNIDRIVE NOT DETECTED',
        '24': 'SPEED OUT OF RANGE',
        '25': 'INVALID TRAJECTORY MASTER AXIS',
        '26': 'PARAMETER CHARGE NOT ALLOWED',
        '27': 'INVALID TRAJECTORY MODE FOR HOMING',
        '28': 'INVALID ENCODER STEP RATIO',
        '29': 'DIGITAL I/O INTERLOCK DETECTED',
        '30': 'COMMAND NOT ALLOWED DURING HOMING',
        '31': 'COMMAND NOT ALLOWED DUE TO GROUP',
        '32': 'INVALID TRAJECTORY MODE FOR MOVING'
    }

    def __init__(self, code):
        self.axis = str(code)[0]
        self.error = str(code)[1:]
        self.message = self.MESSAGES[self.error]

    def __str__(self):
        return ""Newport ESP300 axis {} reported the error: {}"".format(
            self.axis, self.message)


class GeneralError(Exception):
    """""" Raised when the Newport ESP300 has a general error.
    """"""

    MESSAGES = {
        '1': 'PCI COMMUNICATION TIME-OUT',
        '4': 'EMERGENCY SOP ACTIVATED',
        '6': 'COMMAND DOES NOT EXIST',
        '7': 'PARAMETER OUT OF RANGE',
        '8': 'CABLE INTERLOCK ERROR',
        '9': 'AXIS NUMBER OUT OF RANGE',
        '13': 'GROUP NUMBER MISSING',
        '14': 'GROUP NUMBER OUT OF RANGE',
        '15': 'GROUP NUMBER NOT ASSIGNED',
        '17': 'GROUP AXIS OUT OF RANGE',
        '18': 'GROUP AXIS ALREADY ASSIGNED',
        '19': 'GROUP AXIS DUPLICATED',
        '16': 'GROUP NUMBER ALREADY ASSIGNED',
        '20': 'DATA ACQUISITION IS BUSY',
        '21': 'DATA ACQUISITION SETUP ERROR',
        '23': 'SERVO CYCLE TICK FAILURE',
        '25': 'DOWNLOAD IN PROGRESS',
        '26': 'STORED PROGRAM NOT STARTED',
        '27': 'COMMAND NOT ALLOWED',
        '29': 'GROUP PARAMETER MISSING',
        '30': 'GROUP PARAMETER OUT OF RANGE',
        '31': 'GROUP MAXIMUM VELOCITY EXCEEDED',
        '32': 'GROUP MAXIMUM ACCELERATION EXCEEDED',
        '22': 'DATA ACQUISITION NOT ENABLED',
        '28': 'STORED PROGRAM FLASH AREA FULL',
        '33': 'GROUP MAXIMUM DECELERATION EXCEEDED',
        '35': 'PROGRAM NOT FOUND',
        '37': 'AXIS NUMBER MISSING',
        '38': 'COMMAND PARAMETER MISSING',
        '34': 'GROUP MOVE NOT ALLOWED DURING MOTION',
        '39': 'PROGRAM LABEL NOT FOUND',
        '40': 'LAST COMMAND CANNOT BE REPEATED',
        '41': 'MAX NUMBER OF LABELS PER PROGRAM EXCEEDED'
    }

    def __init__(self, code):
        self.error = str(code)
        self.message = self.MESSAGES[self.error]

    def __str__(self):
        return ""Newport ESP300 reported the error: %s"" % (
            self.message)


class Axis:
    """""" Represents an axis of the Newport ESP300 Motor Controller,
    which can have independent parameters from the other axes.
    """"""

    position = Instrument.control(
        ""TP"", ""PA%g"",
        """""" A floating point property that controls the position
        of the axis. The units are defined based on the actuator.
        Use the :meth:`~.wait_for_stop` method to ensure the position
        is stable.
        """"""
    )
    enabled = Instrument.measurement(
        ""MO?"",
        """""" Returns a boolean value that is True if the motion for
        this axis is enabled.
        """""",
        cast=bool
    )
    left_limit = Instrument.control(
        ""SL?"", ""SL%g"",
        """""" A floating point property that controls the left software
        limit of the axis. """"""
    )
    right_limit = Instrument.control(
        ""SR?"", ""SR%g"",
        """""" A floating point property that controls the right software
        limit of the axis. """"""
    )
    units = Instrument.control(
        ""SN?"", ""SN%d"",
        """""" A string property that controls the displacement units of the
        axis, which can take values of: enconder count, motor step, millimeter,
        micrometer, inches, milli-inches, micro-inches, degree, gradient, radian,
        milliradian, and microradian.
        """""",
        validator=strict_discrete_set,
        values={
            'encoder count': 0, 'motor step': 1, 'millimeter': 2,
            'micrometer': 3, 'inches': 4, 'milli-inches': 5,
            'micro-inches': 6, 'degree': 7, 'gradient': 8,
            'radian': 9, 'milliradian': 10, 'microradian': 11
        },
        map_values=True
    )
    motion_done = Instrument.measurement(
        ""MD?"",
        """""" Returns a boolean that is True if the motion is finished.
        """""",
        cast=bool
    )

    def __init__(self, axis, controller):
        self.axis = str(axis)
        self.controller = controller

    def ask(self, command):
        command = self.axis + command
        return self.controller.ask(command)

    def write(self, command):
        command = self.axis + command
        self.controller.write(command)

    def values(self, command, **kwargs):
        command = self.axis + command
        return self.controller.values(command, **kwargs)

    def enable(self):
        """""" Enables motion for the axis. """"""
        self.write(""MO"")

    def disable(self):
        """""" Disables motion for the axis. """"""
        self.write(""MF"")

    def home(self, type=1):
        """""" Drives the axis to the home position, which may be the negative
        hardware limit for some actuators (e.g. LTA-HS).
        type can take integer values from 0 to 6.
        """"""
        home_type = strict_discrete_set(type, [0, 1, 2, 3, 4, 5, 6])
        self.write(""OR%d"" % home_type)

    def define_position(self, position):
        """""" Overwrites the value of the current position with the given
        value. """"""
        self.write(""DH%g"" % position)

    def zero(self):
        """""" Resets the axis position to be zero at the current poisiton.
        """"""
        self.write(""DH"")

    def wait_for_stop(self, delay=0, interval=0.05):
        """""" Blocks the program until the motion is completed. A further
        delay can be specified in seconds.
        """"""
        self.write(""WS%d"" % (delay * 1e3))
        while not self.motion_done:
            sleep(interval)


class ESP300(Instrument):
    """""" Represents the Newport ESP 300 Motion Controller
    and provides a high-level for interacting with the instrument.

    By default this instrument is constructed with x, y, and phi
    attributes that represent axes 1, 2, and 3. Custom implementations
    can overwrite this depending on the avalible axes. Axes are controlled
    through an :class:`Axis <pymeasure.instruments.newport.esp300.Axis>`
    class.
    """"""

    error = Instrument.measurement(
        ""TE?"",
        """""" Get an error code from the motion controller.
        """""",
        cast=int
    )

    def __init__(self, adapter, name=""Newport ESP 300 Motion Controller"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        # Defines default axes, which can be overwritten
        self.x = Axis(1, self)
        self.y = Axis(2, self)
        self.phi = Axis(3, self)

    def clear_errors(self):
        """""" Clears the error messages by checking until a 0 code is
        recived. """"""
        while self.error != 0:
            continue

    @property
    def errors(self):
        """""" Get a list of error Exceptions that can be later raised, or
        used to diagnose the situation.
        """"""
        errors = []

        code = self.error
        while code != 0:
            if code > 100:
                errors.append(AxisError(code))
            else:
                errors.append(GeneralError(code))
            code = self.error
        return errors

    @property
    def axes(self):
        """""" Get a list of the :class:`Axis <pymeasure.instruments.newport.esp300.Axis>`
        objects that are present. """"""
        axes = []
        directory = dir(self)
        for name in directory:
            if name == 'axes':
                continue  # Skip this property
            try:
                item = getattr(self, name)
                if isinstance(item, Axis):
                    axes.append(item)
            except TypeError:
                continue
            except Exception as e:
                raise e
        return axes

    def enable(self):
        """""" Enables all of the axes associated with this controller.
        """"""
        for axis in self.axes:
            axis.enable()

    def disable(self):
        """""" Disables all of the axes associated with this controller.
        """"""
        for axis in self.axes:
            axis.disable()

    def shutdown(self):
        """""" Shuts down the controller by disabling all of the axes.
        """"""
        self.disable()
        super().shutdown()
"
48,https://www.keysight.com/us/en/assets/7018-03659/product-fact-sheets/5991-1206.pdf,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,"[OrderedDict([('id', 'attOj9CAu6oVexCXp'), ('width', 1156), ('height', 650), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fsJviTvYQrnCcv_IRTu7qA/I-xR_eW3XLj0DzTURDctYqv9NlwIkevEy0fd76GcV4M2BwuTVQ-Ye6jCVjkX-UE99SevJLOEEKTDQIzUYFHLkFDF5Utc0d0BjlrkvBM8YcA/doSx6T1jNwXK-6UEZRyCmFyb-IhRJMbumujiMAZTix0'), ('filename', '34450A.png'), ('size', 398092), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FWknGNd3FQQ47R-_uE61sg/_sczEsDS2o4JNW4izWZ6oU17-OnOxEtAe12tF27ENEn-Hx7Ay-3UUZYGUCVYWzWwA4_M8HQOJcXl6hSJSuGSEQ/zHXRCZ-yCX14UJIzYX2DvsxFQ-3FuscupKafZccFOLo'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YgQvLvnRlYCWMHdu12o53A/i8Sb9JBUJixevajTcZSnUHP6B8YIOdI12QF2slzLXHhEMTJPkgAeA1a24aGsK8ed4FnjWCH5kQqeuEcwqEmQBw/4jC_qowy5GH3CtvPpEuqP11Xb08k9g8xfOslbPgQF7o'), ('width', 911), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ScmVZviDPoeoULJHdqg9PQ/3V1n5og7wc1eJnqqON5CyWW3QFAl80VeBrQ3bBpDnpgw1avEbdupQFpsZoIiDT-dbSSLdKUxYUOIIbSd4c-qmw/DSz6ciIO8XELXQe7O8_M9hh-mX9MWp8HiEd2bg6AJAg'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,"Turbo charge your production line with the Keysight 34450A 5.5-digit multimeter with OLED display. With its fast speed of up to 190 readings per second, you can increase your manufacturing throughput tremendously.",https://www.keysight.com/us/en/product/34450A/digital-multimeter-5-5-digit-oled-display.html,Agilent 34450 A,11.0,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent34450A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent34450A.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782461/Instruments/Multimeters/Keysight-34450A/Keysight-34450A.png,Keysight 34450A,Write a Python script that uses Pymeasure to connect to a Keysight 34450A Multimeters,1138.0,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Agilent34450A(Instrument):
    """"""
    Represent the HP/Agilent/Keysight 34450A and related multimeters.

    .. code-block:: python

        dmm = Agilent34450A(""USB0::..."")
        dmm.reset()
        dmm.configure_voltage()
        print(dmm.voltage)
        dmm.shutdown()

    """"""

    BOOLS = {True: 1, False: 0}

    MODES = {'current': 'CURR', 'ac current': 'CURR:AC',
             'voltage': 'VOLT', 'ac voltage': 'VOLT:AC',
             'resistance': 'RES', '4w resistance': 'FRES',
             'current frequency': 'FREQ:ACI', 'voltage frequency': 'FREQ:ACV',
             'continuity': 'CONT',
             'diode': 'DIOD',
             'temperature': 'TEMP',
             'capacitance': 'CAP'}

    @property
    def mode(self):
        get_command = "":configure?""
        vals = self._conf_parser(self.values(get_command))
        # Return only the mode parameter
        inv_modes = {v: k for k, v in self.MODES.items()}
        mode = inv_modes[vals[0]]
        return mode

    @mode.setter
    def mode(self, value):
        """""" A string parameter that sets the measurement mode of the multimeter. Can be ""current"",
        ""ac current"", ""voltage"", ""ac voltage"", ""resistance"", ""4w resistance"", ""current frequency"",
        ""voltage frequency"", ""continuity"", ""diode"", ""temperature"", or ""capacitance"".""""""
        if value in self.MODES:
            if value not in ['current frequency', 'voltage frequency']:
                self.write(':configure:' + self.MODES[value])
            else:
                if value == 'current frequency':
                    self.mode = 'ac current'
                else:
                    self.mode = 'ac voltage'
                self.write("":configure:freq"")
        else:
            raise ValueError(f'Value {value} is not a supported mode for this device.')

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement("":READ?"",
                                     """""" Reads a DC current measurement in Amps, based on the
                                     active :attr:`~.Agilent34450A.mode`. """"""
                                     )
    current_ac = Instrument.measurement("":READ?"",
                                        """""" Reads an AC current measurement in Amps, based on the
                                        active :attr:`~.Agilent34450A.mode`. """"""
                                        )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %s"",
        """""" A property that controls the DC current range in
        Amps, which can take values 100E-6, 1E-3, 10E-3, 100E-3, 1, 10,
        as well as ""MIN"", ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-6, 1E-3, 10E-3, 100E-3, 1, 10, ""MIN"", ""DEF"", ""MAX""]
    )
    current_auto_range = Instrument.control(
        "":SENS:CURR:RANG:AUTO?"", "":SENS:CURR:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for DC current. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    current_resolution = Instrument.control(
        "":SENS:CURR:RES?"", "":SENS:CURR:RES %s"",
        """""" A property that controls the resolution in the DC current
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", and ""DEF"" (3.00E-5). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    current_ac_range = Instrument.control(
        "":SENS:CURR:AC:RANG?"", "":SENS:CURR:AC:RANG:AUTO 0;:SENS:CURR:AC:RANG %s"",
        """""" A property that controls the AC current range in Amps, which can take
        values 10E-3, 100E-3, 1, 10, as well as ""MIN"", ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[10E-3, 100E-3, 1, 10, ""MIN"", ""MAX"", ""DEF""]
    )
    current_ac_auto_range = Instrument.control(
        "":SENS:CURR:AC:RANG:AUTO?"", "":SENS:CURR:AC:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for AC current. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    current_ac_resolution = Instrument.control(
        "":SENS:CURR:AC:RES?"", "":SENS:CURR:AC:RES %s"",
        """""" An property that controls the resolution in the AC current
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement("":READ?"",
                                     """""" Reads a DC voltage measurement in Volts, based on the
                                     active :attr:`~.Agilent34450A.mode`. """"""
                                     )
    voltage_ac = Instrument.measurement("":READ?"",
                                        """""" Reads an AC voltage measurement in Volts, based on the
                                        active :attr:`~.Agilent34450A.mode`. """"""
                                        )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %s"",
        """""" A property that controls the DC voltage range in Volts, which
        can take values 100E-3, 1, 10, 100, 1000, as well as ""MIN"", ""MAX"", or
        ""DEF"" (10 V). Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 1000, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_auto_range = Instrument.control(
        "":SENS:VOLT:RANG:AUTO?"", "":SENS:VOLT:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for DC voltage. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    voltage_resolution = Instrument.control(
        "":SENS:VOLT:RES?"", "":SENS:VOLT:RES %s"",
        """""" A property that controls the resolution in the DC voltage
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_ac_range = Instrument.control(
        "":SENS:VOLT:AC:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:AC:RANG %s"",
        """""" A property that controls the AC voltage range in Volts, which can
        take values 100E-3, 1, 10, 100, 750, as well as ""MIN"", ""MAX"", or ""DEF""
        (10 V).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 750, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_ac_auto_range = Instrument.control(
        "":SENS:VOLT:AC:RANG:AUTO?"", "":SENS:VOLT:AC:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for AC voltage. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    voltage_ac_resolution = Instrument.control(
        "":SENS:VOLT:AC:RES?"", "":SENS:VOLT:AC:RES %s"",
        """""" A property that controls the resolution in the AC voltage readings,
        which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement("":READ?"",
                                        """""" Reads a resistance measurement in Ohms for 2-wire
                                        configuration, based on the active
                                        :attr:`~.Agilent34450A.mode`. """"""
                                        )
    resistance_4w = Instrument.measurement("":READ?"",
                                           """""" Reads a resistance measurement in Ohms for
                                           4-wire configuration, based on the active
                                           :attr:`~.Agilent34450A.mode`. """"""
                                           )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %s"",
        """""" A property that controls the 2-wire resistance range in Ohms, which can
        take values 100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, as well as ""MIN"", ""MAX"",
        or ""DEF"" (1E3).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_auto_range = Instrument.control(
        "":SENS:RES:RANG:AUTO?"", "":SENS:RES:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for 2-wire resistance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    resistance_resolution = Instrument.control(
        "":SENS:RES:RES?"", "":SENS:RES:RES %s"",
        """""" A property that controls the resolution in the 2-wire
        resistance readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_4w_range = Instrument.control(
        "":SENS:FRES:RANG?"", "":SENS:FRES:RANG:AUTO 0;:SENS:FRES:RANG %s"",
        """""" A property that controls the 4-wire resistance range
        in Ohms, which can take values 100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6,
        as well as ""MIN"", ""MAX"", or ""DEF"" (1E3).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_4w_auto_range = Instrument.control(
        "":SENS:FRES:RANG:AUTO?"", "":SENS:FRES:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for 4-wire resistance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    resistance_4w_resolution = Instrument.control(
        "":SENS:FRES:RES?"", "":SENS:FRES:RES %s"",
        """""" A property that controls the resolution in the 4-wire
        resistance readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ##################
    # Frequency (Hz) #
    ##################

    frequency = Instrument.measurement("":READ?"",
                                       """""" Reads a frequency measurement in Hz, based on the
                                       active :attr:`~.Agilent34450A.mode`. """"""
                                       )
    frequency_current_range = Instrument.control(
        "":SENS:FREQ:CURR:RANG?"", "":SENS:FREQ:CURR:RANG:AUTO 0;:SENS:FREQ:CURR:RANG %s"",
        """""" A property that controls the current range in Amps for frequency on AC current
        measurements, which can take values 10E-3, 100E-3, 1, 10, as well as ""MIN"",
        ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[10E-3, 100E-3, 1, 10, ""MIN"", ""MAX"", ""DEF""]
    )
    frequency_current_auto_range = Instrument.control(
        "":SENS:FREQ:CURR:RANG:AUTO?"", "":SENS:FREQ:CURR:RANG:AUTO %d"",
        """""" Boolean property that toggles auto ranging for AC current in frequency measurements."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    frequency_voltage_range = Instrument.control(
        "":SENS:FREQ:VOLT:RANG?"", "":SENS:FREQ:VOLT:RANG:AUTO 0;:SENS:FREQ:VOLT:RANG %s"",
        """""" A property that controls the voltage range in Volts for frequency on AC voltage
        measurements, which can take values 100E-3, 1, 10, 100, 750,
        as well as ""MIN"", ""MAX"", or ""DEF"" (10 V).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 750, ""MAX"", ""MIN"", ""DEF""]
    )
    frequency_voltage_auto_range = Instrument.control(
        "":SENS:FREQ:VOLT:RANG:AUTO?"", "":SENS:FREQ:VOLT:RANG:AUTO %d"",
        """"""Boolean property that toggles auto ranging for AC voltage in frequency measurements. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    frequency_aperture = Instrument.control(
        "":SENS:FREQ:APER?"", "":SENS:FREQ:APER %s"",
        """""" A property that controls the frequency aperture in seconds,
        which sets the integration period and measurement speed. Takes values
        100 ms, 1 s, as well as ""MIN"", ""MAX"", or ""DEF"" (1 s). """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, ""MIN"", ""MAX"", ""DEF""]
    )

    ###################
    # Temperature (C) #
    ###################

    temperature = Instrument.measurement(
        "":READ?"",
        """""" Reads a temperature measurement in Celsius, based on the active :attr:`~.Agilent34450A.mode`.
        """"""  # noqa: E501
    )

    #############
    # Diode (V) #
    #############

    diode = Instrument.measurement(
        "":READ?"",
        """""" Reads a diode measurement in Volts, based on the active :attr:`~.Agilent34450A.mode`.
        """"""
    )

    ###################
    # Capacitance (F) #
    ###################

    capacitance = Instrument.measurement(
        "":READ?"",
        """""" Reads a capacitance measurement in Farads, based on the active :attr:`~.Agilent34450A.mode`.
        """"""  # noqa: E501
    )
    capacitance_range = Instrument.control(
        "":SENS:CAP:RANG?"", "":SENS:CAP:RANG:AUTO 0;:SENS:CAP:RANG %s"",
        """""" A property that controls the capacitance range
        in Farads, which can take values 1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6,
        1E-3, 10E-3, as well as ""MIN"", ""MAX"", or ""DEF"" (1E-6).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6, 1E-3, 10E-3, ""MAX"", ""MIN"", ""DEF""]
    )
    capacitance_auto_range = Instrument.control(
        "":SENS:CAP:RANG:AUTO?"", "":SENS:CAP:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for capacitance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    ####################
    # Continuity (Ohm) #
    ####################

    continuity = Instrument.measurement("":READ?"",
                                        """""" Reads a continuity measurement in Ohms,
                                        based on the active :attr:`~.Agilent34450A.mode`. """"""
                                        )

    def __init__(self, adapter, name=""HP/Agilent/Keysight 34450A Multimeter"", **kwargs):
        super().__init__(
            adapter, name, timeout=10000, **kwargs
        )
        # Configuration changes can necessitate up to 8.8 secs (per datasheet)
        self.check_errors()

    def configure_voltage(self, voltage_range=""AUTO"", ac=False, resolution=""DEF""):
        """""" Configures the instrument to measure voltage.

        :param voltage_range: A voltage in Volts to set the voltage range.
                DC values can be 100E-3, 1, 10, 100, 1000, as well as ""MIN"", ""MAX"",
                ""DEF"" (10 V), or ""AUTO"". AC values can be 100E-3, 1, 10, 100, 750,
                as well as ""MIN"", ""MAX"", ""DEF"" (10 V), or ""AUTO"".
        :param ac: False for DC voltage, True for AC voltage
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5,
                1.50E-6 (5 1/2 digits), as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if ac is True:
            self.mode = 'ac voltage'
            self.voltage_ac_resolution = resolution
            if voltage_range == ""AUTO"":
                self.voltage_ac_auto_range = True
            else:
                self.voltage_ac_range = voltage_range
        elif ac is False:
            self.mode = 'voltage'
            self.voltage_resolution = resolution
            if voltage_range == ""AUTO"":
                self.voltage_auto_range = True
            else:
                self.voltage_range = voltage_range
        else:
            raise TypeError('Value of ac should be a boolean.')

    def configure_current(self, current_range=""AUTO"", ac=False, resolution=""DEF""):
        """""" Configures the instrument to measure current.

        :param current_range: A current in Amps to set the current range.
                DC values can be 100E-6, 1E-3, 10E-3, 100E-3, 1, 10, as well as ""MIN"",
                ""MAX"", ""DEF"" (100 mA), or ""AUTO"". AC values can be 10E-3, 100E-3, 1, 10,
                as well as ""MIN"", ""MAX"", ""DEF"" (100 mA), or ""AUTO"".
        :param ac: False for DC current, and True for AC current
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
                as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if ac is True:
            self.mode = 'ac current'
            self.current_ac_resolution = resolution
            if current_range == ""AUTO"":
                self.current_ac_auto_range = True
            else:
                self.current_ac_range = current_range
        elif ac is False:
            self.mode = 'current'
            self.current_resolution = resolution
            if current_range == ""AUTO"":
                self.current_auto_range = True
            else:
                self.current_range = current_range
        else:
            raise TypeError('Value of ac should be a boolean.')

    def configure_resistance(self, resistance_range=""AUTO"", wires=2, resolution=""DEF""):
        """""" Configures the instrument to measure resistance.

        :param resistance_range: A resistance in Ohms to set the resistance range, can be 100,
                1E3, 10E3, 100E3, 1E6, 10E6, 100E6, as well as ""MIN"", ""MAX"", ""DEF"" (1E3), or ""AUTO"".
        :param wires: Number of wires used for measurement, can be 2 or 4.
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
                as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if wires == 2:
            self.mode = 'resistance'
            self.resistance_resolution = resolution
            if resistance_range == ""AUTO"":
                self.resistance_auto_range = True
            else:
                self.resistance_range = resistance_range
        elif wires == 4:
            self.mode = '4w resistance'
            self.resistance_4w_resolution = resolution
            if resistance_range == ""AUTO"":
                self.resistance_4w_auto_range = True
            else:
                self.resistance_4w_range = resistance_range
        else:
            raise ValueError(""Incorrect wires value, Agilent 34450A only supports 2 or 4 wire""
                             ""resistance meaurement."")

    def configure_frequency(self, measured_from=""voltage_ac"",
                            measured_from_range=""AUTO"", aperture=""DEF""):
        """""" Configures the instrument to measure frequency.

        :param measured_from: ""voltage_ac"" or ""current_ac""
        :param measured_from_range: range of measured_from. AC voltage can have ranges 100E-3,
                                    1, 10, 100, 750, as well as ""MIN"", ""MAX"", ""DEF"" (10 V),
                                    or ""AUTO"". AC current can have ranges 10E-3, 100E-3, 1, 10,
                                    as well as ""MIN"", ""MAX"", ""DEF"" (100 mA), or ""AUTO"".
        :param aperture: Aperture time in Seconds, can be 100 ms, 1 s, as well as ""MIN"", ""MAX"",
                        or ""DEF"" (1 s).
        """"""
        if measured_from == ""voltage_ac"":
            self.mode = ""voltage frequency""
            if measured_from_range == ""AUTO"":
                self.frequency_voltage_auto_range = True
            else:
                self.frequency_voltage_range = measured_from_range
        elif measured_from == ""current_ac"":
            self.mode = ""current frequency""
            if measured_from_range == ""AUTO"":
                self.frequency_current_auto_range = True
            else:
                self.frequency_current_range = measured_from_range
        else:
            raise ValueError('Incorrect value for measured_from parameter. Use '
                             '""voltage_ac"" or ""current_ac"".')
        self.frequency_aperture = aperture

    def configure_temperature(self):
        """""" Configures the instrument to measure temperature.
        """"""
        self.mode = 'temperature'

    def configure_diode(self):
        """""" Configures the instrument to measure diode voltage.
        """"""
        self.mode = 'diode'

    def configure_capacitance(self, capacitance_range=""AUTO""):
        """""" Configures the instrument to measure capacitance.

        :param capacitance_range: A capacitance in Farads to set the capacitance range, can be
                                    1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6, 1E-3, 10E-3,
                                    as well as ""MIN"", ""MAX"", ""DEF"" (1E-6), or ""AUTO"".
        """"""
        self.mode = 'capacitance'
        if capacitance_range == ""AUTO"":
            self.capacitance_auto_range = True
        else:
            self.capacitance_range = capacitance_range

    def configure_continuity(self):
        """""" Configures the instrument to measure continuity.
        """"""
        self.mode = 'continuity'

    def beep(self):
        """""" Sounds a system beep.
        """"""
        self.write("":SYST:BEEP"")

    def _conf_parser(self, conf_values):
        """"""
        Parse the string of configuration parameters read from Agilent34450A with
        command "":configure?"" and returns a list of parameters.

        Use cases:

        ['""CURR +1.000000E-01', '+1.500000E-06""'] from Instrument.measurement or Instrument.control
        '""CURR +1.000000E-01,+1.500000E-06""'      from Instrument.ask

        becomes

        [""CURR"", +1000000E-01, +1.500000E-06]
        """"""
        # If not already one string, get one string

        if isinstance(conf_values, list):
            one_long_string = ', '.join(map(str, conf_values))
        else:
            one_long_string = conf_values

        # Split string in elements
        list_of_elements = re.split(r'[""\s,]', one_long_string)

        # Eliminate empty string elements
        list_without_empty_elements = list(filter(lambda v: v != '', list_of_elements))

        # Convert numbers from str to float, where applicable
        for i, v in enumerate(list_without_empty_elements):
            try:
                list_without_empty_elements[i] = float(v)
            except ValueError as e:
                log.error(e)

        return list_without_empty_elements
"
60,https://www.farnell.com/datasheets/1626633.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attMfg9G4Kzjnbd5P'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/D5POib1Mgp0czkKs7o-yHg/rzQMq4Yls8_W3LkMYYv-HbfEq9iDFcA_NfhXFdFSYf0DMupyYXX1oBZgKS1T3WbhuEaDxWcDGtgykjQp1vqeD5bc6HHB6_ODSeqhBuRy65k/MGRAMWGrF7yPzxiIP8lhlvgtPiVpmKUV3QoDqddn9kE'), ('filename', '2306_front_5in_0.webp'), ('size', 17436), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EEluwHYc4rsjNEJVEZTGzQ/wMt5PAkNELagLB9GPU7fz6A1CEEwF9_NUVi-TUBawFLc0_BWtEyVQBmeVvddTGEXKCYTOcgr6cWPe5hsnjRfX-BsbqKwBcbQ8AEWoHQ2d4A/Nfh4lQBVS7ka-eYI2dp-MYLqhsV2Ww-DCWXL9uA4YAU'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Q9pDzDurehPJGJ82KhJ9iQ/PVaHWqANZ8LSF9LRKfjf1XY1aQxQFv7ZM4yJ9SjdJBRvZmLMqGgi-ynzMn2xzfFWMO4waPICqlB5PCU157W3PzmorSUt9OEvz7DGImfyUOM/XSXwL0i7biCb2oX62bsNi7uo-QZoPy8XdK75j-Z7IE4'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UUX-l4qnal65rXVA_55GmA/lDPs-hkOoM5JV7hkOv_xJoGMEkVuD0gl0eLTZ3EZerCGiVjXNCQy0WvuaGqukmv086Mph8LE1Kc65I2pT2-g69Oe-zJBehxRMfOitXh0WuI/p-WKMsrSBrK0kAH7LxDHpQtuCQpUJ4lXx0HIYULYk6s'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The dual channel Battery/Charger Simulator was designed specifically for development and test applications of portable, battery-operated products, such as cellular and cordless telephones, mobile radios, and pagers. This precision DC power supply product has ultrafast transient response so it can have output characteristics identical to actual batteries. This supply employs a unique variable output resistance so the voltage output can emulate a battery's response. It provides stable voltage outputs, even when a device-under-test (DUT) makes the rapid transition from the standby (low current) state to the RF transmission (high current) state. In addition, they can monitor DUT power consumption by measuring both DC currents and pulse load currents. The battery-simulator channel can be programmed to operate like a discharged rechargeable battery, sinking current from a separate charger.",https://canada.newark.com/keithley/2306/battery-charger-simulator-15v/dp/58T8423,Keithley 2306,269.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2306.py,Pymeasure,https://pymeasure.readthedocs.io/en/stable/api/instruments/keithley/keithley2306.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782472/Instruments/Power%20Supplies/Keithley-2306/Keithley-2306.webp,Keithley 2306,Write a Python script that uses Pymeasure to connect to a Keithley 2306 Power Supplies,7450.4,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument, Channel
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2306Channel(Channel):
    """""" Implementation of a Keithley 2306 channel. """"""

    enabled = Channel.control(
        "":OUTPUT{ch}:STAT?"", "":OUTPUT{ch}:STAT %d"",
        """"""A boolean property that controls whether the output is enabled, takes
        values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    bandwidth = Channel.control(
        "":OUTPUT{ch}:BAND?"", "":OUTPUT{ch}:BAND %s"",
        """"""A string property that controls the output bandwidth when the output
        is enabled and the current range is set to 5 A. Takes values 'HIGH' or
        'LOW'. If the output is disabled or the current range is set to 5 mA the
        bandwidth is 'LOW'. """""",
        validator=strict_discrete_set,
        values={'low': 'LOW', 'high': 'HIGH'},
        map_values=True,
    )

    sense_mode = Channel.control(
        "":SENS{ch}:FUNC?"", "":SENS{ch}:FUNC \""%s\"""",
        """"""A string property that controls the channel sense mode, which can
        take the values 'voltage', 'current', 'dvm', 'pulse_current',
        or 'long_integration'. """""",
        validator=strict_discrete_set,
        values={'voltage': 'VOLT', 'current': 'CURR', 'dvm': 'DVM',
                'pulse_current': 'PCUR', 'long_integration': 'LINT'},
        map_values=True,
        get_process=lambda v: v.replace('""', ''),
    )

    nplc = Channel.control(
        "":SENS{ch}:NPLC?"", "":SENS{ch}:NPLC %g"",
        """"""A floating point property that controls the number of power line
        cycles (NPLC) for voltage, current, and DVM measurements. Takes
        values from 0.01 to 10. """""",
        validator=truncated_range,
        values=[0.01, 10],
    )

    average_count = Channel.control(
        "":SENS{ch}:AVER?"", "":SENS{ch}:AVER %d"",
        """"""An integer property that controls the average count for voltage,
        current, and DVM measurements. Takes values from 1 to 10. """""",
        validator=truncated_range,
        values=[1, 10],
    )

    current_range = Channel.control(
        "":SENS{ch}:CURR:RANG?"", "":SENS{ch}:CURR:RANG %g"",
        """"""A floating point property that controls the current range which
        takes values of 5 mA and 5 A (or 500 mA and 5 A for the 2306-PJ)."""""",
        validator=strict_discrete_set,
        values=[0.005, 0.5, 5],
    )

    current_range_auto = Channel.control(
        "":SENS{ch}:CURR:RANG:AUTO?"", "":SENS{ch}:CURR:RANG:AUTO %d"",
        """"""A boolean point property that controls whether current range
        is in auto mode. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_average_count = Channel.control(
        "":SENS{ch}:PCUR:AVER?"", "":SENS{ch}:PCUR:AVER %d"",
        """"""An integer property that controls the average count for pulse
        current measurements. Takes values from 1 to either 100 if
        pulse_current_measure_enabled is set to True, 5000 otherwise. """""",
        validator=truncated_range,
        values=[1, 5000],
    )

    pulse_current_measure_enabled = Channel.control(
        "":SENS{ch}:PCUR:SYNC?"", "":SENS{ch}:PCUR:SYNC %d"",
        """"""A boolean property that controls whether pulse current
        measurements are enabled (True) or whether the channel is in
        digitization mode (False). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_trigger_delay = Channel.control(
        "":SENS{ch}:PCUR:SYNC:DEL?"", "":SENS{ch}:PCUR:SYNC:DEL %g"",
        """"""A floating point property that controls the pulse current trigger
        delay in seconds. Takes values from 0 to either 0.1 if
        pulse_current_measure_enabled is set to True, 5 otherwise."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    pulse_current_trigger_level = Channel.control(
        "":SENS{ch}:PCUR:SYNC:TLEV?"", "":SENS{ch}:PCUR:SYNC:TLEV %g"",
        """"""A floating point property that controls the pulse current trigger
        level in amps. Takes values between 0 and 5."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    pulse_current_mode = Channel.control(
        "":SENS{ch}:PCUR:MODE?"", "":SENS{ch}:PCUR:MODE %s"",
        """"""A string property that controls the pulse current measurement
        mode, which can take the values 'high', 'low', or 'average'. """""",
        validator=strict_discrete_set,
        values={'high': 'HIGH', 'low': 'LOW', 'average': 'AVER'},
        map_values=True,
    )

    def pulse_current_time_auto(self):
        """"""Arranges for the instrument to control integration times. """"""
        self.write("":SENS{ch}:PCUR:TIME:AUTO"")

    pulse_current_time_high = Channel.control(
        "":SENS{ch}:PCUR:TIME:HIGH?"", "":SENS{ch}:PCUR:TIME:HIGH %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for high pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_low = Channel.control(
        "":SENS{ch}:PCUR:TIME:LOW?"", "":SENS{ch}:PCUR:TIME:LOW %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for low pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_average = Channel.control(
        "":SENS{ch}:PCUR:TIME:AVER?"", "":SENS{ch}:PCUR:TIME:AVER %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for average pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_digitize = Channel.control(
        "":SENS{ch}:PCUR:TIME:DIG?"", "":SENS{ch}:PCUR:TIME:DIG %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for digitizing or burst pulse measurements. Takes on values
        between 33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_fast_enabled = Channel.control(
        "":SENS{ch}:PCUR:FAST?"", "":SENS{ch}:PCUR:FAST %d"",
        """"""A boolean property that controls whether pulse current fast readings
        are enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_search_enabled = Channel.control(
        "":SENS{ch}:PCUR:SEAR?"", "":SENS{ch}:PCUR:SEAR %d"",
        """"""A boolean property that controls whether pulse current search
        is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_detect_enabled = Channel.control(
        "":SENS{ch}:PCUR:DET?"", "":SENS{ch}:PCUR:DET %d"",
        """"""A boolean property that controls whether pulse current detection
        mode is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_timeout = Channel.control(
        "":SENS{ch}:PCUR:TOUT?"", "":SENS{ch}:PCUR:TOUT %g"",
        """"""A floating point property that controls the pulse current timeout
        in seconds, which takes on values between 0.005 and 32. """""",
        validator=truncated_range,
        values=[0.005, 32],
    )

    long_integration_trigger_edge = Channel.control(
        "":SENS{ch}:LINT:TEDG?"", "":SENS{ch}:LINT:TEDG %s"",
        """"""A string property that controls the long integration trigger edge,
         which can take the values 'rising', 'falling', or 'neither'. """""",
        validator=strict_discrete_set,
        values={'rising': 'RISING', 'falling': 'FALLING', 'neither': 'NEITHER'},
        map_values=True,
    )

    long_integration_time = Channel.control(
        "":SENS{ch}:LINT:TIME?"", "":SENS{ch}:LINT:TIME %g"",
        """"""A floating point property that controls the long integration time
        in seconds, which takes on values in the range of 0.850 for 60 Hz and
         0.840 for 50 Hz up to 60. """""",
        validator=truncated_range,
        values=[0.840, 60],
    )

    def long_integration_time_auto(self):
        """"""Arranges for the instrument to control integration times. """"""
        self.write("":SENS{ch}:LINT:TIME:AUTO"")

    long_integration_trigger_level = Channel.control(
        "":SENS{ch}:LINT:TLEV?"", "":SENS{ch}:LINT:TLEV %g"",
        """"""A floating point property that controls the long integration trigger
        level in amps, which takes values between 0 and 5. """""",
        validator=truncated_range,
        values=[0, 5],
    )

    long_integration_timeout = Channel.control(
        "":SENS{ch}:LINT:TOUT?"", "":SENS{ch}:LINT:TOUT %g"",
        """"""A floating point property that controls the long integration timeout
        in seconds, which takes values between 1 and 63. """""",
        validator=truncated_range,
        values=[1, 63],
    )

    long_integration_fast_enabled = Channel.control(
        "":SENS{ch}:LINT:FAST?"", "":SENS{ch}:LINT:FAST %d"",
        """"""A boolean property that controls whether long integration fast
        readings are enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    long_integration_search_enabled = Channel.control(
        "":SENS{ch}:LINT:SEAR?"", "":SENS{ch}:LINT:SEAR %d"",
        """"""A boolean property that controls whether long integration search
        is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    long_integration_detect_enabled = Channel.control(
        "":SENS{ch}:LINT:DET?"", "":SENS{ch}:LINT:DET %d"",
        """"""A boolean property that controls whether long integration detection
        mode is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_voltage = Channel.control(
        "":SOUR{ch}:VOLT?"", "":SOUR{ch}:VOLT %g"",
        """"""A floating point property that controls the source voltage in volts,
        which takes values between 0 and 15. """""",
        validator=truncated_range,
        values=[0, 15],
    )

    source_voltage_protection = Channel.control(
        "":SOUR{ch}:VOLT:PROT?"", "":SOUR{ch}:VOLT:PROT %g"",
        """"""A floating point property that controls the source voltage protection
        offset in volts, which takes values between 0 and 8. """""",
        validator=truncated_range,
        values=[0, 8],
    )

    source_voltage_protection_enabled = Channel.measurement(
        "":SOUR{ch}:VOLT:PROT:STAT?"",
        """"""A boolean property that returns the source voltage protection state.
        If this property is True, the source has been shut off in accordance
        with the source voltage protection settings. If this property is False,
        the source has not been shut off due to voltage protection. """""",
        cast=bool
    )

    source_voltage_protection_clamp_enabled = Channel.control(
        "":SOUR{ch}:VOLT:PROT:CLAM?"", "":SOUR{ch}:VOLT:PROT:CLAM %d"",
        """"""A boolean property that controls whether source voltage protection
        clamp is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_current_limit = Channel.control(
        "":SOUR{ch}:CURR?"", "":SOUR{ch}:CURR %g"",
        """"""A floating point property that controls the source current limit in
        amps, which takes values between 0.006 and 5. """""",
        validator=truncated_range,
        values=[0.006, 5],
    )

    source_current_limit_type = Channel.control(
        "":SOUR{ch}:CURR:TYPE?"", "":SOUR{ch}:CURR:TYPE %s"",
        """"""A string property that controls source current limit type, which can
        take the values 'limit' or 'trip'. """""",
        validator=strict_discrete_set,
        values={'limit': 'LIM', 'trip': 'TRIP'},
        map_values=True,
    )

    source_current_limit_enabled = Channel.measurement(
        "":SOUR{ch}:CURR:STAT?"",
        """"""A boolean property that returns the source current limit state. If
        this property is True, the source is in either in current limit mode,
        or has tripped (shut off), based on the `source_current_limit_type`
        setting. If this property is False, the source is not being limited and
        has not been tripped. """""",
        cast=bool
    )

    last_reading = Channel.measurement(
        "":FETCH{ch}?"",
        """"""A floating point property that returns the last reading. """"""
    )

    last_readings = Channel.measurement(
        "":FETCH{ch}:ARR?"",
        """"""A floating point array property that returns the last readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    reading = Channel.measurement(
        "":READ{ch}?"",
        """"""A floating point property that triggers and returns a reading
        in accordance with sense_mode. """"""
    )

    readings = Channel.measurement(
        "":READ{ch}:ARR?"",
        """"""A floating point array property that triggers and returns readings
        in accordance with sense_mode. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    measured_voltage = Channel.measurement(
        "":MEAS{ch}:VOLT?"",
        """"""A floating point property that triggers and returns a voltage
        reading. """"""
    )

    measured_voltages = Channel.measurement(
        "":MEAS{ch}:ARR:VOLT?"",
        """"""A floating point array property that triggers and returns
        voltage readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    measured_current = Channel.measurement(
        "":MEAS{ch}:CURR?"",
        """"""A floating point property that triggers and returns a current
        reading. """"""
    )

    measured_currents = Channel.measurement(
        "":MEAS{ch}:ARR:CURR?"",
        """"""A floating point array property that triggers and returns
        current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    dvm_voltage = Channel.measurement(
        "":MEAS{ch}:DVM?"",
        """"""A floating point property that triggers and returns a DVM voltage
        reading. """"""
    )

    dvm_voltages = Channel.measurement(
        "":MEAS{ch}:ARR:DVM?"",
        """"""A floating point array property that triggers and returns
        DVM voltage readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    pulse_current = Channel.measurement(
        "":MEAS{ch}:PCUR?"",
        """"""A floating point property that returns a pulse current reading. """"""
    )

    pulse_currents = Channel.measurement(
        "":MEAS{ch}:ARR:PCUR?"",
        """"""A floating point array property that triggers and returns
        pulse current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    long_integration_current = Channel.measurement(
        "":MEAS{ch}:LINT?"",
        """"""A floating point property that returns a long integration current
        reading. """"""
    )

    long_integration_currents = Channel.measurement(
        "":MEAS{ch}:ARR:LINT?"",
        """"""A floating point array property that triggers and returns
        long integration current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )


class BatteryChannel(Keithley2306Channel):
    """""" Implementation of a Keithley 2306 battery channel. """"""

    impedance = Keithley2306Channel.control(
        "":OUTPUT{ch}:IMP?"", "":OUTPUT{ch}:IMP %g"",
        """"""A floating point property that controls the output impedance in ohms.
        Takes values from 0 to 1, in 10 milliohm steps."""""",
        validator=truncated_range,
        values=[0, 1],
    )

    pulse_current_step_enabled = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP?"", "":SENS{ch}:PCUR:STEP %d"",
        """"""A boolean property that controls whether a series of pulse current
        step measurements is enabled."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_step_up_count = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:UP?"", "":SENS{ch}:PCUR:STEP:UP %d"",
        """"""An integer property that controls the number of up steps. Takes
        values from 0 to 20 (max is both up and down combined). """""",
        validator=truncated_range,
        values=[0, 20],
    )

    pulse_current_step_down_count = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:DOWN?"", "":SENS{ch}:PCUR:STEP:DOWN %d"",
        """"""An integer property that controls the number of down steps. Takes
        values from 0 to 20 (max is both up and down combined). """""",
        validator=truncated_range,
        values=[0, 20],
    )

    pulse_current_step_time = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:TIME?"", "":SENS{ch}:PCUR:STEP:TIME %g"",
        """"""A floating point property that controls the integration time for up
        plus down steps in seconds. Takes values from 33.33333e-06 to 100e-3. """""",
        validator=truncated_range,
        values=[33.33333e-06, 100e-3],
    )

    pulse_current_step_timeout = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:TOUT?"", "":SENS{ch}:PCUR:STEP:TOUT %g"",
        """"""A floating point property that controls the integration timeout for
        pulse current steps in seconds (for all but the first step). Takes values
        from 2e-3 to 200e-3. """""",
        validator=truncated_range,
        values=[2e-3, 200e-3],
    )

    pulse_current_step_timeout_initial = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:TOUT:INIT?"", "":SENS{ch}:PCUR:STEP:TOUT:INIT %g"",
        """"""A floating point property that controls the integration timeout for
        the initial pulse current step in seconds. Takes values from 10e-3
        to 60. """""",
        validator=truncated_range,
        values=[10e-3, 60],
    )

    pulse_current_step_delay = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:DEL?"", "":SENS{ch}:PCUR:STEP:DEL %g"",
        """"""A floating point property that controls the pulse current step delay
        in seconds. Takes values from 0 to 100e-3 in 10e-6 increments. """""",
        validator=truncated_range,
        values=[0, 100e-3],
    )

    pulse_current_step_range = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:STEP:RANG?"", "":SENS{ch}:PCUR:STEP:RANG %g"",
        """"""A floating point property that controls the pulse current step trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    pulse_current_trigger_level_range = Keithley2306Channel.control(
        "":SENS{ch}:PCUR:SYNC:TLEV:RANG?"", "":SENS{ch}:PCUR:SYNC:TLEV:RANG %g"",
        """"""A floating point property that controls the pulse current trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    long_integration_trigger_level_range = Keithley2306Channel.control(
        "":SENS{ch}:LINT:TLEV:RANG?"", "":SENS{ch}:LINT:TLEV:RANG %g"",
        """"""A floating point property that controls the long integration trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    def pulse_current_step(self, step_number):
        """"""Create a new current step point for this instrument.

        :param: step_number:
            int: the number of the step to be created
        :type: :class:`.Step`

        """"""
        return Step(self.parent, step_number)


class Step(Channel):
    """""" Implementation of a Keithley 2306 step. """"""
    placeholder = 'step'
    trigger_level = Channel.control(
        "":SENS:PCUR:STEP:TLEV{step}?"", "":SENS:PCUR:STEP:TLEV{step} %g"",
        """"""A floating point property that controls the pulse current step trigger
        level range in amps. Takes values from 0 up to the range set via
        pulse_current_step_range."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    def __init__(self, instrument, number, **kwargs):
        super().__init__(instrument, number, **kwargs)


class Relay(Channel):
    """""" Implementation of a Keithley 2306 relay. """"""

    closed = Channel.control(
        "":OUTP:REL{ch}?"", "":OUTP:REL{ch} %s"",
        """"""A boolean property that controls whether the relay is closed (True)
        or open (False). """""",
        validator=strict_discrete_set,
        values={True: 'ONE', False: 'ZERO'},
        map_values=True
    )


class Keithley2306(Instrument):
    """""" Represents the Keithley 2306 Dual Channel Battery/Charger Simulator.
    """"""

    def __init__(self, adapter, name=""Keithley 2306"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ch1 = BatteryChannel(self, 1)
        self.ch2 = Keithley2306Channel(self, 2)
        self.relay1 = Relay(self, 1)
        self.relay2 = Relay(self, 2)
        self.relay3 = Relay(self, 3)
        self.relay4 = Relay(self, 4)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """"""A boolean property that controls whether the display is enabled,
        takes values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    display_brightness = Instrument.control(
        "":DISP:BRIG?"", "":DISP:BRIG %g"",
        """"""A floating point property that controls the display brightness,
        takes values beteween 0.0 and 1.0. A blank display is 0.0,
        1/4 brightness is for values less or equal to 0.25, otherwise 1/2
        brightness for values less than or equal to 0.5, otherwise 3/4
        brightness for values less than or equal to 0.75, otherwise full
        brightness. """""",
        validator=truncated_range,
        values=[0, 1],
    )

    display_channel = Instrument.control(
        "":DISP:CHAN?"", "":DISP:CHAN %d"",
        """"""An integer property that controls the display channel, takes
        values 1 or 2. """""",
        validator=strict_discrete_set,
        values=[1, 2],
    )

    display_text_data = Instrument.control(
        "":DISP:TEXT:DATA?"", "":DISP:TEXT:DATA \""%s\"""",
        """"""A string property that control text to be displayed, takes strings
        up to 32 characters. """""",
        get_process=lambda v: v.replace('""', '')
    )

    display_text_enabled = Instrument.control(
        "":DISP:TEXT:STAT?"", "":DISP:TEXT:STAT %d"",
        """"""A boolean property that controls whether display text is enabled,
        takes values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    both_channels_enabled = Instrument.setting(
        "":BOTHOUT%s"",
        """"""A boolean setting that controls whether both channel outputs are
        enabled, takes values of True or False. """""",
        validator=strict_discrete_set,
        values={True: ""ON"", False: ""OFF""},
        map_values=True,
    )

    def ch(self, channel_number):
        """"""Get a channel from this instrument.

        :param: channel_number:
            int: the number of the channel to be selected
        :type: :class:`.Keithley2306Channel`

        """"""
        if channel_number == 1:
            return self.ch1
        elif channel_number == 2:
            return self.ch2
        else:
            raise ValueError(""Invalid channel number. Must be 1 or 2."")

    def relay(self, relay_number):
        """"""Get a relay channel from this instrument.

        :param: relay_number:
            int: the number of the relay to be selected
        :type: :class:`.Relay`

        """"""
        if relay_number == 1:
            return self.relay1
        elif relay_number == 2:
            return self.relay2
        elif relay_number == 3:
            return self.relay3
        elif relay_number == 4:
            return self.relay4
        else:
            raise ValueError(""Invalid relay number. Must be 1, 2, 3, or 4"")
"
61,https://www.keysight.com/us/en/assets/3119-1067/data-sheets/5992-4217.pdf,https://en.wikipedia.org/wiki/Laser_diode,"[OrderedDict([('id', 'attyzP9nvI5xJDqWR'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/L_V9iWDE7yUJ4-Tp6WVzaA/v5fghNcRu31VSPiuPGibgdkTQ845HzfmJsDTnmnJBmvpJwZRqE79oqfSzIL6QTQJg2JUwhLvqfP5mlGSMvByodPOV797YSwTL7NmHPeggzcgXDuaKGz7iXB1elPtoVAT/RFVo-h7pMnJhUQ0BHmGKXE574LMB_XwWMFSa8R0TmOw'), ('filename', 'N7776C_FR_TRANS_SHAD_1600x900.png'), ('size', 1045757), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/oCut-Z_0jSRzJ71YyT4zfA/R0yMprNxcqvwxyelhe5iWZ1ih-67QViybsGyXX7MhwPXzRrnT5bRWtLSOlnC1mwauLqpMXXSTcoGdHFEZ7tbNQ/cLnCpzMiy_PEMUBuhEEv68z2PTFVUsevsr6aHHcV9Mc'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/r9vCEuMTDJHUPT98fbz1wQ/20Bd4Rb4pIWSKZFZfFcXHqkvZQmOYEz9dsV9C5Gw4g7D-iYlHZrt_ocMbbB1_mEKUj2KJOmB8NtgzGBSfoez4A/iH-9iyXEVQj0_4Gsu7C7DZKFHz2KjMYlfcKgLE2AEjk'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9LVUbL5xTWEstWjaZBjAHA/hRXVjg3b4AI3owcrxYsAAGVMxlYB12EcxEAnu9r_xfriBpGM1YSLnWgqG1PcDKVyTj1VFxyMCQY-sjQAwIFD8Q/iS7s231qv0RqLZ_bqSQ3WVfGPWK4gqnSdDnlGF7cHcg'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125973/Instruments/Vendor%20Logos/Keysight.png,"The new Keysight N7776C top line tunable laser source is designed to reach best-in-class accuracy in static and swept operation for outstanding test efficiency. Two-way sweeps up to 200 nm/s speed with sub-picometer repeatability and without impacting the specified dynamic accuracy accelerate wavelength-dependent alignment processes and the automated calibration of wavelength-selective devices. Shorter time to testing and faster swept-wavelength tests help reduce test cost per device, improve test margins and lower the cost of ownership.

",https://www.keysight.com/us/en/product/N7776C/tunable-laser-source-high-power-lowest-sse-top-line.html,Keysightn 7776 C,319.0,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightN7776C.py,Pymeasure,https://github.com/pymeasure/pymeasure/tree/master/docs,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/megNNA5_wzuwWNCz6WDjcw/pQyuIu38l8MsHtaFtaOLmkMRzbqTDqGfMLlXBJhFa7ggZPbno9t2eqjBe10eReASLOJl_8haDklFBQFmKIcdqa3aD7V5mul-MgXSWAEryJk/0vNQYOLhY1SDrjXhjXsyVp32UY9MBoh8pi_b347YZ0c'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1RC4XJCrTJbUIlcqhOcJig/okl3Me440BMr3q1gjrB0ZgbQEfGUrmHNr0YTpKYJNQ2iNBR-or2oqc1R3G_ElqfSqNsuzpagWZH5DUqHJm_AZd7fQdW2NyQK-QFmn2ayFqk/naZmSvm7PJ-qjwjEUyWtpMXIGRSofD6fBelDaBktR74'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ybeEhpT9SyxU5RIxr0NP4w/SXZN1vvm029SORyK_WT2NOYhg1wK1kZkt6bw-kFlMyvaJpSNxjwYZCRBej3Tn-swtIcVXr5OHTSVnLpU_pRha9WM0LM87R1CX-drKxV-L3o/ISIa5a59ilLldrkBEq_PsDFCkb9vZUTJAWjxaxB9OLc'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qn98Xihw8ou906fGgF2Dzw/9aKhJN716Y8Pl17Bxi7ANhxbQZOC7susFJYn78DkZCpyBZwyTBzys51YJWrwbjBAMOYQksvWcmhCIwnWNgNN2-jkr7LQkp8OlFQ1S9MzEUU/l4F-gkk5SwbmwZaMvHeWmpzk02MUYQ_xsEShq-bDEBk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782473/Instruments/Lasers/Keysight-N7776C/Keysight-N7776C.png,Keysight N7776C,Write a Python script that uses Pymeasure to connect to a Keysight N7776C Lasers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

WL_RANGE = [1480, 1620]
LOCK_PW = 1234


class KeysightN7776C(Instrument):
    """"""
    This represents the Keysight N7776C Tunable Laser Source interface.

    .. code-block:: python

        laser = N7776C(address)
        laser.sweep_wl_start = 1550
        laser.sweep_wl_stop = 1560
        laser.sweep_speed = 1
        laser.sweep_mode = 'CONT'
        laser.output_enabled = 1
        while laser.sweep_state == 1:
            log.info('Sweep in progress.')
        laser.output_enabled = 0

    """"""

    def __init__(self, adapter, name=""N7776C Tunable Laser Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs)

    locked = Instrument.control(
        ':LOCK?', ':LOCK %g,' + str(LOCK_PW),
        """""" Boolean property controlling the lock state (True/False) of the laser source"""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    output_enabled = Instrument.control(
        'SOUR0:POW:STAT?', 'SOUR0:POW:STAT %g',
        """""" Boolean Property that controls the state (on/off) of the laser source """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    _output_power_mW = Instrument.control(
        'SOUR0:POW?', 'SOUR0:POW %f mW',
        """""" Floating point value indicating the laser output power in mW."""""",
        get_process=lambda v: v * 1e3
    )

    _output_power_dBm = Instrument.control(
        'SOUR0:POW?', 'SOUR0:POW %f dBm',
        """""" Floating point value indicating the laser output power in dBm.""""""
    )

    _output_power_unit = Instrument.control(
        'SOUR0:POW:UNIT?', 'SOUR0:POW:UNIT %g',
        """""" String parameter controlling the power unit used internally by the laser."""""",
        map_values=True,
        values={'dBm': 0, 'mW': 1}
    )

    @property
    def output_power_mW(self):
        self._output_power_unit = 'mW'
        return self._output_power_mW

    @output_power_mW.setter
    def output_power_mW(self, new_power):
        self._output_power_mW = new_power

    @property
    def output_power_dBm(self):
        self._output_power_unit = 'dBm'
        return self._output_power_dBm

    @output_power_dBm.setter
    def output_power_dBm(self, new_power):
        self._output_power_dBm = new_power

    trigger_out = Instrument.control(
        'TRIG0:OUTP?', 'TRIG0:OUTP %s',
        """""" Specifies if and at which point in a sweep cycle an output trigger
        is generated and arms the module. """""",
        validator=strict_discrete_set,
        values=['DIS', 'STF', 'SWF', 'SWST']
    )

    trigger_in = Instrument.control('TRIG0:INP?', 'TRIG0:INP %s',
                                    """""" Sets the incoming trigger response and arms the module. """""",
                                    validator=strict_discrete_set,
                                    values=['IGN', 'NEXT', 'SWS'])

    wavelength = Instrument.control('sour0:wav?', 'sour0:wav %fnm',
                                    """""" Absolute wavelength of the output light (in nanometers)"""""",
                                    validator=strict_range,
                                    values=WL_RANGE,
                                    get_process=lambda v: v * 1e9)

    sweep_wl_start = Instrument.control('sour0:wav:swe:star?', 'sour0:wav:swe:star %fnm',
                                        """""" Start Wavelength (in nanometers) for a sweep."""""",
                                        validator=strict_range,
                                        values=WL_RANGE,
                                        get_process=lambda v: v * 1e9)
    sweep_wl_stop = Instrument.control('sour0:wav:swe:stop?', 'sour0:wav:swe:stop %fnm',
                                       """""" End Wavelength (in nanometers) for a sweep."""""",
                                       validator=strict_range,
                                       values=WL_RANGE,
                                       get_process=lambda v: v * 1e9)

    sweep_step = Instrument.control('sour0:wav:swe:step?', 'sour0:wav:swe:step %fnm',
                                    """""" Step width of the sweep (in nanometers)."""""",
                                    validator=strict_range,
                                    values=[0.0001, WL_RANGE[1] - WL_RANGE[0]],
                                    get_process=lambda v: v * 1e9)
    sweep_speed = Instrument.control('sour0:wav:swe:speed?', 'sour0:wav:swe:speed %fnm/s',
                                     """""" Speed of the sweep (in nanometers per second)."""""",
                                     validator=strict_discrete_set,
                                     values=[0.5, 1, 50, 80, 200],
                                     get_process=lambda v: v * 1e9)
    sweep_mode = Instrument.control('sour0:wav:swe:mode?', 'sour0:wav:swe:mode %s',
                                    """""" Sweep mode of the swept laser source """""",
                                    validator=strict_discrete_set,
                                    values=['STEP', 'MAN', 'CONT'])
    sweep_twoway = Instrument.control('sour0:wav:swe:rep?', 'sour0:wav:swe:rep %s',
                                      """"""Sets the repeat mode. Applies in stepped,continuous and
                                      manual sweep mode."""""",
                                      validator=strict_discrete_set,
                                      map_values=True,
                                      values={False: 'ONEW', True: 'TWOW'})
    _sweep_params_consistent = Instrument.measurement(
        'sour0:wav:swe:chec?',
        """"""Returns whether the currently set sweep parameters (sweep mode, sweep start,
        stop, width, etc.) are consistent. If there is a
        sweep configuration problem, the laser source is not
        able to pass a wavelength sweep."""""")

    sweep_points = Instrument.measurement(
        'sour0:read:points? llog',
        """"""Returns the number of datapoints that the :READout:DATA?
        command will return."""""")

    sweep_state = Instrument.control('sour0:wav:swe?', 'sour0:wav:swe %g',
                                     """""" State of the wavelength sweep. Stops, starts, pauses
                                     or continues a wavelength sweep. Possible state values are
                                     0 (not running),
                                     1 (running) and
                                     2 (paused).
                                     Refer to the N7776C user manual for exact usage of the
                                     paused option. """""",
                                     validator=strict_discrete_set,
                                     values=[0, 1, 2])

    wl_logging = Instrument.control('SOUR0:WAV:SWE:LLOG?', 'SOUR0:WAV:SWE:LLOG %g',
                                    """""" State (on/off) of the lambda logging feature of the
                                    laser source."""""",
                                    validator=strict_discrete_set,
                                    map_values=True,
                                    values={True: 1, False: 0})

    def valid_sweep_params(self):
        response = int(self._sweep_params_consistent[0])
        if response == 0:
            return True
        elif response == 368:
            log.warning('End Wavelength <= Start Wavelength.')
        elif response == 369:
            log.warning('Sweep time too small.')
        elif response == 370:
            log.warning('Sweep time too big.')
        elif response == 371:
            log.warning('Trigger Frequency too large.')
        elif response == 372:
            log.warning('Stepsize too small.')
        elif response == 373 or response == 378:
            log.warning('Number of triggers exceeds allowed limit.')
        elif response == 374:
            log.warning('The only allowed modulation source with lambda logging \
                        function is coherence control.')
        elif response == 375:
            log.warning('Lambda logging only works Step Finished output trigger configuration')
        elif response == 376:
            log.warning('Lambda logging can only be done in continuous sweep mode')
        elif response == 377:
            log.warning('The step size must be a multiple of the smallest possible step size')
        elif response == 379:
            log.warning('Continuous Sweep and Modulation on.')
        elif response == 380:
            log.warning('Start Wavelength is too small.')
        elif response == 381:
            log.warning('End Wavelength is too large.')
        else:
            log.warning('Unknown Error!')
        return False

    def next_step(self):
        """"""
        Performs the next sweep step in stepped sweep if it is paused or in manual mode.
        """"""
        self.write('sour0:wav:swe:step:next')

    def previous_step(self):
        """"""
        Performs one sweep step backwards in stepped sweep if its paused or in manual mode.
        """"""
        self.write('sour0:wav:swe:step:prev')

    def get_wl_data(self):
        """"""
        Function returning the wavelength data logged in the internal memory of the laser
        """"""
        # Using pyvisa's method bypassing the normal read.
        return np.array(self.adapter.connection.query_binary_values('sour0:read:data? llog',
                        datatype=u'd'))

    def close(self):
        """"""
        Fully closes the connection to the instrument through the adapter connection.
        """"""
        self.adapter.close()
"
62,https://download.tek.com/datasheet/3GW_15314_6.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attdL6BvdnNPHWFdN'), ('width', 500), ('height', 344), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kEIn8tvwbvyQhiZgoUsNOg/EWRkUt-lSXvzMf9NB0LNstLxe-iw9rpurnJb-4Oz9XyTSjx8ELWUjE2j62I7EvL3wA3lgeCuU2I_1324O3pmv3SxpK8HnLHbgpb39jgxAew/Mx6ivencgyPxGGpUYUSdjBPilRdiGN3mpKcbU-T3ac0'), ('filename', 'TDS2000C-1.jpg'), ('size', 27591), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/35tOqAHaI17owrAdxSbKgw/BfvB26JhLkF-9K10tGNHcz2imQwBxfzXky0ZGPUpi9PXgDtvGDddKXCG3NUBZclR0s1hAz6GWz2r3Z5oJ5JdAg/z_Z3oqpqOv78Fb_2R2J-6-EjOU8EMJ33aDiI4CWZt30'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TSf_C9Nu9skisTLF91Tvhg/X9AILsbqyvUQocg6i_OXV9tLgx4TlQ-ZJUbmwAio6PUn1dsu1ZdSSWhM3PNFJ0DpdfLda7ISdeXeESLpWNE6JQ/q39NmWYSvfdCvQWvvK_v3k2TXYHR-bYCFo4nSjjkoTs'), ('width', 500), ('height', 344)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PAZi7T3cLRY39OnSTc2sOg/pUFFsT4CZBl6L77Qg16JvV2s1nBiGHtz1HsvzkWIPQn6t9aRuDDJ7EAjyVJANlaFAqkLlAuuVTv1F3OigK76dw/VFMt43TzNaukKh4jrAzEFmr9Au2smo7-aiyCuEAYqLY'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"The TDS1000 Series and TDS2000 Series digital storage oscilloscopes deliver an unbeatable combination of superior performance, unmatched ease-of-use, and affordability in an ultra lightweight, portable package.",https://www.tek.com/en/products/oscilloscopes/tds2000-digital-storage-oscilloscope,TDS 2000,540.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/tektronix/tds2000.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/tektronix/tds2000.html,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782473/Instruments/Oscilloscopes/TDS2000/TDS2000.jpg,TDS2000,Write a Python script that uses Pymeasure to connect to a TDS2000 Oscilloscopes,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


class TDS2000(Instrument):
    """""" Represents the Tektronix TDS 2000 Oscilloscope
    and provides a high-level for interacting with the instrument
    """"""

    class Measurement:

        SOURCE_VALUES = ['CH1', 'CH2', 'MATH']

        TYPE_VALUES = [
            'FREQ', 'MEAN', 'PERI', 'PHA', 'PK2', 'CRM',
            'MINI', 'MAXI', 'RIS', 'FALL', 'PWI', 'NWI'
        ]

        UNIT_VALUES = ['V', 's', 'Hz']

        def __init__(self, parent, preamble=""MEASU:IMM:""):
            self.parent = parent
            self.preamble = preamble

        @property
        def value(self):
            return self.parent.values(""%sVAL?"" % self.preamble)

        @property
        def source(self):
            return self.parent.ask(""%sSOU?"" % self.preamble).strip()

        @source.setter
        def source(self, value):
            if value in TDS2000.Measurement.SOURCE_VALUES:
                self.parent.write(f""{self.preamble}SOU {value}"")
            else:
                raise ValueError(""Invalid source ('{}') provided to {}"".format(
                                 self.parent, value))

        @property
        def type(self):
            return self.parent.ask(""%sTYP?"" % self.preamble).strip()

        @type.setter
        def type(self, value):
            if value in TDS2000.Measurement.TYPE_VALUES:
                self.parent.write(f""{self.preamble}TYP {value}"")
            else:
                raise ValueError(""Invalid type ('{}') provided to {}"".format(
                                 self.parent, value))

        @property
        def unit(self):
            return self.parent.ask(""%sUNI?"" % self.preamble).strip()

        @unit.setter
        def unit(self, value):
            if value in TDS2000.Measurement.UNIT_VALUES:
                self.parent.write(f""{self.preamble}UNI {value}"")
            else:
                raise ValueError(""Invalid unit ('{}') provided to {}"".format(
                                 self.parent, value))

    def __init__(self, adapter, name=""Tektronix TDS 2000 Oscilliscope"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.measurement = TDS2000.Measurement(self)
"
63,https://www.danfysik.com/media/1098/model-854-datasheet.pdf,https://www.danfysik.com/en/products/power-supplies/superconducting/,"[OrderedDict([('id', 'att1indeo2AmmjpTb'), ('width', 1008), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/q1ff76gusTDA9sWhl2Y8aA/2jBJ8oZ2vXjhgym7yR93BVxs8Csa3lJJ-qRgwu4XVsjoysfcgRCdCoCfIM6BadfULyKEAE2ur8IYENsnL2i3RgNsM0Ihw2UbpML2jqVAjMFYT6xTreTpUaQKwQR9OM9q/R46007hHWw7C0IEdz1eAxvMQ0yra1EaoytuxUe62n7U'), ('filename', 'SYSTEM-8500--Model-854.jpeg'), ('size', 153786), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jiEbkquPLM3a3Gi47ttmBQ/nhrjgc4Dzpdk7cq_T5yB60R09YmT-uPVfYNVzhgVpALv9F-5BkYNU6yH_z8uDvpILs7Cgm7PGCCS_RTd7M1u_g/Spp3aJjG_J54REXAG62qRFWK1DhrB7j1cJ_hJzX9xXQ'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PbHVCOHbU5v9GN1Td5t7dA/VhJE94K1_JNLbMJdld_WYybRaQtF8Ismzlrcc4jtEO8h8HEcLTrEqxlMH4UEFubKzKctdsFtcUsrNPLkwRdetQ/_O8Lh5URZqBddKJw8KsEJE9gjLBh-9p6Rwx2vHMiIeY'), ('width', 645), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/d1xs1-d4UJW8thFqzjAQBw/SpFMtA9VlIYM50pS4wghSUDfWZZKl5aRJGZ4VJ0kcBBZkkuLqP8BitZa3HBBqXQ1O0ChbkCGP97iKoiKpDtieA/0FbHffFYKGMBCBs8Rq0pOZwQzMf6LCgJmCF9UYE2sBY'), ('width', 3000), ('height', 3000)]))]))])]",13.0,Denmark,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125953/Instruments/Vendor%20Logos/Danfysik.png,The System 8500 Power Supply program offers the ultrastable Model 854 specially designed for powering magnets in MRI applications,https://www.danfysik.com/media/1098/model-854-datasheet.pdf,Danfysik 8500,116.0,['Power Supplies'],"Power Supply for Super conducting Application
","Danfysik accelerator system and accelerator components are in service at most particle accelerator facilities worldwide
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/danfysik/danfysik8500.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/danfysik/danfysik8500.html,Danfysik,"[OrderedDict([('id', 'atths1QV2NfuQ9sTz'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LrBjyy6kZohIAILrXZySkw/2umCLE2mtIQxVr1uxBHf0YyBWTizgcPjBJquid_MdtVQtxgb4FAiLCzaaEoWTcScLuWIQ8lBIJzMOF3ysRVliOSxxcphrc5QXCjzJUWHwzM/KEUMNbt9fseTZfeGT5B52JEXu3PROabpXB7b0h61mT4'), ('filename', '52408-27d3b659.png'), ('size', 3404), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/h7FyqRwWUZhUoLqhX7gysw/TKTxUajpNkzqCHoftPfNIF3dRbkB2UawN1BCYKdcvE_FTBZDmTnVe8MRstIBNv-CSR_8BUCRF1gukVMx3fM1vQ/Mqxtcrv3_Xt3Geol3mXNcTNMvUBHDeL9wFm7-0WWfFc'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fNLg72IkVVhEhNoDd2mAQQ/6pcL7PDAQKWUz1el3jamsOF7QOfy8msibQiYG_Zh43BtLASTy3sCV7Lk_cOucuh4daiCdBaugTF7pFeiwZeQ4g/hynvQnYPLom69iRLhS7wbgvBrFzoLZ4nlmGznis5PNU'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/QBBToEtV1JjkcMsFtnewtA/9H-GYnyUs6fzIAjxp2k6HIwr32_gXd2QapzK1nouUpDrtAOJ17fZV_3_9cD9TlgH2o4Bp_8iSLKdMmhiF8yydQ/j2V5Y6bholTOKIJMGw17r7PqZXivpapnCbFmVt85EmM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.danfysik.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782474/Instruments/Power%20Supplies/SYSTEM-8500---Model-854/SYSTEM-8500---Model-854.jpg,SYSTEM 8500-Model 854,Write a Python script that uses Pymeasure to connect to a SYSTEM 8500-Model 854 Power Supplies,,,,Github Project too ld,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument, RangeException

from time import sleep
import numpy as np
import re


class Danfysik8500(Instrument):
    """""" Represents the Danfysik 8500 Electromanget Current Supply
    and provides a high-level interface for interacting with the
    instrument

    To allow user access to the Prolific Technology PL2303 Serial port adapter
    in Linux, create the file:
    :code:`/etc/udev/rules.d/50-danfysik.rules`, with contents:

    .. code-block:: none

        SUBSYSTEMS==""usb"",ATTRS{idVendor}==""067b"",ATTRS{idProduct}==""2303"",MODE=""0666"",SYMLINK+=""danfysik""

    Then reload the udev rules with:

    .. code-block:: bash

        sudo udevadm control --reload-rules
        sudo udevadm trigger

    The device will be accessible through the port :code:`/dev/danfysik`.
    """"""

    id = Instrument.measurement(
        ""PRINT"", """""" Reads the idenfitication information. """"""
    )

    def __init__(self, adapter, name=""Danfysik 8500 Current Supply"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            write_termination=""\r"",
            read_termination=""\r"",
            timeout=500,
            **kwargs
        )
        # TODO verify serial connection.
        self.write(""ERRT"")  # Use text error messages
        self.write(""UNLOCK"")  # Unlock from remote or local mode

    def read(self):
        """""" Read the device and raise exceptions if errors are reported by the instrument.

        :returns: String ASCII response of the instrument
        :raises: An :code:`Exception` if the Danfysik raises an error
        """"""
        result = super().read()
        search = re.search(r""^\?\x07\s(?P<name>.*)$"", result, re.MULTILINE)
        if search:
            raise Exception(""Danfysik raised the error: %s"" % (
                            search.groups()[0]))
        else:
            return result

    def local(self):
        """""" Sets the instrument in local mode, where the front
        panel can be used.
        """"""
        self.write(""LOC"")

    def remote(self):
        """""" Sets the instrument in remote mode, where the the
        front panel is disabled.
        """"""
        self.write(""REM"")

    @property
    def polarity(self):
        """""" The polarity of the current supply, being either
        -1 or 1. This property can be set by suppling one of
        these values.
        """"""
        return 1 if self.ask(""PO"").strip() == '+' else -1

    @polarity.setter
    def polarity(self, value):
        polarity = ""+"" if value > 0 else ""-""
        self.write(""PO %s"" % polarity)

    def reset_interlocks(self):
        """""" Resets the instrument interlocks.
        """"""
        self.write(""RS"")

    def enable(self):
        """""" Enables the flow of current.
        """"""
        self.write(""N"")

    def disable(self):
        """""" Disables the flow of current.
        """"""
        self.write(""F"")

    def is_enabled(self):
        """""" Returns True if the current supply is enabled.
        """"""
        return self.status_hex & 0x800000 == 0

    @property
    def status_hex(self):
        """""" The status in hexadecimal. This value is parsed in
        :attr:`~.Danfysik8500.status` into a human-readable list.
        """"""
        status = self.ask(""S1H"")
        match = re.search(r'(?P<hex>[A-Z0-9]{6})', status)
        if match is not None:
            return int(match.groupdict()['hex'], 16)
        else:
            raise Exception(""Danfysik status not properly returned. Instead ""
                            ""got '%s'"" % status)

    @property
    def current(self):
        """""" The actual current in Amps. This property can be set through
        :attr:`~.current_ppm`.
        """"""
        return int(self.ask(""AD 8"")) * 1e-2 * self.polarity

    @current.setter
    def current(self, amps):
        if amps > 160 or amps < -160:
            raise RangeException(""Danfysik 8500 is only capable of sourcing ""
                                 ""+/- 160 Amps"")
        self.current_ppm = int((1e6 / 160) * amps)

    @property
    def current_ppm(self):
        """""" The current in parts per million. This property can be set.
        """"""
        return int(self.ask(""DA 0"")[2:])

    @current_ppm.setter
    def current_ppm(self, ppm):
        if abs(ppm) < 0 or abs(ppm) > 1e6:
            raise RangeException(""Danfysik 8500 requires parts per million ""
                                 ""to be an appropriate integer"")
        self.write(""DA 0,%d"" % ppm)

    @property
    def current_setpoint(self):
        """""" The setpoint for the current, which can deviate from the actual current
        (:attr:`~.Danfysik8500.current`) while the supply is in the process of setting the value.
        """"""
        return self.current_ppm * (160 / 1e6)

    @property
    def slew_rate(self):
        """""" The slew rate of the current sweep.
        """"""
        return float(self.ask(""R3""))

    def wait_for_current(self, has_aborted=lambda: False, delay=0.01):
        """""" Blocks the process until the current has stabilized. A
        provided function :code:`has_aborted` can be supplied, which
        is checked after each delay time (in seconds) in addition to the
        stability check. This allows an abort feature to be integrated.

        :param has_aborted: A function that returns True if the process should stop waiting
        :param delay: The delay time in seconds between each check for stability
        """"""
        self.wait_for_ready(has_aborted, delay)
        while not has_aborted() and not self.is_current_stable():
            sleep(delay)

    def is_current_stable(self):
        """""" Returns True if the current is within 0.02 A of the
        setpoint value.
        """"""
        return abs(self.current - self.current_setpoint) <= 0.02

    def is_ready(self):
        """""" Returns True if the instrument is in the ready state.
        """"""
        return self.status_hex & 0b10 == 0

    def wait_for_ready(self, has_aborted=lambda: False, delay=0.01):
        """""" Blocks the process until the instrument is ready. A
        provided function :code:`has_aborted` can be supplied, which
        is checked after each delay time (in seconds) in addition to the
        readiness check. This allows an abort feature to be integrated.

        :param has_aborted: A function that returns True if the process should stop waiting
        :param delay: The delay time in seconds between each check for readiness
        """"""
        while not has_aborted() and not self.is_ready():
            sleep(delay)

    @property
    def status(self):
        """""" A list of human-readable strings that contain
        the instrument status information, based on :attr:`~.status_hex`.
        """"""
        status = []
        indicator = self.ask(""S1"")
        if indicator[0] == ""!"":
            status.append(""Main Power OFF"")
        else:
            status.append(""Main Power ON"")
        # Skipping 5, 6 and 7 (from Appendix Manual on command S1)
        messages = {
            1: ""Polarity Normal"",
            2: ""Polarity Reversed"",
            3: ""Regulation Transformer is not equal to zero"",
            7: ""Spare Interlock"",
            8: ""One Transistor Fault"",
            9: ""Sum - Interlock"",
            10: ""DC Overcurrent (OCP)"",
            11: ""DC Overload"",
            12: ""Regulation Module Failure"",
            13: ""Preregulator Failure"",
            14: ""Phase Failure"",
            15: ""MPS Waterflow Failure"",
            16: ""Earth Leakage Failure"",
            17: ""Thermal Breaker/Fuses"",
            18: ""MPS Overtemperature"",
            19: ""Panic Button/Door Switch"",
            20: ""Magnet Waterflow Failure"",
            21: ""Magnet Overtemperature"",
            22: ""MPS Not Ready""
        }
        for index, message in messages.items():
            if indicator[index] == ""!"":
                status.append(message)
        return status

    def clear_ramp_set(self):
        """""" Clears the ramp set.
        """"""
        self.write(""RAMPSET C"")

    def set_ramp_delay(self, time):
        """""" Sets the ramp delay time in seconds.

        :param time: The time delay time in seconds
        """"""
        self.write(""RAMPSET %f"" % time)

    def start_ramp(self):
        """""" Starts the current ramp.
        """"""
        self.write(""RAMP R"")

    def add_ramp_step(self, current):
        """""" Adds a current step to the ramp set.

        :param current: A current in Amps
        """"""
        self.write(""R %.6f"" % (current / 160.))

    def stop_ramp(self):
        """""" Stops the current ramp.
        """"""
        self.ask(""RAMP S"")

    def set_ramp_to_current(self, current, points, delay_time=1):
        """""" Sets up a linear ramp from the initial current to a different
        current, with a number of points, and delay time.

        :param current: The final current in Amps
        :param points: The number of linear points to traverse
        :param delay_time: A delay time in seconds
        """"""
        initial_current = self.current
        self.clear_ramp_set()
        self.set_ramp_delay(delay_time)
        steps = np.linspace(initial_current, current, num=points)
        cmds = [""R %.6f"" % (step / 160.) for step in steps]
        self.write(""\r"".join(cmds))

    def ramp_to_current(self, current, points, delay_time=1):
        """""" Executes :meth:`~.set_ramp_to_current` and starts the ramp.
        """"""
        self.set_ramp_to_current(current, points, delay_time)
        self.start_ramp()

    # self.setSequence(0, [0, 10], [0.01])
    def set_sequence(self, stack, currents, times, multiplier=999999):
        """""" Sets up an arbitrary ramp profile with a list of currents (Amps)
        and a list of interval times (seconds) on the specified stack number
        (0-15)
        """"""
        self.clear_sequence(stack)
        if min(times) >= 1 and max(times) <= 65535:
            self.write(""SLOW %i"" % stack)
        elif min(times) >= 0.1 and max(times) <= 6553.5:
            self.write(""FAST %i"" % stack)
            times = [0.1 * x for x in times]
        else:
            raise RangeException(""Timing for Danfysik 8500 ramp sequence is""
                                 "" out of range"")
        for i in range(len(times)):
            self.write(""WSA %i,%i,%i,%i"" % (
                stack,
                int(6250 * abs(currents[i])),
                int(6250 * abs(currents[i + 1])), times[i])
            )
        self.write(""MULT %i,%i"" % (stack, multiplier))

    def clear_sequence(self, stack):
        """""" Clears the sequence by the stack number.

        :param stack: A stack number between 0-15
        """"""
        self.write(""CSS %i"" % stack)

    def sync_sequence(self, stack, delay=0):
        """""" Arms the ramp sequence to be triggered by a hardware
        input to pin P33 1&2 (10 to 24 V) or a TS command. If a
        delay is provided, the sequence will start after the delay.

        :param stack: A stack number between 0-15
        :param delay: A delay time in seconds
        """"""
        self.write(""SYNC %i, %i"" % (stack, delay))

    def start_sequence(self, stack):
        """""" Starts a sequence by the stack number.

        :param stack: A stack number between 0-15
        """"""
        self.write(""TS %i"" % stack)

    def stop_sequence(self):
        """""" Stops the currently running sequence.
        """"""
        self.write(""STOP"")

    def is_sequence_running(self, stack):
        """""" Returns True if a sequence is running with a given stack number

        :param stack: A stack number between 0-15
        """"""
        return re.search(""R%i,"" % stack, self.ask(""S2"")) is not None
"
68,https://www.thinksrs.com/downloads/pdfs/catalog/SG380c.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attJpMTKKFLWIt0jZ'), ('width', 2916), ('height', 2136), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mHfbnaDLwVaH-JSySpJT1w/3KNKFQ2ql9eFg6OkG-V-zp34ALbaJD-SjjI5kn1_dHJ_u9hb5nXCiqIzC3cLfIahBQzgCxV-4Miao9LJVWESNQHKCtGJdmtD_DXtaU0nrVg/zmznHNREz_VXtV0LM8T_8vZ0M19C7WS-RIlspWfVtWc'), ('filename', 'SG382 ReflectR.jpg'), ('size', 1271602), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Vn71MtWwF44P8stTaVzAxQ/H0dElBbRLQeKn-D78PtQLY5pd-DUDlqzSkxE3nn_jzgTydUkrthlPkLA6bdUBCSiIEQ65bQr00_FC5yP0IwlJA/7D30KGcWB4N5Ik0gOp6weR-SEZ8OtklDUREoYuRphNU'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cU1IkxP54jylG1ufKb0CLQ/DbiDA9bzElgBtDA8iYtqxqa9ZqiH0UKGxNfbXxzSbdAaVlOMqC6sc-XF9NNt9RAbNSFdf65ywEOtVfIEcSCCAw/4MyzD-Rp5eAvznEmZkUs72kM99H8CpFpmO9FYOoljVI'), ('width', 699), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/30i5g_U_hPimZXvpemZXzA/sJhMh3dJt1ZgEG4tBsonfcrVdCwqr5jdjkkB3DOCdT-Fwam1qrjyVEcQGb4gc3nM-LwqTSM3a9ptXlBiQkcTbw/E2dDY-MmNJlAcPTpLg4IWmVcUCy6n2KV_UbkG3KhlyI'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"The SG380 Series RF Signal Generators use a unique, innovative architecture (Rational Approximation Frequency Synthesis) to deliver ultra-high frequency resolution (1 µHz), excellent phase noise, and versatile modulation capabilities (AM, FM, ØM, pulse modulation and sweeps) at a fraction of the cost of competing designs. The standard models produce sine waves from DC to 2.025 GHz (SG382), 4.05 GHz (SG384) and 6.075 GHz (SG386).",https://www.thinksrs.com/products/sg380.html,SG 380,518.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sg380.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/index.html,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782478/Instruments/RF%20Signal%20Generator/SG-380/SG-380.jpg,SG 380,Write a Python script that uses Pymeasure to connect to a SG 380 RF Signal Generator,3900.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range


class SG380(Instrument):

    MOD_TYPES_VALUES = ['AM', 'FM', 'PM', 'SWEEP', 'PULSE', 'BLANK', 'IQ']

    MOD_FUNCTIONS = ['SINE', 'RAMP', 'TRIANGLE', 'SQUARE', 'NOISE', 'EXTERNAL']

    MIN_RF = 0.0

    MAX_RF = 4E9

    # TODO: restrict modulation depth to allowed values (depending on
    # frequency)
    fm_dev = Instrument.control(
        ""FDEV?"", ""FDEV%.6f"",
        """""" A floating point property that represents the modulation frequency
        deviation in Hz. This property can be set. """"""
    )

    rate = Instrument.control(
        ""RATE?"", ""RATE%.6f"",
        """""" A floating point property that represents the modulation rate
        in Hz. This property can be set. """"""
    )

    def __init__(self, adapter, name=""Stanford Research Systems SG380 RF Signal Generator"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    @property
    def has_doubler(self):
        """"""Gets the modulation type""""""
        return bool(self.ask(""OPTN? 2""))

    @property
    def has_IQ(self):
        """"""Gets the modulation type""""""
        return bool(self.ask(""OPTN? 3""))

    @property
    def frequency(self):
        """"""Gets RF frequency""""""
        return float(self.ask(""FREQ?""))

    @frequency.setter
    def frequency(self, frequency):
        """"""Defines RF frequency""""""
        if self.has_doubler:
            truncated_range(frequency, (SG380.MIN_RF, 2 * SG380.MAX_RF))
        else:
            truncated_range(frequency, (SG380.MIN_RF, SG380.MAX_RF))
        self.write(""FREQ%.6f"" % frequency)

    @property
    def mod_type(self):
        """"""Gets the modulation type""""""
        return SG380.MOD_TYPES_VALUES[int(self.ask(""TYPE?""))]

    @mod_type.setter
    def mod_type(self, type_):
        """"""Defines the modulation type""""""
        if type_ not in SG380.MOD_TYPES_VALUES:
            raise RuntimeError('Undefined modulation type')
        elif (type_ == 'IQ') and not self.has_IQ:
            raise RuntimeError('IQ option not installed')
        else:
            index = SG380.MOD_TYPES_VALUES.index(type_)
        self.write(""TYPE%d"" % index)

    @property
    def mod_function(self):
        """"""Gets the modulation function""""""
        return SG380.MOD_FUNCTIONS[int(self.ask(""MFNC?""))]

    @mod_function.setter
    def mod_func(self, function):
        """"""Defines the modulation function""""""
        if function not in SG380.MOD_FUNCTIONS:
            index = 1
        else:
            index = SG380.MOD_FUNCTIONS.index(function)
        self.write(""MFNC%d"" % index)
"
72,"https://www.anapico.com/products/rf-signal-generators/single-output-rf-and-microwave-signal-generators/apsin-g-series-up-to-26-ghz/#:~:text=and%20outdoor%20fields.-,Download%20Datasheet,-Request%20for%20Quote",https://www.anapico.com/category/rf-signal-generators/single-output-rf-and-microwave-signal-generators/,"[OrderedDict([('id', 'attso7NGDDHsmn9iZ'), ('width', 2083), ('height', 1516), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hpg3BPODZRy-tHyQ1CZ5rw/ecJj83wUJi6aGhdd-kNvXZ1oFYXPmktDVSzhgN3lCeYfR1-l-XkNbWJtlZbenriyiRs94rQfVf9YhvrSHbDVAhT9wWkzi7HqkU4vpb_8WN0/s81oYLjMiyuuES78lIreKGBfsLsrV7Xk0IixyPDtKJ0'), ('filename', 'Apsin-26G.jpg'), ('size', 310247), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WrSBYwbQ8atdyFPCXyDnZg/8gjUvIy9Fx9sZetqQPbEQ6f-YhscJAcCTeYQv74wownoOINEmAfj4dB9_MdlYx7Zzyz8YJj7UhPI4l1W_4eQcg/BhQo6lyyVjfPybDWpwLAFnp2zwkP9WT_m5R4yp-imx0'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/D0R8WqVzu9z1t4RDoVVKhA/KGlXZGONQyXAEewiWZSiI0Jd8yjaScjGe-V98nRE5foaobwUrevpiwTf5O3KyXZq8O20c1mjJcOhmtUwy7_LUQ/ytPPBjpjDFC_gVWXRGvcytTA5IqxuGlD-04WVFod_bw'), ('width', 703), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZRzHmIxp0zlCoa9YyUNXrA/-ja7DIUP7T1V-CzrghRi8Fn6NGVohJY0kAR8JR9mEUIeCEUxhXYAfbFLgq575jwqaYa1X1A2NsRg2Jzjvix2aw/cMqwBhsUWScUaaOf1dCcIzpkjNI18V-tsFWX3ZDxUMo'), ('width', 3000), ('height', 3000)]))]))])]",5.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125957/Instruments/Vendor%20Logos/Anapico.png,"The APSINXXG is an analog signal generator (analog signal source) series covering RF and microwave frequency ranges from 9 kHz to 12, 20 and 26.5 GHz
",https://www.anapico.com/products/rf-signal-generators/single-output-rf-and-microwave-signal-generators/apsin-g-series-up-to-26-ghz/,Apsin 12 G,75.0,['RF Signal Generator']," Single-Output RF and Microwave Signal Generators
","**AnaPico** is an ISO 9001:2015 certified technology leader, developing, manufacturing and supplying RF and MW test & measurement instruments

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anapico/apsin12G.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/anapico/apsin12G.html,Anapico,"[OrderedDict([('id', 'att5A0dfCy70SahVz'), ('width', 400), ('height', 267), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Zcj73TBi_ZNfxgR7F11sRQ/kzbpTlnlLiWfWFHLSbCgQvrqpNkJUCTO-UBYniepINAiNoJaFTbRo848cpEV5DHgYNMCL2cbbHhzYyWbqCSYVbx66cIdbzlkH4sejWM6VaI/zjG9kolliZs8CZzGMmvEshU5dntH155ldeUcHjh-R9k'), ('filename', 'logo-e1591109604777.png'), ('size', 18323), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7kveV9_ZuHv_lUslaOz_JQ/KC7HXGI-jYlB-EpRYBYexBRqXMEjh93ozXm1o6l8YzWScrae8cUMb5c6TSTP9IUz1vfiWQhELAHBrg5rZ09Egw/MgcT6wQQau8MMBFQ4TkJexmxaiwJPVu-4w2Dfy49dkU'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eM7DRWICgkqH3x0p7f5TzQ/lnLaaobSZez_ZSRMWwzqb92aAZttr_SQdvSnGijEW9CFcwbXhQjDMfTvbHrH1Dzvw-OHKn5Ism8hWpJNzFVzAA/z2YhcdZq5ML5Rj1es-lNktLupyE4NKz2Z_l6ZDYinSU'), ('width', 400), ('height', 267)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5Vuz2suklFOHcz_l7dgbEg/MjxQdbcaH4WwjEtIJxo0Y1b-S5Tdz0YV2UMjHyVaNzTghVyRgt77EzXFl60IObivM1K-i0IRDEXRBzKXjwhDsg/bDg2Td-3iiyNtoAyprIXkb8DSdPm-gSl0Tx4cCPh9B4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anapico.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782482/Instruments/RF%20Signal%20Generator/Apsin-26G/Apsin-26G.jpg,Apsin 26G,Write a Python script that uses Pymeasure to connect to a Apsin 26G RF Signal Generator,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range, strict_discrete_set


class APSIN12G(Instrument):
    """""" Represents the Anapico APSIN12G Signal Generator with option 9K,
    HP and GPIB. """"""
    FREQ_LIMIT = [9e3, 12e9]
    POW_LIMIT = [-30, 27]

    power = Instrument.control(
        ""SOUR:POW:LEV:IMM:AMPL?;"", ""SOUR:POW:LEV:IMM:AMPL %gdBm;"",
        """""" A floating point property that represents the output power
        in dBm. This property can be set. """""",
        validator=strict_range,
        values=POW_LIMIT
    )
    frequency = Instrument.control(
        ""SOUR:FREQ:CW?;"", ""SOUR:FREQ:CW %eHz;"",
        """""" A floating point property that represents the output frequency
        in Hz. This property can be set. """""",
        validator=strict_range,
        values=FREQ_LIMIT
    )
    blanking = Instrument.control(
        "":OUTP:BLAN:STAT?"", "":OUTP:BLAN:STAT %s"",
        """""" A string property that represents the blanking of output power
        when frequency is changed. ON makes the output to be blanked (off) while
        changing frequency. This property can be set. """""",
        validator=strict_discrete_set,
        values=['ON', 'OFF']
    )
    reference_output = Instrument.control(
        ""SOUR:ROSC:OUTP:STAT?"", ""SOUR:ROSC:OUTP:STAT %s"",
        """""" A string property that represents the 10MHz reference output from
        the synth. This property can be set. """""",
        validator=strict_discrete_set,
        values=['ON', 'OFF']
    )

    def __init__(self, adapter, name=""Anapico APSIN12G Signal Generator"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def enable_rf(self):
        """""" Enables the RF output. """"""
        self.write(""OUTP:STAT 1"")

    def disable_rf(self):
        """""" Disables the RF output. """"""
        self.write(""OUTP:STAT 0"")
"
74,https://www.keysight.com/us/en/assets/7018-01355/data-sheets/5989-4435.pdf,https://www.keysight.com/us/en/products/lcr-meters-impedance-measurement-products/bench-top-lcr-meters.html,"[OrderedDict([('id', 'attuZHiWXbmDgcXF9'), ('width', 1156), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/22fCOv3fnKnfa3OUbBzR3g/nxz7d7px_-EAQHF2f3G938OQa1wLI5vzkeZqJ5pwT6bAbZh8p4LCOKg8XE_OoM5zm4akDIK5nwiCciqTOa5nOg/ybPjAYGP7Bmjux4eMtLvSNxoRfr1mPFF62nmayY-YHg'), ('filename', 'LCR.png'), ('size', 475849), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/B1YDxePqH8fTjcQxx-6kSA/isYY4RUMpex_NWQnIBX77PEafjiQGfeFhpSGlQHv05GP0QjQlFtlaHxZDrSPwM5PInLGK4L-k-1VIesxLK3AhA/w1iy6OQjfWsjhQZ_h6ykr8DdsRMEhIVJ42W4Lu3dv2I'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bs5oB-0U7cIEv-VVOI5mjw/Zhv9VicJ49aMQMO0LOWHsKntJwTVUF35MN-LJogRHc9r-mQegSIBvT9Qkj_YaU3X5q8_fkq8pMNynW5cB3d2dg/ZFLcQaMtznQ5Nz90a5-23cNOSDBT1VS9IRdQx0PKwLM'), ('width', 769), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9gAG37mWvLnc-YJ36DJMtw/0ivnPjZbLz9k6BF5qngNyqjJmx_uax5YzmvcK6DpKflDI2RK8zn-INY0G9r2g-ksLM6NVaoPR1RaqzWE7abMYA/Zx5VoBYbtJsQ_jVfpwRmoN5RS3R4l5WYzJhzfEb1QTo'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,"The E4980A precision LCR meter provides the best combination of accuracy, speed, and versatility for a wide range of component measurements.",https://www.keysight.com/us/en/product/E4980A/precision-lcr-meter-20-hz-2-mhz.html,Agilent E4980,34.0,['Multimeters'],"An LCR meter is a type of electronic test equipment used to measure the inductance (L), capacitance (C), and resistance (R) of an electronic component.[1]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilentE4980.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentE4980.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782484/Instruments/Multimeters/Keysight-E4980A/Keysight-E4980A.png,Keysight E4980A,Write a Python script that uses Pymeasure to connect to a Keysight E4980A Multimeters,24253.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range
from pyvisa.errors import VisaIOError


class AgilentE4980(Instrument):
    """"""Represents LCR meter E4980A/AL""""""

    ac_voltage = Instrument.control("":VOLT:LEV?"", "":VOLT:LEV %g"",
                                    ""AC voltage level, in Volts"",
                                    validator=strict_range,
                                    values=[0, 20])

    ac_current = Instrument.control("":CURR:LEV?"", "":CURR:LEV %g"",
                                    ""AC current level, in Amps"",
                                    validator=strict_range,
                                    values=[0, 0.1])

    frequency = Instrument.control("":FREQ:CW?"", "":FREQ:CW %g"",
                                   ""AC frequency (range depending on model), in Hertz"",
                                   validator=strict_range,
                                   values=[20, 2e6])

    # FETCH? returns [A,B,state]: impedance returns only A,B
    impedance = Instrument.measurement(
        "":FETCH?"",
        ""Measured data A and B, according to :attr:`~.AgilentE4980.mode`"",
        get_process=lambda x: x[:2])

    mode = Instrument.control(""FUNCtion:IMPedance:TYPE?"", ""FUNCtion:IMPedance:TYPE %s"",
                              """"""
Select quantities to be measured:

    * CPD: Parallel capacitance [F] and dissipation factor [number]
    * CPQ: Parallel capacitance [F] and quality factor [number]
    * CPG: Parallel capacitance [F] and parallel conductance [S]
    * CPRP: Parallel capacitance [F] and parallel resistance [Ohm]

    - CSD: Series capacitance [F] and dissipation factor [number]
    - CSQ: Series capacitance [F] and quality factor [number]
    - CSRS: Series capacitance [F] and series resistance [Ohm]

    * LPD: Parallel inductance [H] and dissipation factor [number]
    * LPQ: Parallel inductance [H] and quality factor [number]
    * LPG: Parallel inductance [H] and parallel conductance [S]
    * LPRP: Parallel inductance [H] and parallel resistance [Ohm]

    - LSD: Series inductance [H] and dissipation factor [number]
    - LSQ: Seriesinductance [H] and quality factor [number]
    - LSRS: Series inductance [H] and series resistance [Ohm]

    * RX: Resitance [Ohm] and reactance [Ohm]
    * ZTD: Impedance, magnitude [Ohm] and phase [deg]
    * ZTR: Impedance, magnitude [Ohm] and phase [rad]
    * GB: Conductance [S] and susceptance [S]
    * YTD: Admittance, magnitude [Ohm] and phase [deg]
    * YTR: Admittance magnitude [Ohm] and phase [rad]
"""""",
                              validator=strict_discrete_set,
                              values=[""CPD"", ""CPQ"", ""CPG"", ""CPRP"",
                                      ""CSD"", ""CSQ"", ""CSRS"",
                                      ""LPD"", ""LPQ"", ""LPG"", ""LPRP"",
                                      ""LSD"", ""LSQ"", ""LSRS"",
                                      ""RX"", ""ZTD"", ""ZTR"", ""GB"", ""YTD"", ""YTR"", ])

    trigger_source = Instrument.control(""TRIG:SOUR?"", ""TRIG:SOUR %s"",
                                        """"""
Select trigger source; accept the values:
    * HOLD: manual
    * INT: internal
    * BUS: external bus (GPIB/LAN/USB)
    * EXT: external connector"""""",
                                        validator=strict_discrete_set,
                                        values=[""HOLD"", ""INT"", ""BUS"", ""EXT""])

    def __init__(self, adapter, name=""Agilent E4980A/AL LCR meter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        self.timeout = 30000
        # format: output ascii
        self.write(""FORM ASC"")

    def freq_sweep(self, freq_list, return_freq=False):
        """"""
        Run frequency list sweep using sequential trigger.

        :param freq_list: list of frequencies
        :param return_freq: if True, returns the frequencies read from the instrument

        Returns values as configured with :attr:`~.AgilentE4980.mode`
            """"""
        # manual, page 299
        # self.write(""*RST;*CLS"")
        self.write(""TRIG:SOUR BUS"")
        self.write(""DISP:PAGE LIST"")
        self.write(""FORM ASC"")
        # trigger in sequential mode
        self.write(""LIST:MODE SEQ"")
        lista_str = "","".join(['%e' % f for f in freq_list])
        self.write(""LIST:FREQ %s"" % lista_str)
        # trigger
        self.write(""INIT:CONT ON"")
        self.write("":TRIG:IMM"")
        # wait for completed measurement
        # using the Error signal (there should be a better way)
        while 1:
            try:
                measured = self.values("":FETCh:IMPedance:FORMatted?"")
                break
            except VisaIOError:
                pass
        # at the end return to manual trigger
        self.write("":TRIG:SOUR HOLD"")
        # gets 4-ples of numbers, first two are data A and B
        a_data = [measured[_] for _ in range(0, 4 * len(freq_list), 4)]
        b_data = [measured[_] for _ in range(1, 4 * len(freq_list), 4)]
        if return_freq:
            read_freqs = self.values(""LIST:FREQ?"")
            return a_data, b_data, read_freqs
        else:
            return a_data, b_data

    # TODO: maybe refactor as property?
    def aperture(self, time=None, averages=1):
        """"""
        Set and get aperture.

        :param time: integration time as string: SHORT, MED, LONG (case insensitive);
            if None, get values
        :param averages: number of averages, numeric
        """"""
        if time is None:
            read_values = self.ask("":APER?"").split(',')
            return read_values[0], int(read_values[1])
        else:
            if time.upper() in [""SHORT"", ""MED"", ""LONG""]:
                self.write(f"":APER {time}, {averages}"")
            else:
                raise Exception(""Time must be a string: SHORT, MED, LONG"")
"
76,https://www.keysight.com/us/en/assets/7018-06749/technical-overviews/5091-3645.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'att2KtkUGjyFWiD7D'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8C5Kye6lQMcIpPb4Kl8AXA/9wp0MnvLpUG-NdfleE1XgWK3Giv6EIjCsSeZ0atMhoO7UkcnhWTJzcAU3wi-KOtO0WCTnvPyQL1MHo6UGbkiBDaCb-EXhiawxytbiZk_VXY/6cOsjoFcH2lw4L_0O7LaWYcqaNQuKNYfStN6Xz80Ogg'), ('filename', '8722ES.webp'), ('size', 15050), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/hfYrgQiGTh0y4PzLrca9-A/-PskAL2qrcmmGMbSleGo3Qyuuj-soDuP8HY3jfHJBeNlecTVD0DYEd1XGTTtJsotvsyOxVWVJA458NA1NtEepsw78cOe-DYzMTtPzZKucMw/CmknKdZq3a-412KfUcShYxusjzm0eDX4X0rmODFnpWM'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zBS52cDnrfKulNW5E3hiuw/hDaPlbmWbVAp5WTYTG_xQtlkG3DtO4gKWXyT_XbHqF2nYfOXCWrgOfUatsB4XltxCgnYuw7H_VNVURaxwrtFFnu6M1SavN9ZQVDG0sE6Fjg/hNm5jHz9uItZscvJelj9ATcDNd_AIX0O1YmbfBuqjiY'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/dT8jmOUaHCWZwUCeaiL_1w/WOGoyuNhTZDuUvlUTobY7AXg3kjgo3A7PxR6uZesudd7zGlAKaaKiNnPlyoPEuLzRVCBeOw03ApoKuThROV2R0LEWWgzW_ckNyYblHzbbA4/UIqPgyBzORa1rzOdJZm9ez_7QYW1LQmbXcPOpYW_z0E'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,"The Agilent 8722ES Vector Network Analyzer (VNA) allows users to test a RF device’s amplitude and phase with one instrument. It works within 50 MHz to 40 GHz and enables the complete characterization of a device or network.

",https://www.cmc.ca/agilent-8722es-s-parameter-vector-network-analyzer-40-ghz/,Agilent 8722 ES,14.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent8722ES.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent8722ES.html,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782485/Instruments/Network%20Analyzer/Keysight-8722ES/Keysight-8722ES.webp,Keysight 8722ES ,Write a Python script that uses Pymeasure to connect to a Keysight 8722ES  Network Analyzer,,"
",True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument, discreteTruncate, RangeException
from pyvisa import VisaIOError

import numpy as np
import re
from io import BytesIO
import warnings


class Agilent8722ES(Instrument):
    """""" Represents the Agilent8722ES Vector Network Analyzer
    and provides a high-level interface for taking scans of the
    scattering parameters.
    """"""

    SCAN_POINT_VALUES = [3, 11, 21, 26, 51, 101, 201, 401, 801, 1601]
    SCATTERING_PARAMETERS = (""S11"", ""S12"", ""S21"", ""S22"")
    S11, S12, S21, S22 = SCATTERING_PARAMETERS

    start_frequency = Instrument.control(
        ""STAR?"", ""STAR %e Hz"",
        """""" A floating point property that represents the start frequency
        in Hz. This property can be set.
        """"""
    )
    stop_frequency = Instrument.control(
        ""STOP?"", ""STOP %e Hz"",
        """""" A floating point property that represents the stop frequency
        in Hz. This property can be set.
        """"""
    )
    sweep_time = Instrument.control(
        ""SWET?"", ""SWET%.2e"",
        """""" A floating point property that represents the sweep time
        in seconds. This property can be set.
        """"""
    )
    averages = Instrument.control(
        ""AVERFACT?"", ""AVERFACT%d"",
        """""" An integer representing the number of averages to take. Note that
        averaging must be enabled for this to take effect. This property can be set.
        """""",
        cast=lambda x: int(float(x))  # need float() to convert scientific notation in strings
    )
    averaging_enabled = Instrument.control(
        ""AVERO?"", ""AVERO%d"",
        """""" A bool that indicates whether or not averaging is enabled. This property
        can be set."""""",
        cast=bool
    )

    def __init__(self, adapter, name=""Agilent 8722ES Vector Network Analyzer"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def set_fixed_frequency(self, frequency):
        """""" Sets the scan to be of only one frequency in Hz """"""
        self.start_frequency = frequency
        self.stop_frequency = frequency
        self.scan_points = 3

    @property
    def parameter(self):
        for parameter in Agilent8722ES.SCATTERING_PARAMETERS:
            if int(self.values(""%s?"" % parameter)) == 1:
                return parameter
        return None

    @parameter.setter
    def parameter(self, value):
        if value in Agilent8722ES.SCATTERING_PARAMETERS:
            self.write(""%s"" % value)
        else:
            raise Exception(""Invalid scattering parameter requested""
                            "" for Agilent 8722ES"")

    @property
    def scan_points(self):
        """""" Gets the number of scan points
        """"""
        search = re.search(r""\d\.\d+E[+-]\d{2}$"", self.ask(""POIN?""),
                           re.MULTILINE)
        if search:
            return int(float(search.group()))
        else:
            raise Exception(""Improper message returned for the""
                            "" number of points"")

    @scan_points.setter
    def scan_points(self, points):
        """""" Sets the number of scan points, truncating to an allowed
        value if not properly provided
        """"""
        points = discreteTruncate(points, Agilent8722ES.SCAN_POINT_VALUES)
        if points:
            self.write(""POIN%d"" % points)
        else:
            raise RangeException(""Maximum scan points (1601) for""
                                 "" Agilent 8722ES exceeded"")

    def set_IF_bandwidth(self, bandwidth):
        """""" Sets the resolution bandwidth (IF bandwidth) """"""
        allowedBandwidth = [10, 30, 100, 300, 1000, 3000, 3700, 6000]
        bandwidth = discreteTruncate(bandwidth, allowedBandwidth)
        if bandwidth:
            self.write(""IFBW%d"" % bandwidth)
        else:
            raise RangeException(""Maximum IF bandwidth (6000) for Agilent ""
                                 ""8722ES exceeded"")

    def set_averaging(self, averages):
        """"""Sets the number of averages and enables/disables averaging. Should be
        between 1 and 999""""""
        averages = int(averages)
        if not 1 <= averages <= 999:
            assert RangeException(""Set"", averages, ""must be in the range 1 to 999"")
        self.averages = averages
        self.averaging_enabled = (averages > 1)

    def disable_averaging(self):
        """"""Disables averaging""""""
        warnings.warn(
            ""Don't use disable_averaging(), use averaging_enabled = False instead"", FutureWarning)
        self.averaging_enabled = False

    def enable_averaging(self):
        """"""Enables averaging""""""
        warnings.warn(
            ""Don't use enable_averaging(), use averaging_enabled = True instead"", FutureWarning)
        self.averaging_enabled = True

    def is_averaging(self):
        """""" Returns True if averaging is enabled """"""
        warnings.warn(""Don't use is_averaging(), use averaging_enabled instead"", FutureWarning)
        return self.averaging_enabled

    def restart_averaging(self, averages):
        warnings.warn(""Don't use restart_averaging(), use scan_single() instead"", FutureWarning)
        self.scan_single()

    def scan(self, averages=None, blocking=None, timeout=None, delay=None):
        """""" Initiates a scan with the number of averages specified and
        blocks until the operation is complete.
        """"""
        if averages is not None or blocking is not None or timeout is not None or delay is not None:
            warnings.warn(
                ""averages, blocking, timeout, and delay arguments are no longer used by scan()"",
                FutureWarning
            )
        self.write(""*CLS"")
        self.scan_single()
        # All queries will block until the scan is done, so use NOOP? to check.
        # These queries will time out after several seconds though,
        # so query repeatedly until the scan finishes.
        while True:
            try:
                self.ask(""NOOP?"")
            except VisaIOError as e:
                if e.abbreviation != ""VI_ERROR_TMO"":
                    raise e
            else:
                break

    def scan_single(self):
        """""" Initiates a single scan """"""
        if self.averaging_enabled:
            self.write(""NUMG%d"" % self.averages)
        else:
            self.write(""SING"")

    def scan_continuous(self):
        """""" Initiates a continuous scan """"""
        self.write(""CONT"")

    @property
    def frequencies(self):
        """""" Returns a list of frequencies from the last scan
        """"""
        return np.linspace(
            self.start_frequency,
            self.stop_frequency,
            num=self.scan_points
        )

    @property
    def data_complex(self):
        """""" Returns the complex power from the last scan
        """"""
        # TODO: Implement binary transfer instead of ASCII
        data = np.loadtxt(
            BytesIO(self.ask(""FORM4;OUTPDATA"").encode()),
            delimiter=',',
            dtype=np.float32
        )
        data_complex = data[:, 0] + 1j * data[:, 1]
        return data_complex

    @property
    def data_log_magnitude(self):
        """""" Returns the absolute magnitude values in dB from the last scan
        """"""
        return 20 * np.log10(self.data_magnitude)

    @property
    def data_magnitude(self):
        """""" Returns the absolute magnitude values from the last scan
        """"""
        return np.abs(self.data_complex)

    @property
    def data_phase(self):
        """""" Returns the phase in degrees from the last scan
        """"""
        return np.degrees(np.angle(self.data_complex))

    @property
    def data(self):
        """""" Returns the real and imaginary data from the last scan
        """"""
        warnings.warn(""Don't use this function, use data_complex instead"", FutureWarning)
        data_complex = self.data_complex
        return data_complex.real, data_complex.complex

    def log_magnitude(self, real, imaginary):
        """""" Returns the magnitude in dB from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use log_magnitude(), use data_log_magnitude instead"", FutureWarning)
        return 20 * np.log10(self.magnitude(real, imaginary))

    def magnitude(self, real, imaginary):
        """""" Returns the magnitude from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use magnitude(), use data_magnitude"", FutureWarning)
        return np.sqrt(real**2 + imaginary**2)

    def phase(self, real, imaginary):
        """""" Returns the phase in degrees from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use phase(), use data_phase instead"", FutureWarning)
        return np.arctan2(imaginary, real) * 180 / np.pi
"
77,https://www.keysight.com/us/en/assets/7018-05520/data-sheets/5992-1965.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'atttRJnawtGzIOFlp'), ('width', 2000), ('height', 1120), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rW66ghEhsT0hCLonhs84WA/KX3Kx5UIC9mYHYCU-wE94Y0o7_LPhQ1o4Q7hl1GmuzzQMWhFZGdRnIOy7s68ttJx_m09vCxI-Dleobg5iqjtiEIQPYITfKuLtRGB3Ipvq8k/NAf1zsYrI2eygXE-ob0yD6fVfV9V6k3ABig4-8UE928'), ('filename', '06AC0355-40.jpg'), ('size', 217676), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FCkHhGqjs_d30EGzg4H-dg/Q02McIBdKHs6hcfpvR98McKQsXou0ttPSK8CjiAuCYnjCBWbO2H0WmQ9H12Eeb-TyBVKvmXFBOnaYbK06dRHnA/b9d7RQbTv8X2YLBXzZS98QEMN3MAWeq8PVKti45dPnc'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fVg6RMmYhKjrgo05lESHlw/pvtRb2sCQNlY6nwA4uUsjUg2EFLHZ9xeckifLv8Sk5kntC3ccvWUEhsGswe-Xg4fRUwsVYYlAqOzNwRDMlftSw/nWKWh4XRjSzijqKnp1m-SvLPznUhQrh77ktDFh8kIpY'), ('width', 914), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wNdWIERddfmpMA36OdYYyA/wit9-q1yUDEL28BUQdbihd-8XT7WojIhzxQiH7laiCAyL2RjirQk8hy0zZxb5kEQDWs2KU5kZ7leWJ4s8w3hNg/R6bVQx0vZH9NqvkgFj-cRkUrOUwyKcvM95V2SFrpu6E'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125973/Instruments/Vendor%20Logos/Keysight.png,"The DSOX1102G oscilloscope provides 70, 100 MHz of bandwidth on 2 analog channels, and waveform generator

",https://www.keysight.com/us/en/product/DSOX1102G/oscilloscope-70-100-mhz-2-analog-channels.html,Keysightdsox 1102 G,317.0,['Oscilloscopes'],"An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightDSOX1102G.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keysight/keysightDSOX1102G.html?highlight=dsox1102G,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/megNNA5_wzuwWNCz6WDjcw/pQyuIu38l8MsHtaFtaOLmkMRzbqTDqGfMLlXBJhFa7ggZPbno9t2eqjBe10eReASLOJl_8haDklFBQFmKIcdqa3aD7V5mul-MgXSWAEryJk/0vNQYOLhY1SDrjXhjXsyVp32UY9MBoh8pi_b347YZ0c'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1RC4XJCrTJbUIlcqhOcJig/okl3Me440BMr3q1gjrB0ZgbQEfGUrmHNr0YTpKYJNQ2iNBR-or2oqc1R3G_ElqfSqNsuzpagWZH5DUqHJm_AZd7fQdW2NyQK-QFmn2ayFqk/naZmSvm7PJ-qjwjEUyWtpMXIGRSofD6fBelDaBktR74'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ybeEhpT9SyxU5RIxr0NP4w/SXZN1vvm029SORyK_WT2NOYhg1wK1kZkt6bw-kFlMyvaJpSNxjwYZCRBej3Tn-swtIcVXr5OHTSVnLpU_pRha9WM0LM87R1CX-drKxV-L3o/ISIa5a59ilLldrkBEq_PsDFCkb9vZUTJAWjxaxB9OLc'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qn98Xihw8ou906fGgF2Dzw/9aKhJN716Y8Pl17Bxi7ANhxbQZOC7susFJYn78DkZCpyBZwyTBzys51YJWrwbjBAMOYQksvWcmhCIwnWNgNN2-jkr7LQkp8OlFQ1S9MzEUU/l4F-gkk5SwbmwZaMvHeWmpzk02MUYQ_xsEShq-bDEBk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782486/Instruments/Oscilloscopes/Keysight-DSOX1102G/Keysight-DSOX1102G.jpg,Keysight DSOX1102G,Write a Python script that uses Pymeasure to connect to a Keysight DSOX1102G Oscilloscopes,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Channel():
    """""" Implementation of a Keysight DSOX1102G Oscilloscope channel.

    Implementation modeled on Channel object of Tektronix AFG3152C instrument. """"""

    BOOLS = {True: 1, False: 0}

    bwlimit = Instrument.control(
        ""BWLimit?"", ""BWLimit %d"",
        """""" A boolean parameter that toggles 25 MHz internal low-pass filter."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    coupling = Instrument.control(
        ""COUPling?"", ""COUPling %s"",
        """""" A string parameter that determines the coupling (""ac"" or ""dc"")."""""",
        validator=strict_discrete_set,
        values={""ac"": ""AC"", ""dc"": ""DC""},
        map_values=True
    )

    display = Instrument.control(
        ""DISPlay?"", ""DISPlay %d"",
        """""" A boolean parameter that toggles the display."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    invert = Instrument.control(
        ""INVert?"", ""INVert %d"",
        """""" A boolean parameter that toggles the inversion of the input signal."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    label = Instrument.control(
        ""LABel?"", 'LABel ""%s""',
        """""" A string to label the channel. Labels with more than 10 characters are truncated to 10
        characters. May contain commonly used ASCII characters. Lower case characters are converted
        to upper case."""""",
        get_process=lambda v: str(v[1:-1])
    )

    offset = Instrument.control(
        ""OFFSet?"", ""OFFSet %f"",
        """""" A float parameter to set value that is represented at center of screen in
        Volts. The range of legal values varies depending on range and scale. If the specified
        value is outside of the legal range, the offset value is automatically set to the nearest
        legal value.
        """"""
    )

    probe_attenuation = Instrument.control(
        ""PROBe?"", ""PROBe %f"",
        """""" A float parameter that specifies the probe attenuation. The probe attenuation
        may be from 0.1 to 10000."""""",
        validator=strict_range,
        values=[0.1, 10000]
    )

    range = Instrument.control(
        ""RANGe?"", ""RANGe %f"",
        """""" A float parameter that specifies the full-scale vertical axis in Volts.
        When using 1:1 probe attenuation, legal values for the range are from 8 mV to 40V.""""""
    )

    scale = Instrument.control(
        ""SCALe?"", ""SCALe %f"",
        """"""A float parameter that specifies the vertical scale, or units per division, in Volts.""""""
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any key-word arguments.
        """"""
        return self.instrument.values("":channel%d:%s"" % (
            self.number, command), **kwargs)

    def ask(self, command):
        self.instrument.ask("":channel%d:%s"" % (self.number, command))

    def write(self, command):
        self.instrument.write("":channel%d:%s"" % (self.number, command))

    def setup(self, bwlimit=None, coupling=None, display=None, invert=None, label=None, offset=None,
              probe_attenuation=None, vertical_range=None, scale=None):
        """""" Setup channel. Unspecified settings are not modified. Modifying values such as
        probe attenuation will modify offset, range, etc. Refer to oscilloscope documentation and
        make multiple consecutive calls to setup() if needed.

        :param bwlimit: A boolean, which enables 25 MHz internal low-pass filter.
        :param coupling: ""ac"" or ""dc"".
        :param display: A boolean, which enables channel display.
        :param invert: A boolean, which enables input signal inversion.
        :param label: Label string with max. 10 commonly used ASCII characters.
        :param offset: Numerical value represented at center of screen, must be inside
            the legal range.
        :param probe_attenuation: Probe attenuation values from 0.1 to 1000.
        :param vertical_range: Full-scale vertical axis of the selected channel. When using 1:1
            probe attenuation, legal values for the range are  from 8mV to 40 V. If the probe
            attenuation is changed, the range value is multiplied by the probe attenuation factor.
        :param scale: Units per division. """"""

        if vertical_range is not None and scale is not None:
            log.warning(
                'Both ""vertical_range"" and ""scale"" are specified. Specified ""scale"" has priority.')

        if probe_attenuation is not None:
            self.probe_attenuation = probe_attenuation
        if bwlimit is not None:
            self.bwlimit = bwlimit
        if coupling is not None:
            self.coupling = coupling
        if display is not None:
            self.display = display
        if invert is not None:
            self.invert = invert
        if label is not None:
            self.label = label
        if offset is not None:
            self.offset = offset
        if vertical_range is not None:
            self.range = vertical_range
        if scale is not None:
            self.scale = scale

    @property
    def current_configuration(self):
        """""" Read channel configuration as a dict containing the following keys:
            - ""CHAN"": channel number (int)
            - ""OFFS"": vertical offset (float)
            - ""RANG"": vertical range (float)
            - ""COUP"": ""dc"" or ""ac"" coupling (str)
            - ""IMP"": input impedance (str)
            - ""DISP"": currently displayed (bool)
            - ""BWL"": bandwidth limiting enabled (bool)
            - ""INV"": inverted (bool)
            - ""UNIT"": unit (str)
            - ""PROB"": probe attenuation (float)
            - ""PROB:SKEW"": skew factor (float)
            - ""STYP"": probe signal type (str)
        """"""

        # Using the instrument's ask method because Channel.ask() adds the prefix "":channelX:"", and
        # to query the configuration details, we actually need to ask "":channelX?"", without a
        # second "":""
        ch_setup_raw = self.instrument.ask("":channel%d?"" % self.number).strip(""\n"")

        # ch_setup_raw hat the following format:
        # :CHAN1:RANG +40.0E+00;OFFS +0.00000E+00;COUP DC;IMP ONEM;DISP 1;BWL 0;
        # INV 0;LAB ""1"";UNIT VOLT;PROB +10E+00;PROB:SKEW +0.00E+00;STYP SING

        # Cut out the "":CHANx:"" at beginning and split string
        ch_setup_splitted = ch_setup_raw[7:].split("";"")

        # Create dict of setup parameters
        ch_setup_dict = dict(map(lambda v: v.split("" ""), ch_setup_splitted))

        # Add ""CHAN"" key
        ch_setup_dict[""CHAN""] = ch_setup_raw[5]

        # Convert values to specific type
        to_str = [""COUP"", ""IMP"", ""UNIT"", ""STYP""]
        to_bool = [""DISP"", ""BWL"", ""INV""]
        to_float = [""OFFS"", ""PROB"", ""PROB:SKEW"", ""RANG""]
        to_int = [""CHAN""]
        for key in ch_setup_dict:
            if key in to_str:
                ch_setup_dict[key] = str(ch_setup_dict[key])
            elif key in to_bool:
                ch_setup_dict[key] = (ch_setup_dict[key] == ""1"")
            elif key in to_float:
                ch_setup_dict[key] = float(ch_setup_dict[key])
            elif key in to_int:
                ch_setup_dict[key] = int(ch_setup_dict[key])
        return ch_setup_dict


class KeysightDSOX1102G(Instrument):
    """""" Represents the Keysight DSOX1102G Oscilloscope interface for interacting
    with the instrument.

    Refer to the Keysight DSOX1102G Oscilloscope Programmer's Guide for further details about
    using the lower-level methods to interact directly with the scope.

    .. code-block:: python

        scope = KeysightDSOX1102G(resource)
        scope.autoscale()
        ch1_data_array, ch1_preamble = scope.download_data(source=""channel1"", points=2000)
        # ...
        scope.shutdown()

    Known issues:

    - The digitize command will be completed before the operation is. May lead to
      VI_ERROR_TMO (timeout) occuring when sending commands immediately after digitize.
      Current fix: if deemed necessary, add delay between digitize and follow-up command
      to scope.
    """"""

    BOOLS = {True: 1, False: 0}

    def __init__(self, adapter, name=""Keysight DSOX1102G Oscilloscope"", **kwargs):
        super().__init__(
            adapter, name, timeout=6000, **kwargs
        )
        # Account for setup time for timebase_mode, waveform_points_mode
        self.ch1 = Channel(self, 1)
        self.ch2 = Channel(self, 2)

    #################
    # Channel setup #
    #################

    def autoscale(self):
        """""" Autoscale displayed channels. """"""
        self.write("":autoscale"")

    ##################
    # Timebase Setup #
    ##################

    @property
    def timebase(self):
        """""" Read timebase setup as a dict containing the following keys:
            - ""REF"": position on screen of timebase reference (str)
            - ""MAIN:RANG"": full-scale timebase range (float)
            - ""POS"": interval between trigger and reference point (float)
            - ""MODE"": mode (str)""""""
        return self._timebase()

    timebase_mode = Instrument.control(
        "":TIMebase:MODE?"", "":TIMebase:MODE %s"",
        """""" A string parameter that sets the current time base. Can be ""main"",
        ""window"", ""xy"", or ""roll""."""""",
        validator=strict_discrete_set,
        values={""main"": ""MAIN"", ""window"": ""WIND"", ""xy"": ""XY"", ""roll"": ""ROLL""},
        map_values=True
    )

    timebase_offset = Instrument.control(
        "":TIMebase:POSition?"", "":TIMebase:REFerence CENTer;:TIMebase:POSition %f"",
        """""" A float parameter that sets the time interval in seconds between the trigger
        event and the reference position (at center of screen by default).""""""
    )

    timebase_range = Instrument.control(
        "":TIMebase:RANGe?"", "":TIMebase:RANGe %f"",
        """""" A float parameter that sets the full-scale horizontal time in seconds for the
        main window.""""""
    )

    timebase_scale = Instrument.control(
        "":TIMebase:SCALe?"", "":TIMebase:SCALe %f"",
        """""" A float parameter that sets the horizontal scale (units per division) in seconds
        for the main window.""""""
    )

    ###############
    # Acquisition #
    ###############

    acquisition_type = Instrument.control(
        "":ACQuire:TYPE?"", "":ACQuire:TYPE %s"",
        """""" A string parameter that sets the type of data acquisition. Can be ""normal"", ""average"",
        ""hresolution"", or ""peak""."""""",
        validator=strict_discrete_set,
        values={""normal"": ""NORM"", ""average"": ""AVER"", ""hresolution"": ""HRES"", ""peak"": ""PEAK""},
        map_values=True
    )

    acquisition_mode = Instrument.control(
        "":ACQuire:MODE?"", "":ACQuire:MODE %s"",
        """""" A string parameter that sets the acquisition mode. Can be ""realtime"" or ""segmented""."""""",
        validator=strict_discrete_set,
        values={""realtime"": ""RTIM"", ""segmented"": ""SEGM""},
        map_values=True
    )

    def run(self):
        """""" Starts repetitive acquisitions.

        This is the same as pressing the Run key on the front panel.
        """"""
        self.write("":run"")

    def stop(self):
        """"""  Stops the acquisition. This is the same as pressing the Stop key on the front panel.""""""
        self.write("":stop"")

    def single(self):
        """""" Causes the instrument to acquire a single trigger of data.
        This is the same as pressing the Single key on the front panel. """"""
        self.write("":single"")

    _digitize = Instrument.setting(
        "":DIGitize %s"",
        """""" Acquire waveforms according to the settings of the :ACQuire commands and specified
        source, as a string parameter that can take the following values: ""channel1"", ""channel2"",
        ""function"", ""math"", ""fft"", ""abus"", or ""ext"". """""",
        validator=strict_discrete_set,
        values={""channel1"": ""CHAN1"", ""channel2"": ""CHAN2"", ""function"": ""FUNC"", ""math"": ""MATH"",
                ""fft"": ""FFT"", ""abus"": ""ABUS"", ""ext"": ""EXT""},
        map_values=True
    )

    def digitize(self, source: str):
        """""" Acquire waveforms according to the settings of the :ACQuire commands. Ensure a delay
        between the digitize operation and further commands, as timeout may be reached before
        digitize has completed.
        :param source: ""channel1"", ""channel2"", ""function"", ""math"", ""fft"", ""abus"", or ""ext"".""""""
        self._digitize = source

    waveform_points_mode = Instrument.control(
        "":waveform:points:mode?"", "":waveform:points:mode %s"",
        """""" A string parameter that sets the data record to be transferred with the waveform_data
         method. Can be ""normal"", ""maximum"", or ""raw""."""""",
        validator=strict_discrete_set,
        values={""normal"": ""NORM"", ""maximum"": ""MAX"", ""raw"": ""RAW""},
        map_values=True
    )
    waveform_points = Instrument.control(
        "":waveform:points?"", "":waveform:points %d"",
        """""" An integer parameter that sets the number of waveform points to be transferred with
        the waveform_data method. Can be any of the following values:
        100, 250, 500, 1000, 2 000, 5 000, 10 000, 20 000, 50 000, 62 500.

        Note that the oscilloscope may provide less than the specified nb of points. """""",
        validator=strict_discrete_set,
        values=[100, 250, 500, 1000, 2000, 5000, 10000, 20000, 50000, 62500]
    )
    waveform_source = Instrument.control(
        "":waveform:source?"", "":waveform:source %s"",
        """""" A string parameter that selects the analog channel, function, or reference waveform
        to be used as the source for the waveform methods. Can be ""channel1"", ""channel2"",
        ""function"", ""fft"", ""wmemory1"", ""wmemory2"", or ""ext""."""""",
        validator=strict_discrete_set,
        values={""channel1"": ""CHAN1"", ""channel2"": ""CHAN2"", ""function"": ""FUNC"", ""fft"": ""FFT"",
                ""wmemory1"": ""WMEM1"", ""wmemory2"": ""WMEM2"", ""ext"": ""EXT""},
        map_values=True
    )
    waveform_format = Instrument.control(
        "":waveform:format?"", "":waveform:format %s"",
        """""" A string parameter that controls how the data is formatted when sent from the
        oscilloscope. Can be ""ascii"", ""word"" or ""byte"". Words are transmitted in big endian by
        default."""""",
        validator=strict_discrete_set,
        values={""ascii"": ""ASC"", ""word"": ""WORD"", ""byte"": ""BYTE""},
        map_values=True
    )

    @property
    def waveform_preamble(self):
        """""" Get preamble information for the selected waveform source as a dict with the following keys:
            - ""format"": byte, word, or ascii (str)
            - ""type"": normal, peak detect, or average (str)
            - ""points"": nb of data points transferred (int)
            - ""count"": always 1 (int)
            - ""xincrement"": time difference between data points (float)
            - ""xorigin"": first data point in memory (float)
            - ""xreference"": data point associated with xorigin (int)
            - ""yincrement"": voltage difference between data points (float)
            - ""yorigin"": voltage at center of screen (float)
            - ""yreference"": data point associated with yorigin (int)""""""  # noqa: E501
        return self._waveform_preamble()

    @property
    def waveform_data(self):
        """""" Get the binary block of sampled data points transmitted using the IEEE 488.2 arbitrary
        block data format.""""""
        # Other waveform formats raise UnicodeDecodeError
        self.waveform_format = ""ascii""

        data = self.values("":waveform:data?"")
        # Strip header from first data element
        data[0] = float(data[0][10:])

        return data

    ################
    # System Setup #
    ################

    @property
    def system_setup(self):
        """""" A string parameter that sets up the oscilloscope. Must be in IEEE 488.2 format.
        It is recommended to only set a string previously obtained from this command.""""""
        return self.ask("":system:setup?"")

    @system_setup.setter
    def system_setup(self, setup_string):
        self.write("":system:setup "" + setup_string)

    def ch(self, channel_number):
        if channel_number == 1:
            return self.ch1
        elif channel_number == 2:
            return self.ch2
        else:
            raise ValueError(""Invalid channel number. Must be 1 or 2."")

    def clear_status(self):
        """""" Clear device status. """"""
        self.write(""*CLS"")

    def factory_reset(self):
        """""" Factory default setup, no user settings remain unchanged. """"""
        self.write(""*RST"")

    def default_setup(self):
        """""" Default setup, some user settings (like preferences) remain unchanged. """"""
        self.write("":SYSTem:PRESet"")

    def timebase_setup(self, mode=None, offset=None, horizontal_range=None, scale=None):
        """""" Set up timebase. Unspecified parameters are not modified. Modifying a single parameter
        might impact other parameters. Refer to oscilloscope documentation and make multiple
        consecutive calls to channel_setup if needed.

        :param mode: Timebase mode, can be ""main"", ""window"", ""xy"", or ""roll"".
        :param offset: Offset in seconds between trigger and center of screen.
        :param horizontal_range: Full-scale range in seconds.
        :param scale: Units-per-division in seconds.""""""

        if mode is not None:
            self.timebase_mode = mode
        if offset is not None:
            self.timebase_offset = offset
        if horizontal_range is not None:
            self.timebase_range = horizontal_range
        if scale is not None:
            self.timebase_scale = scale

    def download_image(self, format_=""png"", color_palette=""color""):
        """""" Get image of oscilloscope screen in bytearray of specified file format.

        :param format_: ""bmp"", ""bmp8bit"", or ""png""
        :param color_palette: ""color"" or ""grayscale""
        """"""
        query = f"":DISPlay:DATA? {format_}, {color_palette}""
        # Using binary_values query because default interface does not support binary transfer
        img = self.binary_values(query, header_bytes=10, dtype=np.uint8)
        return bytearray(img)

    def download_data(self, source, points=62500):
        """""" Get data from specified source of oscilloscope. Returned objects are a np.ndarray of
        data values (no temporal axis) and a dict of the waveform preamble, which can be used to
        build the corresponding time values for all data points.

        Multimeter will be stopped for proper acquisition.

        :param source: measurement source, can be ""channel1"", ""channel2"", ""function"", ""fft"",
            ""wmemory1"", ""wmemory2"", or ""ext"".
        :param points: integer number of points to acquire. Note that oscilloscope may return fewer
            points than specified, this is not an issue of this library. Can be 100, 250, 500, 1000,
            2000, 5000, 10000, 20000, 50000, or 62500.

        :return data_ndarray, waveform_preamble_dict: see waveform_preamble property for dict
            format.
        """"""
        # TODO: Consider downloading from multiple sources at the same time.
        self.waveform_source = source
        self.waveform_points_mode = ""normal""
        self.waveform_points = points

        preamble = self.waveform_preamble
        data_bytes = self.waveform_data
        return np.array(data_bytes), preamble

    def _timebase(self):
        """"""
        Reads setup data from timebase and converts it to a more convenient dict of values.
        """"""
        tb_setup_raw = self.ask("":timebase?"").strip(""\n"")

        # tb_setup_raw hat the following format:
        # :TIM:MODE MAIN;REF CENT;MAIN:RANG +1.00E-03;POS +0.0E+00

        # Cut out the "":TIM:"" at beginning and split string
        tb_setup_splitted = tb_setup_raw[5:].split("";"")

        # Create dict of setup parameters
        tb_setup = dict(map(lambda v: v.split("" ""), tb_setup_splitted))

        # Convert values to specific type
        to_str = [""MODE"", ""REF""]
        to_float = [""MAIN:RANG"", ""POS""]
        for key in tb_setup:
            if key in to_str:
                tb_setup[key] = str(tb_setup[key])
            elif key in to_float:
                tb_setup[key] = float(tb_setup[key])

        return tb_setup

    def _waveform_preamble(self):
        """"""
        Reads waveform preamble and converts it to a more convenient dict of values.
        """"""
        vals = self.values("":waveform:preamble?"")
        # Get values to dict
        vals_dict = dict(zip([""format"", ""type"", ""points"", ""count"", ""xincrement"", ""xorigin"",
                              ""xreference"", ""yincrement"", ""yorigin"", ""yreference""], vals))
        # Map element values
        format_map = {0: ""BYTE"", 1: ""WORD"", 4: ""ASCII""}
        type_map = {0: ""NORMAL"", 1: ""PEAK DETECT"", 2: ""AVERAGE"", 3: ""HRES""}
        vals_dict[""format""] = format_map[int(vals_dict[""format""])]
        vals_dict[""type""] = type_map[int(vals_dict[""type""])]

        # Correct types
        to_int = [""points"", ""count"", ""xreference"", ""yreference""]
        to_float = [""xincrement"", ""xorigin"", ""yincrement"", ""yorigin""]
        for key in vals_dict:
            if key in to_int:
                vals_dict[key] = int(vals_dict[key])
            elif key in to_float:
                vals_dict[key] = float(vals_dict[key])

        return vals_dict
"
78,,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attOJg2Uhzdy0GmeV'), ('width', 700), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xju_jaRSmYYEnz62dplLiw/-e_nzfGmnXWEuCQhTDcpv7q1Mb2fSpLf1cmDo9nSzYX7DhYbpjQ4BiCIdYxRpT-wbmo__HDUI8450FHNs6ZRJEL6zSRdwrRJN3xxO2Uu6IE/TX2FL5RrWLxlnzqKbCzLuLrZ3K5776YuU1JFsAoPxl8'), ('filename', 'SM-70-45D.jpg'), ('size', 44806), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pmUYiyUCoTv5RfmC0UyAZg/7rPuP43ojprld6dmCJaGxHXzUpX3ecUainPw3_X88CLi5jYYj6Gx_hKN8izDOSMiGQoFUqh31lE49_RrcTsZ4A/TFMaMHaBkgOvjhi2WUdd5EdiUus1TbBuDfi2w_huzfc'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qdvo254LnD8YkOoqInsVXQ/UI_Lb-Ca1ZXdav5iYuPIw8uDnH-byQILn9t1Ai5ZswkpWxcz4dUR0lSNudGCpHXQWRrb5vbfUpMF8seSIZdd8g/_5ReDs_sRz8W5Lxvj392vcvspuy4UqzXc0ijvqCaa1g'), ('width', 512), ('height', 585)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bL7J14sCcdufKADnDY83ag/iJ32ZmrsSRu74tyyG_WRgk4K-Lca_pYVh6ED0HEOU0aewA1c--KLJA9teavkd_NtwfNWoEw2uBlagqqSI3yAQg/Ddo6o6WzdZs2gGbVqftdjVAqcLjIBcTAWmE3FXkJEk4'), ('width', 3000), ('height', 3000)]))]))])]",,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125979/Instruments/Vendor%20Logos/Delta_Elektronika.png,The Delta Elektronika BV Model SM70-45D Programmable DC Power Supply 0-70V 0-45A,https://telonic.co.uk/product/delta-elektronika-sm70-45d-programmable-dc-power-supply-0-70v-0-45a/,SM 7045 D,118.0,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,"**Telonic Instruments** is one of the leading Suppliers of Kikusui, Rigol and Lab-Power power supplies and frequency converters.

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/deltaelektronika/sm7045d.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/deltaelektronica/sm7045d.html,Delta Elektronika,"[OrderedDict([('id', 'attzAHv8lUsC6VDSs'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F2W7x8Tc83tk-5mZ2CkBpw/z6W1iCCKmVmtpk-2jdK0k8jL_YhKXg1a0B0P0B-O4Y3prXUbZJdxrojoCXxMOLEzPlDwq6xnwTlS6KgLRjPugAxWsCdhRjiverD5WJsCAqs/pzTToDsI1yCBpFdLFXPc6hxTMkfeR5Os53PhAeknHFo'), ('filename', '4nhdMXDm_400x400.jpeg'), ('size', 11508), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nMotTyUWsFmBiL2PB-HtTw/XSBz7QB0n61fygMheLUC14KRyxgBtyaKJnUyqi0aadeyY1uK2LXkpwHtHGsQoXHA6l1NexRxxNPUSrtYCuKApA/4KGXrS5Jva-bNT6LJsVHVtf_rguQ0oOYCUuxYywUgZQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5XKicCncUFXIH2TWxj5R9g/1tGHi_NNhWWQI0bkZ5I8K1sObCmPchjzN_CEYQ_mfHRg1ifEKw6I8JqSZlM5KtlDVxHxRZuYVL8WvfIzMiy-1A/1HYasjYPIYRrofdNP7KxaAkdC6yK8pb7xiFrCcnk1sw'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_iECUKRAyxrOUgANYgZxxw/o_NiQMiLC4twhS8wqkWMLo-lXlYhWd4YHdCpssR0q9itTAJV6POLMAsMbVtZOK4pzy16cjHAru7I8uS8-a4jJQ/yXrKD4ISFklzprUL2DmaP0r2l9uhEJx2JtIDxfeik-0'), ('width', 3000), ('height', 3000)]))]))])]",https://telonic.co.uk/jg/wp-content/uploads/2021/05/Delta-SM800-Product-Manual.pdf,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782486/Instruments/Power%20Supplies/SM-70-45D/SM-70-45D.jpg,SM 70-45D,Write a Python script that uses Pymeasure to connect to a SM 70-45D Power Supplies,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range

from time import sleep
from numpy import linspace


class SM7045D(Instrument):
    """""" This is the class for the SM 70-45 D power supply.

    .. code-block:: python

        source = SM7045D(""GPIB::8"")

        source.ramp_to_zero(1)               # Set output to 0 before enabling
        source.enable()                      # Enables the output
        source.current = 1                   # Sets a current of 1 Amps

    """"""
    VOLTAGE_RANGE = [0, 70]
    CURRENT_RANGE = [0, 45]

    voltage = Instrument.control(
        ""SO:VO?"", ""SO:VO %g"",
        """""" A floating point property that represents the output voltage
        setting of the power supply in Volts. This property can be set. """""",
        validator=strict_range,
        values=VOLTAGE_RANGE
    )

    current = Instrument.control(
        ""SO:CU?"", ""SO:CU %g"",
        """""" A floating point property that represents the output current of
        the power supply in Amps. This property can be set. """""",
        validator=strict_range,
        values=CURRENT_RANGE
    )

    max_voltage = Instrument.control(
        ""SO:VO:MA?"", ""SO:VO:MA %g"",
        """""" A floating point property that represents the maximum output
        voltage of the power supply in Volts. This property can be set. """""",
        validator=strict_range,
        values=VOLTAGE_RANGE
    )

    max_current = Instrument.control(
        ""SO:CU:MA?"", ""SO:CU:MA %g"",
        """""" A floating point property that represents the maximum output
        current of the power supply in Amps. This property can be set. """""",
        validator=strict_range,
        values=CURRENT_RANGE
    )

    measure_voltage = Instrument.measurement(
        ""ME:VO?"",
        """""" Measures the actual output voltage of the power supply in
        Volts. """""",
    )

    measure_current = Instrument.measurement(
        ""ME:CU?"",
        """""" Measures the actual output current of the power supply in
        Amps. """""",
    )

    rsd = Instrument.measurement(
        ""SO:FU:RSD?"",
        """""" Check whether remote shutdown is enabled/disabled and thus if the
        output of the power supply is disabled/enabled. """""",
    )

    def __init__(self, adapter, name=""Delta Elektronika SM 70-45 D"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def enable(self):
        """"""
        Disable remote shutdown, hence output will be enabled.
        """"""
        self.write(""SO:FU:RSD 0"")

    def disable(self):
        """"""
        Enables remote shutdown, hence input will be disabled.
        """"""
        self.write(""SO:FU:RSD 1"")

    def ramp_to_current(self, target_current, current_step=0.1):
        """"""
        Gradually increase/decrease current to target current.

        :param target_current: Float that sets the target current (in A)
        :param current_step: Optional float that sets the current steps
                             / ramp rate (in A/s)
        """"""

        curr = self.current
        n = round(abs(curr - target_current) / current_step) + 1
        for i in linspace(curr, target_current, n):
            self.current = i
            sleep(0.1)

    def ramp_to_zero(self, current_step=0.1):
        """"""
        Gradually decrease the current to zero.

        :param current_step: Optional float that sets the current steps
                             / ramp rate (in A/s)
        """"""

        self.ramp_to_current(0, current_step)

    def shutdown(self):
        """"""
        Set the current to 0 A and disable the output of the power source.
        """"""
        self.ramp_to_zero()
        self.disable()
        super().shutdown()
"
80,https://www.keysight.com/us/en/assets/7018-06809/data-sheets/5968-0125.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'atthuVvJN2I1Q1oWs'), ('width', 2641), ('height', 1171), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8rbF6oilW3gc_KPHXaeBtg/p9LXHiI0DZNCojALj7mFF1l3y1ZgK-qOQbQrZtSjy63s_ZvNd9VLMkrFb8G-BlbTMPkCcYWO5bYGBmzz-gLNUcEeCsCTkz2uzIlA4w91cNQ/jwtU-W-cpkcbhkr0z3QKsRVyvsBOZtsocWKODrDOJK4'), ('filename', 'SgLabs_HP_33120A_1.jpeg'), ('size', 381447), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/JupOhdWhOmoSHsl86-7uLQ/l-mL9mlbJYUwYHcU_i0ZDXMuAw2H-R953wzpJVeRaIEoGeg7mJULMy3F36hweeFZIwtitcC79055Wj-BRGqlOg/T37G9mgUYKWF02N2EsNVmx0d_HTTbZZBCFMLlLKalrA'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/NSGjVW1R-VWCu4Co8WtvDQ/H9mZx1U0MhGNyyitMABk19eIdP2mIldUGtgOXTTFsD_YiJzzs_9fEI6kbAnbahgpa_qwrrLKyl282tk-5_N99w/sqN1C30mwZfy638LneZPx81Mvh6SKp4ljXmKacgnlTA'), ('width', 1155), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YS-2rc94eiJ89OnSlsmLEg/Fr9oHoubtXX46iodE9hSCqX2iivxC9Vz3jBNBL7Y3RQMFTEiOsbr5nT3PmsR_DovGhHXeMPHGNBjO3LAuAY24A/y-pqknBf6_YUH_KgxiwCZWVcPIV2XEWG39qhpvlP1Ng'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,"33120A Function / Arbitrary Waveform Generator, 15 MHz",https://www.keysight.com/us/en/product/33120A/function--arbitrary-waveform-generator-15-mhz.html,HP 33120 A,183.0,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp33120A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp33120A.html,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782488/Instruments/Function%20Generators/Keysight-33120A/Keysight-33120A.jpg,Keysight 33120A,Write a Python script that uses Pymeasure to connect to a Keysight 33120A Function Generators,400.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class HP33120A(Instrument):
    """""" Represents the Hewlett Packard 33120A Arbitrary Waveform
    Generator and provides a high-level interface for interacting
    with the instrument.
    """"""

    SHAPES = {
        'sinusoid': 'SIN', 'square': 'SQU', 'triangle': 'TRI',
        'ramp': 'RAMP', 'noise': 'NOIS', 'dc': 'DC', 'user': 'USER'
    }
    shape = Instrument.control(
        ""SOUR:FUNC:SHAP?"", ""SOUR:FUNC:SHAP %s"",
        """""" A string property that controls the shape of the wave,
        which can take the values: sinusoid, square, triangle, ramp,
        noise, dc, and user. """""",
        validator=strict_discrete_set,
        values=SHAPES,
        map_values=True
    )
    frequency = Instrument.control(
        ""SOUR:FREQ?"", ""SOUR:FREQ %g"",
        """""" A floating point property that controls the frequency of the
        output in Hz. The allowed range depends on the waveform shape
        and can be queried with :attr:`~.max_frequency` and
        :attr:`~.min_frequency`. """"""
    )
    max_frequency = Instrument.measurement(
        ""SOUR:FREQ? MAX"",
        """""" Reads the maximum :attr:`~.HP33120A.frequency` in Hz for the given shape """"""
    )
    min_frequency = Instrument.measurement(
        ""SOUR:FREQ? MIN"",
        """""" Reads the minimum :attr:`~.HP33120A.frequency` in Hz for the given shape """"""
    )
    amplitude = Instrument.control(
        ""SOUR:VOLT?"", ""SOUR:VOLT %g"",
        """""" A floating point property that controls the voltage amplitude of the
        output signal. The default units are in  peak-to-peak Volts, but can be
        controlled by :attr:`~.amplitude_units`. The allowed range depends
        on the waveform shape and can be queried with :attr:`~.max_amplitude`
        and :attr:`~.min_amplitude`. """"""
    )
    max_amplitude = Instrument.measurement(
        ""SOUR:VOLT? MAX"",
        """""" Reads the maximum :attr:`~.amplitude` in Volts for the given shape """"""
    )
    min_amplitude = Instrument.measurement(
        ""SOUR:VOLT? MIN"",
        """""" Reads the minimum :attr:`~.amplitude` in Volts for the given shape """"""
    )
    offset = Instrument.control(
        ""SOUR:VOLT:OFFS?"", ""SOUR:VOLT:OFFS %g"",
        """""" A floating point property that controls the amplitude voltage offset
        in Volts. The allowed range depends on the waveform shape and can be
        queried with :attr:`~.max_offset` and :attr:`~.min_offset`. """"""
    )
    max_offset = Instrument.measurement(
        ""SOUR:VOLT:OFFS? MAX"",
        """""" Reads the maximum :attr:`~.offset` in Volts for the given shape """"""
    )
    min_offset = Instrument.measurement(
        ""SOUR:VOLT:OFFS? MIN"",
        """""" Reads the minimum :attr:`~.offset` in Volts for the given shape """"""
    )
    AMPLITUDE_UNITS = {'Vpp': 'VPP', 'Vrms': 'VRMS', 'dBm': 'DBM', 'default': 'DEF'}
    amplitude_units = Instrument.control(
        ""SOUR:VOLT:UNIT?"", ""SOUR:VOLT:UNIT %s"",
        """""" A string property that controls the units of the amplitude,
        which can take the values Vpp, Vrms, dBm, and default.
        """""",
        validator=strict_discrete_set,
        values=AMPLITUDE_UNITS,
        map_values=True
    )

    def __init__(self, adapter, name=""Hewlett Packard 33120A Function Generator"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.amplitude_units = 'Vpp'

    def beep(self):
        """""" Causes a system beep. """"""
        self.write(""SYST:BEEP"")
"
89,https://www.keysight.com/us/en/assets/9018-05117/user-manuals/9018-05117.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attFCic0uc57SntNt'), ('width', 700), ('height', 431), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/p5MDk5lzUdYyp8VN7U5mPA/OqHU0bL_8H1CceoOiXd6UBnI6gdEOJn7xedCRNCS6xLRAuCSWI6M_QRON3CpP9fFTVAwVQxsyKDdqRRaO4gQ03ZQvFfRnnmG73Da-dk8KqU/c4CH2IPigvtce6d_3RlZ0ojfetopTbF0iahjWa1af8k'), ('filename', 'prod_8116a1.jpg'), ('size', 178718), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/aVXH0FtD8HGE0azzNw1GXA/sMa86yJ8ABbzFutHi2J7vGvqEkzNuQxA_I_v_l3paoGLX6m44qvfzbQTEsFK00tJFVFp4dZ_jf3mrG802wpiuA/HCtT1nG-tWlZ0B388H7AVgFg4rPk0odVjsFsBOwvG5c'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/z55xEv1PvZIab5k8pm7rmA/a9w0HtdebMqFocDytWHiVsMCAuPRytwgNgJ0x6c_oraOiF46VNv-0Xg6p3en5HPDQepJQ9WBOL3hgG8uIS28bg/cZk75vnvVZV5dX4sFTKXRod6VKg_6Q-XhOTnszeds-M'), ('width', 700), ('height', 431)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qtx3ldUKAMaYh4PNbEng5Q/EH0NofDWZXb8qBXYN8ny0jsaRNx3sjFLeh2IjDq6IoaqhWLCYIKIub1GcpjDUX82YJE9J877pp3vu5dOQf0M1w/ydYxg5wzAJwgI-lzvzTz1u6VSWeMENuqyBB7VyZEESU'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,8116A 50 MHZ PULSE/FUNCTION GENERATOR,https://www.keysight.com/us/en/product/8116A/50-mhz-pulsefunction-generator.html,HP 8116 A,187.0,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp8116a.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp8116A.html,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782497/Instruments/Function%20Generators/Keysight-8116A/Keysight-8116A.jpg,Keysight 8116A,Write a Python script that uses Pymeasure to connect to a Keysight 8116A Function Generators,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import numpy as np
from enum import Enum, IntFlag
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set, strict_range, truncated_discrete_set
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Status(IntFlag):
    """""" IntFlag type for the GPIB status byte which is returned by the :py:attr:`status` property.
    When the timing_error or programming_error flag is set, a more detailed error description
    can be obtained by calling :py:method:`check_errors()`.
    """"""
    timing_error = 1 << 0
    programming_error = 1 << 1
    syntax_error = 1 << 2
    system_failure = 1 << 3
    autovernier_in_progress = 1 << 4
    sweep_in_progress = 1 << 5
    service_request = 1 << 6
    buffer_not_empty = 1 << 7


class HP8116A(Instrument):
    """""" Represents the Hewlett-Packard 8116A 50 MHz Pulse/Function Generator
    and provides a high-level interface for interacting with the instrument.
    The resolution for all floating point instrument parameters is 3 digits.
    """"""

    def __init__(self, adapter, name=""Hewlett-Packard 8116A"", **kwargs):
        kwargs.setdefault('read_termination', '\r\n')
        kwargs.setdefault('write_termination', '\r\n')
        kwargs.setdefault('send_end', True)
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs
        )
        self.has_option_001 = self._check_has_option_001()

    class Digit(Enum):
        """""" Enum of the digits used with the autovernier
        (see :py:meth:`HP8116A.start_autovernier()`).
        """"""
        MOST_SIGNIFICANT = 'M'
        SECOND_SIGNIFICANT = 'S'
        LEAST_SIGNIFICANT = 'L'

    class Direction(Enum):
        """""" Enum of the directions used with the autovernier
        (see :py:meth:`HP8116A.start_autovernier()`).
        """"""
        UP = 'U'
        DOWN = 'D'

    OPERATING_MODES = {
        'normal': 'M1',
        'triggered': 'M2',
        'gate': 'M3',
        'external_width': 'M4',

        # Option 001 only
        'internal_sweep': 'M5',
        'external_sweep': 'M6',
        'internal_burst': 'M7',
        'external_burst': 'M8',
    }

    OPERATING_MODES_INV = {v: k for k, v in OPERATING_MODES.items()}

    CONTROL_MODES = {
        'off': 'CT0',
        'FM': 'CT1',
        'AM': 'CT2',
        'PWM': 'CT3',
        'VCO': 'CT4',
    }

    CONTROL_MODES_INV = {v: k for k, v in CONTROL_MODES.items()}

    TRIGGER_SLOPES = {
        'off': 'T0',
        'positive': 'T1',
        'negative': 'T2',
    }

    TRIGGER_SLOPES_INV = {v: k for k, v in TRIGGER_SLOPES.items()}

    SHAPES = {
        'dc': 'W0',
        'sine': 'W1',
        'triangle': 'W2',
        'square': 'W3',
        'pulse': 'W4',
    }

    SHAPES_INV = {v: k for k, v in SHAPES.items()}

    _units_frequency = {
        'milli': 'MZ',
        'no_prefix': 'HZ',
        'kilo': 'KHZ',
        'mega': 'MHZ',
    }

    _units_voltage = {
        'milli': 'MV',
        'no_prefix': 'V',
    }

    _units_time = {
        'nano': 'NS',
        'micro': 'US',
        'milli': 'MS',
        'no_prefix': 'S',
    }

    _si_prefixes = {
        'nano': 1e-9,
        'micro': 1e-6,
        'milli': 1e-3,
        'no_prefix': 1,
        'kilo': 1e3,
        'mega': 1e6,
    }

    @staticmethod
    def _get_value_with_unit(value, units):
        """""" Convert a floating point value to a string with 3 digits resolution
        and the appropriate unit.

        :param value: The value to convert.
        :param units: Dictionary containing a mapping of SI-prefixes to the unit strings
            the instrument uses, eg. 'milli' -> 'MZ' for millihertz.
        """"""
        if value < 1e-6:
            value_str = f'{value*1e9:.3g} {units[""nano""]}'
        elif value < 1e-3:
            value_str = f'{value*1e6:.3g} {units[""micro""]}'
        elif value < 1:
            value_str = f'{value*1e3:.3g} {units[""milli""]}'
        elif value < 1e3:
            value_str = f'{value:.3g} {units[""no_prefix""]}'
        elif value < 1e6:
            value_str = f'{value*1e-3:.3g} {units[""kilo""]}'
        else:
            value_str = f'{value*1e-6:.3g} {units[""mega""]}'

        return value_str

    @staticmethod
    def _parse_value_with_unit(value_str, units):
        """""" Convert a string with a value and a unit as returned by the HP8116A to a float.

        :param value_str: The string to parse.
        :param units: Dictionary containing a mapping of SI-prefixes to the unit strings
            the instrument uses, eg. 'milli' -> 'MZ' for millihertz.
        """"""

        # Example value_str: 'FRQ 1.00KHZ'
        # Digits and unit are always positioned the same for all parameters
        value_str = value_str.strip()
        value = float(value_str[3:8].strip())
        unit = value_str[8:].strip()
        units_inverse = {v: k for k, v in units.items()}
        value *= HP8116A._si_prefixes[units_inverse[unit]]

        return value

    def _generate_1_2_5_sequence(min, max):
        """""" Generate a list of a 1-2-5 sequence between min and max. """"""
        exp_min = int(np.log10(min))
        exp_max = int(np.log10(max))

        seq_1_2_5 = np.array([1, 2, 5])
        sequence = np.array([seq_1_2_5 * (10 ** exp) for exp in range(exp_min - 1, exp_max + 1)])
        sequence = sequence.flatten()
        sequence = sequence[(sequence >= min) & (sequence <= max)]

        return list(sequence)

    def _boolean_control(identifier, state_index, docs, inverted=False, **kwargs):
        return Instrument.control(
            'CST', identifier + '%d', docs,
            validator=strict_discrete_set,
            values=[True, False],
            get_process=lambda x: inverted ^ bool(int(x[state_index][1])),
            set_process=lambda x: int(inverted ^ x),
            **kwargs
        )

    # Instrument communication #

    def write(self, command):
        """""" Write a command to the instrument and wait until the 8116A has interpreted it. """"""
        super().write(command)

        # We need to read the status byte and wait until the buffer_not_empty bit
        # is cleared because some older units lock up if we don't.
        self._wait_for_commands_processed()

    def ask(self, command, num_bytes=None):
        """""" Write a command to the instrument, read the response, and return the response as ASCII text.

        :param command: The command to send to the instrument.
        :param num_bytes: The number of bytes to read from the instrument. If not specified,
                          the number of bytes is automatically determined by the command.
        """"""  # noqa: E501
        self.write(command)

        if num_bytes is None:
            if command == 'CST':
                # We usually only need the first 29 bytes of the state response since they contain
                # the current boolean parameters. The other parameters all have corresponding
                # 'interrogate' commands.
                num_bytes = 29
            elif command[0] == 'I':
                num_bytes = 14

        # The first character is always a space or a leftover character from the previous command,
        # when the number of bytes read was too large or too small.
        bytes = self.read_bytes(num_bytes)[1:]
        return bytes.decode('ascii').strip(' ,\r\n')

    operating_mode = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the operating mode of the instrument.
        Possible values (without Option 001) are: 'normal', 'triggered', 'gate', 'external_width'.
        With Option 001, 'internal_sweep', 'external_sweep', 'external_width', 'external_pulse'
        are also available.
        """""",
        validator=strict_discrete_set,
        values=OPERATING_MODES,
        map_values=True,
        get_process=lambda x: HP8116A.OPERATING_MODES_INV[x[0]]
    )

    control_mode = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the control mode of the instrument.
        Possible values are 'off', 'FM', 'AM', 'PWM', 'VCO'.
        """""",
        validator=strict_discrete_set,
        values=CONTROL_MODES,
        map_values=True,
        get_process=lambda x: HP8116A.CONTROL_MODES_INV[x[1]]
    )

    trigger_slope = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the slope the trigger triggers on.
        Possible values are: 'off', 'positive', 'negative'.
        """""",
        validator=strict_discrete_set,
        values=TRIGGER_SLOPES,
        map_values=True,
        get_process=lambda x: HP8116A.TRIGGER_SLOPES_INV[x[2]]
    )

    shape = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the shape of the output waveform.
        Possible values are: 'dc', 'sine', 'triangle', 'square', 'pulse'.
        """""",
        validator=strict_discrete_set,
        values=SHAPES,
        map_values=True,
        get_process=lambda x: HP8116A.SHAPES_INV[x[3]]
    )

    haversine_enabled = _boolean_control(
        'H', 4,
        """""" A boolean property that controls whether a haversine/havertriangle signal
        is generated when in 'triggered', 'internal_burst' or 'external_burst' operating mode.
        """""",
    )

    autovernier_enabled = _boolean_control(
        'A', 5,
        """""" A boolean property that controls whether the autovernier is enabled. """""",
        check_set_errors=True
    )

    limit_enabled = _boolean_control(
        'L', 6,
        """""" A boolean property that controls whether parameter limiting is enabled. """""",
    )

    complement_enabled = _boolean_control(
        'C', 7,
        """""" A boolean property that controls whether the complement
        of the signal is generated.
        """""",
    )

    output_enabled = _boolean_control(
        'D', 8,
        """""" A boolean property that controls whether the output is enabled. """""",
        inverted=True,  # The actual command is ""Disable output""...
    )

    frequency = Instrument.control(
        'IFRQ', 'FRQ %s',
        """""" A floating point value that controls the frequency of the
        output in Hz. The allowed frequency range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    duty_cycle = Instrument.control(
        'IDTY', 'DTY %s %%',
        """""" An integer value that controls the duty cycle of the output in percent.
        The allowed range generally is 10 % to 90 %, but it also depends on the current frequency.
        It is valid for all shapes except 'pulse', where :py:attr:`pulse_width` is used instead.
        """""",
        validator=strict_range,
        values=[10, 90.0001],
        cast=int,
        # get_process=lambda x: int(x[6:8])
    )

    pulse_width = Instrument.control(
        'IWID', 'WID %s',
        """""" A floating point value that controls the pulse width.
        The allowed pulse width range is 8 ns to 999 ms.
        The pulse width may not be larger than the period.
        """""",
        validator=strict_range,
        values=[8e-9, 999.001e-3],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    amplitude = Instrument.control(
        'IAMP', 'AMP %s',
        """""" A floating point value that controls the amplitude of the
        output in V. The allowed amplitude range generally is 10 mV to 16 V,
        but it is also limited by the current offset.
        """""",
        validator=strict_range,
        values=[10e-3, 16.001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    offset = Instrument.control(
        'IOFS', 'OFS %s',
        """""" A floating point value that controls the offset of the
        output in V. The allowed offset range generally is -7.95 V to 7.95 V,
        but it is also limited by the amplitude.
        """""",
        validator=strict_range,
        values=[-7.95, 7.95001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    high_level = Instrument.control(
        'IHIL', 'HIL %s',
        """""" A floating point value that controls the high level of the
        output in V. The allowed high level range generally is -7.9 V to 8 V,
        but it must be at least 10 mV greater than the low level.
        """""",
        validator=strict_range,
        values=[-7.9, 8.001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    low_level = Instrument.control(
        'ILOL', 'LOL %s',
        """""" A floating point value that controls the low level of the
        output in V. The allowed low level range generally is -8 V to 7.9 V,
        but it must be at least 10 mV less than the high level.
        """""",
        validator=strict_range,
        values=[-8, 7.9001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    burst_number = Instrument.control(
        'IBUR', 'BUR %s #',
        """""" An integer value that controls the number of periods generated in a burst.
        The allowed range is 1 to 1999. It is only valid for units with Option 001
        in one of the burst modes.
        """""",
        validator=strict_range,
        values=[1, 1999],
        get_process=lambda x: int(x[4:8])
    )

    repetition_rate = Instrument.control(
        'IRPT', 'RPT %s',
        """""" A floating point value that controls the repetition rate (= the time between bursts)
        in 'internal_burst' mode. The allowed range is 20 ns to 999 ms.
        """""",
        validator=strict_range,
        values=[20e-9, 999.001e-3],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    sweep_start = Instrument.control(
        'ISTA', 'STA %s',
        """""" A floating point value that controls the start frequency in both sweep modes.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_stop = Instrument.control(
        'ISTP', 'STP %s',
        """""" A floating point value that controls the stop frequency in both sweep modes.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_marker_frequency = Instrument.control(
        'IMRK', 'MRK %s',
        """""" A floating point value that controls the frequency marker in both sweep modes.
        At this frequency, the marker output switches from low to high.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_time = Instrument.control(
        'ISWT', 'SWT %s',
        """""" A floating point value that controls the sweep time per decade in both sweep modes.
        The sweep time is selectable in a 1-2-5 sequence between 10 ms and 500 s.
        """""",
        validator=truncated_discrete_set,
        values=_generate_1_2_5_sequence(10e-3, 500),
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    @property
    def status(self):
        """""" Returns the status byte of the 8116A as an IntFlag-type enum. """"""
        return Status(self.adapter.connection.read_stb())

    @property
    def complete(self):
        return not (self.status & Status.buffer_not_empty)

    @property
    def options(self):
        """""" Return the device options installed. The only possible option is 001. """"""
        if self.has_option_001:
            return ['001']
        else:
            return []

    def start_autovernier(self, control, digit, direction, start_value=None):
        """""" Start the autovernier on the specified control.

        :param control: The control to change, pass as :code:`HP8116A.some_control`. Allowed
                        controls are frequency, amplitude, offset, duty_cycle, and pulse_width
        :param digit: The digit to change, type: :py:class:`HP8116A.Digit`.
        :param direction: The direction in which to change the control,
                          type: :py:class:`HP8116A.Direction`.
        :param start_value: An optional value to start the autovernier at. If not specified,
                            the current value of the control is used.
        """"""
        if not self.autovernier_enabled:
            raise RuntimeError('Autovernier has to be enabled first.')

        if control not in (HP8116A.frequency, HP8116A.amplitude, HP8116A.offset,
                           HP8116A.duty_cycle, HP8116A.pulse_width):
            raise ValueError('Control must be one of frequency, amplitude, offset, ' +
                             'duty_cycle, or pulse_width.')

        start_value = control.fget(self) if start_value is None else start_value
        # The control always has to be set to select it for the autovernier.
        control.fset(self, start_value)

        self.write(digit.value + direction.value)

    def GPIB_trigger(self):
        """""" Initate trigger via low-level GPIB-command (aka GET - group execute trigger). """"""
        self.adapter.connection.assert_trigger()

    def reset(self):
        """""" Initatiate a reset (like a power-on reset) of the 8116A. """"""
        self.adapter.connection.clear()
        self._wait_for_commands_processed()

    def shutdown(self):
        """""" Gracefully close the connection to the 8116A. """"""
        self.adapter.connection.clear()
        self.adapter.connection.close()
        super().shutdown()

    def check_errors(self):
        """""" Check for errors in the 8116A.

        :return: list of error entries or empty list if no error occurred.
        """"""
        errors_response = self.ask('IERR', 100).split('\r\n')[0].strip(' ,\r\n')
        errors = errors_response.split('ERROR')[:-1]
        errors = [e.strip() + "" ERROR"" for e in errors]

        if errors[0] == 'NO ERROR':
            return []
        else:
            for error in errors:
                log.error(f'{self.name}: {error}')
            return errors

    def _wait_for_commands_processed(self, timeout=1):
        """""" Wait until the commands have been processed by the 8116A. """"""
        start = time.time()
        while not self.complete:
            time.sleep(0.001)
            if time.time() - start > timeout:
                raise RuntimeError('Timeout waiting for commands to be processed.')

    def _check_has_option_001(self):
        """""" Return True if the 8116A has option 001 and False otherwise.

        This is done by checking the length of the response to the CST (current status) command
        which includes sweep parameters and burst parameters only if the 8116A has option 001.
        """"""

        # The longest possible state string is 163 characters long including termination characters
        state_string = self.ask('CST', 163).split('\r\n')[0].strip(' ,\r\n')

        if len(state_string) == 159:
            return True
        elif len(state_string) == 87:
            return False
        else:
            log.warning('Could not determine if 8116A has option 001. Assuming it has.')
            return True
"
96,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/425.pdf?sfvrsn=1581d8be_6,https://en.wikipedia.org/wiki/Magnetometer,"[OrderedDict([('id', 'attqoQm3frhx3s4le'), ('width', 505), ('height', 268), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5dHTeUb67bZu_AaDxH5dLA/gR-WwBaV6w6aqEH8kpfwGi-qfgZ03xFM0PEjEIfmml4B6ffNs_qN96fJgmr489YZD-K5LtJOwYFezp2ongSvsA/kA_6Pl3JLS0RG1uTij60Q7WhDStCTprv1qh-vl1LBBk'), ('filename', '425.png'), ('size', 159132), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nC0-uQMS5t3DhB8dq03fGg/dBOqHKCpmc_x99ZL-e35QXtvv7uVvRqe8GTurt1PeftrNJcu2lxMxIgJS6pDPgAXCkJwwwpjY8FIpBUCu0dSAw/Wfc3yTIG-QFkgyhJhe7WrvVtJU6AsFruh8VF2JFlnms'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1JJUL19X1kvMGPZybHLkbw/oaHb-Be3Irq4f2v-8dVPwtQo9PepY66FrCiVLJsFjqTBF3e4aglJwuQ0jIjOqF6Zvbdc_apZBBBy_rF_jN6LPw/SiJ8wD5T-Ikt36wj8FW3E6lVirKT8xibEsWZF8RhOG0'), ('width', 505), ('height', 268)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3FojK7GC4tTpaTHth8G2ZA/EUlqzDVbWr9LyR_SwArv3Em_ore2RYz8l7ER15VzwmZwQJvu8lnN4ro109vOkP7_FjgQJ093G6OlMwrxRdXulw/EKu4V43ykLx5oawU-P1FDslnEWw3wumE3r-tviO22_U'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"Lake Shore Model 425 gaussmeter provides high-end functionality and performance in an affordable desktop instrument. Magnet testing and sorting have never been easier. When used in combination with the built-in relay and audible alarm features, the Model 425 takes the guesswork out of pass/fail criteria. Additional features including DC to 10 kHz AC frequency response, max hold and relative measurement make the Model 425 the ideal tool for your manufacturing, quality control and R&D flux density measurement applications. Put the Model 425 gaussmeter to use with confidence knowing it’s supported by industry leading experts in magnet measurement instrument, sensor, and Hall probe technology.",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-425-gaussmeter,Lakeshore 425,346.0,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore425.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore425.html,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782503/Instruments/Power%20Meters/Lakeshore-425/Lakeshore-425.png,Lakeshore 425,Write a Python script that uses Pymeasure to connect to a Lakeshore 425 Power Meters,2315.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, truncated_discrete_set

from time import sleep
import numpy as np


class LakeShore425(Instrument):
    """""" Represents the LakeShore 425 Gaussmeter and provides
    a high-level interface for interacting with the instrument

    To allow user access to the LakeShore 425 Gaussmeter in Linux,
    create the file:
    :code:`/etc/udev/rules.d/52-lakeshore425.rules`, with contents:

    .. code-block:: none

        SUBSYSTEMS==""usb"",ATTRS{idVendor}==""1fb9"",ATTRS{idProduct}==""0401"",MODE=""0666"",SYMLINK+=""lakeshore425""

    Then reload the udev rules with:

    .. code-block:: bash

        sudo udevadm control --reload-rules
        sudo udevadm trigger

    The device will be accessible through :code:`/dev/lakeshore425`.
    """"""

    field = Instrument.measurement(
        ""RDGFIELD?"",
        """""" Returns the field in the current units """"""
    )
    unit = Instrument.control(
        ""UNIT?"", ""UNIT %d"",
        """""" A string property that controls the units of the instrument,
        which can take the values of G, T, Oe, or A/m. """""",
        validator=strict_discrete_set,
        values={'G': 1, 'T': 2, 'Oe': 3, 'A/m': 4},
        map_values=True
    )
    range = Instrument.control(
        ""RANGE?"", ""RANGE %d"",
        """""" A floating point property that controls the field range in
        units of Gauss, which can take the values 35, 350, 3500, and
        35,000 G. """""",
        validator=truncated_discrete_set,
        values={35: 1, 350: 2, 3500: 3, 35000: 4},
        map_values=True
    )

    def __init__(self, adapter, name=""LakeShore 425 Gaussmeter"", **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'write_termination': ""\n"",
                  'read_termination': ""\n"",  # from manual
                  'baud_rate': 57600,
                  'timeout': 500,
                  'parity': 1,  # odd
                  'data_bits': 7
                  },
            **kwargs
        )

    def auto_range(self):
        """""" Sets the field range to automatically adjust """"""
        self.write(""AUTO"")

    def dc_mode(self, wideband=True):
        """""" Sets up a steady-state (DC) measurement of the field """"""
        if wideband:
            self.mode = (1, 0, 1)
        else:
            self.mode(1, 0, 2)

    def ac_mode(self, wideband=True):
        """""" Sets up a measurement of an oscillating (AC) field """"""
        if wideband:
            self.mode = (2, 1, 1)
        else:
            self.mode = (2, 1, 2)

    @property
    def mode(self):
        return tuple(self.values(""RDGMODE?""))

    @mode.setter
    def mode(self, value):
        """""" Provides access to directly setting the mode, filter, and
        bandwidth settings
        """"""
        mode, filter, band = value
        self.write(""RDGMODE %d,%d,%d"" % (mode, filter, band))

    def zero_probe(self):
        """""" Initiates the zero field sequence to calibrate the probe """"""
        self.write(""ZPROBE"")

    def measure(self, points, has_aborted=lambda: False, delay=1e-3):
        """"""Returns the mean and standard deviation of a given number
        of points while blocking
        """"""
        data = np.zeros(points, dtype=np.float32)
        for i in range(points):
            if has_aborted():
                break
            data[i] = self.field
            sleep(delay)
        return data.mean(), data.std()
"
97,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_331_l.pdf?sfvrsn=5d8525f8_1,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attW95TFgpWcCokKy'), ('width', 505), ('height', 273), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cYQMqYgdOmhwe7z0GKqdUg/maXn_PWZVx-CKNcx8Aa31g-VOAVFScHR0EV89606CzUk04k3Yi4W0A15A7eGqdYhfo2BGVpERr_6YKkza6NKqA/TbzjxL19ZZP1di2rPkTPX6FTdxNgYSFFAuNLnu50iw0'), ('filename', '331.png'), ('size', 155224), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PMD2C_USEwSJLJ5CcgsRww/rBrn6PtRemc1G4hX3vsiZnegeIjIjNQjvWm7BXhb7dVdF4rWA6btrzpxJXsDvRovWe8h973WvBDPN1w_KHXjfA/ohWswjGHG60zOkL5or-G14mxQC7oj7e6Bs8eLgRCdDY'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U0_xwI--cx6JNraZ0ZCnOw/FjrBSD7NsSfJOiMt-A_NtbCStfqUUtPgTTqdwW7B_VhJavAif8b93zbFVsoYG52gx6LMA3-IR7Zo6OZMQtXvjQ/ZjSa5jT9JQUWMP-MONU9YxV0s3MUSdy-MYxSghz8FN8'), ('width', 505), ('height', 273)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Rs-E1Z3Yn76jZF0r7K5BOQ/6O3Y9X158qU_pHGyEcaTQiVUbuufTgESxli3xJzIQADkr3q2824L1UrBYyLxSmuV30tXaPq2wsCAaEIqYTV9Dw/D4qRyKVRMhfA5HPSKA1WHScBU3H-nNo7IHIThzn4T6w'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125966/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 331 cryogenic temperature controller combines the easy operation and unsurpassed reliability of the Model 330 with improved sensor input and interface flexibility, including compatibility with negative temperature coefficient (NTC) resistance temperature detectors (RTDs). Backed by the Lake Shore tradition of excellence in cryogenic sensors and instrumentation, the Model 331 temperature controller sets the standard for mid-price range temperature control instruments.",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-331-cryogenic-temperature-controller,Lakeshore 331,365.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore331.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore331.html,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FpjH1tTnVvca7OmYHWD4Mg/-2iNg_uDv7EjlZa8i0z_Zy_jwR8jHC9pom6u5pkxznXhPZNBlEH7welGBP6lPMYJxrgugWmyP9DIQNHMxR6xK_zEyjDTN-6kJ1QdJicu67Y/FYVVTnA-Y7mpOtlazqxBzj_j9C3TbsfKdSQ0ThftlIU'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9xVGc-_2IEr__gznTebkhg/wwU5sTsj9o20DP8cZ28nTi_5_yppI-L1O4lE_qbluU-YPihfA8aqNWCVbJ5WCzXK4JO4gVYu1IwL5Z1aSbqj1fj1wpjedjZ7oWBIR9pcoHg/alqaxtMgBtuHHs0kJsW03G2WVUnAM9ztrmJnESpc_qg'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/X7j1NfKEgYAdZGJgYyM-rQ/rHtOQxqIwMemJ9pOMnHvBqp3eMh3nuIbcju0utXr-JoMSB4H_xmlBlDw5waGBnC8D1oMQriZBE1weu3wHWHF6S8fqMx-xRE0fqvirjHSvNk/e6S0M51sEAWo5TWivO7hJFNhav4qqGAEfgebk8Wk7is'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y8Ma953fBzPAjULdDTw_SQ/yLubLk1kiaNvZylNrdoTasA0n7RnqpFBKrSOckvcXqEUVxo9G08mo8vMJaQiw-cXEwv7u-6MvJKMicPcnGfaXrZ9L_GmI749uOp0OE62Jbg/X0vdNkuICOYDx4wxzDiQX6SFalbKnezAOE6mWPUHspY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782504/Instruments/Temperature%20Controllers/Lakeshore-331/Lakeshore-331.png,Lakeshore 331,Write a Python script that uses Pymeasure to connect to a Lakeshore 331 Temperature Controllers,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.lakeshore.lakeshore_base import LakeShoreTemperatureChannel, \
    LakeShoreHeaterChannel

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class LakeShore331(Instrument):
    """""" Represents the Lake Shore 331 Temperature Controller and provides
    a high-level interface for interacting with the instrument. Note that the
    331 provides two input channels (A and B) and two output channels (1 and 2).
    This driver makes use of the :ref:`LakeShoreChannels`.

    .. code-block:: python

        controller = LakeShore331(""GPIB::1"")

        print(controller.output_1.setpoint)         # Print the current setpoint for loop 1
        controller.output_1.setpoint = 50           # Change the loop 1 setpoint to 50 K
        controller.output_1.heater_range = 'low'    # Change the heater range to low.
        controller.input_A.wait_for_temperature()   # Wait for the temperature to stabilize.
        print(controller.input_A.temperature)       # Print the temperature at sensor A.
    """"""
    input_A = Instrument.ChannelCreator(LakeShoreTemperatureChannel, 'A')

    input_B = Instrument.ChannelCreator(LakeShoreTemperatureChannel, 'B')

    output_1 = Instrument.ChannelCreator(LakeShoreHeaterChannel, 1)

    output_2 = Instrument.ChannelCreator(LakeShoreHeaterChannel, 2)

    def __init__(self, adapter, name=""Lakeshore Model 336 Temperature Controller"", **kwargs):
        kwargs.setdefault('read_termination', ""\r\n"")
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
100,https://razorbillinstruments.com/wp-content/uploads/2018/10/RP100-Manual-v6.1-1.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attZaMT95mRfMJMtO'), ('width', 1596), ('height', 709), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TxCw1bsLcGONcx7MxD5Raw/16irExtX8rMvHFkbOqA3t_i4HcP_OSMy-GGuzhd-q103wkjZDay3eM3n49epXX9jTzEShAzG7tss1uN4Q72wnsSVhWAqbFp3AB9NEz7NrOE/bS33wQXZC7RP1qFRp71SvzbOJLnIcJTmhdebeQ4PGfo'), ('filename', 'rendering7.jpeg'), ('size', 105627), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yUpXSOiF9fq3EwS8zS_3uw/KjB6EA76M7YT9hAI95FSe9QmhuOnpUqNjrnH2_pKYSXDF1JWK_fO9EqXrhQhb66P5w-MwpiDY5_fYCScze5wAg/bUtm1j0HZ3geWHOJcVsqDVy3LTcB4J3ih1LqgR1ivYQ'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VWWAd3LXJ6G8GHA9PAk5qQ/RGZOLYWkHy_zPZnA7K5a-E4xHt8NOaMhb4VAnO-G1yaRPOTNqUouJqtRBAOGdJd7bZyDvixYmsBmVTkYFSzsng/iGlmqpNPubiOCwFJx_fPO1VSHISt8gabk1X1LCPp-AU'), ('width', 1153), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iQCKkRsm4raXb71KAQikkw/f3tM8dQUIqs0BWMBFS9maR37gcbTLX9RP7-hSzaea6aH5mY7vi2KAKQjFuswEltjCYbCNYQ9-KamOzhJEo8OHA/b3773crSbSnlgkI0TZeCR_bmYw9tCIZJWROuSHyiXhw'), ('width', 3000), ('height', 3000)]))]))])]",5.0,"Edinburgh, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125964/Instruments/Vendor%20Logos/Razorbill_Instruments.png,"The RP100 is a two channel, sink-source power supply
designed to drive the CS100 series strain cells and the FC100
series stress cells. This power supply can be used in conjunction
with the corresponding range of compatible Razorbill Instruments
products to tune the electronic properties of materials by applying
controlled strains and stresses to the material. ",https://razorbillinstruments.com/wp-content/uploads/2018/10/RP100-Manual-v6.1-1.pdf,Razorbillrp 100,441.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Manufacturer of precision instruments intended for use in fundamental physics and space applications. The company manufactures electromechanical mechanisms to apply tunable uniaxial strains at low temperatures and high magnetic fields and provides expertise in the field of design for cryogenic environments, compliant mechanisms and compact systems for applying and measuring strain, enabling clients to incorporate a number of unique key technologies that allow them to have such high performance and repeatability.

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/razorbill/razorbillRP100.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/razorbill/razorbillRP100.html,Razorbill,"[OrderedDict([('id', 'attKAoLkJBDty1WX0'), ('width', 389), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-omkFjiiuRzthobnFmKQpg/yXpxkhIk3PAXI9p4H5ngWO2Md4inua4QH03KDMqyGZrvfs5k7WjctodBJqCln9IwQ-F-JTY5JMrEzqRCY9vEheWPALNRoN4HFhwZX8zAGYI/RzwNDaoYTUQhg61lPXyO7eMht0nbooI_VSOpZSFKyWY'), ('filename', 'xrfz14rxhnve5cmpv58y.jpg'), ('size', 4388), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7Gk8ONOeHIFI2Z2SwCe7Dg/SH1w6sJqFUIe2qIjfZjFHI_4o75JVUdPQ3mm0-SgJLeOdKXqDThaUFIr3XNfIbZWkAGdJGJrlAiD9AjFQD7_Dg/hnwQdi6tbbdldDavhDAUs-BzGEpH5aizYwN1aS-bubs'), ('width', 93), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vNp7gN9DfCaKt2gqP8ayZA/xQmB7kSfT8aKg7TZ6tZjHqA0HHj9ZeN9N_5dS5KncPM_gofjF3Ns9nBP7CQ_vAlnVdLxgLLCKf4t1-iaVVeakg/jg9r5ucpmoBJYRqFBIey_29bMZb0lorGIALF33GSk0U'), ('width', 389), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XV_Fb6wXFWmPpoEzp5UOXQ/q-M9_GsqUTOe0w0MZZ7-_8Cg9t0kvOkJmSgiphLJfBYZoWm5GT5x-MwnPOFtuuD1bOCOyzA6uYFBKi-vBhNavg/6E6WotHzPbkBRjAsue6eChRZhWo5XhF4nSWrnkx7Jt0'), ('width', 3000), ('height', 3000)]))]))])]",https://razorbillinstruments.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782506/Instruments/Power%20Supplies/Razorbill-RP100/Razorbill-RP100.jpg,Razorbill RP100,Write a Python script that uses Pymeasure to connect to a Razorbill RP100 Power Supplies,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              strict_range)


class razorbillRP100(Instrument):
    """"""Represents Razorbill RP100 strain cell controller

    .. code-block:: python

        scontrol = razorbillRP100(""ASRL/dev/ttyACM0::INSTR"")

        scontrol.output_1 = True      # turns output on
        scontrol.slew_rate_1 = 1      # sets slew rate to 1V/s
        scontrol.voltage_1 = 10       # sets voltage on output 1 to 10V

    """"""

    output_1 = Instrument.control(""OUTP1?"", ""OUTP1 %d"",
                                  """"""Turns output of channel 1 on or off"""""",
                                  validator=strict_discrete_set,
                                  values={True: 1, False: 0},
                                  map_values=True)

    output_2 = Instrument.control(""OUTP2?"", ""OUTP2 %d"",
                                  """"""Turns output of channel 2 on or off"""""",
                                  validator=strict_discrete_set,
                                  values={True: 1, False: 0},
                                  map_values=True)

    voltage_1 = Instrument.control(""SOUR1:VOLT?"", ""SOUR1:VOLT %g"",
                                   """"""Sets or queries the output voltage of channel 1"""""",
                                   validator=strict_range,
                                   values=[-230, 230])

    voltage_2 = Instrument.control(""SOUR2:VOLT?"", ""SOUR2:VOLT %g"",
                                   """"""Sets or queries the output voltage of channel 2"""""",
                                   validator=strict_range,
                                   values=[-230, 230])

    slew_rate_1 = Instrument.control(
        ""SOUR1:VOLT:SLEW?"", ""SOUR1:VOLT:SLEW %g"",
        """"""Sets or queries the source slew rate in volts/sec of channel 1"""""",
        validator=strict_range,
        values=[0.1 * 10e-3, 100 * 10e3]
    )

    slew_rate_2 = Instrument.control(
        ""SOUR2:VOLT:SLEW?"", ""SOUR2:VOLT:SLEW %g"",
        """"""Sets or queries the source slew rate in volts/sec of channel 2"""""",
        validator=strict_range,
        values=[0.1 * 10e-3, 100 * 10e3]
    )

    instant_voltage_1 = Instrument.measurement(
        ""SOUR1:VOLT:NOW?"",
        """"""Returns the instantaneous output of source one in volts""""""
    )

    instant_voltage_2 = Instrument.measurement(
        ""SOUR2:VOLT:NOW?"",
        """"""Returns the instanteneous output of source two in volts""""""
    )

    contact_voltage_1 = Instrument.measurement(
        ""MEAS1:VOLT?"",
        """"""Returns the Voltage in volts present at the front panel output of channel 1""""""
    )

    contact_voltage_2 = Instrument.measurement(
        ""MEAS2:VOLT?"",
        """"""Returns the Voltage in volts present at the front panel output of channel 2""""""
    )

    contact_current_1 = Instrument.measurement(
        ""MEAS1:CURR?"",
        """"""Returns the current in amps present at the front panel output of channel 1""""""
    )

    contact_current_2 = Instrument.measurement(
        ""MEAS2:CURR?"",
        """"""Returns the current in amps present at the front panel output of channel 2""""""
    )

    def __init__(self, adapter, name=""Razorbill RP100 Piezo Stack Powersupply"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        self.timeout = 20
"
113,https://www.testequipmenthq.com/datasheets/KEITHLEY-2400-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attFCwQhJ4waLZGsg'), ('width', 327), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-IDVQL2dumx4dtgocQYeIg/HlMbrbT7bQJ9uUzX_D4Z-9shrSgyrgLPuV4pjsCIwl_w3STg2oG_ce_8OOpmW3giOkXGVVoRT6Eh53qU-N-1d5v1tX7OCIOt5jzW0zpSXec/GHaBrL5SjI8Y_gFykq-WGRcd8SByCAWqFDu2YO1jltU'), ('filename', '2400.webp'), ('size', 10742), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eF-VYAok6kIwdd8NoDCRbg/MeerM8u7vT3Z7vjH8z9TA8KcFKenY5odPN3Efl1v5G4-5RSXprxQrLWwZFtjagJyXl3VXbEQszD1K_oQNQ2CJ2PcgUVXW4Wi3pzFW4cxiUw/FIN84F4SywDB0fzJ7mRj8-nmS2WNKrzRaPvQy4HDXkg'), ('width', 38), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wOuBMESMPsArkJApQQOd2g/8zqb-wKJ9voqH-fXyJqM17tTCt7SSA0-f0KsSoQa4Ub4NWvD2fQhsTW0yRNi82V3ZDCNFs6x11pLcoIIGBuMqxJUOWhliqUVOTQgRRn9px8/jcwokQPcecWjTCxmyX9dlFfpWvCwCpF4k_U38HCS6mM'), ('width', 327), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tTHNSNZUNDf7gQntpLDmUA/UETXUV2M1h5lvTVF8-Z5hy2xQBJFD8nYZBQDNqk873VGLRGTsdiCsX7CtBYcG8kxE1uItbHT4s8feYqD3ettxbB90CZU277wUnH6Fpa0_4E/EMsETlDDVb0W4_j65mHaYUkxJeoUzeyWixCvx1fDsdo'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"Keithley’s Standard Series 2400 Source Measure Unit (SMU) Instruments offer four-quadrant precision voltage and current source/load coupled with measurement. Each SMU instrument is both a highly stable DC power source and a true instrument-grade 6½-digit multimeter. The power source characteristics include low noise, precision, and readback. The multimeter capabilities include high repeatability and low noise.",https://www.tek.com/en/products/keithley/source-measure-units/2400-standard-series-sourcemeter,Keithley 2400,270.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2400.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2400.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782492/Instruments/Power%20Supplies/Keithley-2400/Keithley-2400.webp,Keithley 2400,Write a Python script that uses Pymeasure to connect to a Keithley 2400 Power Supplies,13000.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument, RangeException
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

from .buffer import KeithleyBuffer


log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2400(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2400 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2400(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2400.apply_current` and :meth:`~.Keithley2400.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.control(
        ""OUTPut?"", ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False. The convenience methods :meth:`~.Keithley2400.enable_source` and
        :meth:`~.Keithley2400.disable_source` can also be used."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    auto_output_off = Instrument.control(
        "":SOUR:CLE:AUTO?"", "":SOUR:CLE:AUTO %d"",
        """""" A boolean property that enables or disables the auto output-off.
        Valid values are True (output off after measurement) and False (output
        stays on after measurement). """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    source_delay = Instrument.control(
        "":SOUR:DEL?"", "":SOUR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_delay_auto = Instrument.control(
        "":SOUR:DEL:AUTO?"", "":SOUR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    auto_zero = Instrument.control(
        "":SYST:AZER:STAT?"", "":SYST:AZER:STAT %s"",
        """""" A property that controls the auto zero option. Valid values are
        True (enabled) and False (disabled) and 'ONCE' (force immediate). """""",
        values={True: 1, False: 0, ""ONCE"": ""ONCE""},
        map_values=True,
    )

    line_frequency = Instrument.control(
        "":SYST:LFR?"", "":SYST:LFR %d"",
        """""" An integer property that controls the line frequency in Hertz.
        Valid values are 50 and 60. """""",
        validator=strict_discrete_set,
        values=[50, 60],
        cast=int,
    )

    line_frequency_auto = Instrument.control(
        "":SYST:LFR:AUTO?"", "":SYST:LFR:AUTO %d"",
        """""" A boolean property that enables or disables auto line frequency.
        Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    measure_concurent_functions = Instrument.control(
        "":SENS:FUNC:CONC?"", "":SENS:FUNC:CONC %d"",
        """""" A boolean property that enables or disables the ability to measure
        more than one function simultaneously. When disabled, volts function
        is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    compliance_current = Instrument.control(
        "":SENS:CURR:PROT?"", "":SENS:CURR:PROT %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )
    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    compliance_voltage = Instrument.control(
        "":SENS:VOLT:PROT?"", "":SENS:VOLT:PROT %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )
    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )
    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    wires = Instrument.control(
        "":SYSTEM:RSENSE?"", "":SYSTEM:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 2500],
        cast=int
    )
    means = Instrument.measurement(
        "":CALC3:FORM MEAN;:CALC3:DATA?;"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )
    maximums = Instrument.measurement(
        "":CALC3:FORM MAX;:CALC3:DATA?;"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )
    minimums = Instrument.measurement(
        "":CALC3:FORM MIN;:CALC3:DATA?;"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )
    standard_devs = Instrument.measurement(
        "":CALC3:FORM SDEV;:CALC3:DATA?;"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Trigger #
    ###########

    trigger_count = Instrument.control(
        "":TRIG:COUN?"", "":TRIG:COUN %d"",
        """""" An integer property that controls the trigger count,
        which can take values from 1 to 9,999. """""",
        validator=truncated_range,
        values=[1, 2500],
        cast=int
    )
    trigger_delay = Instrument.control(
        "":TRIG:SEQ:DEL?"", "":TRIG:SEQ:DEL %g"",
        """""" A floating point property that controls the trigger delay
        in seconds, which can take values from 0 to 999.9999 s. """""",
        validator=truncated_range,
        values=[0, 999.9999]
    )

    ###########
    # Filters #
    ###########

    filter_type = Instrument.control(
        "":SENS:AVER:TCON?"", "":SENS:AVER:TCON %s"",
        """""" A String property that controls the filter's type.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    filter_count = Instrument.control(
        "":SENS:AVER:COUNT?"", "":SENS:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    filter_state = Instrument.control(
        "":SENS:AVER?"", "":SENS:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    #####################
    # Output subsystem #
    #####################

    output_off_state = Instrument.control(
        "":OUTP:SMOD?"", "":OUTP:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2400 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."" % self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:MODE MAN;""
                   "":SENS:RES:NPLC %f;:FORM:ELEM RES;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."" % self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;:FORM:ELEM VOLT;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."" % self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;:FORM:ELEM CURR;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2400.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2400.current_range` value or None
        """"""
        log.info(""%s is sourcing current."" % self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2400.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2400.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."" % self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """""" A boolean property that controls whether or not the display of the
        sourcemeter is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2400 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2400 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":ARM:SOUR IMM;:TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":ARM:COUN 1;:ARM:SOUR BUS;:TRIG:SOUR BUS;"")

    def set_trigger_counts(self, arm, trigger):
        """""" Sets the number of counts for both the sweeps (arm) and the
        points in those sweeps (trigger), where the total number of
        points can not exceed 2500
        """"""
        if arm * trigger > 2500 or arm * trigger < 0:
            raise RangeException(""Keithley 2400 has a combined maximum ""
                                 ""of 2500 counts"")
        if arm < trigger:
            self.write("":ARM:COUN %d;:TRIG:COUN %d"" % (arm, trigger))
        else:
            self.write("":TRIG:COUN %d;:ARM:COUN %d"" % (trigger, arm))

    def sample_continuously(self):
        """""" Causes the instrument to continuously read samples
        and turns off any buffer or output triggering
        """"""
        self.disable_buffer()
        self.disable_output_trigger()
        self.trigger_immediately()

    def set_timed_arm(self, interval):
        """""" Sets up the measurement to be taken with the internal
        trigger at a variable sampling rate defined by the interval
        in seconds between sampling points
        """"""
        if interval > 99999.99 or interval < 0.001:
            raise RangeException(""Keithley 2400 can only be time""
                                 "" triggered between 1 mS and 1 Ms"")
        self.write("":ARM:SOUR TIM;:ARM:TIM %.3f"" % interval)

    def trigger_on_external(self, line=1):
        """""" Configures the measurement trigger to be taken from a
        specific line of an external trigger

        :param line: A trigger line from 1 to 4
        """"""
        cmd = "":ARM:SOUR TLIN;:TRIG:SOUR TLIN;""
        cmd += "":ARM:ILIN %d;:TRIG:ILIN %d;"" % (line, line)
        self.write(cmd)

    def output_trigger_on_external(self, line=1, after='DEL'):
        """""" Configures the output trigger on the specified trigger link
        line number, with the option of supplying the part of the
        measurement after which the trigger should be generated
        (default to delay, which is right before the measurement)

        :param line: A trigger line from 1 to 4
        :param after: An event string that determines when to trigger
        """"""
        self.write("":TRIG:OUTP %s;:TRIG:OLIN %d;"" % (after, line))

    def disable_output_trigger(self):
        """""" Disables the output trigger for the Trigger layer
        """"""
        self.write("":TRIG:OUTP NONE"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def status(self):
        return self.ask(""status:queue?;"")

    def RvsI(self, startI, stopI, stepI, compliance, delay=10.0e-3, backward=False):
        num = int(float(stopI - startI) / float(stepI)) + 1
        currRange = 1.2 * max(abs(stopI), abs(startI))
        # self.write("":SOUR:CURR 0.0"")
        self.write("":SENS:VOLT:PROT %g"" % compliance)
        self.write("":SOUR:DEL %g"" % delay)
        self.write("":SOUR:CURR:RANG %g"" % currRange)
        self.write("":SOUR:SWE:RANG FIX"")
        self.write("":SOUR:CURR:MODE SWE"")
        self.write("":SOUR:SWE:SPAC LIN"")
        self.write("":SOUR:CURR:STAR %g"" % startI)
        self.write("":SOUR:CURR:STOP %g"" % stopI)
        self.write("":SOUR:CURR:STEP %g"" % stepI)
        self.write("":TRIG:COUN %d"" % num)
        if backward:
            currents = np.linspace(stopI, startI, num)
            self.write("":SOUR:SWE:DIR DOWN"")
        else:
            currents = np.linspace(startI, stopI, num)
            self.write("":SOUR:SWE:DIR UP"")
        self.connection.timeout = 30.0
        self.enable_source()
        data = self.values("":READ?"")

        self.check_errors()
        return zip(currents, data)

    def RvsIaboutZero(self, minI, maxI, stepI, compliance, delay=10.0e-3):
        data = []
        data.extend(self.RvsI(minI, maxI, stepI, compliance=compliance, delay=delay))
        data.extend(self.RvsI(minI, maxI, stepI, compliance=compliance, delay=delay, backward=True))
        self.disable_source()
        data.extend(self.RvsI(-minI, -maxI, -stepI, compliance=compliance, delay=delay))
        data.extend(self.RvsI(-minI, -maxI, -stepI, compliance=compliance, delay=delay,
                              backward=True))
        self.disable_source()
        return data

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."" % self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
118,https://www.testequipmenthq.com/datasheets/ADVANTEST-R3767CG-Datasheet.pdf,https://www.keysight.com/blogs/tech/rfmw/2019/03/08/network-analyzer-basics-you-need-to-know,"[OrderedDict([('id', 'att1uDag9L17iJOra'), ('width', 260), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tdAk1G_wt6bo-TQWvLp-Uw/6Rgg4QqPjEgGUfq40Pe2Ahq5GG5uHSzAEsWzIw74HUe0NWh7Nj0AKO_MWL_2tONG4d-Mc9vXrTk-p7D2PTjrEPq9OU3Icj6-SLK5qQ7WfT98ny9lAnAKwFCw_M01gRWT/13TNKQGmiLhjA5b3lS4cwt9aiEG6NBCHw1TzoptMMWE'), ('filename', 'Advantest-R3766AH-23367.jpg'), ('size', 13704), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U9yAWXsOjqjH_LQ7fRCDRQ/VFCRCEM2ViRfdSsAb3iKov8itGRUVtFv_1Hgdil93lIkYbbRSA8EYOg9TkrJ1WnY_JzCNRbjabQURaHUpAhphw/Iy-CEPWi76E7_2KiFTvEnDZ_o-3SwXJIKD5La7mUj3Y'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/BFYLHBd-I9NSd9N7WHoGqw/qzCjYDbfhZ4qyMV8AYEn1DHw2uKgNXGyW9xnlk7lTTq6DAGTpNjjWd2CLDZsTfy9dDyB7qMK2g6waUjBrw8Xnw/4KTjC432yHRP_on9bpOU7lE7SNTA88SjOafbMPW2TCA'), ('width', 260), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ie4GBFl6OEsR6WK2iZg8AA/FIzg2BAg55nbxtum3WfbuOrPkd3UsuqHu0yftoGrO3jCQpg1h7JCD7ukFsKQzxzWF4h122LmNowW5TXzJv16Og/yg10xpMFGXzSLnkompS5ZHRFahBWTR838nXX8h0V58k'), ('width', 3000), ('height', 3000)]))]))])]",2940.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125967/Instruments/Vendor%20Logos/Advantest.png,The Advantest R3765CG/R3767CG network analyzers are vector network analyzers that incorporate a new RF circuit analysis technique.,https://www.testequipmenthq.com/datasheets/ADVANTEST-R3765CG-Datasheet.pdf,Advantestr 3767 CG,1.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Advantest manufactures and sells semiconductor and component test system products and mechatronics-related products.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/advantest/advantestR3767CG.py,Pymeasure,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Advantech.html#module-qcodes_contrib_drivers.drivers.Advantech.PCIE_1751,Advantest,"[OrderedDict([('id', 'attoXUfAlOUSTI5he'), ('width', 153), ('height', 19), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/oVzvRpcLvW4EW5oM32E7OA/05xppVtOC3FjUo8PtUAIxhrBPDw1A-k6s625oaGoR4XfaYFWuSiikMlCdZvGzAjuEheN98BRwh4Kv9fRng6GThxpogvTN-sc66TBLeSQZNk/xDyz0YcLgoZvI1nWobCfWMiYzx8mCrsK3vE0njccRl8'), ('filename', 'advantest-logo.gif'), ('size', 912), ('type', 'image/gif'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Br0NLcmF0rGnuEKO-JiGwQ/oRMxa5FUr1uvOY0EB9vZnoUmJcVoR7ztv4G6Ra4yB15riX4WFkzF_PVPsQ-78g9BeLUYe4eMm95BGeZGAkQy8w/e-1ZmuRQU5O8zCiNsIe2cx_EYnJIqU5d8abScUTFPNc'), ('width', 153), ('height', 19)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TkI05D2VxA5hLLtFZNpgtA/Y2xDYTrdoTWdcTNG2C9wibckb_FP9Z69Q99vhkxA5xVLIJQ2qX4vSG2_HX-jUKCBgP8tlv5-rE3CCC7JIktpfA/APrkYwq96OgUl7rc1b-PZ1ljY46nlYk1xMLT7UdxZ-o'), ('width', 153), ('height', 19)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/adIlXP6ZZOpXjGxNlr-emA/OgEaqxrLV-hoKJ3J2sgl030jy2UTiYZdfD1AC7rH0cbPDmupBi1WFC36OvUn0pw3DTp9bEUkNEdHoNNRaGgWjw/2qahuj_Bnsjggn0zVDHtFL7w9s3iJmHefaoqovmYYhc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.advantest.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782521/Instruments/Network%20Analyzer/Advantest-R3767CG/Advantest-R3767CG.jpg,Advantest R3767CG,Write a Python script that uses Pymeasure to connect to a Advantest R3767CG Network Analyzer,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range


class AdvantestR3767CG(Instrument):
    """""" Represents the Advantest R3767CG VNA. Implements controls to change the analysis
        range and to retreve the data for the trace.
    """"""

    id = Instrument.measurement(
        ""*IDN?"", """""" Reads the instrument identification """"""
    )

    center_frequency = Instrument.control(
        "":FREQ:CENT?"", "":FREQ:CENT %d"",
        """"""Center Frequency in Hz"""""",
        validator=strict_range,
        values=[300000, 8000000000]
    )

    span_frequency = Instrument.control(
        "":FREQ:SPAN?"", "":FREQ:SPAN %d"",
        """"""Span Frequency in Hz"""""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    start_frequency = Instrument.control(
        "":FREQ:STAR?"", "":FREQ:STAR %d"",
        """""" Starting frequency in Hz """""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    stop_frequency = Instrument.control(
        "":FREQ:STOP?"", "":FREQ:STOP %d"",
        """""" Stoping frequency in Hz """""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    trace_1 = Instrument.measurement(
        ""TRAC:DATA? FDAT1"", """""" Reads the Data array from trace 1 after formatting """"""
    )

    def __init__(self, adapter, name=""Advantest R3767CG"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

        # Tell unit to operate in IEEE488.2-1987 command mode.
        self.write(""OLDC OFF"")
"
120,https://www.testequipmenthq.com/datasheets/Rohde-Schwarz-SFM-Datasheet.pdf,https://en.wikipedia.org/wiki/Television_transmitter,"[OrderedDict([('id', 'attZfK0euyafNAfDM'), ('width', 275), ('height', 183), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s7FFgwsVc5RqpeBuK7nqfw/ccZoUj3kzdemTk7QbKPR-R1RKFMVqShbQ3DeqK4QfC2Y_Hagt1jUMwcESOx1c3e0fed0WUAmDa6pd-SUvWR4PH1smKiTs1_TMP7FE4chnUg/ruSjA11ANNZCYG32DlrEv4qDX0T_hN9jpRVk1yqO9zA'), ('filename', 'download (3).jpg'), ('size', 5928), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/S8hvqBUh0_AujU5d_KfxLA/9N3dkYDritP8sd1uU-YmWw1HTd_16X_d_cqqyuVywetc9-XtDALm6IzV8mqBCv2sXWoDjbdxKCSHG5h2gn5aeg/nGdrpLJ6ou1hNaPho2rr4e5Am6k17AezX7Cm-jJMyN4'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PlV96lU9Y-6nbao5MmN0kw/juBMkkS42JqPsrq7U_2wSR2SitLm8l9z3qfgJQ9pWt8SM4P1oYVwYOgb7u281NHUMowuBQiW2yAInUzL4MP5pQ/dtml7kYyfvZO3qqQGjc15QXDwa5OTai9yewuBWWXngA'), ('width', 275), ('height', 183)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/SbdIuiJzz6yzr2f2bmZzEw/QLP-yfrmZ2eA33AQmthMS18fbPKmUYCVKymLzpEVSIC6XDLfsbZ7QI2OxoG-_eogB4ePiQ_g0EEqGhK2t_Foyg/ekeNcmyCQERcOXVStqiHzWT8dTlBG-0v1iZtUPiqcVc'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692139604/Instruments/Vendor%20Logos/RohdeSchwarz.png,"Generation of standard TV signals (standards B&G, D&K, L&L, I, M, N, K1) including stereo/dual sound and NICAM
Double-sideband test modulator for all IFs between 32 and 46 MHz
RF upconverter, 5 to 1000 MHz, with high frequency resolution (1 Hz)",https://www.testwall.com/product/rohde-schwarz-sfm/,SFM,468.0,['RF Signal Generator'],"A television transmitter is a transmitter that is used for terrestrial (over-the-air) television broadcasting. It is an electronic device that radiates radio waves that carry a video signal representing moving images, along with a synchronized audio channel, which is received by television receivers ('televisions' or 'TVs') belonging to a public audience, which display the image on a screen. A television transmitter, together with the broadcast studio which originates the content, is called a television station. Television transmitters must be licensed by governments, and are restricted to a certain frequency channel and power level. They transmit on frequency channels in the VHF and UHF bands. Since radio waves of these frequencies travel by line of sight, they are limited by the horizon to reception distances of 40–60 miles depending on the height of transmitter station.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/sfm.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/sfm.html,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CpS01u_OTWzigpyIX294cA/EX_5PJyYktFu5Al55zSNyjcXLtJsFmmbuTlCPJIP440S20z80VXEZOU8y3TwjyfvjAr8kh0xDb-A3ZuBQd2qNDvw8gY7f0gUO5tuGNvudjQ/VX48XpjO9xisV9e4b9OqW21lZJ4bIlUErS1hzs8d_CE'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MyefG5SLCFh4IVEyVyhAUA/w_qFkuwLUw26XSJsiflkFgNM4soFUFffkWc0MpKgId0Ana-PViShd1ra1Uw7P9esiM7qPsjWn1oUBP8woOUC5w/ZIPgySMN9PXcVEezUO0mvcUtvLfX6IV8ce8CautxXH4'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pxbHby4ijBkZ-MCbLaMYdg/daQthpa_MxbepZl99pXfKmWFoDVTQK3jm2CQ9Xo4rg3yCJDoSROaJzceaP2pmWlC0nRtV0t0v-TqL2XBA1u44g/0--RegDQKIvXD1tEHXkOcQX5OFePHgzhz00XmVw9fNs'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vqjISP7Yaeb9FU33xwX-8Q/yhoGrCY_Tmtyu3_wVlw59C6mVxdARdPYKdFsole1IGdCIf6FwQzHjiHT5PMCqRqnKZMm42wR_rjv_-OnaBdO6w/RO9AJA_e6QpEEeiVOUEpQSAWLkvDws_NZeyv2PiqkVY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782523/Instruments/RF%20Signal%20Generator/SFM/SFM.jpg,SFM,Write a Python script that uses Pymeasure to connect to a SFM RF Signal Generator,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Sound_Channel:
    """"""
    Class object for the two sound channels

    refere also to chapter 3.6.6.7 of the user manual
    """"""
    modulation_degree = Instrument.control(
        ""AUD:DEGR?"",
        ""AUD:DEGR %g"",
        """""" A float property that controls the modulation depth for the audio signal
        (Note: only for the use of AM in Standard L)

        valid range: 0 .. 1 (100%)
        """""",
        validator=strict_range,
        values=[0, 1],
    )

    deviation = Instrument.control(
        ""AUD:DEV?"",
        ""AUD:DEV %d"",
        """""" A int property that controls deviation of the selected audio signal

        valid range: 0 .. 110 kHz
        """""",
        validator=strict_range,
        values=[0, 1.1E5],
    )

    frequency = Instrument.control(
        ""AUD:FREQ?"",
        ""AUD:FREQ %d"",
        """""" A int property that controls the frequency of the internal sound generator

        valid range: 300 Hz .. 15 kHz
        """""",
        validator=strict_range,
        values=[300, 1.5E4],
    )

    use_external_source = Instrument.control(
        ""FREQ:SOUR?"",
        ""FREQ:SOUR %s"",
        """""" A bool property for the audio source selection

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal audio generator(s)
        True    External signal source
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    modulation_enabled = Instrument.control(
        ""AUD:FREQ:STAT?"",
        ""AUD:FREQ:STAT %s"",
        """""" A bool property that controls the audio modulation status

        ======  =======
        Value   Meaning
        ======  =======
        False   modulation disabled
        True    modulation enabled
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    carrier_frequency = Instrument.control(
        ""CARR:FREQ?"",
        ""CARR:FREQ %g"",
        """""" A float property that controls the frequency of the sound carrier

        valid range: 32 .. 46 MHz

        """""",
        validator=strict_range,
        values=[38.75E6, 52.75E6],
    )

    carrier_level = Instrument.control(
        ""CARR:LEV?"",
        ""CARR:LEV %g"",
        """""" A float property that controls the level of the audio carrier in dB
        relative to the vision carrier (0dB)

        valid range: -34 .. -6 dB
        """""",
        validator=strict_range,
        values=[-34, 6],
    )

    carrier_enabled = Instrument.control(
        ""CARR:STAT?"",
        ""CARR:STAT %s"",
        """""" A bool property that controls if the audio carrier is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    preemphasis_time = Instrument.control(
        ""PRE:MODE?"",
        ""PRE:MODE %s"",
        """""" A int property that controls if the mode of the preemphasis for the audio signal

        ======  =======
        Value   Meaning
        ======  =======
        50      50 us preemphasis
        75      75 us preemphasis
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={50: ""US50"", 75: ""US75""},
        map_values=True,
    )

    preemphasis_enabled = Instrument.control(
        ""PRE:STAT?"",
        ""PRE:STAT %s"",
        """""" A bool property that controls if the preemphasis for the audio is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any keyword arguments.
        """"""
        return self.instrument.values(""SOUR:TEL:MOD:SOUN%d:%s"" % (
                                      self.number, command), **kwargs)

    def ask(self, command):
        self.instrument.ask(""SOUR:TEL:MOD:SOUN:%d:%s"" % (self.number, command))

    def write(self, command):
        self.instrument.write(""SOUR:TEL:MOD:SOUN:%d:%s"" % (self.number, command))

    def read(self):
        self.instrument.read()


class SFM(Instrument):
    """""" Represents the Rohde&Schwarz SFM TV test transmitter
    interface for interacting with the instrument.

    .. Note::
        The current implementation only works with the first system in this unit.

        Further source extension for system 2-6 would be required.

        The intermodulation subsystem is also not yet implmented.

    """"""

    def __init__(self, adapter, name=""Rohde&Schwarz SFM"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=True,
            **kwargs
        )
        self.sound1 = Sound_Channel(self, 1)
        self.sound2 = Sound_Channel(self, 2)

    def calibration(self, number=1, subsystem=None):
        """"""
        Function to either calibrate the whole modulator, when subsystem parameter is omitted,
        or calibrate a subsystem of the modulator.

        Valid subsystem selections: ""NICam, VISion, SOUNd1, SOUNd2, CODer""

        """"""
        if subsystem is None:
            self.write(""CAL:MOD%d"" % (number))
        else:
            self.write(
                ""CAL:MOD%d:%s"" % (
                    number,
                    strict_discrete_set(subsystem,
                                        [""NIC"", ""NICAM"", ""VIS"", ""VISION"", ""SOUN1"",
                                         ""SOUND1"", ""SOUN2"", ""SOUND2"", ""COD"", ""CODER""])
                )
            )

    # INST (Manual 3.6.4)
    system_number = Instrument.control(
        ""INST:SEL?"",
        ""INST:SEL:%s"",
        """"""A int property for the selected systems (if more than 1 available)

        * Minimum 1
        * Maximum 6

        """""",
        validator=strict_discrete_set,
        values={1: ""SYS1"", 2: ""SYS2"", 3: ""SYS3"", 4: ""SYS4"", 5: ""SYS5"", 6: ""SYS6""},
        map_values=True,
        check_set_errors=True,
    )

    R75_out = Instrument.control(
        ""ROUT:CHAN:OUTP:IMP?"",
        ""ROUT:CHAN:OUTP:IMP %s"",
        """""" A bool property that controls the use of the 75R output (if installed)

        ======  =======
        Value   Meaning
        ======  =======
        False   50R output active (N)
        True    75R output active (BNC)
        ======  =======

        refer also to chapter 3.6.5 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""LOW"", True: ""HIGH""},
        map_values=True,
    )

    ext_ref_base_unit = Instrument.control(
        ""ROUT:REF:CLOCK:BAS?"",
        ""ROUT:REF:CLOCK:BAS %s"",
        """""" A bool property for the external reference for the basic unit

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal 10 MHz is used
        True    External 10 MHz is used
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    ext_ref_extension = Instrument.control(
        ""ROUT:REF:CLOCK:EXT?"",
        ""ROUT:REF:CLOCK:EXT %s"",
        """""" A bool property for the external reference for the extension frame

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal 10 MHz is used
        True    External 10 MHz is used
        ======  =======
        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    ext_vid_connector = Instrument.control(
        ""ROUT:TEL:VID:EXT?"",
        ""ROUT:TEL:VID:EXT %s"",
        """"""A string property controlling which connector is used as the input of the video source

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        HIGH    Front connector - Hi-Z
        LOW     Front connector - 75R
        REAR1   Rear connector 1
        REAR2   Rear connector 2
        AUTO    Automatic assignment
        ======  =======
        """""",
        validator=strict_discrete_set,
        values=[""HIGH"", ""LOW"", ""REAR1"", ""REAR2"", ""AUTO""],
    )

    channel_table = Instrument.control(
        ""SOUR:FREQ:CHAN:TABL ?"",
        ""SOUR:FREQ:CHAN:TABL %s"",
        """"""A string property controlling which channel table is used

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        DEF     Default channel table
        USR1    User table No. 1
        USR2    User table No. 2
        USR3    User table No. 3
        USR4    User table No. 4
        USR5    User table No. 5
        ======  =======

        refer also to chapter 3.6.6.1 of the manual
        """""",
        validator=strict_discrete_set,
        values=[""DEF"", ""USR1"", ""USR2"", ""USR3"", ""USR4"", ""USR5""],
    )

    normal_channel = Instrument.control(
        ""SOUR:FREQ:CHAN:NORM ?"",
        ""SOUR:FREQ:CHAN:NORM %d"",
        """"""A int property controlling the current selected regular/normal channel number
        valid selections are based on the country settings.
        """""",
    )

    special_channel = Instrument.control(
        ""SOUR:FREQ:CHAN:SPEC ?"",
        ""SOUR:FREQ:CHAN:SPEC %d"",
        """"""A int property controlling the current selected special channel number
        valid selections are based on the country settings.
        """""",
    )

    def channel_up_relative(self):
        """"""
        Increases the output frequency to the next higher channel/special channel
        based on the current country settings
        """"""
        Instrument.write(self, ""SOUR:CHAN:REL UP"")

    def channel_down_relative(self):
        """"""
        Decreases the output frequency to the next low channel/special channel
        based on the current country settings
        """"""
        Instrument.write(self, ""SOUR:CHAN:REL DOWN"")

    channel_sweep_start = Instrument.control(
        ""SOUR:FREQ:CHAN:STAR?"",
        ""SOUR:FREQ:CHAN:STAR %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    channel_sweep_stop = Instrument.control(
        ""SOUR:FREQ:CHAN:STOP?"",
        ""SOUR:FREQ:CHAN:STOP %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    channel_sweep_step = Instrument.control(
        ""SOUR:FREQ:CHAN:STEP?"",
        ""SOUR:FREQ:CHAN:STEP %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    cw_frequency = Instrument.control(
        ""SOUR:FREQ:CW?"",
        ""SOUR:FREQ:CW %g"",
        """"""A float property controlling the CW-frequency in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    frequency = Instrument.control(
        ""SOUR:FREQ:FIXED?"",
        ""SOUR:FREQ:FIXED %g"",
        """"""A float property controlling the frequency in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    frequency_mode = Instrument.control(
        ""SOUR:FREQ:MODE?"",
        ""SOUR:FREQ:MODE %s"",
        """"""A string property controlling which the unit is used in

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        CW      Continous wave mode
        FIXED   fixed frequency mode
        CHSW    Channel sweep
        RFSW    Frequency sweep
        ======  =======

        .. Note::
            selecting the sweep mode, will start the sweep imemdiately!

        """""",
        validator=strict_discrete_set,
        values=[""CW"", ""FIXED"", ""CHSW"", ""RFSW""],
    )

    high_frequency_resolution = Instrument.control(
        ""SOUR:FREQ:RES?"",
        ""SOUR:FREQ:RES %s"",
        """""" A property that controls the frequency resolution,

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        False   Low resolution (1000Hz)
        True    High resolution (1Hz)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""LOW"", True: ""HIGH""},
        map_values=True,
    )

    rf_sweep_center = Instrument.control(
        ""SOUR:FREQ:CENTER?"",
        ""SOUR:FREQ:CENTER %g"",
        """"""A float property controlling the center frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_start = Instrument.control(
        ""SOUR:FREQ:STAR?"",
        ""SOUR:FREQ:STAR %g"",
        """"""A float property controlling the start frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_stop = Instrument.control(
        ""SOUR:FREQ:STOP?"",
        ""SOUR:FREQ:STOP %g"",
        """"""A float property controlling the stop frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_step = Instrument.control(
        ""SOUR:FREQ:STEP?"",
        ""SOUR:FREQ:STEP %g"",
        """"""A float property controlling the stepwidth for sweep in Hz,

        * Minimum 1 kHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[1E3, 1E9]
    )

    rf_sweep_span = Instrument.control(
        ""SOUR:FREQ:SPAN?"",
        ""SOUR:FREQ:SPAN %g"",
        """"""A float property controlling the sweep span in Hz,

        * Minimum 1 kHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[1E3, 1E9]
    )

    level = Instrument.control(
        ""SOUR:POW:LEV?"",
        ""SOUR:POW:LEV %g DBM"",
        """"""A float property controlling the output level in dBm,

        * Minimum -99dBm
        * Maximum 10dBm (depending on output mode)

        refer also to chapter 3.6.6.2 of the manual
        """""",
        validator=strict_range,
        values=[-99, 10],
    )

    level_mode = Instrument.control(
        ""SOUR:POW:LEV:MODE?"",
        ""SOUR:POW:LEV:MODE %s"",
        """"""A string property controlling the output attenuator and linearity mode

        Possible selections are:

        ======  ====================  =================
        Value   Meaning               max. output level
        ======  ====================  =================
        NORM    Normal mode           +6 dBm
        LOWN    low noise mode        +10 dBm
        CONT    continous mode        +10 dBm
        LOWD    low distortion mode   +0 dBm
        ======  ====================  =================

        Contiuous mode allows up to 14 dB of level setting without use of the mechanical attenuator.
        """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""LOWN"", ""CONT"", ""LOWD""]
    )

    rf_out_enabled = Instrument.control(
        ""SOUR:POW:STAT?"",
        ""SOUR:POW:STATE %s"",
        """""" A bool property that controls the status of the RF-output

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    def coder_adjust(self):
        """"""
        Starts the automatic setting of the differential deviation

        refer also to chapter 3.6.6.4 of the manual

        """"""
        self.write(""SOUR:TEL:MOD:COD:ADJ"")

    coder_id_frequency = Instrument.control(
        ""SOUR:TEL:MOD:COD:IDENT:FREQ?"",
        ""SOUR:TEL:MOD:COD:IDENT:FREQ %d"",
        """""" A int property that controls the frequency of the identification of the coder

        valid range 0 .. 200 Hz
        """""",
        validator=strict_range,
        values=[0, 200],
    )

    coder_modulation_degree = Instrument.control(
        ""SOUR:TEL:MOD:COD:MOD:DEGR?"",
        ""SOUR:TEL:MOD:COD:MOD:DEGR %g"",
        """""" A float property that controls the modulation degree of the identification of the coder

        valid range: 0 .. 0.9
        """""",
        validator=strict_range,
        values=[0, 0.9],
    )

    coder_pilot_frequency = Instrument.control(
        ""SOUR:TEL:MOD:COD:PIL:FREQ?"",
        ""SOUR:TEL:MOD:COD:PIL:FREQ %d"",
        """""" A int property that controls the pilot frequency of the coder

        valid range: 40 .. 60 kHz
        """""",
        validator=strict_range,
        values=[5E4, 6E4],
    )

    coder_pilot_deviation = Instrument.control(
        ""SOUR:TEL:MOD:COD:PIL:FREQ:DEV?"",
        ""SOUR:TEL:MOD:COD:PIL:FREQ:DEV %d"",
        """""" A int property that controls deviation of the pilot frequency of the coder

        valid range: 1 .. 4 kHz
        """""",
        validator=strict_range,
        values=[1E3, 4E3],
    )

    external_modulation_power = Instrument.control(
        ""SOUR:TEL:MOD:EXT:POW?"",
        ""SOUR:TEL:MOD:EXT:POW %d"",
        """""" A int property that controls the setting for the external modulator output power

        valid range: -7..0 dBm

        refer also to chapter 3.6.6.5 of the manual
        """""",
        validator=strict_range,
        values=[-7, 0],
    )

    external_modulation_frequency = Instrument.control(
        ""SOUR:TEL:MOD:EXT:FREQ?"",
        ""SOUR:TEL:MOD:EXT:FREQ %d"",
        """""" A int property that controls the setting for the external modulator frequency

        valid range: 32 .. 46 MHz
        """""",
        validator=strict_range,
        values=[32e6, 46e6],
    )

    nicam_mode = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:MODE?"",
        ""SOUR:TEL:MOD:NIC:AUD:MODE %s"",
        """""" A string property that controls the signal type to be sent via NICAM

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        MON     Mono sound + NICAM data
        STER    Stereo sound
        DUAL    Dual channel sound
        DATA    NICAM data only
        ======  =======

        refer also to chapter 3.6.6.6 of the manual

        """""",
        validator=strict_discrete_set,
        values=[""MON"", ""STER"", ""DUAL"", ""DATA""],
    )

    nicam_audio_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:FREQ?"",
        ""SOUR:TEL:MOD:NIC:AUD:FREQ %d"",
        """""" A int property that controls the frequency of the internal sound generator

        valid range: 0 Hz .. 15 kHz
        """""",
        validator=strict_range,
        values=[0, 1.5E4],
    )

    nicam_preemphasis_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:PRE?"",
        ""SOUR:TEL:MOD:NIC:AUD:PRE %d"",
        """""" A bool property that controls the status of the J17 preemphasis

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_audio_volume = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:VOL?"",
        ""SOUR:TEL:MOD:NIC:AUD:VOL %g"",
        """""" A float property that controls the audio volume in the NICAM  modulator in dB

        valid range: 0..60 dB

        """""",
        validator=strict_range,
        values=[0, 60],
    )

    nicam_data = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:DATA?"",
        ""SOUR:TEL:MOD:NIC:AUD:DATA %d"",
        """""" A int property that controls the data in the NICAM  modulator

        valid range: 0 .. 2047
        """""",
        validator=strict_range,
        values=[0, 2047],
        cast=int
    )

    nicam_additional_bits = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:ADD?"",
        ""SOUR:TEL:MOD:NIC:AUD:ADD %d"",
        """""" A int property that controls the additional data in the NICAM  modulator

        valid range: 0 .. 2047
        """""",
        validator=strict_range,
        values=[0, 2047],
    )

    nicam_control_bits = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:CONT?"",
        ""SOUR:TEL:MOD:NIC:AUD:CONT %d"",
        """""" A int property that controls the additional data in the NICAM  modulator

        valid range: 0 .. 3
        """""",
        validator=strict_range,
        values=[0, 3],
    )

    nicam_bit_error_rate = Instrument.control(
        ""SOUR:TEL:MOD:NIC:BIT?"",
        ""SOUR:TEL:MOD:NIC:BIT %g"",
        """""" A float property that controls the artifical bit error rate.

        valid range: 1.2E-7 .. 2E-3
        """""",
        validator=strict_range,
        values=[1.2E-7, 2E-3],
    )

    nicam_bit_error_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:BIT:STAT?"",
        ""SOUR:TEL:MOD:NIC:BIT:STAT %d"",
        """""" A bool property that controls the status of an artifical bit error rate to be applied

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_carrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:FREQ?"",
        ""SOUR:TEL:MOD:NIC:CARR:FREQ %g"",
        """""" A float property that controls the frequency of the NICAM carrier

        valid range: 33.05 MHz +/- 0.2 Mhz

        """""",
        validator=strict_range,
        values=[32.85E6, 33.25E6],
    )

    nicam_intercarrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:INT:FREQ?"",
        ""SOUR:TEL:MOD:NIC:INT:FREQ %g"",
        """""" A float property that controls the inter-carrier frequency of the NICAM carrier

        valid range: 5 .. 9 MHz
        """""",
        validator=strict_range,
        values=[5E6, 9E6],
    )

    nicam_carrier_level = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:LEV?"",
        ""SOUR:TEL:MOD:NIC:CARR:LEV %g"",
        """""" A float property that controls the value of the NICAM carrier

        valid range: -40 .. -13 dB
        """""",
        validator=strict_range,
        values=[-40, 13],
    )

    nicam_carrier_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:STAT?"",
        ""SOUR:TEL:MOD:NIC:CARR:STAT %s"",
        """""" A bool property that controls if the NICAM carrier is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_IQ_inverted = Instrument.control(
        ""SOUR:TEL:MOD:NIC:MODE?"",
        ""SOUR:TEL:MOD:NIC:MODE %s"",
        """""" A bool property that controls if the NICAM IQ signals are inverted or not

        ======  =======
        Value   Meaning
        ======  =======
        False   normal (IQ)
        True    inverted (QI)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""IQ"", True: ""QI""},
        map_values=True,
    )

    nicam_source = Instrument.control(
        ""SOUR:TEL:MOD:NIC:SOUR?"",
        ""SOUR:TEL:MOD:NIC:SOUR %s"",
        """""" A string property that controls the signal source for NICAM

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        INT     Internal audio generator(s)
        EXT     External audio source
        CW      Continous wave signal
        RAND    Random data stream
        TEST    Test signal
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""INT"", ""EXT"", ""CW"", ""RAND"", ""TEST""],
    )

    nicam_test_signal = Instrument.control(
        ""SOUR:TEL:MOD:NIC:TEST?"",
        ""SOUR:TEL:MOD:NIC:TEST %s"",
        """""" A int property that controls the selection of the test signal applied

        ======  =======
        Value   Meaning
        ======  =======
        1       Test signal 1 (91 kHz square wave, I&Q 90deg apart)
        2       Test signal 2 (45.5 kHz square wave, I&Q 90deg apart)
        3       Test signal 3 (182 kHz sine wave, I&Q in phase)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={1: ""TST1"", 2: ""TST2"", 3: ""TST3""},
        map_values=True,
    )

    external_modulation_source = Instrument.control(
        ""SOUR:MOD:SOUR?"",
        ""SOUR:MOD:SOUR %s"",
        """""" A bool property for the modulation source selection

        refer also to chapter 3.6.6.8 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    modulation_enabled = Instrument.control(
        ""SOUR:MOD:STAT?"",
        ""SOUR:MOD:STAT %s"",
        """""" A bool property that controls the modulation status
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_carrier_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CARR:STAT?"",
        ""SOUR:TEL:MOD:VIS:CARR:STAT %s"",
        """""" A bool property that controls the vision carrier status

        refer also to chapter 3.6.6.9 of the manual

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_carrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CARR:FREQ?"",
        ""SOUR:TEL:MOD:VIS:CARR:FREQ %g"",
        """""" A float property that controls the frequency of the vision carrier

        valid range: 32 .. 46 MHz
        """""",
        validator=strict_range,
        values=[32E6, 46E6],
    )

    vision_average_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:AVER:STAT?"",
        ""SOUR:TEL:MOD:VIS:AVER:STAT %s"",
        """""" A bool property that controls the average mode for the vision system
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_balance = Instrument.control(
        ""SOUR:TEL:MOD:VIS:BAL?"",
        ""SOUR:TEL:MOD:VIS:BAL %g"",
        """""" A float property that controls the balance of the vision modulator

        valid range: -0.5 .. 0.5
        """""",
        validator=strict_range,
        values=[-0.5, 0.5],
    )

    vision_clamping_average = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:AVER?"",
        ""SOUR:TEL:MOD:VIS:CLAM:AVER %g"",
        """""" A float property that controls the operation point of the vision modulator

        valid range: -0.5 .. 0.5
        """""",
        validator=strict_range,
        values=[-0.5, 0.5],
    )

    vision_clamping_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:STAT?"",
        ""SOUR:TEL:MOD:VIS:CLAM:STAT %s"",
        """""" A bool property that controls the clamping behavior of the vision modulator

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_clamping_mode = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:TYPE?"",
        ""SOUR:TEL:MOD:VIS:CLAM:TYPE %s"",
        """""" A string property that controls the clamping mode of the vision modulator

        Possible selections are HARD or SOFT
        """""",
        validator=strict_discrete_set,
        values=[""HARD"", ""SOFT""],
    )

    vision_precorrection_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:PREC?"",
        ""SOUR:TEL:MOD:VIS:PREC %s"",
        """""" A bool property that controls the precorrection behavior of the vision modulator
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_residual_carrier_level = Instrument.control(
        ""SOUR:TEL:MOD:VIS:RES?"",
        ""SOUR:TEL:MOD:VIS:RES %g"",
        """""" A float property that controls the value of the residual carrier

        valid range: 0 .. 0.3 (30%)
        """""",
        validator=strict_range,
        values=[0, 0.3],
    )

    vision_videosignal_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:VID?"",
        ""SOUR:TEL:MOD:VIS:VID %s"",
        """""" A bool property that controls if the video signal is switched on or off

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_sideband_filter_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:VSBF?"",
        ""SOUR:TEL:MOD:VIS:VSBF %s"",
        """""" A bool property that controls the use of the VSBF (vestigal sideband filter)
        in the vision modulator
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    lower_sideband_enabled = Instrument.control(
        ""SOUR:TEL:SID?"",
        ""SOUR:TEL:SID %s"",
        """""" A bool property that controls the use of the lower sideband

        refer also to chapter 3.6.6.10 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""UPP"", True: ""LOW""},
        map_values=True,
    )

    sound_mode = Instrument.control(
        ""SOUR:TEL:SOUN?"",
        ""SOUR:TEL:SOUN %s"",
        """""" A string property that controls the type of audio signal

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        MONO    MOnoaural sound
        PIL     pilot-carrier + mono
        BTSC    BTSC + mono
        STER    Stereo sound
        DUAL    Dual channel sound
        NIC     NICAM + Mono
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""MONO"", ""PIL"", ""BTSC"", ""STER"", ""DUAL"", ""NIC""],
    )

    TV_standard = Instrument.control(
        ""SOUR:TEL:STAN?"",
        ""SOUR:TEL:STAN %s"",
        """""" A string property that controls the type of video standard

        Possible values are:

        ======  ======  ======
        Value   Lines   System
        ======  ======  ======
        BG      625     PAL
        DK      625     SECAM
        I       625     PAL
        K1      625     SECAM
        L       625     SECAM
        M       525     NTSC
        N       625     NTSC
        ======  ======  ======

        Please confirm with the manual about the details for these settings.
        """""",
        validator=strict_discrete_set,
        values=[""BG"", ""DK"", ""I"", ""K1"", ""L"", ""M"", ""N""],
    )

    TV_country = Instrument.control(
        ""SOUR:TEL:STAN:COUN?"",
        ""SOUR:TEL:STAN:COUN %s"",
        """""" A string property that controls the country specifics of the
        video/sound system to be used

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        BG_G    BG General
        DK_G    DK General
        I_G     I General
        L_G     L General
        GERM    Germany
        BELG    Belgium
        NETH    Netherlands
        FIN     Finland
        AUST    Australia
        BG_T    BG Th
        DENM    Denmark
        NORW    Norway
        SWED    Sweden
        GUS     Russia
        POL1    Poland
        POL2    Poland
        HUNG    Hungary
        CHEC    Czech Republic
        CHINA1  China
        CHINA2  China
        GRE     Great Britain
        SAFR    South Africa
        FRAN    France
        USA     United States
        KOR     Korea
        JAP     Japan
        CAN     Canada
        SAM     South America
        ======  =======

        Please confirm with the manual about the details for these settings.
        """""",
        validator=strict_discrete_set,
        values=[""BG_G"", ""DK_G"", ""I_G"", ""L_G"", ""GERM"", ""BELG"", ""NETH"",
                ""FIN"", ""AUST"", ""BG_T"", ""DENM"", ""NORW"", ""SWED"", ""GUS"", ""POL1"", ""POL2"",
                ""HUNG"", ""CHEC"", ""CHINA1"", ""CHINA2"", ""GRE"", ""SAFR"", ""FRAN"", ""USA"",
                ""KOR"", ""JAP"", ""CAN"", ""SAM""],
    )

    output_voltage = Instrument.control(
        ""SOUR:VOLT:LEV?"",
        ""SOUR:VOLT:LEV %g"",
        """"""A float property controlling the output level in Volt,

        Minimum 2.50891e-6, Maximum 0.707068 (depending on output mode)
        refer also to chapter 3.6.6.12 of the manual
        """""",
        validator=strict_range,
        values=[2.508910e-6, 0.7070168],
    )

    event_reg = Instrument.measurement(
        ""STAT:OPER:EVEN?"",
        """"""
        Content of the event register of the Status Operation Register
        refer also to chapter 3.6.7 of the manual
        """""",
        cast=int,
    )

    status_reg = Instrument.measurement(
        ""STAT:OPER:COND?"",
        """"""
        Content of the condition register of the Status Operation Register
        """""",
        cast=int,
    )

    operation_enable_reg = Instrument.control(
        ""STAT:OPER:ENAB?"",
        ""STAT:OPER:ENAB %d"",
        """"""
        Content of the enable register of the Status Operation Register

        Valid range: 0...32767
        """""",
        cast=int,
        validator=strict_range,
        values=[0, 32767]
    )

    def status_preset(self):
        """""" partly resets the SCPI status reporting structures
        """"""
        self.write(""STAT:PRES"")

    questionable_event_reg = Instrument.measurement(
        ""STAT:QUES:EVEN?"",
        """"""
        Content of the event register of the Status Questionable Operation Register
        """""",
        cast=int,
    )

    questionanble_status_reg = Instrument.measurement(
        ""STAT:QUES:COND?"",
        """"""
        Content of the condition register of the Status Questionable Operation Register
        """""",
        cast=int,
    )

    questionable_operation_enable_reg = Instrument.control(
        ""STAT:QUES:ENAB?"",
        ""STAT:QUES:ENAB %d"",
        """"""
        Content of the enable register of the Status Questionable Operation Register

        Valid range 0...32767
        """""",
        cast=int,
        validator=strict_range,
        values=[0, 32767]
    )

    beeper_enabled = Instrument.control(
        ""SYST:BEEP:STATE?"",
        ""SYST:BEEP:STATE %s"",
        """""" A bool property that controls the beeper status,

        refer also to chapter 3.6.8 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    status_info_shown = Instrument.control(
        ""SYST:DISP:UPDATE:STATE?"",
        ""SYST:DISP:UPDATE:STATE %s"",
        """""" A bool property that controls if the display shows infomation during remote control

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    gpib_address = Instrument.control(
        ""SYST:COMM:GPIB:ADDR?"",
        ""SYST:COMM:GPIB:ADDR %d"",
        """""" A int property that controls the GPIB address of the unit

        valid range:  0..30
        """""",
        validator=strict_range,
        values=[0, 30],
    )

    remote_interfaces = Instrument.control(
        ""SYST:COM:REM?"",
        ""SYST:COM:REM %s"",
        """"""A string property controlling the selection of interfaces for remote control

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        OFF     no remote control
        GPIB    GPIB only enabled
        SER     RS232 only enabled
        BOTH    GPIB & RS232 enabled
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""OFF"", ""GPIB"", ""SER"", ""BOTH""]
    )

    serial_baud = Instrument.control(
        ""SYST:COMM:SER:BAUD?"",
        ""SYST:COMM:SER:BAUD %g"",
        """""" A int property that controls the serial communication speed ,

        Possible values are: 110,300,600,1200,4800,9600,19200
        """""",
        validator=strict_discrete_set,
        values=[110, 300, 600, 1200, 4800, 9600, 19200],
    )

    serial_bits = Instrument.control(
        ""SYST:COMM:SER:BITS?"",
        ""SYST:COMM:SER:BITS %g"",
        """""" A int property that controls the number of bits used in serial communication

        Possible values are: 7 or 8
        """""",
        validator=strict_discrete_set,
        values=[7, 8],
    )

    serial_flowcontrol = Instrument.control(
        ""SYST:COMM:SER:PACE?"",
        ""SYST:COMM:SER:PACE %s"",
        """""" A string property that controls the serial handshake type used in serial communication

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        NONE    no flow-control/handshake
        XON     XON/XOFF flow-control
        ACK     hardware handshake with RTS&CTS
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""NONE"", ""XON"", ""ACK""],
    )

    serial_parity = Instrument.control(
        ""SYST:COMM:SER:PAR?"",
        ""SYST:COMM:SER:PAR %s"",
        """""" A string property that controls the parity type used for serial communication

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        NONE    no parity
        EVEN    even parity
        ODD     odd parity
        ONE     parity bit fixed to 1
        ZERO    parity bit fixed to 0
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""NONE"", ""EVEN"", ""ODD"", ""ONE"", ""ZERO""],
    )

    serial_stopbits = Instrument.control(
        ""SYST:COMM:SER:SBIT?"",
        ""SYST:COMM:SER:SBIT %g"",
        """""" A int property that controls the number of stop-bits used in serial communication,

        Possible values are: 1 or 2
        """""",
        validator=strict_discrete_set,
        values=[1, 2],
    )

    date = Instrument.measurement(
        ""SYST:DATE?"",
        """"""
        A list property for the date of the RTC in the unit
        """""",
    )

    time = Instrument.measurement(
        ""SYST:TIME?"",
        """"""
        A list property for the time of the RTC in the unit
        """""",
    )

    basic_info = Instrument.measurement(
        ""SYST:INF:BAS?"",
        """"""
        A String property containing infomation about the hardware modules installed in the unit
        """""",
    )

    subsystem_info = Instrument.measurement(
        ""SYST:INF:SUBS?"",
        """"""
        A String property containing infomation about the system configuration
        """""",
    )

    scale_volt = Instrument.control(
        ""UNIT:VOLT?"",
        ""UNIT:VOLT %s"",
        """""" A string property that controls the unit to be used for voltage entries on the unit

        Possible values are:
        AV,FV, PV, NV, UV, MV, V, KV, MAV, GV, TV, PEV, EV,
        DBAV, DBFV, DBPV, DBNV, DBUV, DBMV, DBV, DBKV, DBMAv, DBGV, DBTV, DBPEv, DBEV

        refer also to chapter 3.6.9 of the manual
        """""",
        validator=strict_discrete_set,
        values=[""AV"", ""FV"", ""PV"", ""NV"", ""UV"", ""MV"", ""V"", ""KV"", ""MAV"", ""GV"",
                ""TV"", ""PEV"", ""EV"", ""DBAV"", ""DBFV"", ""DBPV"", ""DBNV"", ""DBUV"",
                ""DBMV"", ""DBV"", ""DBKV"", ""DBMAv"", ""DBGV"", ""DBTV"", ""DBPEv"", ""DBEV""],
    )
"
124,https://www.keysight.com/us/en/assets/9018-05398/user-manuals/9018-05398.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attFQwLe4SfLaRgSf'), ('width', 1204), ('height', 656), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mGQ6yzw3AlyxxdWXg84eGw/rsRv832IL_wPI3owNHtiF1aFXANpEPot3aVZFWITUpOEhQpJ50RT5TmHTpOodCv0hdDurzehRrmAQqBhOPFfaKFNjlfu4O89LknUtqTmaG0/JDDAb5erZ5PJGt44chFu7fPtHa5GkdXnG34ArpM3khs'), ('filename', 'img3050.jpg'), ('size', 114606), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AULirdKoUFNfpFkTgi8H1A/vCBVwjTSP_DXw_wl7mOVdzipLX0BeoACXHRwuT67op_O_KFlOSy5HVVloqxLN91XWmTSfkEFfLnyEh_8D1RrFg/7CFCsLZKk9HVRuinUZ-MxwVhQekLWDKDtuwveXJh2yk'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8LWjWsB52_urCw68DRB0iA/lovCe6TBLOeLGCC34AKxl5QOnMpUnvV-0ZahMZ6hUwGQ55iRFwuGW3VcHT_tQ_QI1CaW7K_K_hBM1UGxpJuqxg/n_TY7V09344gt_0KVQ4Zt6tzZgwq-lMosVkJZ0KBH1o'), ('width', 940), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/n-QGECrZwAjNtnMtgyk7ZQ/hpkoBG8-_wumbM4d63jOO3zd6KwXGr-uYu9qzRIzm6O2_z2bPT5oMclewoHs9tlDbY9PnfreCxFmLkyYggvRUQ/_hlduF91ZTzRVYgNMqcO8pzB9V6K03GiEs_yYDG3yGg'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,"The HP 3478A 5.5 digit DMM with HP-IB interface
",https://www.keysight.com/us/en/product/3478A/55-digit-dmm-with-hpib-interface.html,HP 3478 A,186.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp3478A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp3478A.html,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782526/Instruments/Multimeters/Keysight-3478A/Keysight-3478A.jpg,Keysight 3478A,Write a Python script that uses Pymeasure to connect to a Keysight 3478A Multimeters,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import ctypes
import logging
import math
from enum import IntFlag
from pymeasure.instruments.hp.hplegacyinstrument import HPLegacyInstrument, StatusBitsBase
from pymeasure.instruments.validators import strict_discrete_set, strict_range


log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

c_uint8 = ctypes.c_uint8


class SRQ(ctypes.BigEndianStructure):
    """"""Support class for the SRQ handling
    """"""
    _fields_ = [
        (""power_on"", c_uint8, 1),
        (""not_assigned_1"", c_uint8, 1),
        (""calibration"", c_uint8, 1),
        (""front_panel_button"", c_uint8, 1),
        (""internal_error"", c_uint8, 1),
        (""syntax_error"", c_uint8, 1),
        (""not_assigned_2"", c_uint8, 1),
        (""data_ready"", c_uint8, 1),
    ]

    def __str__(self):
        """"""
        Returns a pretty formatted string showing the status of the instrument

        """"""
        ret_str = """"
        for field in self._fields_:
            ret_str = ret_str + f""{field[0]}: {hex(getattr(self, field[0]))}\n""

        return ret_str


class Status(StatusBitsBase):
    """"""
    Support-Class with the bit assignments for the 5 status byte of the HP3478A
    """"""

    _fields_ = [
        # Byte 1: Function, Range and Number of Digits
        (""function"", c_uint8, 3),  # bit 5..7
        (""range"", c_uint8, 3),  # bit 2..4
        (""digits"", c_uint8, 2),  # bit 0..1
        # Byte 2: Status Bits
        (""res1"", c_uint8, 1),
        (""ext_trig"", c_uint8, 1),
        (""cal_enable"", c_uint8, 1),
        (""front_rear"", c_uint8, 1),
        (""fifty_hz"", c_uint8, 1),
        (""auto_zero"", c_uint8, 1),
        (""auto_range"", c_uint8, 1),
        (""int_trig"", c_uint8, 1),
        # Byte 3: Serial Poll Mask (SRQ)
        # (""SRQ_PON"", c_uint8, 1),
        # (""res3"", c_uint8, 1),
        # (""SRQ_cal_error"", c_uint8, 1),
        # (""SRQ_front_panel"", c_uint8, 1),
        # (""SRQ_internal_error"", c_uint8, 1),
        # (""SRQ_syntax_error"", c_uint8, 1),
        # (""res2"", c_uint8, 1),
        # (""SRQ_data_rdy"", c_uint8, 1),
        (""SRQ"", SRQ),
        # Byte 4: Error Information
        # (""res5"", c_uint8, 1),
        # (""res4"", c_uint8, 1),
        # (""ERR_AD_Link"", c_uint8, 1),
        # (""ERR_AD"", c_uint8, 1),
        # (""ERR_slope"", c_uint8, 1),
        # (""ERR_ROM"", c_uint8, 1),
        # (""ERR_RAM"", c_uint8, 1),
        # (""ERR_cal"", c_uint8, 1),
        (""Error_Status"", c_uint8, 8),
        # Byte 5: DAC Value
        (""DAC_value"", c_uint8, 8),
    ]


class HP3478A(HPLegacyInstrument):
    """""" Represents the Hewlett Packard 3478A 5 1/2 digit multimeter
    and provides a high-level interface for interacting
    with the instrument.
    """"""
    status_desc = Status

    def __init__(self, adapter, name=""Hewlett-Packard HP3478A"", **kwargs):
        kwargs.setdefault('read_termination', '\r\n')
        kwargs.setdefault('send_end', True)
        super().__init__(
            adapter,
            name,
            **kwargs,
        )

    # Definitions for different specifics of this instrument
    MODES = {""DCV"": ""F1"",
             ""ACV"": ""F2"",
             ""R2W"": ""F3"",
             ""R4W"": ""F4"",
             ""DCI"": ""F5"",
             ""ACI"": ""F6"",
             ""Rext"": ""F7"",
             }

    INV_MODES = {v: k for k, v in MODES.items()}

    RANGES = {""DCV"": {3E-2: ""R-2"", 3E-1: ""R-1"", 3: ""R0"", 30: ""R1"", 300: ""R2"",
                      ""auto"": ""RA""},
              ""ACV"": {3E-1: ""R-1"", 3: ""R0"", 30: ""R1"", 300: ""R2"", ""auto"": ""RA""},
              ""R2W"": {30: ""R1"", 300: ""R2"", 3E3: ""R3"", 3E4: ""R4"", 3E5: ""R5"",
                      3E6: ""R6"", 3E7: ""R7"", ""auto"": ""RA""},
              ""R4W"": {30: ""R1"", 300: ""R2"", 3E3: ""R3"", 3E4: ""R4"", 3E5: ""R5"",
                      3E6: ""R6"", 3E7: ""R7"", ""auto"": ""RA""},
              ""DCI"": {3E-1: ""R-1"", 3: ""R0"", ""auto"": ""RA""},
              ""ACI"": {3E-1: ""R-1"", 3: ""R0"", ""auto"": ""RA""},
              ""Rext"": {3E7: ""R7"", ""auto"": ""RA""},
              }

    TRIGGERS = {
        ""auto"": ""T1"",
        ""internal"": ""T1"",
        ""external"": ""T2"",
        ""single"": ""T3"",
        ""hold"": ""T4"",
        ""fast"": ""T5"",
    }

    class ERRORS(IntFlag):
        """"""Enum element for errror bit decoding
        """"""
        AD_LINK = 32  # AD link error
        AD_SELFCHK = 16  # AD self check error
        AD_SLOPE = 8  # AD slope error
        ROM = 4  # Control ROM error
        RAM = 2  # RAM selftest failed
        CALIBRATION = 1  # Calibration checksum error or cal range issue
        NO_ERR = 0  # Should be obvious

    # commands/properties for instrument control
    @property
    def active_connectors(self):
        """"""Return selected connectors (""front""/""back""), based on front-panel selector switch
        """"""
        selection = self.status.front_rear
        if selection == 1:
            return ""front""
        else:
            return ""back""

    @property
    def auto_range_enabled(self):
        """""" Property describing the auto-ranging status

        ======  ============================================
        Value   Status
        ======  ============================================
        True    auto-range function activated
        False   manual range selection / auto-range disabled
        ======  ============================================

        The range can be set with the :py:attr:`range` property
        """"""
        selection = self.status.auto_range
        return bool(selection)

    @property
    def auto_zero_enabled(self):
        """""" Return auto-zero status, this property can be set

        ======  ==================
        Value   Status
        ======  ==================
        True    auto-zero active
        False   auto-zero disabled
        ======  ==================

        """"""
        selection = self.status.auto_zero
        return bool(selection)

    @auto_zero_enabled.setter
    def auto_zero_enabled(self, value):
        az_set = int(value)
        az_str = ""Z"" + str(int(strict_discrete_set(az_set, [0, 1])))
        self.write(az_str)

    @property
    def calibration_enabled(self):
        """"""Return calibration enable switch setting,
        based on front-panel selector switch

        ======  ===================
        Value   Status
        ======  ===================
        True    calbration possible
        False   calibration locked
        ======  ===================

        """"""
        selection = self.status.cal_enable
        return bool(selection)

    def check_errors(self):
        """"""
        Method to read the error status register

        :return error_status: one byte with the error status register content
        :rtype error_status: int
        """"""
        # Read the error status register only one time for this method, as
        # the manual states that reading the error status register also clears it.
        current_errors = self.error_status
        if current_errors != 0:
            log.error(""HP3478A error detected: %s"", self.ERRORS(current_errors))
        return self.ERRORS(current_errors)

    error_status = HPLegacyInstrument.measurement(
        ""E"",
        """"""Checks the error status register

        """""",
        cast=int,
    )

    def display_reset(self):
        """""" Reset the display of the instrument.

        """"""
        self.write(""D1"")

    display_text = HPLegacyInstrument.setting(
        ""D2%s"",
        """"""Displays up to 12 upper-case ASCII characters on the display.

        """""",
        set_process=(lambda x: str.upper(x[0:12])),
    )

    display_text_no_symbol = HPLegacyInstrument.setting(
        ""D3%s"",
        """"""Displays up to 12 upper-case ASCII characters on the display and
        disables all symbols on the display.

        """""",
        set_process=(lambda x: str.upper(x[0:12])),
    )

    measure_ACI = HPLegacyInstrument.measurement(
        MODES[""ACI""],
        """"""
        Returns the measured value for AC current as a float in A.

        """""",
    )

    measure_ACV = HPLegacyInstrument.measurement(
        MODES[""ACV""],
        """"""
        Returns the measured value for AC Voltage as a float in V.

        """""",
    )

    measure_DCI = HPLegacyInstrument.measurement(
        MODES[""DCI""],
        """"""
        Returns the measured value for DC current as a float in A.

        """""",
    )

    measure_DCV = HPLegacyInstrument.measurement(
        MODES[""DCV""],
        """"""
        Returns the measured value for DC Voltage as a float in V.

        """""",
    )

    measure_R2W = HPLegacyInstrument.measurement(
        MODES[""R2W""],
        """"""
        Returns the measured value for 2-wire resistance as a float in Ohm.

        """""",
    )

    measure_R4W = HPLegacyInstrument.measurement(
        MODES[""R4W""],
        """"""
        Returns the measured value for 4-wire resistance as a float in Ohm.

        """""",
    )

    measure_Rext = HPLegacyInstrument.measurement(
        MODES[""Rext""],
        """"""
        Returns the measured value for extended resistance mode (>30M, 2-wire)
        resistance as a float in Ohm.
        """""",
    )

    @property
    def mode(self):
        """"""Return current selected measurement mode, this propery can be set.
        Allowed values are

        ====  ==============================================================
        Mode  Function
        ====  ==============================================================
        ACI   AC current
        ACV   AC voltage
        DCI   DC current
        DCV   DC voltage
        R2W   2-wire resistance
        R4W   4-wire resistance
        Rext  extended resistance method (requires additional 10 M resistor)
        ====  ==============================================================
        """"""
        current_mode = self.INV_MODES[""F"" + str(self.status.function)]
        return current_mode

    @mode.setter
    def mode(self, value):
        mode_set = self.MODES[strict_discrete_set(value, self.MODES)]
        self.write(mode_set)

    @property
    def range(self):
        """"""Returns the current measurement range, this property can be set.

        Valid values are :

        ====  =======================================
        Mode  Range
        ====  =======================================
        ACI   0.3, 3, auto
        ACV   0.3, 3, 30, 300, auto
        DCI   0.3, 3, auto
        DCV   0.03, 0.3, 3, 30, 300, auto
        R2W   30, 300, 3000, 3E4, 3E5, 3E6, 3E7, auto
        R4W   30, 300, 3000, 3E4, 3E5, 3E6, 3E7, auto
        Rext  3E7, auto
        ====  =======================================

        """"""
        cur_mode = self.INV_MODES[""F"" + str(self.status.function)]
        if cur_mode == ""DCV"":
            correction_factor = 3
        elif cur_mode in [""ACV"", ""ACI"", ""DCI""]:
            correction_factor = 2
        else:
            correction_factor = 0
        current_range = 3 * math.pow(10, self.status.range - correction_factor)
        return current_range

    @range.setter
    def range(self, value):
        cur_mode = self.mode
        value = strict_discrete_set(value, self.RANGES[cur_mode])
        set_range = self.RANGES[cur_mode][value]
        self.write(set_range)

    @property
    def resolution(self):
        """"""Returns current selected resolution, this property can be set.

        Possible values are 3,4 or 5 (for 3 1/2, 4 1/2 or 5 1/2 digits of resolution)
        """"""
        number_of_digit = 6 - self.status.digits
        return number_of_digit

    @resolution.setter
    def resolution(self, value):
        resolution_string = ""N"" + str(strict_discrete_set(value, [3, 4, 5]))
        self.write(resolution_string)

    @property
    def SRQ_mask(self):
        """"""Return current SRQ mask, this property can be set,

        bit assigment for SRQ:

        =========  ==========================
        Bit (dec)  Description
        =========  ==========================
         1         SRQ when Data ready
         4         SRQ when Syntax error
         8         SRQ when internal error
        16         front panel SQR button
        32         SRQ by invalid calibration
        =========  ==========================

        """"""

        return self.status.SRQ

    @SRQ_mask.setter
    def SRQ_mask(self, value):
        self.write(f""M{strict_range(value, [0, 63]):02o}"")

    @property
    def trigger(self):
        """"""Return current selected trigger mode, this property can be set

        Possibe values are:

        ========  ===========================================
        Value     Meaning
        ========  ===========================================
        auto      automatic trigger (internal)
        internal  automatic trigger (internal)
        external  external trigger (connector on back or GET)
        hold      holds the measurement
        fast      fast trigger for AC measurements
        ========  ===========================================

        """"""
        status = self.status
        i_trig = status.int_trig
        e_trig = status.ext_trig
        if i_trig == 0:
            if e_trig == 0:
                trigger_mode = ""hold""
            else:
                trigger_mode = ""external""
        else:
            trigger_mode = ""internal""
        return trigger_mode

    @trigger.setter
    def trigger(self, value):
        trig_set = self.TRIGGERS[strict_discrete_set(value, self.TRIGGERS)]
        self.write(trig_set)

    @property
    def calibration_data(self):
        """"""Read or write the calibration data as an array of 256 values between 0 and 15.

        The calibration data of an HP 3478A is stored in a 256x4 SRAM that is
        permanently powered by a 3v Lithium battery. When the battery runs
        out, the calibration data is lost, and recalibration is required.

        When read, this property fetches and returns the calibration data so that it can be
        backed up.

        When assigned a value, it similarly expects an array of 256 values between 0 and 15,
        and writes the values back to the instrument.

        When writing, exceptions are raised for the following conditions:

        * The CAL ENABLE switch at the front of the instrument is not set to ON.
        * The array with values does not contain exactly 256 elements.
        * The array with values does not pass a verification check.

        IMPORTANT: changing the calibration data results in permanent loss of
        the previous data. Use with care!

        """"""
        cal_data = []
        for addr in range(0, 256):
            # To fetch one nibble: 'W<address>', where address is a raw 8-bit number.
            cmd = bytes([ord('W'), addr])
            self.write_bytes(cmd)
            rvalue = self.read_bytes(1)[0]
            # 'W' command reads a nibble from the SRAM, but then adds a value of 64 to return
            # it as an ASCII value.
            if rvalue < 64 or rvalue >= 80:
                raise Exception(""calibration nibble out of range"")
            cal_data.append(rvalue-64)

        return cal_data

    @calibration_data.setter
    def calibration_data(self, cal_data):
        """"""Setter to write the calibration data.

        """"""

        if not self.calibration_enabled:
            raise Exception(""CAL ENABLE switch not set to ON"")

        self.write_calibration_data(cal_data, True)

    def write_calibration_data(self, cal_data, verify_calibration_data=True):
        """"""Method to write calibration data.

        The cal_data parameter format is the same as the ``calibration_data`` property.

        Verification of the cal_data array can be bypassed by setting
        ``verify_calibration_data`` to ``False``.

        """"""
        if verify_calibration_data and not self.verify_calibration_data(cal_data):
            raise ValueError(""cal_data verification fail."")

        for addr in range(0, 256):
            # To write one nibble: 'X<address><byte>', where address and byte are raw 8-bit numbers.
            cmd = bytes([ord('X'), addr, cal_data[addr]])
            self.write_bytes(cmd)
        pass

    def verify_calibration_entry(self, cal_data, entry_nr):
        """"""Verify the checksum of one calibration entry.

        Expects an array of 256 values with calibration data, and an entry
        number from 0 to 18.

        Returns True when the checksum of the specified calibration entry
        is correct.

        """"""
        if len(cal_data) != 256:
            raise Exception(""cal_data must contain 256 values"")

        sum = 0
        for idx in range(0, 13):
            val = cal_data[entry_nr*13 + idx + 1]
            if idx != 11:
                sum += val
            else:
                sum += val*16
        return sum == 255

    def verify_calibration_data(self, cal_data):
        """"""Verify the checksums of all calibration entries.

        Expects an array of 256 values with calibration data.

        :return calibration_correct: True when all checksums are correct.
        :rtype calibration_correct: boolean

        """"""
        for entry_nr in range(0, 19):
            if entry_nr in [5, 16, 18]:
                continue
            if not self.verify_calibration_entry(cal_data, entry_nr):
                return False
        return True
"
125,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/sUZnDIX-8nieD32jgr252w/NhhE9m3ihZmrN4xBUJbE4bLraR6GhpZ9j2r86wtmzw4w5VcGFpCZNCGI4yfU4bQBJ2_2HkrpMbG7n4U89RkfgQ/oKrWP5d3wFCxfQ1kNk4aE7tM78nJ98EiooiuXagcrWw'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2E0xpl91STbOPloNM64YQg/ph68iyo88kgu5nTF8w1wNmfuTNTMaovNyKmp6OMpg1j6e1dAK7gfzFAYUQEchvXleCZTFyKmAIpo9ikGP5fS0A/OhBlcoz33Nh4sRDaShARRqaWxUTh9xgwcHo2SWb00So'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rvL36QIOaxSBHW7djFWrgA/8boUIpHc8MC5pX-ZdFI7y3Qh7qMDf8Gnr2mQyKpaKoWWH5IqPhIPmAH19foOpsgUoW8go7Nb07NWsL6r9UdAew/l5B6MQfM7RMooMxyFdXtKKmRrRlhSZY9EngXo7cgC8Q'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/01SYOrKqyi853H_pFc-JIQ/wazv5KyO_3KHAoTzMn0HXVrBXDgBW3arSoyutV79748ntCc-OO9rsORV-a4M8uJDEF-wuiufipt0Xh5MTkJHmQ/g8wIFutcEGvsyV0UhUsp486hiJn7FBrDVapWAqR6UIE'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,Keithley 2450,262.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2450.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2450.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782527/Instruments/Power%20Supplies/Keithley-2450/Keithley-2450.png,Keithley 2450,Write a Python script that uses Pymeasure to connect to a Keithley 2450 Power Supplies,9549.3,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set
from .buffer import KeithleyBuffer

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2450(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2450 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2450(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2450.apply_current` and :meth:`~.Keithley2450.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    compliance_current = Instrument.control(
        "":SOUR:VOLT:ILIM?"", "":SOUR:VOLT:ILIM %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """"""
    )

    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current_delay = Instrument.control(
        "":SOUR:CURR:DEL?"", "":SOUR:CURR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_current_delay_auto = Instrument.control(
        "":SOUR:CURR:DEL:AUTO?"", "":SOUR:CURR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    compliance_voltage = Instrument.control(
        "":SOUR:CURR:VLIM?"", "":SOUR:CURR:VLIM %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage_delay = Instrument.control(
        "":SOUR:VOLT:DEL?"", "":SOUR:VOLT:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_voltage_delay_auto = Instrument.control(
        "":SOUR:VOLT:DEL:AUTO?"", "":SOUR:VOLT:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )

    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    wires = Instrument.control(
        "":SENS:RES:RSENSE?"", "":SENS:RES:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    means = Instrument.measurement(
        "":TRACe:STATistics:AVERage?"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )

    maximums = Instrument.measurement(
        "":TRACe:STATistics:MAXimum?"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    minimums = Instrument.measurement(
        "":TRACe:STATistics:MINimum?"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    standard_devs = Instrument.measurement(
        "":TRACe:STATistics:STDDev?"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Filters #
    ###########

    current_filter_type = Instrument.control(
        "":SENS:CURR:AVER:TCON?"", "":SENS:CURR:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    current_filter_count = Instrument.control(
        "":SENS:CURR:AVER:COUNT?"", "":SENS:CURR:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    current_filter_state = Instrument.control(
        "":SENS:CURR:AVER?"", "":SENS:CURR:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    voltage_filter_type = Instrument.control(
        "":SENS:VOLT:AVER:TCON?"", "":SENS:VOLT:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    voltage_filter_count = Instrument.control(
        "":SENS:VOLT:AVER:COUNT?"", "":SENS:VOLT:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    #####################
    # Output subsystem #
    #####################

    current_output_off_state = Instrument.control(
        "":OUTP:CURR:SMOD?"", "":OUTP:CURR:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    voltage_output_off_state = Instrument.control(
        "":OUTP:VOLT:SMOD?"", "":OUTP:VOLT:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2450 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2450.current_range` value or None
        """"""
        log.info(""%s is sourcing current."", self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2450.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2450 reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2450 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger.
        """"""
        return self.write(""*TRG"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
140,https://www.testequipmenthq.com/datasheets/KEITHLEY-6517A-Datasheet.pdf,https://en.wikipedia.org/wiki/Electrometer,"[OrderedDict([('id', 'atto8lu3YYQRLjggT'), ('width', 500), ('height', 289), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/kM--BaXnQHn63DA6PKlFAg/E0ta2iIOBZ1aSjBCz3XfuM-RY8tZOv_UWKkyBy6ktQFlAMOwX5u5t68rtyLcAkTFQ1ZVgisohqnMCxmXZL3vGTiVNjWVmQY6PKaz6Slj4Uo/sw8T9axnNFolmcydGexHYVnga-Tu2Ev10Xa68-IcXKA'), ('filename', '6517a.jpg'), ('size', 12864), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/q0XNzhoQm26hjp_WVjURuQ/vFYcqxwbDei3ErZUrN_acoLoWC8wd500h0ps1jvBMfFieTREZghp-L3I8mcCxAaH_M7lb3EN7BMkjnkCbVPVfA/CYBn9nODU3b1NwFoBHJWQMDx0O1Fl8gYVameZG-484w'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/h5knx9_Db9g0mM6S-jDMxw/Y5qfK12u36zTBLKb2MxVBR2rAryeOIToHkkZtYQBvvO1i_zMp0x3qEoNaPo-fNHfB9PTGGGkN05wXOw2b7TG_A/B_ITNo2iaEyDgS2ndACC1v0g9qeHoCeVj8wc64J0K9o'), ('width', 500), ('height', 289)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MsmW1DnzP3pBSnRpl41eyA/rMBABtJc86yeRhlfZto9gDUAX1Hib_fWbBLxdyo0KsOgBPrvr7uWaGUoNhmt4WbnOaYh0rEN3mnkUcj8Lf8aqg/iAPUth6H6cPR35c3KA6AnlQxZF7qi3WRLXH-gw5f03w'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Keithley 6517A 5 1/2 digit Electrometer / High Resistance Meter offers extreme accuracy and sensitivity specifications. It also offers a variety of features that simplify measuring high resistances and the resistivity of insulating materials. With reading rates of up to 125 readings/ second, the Keithley 6517A is also significantly faster than competitive electrometers, so it offers a quick, easy way to measure low-level curs.The half-rack-sized Keithley 6517A has a special low cur input amplifier with an input bias cur ofThe Keithley 6517A offers full autoranging over the full span of ranges on cur, resistance, voltage, and charge measurements",https://www.testwall.com/product/keithley-6517a/,Keithley 6517 A,203.0,['Power Meters'],"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6517b.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6517b.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782543/Instruments/Power%20Meters/Keithley-6517A/Keithley-6517A.jpg,Keithley 6517A,Write a Python script that uses Pymeasure to connect to a Keithley 6517A Power Meters,3895.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import re

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6517B(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6517B ElectroMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6517B(""GPIB::1"")

        keithley.apply_voltage()              # Sets up to source current
        keithley.source_voltage_range = 200   # Sets the source voltage
                                              # range to 200 V
        keithley.source_voltage = 20          # Sets the source voltage to 20 V
        keithley.enable_source()              # Enables the source output

        keithley.measure_resistance()         # Sets up to measure resistance

        keithley.ramp_to_voltage(50)          # Ramps the voltage to 50 V
        print(keithley.resistance)            # Prints the resistance in Ohms

        keithley.shutdown()                   # Ramps the voltage to 0 V
                                              # and disables output

    """"""

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    @staticmethod
    def extract_value(result):
        """""" extracts the physical value from a result object returned
            by the instrument """"""
        m = re.fullmatch(r'([+\-0-9E.]+)[A-Z]{4}', result[0])
        if m:
            return float(m.group(1))
        return None

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":MEAS?"",
        """""" Reads the current in Amps, if configured for this reading.
        """""", get_process=extract_value
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -20 and +20 mA.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-20e-3, 20e-3]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC current measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    source_current_resistance_limit = Instrument.control(
        "":SOUR:CURR:RLIM?"", "":SOUR:CURR:RLIM %g"",
        """""" Boolean property which enables or disables resistance
        current limit """""",
        cast=bool
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":MEAS:VOLT?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """""", get_process=extract_value
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC voltage measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """"""
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """""", get_process=extract_value
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 100e18 Ohms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 100e18]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the
        integration period and measurement speed. Takes values from 0.01
        to 10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively.
        """"""
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 6517B Electrometer/High Resistance Meter"", **kwargs):
        super().__init__(
            adapter, name,
            **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms,
                           from -210 POhms to 210 POhms
        :param auto_range: Enables auto_range if True, else uses the
                           resistance_range attribut
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -1000 V to 1000 V
        :param auto_range: Enables auto_range if True, else uses the
                           voltage_range attribut
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -21 mA to 21 mA
        :param auto_range: Enables auto_range if True, else uses the
                           current_range attribut
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_voltage(self, voltage_range=None):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.

        :param voltage_range: A :attr:`~.Keithley6517B.voltage_range` value
                              or None (activates auto range)
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.check_errors()

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6517B reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6517B error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Volts
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":TRIG:SOUR BUS;"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
148,https://www.testequipmenthq.com/datasheets/KEITHLEY-6221-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attAMc0ndlQOH57r9'), ('width', 218), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Zf-Fx9fdOKOpN41H5xt_BA/FAGUmn_celvT3g7khisVPHNowlFTTp5Czuin9SYUKdP9s3DEu-tPkmQ0SgtvqLW00BaXHnQTigAo0OGjHqxBd9rRugKMnvhA5zJr1rRpG8I/dmzrOUDgCINYDO6et6LebvetY3iyiSkFiopfreKPgEg'), ('filename', '6221.webp'), ('size', 4854), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wN3_trW3lLF5eCYvBaW_lA/W3o8NM7txTU9SwQ7BeFFZqPeld-w5btesbtX7yocqRHk08QFh1BpNGhYhPTQ_36HKVKZN8wwrzVPqCgaljLh5zN8wrxf_KllL6pej4BbsKA/tSe2CngoQ_whMaR8sQ7VxK4hOmZdj-srs_rYW2kM2GU'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YJPBCt4cLV28JRJKD_HuNQ/3uySpyLppcoMC6iNhN1-p-ijDe5MbZaEgJwjj-aaqqWBB4ytWcYYTZD5Vuu2SmbY9mdy0ZF5sB63NUlBz-Ic3GGJums-iTLIXguiCdqXzYQ/LD-XyKjaPCm0vuNifbOwCp1otrZuRlwwFzkdaVKIB2w'), ('width', 218), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/E69MTTXf0c2AQpLqbwYg-w/OYeTuq9SWHBcNXZA10-8Ptlj3boZ27miUalhLS-C_XdqWfiCN6GivKTYrNE9JBwBsJdoaKy43AzXiuGY1lelwq4PdqoDRfrjOtD5xTjN-CQ/MQ4B2usZJLC1EyTzeI8ASczqnkXlSNIQUfJ9sscmKVw'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://canada.newark.com/keithley/6221/source-meter-ac-dc-current-11w/dp/54K3077,Keithley 6221,232.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6221.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6221.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782550/Instruments/Power%20Supplies/Keithley-6221/Keithley-6221.webp,Keithley 6221,Write a Python script that uses Pymeasure to connect to a Keithley 6221 Power Supplies,11620.4,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument, RangeException
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6221(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6221 AC and DC current source and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6221(""GPIB::1"")
        keithley.clear()

        # Use the keithley as an AC source
        keithley.waveform_function = ""square""   # Set a square waveform
        keithley.waveform_amplitude = 0.05      # Set the amplitude in Amps
        keithley.waveform_offset = 0            # Set zero offset
        keithley.source_compliance = 10         # Set compliance (limit) in V
        keithley.waveform_dutycycle = 50        # Set duty cycle of wave in %
        keithley.waveform_frequency = 347       # Set the frequency in Hz
        keithley.waveform_ranging = ""best""      # Set optimal output ranging
        keithley.waveform_duration_cycles = 100 # Set duration of the waveform

        # Link end of waveform to Service Request status bit
        keithley.operation_event_enabled = 128  # OSB listens to end of wave
        keithley.srq_event_enabled = 128        # SRQ listens to OSB

        keithley.waveform_arm()                 # Arm (load) the waveform

        keithley.waveform_start()               # Start the waveform

        keithley.adapter.wait_for_srq()         # Wait for the pulse to finish

        keithley.waveform_abort()               # Disarm (unload) the waveform

        keithley.shutdown()                     # Disables output

    """"""

    ##########
    # OUTPUT #
    ##########

    source_enabled = Instrument.control(
        ""OUTPut?"", ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False. The convenience methods :meth:`~.Keithley6221.enable_source` and
        :meth:`~.Keithley6221.disable_source` can also be used."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_delay = Instrument.control(
        "":SOUR:DEL?"", "":SOUR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 1e-3 [seconds] and 999999.999 [seconds]."""""",
        validator=truncated_range,
        values=[1e-3, 999999.999],
    )

    output_low_grounded = Instrument.control(
        "":OUTP:LTE?"", ""OUTP:LTE %d"",
        """""" A boolean property that controls whether the low output of the triax
        connection is connected to earth ground (True) or is floating (False). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    ##########
    # SOURCE #
    ##########

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR %g"",
        """""" A floating point property that controls the source current
        in Amps. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_compliance = Instrument.control(
        "":SOUR:CURR:COMP?"", "":SOUR:CURR:COMP %g"",
        """"""A floating point property that controls the compliance of the current
        source in Volts. valid values are in range 0.1 [V] to 105 [V]."""""",
        validator=truncated_range,
        values=[0.1, 105])
    source_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -0.105 A and +0.105 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_auto_range = Instrument.control(
        "":SOUR:CURR:RANG:AUTO?"", "":SOUR:CURR:RANG:AUTO %d"",
        """""" A boolean property that controls the auto range of the current source.
        Valid values are True or False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ##################
    # WAVE FUNCTIONS #
    ##################

    waveform_function = Instrument.control(
        "":SOUR:WAVE:FUNC?"", "":SOUR:WAVE:FUNC %s"",
        """""" A string property that controls the selected wave function. Valid
        values are ""sine"", ""ramp"", ""square"", ""arbitrary1"", ""arbitrary2"",
        ""arbitrary3"" and ""arbitrary4"". """""",
        values={
            ""sine"": ""SIN"",
            ""ramp"": ""RAMP"",
            ""square"": ""SQU"",
            ""arbitrary1"": ""ARB1"",
            ""arbitrary2"": ""ARB2"",
            ""arbitrary3"": ""ARB3"",
            ""arbitrary4"": ""ARB4"",
        },
        map_values=True
    )

    waveform_frequency = Instrument.control(
        "":SOUR:WAVE:FREQ?"", "":SOUR:WAVE:FREQ %g"",
        """"""A floating point property that controls the frequency of the
        waveform in Hertz. Valid values are in range 1e-3 to 1e5. """""",
        validator=truncated_range,
        values=[1e-3, 1e5]
    )
    waveform_amplitude = Instrument.control(
        "":SOUR:WAVE:AMPL?"", "":SOUR:WAVE:AMPL %g"",
        """"""A floating point property that controls the (peak) amplitude of the
        waveform in Amps. Valid values are in range 2e-12 to 0.105. """""",
        validator=truncated_range,
        values=[2e-12, 0.105]
    )
    waveform_offset = Instrument.control(
        "":SOUR:WAVE:OFFS?"", "":SOUR:WAVE:OFFS %g"",
        """"""A floating point property that controls the offset of the waveform
        in Amps. Valid values are in range -0.105 to 0.105. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    waveform_dutycycle = Instrument.control(
        "":SOUR:WAVE:DCYC?"", "":SOUR:WAVE:DCYC %g"",
        """"""A floating point property that controls the duty-cycle of the
        waveform in percent for the square and ramp waves. Valid values are in
        range 0 to 100. """""",
        validator=truncated_range,
        values=[0, 100]
    )
    waveform_duration_time = Instrument.control(
        "":SOUR:WAVE:DUR:TIME?"", "":SOUR:WAVE:DUR:TIME %g"",
        """"""A floating point property that controls the duration of the
        waveform in seconds. Valid values are in range 100e-9 to 999999.999.
        """""",
        validator=truncated_range,
        values=[100e-9, 999999.999]
    )
    waveform_duration_cycles = Instrument.control(
        "":SOUR:WAVE:DUR:CYCL?"", "":SOUR:WAVE:DUR:CYCL %g"",
        """"""A floating point property that controls the duration of the
        waveform in cycles. Valid values are in range 1e-3 to 99999999900.
        """""",
        validator=truncated_range,
        values=[1e-3, 99999999900]
    )

    def waveform_duration_set_infinity(self):
        """""" Set the waveform duration to infinity.
        """"""
        self.write("":SOUR:WAVE:DUR:TIME INF"")

    waveform_ranging = Instrument.control(
        "":SOUR:WAVE:RANG?"", "":SOUR:WAVE:RANG %s"",
        """""" A string property that controls the source ranging of the
        waveform. Valid values are ""best"" and ""fixed"". """""",
        values={""best"": ""BEST"", ""fixed"": ""FIX""},
        map_values=True,
    )
    waveform_use_phasemarker = Instrument.control(
        "":SOUR:WAVE:PMAR:STAT?"", "":SOUR:WAVE:PMAR:STAT %s"",
        """""" A boolean property that controls whether the phase marker option
        is turned on or of. Valid values True (on) or False (off). Other
        settings for the phase marker have not yet been implemented."""""",
        values={True: 1, False: 0},
        map_values=True,
    )
    waveform_phasemarker_phase = Instrument.control(
        "":SOUR:WAVE:PMAR?"", "":SOUR:WAVE:PMAR %g"",
        """""" A numerical property that controls the phase of the phase marker."""""",
        validator=truncated_range,
        values=[-180, 180],
    )
    waveform_phasemarker_line = Instrument.control(
        "":SOUR:WAVE:PMAR:OLIN?"", "":SOUR:WAVE:PMAR:OLIN %d"",
        """""" A numerical property that controls the line of the phase marker."""""",
        validator=truncated_range,
        values=[1, 6],
    )

    def waveform_arm(self):
        """""" Arm the current waveform function. """"""
        self.write("":SOUR:WAVE:ARM"")

    def waveform_start(self):
        """""" Start the waveform output. Must already be armed """"""
        self.write("":SOUR:WAVE:INIT"")

    def waveform_abort(self):
        """""" Abort the waveform output and disarm the waveform function. """"""
        self.write("":SOUR:WAVE:ABOR"")

    def define_arbitary_waveform(self, datapoints, location=1):
        """""" Define the data points for the arbitrary waveform and copy the
        defined waveform into the given storage location.

        :param datapoints: a list (or numpy array) of the data points; all
            values have to be between -1 and 1; 100 points maximum.
        :param location: integer storage location to store the waveform in.
            Value must be in range 1 to 4.
        """"""

        # Check validity of parameters
        if not isinstance(datapoints, (list, np.ndarray)):
            raise ValueError(""datapoints must be a list or numpy array"")
        elif len(datapoints) > 100:
            raise ValueError(""datapoints cannot be longer than 100 points"")
        elif not all([x >= -1 and x <= 1 for x in datapoints]):
            raise ValueError(""all data points must be between -1 and 1"")

        if location not in [1, 2, 3, 4]:
            raise ValueError(""location must be in [1, 2, 3, 4]"")

        # Make list of strings
        datapoints = [str(x) for x in datapoints]
        data = "", "".join(datapoints)

        # Write the data points to the Keithley 6221
        self.write("":SOUR:WAVE:ARB:DATA %s"" % data)

        # Copy the written data to the specified location
        self.write("":SOUR:WAVE:ARB:COPY %d"" % location)

        # Select the newly made arbitrary waveform as waveform function
        self.waveform_function = ""arbitrary%d"" % location

    def __init__(self, adapter, name=""Keithley 6221 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """""" A boolean property that controls whether or not the display of the
        sourcemeter is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6221 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6221 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":ARM:SOUR IMM;:TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":ARM:SOUR BUS;:TRIG:SOUR BUS;"")

    def set_timed_arm(self, interval):
        """""" Sets up the measurement to be taken with the internal
        trigger at a variable sampling rate defined by the interval
        in seconds between sampling points
        """"""
        if interval > 99999.99 or interval < 0.001:
            raise RangeException(""Keithley 6221 can only be time""
                                 "" triggered between 1 mS and 1 Ms"")
        self.write("":ARM:SOUR TIM;:ARM:TIM %.3f"" % interval)

    def trigger_on_external(self, line=1):
        """""" Configures the measurement trigger to be taken from a
        specific line of an external trigger

        :param line: A trigger line from 1 to 4
        """"""
        cmd = "":ARM:SOUR TLIN;:TRIG:SOUR TLIN;""
        cmd += "":ARM:ILIN %d;:TRIG:ILIN %d;"" % (line, line)
        self.write(cmd)

    def output_trigger_on_external(self, line=1, after='DEL'):
        """""" Configures the output trigger on the specified trigger link
        line number, with the option of supplying the part of the
        measurement after which the trigger should be generated
        (default to delay, which is right before the measurement)

        :param line: A trigger line from 1 to 4
        :param after: An event string that determines when to trigger
        """"""
        self.write("":TRIG:OUTP %s;:TRIG:OLIN %d;"" % (after, line))

    def disable_output_trigger(self):
        """""" Disables the output trigger for the Trigger layer
        """"""
        self.write("":TRIG:OUTP NONE"")

    def shutdown(self):
        """""" Disables the output. """"""
        log.info(""Shutting down %s."" % self.name)
        self.disable_source()
        super().shutdown()

    ###############
    # Status bits #
    ###############

    measurement_event_enabled = Instrument.control(
        "":STAT:MEAS:ENAB?"", "":STAT:MEAS:ENAB %d"",
        """""" An integer value that controls which measurement events are
        registered in the Measurement Summary Bit (MSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    operation_event_enabled = Instrument.control(
        "":STAT:OPER:ENAB?"", "":STAT:OPER:ENAB %d"",
        """""" An integer value that controls which operation events are
        registered in the Operation Summary Bit (OSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    questionable_event_enabled = Instrument.control(
        "":STAT:QUES:ENAB?"", "":STAT:QUES:ENAB %d"",
        """""" An integer value that controls which questionable events are
        registered in the Questionable Summary Bit (QSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    standard_event_enabled = Instrument.control(
        ""ESE?"", ""ESE %d"",
        """""" An integer value that controls which standard events are
        registered in the Event Summary Bit (ESB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    srq_event_enabled = Instrument.control(
        ""*SRE?"", ""*SRE %d"",
        """""" An integer value that controls which event registers trigger the
        Service Request (SRQ) status bit. Refer to the Model 6220/6221
        Reference Manual for more information about programming the status
        bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 255],
    )

    measurement_events = Instrument.measurement(
        "":STAT:MEAS?"",
        """""" An integer value that reads which measurement events have been
        registered in the Measurement event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    operation_events = Instrument.measurement(
        "":STAT:OPER?"",
        """""" An integer value that reads which operation events have been
        registered in the Operation event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    questionable_events = Instrument.measurement(
        "":STAT:QUES?"",
        """""" An integer value that reads which questionable events have been
        registered in the Questionable event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    standard_events = Instrument.measurement(
        ""*ESR?"",
        """""" An integer value that reads which standard events have been
        registered in the Standard event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )
"
153,https://www.electrokit.com/uploads/productfile/41016/SPD1168X_DataSheet_DS0501X-E01A.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attsg6pyZAwOVcumH'), ('width', 799), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IYzfoafQAyhvmVeDNFBtJg/asSR-L9OhDojrN-8ZV0QrVs-qXJnos6SqeAl3Awf2JEUI_fNZFC7gbm7-OlRTYkon4LYEFgyzUcyBOOJGODs87xGecZI5BBIjRHurG9S0FxPgT4YEl1EJITNaqjPk6Tp/2-lrjbfOroOMsCTjtrP6kGtNDAA3i2Kjgg4s2I-ZqK8'), ('filename', '71+Pg3OmZeL._AC_UF894,1000_QL80_.jpg'), ('size', 88161), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/JH7TxQLefh5f7slFXuCEig/T7lmS1fMclfUt1XjaPA1zczUDasye9cszGyBzVicPCZCIeHiMaouM3Fydz37YHoNxILMofBy0lIKD_P00cUOWA/1uJLBezlpEGZappzilnJDJjIXaNEWH_lCMk-3-q8LDo'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mgHwfY9Vs_IizrU3VtMDoQ/lw-ZFalFFDq3kAz87b7P3hkd1irvCOe-ZsnUIp6tL3r1MKDE_v4m4Xtli2xAyiwbsO0d90Y07wT2IyRlB_QFTA/XI-mWFPULAm_6YcHI0zK7T66Kxs_07Fl3aa2LrLh0AE'), ('width', 512), ('height', 641)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AuCPdUMnE_bgYlbg90MuRw/1JvDkrjXaEme8z0xw_WKrBTOjehtguiN4gFHZXYkS_Vn0RDMC68kSTcT37dE8ZPNzC_iXDfYeApfqyXX1dNTfQ/FjNHRWMu0kFKgScvydBur4Cb4scAJF0u_5FZY24wPwI'), ('width', 3000), ('height', 3000)]))]))])]",57.0,"Shenzhen, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126014/Instruments/Vendor%20Logos/Siglent.png,"Siglent’s SPD1305X Series Programmable Linear DC Power Supply has a 2.8 inch TFT-LCD (240 * 320) color display. The SPD1305X outputs up to 150 Watts of power and has a Voltage range of 0-30 V and Current range of 0-5 A. The Voltage resolution is 1 uV while the Current resolution is 1 mA.

Because higher currents supplied through smaller gauge wire or longer distances can cause a drop in voltage to the supplied load, the SPD1305X incorporates Remote Sensing in order to measure the actual supplied voltage at the load. The remote sensed voltage is fed back to the power supply and output voltage is adjusted almost instantaneously.",https://siglentna.com/product/spd1305x/,Siglent SPD 1305 X,500.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","**iglent** is a China-based manufacturer specializing in electronic test & measurement instruments. Siglent founders began a preliminary study of digital oscilloscopes in 2002. It founded in 2007, and now Siglent has extended its product line to include digital oscilloscopes, function / arbitrary waveform generators, RF generators，digital multi-meters, DC power supplies, spectrum analyzers, spectrum & vector network analyzers, isolated handheld oscilloscopes, DC electronic loads and other general test instruments.Siglent also manufactured entry-level products for Lecroy.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/siglenttechnologies/siglent_spd1305x.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/siglenttechnologies/siglent_spd1305x.html,Siglent Technologies,"[OrderedDict([('id', 'attzuZfmx06hyyd2m'), ('width', 500), ('height', 304), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ovri_IqzfyTkltYKQf-5cw/fUefYEBFp44ZfgvrRFbEsxg5b-EgoBSh0S9X5t1baT-f36g1gHacA5dSoDLOIy6ilS0xVjJjgxBYIlnBTKEYT6T2iFx4crpsFTWfAqCO--Q/KoaoL7zZoZlZ-BUGWPgsp-uU4810G8foAaN5wg_4rsw'), ('filename', 'New-Siglent-Logo.png'), ('size', 3479), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EUOwxjHRDkR2ZXIsLitEVQ/V6LI0p2NivPfKsOes95120SaGjrVG7DUVaBiWK0RVsCnrg8xFAyQry2WQYK6oZ1ZG-nTDtxkKt0ptfqLzR_N2Q/TaM6PpOpi12pqlBZme25jC9OsK3H5lpNjIcZ9h-ZIbM'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7KUO2e0Bf6BrEl-H8av2Bw/vq__ajdEO0-pZ31cDiWXwYheijYwaAIRWTuNd39my6YGmsf31Cm0HjSbpeNcPAMNSomCYizTN8S4yfdiOrJaaA/GoDmhKCSdF5IJhNtcrXVmIcPe2R0yB3GxU5-ZZ0kInQ'), ('width', 500), ('height', 304)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZRQAVhXToHyxANCi45K_Jg/MfK_GwT0G27Gs5SYTaHMhjcKiN3_KT7k8NYjh1HaTDQUs779ziDIOjTK_iJqlmGDVJTYD0blNEQy6fznjzIztA/bkudePH6v2RxzvbXjRUx7WXWdNWWbxXAy6PMdOiFHaI'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782556/Instruments/Power%20Supplies/SPD1305X-Power-Supply/SPD1305X-Power-Supply.jpg,SPD1305X Power Supply,Write a Python script that uses Pymeasure to connect to a SPD1305X Power Supply Power Supplies,285.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.siglenttechnologies.siglent_spdbase import (SPDSingleChannelBase,
                                                                       SPDChannel)


class SPD1305X(SPDSingleChannelBase):
    """"""Represent the Siglent SPD1305X Power Supply.
    """"""

    voltage_range = [0, 30]
    current_range = [0, 5]
    ch_1 = Instrument.ChannelCreator(SPDChannel, 1,
                                     voltage_range=voltage_range,
                                     current_range=current_range)

    def __init__(self, adapter, name=""Siglent Technologies SPD1305X Power Supply"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

        self.ch_1.voltage_setpoint_values = self.voltage_range
        self.ch_1.current_limit_values = self.current_range
"
155,https://dl.cdn-anritsu.com/en-en/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/ms9740a-e11000.pdf,https://en.wikipedia.org/wiki/Spectrum_analyzer,"[OrderedDict([('id', 'attx5Gv1mQAH0GHFA'), ('width', 420), ('height', 310), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TmE2p_V5sK9wmVy3mLMnvg/g72jFarW1asxLX6WNE5s3PdywXfxZGMMQskvnsBNRj8oSfLIqK23ezeAHjI9mr9XKeWZ8wKi4bWkJuXY9xFPbEeuZiAl2fZhn_z9d2stOgQgWMHoUYsBQ3arA2Spzp4f/pg9B-ZXqTDYruoPqIErU8KJ0vpKfhOY38CKSeya-LDo'), ('filename', 'ms9740a-opticalspectrumanalyzer.png'), ('size', 100654), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ctk0DfCEVQ4eZsslN65AoQ/d9OP_07Ba8wJt6ey8QSpGL33sZ1Y4JZSpo0uHV17MhewZ01-7EYkyIAJ1hw8Okh9ZJypWS50dH5fE4yB4ly4mg/s9XdquWOyCPAXDHshqSdoM34_gK8wPId49M9FWUCA4c'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jrQ_8unqdmCgCxGTvI-VBQ/ltBIf0O71N69GBPD31_mxQtKOiTsYVqXjS6E1Rq8kjmv41l4FjdIzD4-sPFvBiTVXIX_oVZ3fVoen6tMZIsMjg/UD8rkMbw2uYhCMtZ_QXnMDyQuhTa93VMCS4xI9_InGs'), ('width', 420), ('height', 310)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Wcu0sUvFfM3tT0Zxg8HyCQ/WapJrIpzBLXnEXqbFAybuNnI25Rm-a8mVfM7FBDTzg0S18dAdKMH_7_wZMBoEAdH_wkLe8O35T1GZoMRutQOAA/W-Xr-mYXXvSmlVQnir9Am8PuLfmHS-wRmq0yPuJQB8Q'), ('width', 3000), ('height', 3000)]))]))])]",670.0,JAPAN,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125977/Instruments/Vendor%20Logos/Anritsu.png,"The MS9740A supports nine application measurement modes (DFBLD, FP-LD, LED, PMD, Opt. Amp, Opt. Amp (Multi-channel), WDM, LD Module, WDM Filter) for measurement targets",https://dl.cdn-anritsu.com/en-en/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/ms9740a-e11000.pdf,"Anritsums MS9749A

",83.0,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument.,"**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anritsu/anritsuMS9740A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMS9740A.html,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TRQ4_Rn8tl0yPM-RVMjuBw/kFmYa3cCjVKX_qs_g9OW7zhD_i4GEkoEppjnOVpMVuiX0JzEH1yU8nBH4mKsLSYi1uFpmyyXJiT3ttd2HQcUFfui1m7LKmPZDJtCpnY5zFU/qkJY09XNCCHcdbwxeGs4m9QAYf6HHtIptZXrVfVJEk0'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LnL4Lh9ggmFEWMhGWdT0gg/kWtki8ftAi-SCpHsi9Sw5Cp37ZLBmHCLO0BorUzi_Ec0G8orC_Ih-MEc4X9eM83qZ6GkYjFB_ByAaWFZbxhjyA/MROtjYDJdEfrz_I8_oyyWiMjzmmdKwjF0XSqSU0Dwsw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6Ic2IP80HOOT3l98fAw4uA/SLdpR9G_eKRIq4BWQT9eYpv5SuFVA2BHsIbi_FxFcEgMylu9vp2EEuBTbOC6QnxbQyInOT7hztv45kbAbOFMNg/LvfXHayFDgfCltMW4VSoM2ERLjffE9aTyhLEUsrhpBE'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tE-47WX6ExIM5eVQcREWKg/0D2mpJbdUmkE-D1ZcAIbxQtLqJDKaD_OybxyXdhv68_QyEfy26JOKxbwsiVGSk4BpUbYFWElRYLXTVYef6r3YA/xdLcUTzUj00BDRTmsWR4cpCnLkQC8H5RIRh7pkQ1C3s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782557/Instruments/Spectrum%20Analyzers/MS9740A/MS9740A.png,MS9740A,Write a Python script that uses Pymeasure to connect to a MS9740A Spectrum Analyzers,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.anritsu import AnritsuMS9710C
from pymeasure.instruments.validators import (
    strict_discrete_set,
    truncated_discrete_set,
    truncated_range,
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class AnritsuMS9740A(AnritsuMS9710C):
    """"""Anritsu MS9740A Optical Spectrum Analyzer.""""""

    def __init__(self, adapter, name=""Anritsu MS9740A Optical Spectrum Analyzer"", **kwargs):
        """"""Constructor.""""""
        self.analysis_mode = None
        super().__init__(
            adapter, name, **kwargs)

    ####################################
    # Spectrum Parameters - Wavelength #
    ####################################

    resolution = Instrument.control(
        ""RES?"", ""RES %s"", ""Resolution (nm)"",
        validator=truncated_discrete_set,
        values=[0.03, 0.05, 0.07, 0.1, 0.2, 0.5, 1.0],
    )

    resolution_vbw = Instrument.control(
        ""VBW?"", ""VBW %s"", ""Video Bandwidth Resolution"",
        validator=strict_discrete_set,
        values=[""1MHz"", ""100kHz"", ""10kHz"", ""2kHz"", ""1kHz"", ""200Hz"", ""100Hz"", ""10Hz""]
    )

    average_sweep = Instrument.control(
        ""AVS?"", ""AVS %d"",
        ""Nr. of averages to make on a sweep (1-1000), with 1 being a single (non-averaged) sweep"",
        validator=truncated_range, values=[1, 1000]
    )

    sampling_points = Instrument.control(
        ""MPT?"", ""MPT %d"", ""Number of sampling points"",
        validator=truncated_discrete_set,
        values=[51, 101, 251, 501, 1001, 2001, 5001, 10001, 20001, 50001],
        get_process=lambda v: int(v)
    )

    ##########################
    #  Data Memory Commands  #
    ##########################

    data_memory_select = Instrument.control(
        ""TTP?"", ""TTP %s"",
        ""Memory Data Select."",
        validator=strict_discrete_set,
        values=[""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J""]
    )

    def repeat_sweep(self, n=20, delay=0.5):
        """"""Perform a single sweep and wait for completion.""""""
        log.debug(""Performing a repeat Spectrum Sweep"")
        self.clear()
        self.write('SRT')
        self.wait_for_sweep(n=n, delay=delay)
"
161,https://download.tek.com/datasheet/2000-DMM-Data-Sheet-1KW612970.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attCEhcR8XZUmMJ2j'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/moPu1oXdipHWLs9jivmQaA/NosvBKMzZC3ZSxgVx5D66HxERssvrsaYClt6MXUiZIVvZUde-BqAWWc6MsmPu7B8zPr6oAaG7oeKlONrKfM0es_SY_nEwwyh7vfghbjdQ_0/s7NZ5CQFQPIJ5CdgaX5XHgAF04j-FP3_5qsxUgGXAzs'), ('filename', '2000.webp'), ('size', 6118), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yS6yv8pMqWs2C3pt7f4L2w/2JJJXsNyP7SFKiZDNHOyZp7yTF5lEOP2I6RRwnuPZYQQLKgnLYXiTV2zhuvKH5l1EZH9I6Io34cyIlzm_3sRSFDWeOv5dDoJ1-7s1t-nzfg/kDODSJwBMDw5X-_tDNkk9yoDDsmg89CAurOAiu_sgTg'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1u7Clb9iQXIIMXv6Mb3UxQ/NIfMPM2XAMgx1N0pei1hV03WcfyiaP2WyYj2ZPIg7JUk2xAJEqzivhDfBY419g5n0qDGd0M7bKj4eVC6pzHsEL_Jre6RWlLyu1v_VP2x25k/gvlmkgns5L7t9Znw0x4QaAEayY6KsdFUlIXympfWFe8'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IiBytagFPbVSpsjJ5_UgOQ/9bSe2_By0goAYW2opt4OLuPkh8ahxnvcrnUSiWfTFzR4petZY7LKUBO2RGAOZkmqDsEBJf5_kwyxGwxXP8-4PSBhdNXUbS5X0COkw5O9jvM/pmYQ2ytDyU86uiHyfpPHipye-JmDTHflHVylUUPgbCc'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Model 2000 6½-Digit Multimeter is part of Keithley’s family of high performance DMMs. Based on the same high speed, low noise A/D converter
technology as the Model 2001 and 2002, the 2000 is a fast, accurate,
and highly stable instrument that’s as easy to operate as it is to afford. It
combines broad measurement ranges with superior accuracy specifications",https://download.tek.com/datasheet/2000-DMM-Data-Sheet-1KW612970.pdf,Keithley 2000,224.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2000.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2000.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782454/Instruments/Multimeters/Keithley-2000/Keithley-2000.webp,Keithley 2000,Write a Python script that uses Pymeasure to connect to a Keithley 2000 Multimeters,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    truncated_range, truncated_discrete_set,
    strict_discrete_set
)
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2000(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2000 Multimeter and provides a high-level
    interface for interacting with the instrument.

    .. code-block:: python

        meter = Keithley2000(""GPIB::1"")
        meter.measure_voltage()
        print(meter.voltage)

    """"""
    MODES = {
        'current': 'CURR:DC', 'current ac': 'CURR:AC',
        'voltage': 'VOLT:DC', 'voltage ac': 'VOLT:AC',
        'resistance': 'RES', 'resistance 4W': 'FRES',
        'period': 'PER', 'frequency': 'FREQ',
        'temperature': 'TEMP', 'diode': 'DIOD',
        'continuity': 'CONT'
    }

    mode = Instrument.control(
        "":CONF?"", "":CONF:%s"",
        """""" A string property that controls the configuration mode for measurements,
        which can take the values: ``current`` (DC), ``current ac``,
        ``voltage`` (DC),  ``voltage ac``, ``resistance`` (2-wire),
        ``resistance 4W`` (4-wire), ``period``,
        ``temperature``, ``diode``, and ``frequency``."""""",
        validator=strict_discrete_set,
        values=MODES,
        map_values=True,
        get_process=lambda v: v.replace('""', '')
    )

    beep_state = Instrument.control(
        "":SYST:BEEP:STAT?"",
        "":SYST:BEEP:STAT %g"",
        """""" A string property that enables or disables the system status beeper,
        which can take the values: ``enabled`` and ``disabled``. """""",
        validator=strict_discrete_set,
        values={'enabled': 1, 'disabled': 0},
        map_values=True
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC current measurement in Amps, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the DC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_reference = Instrument.control(
        "":SENS:CURR:REF?"", "":SENS:CURR:REF %g"",
        """""" A floating point property that controls the DC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_digits = Instrument.control(
        "":SENS:CURR:DIG?"", "":SENS:CURR:DIG %d"",
        """""" An integer property that controls the number of digits in the DC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int,
    )
    current_ac_range = Instrument.control(
        "":SENS:CURR:AC:RANG?"", "":SENS:CURR:AC:RANG:AUTO 0;:SENS:CURR:AC:RANG %g"",
        """""" A floating point property that controls the AC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_ac_reference = Instrument.control(
        "":SENS:CURR:AC:REF?"", "":SENS:CURR:AC:REF %g"",
        """""" A floating point property that controls the AC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_ac_nplc = Instrument.control(
        "":SENS:CURR:AC:NPLC?"", "":SENS:CURR:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_ac_digits = Instrument.control(
        "":SENS:CURR:AC:DIG?"", "":SENS:CURR:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    current_ac_bandwidth = Instrument.control(
        "":SENS:CURR:AC:DET:BAND?"", "":SENS:CURR:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC current detector
        bandwidth in Hz, which can take the values 3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC voltage measurement in Volts, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the DC voltage range in
        Volts, which can take values from 0 to 1010 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    voltage_reference = Instrument.control(
        "":SENS:VOLT:REF?"", "":SENS:VOLT:REF %g"",
        """""" A floating point property that controls the DC voltage reference
        value in Volts, which can take values from -1010 to 1010 V. """""",
        validator=truncated_range,
        values=[-1010, 1010]
    )
    voltage_nplc = Instrument.control(
        "":SENS:CURRVOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_digits = Instrument.control(
        "":SENS:VOLT:DIG?"", "":SENS:VOLT:DIG %d"",
        """""" An integer property that controls the number of digits in the DC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_range = Instrument.control(
        "":SENS:VOLT:AC:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:AC:RANG %g"",
        """""" A floating point property that controls the AC voltage range in
        Volts, which can take values from 0 to 757.5 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 757.5]
    )
    voltage_ac_reference = Instrument.control(
        "":SENS:VOLT:AC:REF?"", "":SENS:VOLT:AC:REF %g"",
        """""" A floating point property that controls the AC voltage reference
        value in Volts, which can take values from -757.5 to 757.5 Volts. """""",
        validator=truncated_range,
        values=[-757.5, 757.5]
    )
    voltage_ac_nplc = Instrument.control(
        "":SENS:VOLT:AC:NPLC?"", "":SENS:VOLT:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_ac_digits = Instrument.control(
        "":SENS:VOLT:AC:DIG?"", "":SENS:VOLT:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_bandwidth = Instrument.control(
        "":SENS:VOLT:AC:DET:BAND?"", "":SENS:VOLT:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC voltage detector
        bandwidth in Hz, which can take the values  3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads a resistance measurement in Ohms for both 2-wire and 4-wire
        configurations, based on the active :attr:`~.Keithley2000.mode`. """"""
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the 2-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_reference = Instrument.control(
        "":SENS:RES:REF?"", "":SENS:RES:REF %g"",
        """""" A floating point property that controls the 2-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_digits = Instrument.control(
        "":SENS:RES:DIG?"", "":SENS:RES:DIG %d"",
        """""" An integer property that controls the number of digits in the 2-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    resistance_4W_range = Instrument.control(
        "":SENS:FRES:RANG?"", "":SENS:FRES:RANG:AUTO 0;:SENS:FRES:RANG %g"",
        """""" A floating point property that controls the 4-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_reference = Instrument.control(
        "":SENS:FRES:REF?"", "":SENS:FRES:REF %g"",
        """""" A floating point property that controls the 4-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_nplc = Instrument.control(
        "":SENS:FRES:NPLC?"", "":SENS:FRES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 4-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_4W_digits = Instrument.control(
        "":SENS:FRES:DIG?"", "":SENS:FRES:DIG %d"",
        """""" An integer property that controls the number of digits in the 4-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ##################
    # Frequency (Hz) #
    ##################

    frequency = Instrument.measurement(
        "":READ?"",
        """""" Reads a frequency measurement in Hz, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    frequency_reference = Instrument.control(
        "":SENS:FREQ:REF?"", "":SENS:FREQ:REF %g"",
        """""" A floating point property that controls the frequency reference
        value in Hz, which can take values from 0 to 15 MHz. """""",
        validator=truncated_range,
        values=[0, 15e6]
    )
    frequency_digits = Instrument.control(
        "":SENS:FREQ:DIG?"", "":SENS:FREQ:DIG %d"",
        """""" An integer property that controls the number of digits in the frequency
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    frequency_threshold = Instrument.control(
        "":SENS:FREQ:THR:VOLT:RANG?"", "":SENS:FREQ:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the frequency measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    frequency_aperature = Instrument.control(
        "":SENS:FREQ:APER?"", "":SENS:FREQ:APER %g"",
        """""" A floating point property that controls the frequency aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ##############
    # Period (s) #
    ##############

    period = Instrument.measurement(
        "":READ?"",
        """""" Reads a period measurement in seconds, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    period_reference = Instrument.control(
        "":SENS:PER:REF?"", "":SENS:PER:REF %g"",
        """""" A floating point property that controls the period reference value
        in seconds, which can take values from 0 to 1 s. """""",
        validator=truncated_range,
        values=[0, 1]
    )
    period_digits = Instrument.control(
        "":SENS:PER:DIG?"", "":SENS:PER:DIG %d"",
        """""" An integer property that controls the number of digits in the period
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    period_threshold = Instrument.control(
        "":SENS:PER:THR:VOLT:RANG?"", "":SENS:PRE:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the period measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    period_aperature = Instrument.control(
        "":SENS:PER:APER?"", "":SENS:PER:APER %g"",
        """""" A floating point property that controls the period aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ###################
    # Temperature (C) #
    ###################

    temperature = Instrument.measurement(
        "":READ?"",
        """""" Reads a temperature measurement in Celsius, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    temperature_reference = Instrument.control(
        "":SENS:TEMP:REF?"", "":SENS:TEMP:REF %g"",
        """""" A floating point property that controls the temperature reference value
        in Celsius, which can take values from -200 to 1372 C. """""",
        validator=truncated_range,
        values=[-200, 1372]
    )
    temperature_nplc = Instrument.control(
        "":SENS:TEMP:NPLC?"", "":SENS:TEMP:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the temperature measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    temperature_digits = Instrument.control(
        "":SENS:TEMP:DIG?"", "":SENS:TEMP:DIG %d"",
        """""" An integer property that controls the number of digits in the temperature
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ###########
    # Trigger #
    ###########

    trigger_count = Instrument.control(
        "":TRIG:COUN?"", "":TRIG:COUN %d"",
        """""" An integer property that controls the trigger count,
        which can take values from 1 to 9,999. """""",
        validator=truncated_range,
        values=[1, 9999],
        cast=int
    )
    trigger_delay = Instrument.control(
        "":TRIG:SEQ:DEL?"", "":TRIG:SEQ:DEL %g"",
        """""" A floating point property that controls the trigger delay
        in seconds, which can take values from 1 to 9,999,999.999 s. """""",
        validator=truncated_range,
        values=[0, 999999.999]
    )

    def __init__(self, adapter, name=""Keithley 2000 Multimeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def measure_voltage(self, max_voltage=1, ac=False):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if ac:
            self.mode = 'voltage ac'
            self.voltage_ac_range = max_voltage
        else:
            self.mode = 'voltage'
            self.voltage_range = max_voltage

    def measure_current(self, max_current=10e-3, ac=False):
        """""" Configures the instrument to measure current,
        based on a maximum current to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_current: A current in Volts to set the current range
        :param ac: False for DC current, and True for AC current
        """"""
        if ac:
            self.mode = 'current ac'
            self.current_ac_range = max_current
        else:
            self.mode = 'current'
            self.current_range = max_current

    def measure_resistance(self, max_resistance=10e6, wires=2):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if wires == 2:
            self.mode = 'resistance'
            self.resistance_range = max_resistance
        elif wires == 4:
            self.mode = 'resistance 4W'
            self.resistance_4W_range = max_resistance
        else:
            raise ValueError(""Keithley 2000 only supports 2 or 4 wire""
                             ""resistance meaurements."")

    def measure_period(self):
        """""" Configures the instrument to measure the period. """"""
        self.mode = 'period'

    def measure_frequency(self):
        """""" Configures the instrument to measure the frequency. """"""
        self.mode = 'frequency'

    def measure_temperature(self):
        """""" Configures the instrument to measure the temperature. """"""
        self.mode = 'temperature'

    def measure_diode(self):
        """""" Configures the instrument to perform diode testing.  """"""
        self.mode = 'diode'

    def measure_continuity(self):
        """""" Configures the instrument to perform continuity testing. """"""
        self.mode = 'continuity'

    def _mode_command(self, mode=None):
        if mode is None:
            mode = self.mode
        return self.MODES[mode]

    def auto_range(self, mode=None):
        """""" Sets the active mode to use auto-range,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:RANG:AUTO 1"" % self._mode_command(mode))

    def enable_reference(self, mode=None):
        """""" Enables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 1"" % self._mode_command(mode))

    def disable_reference(self, mode=None):
        """""" Disables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 0"" % self._mode_command(mode))

    def acquire_reference(self, mode=None):
        """""" Sets the active value as the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:ACQ"" % self._mode_command(mode))

    def enable_filter(self, mode=None, type='repeat', count=1):
        """""" Enables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        :param type: The type of averaging filter, either 'repeat' or 'moving'.
        :param count: A number of averages, which can take take values from 1 to 100
        """"""
        self.write("":SENS:%s:AVER:STAT 1"")
        self.write("":SENS:%s:AVER:TCON %s"")
        self.write("":SENS:%s:AVER:COUN %d"")

    def disable_filter(self, mode=None):
        """""" Disables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:AVER:STAT 0"" % self._mode_command(mode))

    def local(self):
        """""" Returns control to the instrument panel, and enables
        the panel if disabled. """"""
        self.write("":SYST:LOC"")

    def remote(self):
        """""" Places the instrument in the remote state, which is
        does not need to be explicity called in general. """"""
        self.write("":SYST:REM"")

    def remote_lock(self):
        """""" Disables and locks the front panel controls to prevent
        changes during remote operations. This is disabled by
        calling :meth:`~.Keithley2000.local`.  """"""
        self.write("":SYST:RWL"")

    def reset(self):
        """""" Resets the instrument state. """"""
        self.write("":STAT:QUEUE:CLEAR;*RST;:STAT:PRES;:*CLS;"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")
"
168,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attNaj1PW0Au0Ue7A'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qlt1jtptdv2bgF24g3R74Q/glIYEGTwQs21RV_t_QBDR6xz9WvGrg0ldfBXN99gVXUxHmPoZG4vyEeYPPSfkAaHrhsUKc2Ae9H9dhdoeYF8GunTaYqzJjzJvXGLikdKd0I/ToJ8NNXgpZkV92Ly6yKvYdRuLRiV4eLoohGFXU0tCsw'), ('filename', 'SR830_FP_Wide1.jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/RA1pbiRpAbvK-gncslHElQ/bVQwxBC3J3UQB-aN3YiZp--IqTlWXSVWGjAAyEw36J-LkgHSCcprYr9GtB8n_tXulTh42uTOllinWIUXD0ngzg/m5u6ABCrmc393w5zpEUNvqXVY_iC9p7NzOkMBn0xROc'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZMdHov0U9VqXejpSiPIhBA/qgQaGJHFUexcwqj9szqqcimqk8ZuavWKjgfln2jNltkSKv60yqNV0ovfpApiIbb8elSYcjNs1AkKfKQYEw43GQ/5y366OakVxsfXqxYtCoK0yGheOO_rKzE1l1wd9sZZzU'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5EKFuLPlE3iqPkJqgzwMMw/T3JqeW5oMruqPAxTiL-LjDVFlBJgloMC1s78-Ar5fzx_HXhgWSTW9l-ldU-bgq-z2TRfLM-WSZAKH579BIv_PA/xRCqMrrcaLsee5Pzv5Ni3KmdRMvdW7WepTKnskal0sI'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,https://www.thinksrs.com/products/sr810830.htm,SR 830,521.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr830.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr830.html,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782548/Instruments/Lockin%20Amplifiers/SR-830/SR-830.jpg,SR 830,Write a Python script that uses Pymeasure to connect to a SR 830 Lockin Amplifiers,4250.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import time
import numpy as np
from enum import IntFlag
from pymeasure.instruments import Instrument, discreteTruncate
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range


class LIAStatus(IntFlag):
    """""" IntFlag type that is returned by the lia_status property.
    """"""
    NO_ERROR = 0
    INPUT_OVERLOAD = 1
    FILTER_OVERLOAD = 2
    OUTPUT_OVERLOAD = 4
    REF_UNLOCK = 8
    FREQ_RANGE_CHANGE = 16
    TC_CHANGE = 32
    TRIGGER = 64
    UNUSED = 128


class ERRStatus(IntFlag):
    """""" IntFlag type that is returned by the err_status property.
    """"""
    NO_ERROR = 0
    BACKUP_ERR = 2
    RAM_ERR = 4
    ROM_ERR = 16
    GPIB_ERR = 32
    DSP_ERR = 64
    MATH_ERR = 128


class SR830(Instrument):

    SAMPLE_FREQUENCIES = [
        62.5e-3, 125e-3, 250e-3, 500e-3, 1, 2, 4, 8, 16,
        32, 64, 128, 256, 512
    ]
    SENSITIVITIES = [
        2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9,
        500e-9, 1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6,
        200e-6, 500e-6, 1e-3, 2e-3, 5e-3, 10e-3, 20e-3,
        50e-3, 100e-3, 200e-3, 500e-3, 1
    ]
    TIME_CONSTANTS = [
        10e-6, 30e-6, 100e-6, 300e-6, 1e-3, 3e-3, 10e-3,
        30e-3, 100e-3, 300e-3, 1, 3, 10, 30, 100, 300, 1e3,
        3e3, 10e3, 30e3
    ]
    FILTER_SLOPES = [6, 12, 18, 24]
    EXPANSION_VALUES = [1, 10, 100]
    RESERVE_VALUES = ['High Reserve', 'Normal', 'Low Noise']
    CHANNELS = ['X', 'Y', 'R']
    INPUT_CONFIGS = ['A', 'A - B', 'I (1 MOhm)', 'I (100 MOhm)']
    INPUT_GROUNDINGS = ['Float', 'Ground']
    INPUT_COUPLINGS = ['AC', 'DC']
    INPUT_NOTCH_CONFIGS = ['None', 'Line', '2 x Line', 'Both']
    REFERENCE_SOURCES = ['External', 'Internal']
    SNAP_ENUMERATION = {""x"": 1, ""y"": 2, ""r"": 3, ""theta"": 4,
                        ""aux in 1"": 5, ""aux in 2"": 6, ""aux in 3"": 7, ""aux in 4"": 8,
                        ""frequency"": 9, ""ch1"": 10, ""ch2"": 11}
    REFERENCE_SOURCE_TRIGGER = ['SINE', 'POS EDGE', 'NEG EDGE']
    INPUT_FILTER = ['Off', 'On']

    sine_voltage = Instrument.control(
        ""SLVL?"", ""SLVL%0.3f"",
        """""" A floating point property that represents the reference sine-wave
        voltage in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[0.004, 5.0]
    )
    frequency = Instrument.control(
        ""FREQ?"", ""FREQ%0.5e"",
        """""" A floating point property that represents the lock-in frequency
        in Hz. This property can be set. """""",
        validator=truncated_range,
        values=[0.001, 102000]
    )
    phase = Instrument.control(
        ""PHAS?"", ""PHAS%0.2f"",
        """""" A floating point property that represents the lock-in phase
        in degrees. This property can be set. """""",
        validator=truncated_range,
        values=[-360, 729.99]
    )
    x = Instrument.measurement(""OUTP?1"",
                               """""" Reads the X value in Volts. """"""
                               )
    y = Instrument.measurement(""OUTP?2"",
                               """""" Reads the Y value in Volts. """"""
                               )

    lia_status = Instrument.measurement(
        ""LIAS?"",
        """""" Reads the value of the lockin amplifier (LIA) status byte. Returns a binary string with
            positions within the string corresponding to different status flags:

            +----+--------------------------------------+
            |Bit | Status                               |
            +====+======================================+
            | 0  | Input/Amplifier overload             |
            +----+--------------------------------------+
            | 1  | Time constant filter overload        |
            +----+--------------------------------------+
            | 2  | Output overload                      |
            +----+--------------------------------------+
            | 3  | Reference unlock                     |
            +----+--------------------------------------+
            | 4  | Detection frequency range switched   |
            +----+--------------------------------------+
            | 5  | Time constant changed indirectly     |
            +----+--------------------------------------+
            | 6  | Data storage triggered               |
            +----+--------------------------------------+
            | 7  | unused                               |
            +----+--------------------------------------+
            """""",
        get_process=lambda s: LIAStatus(int(s)),
    )

    err_status = Instrument.measurement(
        ""ERRS?"",
        """"""Reads the value of the lockin error (ERR) status byte. Returns an IntFlag type with
        positions within the string corresponding to different error flags:

        +----+--------------------------------------+
        |Bit | Status                               |
        +====+======================================+
        | 0  | unused                               |
        +----+--------------------------------------+
        | 1  | backup error                         |
        +----+--------------------------------------+
        | 2  | RAM error                            |
        +----+--------------------------------------+
        | 3  | unused                               |
        +----+--------------------------------------+
        | 4  | ROM error                            |
        +----+--------------------------------------+
        | 5  | GPIB error                           |
        +----+--------------------------------------+
        | 6  | DSP error                            |
        +----+--------------------------------------+
        | 7  | DSP error                            |
        +----+--------------------------------------+
        """""",
        get_process=lambda s: ERRStatus(int(s)),
    )

    @property
    def xy(self):
        """""" Reads the X and Y values in Volts. """"""
        return self.snap()

    magnitude = Instrument.measurement(""OUTP?3"",
                                       """""" Reads the magnitude in Volts. """"""
                                       )
    theta = Instrument.measurement(""OUTP?4"",
                                   """""" Reads the theta value in degrees. """"""
                                   )
    channel1 = Instrument.control(
        ""DDEF?1;"", ""DDEF1,%d,0"",
        """""" A string property that represents the type of Channel 1,
        taking the values X, R, X Noise, Aux In 1, or Aux In 2.
        This property can be set."""""",
        validator=strict_discrete_set,
        values=['X', 'R', 'X Noise', 'Aux In 1', 'Aux In 2'],
        map_values=True
    )
    channel2 = Instrument.control(
        ""DDEF?2;"", ""DDEF2,%d,0"",
        """""" A string property that represents the type of Channel 2,
        taking the values Y, Theta, Y Noise, Aux In 3, or Aux In 4.
        This property can be set."""""",
        validator=strict_discrete_set,
        values=['Y', 'Theta', 'Y Noise', 'Aux In 3', 'Aux In 4'],
        map_values=True
    )
    sensitivity = Instrument.control(
        ""SENS?"", ""SENS%d"",
        """""" A floating point property that controls the sensitivity in Volts,
        which can take discrete values from 2 nV to 1 V. Values are truncated
        to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True
    )
    time_constant = Instrument.control(
        ""OFLT?"", ""OFLT%d"",
        """""" A floating point property that controls the time constant
        in seconds, which can take discrete values from 10 microseconds
        to 30,000 seconds. Values are truncated to the next highest
        level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True
    )
    filter_slope = Instrument.control(
        ""OFSL?"", ""OFSL%d"",
        """""" An integer property that controls the filter slope, which
        can take on the values 6, 12, 18, and 24 dB/octave. Values are
        truncated to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=FILTER_SLOPES,
        map_values=True
    )
    filter_synchronous = Instrument.control(
        ""SYNC?"", ""SYNC %d"",
        """"""A boolean property that controls the synchronous filter.
        This property can be set. Allowed values are: True or False """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )
    harmonic = Instrument.control(
        ""HARM?"", ""HARM%d"",
        """""" An integer property that controls the harmonic that is measured.
        Allowed values are 1 to 19999. Can be set. """""",
        validator=strict_discrete_set,
        values=range(1, 19999),
    )
    input_config = Instrument.control(
        ""ISRC?"", ""ISRC %d"",
        """""" An string property that controls the input configuration. Allowed
        values are: {}"""""".format(INPUT_CONFIGS),
        validator=strict_discrete_set,
        values=INPUT_CONFIGS,
        map_values=True
    )
    input_grounding = Instrument.control(
        ""IGND?"", ""IGND %d"",
        """""" An string property that controls the input shield grounding. Allowed
        values are: {}"""""".format(INPUT_GROUNDINGS),
        validator=strict_discrete_set,
        values=INPUT_GROUNDINGS,
        map_values=True
    )
    input_coupling = Instrument.control(
        ""ICPL?"", ""ICPL %d"",
        """""" An string property that controls the input coupling. Allowed
        values are: {}"""""".format(INPUT_COUPLINGS),
        validator=strict_discrete_set,
        values=INPUT_COUPLINGS,
        map_values=True
    )
    input_notch_config = Instrument.control(
        ""ILIN?"", ""ILIN %d"",
        """""" An string property that controls the input line notch filter
        status. Allowed values are: {}"""""".format(INPUT_NOTCH_CONFIGS),
        validator=strict_discrete_set,
        values=INPUT_NOTCH_CONFIGS,
        map_values=True
    )
    reference_source = Instrument.control(
        ""FMOD?"", ""FMOD %d"",
        """""" An string property that controls the reference source. Allowed
        values are: {}"""""".format(REFERENCE_SOURCES),
        validator=strict_discrete_set,
        values=REFERENCE_SOURCES,
        map_values=True
    )
    reference_source_trigger = Instrument.control(
        ""RSLP?"", ""RSLP %d"",
        """""" A string property that controls the reference source triggering. Allowed
             values are: {}"""""".format(REFERENCE_SOURCE_TRIGGER),
        validator=strict_discrete_set,
        values=REFERENCE_SOURCE_TRIGGER,
        map_values=True
    )

    aux_out_1 = Instrument.control(
        ""AUXV?1;"", ""AUXV1,%f;"",
        """""" A floating point property that controls the output of Aux output 1 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac1 = aux_out_1

    aux_out_2 = Instrument.control(
        ""AUXV?2;"", ""AUXV2,%f;"",
        """""" A floating point property that controls the output of Aux output 2 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac2 = aux_out_2

    aux_out_3 = Instrument.control(
        ""AUXV?3;"", ""AUXV3,%f;"",
        """""" A floating point property that controls the output of Aux output 3 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac3 = aux_out_3

    aux_out_4 = Instrument.control(
        ""AUXV?4;"", ""AUXV4,%f;"",
        """""" A floating point property that controls the output of Aux output 4 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac4 = aux_out_4

    aux_in_1 = Instrument.measurement(
        ""OAUX?1;"",
        """""" Reads the Aux input 1 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc1 = aux_in_1

    aux_in_2 = Instrument.measurement(
        ""OAUX?2;"",
        """""" Reads the Aux input 2 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc2 = aux_in_2

    aux_in_3 = Instrument.measurement(
        ""OAUX?3;"",
        """""" Reads the Aux input 3 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc3 = aux_in_3

    aux_in_4 = Instrument.measurement(
        ""OAUX?4;"",
        """""" Reads the Aux input 4 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc4 = aux_in_4

    def __init__(self, adapter, name=""Stanford Research Systems SR830 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def auto_gain(self):
        self.write(""AGAN"")

    def auto_reserve(self):
        self.write(""ARSV"")

    def auto_phase(self):
        self.write(""APHS"")

    def auto_offset(self, channel):
        """""" Offsets the channel (X, Y, or R) to zero """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        self.write(""AOFF %d"" % channel)

    def get_scaling(self, channel):
        """""" Returns the offset precent and the exapnsion term
        that are used to scale the channel in question
        """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        offset, expand = self.ask(""OEXP? %d"" % channel).split(',')
        return float(offset), self.EXPANSION_VALUES[int(expand)]

    def set_scaling(self, channel, precent, expand=0):
        """""" Sets the offset of a channel (X=1, Y=2, R=3) to a
        certain precent (-105% to 105%) of the signal, with
        an optional expansion term (0, 10=1, 100=2)
        """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        expand = discreteTruncate(expand, self.EXPANSION_VALUES)
        self.write(""OEXP %i,%.2f,%i"" % (channel, precent, expand))

    def output_conversion(self, channel):
        """""" Returns a function that can be used to determine
        the signal from the channel output (X, Y, or R)
        """"""
        offset, expand = self.get_scaling(channel)
        sensitivity = self.sensitivity
        return lambda x: (x / (10. * expand) + offset) * sensitivity

    @property
    def sample_frequency(self):
        """""" Gets the sample frequency in Hz """"""
        index = int(self.ask(""SRAT?""))
        if index == 14:
            return None  # Trigger
        else:
            return SR830.SAMPLE_FREQUENCIES[index]

    @sample_frequency.setter
    def sample_frequency(self, frequency):
        """"""Sets the sample frequency in Hz (None is Trigger)""""""
        assert type(frequency) in [float, int, type(None)]
        if frequency is None:
            index = 14  # Trigger
        else:
            frequency = discreteTruncate(frequency, SR830.SAMPLE_FREQUENCIES)
            index = SR830.SAMPLE_FREQUENCIES.index(frequency)
        self.write(""SRAT%f"" % index)

    def aquireOnTrigger(self, enable=True):
        self.write(""TSTR%d"" % enable)

    @property
    def reserve(self):
        return SR830.RESERVE_VALUES[int(self.ask(""RMOD?""))]

    @reserve.setter
    def reserve(self, reserve):
        if reserve not in SR830.RESERVE_VALUES:
            index = 1
        else:
            index = SR830.RESERVE_VALUES.index(reserve)
        self.write(""RMOD%d"" % index)

    def is_out_of_range(self):
        """""" Returns True if the magnitude is out of range
        """"""
        return int(self.ask(""LIAS?2"")) == 1

    def quick_range(self):
        """""" While the magnitude is out of range, increase
        the sensitivity by one setting
        """"""
        self.write('LIAE 2,1')
        while self.is_out_of_range():
            self.write(""SENS%d"" % (int(self.ask(""SENS?"")) + 1))
            time.sleep(5.0 * self.time_constant)
            self.write(""*CLS"")
        # Set the range as low as possible
        newsensitivity = 1.15 * abs(self.magnitude)
        if self.input_config in ('I (1 MOhm)', 'I (100 MOhm)'):
            newsensitivity = newsensitivity * 1e6
        self.sensitivity = newsensitivity

    @property
    def buffer_count(self):
        query = self.ask(""SPTS?"")
        if query.count(""\n"") > 1:
            return int(re.match(r""\d+\n$"", query, re.MULTILINE).group(0))
        else:
            return int(query)

    def fill_buffer(self, count, has_aborted=lambda: False, delay=0.001):
        ch1 = np.empty(count, np.float32)
        ch2 = np.empty(count, np.float32)
        currentCount = self.buffer_count
        index = 0
        while currentCount < count:
            if currentCount > index:
                ch1[index:currentCount] = self.buffer_data(1, index, currentCount)
                ch2[index:currentCount] = self.buffer_data(2, index, currentCount)
                index = currentCount
                time.sleep(delay)
            currentCount = self.buffer_count
            if has_aborted():
                self.pause_buffer()
                return ch1, ch2
        self.pauseBuffer()
        ch1[index : count + 1] = self.buffer_data(1, index, count)  # noqa: E203
        ch2[index : count + 1] = self.buffer_data(2, index, count)  # noqa: E203
        return ch1, ch2

    def buffer_measure(self, count, stopRequest=None, delay=1e-3):
        self.write(""FAST0;STRD"")
        ch1 = np.empty(count, np.float64)
        ch2 = np.empty(count, np.float64)
        currentCount = self.buffer_count
        index = 0
        while currentCount < count:
            if currentCount > index:
                ch1[index:currentCount] = self.buffer_data(1, index, currentCount)
                ch2[index:currentCount] = self.buffer_data(2, index, currentCount)
                index = currentCount
                time.sleep(delay)
            currentCount = self.buffer_count
            if stopRequest is not None and stopRequest.isSet():
                self.pauseBuffer()
                return (0, 0, 0, 0)
        self.pauseBuffer()
        ch1[index:count] = self.buffer_data(1, index, count)
        ch2[index:count] = self.buffer_data(2, index, count)
        return (ch1.mean(), ch1.std(), ch2.mean(), ch2.std())

    def pause_buffer(self):
        self.write(""PAUS"")

    def start_buffer(self, fast=False):
        if fast:
            self.write(""FAST2;STRD"")
        else:
            self.write(""FAST0;STRD"")

    def wait_for_buffer(self, count, has_aborted=lambda: False,
                        timeout=60, timestep=0.01):
        """""" Wait for the buffer to fill a certain count
        """"""
        i = 0
        while not self.buffer_count >= count and i < (timeout / timestep):
            time.sleep(timestep)
            i += 1
            if has_aborted():
                return False
        self.pauseBuffer()

    def get_buffer(self, channel=1, start=0, end=None):
        """""" Aquires the 32 bit floating point data through binary transfer
        """"""
        if end is None:
            end = self.buffer_count
        return self.binary_values(""TRCB?%d,%d,%d"" % (
            channel, start, end - start))

    def reset_buffer(self):
        self.write(""REST"")

    def trigger(self):
        self.write(""TRIG"")

    def snap(self, val1=""X"", val2=""Y"", *vals):
        """""" Method that records and retrieves 2 to 6 parameters at a single
        instant. The parameters can be one of: X, Y, R, Theta, Aux In 1,
        Aux In 2, Aux In 3, Aux In 4, Frequency, CH1, CH2.
        Default is ""X"" and ""Y"".

        :param val1: first parameter to retrieve
        :param val2: second parameter to retrieve
        :param vals: other parameters to retrieve (optional)
        """"""
        if len(vals) > 4:
            raise ValueError(""No more that 6 values (in total) can be captured""
                             ""simultaneously."")

        # check if additional parameters are given as a list
        if len(vals) == 1 and isinstance(vals[0], (list, tuple)):
            vals = vals[0]

        # make a list of all vals
        vals = [val1, val2] + list(vals)

        vals_idx = [str(self.SNAP_ENUMERATION[val.lower()]) for val in vals]

        command = ""SNAP? "" + "","".join(vals_idx)
        return self.values(command)
"
185,https://dl.cdn-anritsu.com/en-us/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/MS9710C_E11000.pdf,https://en.wikipedia.org/wiki/Spectrum_analyzer,"[OrderedDict([('id', 'att0T5rZRurNk2dQN'), ('width', 300), ('height', 250), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rof3fvsBZFX6BEpCHSeUJQ/K_sVcb-JQPKeWfuq1mRxpsI6gxCwweicm-NUxJmvnQeiVR4wTd449M_D-GaTR0btqFu8wytxO2J359zJyGoLAYYGmzv8Etyki_XJuEtWq78/ekMKWbSP0NJ4U31rc8FUMFrzJ5ot8LRzzTTgtzcrSbM'), ('filename', 'MS9710C.jpeg'), ('size', 48894), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/fuAhhy9vG6MBpjTKN8KL1w/4MOJfa1sg5ajds4VJony1eyUmsuriKd9cQn1u_BM21XErV-b9FYxEPbnvfXWYNp5I325aM6nBeOw-wId7rLqrA/_gv5JBIIbE-tXCvKYbVuCddtVKZT2Yx5O7weD1Q0nME'), ('width', 43), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/P2OKLJUo0oOf_GAIqXPLyw/16Xuz2fn3h4Si2PtI-1G6RCxA9NBOkDs1aAlyOnudjXFd-tGrvpcwcsYX7G5yz9gVXL_DakEBWwNMgTKuEuUBQ/jwYnPcqMNNAj9srU3jP26ve1ufgBzCnCz6a3JDTJ9z4'), ('width', 300), ('height', 250)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6HQMkb5z3wSp5XjgfW2F4g/gU93Yk1kvy3dOyh0KJIppr8StZikFv2nTLv3JBsShdNfxFBi_G0v0EZxN6VOEj1zBakhaW4StSOnwGRdmFFPkw/wIQ-ma4VM4U8AMZR8abgTy47D2zCqzhxC5i_S9q1AgU'), ('width', 3000), ('height', 3000)]))]))])]",670.0,JAPAN,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125977/Instruments/Vendor%20Logos/Anritsu.png,"The MS9710C provides excellent wavelength accuracy, waveform shape, and new features
",https://www.anritsu.com/en-us/test-measurement/products/ms9710c,Anritsums MS9710 C,82.0,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument.,"**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anritsu/anritsuMS9710C.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMS9710C.html,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TRQ4_Rn8tl0yPM-RVMjuBw/kFmYa3cCjVKX_qs_g9OW7zhD_i4GEkoEppjnOVpMVuiX0JzEH1yU8nBH4mKsLSYi1uFpmyyXJiT3ttd2HQcUFfui1m7LKmPZDJtCpnY5zFU/qkJY09XNCCHcdbwxeGs4m9QAYf6HHtIptZXrVfVJEk0'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LnL4Lh9ggmFEWMhGWdT0gg/kWtki8ftAi-SCpHsi9Sw5Cp37ZLBmHCLO0BorUzi_Ec0G8orC_Ih-MEc4X9eM83qZ6GkYjFB_ByAaWFZbxhjyA/MROtjYDJdEfrz_I8_oyyWiMjzmmdKwjF0XSqSU0Dwsw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6Ic2IP80HOOT3l98fAw4uA/SLdpR9G_eKRIq4BWQT9eYpv5SuFVA2BHsIbi_FxFcEgMylu9vp2EEuBTbOC6QnxbQyInOT7hztv45kbAbOFMNg/LvfXHayFDgfCltMW4VSoM2ERLjffE9aTyhLEUsrhpBE'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tE-47WX6ExIM5eVQcREWKg/0D2mpJbdUmkE-D1ZcAIbxQtLqJDKaD_OybxyXdhv68_QyEfy26JOKxbwsiVGSk4BpUbYFWElRYLXTVYef6r3YA/xdLcUTzUj00BDRTmsWR4cpCnLkQC8H5RIRh7pkQ1C3s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782588/Instruments/Spectrum%20Analyzers/MS9710C/MS9710C.jpg,MS9710C,Write a Python script that uses Pymeasure to connect to a MS9710C Spectrum Analyzers,,"
",True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging
from time import sleep
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set,
    truncated_discrete_set,
    truncated_range,
    joined_validators
)
import re

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

# Analysis Results with Units, ie -24.5DBM -> (-24.5, 'DBM')
r_value_units = re.compile(r""([-\d]*\.\d*)(.*)"")

# Join validators to allow for special sets of characters
truncated_range_or_off = joined_validators(strict_discrete_set, truncated_range)


def _int_or_neg_one(v):
    try:
        return int(v)
    except ValueError:
        return -1


def _parse_trace_peak(vals):
    """"""Parse the returned value from a trace peak query.""""""
    l, p = vals
    res = [l]
    m = r_value_units.match(p)
    if m is not None:
        data = list(m.groups())
        data[0] = float(data[0])
        res.extend(data)
    else:
        res.append(float(p))
    return res


class AnritsuMS9710C(Instrument):
    """"""Anritsu MS9710C Optical Spectrum Analyzer.""""""

    def __init__(self, adapter, name=""Anritsu MS9710C Optical Spectrum Analyzer"", **kwargs):
        """"""Constructor.""""""
        self.analysis_mode = None
        super().__init__(adapter, name=name, **kwargs)

    #############
    #  Mappings #
    #############
    ONOFF = [""ON"", ""OFF""]
    ONOFF_MAPPING = {True: 'ON', False: 'OFF', 1: 'ON', 0: 'OFF', 'ON': 'ON', 'OFF': 'OFF'}

    ######################
    #  Status Registers  #
    ######################

    ese2 = Instrument.control(
        ""ESE2?"", ""ESE2 %d"",
        ""Extended Event Status Enable Register 2"",
        get_process=int
    )

    esr2 = Instrument.control(
        ""ESR2?"", ""ESR2 %d"",
        ""Extended Event Status Register 2"",
        get_process=_int_or_neg_one
    )

    ###########
    #  Modes  #
    ###########

    measure_mode = Instrument.measurement(
        ""MOD?"", ""Returns the current Measure Mode the OSA is in."",
        values={None: 0, ""SINGLE"": 1.0, ""AUTO"": 2.0, ""POWER"": 3.0},
        map_values=True
    )

    ####################################
    # Spectrum Parameters - Wavelength #
    ####################################
    wavelength_center = Instrument.control(
        'CNT?', 'CNT %g', ""Center Wavelength of Spectrum Scan in nm."")

    wavelength_span = Instrument.control(
        'SPN?', 'SPN %g', ""Wavelength Span of Spectrum Scan in nm."")

    wavelength_start = Instrument.control(
        'STA?', 'STA %g', ""Wavelength Start of Spectrum Scan in nm."")

    wavelength_stop = Instrument.control(
        'STO?', 'STO %g', ""Wavelength Stop of Spectrum Scan in nm."")

    wavelength_marker_value = Instrument.control(
        'MKV?', 'MKV %s',
        ""Wavelength Marker Value (wavelength or freq.?)"",
        validator=strict_discrete_set,
        values=[""WL"", ""FREQ""]
    )

    wavelength_value_in = Instrument.control(
        'WDP?', 'WDP %s',
        ""Wavelength value in Vacuum or Air"",
        validator=strict_discrete_set,
        values=[""VACUUM"", ""AIR""]
    )

    level_scale = Instrument.measurement(
        'LVS?', ""Current Level Scale"",
        values=[""LOG"", ""LIN""]
    )

    level_log = Instrument.control(
        ""LOG?"", ""LOG %f"", ""Level Log Scale (/div)"",
        validator=truncated_range, values=[0.1, 10.0]
    )

    level_lin = Instrument.control(
        ""LIN?"", ""LIN %f"", ""Level Linear Scale (/div)"",
        validator=truncated_range, values=[1e-12, 1]
    )

    level_opt_attn = Instrument.control(
        ""ATT?"", ""ATT %s"", ""Optical Attenuation Status (ON/OFF)"",
        validator=strict_discrete_set,
        values=ONOFF
    )

    resolution = Instrument.control(
        ""RES?"", ""RES %f"", ""Resolution (nm)"",
        validator=truncated_discrete_set,
        values=[0.05, 0.07, 0.1, 0.2, 0.5, 1.0]
    )

    resolution_actual = Instrument.control(
        ""ARES?"", ""ARES %s"", ""Resolution Actual (ON/OFF)"",
        validator=strict_discrete_set,
        values=ONOFF,
        map_values=True

    )

    resolution_vbw = Instrument.control(
        ""VBW?"", ""VBW %s"", ""Video Bandwidth Resolution"",
        validator=strict_discrete_set,
        values=[""1MHz"", ""100kHz"", ""10kHz"", ""1kHz"", ""100Hz"", ""10Hz""]
    )

    average_point = Instrument.control(
        ""AVT?"", ""AVT %d"",
        ""Number of averages to take on each point (2-1000), or OFF"",
        validator=truncated_range_or_off,
        values=[[""OFF""], [2, 1000]]
    )

    average_sweep = Instrument.control(
        ""AVS?"", ""AVS %d"",
        ""Number of averages to make on a sweep (2-1000) or OFF"",
        validator=truncated_range_or_off,
        values=[[""OFF""], [2, 1000]]
    )

    sampling_points = Instrument.control(
        ""MPT?"", ""MPT %d"", ""Number of sampling points"",
        validator=truncated_discrete_set,
        values=[51, 101, 251, 501, 1001, 2001, 5001],
        get_process=lambda v: int(v)
    )

    #####################################
    #  Analysis Peak Search Parameters  #
    #####################################

    peak_search = Instrument.control(
        ""PKS?"", ""PKS %s"", ""Peak Search Mode"",
        validator=strict_discrete_set,
        values=[""PEAK"", ""NEXT"", ""LAST"", ""LEFT"", ""RIGHT""]
    )

    dip_search = Instrument.control(
        ""DPS?"", ""DPS %s"", ""Dip Search Mode"",
        validator=strict_discrete_set,
        values=[""DIP"", ""NEXT"", ""LAST"", ""LEFT"", ""RIGHT""]
    )

    analysis = Instrument.control(
        ""ANA?"", ""ANA %s"", ""Analysis Control""
    )

    analysis_result = Instrument.measurement(
        ""ANAR?"", ""Read back anaysis result from current scan.""
    )

    ##########################
    #  Data Memory Commands  #
    ##########################

    data_memory_a_size = Instrument.measurement(
        'DBA?',
        ""Returns the number of points sampled in data memory register A.""
    )

    data_memory_b_size = Instrument.measurement(
        'DBB?',
        ""Returns the number of points sampled in data memory register B.""
    )

    data_memory_a_condition = Instrument.measurement(
        ""DCA?"",
        """"""Returns the data condition of data memory register A.
        Starting wavelength, and a sampling point (l1, l2, n).""""""
    )

    data_memory_b_condition = Instrument.measurement(
        ""DCB?"",
        """"""Returns the data condition of data memory register B.
        Starting wavelength, and a sampling point (l1, l2, n).""""""
    )

    data_memory_a_values = Instrument.measurement(
        ""DMA?"",
        ""Reads the binary data from memory register A.""
    )

    data_memory_b_values = Instrument.measurement(
        ""DMA?"",
        ""Reads the binary data from memory register B.""
    )

    data_memory_select = Instrument.control(
        ""MSL?"", ""MSL %s"",
        ""Memory Data Select."",
        validator=strict_discrete_set,
        values=[""A"", ""B""]
    )

    ###########################
    #  Trace Marker Commands  #
    ###########################

    trace_marker_center = Instrument.setting(
        ""TMC %s"", ""Trace Marker at Center. Set to 1 or True to initiate command"",
        map_values=True,
        values={True: ''}
    )

    trace_marker = Instrument.control(
        ""TMK?"", ""TMK %f"",
        ""Sets the trace marker with a wavelength.  Returns the trace wavelength and power."",
        get_process=_parse_trace_peak
    )

    @property
    def wavelengths(self):
        """"""Return a numpy array of the current wavelengths of scans.""""""
        return np.linspace(
            self.wavelength_start,
            self.wavelength_stop,
            self.sampling_points
        )

    def read_memory(self, slot=""A""):
        """"""Read the scan saved in a memory slot.""""""
        cond_attr = f""data_memory_{slot.lower()}_condition""
        data_attr = f""data_memory_{slot.lower()}_values""

        scan = getattr(self, cond_attr)
        wavelengths = np.linspace(scan[0], scan[1], int(scan[2]))
        power = np.fromstring(getattr(self, data_attr), sep=""\r\n"")

        return wavelengths, power

    def wait(self, n=3, delay=1):
        """"""Query OPC Command and waits for appropriate response.""""""
        log.info(""Wait for OPC"")
        res = self.ask(""*OPC?"")
        n_attempts = n
        while res == '':
            log.debug(f""Empty OPC Response. {n_attempts} remaining"")
            if n_attempts == 0:
                break
            n_attempts -= 1
            sleep(delay)
            res = self.read().strip()

        log.debug(res)

    def wait_for_sweep(self, n=20, delay=0.5):
        """"""Wait for a sweep to stop.

        This is performed by checking bit 1 of the ESR2.
        """"""
        log.debug(""Waiting for spectrum sweep"")

        while self.esr2 != 3 and n > 0:
            log.debug(f""Wait for sweep [{n}]"")
            # log.debug(""ESR2: {}"".format(esr2))
            sleep(delay)
            n -= 1

        if n <= 0:
            log.warning(f""Sweep Timeout Occurred ({int(delay * n)} s)"")

    def single_sweep(self, **kwargs):
        """"""Perform a single sweep and wait for completion.""""""
        log.debug(""Performing a Spectrum Sweep"")
        self.clear()
        self.write('SSI')
        self.wait_for_sweep(**kwargs)

    def center_at_peak(self, **kwargs):
        """"""Center the spectrum at the measured peak.""""""
        self.write(""PKC"")
        self.wait(**kwargs)

    def measure_peak(self):
        """"""Measure the peak and return the trace marker.""""""
        self.peak_search = ""PEAK""
        return self.trace_marker
"
186,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037,"[OrderedDict([('id', 'attE3gJZRoLQpO3nR'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/L3WnVH1jcTmGa3oP-wrc1Q/i9YJkRvcOMvPi-9_T0yKrpWpis1idaHI86gFZRpLFo-nGxMH9UXJg27VWzaSrb1in1MBMNuBxfy_jnP75jn7X0W3dCKGPe0njS10vtqqaLA/PDH-LCgYLgM3QWW-ejc05ncIeQhWkGGInWkcx8NFOAI'), ('filename', '8135_PM100USB_SGL.jpg'), ('size', 136075), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s5XChqt3l45-o0wOXWQXNg/0gsoGCdFGV3J_lVZSQGarCHSB5aPYkPvaVN5Vh-4CJf4qT7vjguWQ9XL045JxO4w6nzUgsi-eLo47eMox4vNoQ/bCgSl-tFRNNEoO08K2v10pX5qoH7252XavZL0bLCuNM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KzVGgQqJCtJT959R2OX5kQ/HhAIyUHDKLOLa8WUZrOpufgQDfx7I05Z-LZo7DX-n9rSi4_dg4cBT4iU7JJLhJgXHZo7KcQnJc-NWlTnx1HEDA/8zOIi8mUdgWmF0gRcEuNSMC1fFSkCTpmC00j8Ucv_A0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tu4KDopbR3ruCsJmKaQfmw/AzYamci3R8htlNyk-FEKBkCY4zYRbAfWS43AT6g8oNdZZBW1ouUqeUe4w3MyaUuVKu9kDy5F8kebTpqO0johcQ/C6hkc362JD70YxjSRsO3-DQlW4X2VwjIw_hn0UAYMh8'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The PM100USB Power and Energy Meter Interface is compatible with all our C-Series photodiode, thermal, and pyroelectric sensors except for the ES408C Fast Pyroelectric Sensor. Our C-Type standard photodiode, slim photodiode, integrating sphere, and fiber sensors can collectively measure optical powers from 100 pW to 20 W. Our thermal power sensors measure optical powers from 10 µW to 200 W. Compatible C-Series pyroelectric energy sensors can measure energies from 10 µJ to 15 J and repetition rates up to 2 kHz. Note that the ES408C sensor for repetition rates up to 10 kHz, also available below, is not recommended for use with the PM100USB interface, which supports a maximum repetition rate of 3 kHz. Alternatively, other unamplified anode- or cathode-grounded photodiodes with up to 5 mA photocurrent, thermal elements with a maximum output voltage of 1 V, or energy sensors with voltage outputs from 100 mV to 100 V may be used.

This interface can be operated and powered by a PC via the mini-USB port. A readout rate of 300 samples per second allows active signal monitoring while the interface is in use.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037&pn=PM100USB,Thorlabspm 100 USB,615.0,['Power Meters'],These interfaces provide communication between an attached sensor and a PC or other external control unit. They are designed to be controlled via an external device or operated autonomously using the analog output; there are no controls or display screens.,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thorlabs/thorlabspm100usb.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/thorlabs/thorlabspm100usb.html,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782423/Instruments/Power%20Meters/PM100USB/PM100USB.jpg,PM100USB,Write a Python script that uses Pymeasure to connect to a PM100USB Power Meters,487.99,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class ThorlabsPM100USB(Instrument):
    """"""Represents Thorlabs PM100USB powermeter.""""""

    def __init__(self, adapter, name=""ThorlabsPM100USB powermeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        self._set_flags()

    wavelength_min = Instrument.measurement(
        ""SENS:CORR:WAV? MIN"", ""Measure minimum wavelength, in nm""
    )

    wavelength_max = Instrument.measurement(
        ""SENS:CORR:WAV? MAX"", ""Measure maximum wavelength, in nm""
    )

    @property
    def wavelength(self):
        """"""Control the wavelength in nm.""""""
        value = self.values(""SENSE:CORR:WAV?"")[0]
        return value

    @wavelength.setter
    def wavelength(self, value):
        """"""Wavelength in nm.""""""
        if self.wavelength_settable:
            # Store min and max wavelength to only request them once.
            if not hasattr(self, ""_wavelength_min""):
                self._wavelength_min = self.wavelength_min
            if not hasattr(self, ""_wavelength_max""):
                self._wavelength_max = self.wavelength_max

            value = truncated_range(
                value, [self._wavelength_min, self._wavelength_max]
            )
            self.write(f""SENSE:CORR:WAV {value}"")
        else:
            raise AttributeError(
                f""{self.sensor_name} does not allow setting the wavelength.""
            )

    @property
    def power(self):
        """"""Measure the power in W.""""""
        if self.is_power_sensor:
            return self.values(""MEAS:POW?"")[0]
        else:
            raise AttributeError(f""{self.sensor_name} is not a power sensor."")

    @property
    def energy(self):
        """"""Measure the energy in J.""""""
        if self.is_energy_sensor:
            return self.values(""MEAS:ENER?"")[0]
        else:
            raise AttributeError(
                f""{self.sensor_name} is not an energy sensor.""
            )

    def _set_flags(self):
        """"""Get sensor info and write flags.""""""
        response = self.values(""SYST:SENSOR:IDN?"")
        if response[0] == ""no sensor"":
            raise OSError(""No sensor connected."")
        self.sensor_name = response[0]
        self.sensor_sn = response[1]
        self.sensor_cal_msg = response[2]
        self.sensor_type = response[3]
        self.sensor_subtype = response[4]
        _flags_str = response[5]

        # interpretation of the flags, see p. 49 of the manual:
        # https://www.thorlabs.de/_sd.cfm?fileName=17654-D02.pdf&partNumber=PM100D

        # Convert to binary representation and pad zeros to 9 bit for sensors
        # where not all flags are present.
        _flags_str = format(int(_flags_str), ""09b"")
        # Reverse the order so it matches the flag order from the manual, i.e.
        # from decimal values from 1 to 256.
        _flags_str = _flags_str[::-1]

        # Convert to boolean.
        self.flags = [x == ""1"" for x in _flags_str]

        # setting the flags; _dn are unused; decimal values as comments
        (
            self.is_power_sensor,  # 1
            self.is_energy_sensor,  # 2
            _d4,  # 4
            _d8,  # 8
            self.response_settable,  # 16
            self.wavelength_settable,  # 32
            self.tau_settable,  # 64
            _d128,  # 128
            self.has_temperature_sensor,  # 256
        ) = self.flags
"
188,https://www.ameteksi.com/-/media/ameteksi/download_links/documentations/7270/model_7270.pdf,https://en.wikipedia.org/wiki/Lock-in_amplifier,"[OrderedDict([('id', 'attHoI3NQpJoD6CN6'), ('width', 450), ('height', 450), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GufrtaHmRH7H8pYoZdw46g/tNUeVrZrRwMHFDHh9T28sTL4y-ujNE0wNrWdRrdp5oXoMHquNKxu26-6MDoVxjsJGmeQvZGXOK13oNYfinPBtJZxlJpIowK4-I7ZZfGAg0kQXm4rp4lxzOyit8um3M9R/_2PdUiOPnDp6pBrcM_TcEr8pLmJ5XpW5f9C4E0N1P5E'), ('filename', 'Detection-synchrone-LockIn_7270.jpg'), ('size', 12509), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/4d3DTi5Ns7x-xBuVf3GJIA/DWeTZe-Nr83B3NFGGQFPBOQx9tkKafW11d1riTZY9fUE3DPvIZoBnJ1TLrQLbuYUTR5tiT5RvYBo5ynpxzf1rg/S1NUHxLe0doLAPmfM4nIkK0SFI_X7hGFZO8co8wDkS0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jfWv25VTsUaJSxjPJVXKTQ/Qvr91CYXQyDTsbb5gKQHNe2K5_2Oc_4_UEG7ma2c_P7b2iNJsmat9QzZB3LU7U8TLAFhjXPpL8t6usWKPul2CA/H7ZL2GVqqjL1dJhzVK_TGe9mu0AeNg2_E1X14OK49m8'), ('width', 450), ('height', 450)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cBad0usLfttHox4pygJbZw/yRnr-SaUxJCMfmgOn_sZa6YCSZWguHu2-r5AlYI5kS4bdixu1yikHNJmwIHGjuEnItp3xoadTk3Lg_TLRh6kTg/B25sl472gD2xdYA4k2HEyd2DTZT5qjVHgkZ-bUcfMjQ'), ('width', 3000), ('height', 3000)]))]))])]",6200.0,US,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125962/Instruments/Vendor%20Logos/Ametek.png,"The model 7270 sets a new standard for general-purpose DSP lock-in amplifiers.
",https://www.ameteksi.com/-/media/ameteksi/download_links/documentations/7270/model_7270.pdf,Ametek 7270,68.0,['Lockin Amplifiers'],A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment,"Since 1930, our talented and diverse workforce has been delivering **differentiated technology solutions** to create strong, sustainable and profitable growth.

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/ametek/ametek7270.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/ametek/ametek7270.html,Ametek,"[OrderedDict([('id', 'attRA8RkXtCHdQBNb'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/P1EEgAIIUcJqJK9tyWl05Q/K_CznFBe7cPafJy8h7Inx8-makxeMqBsMPyU6rNL3RMJhhfnRKVoIwkKYoazQyb8b9tFY56yveUjWPtmZL4U6Yi9TfN_KlQgiunbOtiZIwo/aSVzJqOEIGaKQL2RAtthcFQojdvJOOiD-5-hc0hpF9k'), ('filename', 'ametek-vector-logo.png'), ('size', 3631), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/4_t8QkZa3bEz1mvvzT8Yyw/aE7q3-h_G58LJO3xrpogQAH55nQWg5FP2Q4BcSKZ4kenRjvip4jIq8TFB1bkAHydmSmgUYXSGOUeYMxVq58otA/NkRbE973X8a7Dc1bw9zUi5SOX8TeYP3_YZAkqLusgzs'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vycyskJ5SGgaJ9xS7YEOzQ/F_CkGfaLcBtSyNgX5_Y_-SeONpOLyw10fpXmVyekFKJC47zHrazbLxdt1A5TjO_wxP0LXh-7HpVySZLNb2itUg/zL8lVWi6L1ckObTQsxDsFLF6ci6WJrb-r2QJ0c_OeEc'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/D3rRJ8610IkHaI2yRneAsA/luINcIg2uz92qBH-qKdaVBzrNbyc5mECeC_3B3jysE3_Fo0-wjI4Miu_ePlGi8W7fi_3fmzakwwLDbnAG-D_gA/wszdd0p2GxWbmZ2fpw9PnG4TJvOG0p8jW_ZHL3r9oRg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ametek.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782591/Instruments/Lockin%20Amplifiers/Ametek-7270/Ametek-7270.jpg,Ametek 7270,Write a Python script that uses Pymeasure to connect to a Ametek 7270 Lockin Amplifiers,,"
",,Not a real Script for Github,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import modular_range, truncated_discrete_set, truncated_range

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def check_read_not_empty(value):
    """"""Called by some properties to check if the reply is not an empty string
    that would mean the properties is currently invalid (probably because the reference mode
    is on single or dual)""""""
    if value == '':
        raise ValueError('Invalid response from measurement call, '
                         'probably because the reference mode is set on single or dual')
    else:
        return value


class Ametek7270(Instrument):
    """"""This is the class for the Ametek DSP 7270 lockin amplifier

    In this instrument, some measurements are defined only for specific modes,
    called Reference modes, see :meth:`set_reference_mode` and will raise errors
    if called incorrectly
    """"""

    SENSITIVITIES = [
        0.0, 2.0e-9, 5.0e-9, 10.0e-9, 20.0e-9, 50.0e-9, 100.0e-9,
        200.0e-9, 500.0e-9, 1.0e-6, 2.0e-6, 5.0e-6, 10.0e-6,
        20.0e-6, 50.0e-6, 100.0e-6, 200.0e-6, 500.0e-6, 1.0e-3,
        2.0e-3, 5.0e-3, 10.0e-3, 20.0e-3, 50.0e-3, 100.0e-3,
        200.0e-3, 500.0e-3, 1.0
    ]

    SENSITIVITIES_IMODE = {0: SENSITIVITIES,
                           1: [sen * 1e-6 for sen in SENSITIVITIES],
                           2: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2e-15, 5e-15, 10e-15,
                               20e-15, 50e-15, 100e-15, 200e-15, 500e-15, 1e-12, 2e-12]}

    TIME_CONSTANTS = [
        10.0e-6, 20.0e-6, 50.0e-6, 100.0e-6, 200.0e-6, 500.0e-6,
        1.0e-3, 2.0e-3, 5.0e-3, 10.0e-3, 20.0e-3, 50.0e-3, 100.0e-3,
        200.0e-3, 500.0e-3, 1.0, 2.0, 5.0, 10.0, 20.0, 50.0,
        100.0, 200.0, 500.0, 1.0e3, 2.0e3, 5.0e3, 10.0e3,
        20.0e3, 50.0e3, 100.0e3
    ]

    sensitivity = Instrument.control(  # NOTE: only for IMODE = 1.
        ""SEN"", ""SEN %d"",
        """""" A floating point property that controls the sensitivity
        range in Volts, which can take discrete values from 2 nV to
        1 V. This property can be set. """""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True,
        check_set_errors=True,
        dynamic=True,
    )

    slope = Instrument.control(
        ""SLOPE"", ""SLOPE %d"",
        """""" A integer property that controls the filter slope in
        dB/octave, which can take the values 6, 12, 18, or 24 dB/octave.
        This property can be set. """""",
        validator=truncated_discrete_set,
        values=[6, 12, 18, 24],
        map_values=True,
        check_set_errors=True,
    )

    time_constant = Instrument.control(  # NOTE: only for NOISEMODE = 0
        ""TC"", ""TC %d"",
        """""" A floating point property that controls the time constant
        in seconds, which takes values from 10 microseconds to 100,000
        seconds. This property can be set. """""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True,
        check_set_errors=True,
    )

    x = Instrument.measurement(""X."",
                               """""" Reads the X value in Volts """""",
                               get_process=check_read_not_empty,
                               )
    y = Instrument.measurement(""Y."",
                               """""" Reads the Y value in Volts """""",
                               get_process=check_read_not_empty,
                               )
    x1 = Instrument.measurement(""X1."",
                                """""" Reads the first harmonic X value in Volts """""",
                                get_process=check_read_not_empty,
                                )
    y1 = Instrument.measurement(""Y1."",
                                """""" Reads the first harmonic Y value in Volts """""",
                                get_process=check_read_not_empty,
                                )
    x2 = Instrument.measurement(""X2."",
                                """""" Reads the second harmonic X value in Volts """""",
                                get_process=check_read_not_empty,
                                )
    y2 = Instrument.measurement(""Y2."",
                                """""" Reads the second harmonic Y value in Volts """""",
                                get_process=check_read_not_empty,
                                )
    xy = Instrument.measurement(""XY."",
                                """""" Reads both the X and Y values in Volts """""",
                                get_process=check_read_not_empty,
                                )
    mag = Instrument.measurement(""MAG."",
                                 """""" Reads the magnitude in Volts """""",
                                 get_process=check_read_not_empty,
                                 )

    theta = Instrument.measurement(""PHA."",
                                   """""" Reads the signal phase in degrees """""",
                                   get_process=check_read_not_empty,
                                   )

    harmonic = Instrument.control(
        ""REFN"", ""REFN %d"",
        """""" An integer property that represents the reference
        harmonic mode control, taking values from 1 to 127.
        This property can be set. """""",
        validator=truncated_discrete_set,
        values=list(range(1, 128)),
        check_set_errors=True,
    )
    phase = Instrument.control(
        ""REFP."", ""REFP. %g"",
        """""" A floating point property that represents the reference
        harmonic phase in degrees. This property can be set. """""",
        validator=modular_range,
        values=[0, 360],
        check_set_errors=True,
    )
    voltage = Instrument.control(
        ""OA."", ""OA. %g"",
        """""" A floating point property that represents the voltage
        in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[0, 5],
        check_set_errors=True,
    )
    frequency = Instrument.control(
        ""OF."", ""OF. %g"",
        """""" A floating point property that represents the lock-in
        frequency in Hz. This property can be set. """""",
        validator=truncated_range,
        values=[0, 2.5e5],
        check_set_errors=True,
    )
    dac1 = Instrument.control(
        ""DAC. 1"", ""DAC. 1 %g"",
        """""" A floating point property that represents the output
        value on DAC1 in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[-10, 10],
        check_set_errors=True,
    )
    dac2 = Instrument.control(
        ""DAC. 2"", ""DAC. 2 %g"",
        """""" A floating point property that represents the output
        value on DAC2 in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[-10, 10],
        check_set_errors=True,
    )
    dac3 = Instrument.control(
        ""DAC. 3"", ""DAC. 3 %g"",
        """""" A floating point property that represents the output
        value on DAC3 in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[-10, 10],
        check_set_errors=True,
    )
    dac4 = Instrument.control(
        ""DAC. 4"", ""DAC. 4 %g"",
        """""" A floating point property that represents the output
        value on DAC4 in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[-10, 10],
        check_set_errors=True,
    )
    adc1 = Instrument.measurement(""ADC. 1"",
                                  """""" Reads the input value of ADC1 in Volts """""",
                                  get_process=check_read_not_empty,
                                  )
    adc2 = Instrument.measurement(""ADC. 2"",
                                  """""" Reads the input value of ADC2 in Volts """""",
                                  get_process=check_read_not_empty,
                                  )
    adc3 = Instrument.measurement(""ADC. 3"",
                                  """""" Reads the input value of ADC3 in Volts """""",
                                  get_process=check_read_not_empty,
                                  )
    adc4 = Instrument.measurement(""ADC. 4"",
                                  """""" Reads the input value of ADC4 in Volts """""",
                                  get_process=check_read_not_empty,
                                  )

    def __init__(self, adapter, name=""Ametek DSP 7270"",
                 read_termination='\x00',
                 write_termination='\x00',
                 **kwargs):

        super().__init__(
            adapter,
            name,
            read_termination=read_termination,
            write_termination=write_termination,
            **kwargs)

    def check_set_errors(self):
        """"""mandatory to be used for property setter

        The Ametek protocol expect the default null character to be read to check the property
        has been correctly set. With default termination character set as Null character,
        this turns out as an empty string to be read.
        """"""
        if self.read() == '':
            return []
        else:
            return ['Incorrect return from previously set property']

    def ask(self, command, query_delay=0):
        """"""Send a command and read the response, stripping white spaces.

        Usually the properties use the
        :meth:`~pymeasure.instruments.common_base.CommonBase.values`
        method that adds a strip call, however several methods use directly the result from ask to
        be cast into some other types. It should therefore also add the strip here, as all responses
        end with a newline character.
        """"""
        return super().ask(command, query_delay).strip()

    def set_reference_mode(self, mode: int = 0):
        """"""Set the instrument in Single, Dual or harmonic mode.

        :param mode: the integer specifying the mode: 0 for Single, 1 for Dual harmonic, and 2 for
            Dual reference.

        """"""
        if mode not in [0, 1, 2]:
            raise ValueError('Invalid reference mode')
        self.ask(f'REFMODE {mode}')

    def set_voltage_mode(self):
        """""" Sets instrument to voltage control mode """"""
        self.ask(""IMODE 0"")
        self.sensitivity_values = self.SENSITIVITIES_IMODE[0]

    def set_differential_mode(self, lineFiltering=True):
        """""" Sets instrument to differential mode -- assuming it is in voltage mode """"""
        self.ask(""VMODE 3"")
        self.ask(""LF %d 0"" % 3 if lineFiltering else 0)

    def set_current_mode(self, low_noise=False):
        """""" Sets instrument to current control mode with either low noise or high bandwidth""""""
        if low_noise:
            self.ask(""IMODE 2"")
            self.sensitivity_values = self.SENSITIVITIES_IMODE[2]
        else:
            self.ask(""IMODE 1"")
            self.sensitivity_values = self.SENSITIVITIES_IMODE[1]

    def set_channel_A_mode(self):
        """""" Sets instrument to channel A mode -- assuming it is in voltage mode """"""
        self.ask(""VMODE 1"")

    @property
    def id(self):
        """"""Get the instrument ID and firmware version""""""
        return f""{self.ask('ID')}/{self.ask('VER')}""

    @property
    def auto_gain(self):
        return int(self.ask(""AUTOMATIC"")) == 1

    @auto_gain.setter
    def auto_gain(self, setval):
        if setval:
            self.ask(""AUTOMATIC 1"")
        else:
            self.ask(""AUTOMATIC 0"")

    def shutdown(self):
        """""" Ensures the instrument in a safe state """"""
        log.info(""Shutting down %s"" % self.name)
        self.voltage = 0.
        super().shutdown()
"
194,https://rapid-tech.com.au/wp-content/uploads/2020/06/RS-FSL-Datasheet.pdf,https://en.wikipedia.org/wiki/Spectrum_analyzer,"[OrderedDict([('id', 'attgVn4mkgcYBvVCi'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0GCZRREpY_AGAHsFiqWBTw/7YjqX6jj9e_TRc7g-QObb2ulz1cZfS_nqOKRzUsZj3prhyrPttt2TW07u1q8GMBVoDxAwfFKyqLRrdFL0tuBg66mV6WF8rcX1n_VyCgoCLO_Ibs5XE640Iu37sHE3VyrcsHc0ZiH5phsKdQ0Q4aChbuO98W-oymb2wIGzs1WvfE/5yKaqSel3eCb05_tRnzTdGAJ3VRKkOJCNOjigsw-Jkg'), ('filename', 'fsl18-spectrum-analyzer-front-view-rohde-schwarz_200_1315_640_360_5.jpg'), ('size', 38239), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2vUf7ViO1PelnL0S11xcxQ/jG9z7V5FTETANfHaWzbg-AdkYKogzFGeU8jDyE3lvOyVjz382uz_T9W9cjQIBK-edEhYIQbBhTMaP8VfNDla6w/SEbmaIOmVT_PXUXSx7rOqMMvI-6MEwfIGRAtYbTEhmc'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DZEm0RkgG1tb52qK5CiVFw/4RFbn9fmuF9jjTk_bNPpd4OfCJL4Tnc7Fn2oE93K3vfR8kZSgxMnQX_MdO4J-94vi9jNL5MkTfwbHmahS9gC0A/XHxHAVk8rTx1ZsEaK1QHjuSLIJywyqFpAMqsKL_VY0M'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uFWIhjPPSCMQWpYLI-G4-A/1pq0abcRqfcYs5UqTWpZY0QWUPLMli4WLr8wE4-duOmmNHvc-2sNgZIom-19iA68uA79GROXEX8JfoUjOfCAuA/ZcLUQRwGXyA6YgUHmhiE8on6m5DykZFFHAlvjS8VVJQ'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692139604/Instruments/Vendor%20Logos/RohdeSchwarz.png,"The R&S FSL series Spectrum Analyzer – are a lightweight and compact range of spectrum analyzer for cost-conscious users who want the functionality of high-end instruments.

These analyzers are ideal for a large number of applications in development, service and production.",https://rapid-tech.com.au/rs-fsl-spectrum-analyzer-9-khz-to-3-ghz-6-ghz-or-18-ghz/,FSL,471.0,['Spectrum Analyzers'],"A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals. The input signal that most common spectrum analyzers measure is electrical; however, spectral compositions of other signals, such as acoustic pressure waves and optical light waves, can be considered through the use of an appropriate transducer. Spectrum analyzers for other types of signals also exist, such as optical spectrum analyzers which use direct optical techniques such as a monochromator to make measurements.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/fsl.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/fsl.html,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CpS01u_OTWzigpyIX294cA/EX_5PJyYktFu5Al55zSNyjcXLtJsFmmbuTlCPJIP440S20z80VXEZOU8y3TwjyfvjAr8kh0xDb-A3ZuBQd2qNDvw8gY7f0gUO5tuGNvudjQ/VX48XpjO9xisV9e4b9OqW21lZJ4bIlUErS1hzs8d_CE'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MyefG5SLCFh4IVEyVyhAUA/w_qFkuwLUw26XSJsiflkFgNM4soFUFffkWc0MpKgId0Ana-PViShd1ra1Uw7P9esiM7qPsjWn1oUBP8woOUC5w/ZIPgySMN9PXcVEezUO0mvcUtvLfX6IV8ce8CautxXH4'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pxbHby4ijBkZ-MCbLaMYdg/daQthpa_MxbepZl99pXfKmWFoDVTQK3jm2CQ9Xo4rg3yCJDoSROaJzceaP2pmWlC0nRtV0t0v-TqL2XBA1u44g/0--RegDQKIvXD1tEHXkOcQX5OFePHgzhz00XmVw9fNs'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vqjISP7Yaeb9FU33xwX-8Q/yhoGrCY_Tmtyu3_wVlw59C6mVxdARdPYKdFsole1IGdCIf6FwQzHjiHT5PMCqRqnKZMm42wR_rjv_-OnaBdO6w/RO9AJA_e6QpEEeiVOUEpQSAWLkvDws_NZeyv2PiqkVY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782599/Instruments/Spectrum%20Analyzers/FSL/FSL.jpg,FSL,Write a Python script that uses Pymeasure to connect to a FSL Spectrum Analyzers,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

import numpy as np
from pymeasure.instruments.validators import strict_discrete_set
from pymeasure.instruments import Instrument

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def _number_or_auto(value):
    # helper for the bandwidth setting
    if isinstance(value, str) and value.upper() == ""AUTO"":
        return "":AUTO ON""
    else:
        # There is no space in the set commands, so we have to add it
        return "" "" + str(value)


class FSL(Instrument):
    """"""
    Represents a Rohde&Schwarz FSL spectrum analyzer.

    All physical values that can be set can either be as a string of a value
    and a unit (e.g. ""1.2 GHz"") or as a float value in the base units (Hz,
    dBm, etc.).
    """"""

    def __init__(self, adapter, name=""Rohde&Schwarz FSL"", **kwargs):
        super().__init__(
            adapter, name, includeSCPI=True, **kwargs
        )

    # Frequency settings ------------------------------------------------------

    freq_span = Instrument.control(
        ""FREQ:SPAN?"",
        ""FREQ:SPAN %s"",
        ""Frequency span in Hz."",
    )

    freq_center = Instrument.control(
        ""FREQ:CENT?"",
        ""FREQ:CENT %s"",
        ""Center frequency in Hz."",
    )

    freq_start = Instrument.control(
        ""FREQ:STAR?"",
        ""FREQ:STAR %s"",
        ""Start frequency in Hz."",
    )

    freq_stop = Instrument.control(
        ""FREQ:STOP?"",
        ""FREQ:STOP %s"",
        ""Stop frequency in Hz."",
    )

    attenuation = Instrument.control(
        ""INP:ATT?"",
        ""INP:ATT %s"",
        ""Attenuation in dB."",
    )

    res_bandwidth = Instrument.control(
        ""BAND:RES?"",
        # There is no space between RES and %s on purpose, see _number_or_auto.
        ""BAND:RES%s"",
        ""Resolution bandwidth in Hz. Can be set to 'AUTO'"",
        set_process=_number_or_auto,
    )

    video_bandwidth = Instrument.control(
        ""BAND:VID?"",
        ""BAND:VID%s"",
        ""Video bandwidth in Hz. Can be set to 'AUTO'"",
        set_process=_number_or_auto,
    )

    # Sweeping ----------------------------------------------------------------

    sweep_time = Instrument.control(
        ""SWE:TIME?"",
        # No space between TIME and %s on purpose, see _number_or_auto.
        ""SWE:TIME%s"",
        ""Sweep time in s. Can be set to 'AUTO'."",
        set_process=_number_or_auto,
    )

    continuous_sweep = Instrument.control(
        ""INIT:CONT?"",
        ""INIT:CONT %s"",
        ""Continuous (True) or single sweep (False)"",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    def single_sweep(self):
        """"""Perform a single sweep with synchronization.""""""
        self.write(""INIT; *WAI"")

    def continue_single_sweep(self):
        """"""Continue with single sweep with synchronization.""""""
        self.write(""INIT:CONM; *WAI"")

    # Traces ------------------------------------------------------------------

    def read_trace(self, n_trace=1):
        """"""
        Read trace data.

        :param n_trace: The trace number (1-6). Default is 1.
        :return: 2d numpy array of the trace data, [[frequency], [amplitude]].
        """"""
        y = np.array(self.values(f""TRAC{n_trace}? TRACE{n_trace}""))
        x = np.linspace(self.freq_start, self.freq_stop, len(y))
        return np.array([x, y])

    trace_mode = Instrument.control(
        ""DISP:TRAC:MODE?"",
        ""DISP:TRAC:MODE %s"",
        ""Trace mode ('WRIT', 'MAXH', 'MINH', 'AVER' or 'VIEW')"",
        validator=strict_discrete_set,
        values=[""WRIT"", ""MAXH"", ""MINH"", ""AVER"", ""VIEW""],
    )

    # Markers -----------------------------------------------------------------

    def create_marker(self, num=1, is_delta_marker=False):
        """"""
        Create a marker.

        :param num: The marker number (1-4)
        :param is_delta_marker: True if the marker is a delta marker, default
            is False.
        :return: The marker object.
        """"""
        return self.Marker(self, num, is_delta_marker)

    class Marker:
        def __init__(self, instrument, num, is_delta_marker):
            """"""
            Marker and Delta Marker class.

            :param instrument: The FSL instrument.
            :param num: The marker number (1-4)
            :param is_delta_marker: True if the marker is a delta marker,
                defaults to False.
            """"""
            self.instrument = instrument
            self.is_delta_marker = is_delta_marker
            # Building the marker name for the commands.
            if self.is_delta_marker:
                # Smallest delta marker number is 2.
                self.name = ""DELT"" + str(max(2, num))
            else:
                self.name = ""MARK""
                if num > 1:
                    # Marker 1 doesn't get a number.
                    self.name = self.name + str(num)

            self.activate()

        def read(self):
            return self.instrument.read()

        def write(self, command):
            self.instrument.write(f""CALC:{self.name}:{command}"")

        def ask(self, command):
            return self.instrument.ask(f""CALC:{self.name}:{command}"")

        def values(self, command, **kwargs):
            """"""
            Reads a set of values from the instrument through the adapter,
            passing on any keyword arguments.
            """"""
            return self.instrument.values(
                f""CALC:{self.name}:{command}"", **kwargs
            )

        def activate(self):
            """"""Activate a marker.""""""
            self.write(""STAT ON"")

        def disable(self):
            """"""Disable a marker.""""""
            self.write(""STAT OFF"")

        x = Instrument.control(
            ""X?"", ""X %s"", ""Position of marker on the frequency axis in Hz.""
        )

        y = Instrument.control(
            ""Y?"", ""Y %s"", ""Amplitude of the marker position in dBm.""
        )

        peak_excursion = Instrument.control(
            ""PEXC?"",
            ""PEXC %s"",
            ""Peak excursion in dB."",
        )

        def to_trace(self, n_trace=1):
            """"""
            Set marker to trace.

            :param n_trace: The trace number (1-6). Default is 1.
            """"""
            self.write(f""TRAC {n_trace}"")

        def to_peak(self):
            """"""Set marker to highest peak within the span.""""""
            self.write(""MAX"")

        def to_next_peak(self, direction=""right""):
            """"""
            Set marker to next peak.

            :param direction: Direction of the next peak ('left' or 'right' of
                the current position).
            """"""
            self.write(f""MAX:{direction}"")

        def zoom(self, value):
            """"""
            Zoom in to a frequency span or by a factor.

            :param value: The value to zoom in by. If a number is passed it is
                interpreted as a factor. If a string (number with unit) is
                passed it is interpreted as a frequency span.
            """"""
            self.write(f""FUNC:ZOOM {value}; *WAI"")
"
205,,"https://www.sciencedirect.com/topics/engineering/motor-controller#:~:text=Motor%20controllers-,Motor%20controllers%20are%20devices%20which%20regulate%20the%20operation%20of%20an,operation%20of%20the%20prime%20mover.","[OrderedDict([('id', 'att0XPLyyoO06Sc3u'), ('width', 2106), ('height', 1032), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qMWOtdQR6Gqs8zTXF7eFDQ/4u5JLsotMFt0KbeNRm_6PmyGmAgmrJ7dK3mRLtMXNdz_Sgyohj_9RelTJKSUtw2z661omUURGk_6GHBakJD__WIOSaNyUOImVu4PjaFWSNs/zsapxvcDdErrfOuW3X3VfuOzn5zvcP09tuO-jshv3_A'), ('filename', 'anaheim-controllers.png'), ('size', 3166220), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jLbLk3wspSUEYIGgqCBgOw/ZpHA6XhQpuWER86ynhTDHeJN2_duGkpbWL16N24ZJdfpetgABdkKHAX6b9m8IHZ4oIlVo16hiyQyFrZI93bUNw/zJarzJVLGX7XDsbbuIUDbhS2UcwJd-MpiqrkgPX5afs'), ('width', 73), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FPcibTJf6s63fUMikCcrpg/F48WTtyRa4C5fdPwbpY_GyTiLXcJWdDRIyPlG585krYxp6g8izkZfx0fgf5r4WmkcbbJ-kvVi6qpwqnI6VlJPA/v5iH3oUM3rrxnotkxtGZxA_aBwNiDFdaUDYkd1G39FQ'), ('width', 1045), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-RBiyWO0qS2mCneEXEfi2Q/AufWx9WHTaiLfEdnITjbTqta-lVKTG-mB2DsTOYG1WiImHfTlsOJTezS4Wxx25vb_ucvix8o7nzMGyYYxuvSiw/HfnJwZs9P-Az68wUusO_2Ni1a80Dg7s7G32Em4nx_LM'), ('width', 3000), ('height', 3000)]))]))])]",,"Anaheim, US",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125991/Instruments/Vendor%20Logos/Anaheim_Automation.png,"Anaheim Automation manufactures a variety of Stepper Motor Driver Packs with Programmable Controllers. The DPC50501 contains a single-axis bipolar microstep driver with an output capacity of 0.5 to 5 Amps, and incorporates a simple 18-command programmable controller, with a power supply in an enclosure. Models DPY50601 and DPY50611 each contain a single-axis bipolar microstep driver with an output capacity of 0.5 to 5 Amps, and a 40-command programmable controller, packaged with a power supply in an enclosure. The DPD75601 contains a single-axis bilevel driver with an output capacity of 1 to 7 Amps, and a 40-command programmable controller, with a power supply packaged in an enclosure.",https://www.anaheimautomation.com/products/stepper/stepper-drivers-controllers.php?tID=135&pt=t&cID=49,Dpseriesmotorcontroller,73.0,['Motor Controller'],"Motor controllers are devices which regulate the operation of an electric motor. In artificial lift applications, motor controllers generally refer to those devices used in conjunction with switchboards or VFDs to control the operation of the prime mover.",,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anaheimautomation/dpseriesmotorcontroller.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/anaheimautomation/dpseriesstepmotorcontroller.html,Anaheim Automation,"[OrderedDict([('id', 'attqpxWgFobqeBjjF'), ('width', 3600), ('height', 1281), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/JMMvlB2Wy9KkEO7TVOLRPw/Fa2X_ah-Pater9V7X2kAfBCAi0LWFv_VtZZbLIPslg7hblCpP5a1B3K2f5xLdPJOMh44wRyTVZlSyaTCmTToLBRJARnWr-r9oyzGwxDv_1TrCIuE85VfJDw5VmXEFPBA/GT9CmmB3sO0tfaeCG9MF9ire32W6WJAybGsiPhdL4Xc'), ('filename', 'AA Logo - Transparent New AA Blue (3600x1281).png'), ('size', 164761), ('type', 'image/png')])]",https://www.anaheimautomation.com/?gclid=Cj0KCQjwib2mBhDWARIsAPZUn_m78imRVeC4iew-ALEMOH2ABgkCznvLz8KJ7IP3DU4ltd1my9bdZrgaAo0jEALw_wcB,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782609/Instruments/Motor%20Controller/DP-Series-Motor-Controller/DP-Series-Motor-Controller.png,DP Series Motor Controller,Write a Python script that uses Pymeasure to connect to a DP Series Motor Controller Motor Controller,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from time import sleep
from enum import IntFlag
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range, truncated_range, strict_discrete_set


log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class DPSeriesErrors(IntFlag):
    """""" IntFlag type to decode error register queries. Error codes are as follows:

        0: no error
        1: Receive Overflow Error: serial communications had a receiving error.
        2: Encoder Error 1: encoder needed to correct the motor position.
        4: Encoder Error 2: encoder could not finish motor position correction.
        8: Command Error: a bad command was sent to the controller.
        16: Motor Error: motor speed profiles are set incorrectly.
        32: Range Overflow Error: go to position has an overflow error.
        64: Range Error: invalid number of commands and characters sent to the controller.
        128: Transmit Error: Too many parameters sent back to the pc.
        256: Mode Error: Controller is in a wrong mode.
        512: Zero Parameters Error: Command sent to the controller that expected to see
                                    parameters follow, but none were given.
        1024: Busy Error: The controller is busy indexing (moving a motor).
        2048: Memory Range Error: Specified address is out of range.
        4096: Memory Command Error: Command pulled from memory is invalid.
        8192: Thumbwheel Read Error: Error reading the thumbwheel, or thumbwheel is not present.
    """"""
    NO_ERR = 0
    RCV_OVERFLOW_ERR = 1
    ENC_ERR_1 = 2
    ENC_ERR_2 = 4
    CMD_ERR = 8
    MOT_ERR = 16
    RANGE_OVERFLOW_ERR = 32
    RANGE_ERR = 64
    TX_ERR = 128
    MODE_ERR = 256
    ZERO_PARAMS_ERR = 512
    BUSY_ERR = 1024
    MEM_RANGE_ERR = 2048
    MEM_CMD_ERR = 4096
    THBWHEEL_ERR = 8192


class DPSeriesMotorController(Instrument):
    """"""Base class to interface with Anaheim Automation DP series stepper motor controllers.

    This driver has been tested with the DPY50601 and DPE25601 motor controllers.
    """"""

    address = Instrument.control(
        ""%"", ""~%i"",
        """"""Integer property representing the address that the motor controller uses for serial
        communications."""""",
        validator=strict_range,
        values=[0, 99],
        cast=int,
    )

    basespeed = Instrument.control(
        ""VB"", ""B%i"",
        """"""Integer property that represents the motor controller's starting/homing speed. This
        property can be set."""""",
        validator=truncated_range,
        values=[1, 5000],
        cast=int,
    )

    maxspeed = Instrument.control(
        ""VM"", ""M%i"",
        """"""Integer property that represents the motor controller's maximum (running) speed.
        This property can be set."""""",
        validator=truncated_range,
        values=[1, 50000],
        cast=int,
    )

    direction = Instrument.control(
        ""V+"", ""%s"",
        """"""A string property that represents the direction in which the stepper motor will rotate
        upon subsequent step commands. This property can be set. 'CW' corresponds to clockwise
        rotation and 'CCW' corresponds to counter-clockwise rotation."""""",
        map_values=True,
        validator=strict_discrete_set,
        values={""CW"": ""+"", ""CCW"": ""-""},
        get_process=lambda d: ""+"" if d == 1.0 else ""-"",
    )

    encoder_autocorrect = Instrument.control(
        ""VEA"", ""EA%i"",
        """"""A boolean property to enable or disable the encoder auto correct function. This property
        can be set."""""",
        map_values=True,
        values={True: 1, False: 0},
        validator=strict_discrete_set,
        cast=int,
    )

    encoder_delay = Instrument.control(
        ""VED"", ""ED%i"",
        """"""An integer property that represents the wait time in ms. after a move is finished before
        the encoder is read for a potential encoder auto-correct action to take place. This
        property can be set."""""",
        validator=truncated_range,
        values=[0, 65535],
        cast=int,
    )

    encoder_motor_ratio = Instrument.control(
        ""VEM"", ""EM%i"",
        """"""An integer property that represents the ratio of the number of encoder pulses per motor
        step. This property can be set."""""",
        validator=truncated_range,
        values=[1, 255],
        cast=int,
    )

    encoder_retries = Instrument.control(
        ""VER"", ""ER%i"",
        """"""An integer property that represents the number of times the motor controller will try the
        encoder auto correct function before setting an error flag. This property can be set."""""",
        validator=truncated_range,
        values=[0, 255],
        cast=int,
    )

    encoder_window = Instrument.control(
        ""VEW"", ""EW%i"",
        """"""An integer property that represents the allowable error in encoder pulses from the
        desired position before the encoder auto-correct function runs. This property can be set.
        """""",
        validator=truncated_range,
        values=[0, 255],
        cast=int,
    )

    busy = Instrument.measurement(
        ""VF"",
        """"""Query to see if the controller is currently moving a motor.""""""
    )

    error_reg = Instrument.measurement(
        ""!"",
        """"""Reads the current value of the error codes register."""""",
        get_process=lambda err: DPSeriesErrors(int(err)),
    )

    def check_errors(self):
        """""" Method to read the error codes register and log when an error is detected.

        :return error_code: one byte with the error codes register contents
        """"""
        current_errors = self.error_reg
        if current_errors != 0:
            logging.error(""DP-Series motor controller error detected: %s"" % current_errors)
        return current_errors

    def __init__(self, adapter, name=""Anaheim Automation Stepper Motor Controller"",
                 address=0, encoder_enabled=False, **kwargs):
        """"""
        Initialize communication with the motor controller with the address given by `address`.

        In addition to the keyword arguments that can be set for the Instrument base class, this
        class has the following kwargs:

        :param address: (int) Address that the motor controller uses for serial communiation.
        :param encoder_enabled: (bool) Flag to indicate if the driver should use an encoder input
            to set its position property.
        """"""
        self._address = address
        self._encoder_enabled = encoder_enabled
        kwargs.setdefault('write_termination', '\r')
        kwargs.setdefault('read_termination', '\r')
        kwargs.setdefault('timeout', 2000)

        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            asrl={'baud_rate': 38400},
            **kwargs
        )

    @property
    def encoder_enabled(self):
        """""" A boolean property to represent whether an external encoder is connected and should be
        used to set the :attr:`step_position` property.
        """"""
        return self._encoder_enabled

    @encoder_enabled.setter
    def encoder_enabled(self, en):
        self._encoder_enabled = bool(en)

    @property
    def step_position(self):
        """""" Integer property representing the value of the motor position measured in steps counted
        by the motor controller or, if :attr:`encoder_enabled` is set, the steps counted by an
        externally connected encoder. Note that in the DP series motor controller instrument
        manuals, this property would be referred to as the 'absolute position' while this
        driver implements a conversion between steps and absolute units for the
        :attr:`absolute_position` property. This property can be set.
        """"""
        if self._encoder_enabled:
            pos = self.ask(""VEP"")
        else:
            pos = self.ask(""VZ"")
        return int(pos)

    @step_position.setter
    def step_position(self, pos):
        strict_range(pos, (-8388607, 8388607))
        self.write(""P%i"" % pos)
        self.write(""G"")

    @property
    def absolute_position(self):
        """""" Float property representing the value of the motor position measured in absolute units.
        Note that in DP series motor controller instrument manuals, 'absolute position' refers to
        the :attr:`step_position` property rather than this property. Also note that use of this
        property relies on :meth:`steps_to_absolute()` and :meth:`absolute_to_steps()`
        being implemented in a subclass. In this way, the user can define the conversion from a
        motor step position into any desired absolute unit. Absolute units could be the position in
        meters of a linear stage or the angular position of a gimbal mount, etc. This property can
        be set.
        """"""
        step_pos = self.step_position
        return self.steps_to_absolute(step_pos)

    @absolute_position.setter
    def absolute_position(self, abs_pos):
        steps_pos = self.absolute_to_steps(abs_pos)
        self.step_position = steps_pos

    def absolute_to_steps(self, pos):
        """""" Convert an absolute position to a number of steps to move. This must be implemented in
        subclasses.

        :param pos: Absolute position in the units determined by the subclassed
               :meth:`absolute_to_steps()` method.
        """"""
        raise NotImplementedError(""absolute_to_steps() must be implemented in subclasses!"")

    def steps_to_absolute(self, steps):
        """""" Convert a position measured in steps to an absolute position.

        :param steps: Position in steps to be converted to an absolute position.
        """"""
        raise NotImplementedError(""steps_to_absolute() must be implemented in subclasses!"")

    def reset_position(self):
        """"""
        Reset position as counted by the motor controller and an externally connected encoder to 0.
        """"""
        # reset encoder recorded position #
        self.write(""ET"")
        # reset motor recorded position #
        self.write(""Z0"")

    def stop(self):
        """"""Method that stops all motion on the motor controller.""""""
        self.write(""."")

    def move(self, direction):
        """""" Move the stepper motor continuously in the given direction until a stop command is sent
        or a limit switch is reached. This method corresponds to the 'slew' command in the DP
        series instrument manuals.

        :param direction: value to set on the direction property before moving the motor.
        """"""
        self.direction = direction
        self.write(""S"")

    def home(self, home_mode):
        """""" Send command to the motor controller to 'home' the motor.

        :param home_mode: ``0`` or ``1`` specifying which homing mode to run.

            0 will perform a homing operation where the controller moves the motor until a soft
            limit is reached, then will ramp down to base speed and continue motion until a home
            limit is reached.

            In mode 1, the controller will move the motor until a limit is reached, then will ramp
            down to base speed, change direction, and run until the limit is released.
        """"""
        hm = int(home_mode)
        if hm == 0 or hm == 1:
            self.write(""H%i"" % hm)
        else:
            raise ValueError(""Invalid home mode %i specified!"" % hm)

    def write(self, command):
        """"""Override the instrument base write method to add the motor controller's address to the
        command string.

        :param command: command string to be sent to the motor controller.
        """"""
        # check if @ was already prepended when using say, the SerialAdapter #
        if ""@"" in command:
            cmd_str = command
        elif ""%"" in command or ""~"" in command:
            cmd_str = ""@%s"" % command
        else:
            cmd_str = ""@%i%s"" % (self._address, command)
        super().write(cmd_str)

    def wait_for_completion(self, interval=0.5):
        """""" Block until the controller is not ""busy"" (i.e. block until the motor is no longer moving.)

        :param interval: (float) seconds between queries to the ""busy"" flag.
        :return: None
        """"""  # noqa: E501
        while self.busy:
            sleep(interval)
"
207,https://www.toptica.com/fileadmin/Editors_English/11_brochures_datasheets/01_brochures/toptica_BR_iBeam_smart_family.pdf,https://en.wikipedia.org/wiki/Laser_diode,"[OrderedDict([('id', 'attTnJTuWKGQlwm5Y'), ('width', 1200), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VfCEazTDMd1ALm31JAQyPg/UcwRb9RWrAV48F0VPvNjcvwrwZ1OW-pU6HTrnL0CxzZpzxG51Et6Lg5yEmDPfmxDYZi2zAdJqGA_8ScQt9h_gD4shdjgm1s0cz9WA5_vEuq_Abaca2njUPcooPMsGiI2kHkEJY1WZLWY-n7QyBpH1Q/7UDFeszzkqv29CMc9AKbF_cWPgE2UeYkqwCIua-SwRM'), ('filename', 'toptica_ibeam_smart_3_colors_1200x350_b.jpg'), ('size', 161267), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qj726TQPGBFxhTWPU3w9oA/TEV-r_jkfYY6kAMmdV1Ebp_6ZR7-zXcPnvkxM11M1caMDkZ5h6WUfrQiaALrvfbuWG9spQ5r7uUT1iwFbp0KrA/LcZSkWPl1Rciv9a0V2kOhPXdUvs5RIv91q9aijLTZSc'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Zf359Bi0JTZSlUhLvtpeNw/WeUSnA7eDp-n7zPzPDU26fMfstEwUwwbC66jGhRgeSWQKi0P4ArlhCxn1TC50kna9rmyV3cfpXaOFKBDSBCw6Q/4MSFP_UB3RNVatFFvNC5S-Z5m89FrH7P0JLRrxJgodI'), ('width', 1200), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/UpAoIMen2tCZQF3wPVhw1Q/B7i_vx_4vVl7JwlY3Iy0tlVzfuN50KQcpLbRxY50Z90CxnYoogbvFpZf0Od0CoeJQbKbraTOoA1Vyvl-HyV4xA/8QHZ8wKBtrdynXNROwQfGyf3pEy6v97NpLOKDPqSKC0'), ('width', 3000), ('height', 3000)]))]))])]",75.0,Germany,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125974/Instruments/Vendor%20Logos/Toptica.png,"The iBeam smart is the ultimate choice when looking for a high-performance, ultra-reliable OEM single mode diode laser system. Record values at output power, combined with excellent power and beam pointing stability are setting the standard in the class of compact diode lasers. Its flexible, µ-processor based electronics will make system integration a snap. Features as FINE, SKILL and AUTOPULSE are capable to solve common problems of your application.",https://www.toptica.com/products/single-mode-diode-lasers/ibeam-smart,Ibeamsmart,624.0,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction","TOPTICA Photonics is a manufacturer of [lasers](https://en.wikipedia.org/wiki/Laser) for quantum technologies, biophotonics and material inspection
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/toptica/ibeamsmart.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/toptica/ibeamsmart.html,Toptica,"[OrderedDict([('id', 'attdPu3r6YQ3XuoNe'), ('width', 469), ('height', 107), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TeQgYrDvE5mLqia6IJsurg/7zvIiAICYJhM9loo-_SvZEQSb-0jk1xp5wA1Fp37JLLL8MsILzlizzTued7SlqqxoejiZtY_VrHxhr4bXaxDlBdo85NilbLMAkKWgyo97TI/9V4G3Bg1P3ECsdKSzVK3lGTwjYMfAZ-p6rS9JOixX6Q'), ('filename', 'download.png'), ('size', 4105), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PhGBRWF-WfMypvv-VsWTDw/QmSRGhgQKXHg7creAi1wQHIBhyVsACwIDY5MJiqYRrGejneAEvMkUKwQR2TdVgJWq1ziYBZrm5Lb8ynNv3yeyg/bBiW0hNOoJiZDynQdxSlEil1I2e0RIhULCBv1q74-M8'), ('width', 158), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3_ZsOFGT0BWiy9uxloMNWQ/pMOJeqYLqs1ydyrE9W2GgRivW1Lw_Azb-kNbBQttjI0vVLPKkXnsdYlFRTjJBrMP0qPrBJybxYNar5dKB2T5MA/_NAf6c2MXOilFUL1lzJJ_1e8CBIK4lmrehK14xkVt_0'), ('width', 469), ('height', 107)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qfs4hpFhRCybbwHsJNBRfg/VRl3tGj2PssadCmzClw0Sj-FayUMxwKPT7Fl-NXV2OBOGD0S0YI_Oyf3XEOWbAwcqmjq2w5QqVQWJ_WTQLPcAA/63bwfMF2UwLL7QvwD0SzxQXottc22FQdWc7RNkAUNuQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782611/Instruments/Lasers/iBeam-smart/iBeam-smart.jpg,iBeam smart,Write a Python script that uses Pymeasure to connect to a iBeam smart Lasers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import re
import time
from warnings import warn

from pyvisa.errors import VisaIOError

from pymeasure.instruments import Channel, Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def _deprecation_warning(text):
    def func(x):
        warn(text, FutureWarning)
        return x

    return func


def _deprecation_warning_channels(property_name):
    def func(x):
        warn(f'Deprecated property name ""{property_name}"", use the channels '
             '""enabled"" property instead.', FutureWarning)
        return x

    return func


def deprecated_strict_discrete_set(value, values):
    warn(""This property is deprecated, use channels instead."", FutureWarning)
    return strict_discrete_set(value, values)


class DriverChannel(Channel):
    """"""A laser diode driver channel for the IBeam Smart laser.""""""

    power = Channel.setting(
        ""ch {ch} pow %f mic"",
        """"""Set the output power in µW (float up to 200000)."""""",
        check_set_errors=True,
        validator=strict_range,
        values=[0, 200000],
    )

    enabled = Channel.control(
        ""sta ch {ch}"",
        ""%s {ch}"",
        """"""Control the enabled state of the driver channel."""""",
        validator=strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en"" if v else ""di"",
        check_set_errors=True,
    )


class IBeamSmart(Instrument):
    """""" IBeam Smart laser diode

    For the usage of the different diode driver channels, see the manual

    .. code::

        laser = IBeamSmart(""SomeResourceString"")
        laser.emission = True
        laser.ch_2.power = 1000  # µW
        laser.ch_2.enabled = True
        laser.shutdown()

    :param adapter: pyvisa resource name or adapter instance.
    :param baud_rate: The baud rate you have set in the instrument.
    :param \\**kwargs: Any valid key-word argument for VISAAdapter.
    """"""
    _reg_value = re.compile(r""\w+\s+=\s+(\w+)"")

    ch_1 = Instrument.ChannelCreator(DriverChannel, 1)

    ch_2 = Instrument.ChannelCreator(DriverChannel, 2)

    ch_3 = Instrument.ChannelCreator(DriverChannel, 3)

    ch_4 = Instrument.ChannelCreator(DriverChannel, 4)

    ch_5 = Instrument.ChannelCreator(DriverChannel, 5)

    def __init__(self, adapter, name=""Toptica IBeam Smart laser diode"",
                 baud_rate=115200,
                 **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            read_termination='\r\n',
            write_termination='\r\n',
            asrl={'baud_rate', baud_rate},
            **kwargs
        )
        # configure communication mode: no repeating and no command prompt
        self.write('echo off')
        self.write('prom off')
        time.sleep(0.04)
        # clear the initial messages from the controller
        try:
            self.adapter.flush_read_buffer()
        except AttributeError:
            log.warning(""Adapter does not have 'flush_read_buffer' method."")
        self.ask('talk usual')

    def read(self):
        """"""Read a reply of the instrument and extract the values, if possible.

        Reads a reply of the instrument which consists of at least two
        lines. The initial ones are the reply to the command while the last one
        should be '[OK]' which acknowledges that the device is ready to receive
        more commands.

        Note: '[OK]' is always returned as last message even in case of an
        invalid command, where a message indicating the error is returned
        before the '[OK]'

        Value extraction: extract <value> from 'name = <value> [unit]'.
        If <value> can not be identified the orignal string is returned.

        :return: string containing the ASCII response of the instrument (without '[OK]').
        """"""
        reply = super().read()  # read back the LF+CR which is always sent back
        if reply != """":
            raise ValueError(
                f""Error, no empty line at begin of message, instead '{reply}'"")
        msg = []
        try:
            while True:
                line = super().read()
                if line == '[OK]':
                    break
                msg.append(line)
        except VisaIOError:
            reply = '\n'.join(msg)
            try:
                self.adapter.connection.flush_read_buffer()
            except AttributeError:
                log.warning(""Adapter does not have 'flush_read_buffer' method."")
            raise ValueError(f""Flush buffer failed after '{reply}'"")
        reply = '\n'.join(msg)
        r = self._reg_value.search(reply)
        if r:
            return r.groups()[0]
        else:
            return reply

    def check_set_errors(self):
        """"""Check for errors after having gotten a property and log them.

        Checks if the last reply is only '[OK]', otherwise a ValueError is
        raised and the read buffer is flushed because one has to assume that
        some communication is out of sync.
        """"""
        reply = self.read()
        if reply:
            # anything else than '[OK]'.
            self.adapter.connection.flush_read_buffer()
            log.error(f""Setting a property failed with reply '{reply}'."")
            raise ValueError(f""Setting a property failed with reply '{reply}'."")
        return []

    version = Instrument.measurement(
        ""ver"", """"""Get Firmware version number."""""",
    )

    serial = Instrument.measurement(
        ""serial"", """"""Get Serial number of the laser system."""""",
    )

    temp = Instrument.measurement(
        ""sh temp"",
        """"""Measure the temperature of the laser diode in degree centigrade."""""",
    )

    system_temp = Instrument.measurement(
        ""sh temp sys"",
        """"""Measure base plate (heatsink) temperature in degree centigrade."""""",
    )

    current = Instrument.measurement(
        ""sh cur"",
        """"""Measure the laser diode current in mA."""""",
    )

    emission = Instrument.control(
        ""sta la"", ""la %s"",
        """"""Control emission status of the laser diode driver (bool)."""""",
        validator=strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""on"" if v else ""off"",
        check_set_errors=True,
    )

    laser_enabled = Instrument.control(
        ""sta la"", ""la %s"",
        """"""Control emission status of the laser diode driver (bool).

        .. deprecated:: 0.12 Use attr:`emission` instead.
        """""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""on"" if v else ""off"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning(
            ""Property `laser_enabled` is deprecated, use `emission` instead.""),
    )

    channel1_enabled = Instrument.control(
        ""sta ch 1"", ""%s"",
        """"""Control status of Channel 1 of the laser (bool).

        .. deprecated:: 0.12 Use :attr:`ch_1.enabled` instead.
        """""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en 1"" if v else ""di 1"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning_channels(""channel1_enabled""),
    )

    channel2_enabled = Instrument.control(
        ""sta ch 2"", ""%s"",
        """"""Control status of Channel 2 of the laser (bool).

        .. deprecated:: 0.12 Use :attr:`ch_2.enabled` instead."""""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en 2"" if v else ""di 2"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning_channels(""channel2_enabled""),
    )

    power = Instrument.control(
        ""sh pow"", ""ch pow %f mic"",
        """"""Control actual output power in µW of the laser system. In pulse mode
        this means that the set value might not correspond to the readback
        one (float up to 200000)."""""",
        validator=strict_range,
        values=[0, 200000],
        check_set_errors=True,
    )

    def enable_continous(self):
        """"""Enable countinous emmission mode.""""""
        self.write('di ext')
        self.check_set_errors()
        self.emission = True
        self.ch_2.enabled = True

    def enable_pulsing(self):
        """"""Enable pulsing mode.

        The optical output is controlled by a digital
        input signal on a dedicated connnector on the device.""""""
        self.emission = True
        self.ch_2.enabled = True
        self.write('en ext')
        self.check_set_errors()

    def disable(self):
        """"""Shutdown all laser operation.""""""
        self.write('di 0')
        self.check_set_errors()
        self.emission = False

    def shutdown(self):
        """"""Brings the instrument to a safe and stable state.""""""
        self.disable()
        super().shutdown()
"
208,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,https://www.newport.com/c/laser-diode-controllers,"[OrderedDict([('id', 'att9arouLgpPtpqWm'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jMnvLOJJg-Py3sabQAY4Qw/X1rRG3ty8dEHznZytdL0OLBh4uLooJb-FdlhoWzTjfsAf9bkKqHmkHvcT7wbrjYQ9t2l-CS0B8k4sbXkLurwgd3fMulAhvTVmljNnGubTGE/7Wkoa2SuLdwDsFMIHkoMprfxYibY0iLNmBMtVLzDp2c'), ('filename', '1649_PRO8000_2_SGL.jpg'), ('size', 42451), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MYhgQWF-jDeeqt-6nzE4NA/oxa-sWnP0b5dTQLs6ZKV7Ub3-eT7LcPfn1lCT9acfNch0touQXLmRIBvxcJOYUnDKjmq834SsfkVSMOKwRDTUw/ttGp1Anvrhx0HkFIpZrVJrY-OS9JqoGHa5hnbPuGCmw'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/52t_CkexoAA-7JnZIZsPdg/zh_TxcLYL36ffkkEXETQbkIxk7ohaXM0OgzE7OAWLkSaZv2amKImhuxW8u-Bj9cre6afXifeUcVJ8KeJ-hZW-w/KvbP24enlmrvagOATeW0jO__e-aKKpuPpQxdCpQZdSI'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-5G7lMzMygQr62Jv2lZG0Q/kXtkAgLeKq-k9a6ao6ufwkux0Y-DPCs9rW5vWvvkgSYn1ja1sY6LU3kIyj8tjzmyWQjoqpkIu4zPeks3BGnCUw/DRIb3e7AalU0oj_VjzOUUwxpapyLd2626gTKHJz3cc4'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126009/Instruments/Vendor%20Logos/Thorlabs.png,"The PRO8000 Chassis can accept up to 8 modules and is ideally suited for the needs of large test setups. This made-to-order chassis can be custom configured with up to eight modules that best meet individual experimental needs prior to purchase. The chassis can also be ordered empty, without any pre-installed modules. The empty slots of the PRO8000 can be covered using PRO8000-C front cover plates.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=895&pn=PRO8000,Thorlabspro 8000,619.0,['Laser Diode Controllers'],"Laser diode controllers have an integrated precision laser diode driver and high stability temperature controller. Multiple levels of laser diode protection are built into each instrument including isolated power supplies, slow start, adjustable current limit and compliance voltage, intermittent contact protection, and output shorting relays. To complement our line of laser diode controllers, ILX Lightwave offers a wide variety of laser diode mounts and fixtures with standard interconnection cables.","Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thorlabs/thorlabspro8000.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/thorlabs/thorlabspro8000.html,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/x731LcvXJOhIxKPxXBmL-w/VlkdYgoe64hZvgmVi1Mt2va7W68fvi56sLBEYiL_mrrCmYqRXMbprBW1E-OJi8iD9o-0DLRC5wGR-ssleFTCL3uHby5eA9kC9m0ytppEE90/Ky5aaA1DukMmBAuTe0YNih6iL16m754szjrKl_d_EHY'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3tCz9GDieFUYrT5cVRNlTg/WvwhFhH-q7fyK5DPXrIZFa-3BTndobx-UyMCpJunBqSZ1XrqRHcBUkLXEsxAKP7-7Osz9IbUoxh8h4wk_L2nwg/a8Mm4XjlzKldl5sSWHBcx_6OdDUK8lySzPEgc_yObRY'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F4HozD8tZhKbhCRvIcIpKA/V12OwQQZi2a747mGBz52__bg_a_EumL3Ogivcbki8roaRLMwK5n5brTqFQ9BffmZ8dPSVMeaES21plMnKj8E6A/8nGftj_GpWrmZq97sxddWsTReReWF8jnOVb8ATPuvms'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_Wu8JHeU1hRk635kvkRl6Q/iOinrFGcIbKJPYrZY4bT0uZkwK_bs1h8AAy133kmDrpXvKwDS62Nm4QeHACLopsGzYk3HzKLlGqtB6Rc7vuxVg/1RwEMrv-It85KRA_t3kg7_uvHY0GsP6pRMob7E785bc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782612/Instruments/Laser%20Diode%20Controllers/PRO8000/PRO8000.jpg,PRO8000,Write a Python script that uses Pymeasure to connect to a PRO8000 Laser Diode Controllers,2966.31,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set


class ThorlabsPro8000(Instrument):
    """"""Represents Thorlabs Pro 8000 modular laser driver""""""
    SLOTS = range(1, 9)
    LDC_POLARITIES = ['AG', 'CG']
    STATUS = ['ON', 'OFF']

    def __init__(self, adapter, name=""Thorlabs Pro 8000"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.write(':SYST:ANSW VALUE')

    # Code for general purpose commands (mother board related)
    slot = Instrument.control("":SLOT?"", "":SLOT %d"",
                              ""Control slot selection. Allowed values are: {}"""""".format(SLOTS),
                              validator=strict_discrete_set,
                              values=SLOTS,
                              map_values=False)

    # Code for LDC-xxxx daughter boards (laser driver)
    LDCCurrent = Instrument.control("":ILD:SET?"", "":ILD:SET %g"",
                                    """"""Control laser current."""""")

    LDCCurrentLimit = Instrument.control(
        "":LIMC:SET?"", "":LIMC:SET %g"",
        """"""Set Software current Limit (value must be lower than hardware current limit).""""""
    )

    LDCPolarity = Instrument.control(
        "":LIMC:SET?"", "":LIMC:SET %s"",
        f""""""Set laser diode polarity. Allowed values are: {LDC_POLARITIES}"""""",
        validator=strict_discrete_set,
        values=LDC_POLARITIES,
        map_values=False
    )

    LDCStatus = Instrument.control(
        "":LASER?"", "":LASER %s"",
        """"""Set laser diode status. Allowed values are: {}"""""".format(
            STATUS),
        validator=strict_discrete_set,
        values=STATUS,
        map_values=False
    )

    # Code for TED-xxxx daughter boards (TEC driver)
    TEDStatus = Instrument.control("":TEC?"", "":TEC %s"",
                                   f""""""Control TEC status. Allowed values are: {STATUS}"""""",
                                   validator=strict_discrete_set,
                                   values=STATUS,
                                   map_values=False)

    TEDSetTemperature = Instrument.control("":TEMP:SET?"", "":TEMP:SET %g"",
                                           """"""Control TEC temperature"""""")
"
212,https://www.keysight.com/us/en/assets/7018-03960/technical-overviews/5991-2443.pdf,https://www.keysight.com/us/en/products/parameter-device-analyzers-curve-tracer.html,"[OrderedDict([('id', 'atthxudEM2qtOPtJ2'), ('width', 478), ('height', 269), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1Qm6Y4JAij44K1Xwkfkftg/aRNEzqe56GCCPUaLET9-9haL0U7BAIEZrzNhXY3OhYgToVpeVoAHrcrTTsA7s9FUTMLPnSpEx8TI8flP4jHnOOAtu5BYIEQ_e_qVJs4vyqA/erXBGoQRRAlgf1pox4YxDG_QCqxhV8LeMuqcFF0gMCo'), ('filename', 'B1500A.webp'), ('size', 16664), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/QHkmEATtk1Air4FjCpBp4w/nYFSTSBTYCB0vNxBV1PZZmRHvC1Ock_5_aiEoEodexTbAjM2kAO-kjeCICL0KDxHhkoop4oo5v6yDnZP4kJZgtd5Ttn3V2d3ErUR4p5-p_E/39AboP2zbKDvxlfyL5neguZqaTJZcwIyZ4t7T_LPfOk'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uDJGUFh1cG1V0YlJ0iwsAA/o004TLkVNLuhAWAhY4ghYFoOQb64tLUTkgeEfVOBKDPEen0AKaeUnRvgj4GSj68wdGVYYomewvhV38B5p7x-QI-OjAUXHJTiUcEfVRQcqLw/vhxZEagK7ZA5HBbwHjrB3d2LunGQeTOn4cQWO-4fSl8'), ('width', 478), ('height', 269)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LXYgJ6EEpXMqtYf5nXb3PQ/YlLPSqvWCkuvY8We-Vfj7SZBVMIowi6FDDYRKKQ3X0HQDH8W_m77jlwR6Zu5dUH_8kkOgprhiXOYEA-JFBFhiKulSrAtvXtTJoFng-tJ4RE/EuYbkGIHw5z6C_7vlsO5F3Mt2ls4VD5Oce_L-6-UWIE'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png," It provides a wide range of measurement capabilities to cover the electrical characterization and evaluation of devices, materials, semiconductors, active/passive components, or virtually any other type of electronic device with uncompromised measurement reliability and efficiency. The B1500A modular architecture gives you the flexibility to upgrade when needed.",https://www.keysight.com/us/en/products/parameter-device-analyzers-curve-tracer/precision-current-voltage-analyzers/b1500a-semiconductor-device-parameter-analyzer.html,Agilentb 1500,4.0,['Spectrum Analyzers'],"The Keysight B1500A semiconductor parameter analyzer is an all-in-one device characterization analyzer supporting IV, CV, pulse/dynamic IV and more.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/qcodes/qcodes/blob/master/docs/examples/driver_examples/Qcodes%20example%20with%20Keysight%20B1500%20Parameter%20Analyzer.ipynb,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentB1500.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782723/Instruments/Spectrum%20Analyzers/Keysight-B1500A/Keysight-B1500A.png,Keysight B1500A,Write a Python script that uses Pymeasure to connect to a Keysight B1500A Spectrum Analyzers,,"
",,,"#!/usr/bin/env python
# coding: utf-8

# <h1>Table of Contents<span class=""tocSkip""></span></h1>
# <div class=""toc""><ul class=""toc-item""><li><span><a href=""#Qcodes-example-with-Keysight-B1500-Semiconductor-Parameter-Analyzer"" data-toc-modified-id=""Qcodes-example-with-Keysight-B1500-Semiconductor-Parameter-Analyzer-1""><span class=""toc-item-num"">1&nbsp;&nbsp;</span>Qcodes example with Keysight B1500 Semiconductor Parameter Analyzer</a></span><ul class=""toc-item""><li><span><a href=""#Instrument-Short-info"" data-toc-modified-id=""Instrument-Short-info-1.1""><span class=""toc-item-num"">1.1&nbsp;&nbsp;</span>Instrument Short info</a></span><ul class=""toc-item""><li><span><a href=""#Physical-grouping"" data-toc-modified-id=""Physical-grouping-1.1.1""><span class=""toc-item-num"">1.1.1&nbsp;&nbsp;</span>Physical grouping</a></span></li><li><span><a href=""#Logical-grouping"" data-toc-modified-id=""Logical-grouping-1.1.2""><span class=""toc-item-num"">1.1.2&nbsp;&nbsp;</span>Logical grouping</a></span></li></ul></li><li><span><a href=""#Qcodes-driver-info"" data-toc-modified-id=""Qcodes-driver-info-1.2""><span class=""toc-item-num"">1.2&nbsp;&nbsp;</span>Qcodes driver info</a></span><ul class=""toc-item""><li><span><a href=""#Integer-Flags-and-Constants-used-in-the-driver"" data-toc-modified-id=""Integer-Flags-and-Constants-used-in-the-driver-1.2.1""><span class=""toc-item-num"">1.2.1&nbsp;&nbsp;</span>Integer Flags and Constants used in the driver</a></span></li><li><span><a href=""#High-level-interface"" data-toc-modified-id=""High-level-interface-1.2.2""><span class=""toc-item-num"">1.2.2&nbsp;&nbsp;</span>High level interface</a></span></li><li><span><a href=""#Low-level-interface"" data-toc-modified-id=""Low-level-interface-1.2.3""><span class=""toc-item-num"">1.2.3&nbsp;&nbsp;</span>Low level interface</a></span></li></ul></li><li><span><a href=""#Programming-Examples"" data-toc-modified-id=""Programming-Examples-1.3""><span class=""toc-item-num"">1.3&nbsp;&nbsp;</span>Programming Examples</a></span><ul class=""toc-item""><li><span><a href=""#Initializing-the-instrument"" data-toc-modified-id=""Initializing-the-instrument-1.3.1""><span class=""toc-item-num"">1.3.1&nbsp;&nbsp;</span>Initializing the instrument</a></span></li></ul></li><li><span><a href=""#High-Level-Interface"" data-toc-modified-id=""High-Level-Interface-1.4""><span class=""toc-item-num"">1.4&nbsp;&nbsp;</span>High Level Interface</a></span><ul class=""toc-item""><li><span><a href=""#Identifying-and-selecting-installed-modules"" data-toc-modified-id=""Identifying-and-selecting-installed-modules-1.4.1""><span class=""toc-item-num"">1.4.1&nbsp;&nbsp;</span>Identifying and selecting installed modules</a></span></li><li><span><a href=""#Enabling-/-Disabling-channels"" data-toc-modified-id=""Enabling-/-Disabling-channels-1.4.2""><span class=""toc-item-num"">1.4.2&nbsp;&nbsp;</span>Enabling / Disabling channels</a></span></li><li><span><a href=""#Perform-self-calibration"" data-toc-modified-id=""Perform-self-calibration-1.4.3""><span class=""toc-item-num"">1.4.3&nbsp;&nbsp;</span>Perform self calibration</a></span></li><li><span><a href=""#Performing-sampling-measurements"" data-toc-modified-id=""Performing-sampling-measurements-1.4.4""><span class=""toc-item-num"">1.4.4&nbsp;&nbsp;</span>Performing sampling measurements</a></span></li><li><span><a href=""#CV-Sweep"" data-toc-modified-id=""CV-Sweep-1.4.5""><span class=""toc-item-num"">1.4.5&nbsp;&nbsp;</span>CV Sweep</a></span></li><li><span><a href=""#IV-Sweep"" data-toc-modified-id=""IV-Sweep-1.4.6""><span class=""toc-item-num"">1.4.6&nbsp;&nbsp;</span>IV Sweep</a></span></li><li><span><a href=""#Performing-phase-compensation"" data-toc-modified-id=""Performing-phase-compensation-1.4.7""><span class=""toc-item-num"">1.4.7&nbsp;&nbsp;</span>Performing phase compensation</a></span></li><li><span><a href=""#Performing-Open/Short/Load-correction"" data-toc-modified-id=""Performing-Open/Short/Load-correction-1.4.8""><span class=""toc-item-num"">1.4.8&nbsp;&nbsp;</span>Performing Open/Short/Load correction</a></span><ul class=""toc-item""><li><span><a href=""#Set-and-get-reference-values"" data-toc-modified-id=""Set-and-get-reference-values-1.4.8.1""><span class=""toc-item-num"">1.4.8.1&nbsp;&nbsp;</span>Set and get reference values</a></span></li><li><span><a href=""#Add-CMU-output-frequency-to-the-list-for-correction"" data-toc-modified-id=""Add-CMU-output-frequency-to-the-list-for-correction-1.4.8.2""><span class=""toc-item-num"">1.4.8.2&nbsp;&nbsp;</span>Add CMU output frequency to the list for correction</a></span></li><li><span><a href=""#Clear-CMU-output-frequency-list"" data-toc-modified-id=""Clear-CMU-output-frequency-list-1.4.8.3""><span class=""toc-item-num"">1.4.8.3&nbsp;&nbsp;</span>Clear CMU output frequency list</a></span></li><li><span><a href=""#Query-CMU-output-frequency-list"" data-toc-modified-id=""Query-CMU-output-frequency-list-1.4.8.4""><span class=""toc-item-num"">1.4.8.4&nbsp;&nbsp;</span>Query CMU output frequency list</a></span></li><li><span><a href=""#Open/Short/Load-Correction"" data-toc-modified-id=""Open/Short/Load-Correction-1.4.8.5""><span class=""toc-item-num"">1.4.8.5&nbsp;&nbsp;</span>Open/Short/Load Correction</a></span></li></ul></li><li><span><a href=""#SMU-sourcing-and-measuring"" data-toc-modified-id=""SMU-sourcing-and-measuring-1.4.9""><span class=""toc-item-num"">1.4.9&nbsp;&nbsp;</span>SMU sourcing and measuring</a></span></li><li><span><a href=""#Setting-up-ADCs-to-NPLC-mode"" data-toc-modified-id=""Setting-up-ADCs-to-NPLC-mode-1.4.10""><span class=""toc-item-num"">1.4.10&nbsp;&nbsp;</span>Setting up ADCs to NPLC mode</a></span></li></ul></li><li><span><a href=""#Error-Message"" data-toc-modified-id=""Error-Message-1.5""><span class=""toc-item-num"">1.5&nbsp;&nbsp;</span>Error Message</a></span></li><li><span><a href=""#Low-Level-Interface"" data-toc-modified-id=""Low-Level-Interface-1.6""><span class=""toc-item-num"">1.6&nbsp;&nbsp;</span>Low Level Interface</a></span></li></ul></li></ul></div>

# # Qcodes example with Keysight B1500 Semiconductor Parameter Analyzer

# ## Instrument Short info
# Here a short introduction on how the B1500 measurement system is composed is given. For a detailed overview it is strongly recommended to refer to the *B1500 Programming Guide* and also the *Parametric Measurement Handbook* by Keysight.
# 
# ### Physical grouping
# The Keysight B1500 Semiconductor Parameter Analyzer consists of a *Mainframe* and can be equipped with various instrument *Modules*. 10 *Slots* are available in which up to 10 *modules* can be installed (some *modules* occupy two *slots*). Each *module* can have one or two *channels*.
# 
# ### Logical grouping
# The measurements are typically done in one of the 20 measurement modes. The modes can be roughly subdivided into 
#   - Spot measurements
#       - **High Speed Spot Measurements**
#   - Pulsed Spot measurement
#   - Sweep Measurements
#   - Search Measurements
# 
# The **High Speed Spot (HSS)** Mode is essentually just a fancy way of saying to take readings and forcing constant voltages/currents. The *HSS* commands work at any time, independent of the currenttly selected Measurment Mode.
# 
# With the exception of the *High Speed Spot Measurement Mode*, the other modes have to be activated and configured by the user.

# ## Qcodes driver info
# As can be seen already from the instrument short info, the instrument is very versatile, but also very complex. Hence the driver will eventually consist of two layers:
#   - The Low Level interface allows one to utilize all functions of the driver by offering a thin wrapper around the FLEX command set that the B1500 understands. 
#   - A Higher Level interface that provides a convenient access to the more frequently used features. Not all features are available via the high level interface.
# 
# The two driver levels can be used at the same time, so even if some functionality is not yet implemented in the high-level interface, the user can send a corresponding low-level command.
# 
# ### Integer Flags and Constants used in the driver
# Both the high-level and the low-level interface use integer constants in many commands. For user convienience, the `qcodes.instrument_drivers.Keysight.keysightb1500.constants` provides more descriptive Python Enums for these constants. Although bare integer values can still be used, it is highly recommended to use the enumerations in order to avoid mistakes.
# 
# ### High level interface
# The high level exposes instrument functionality via QCodes Parameters and Python methods on the mainframe object and the individual instrument module objects. For example, *High Speed Spot* Measurement commands for forcing constant voltages/currents or for taking simple readings are implemented.
# 
# ### Low level interface
# The Low Level interface (`MessageBuilder` class) provides a wrapper function for each FLEX command. From the low-level, the full functionality of the instrument can be controlled.
# 
# The `MessageBuilder` assembles a message string which later can be sent to the instrument using the low level `write` and `ask` methods. One can also use the `MessageBuilder` to write FLEX complex measurement routines that are stored in the B1500 and can be executed at a later point. This can be done to enable fast execution.

# ## Programming Examples

# ### Initializing the instrument

# In[1]:


from IPython.display import Markdown, display
from matplotlib import pyplot as plt
from pyvisa.errors import VisaIOError

import qcodes as qc
from qcodes.dataset import (
    Measurement,
    initialise_database,
    load_or_create_experiment,
    plot_dataset,
)
from qcodes.instrument_drivers.Keysight import KeysightB1500
from qcodes.instrument_drivers.Keysight.keysightb1500 import MessageBuilder, constants

# In[2]:


station = qc.Station() # Create a station to hold all the instruments

# In[3]:


#Note: If there is no physical instrument connected 
#the following code will try to load a simulated instrument

try:
    #TODO change that address according to your setup
    b1500 = KeysightB1500('spa', address='GPIB21::17::INSTR')
    display(Markdown(""**Note: using physical instrument.**""))
except (ValueError, VisaIOError):
    # Either there is no VISA lib installed or there was no real instrument found at the
    # specified address => use simulated instrument
    b1500 = KeysightB1500('SPA',
                          address='GPIB::1::INSTR',
                          pyvisa_sim_file=""keysight_b1500.yaml"")
    display(Markdown(""**Note: using simulated instrument. Functionality will be limited.**""))

# In[4]:


station.add_component(b1500)

# ## High Level Interface
# 
# Here is an example of using high-level interface.
# 

# ### Identifying and selecting installed modules
# As mentioned above, the B1500 is a modular instrument, and contains multiple cards. When initializing the driver, the driver requests the installed modules from the B1500 and exposes them to the user via multiple ways.
# 
# The first way to address a certain module is e.g. as follows:

# In[ ]:


b1500.smu1 # first SMU in the system
b1500.cmu1 # first CMU in the system
b1500.smu2 # second SMU in the system

# In[ ]:


b1500.cmu1.phase_compensation_mode()

# The naming scheme is - `b1500.<instrument class as lower case><number>`, where number is `1` for the first instrument in its class, `2` for the second instrument in its class and so on. (*Not the channel or slot number!*)
# 
# Next to this direct access - which is simple and good for direct user interaction - the modules are also exposed via multiple data structures through which they can be adressed:
#   - by slot number
#   - by module kind (such as SMU, or CMU)
#   - by channel number
# 
# This can be more convenient for programmatic selection of the modules.

# Instrument modules are installed in slots (numbered 1-11) and can be selected by the slot number:

# In[ ]:


b1500.by_slot

# All modules are also grouped by module kind (see `constants.ModuleKind` for list of known kinds of modules):

# In[ ]:


b1500.by_kind

# For example, let's list all SMU modules:

# In[ ]:


b1500.by_kind['SMU']

# Lastly, there is dictionary of all module channels:

# In[ ]:


# For the simulation driver:
# Note how the B1530A module has two channels.
# The first channel number is the same as the slot number (6).
# The second channel has a `02` appended to the channel number.
b1500.by_channel

# **Note: For instruments with only one channel, channel number is the same as the slot number. However there are instruments with 2 channels per card. For these instruments the second channel number will differ from the slot number.**
# 
# **Note for the simulated instrument: The simulation driver will list a B1530A module with 2 channels as example.**
# 
# In general, the slot- and channel numbers can be passed as integers. However (especially in the case of the channel numbers for multi-channel instruments) it is recommended to use the Python enums defined in `qcodes.instrument_drivers.Keysight.keysightb1500.constants`:

# In[ ]:


# Selecting a module by channel number using the Enum
m1 = b1500.by_channel[constants.ChNr.SLOT_01_CH1]

# Without enum
m2 = b1500.by_channel[1]

# And we assert that we selected the same module:
assert m1 is m2

# ### Enabling / Disabling channels
# 
# Before sourcing or doing a measurement, the respective channel has to be enabled. There are two ways to enable/disable a channel:
#   - By directly addressing the module
#   - By addressing the mainframe and specifying which channel(s) to be enabled
# 
# The second method is useful if multiple channels shall be enabled, or for programmatic en-/disabling of channels. It also allows to en-/disable all channels with one call.

# In[ ]:


# Direct addressing the module
b1500.smu1.enable_outputs()
b1500.smu1.disable_outputs()

# In[ ]:


# Enabling via the mainframe

# enable one channel
b1500.enable_channels([1])

# enable multiple channels
b1500.enable_channels([1, 2])

# disable multiple channels
b1500.disable_channels([1, 2]) 

# disable all channels
b1500.disable_channels()

# ### Perform self calibration
# 
# Calibration takes about 30 seconds (the visa timeout for it is controlled by `b1500.calibration_time_out` attribute).

# In[ ]:


b1500.self_calibration()

# ### Performing sampling measurements

# This section outlines steps to perform sampling measurement. 

# Set a sample rate and number of samples. 

# In[ ]:


# Number of spot measurments made per second and stored in a buffer. 
sample_rate = 0.02
# Total number of spot measurements. 
nsamples = 100

# Assign timing parameters to SMU. 

# In[ ]:


b1500.smu1.timing_parameters(0, sample_rate, nsamples)

# Autozero is generally disabled for sampling measurement. 

# In[ ]:


b1500.autozero_enabled(False)

# Set SMU to sampling mode. 

# In[ ]:


b1500.smu1.measurement_mode(constants.MM.Mode.SAMPLING)

# SMU is configured with by assigning voltage output range, input output range and compliance. While forcing voltage, current should be the compliance and vice versa.
# 

# In[ ]:


b1500.smu1.source_config(output_range=constants.VOutputRange.AUTO,
                       compliance=1e-7, 
                       compl_polarity=None, 
                       min_compliance_range=constants.IOutputRange.AUTO
                      )

# Set the averaging to 1 otherwise the measurement takes 10 times more time. 

# In[ ]:


b1500.use_nplc_for_high_speed_adc(n=1)

# Set the voltage

# In[ ]:


b1500.smu1.enable_outputs()
b1500.smu1.voltage(1e-6)

# We are now ready to start the sampling measurement. We first initialize the database and create-new/load-old experiment. Then we register our dependent and independent parameters and start the measurement. 
# 
# **Note** that the default values of label and units are not defined for the parameter sampling measurement trace. Hence we first set them according to what is being measured: in this case we will measure current in A. It is important to set the label and the unit before the measurement in order to have this information when looking at the acquired data, for example when plotting it with `plot_dataset` as shown below.

# In[ ]:


b1500.smu1.sampling_measurement_trace.label = 'Current'
b1500.smu1.sampling_measurement_trace.unit = 'A'
# Automatic assignment of the label and unit based on
# the settings of the instrument can be implemented
# upon request.

# In[ ]:


initialise_database()
exp = load_or_create_experiment(experiment_name='dummy_sampling_measurement',
                          sample_name=""no sample"")
meas  = Measurement(exp=exp)
meas.register_parameter(b1500.smu1.sampling_measurement_trace)

with meas.run() as datasaver:
    datasaver.add_result((b1500.smu1.sampling_measurement_trace, b1500.smu1.sampling_measurement_trace.get()))

# Thanks to the `label` and `unit` set above for the `sampling_measurement_trace` parameter, the `plot_dataset` function is able to produce a plot with a useful label for the vertical axis, see below:

# In[ ]:


plot_dataset(datasaver.dataset)

# Check compliance: For the values which are compliant the output is one and for others it is zero. A quick to visualize of your measurements are compliant is to plot the compliance data and look if any value of zero.

# In[ ]:


data_compliance = b1500.smu1.sampling_measurement_trace.compliance()

# In[ ]:


plt.plot(data_compliance)
plt.xlabel('Measurements')
_ = plt.ylabel('Compliance status')

# The channel number of the measured data can be obtained in the following way. 

# In[ ]:


data_channel = b1500.smu1.sampling_measurement_trace.data.channel
data_channel[:5]

# If you want to know the type of the measured data, for ex 'I' or 'V' the following method can be used.

# In[ ]:


data_type = b1500.smu1.sampling_measurement_trace.data.type
data_type[:5]

# The measurement status can be obtained using:

# In[ ]:


data_status = b1500.smu1.sampling_measurement_trace.data.status
data_status[:5]

# The variable 'data_status' is a list of strings of measurement status for each data point. One can look at the meaning of the statuses in `constants.MeasurementStatus` class. It enlists meaning of all possible measurement status. For example: in case the measurement status is 'C' its meaning can be found as following.

# In[ ]:


constants.MeasurementStatus.N

# In[ ]:


constants.MeasurementStatus.C

# ### CV Sweep

# MFCMU has two modes of measurement. The first is spot measurement and this here is sweep measurement. As the name suggest sweep measurement execute the measurement once for the whole list of voltages and saves the output in the buffer untill measurment is completed.
# 
# The function below sets up properly the parameters to run the sweep measurements. Look at the docstring of ``setup_staircase_cv`` to know more about each argument of the function. 

# In[13]:


b1500.cmu1.enable_outputs()

# In[14]:


b1500.cmu1.setup_staircase_cv(
    v_start=0,
    v_end=1,
    n_steps=201,
    freq=1e3,
    ac_rms=250e-3,
    post_sweep_voltage_condition=constants.WMDCV.Post.STOP,
    adc_mode=constants.ACT.Mode.PLC,
    adc_coef=5,
    imp_model=constants.IMP.MeasurementMode.Cp_D,
    ranging_mode=constants.RangingMode.AUTO,
    fixed_range_val=None,
    hold_delay=0,
    delay=0,
    step_delay=225e-3,
    trigger_delay=0,
    measure_delay=0,
    abort_enabled=constants.Abort.ENABLED,
    sweep_mode=constants.SweepMode.LINEAR,
    volt_monitor=False)

# If the setup function does not output any error then we are ready for the measurement. 

# In[15]:


initialise_database()
exp = load_or_create_experiment(
    experiment_name='dummy_capacitance_measurement',
    sample_name=""no sample""
)
meas = Measurement(exp=exp)

meas.register_parameter(b1500.cmu1.run_sweep)

with meas.run() as datasaver:
    res = b1500.cmu1.run_sweep() 
    datasaver.add_result((b1500.cmu1.run_sweep,res))

# The ouput of the ``run_sweep`` is a primary parameter (Capacitance) and a secondary parameter (Dissipation). The type of primary and secondary parameter  depends on the impedance model set in the ``setup_staircase_cv`` function (or via the corresponding ``impedance_model`` parameter). The setpoints of both the parameters are the same voltage values as defined by ``setup_staircase_cv`` (behind the scenes, those values are available in the ``cv_sweep_voltages`` parameter). 

# In[16]:


plot_dataset(datasaver.dataset)

# In[17]:


b1500.cmu1.run_sweep.status_summary()

# ### IV Sweep

# This section explains the IV Staircase sweep measurements. 

# Enable the channels. 

# In[5]:


b1500.smu1.enable_outputs()
b1500.smu2.enable_outputs()

# In[6]:


# Always good to do for the safety of the measured sample
b1500.smu2.voltage(0)
b1500.smu1.voltage(0)

# Setting up smu1 and smu2 for running the staircase sweep. One of the smu's is used for sweep. Both the smu's are used for acquiring data. It is possible to acquire data with more SMUs, that depends on the measurement mode (see below), so refer to the instrument manual for information on how many 'channels' can be measured with which measurement mode. In the setup below, smu1 is used to sweep over the sweep voltages -3 to 3 in 201 steps.

# In[7]:


b1500.smu1.setup_staircase_sweep(
    v_src_range = constants.VOutputRange.AUTO,
    v_start = 3,
    v_end = -3,
    n_steps = 201,
    av_coef = 5,
    step_delay = 0.225,
    abort_enabled = constants.Abort.ENABLED,
    i_meas_range = constants.IMeasRange.FIX_10nA,
    i_comp = 1e-8,
    sweep_mode = constants.SweepMode.LINEAR,
    # and there are more arguments with default values
    # that might need to be changed for your
    # particular measurement situation
)

# `smu2` is kept at constant voltage and at different compliance and measurement range settings.

# In[8]:


b1500.smu2.voltage(10e-3)
b1500.smu2.enable_filter(True)
b1500.smu2.measurement_operation_mode(constants.CMM.Mode.COMPLIANCE_SIDE)
b1500.smu2.current_measurement_range(constants.IMeasRange.FIX_10uA)

# `b1500.set_measurement_mode` is used to define measurement mode and the channels from which data is extracted from. Here, channels correspond to SMU1 and SMU2 respectively - the SMU which is setup to run the sweep needs to go **FIRST**.

# In[9]:


b1500.set_measurement_mode(
    mode=constants.MM.Mode.STAIRCASE_SWEEP,
    channels=(b1500.smu1.channels[0], b1500.smu2.channels[0])
)
# SMUs have only one channel so using `channels[0]` is enough
# This might be improved in the future for better clarity and user convenience.

# `run_iv_staircase_sweep` is used to run the sweep

# In[10]:


initialise_database()
exp = load_or_create_experiment(
    experiment_name='dummy_iv_sweep_measurement',
    sample_name=""no sample""
)
meas = Measurement(exp=exp)

# As per user needs, names and labels of the parameters inside the 
# MultiParameter can be adjusted to reflect what is actually being
# measured using the convenient `set_names_labels_and_units` method.
# The setpoint name/label/unit (the independent sweep 'parameter')
# can be additionally customized using `set_setpoint_name_label_and_unit`
# method.
# Below is an example of using `set_names_labels_and_units`:
b1500.run_iv_staircase_sweep.set_names_labels_and_units(
    names=('gate_current', 'source_drain_current'),
    labels=('Gate current', 'Source-drain current'),
)
# The number of names (and labels) MUST be the same as the number of channels,
# and the order of the names should match the order of channels, as passed to
# `set_measurement_mode` method.

meas.register_parameter(b1500.run_iv_staircase_sweep)

with meas.run() as datasaver:
    res = b1500.run_iv_staircase_sweep() 
    datasaver.add_result((b1500.run_iv_staircase_sweep, res))

# In production code, remeber to revert the names/labels of the
# run_iv_staircase_sweep MultiParameter in order to avoid confusion.

# In[11]:


plot_dataset(datasaver.dataset)

# In[12]:


b1500.run_iv_staircase_sweep.status_summary()

# ### Performing phase compensation

# The phase compensation is performed to adjust the phase zero.
# 
# One must take care of two things before executing the phase compensation. First, make sure that all the channel outputs are enabled else instrument throws an error. 

# In[ ]:


b1500.run_iv_staircase_sweep.measurement_status()

# Second, the phase compensation mode must be set to manual.  

# In[ ]:


b1500.cmu1.phase_compensation_mode(constants.ADJ.Mode.MANUAL)

# Now the phase compensation can be performed as follows. This operation takes about 30 seconds (the visa timeout for this operation is set via `b1500.cmu1.phase_compensation_timeout` attribute).

# In[ ]:


b1500.cmu1.phase_compensation()

# Note that `phase_compensation` method also supports loading data of previously performed phase compensation. To use that, explicitly pass the operation mode argument:

# In[ ]:


b1500.cmu1.phase_compensation(constants.ADJQuery.Mode.USE_LAST)

# ### Performing Open/Short/Load correction

# #### Set and get reference values

# Use the following method to set the calibration values or reference values of the open/short/load standard. Here, we are using open correction with Cp-G mode. The primary reference value, which is the value for Cp (in F), is set to 0.00001, and the secondary reference value, which is the value of G (in S), is set to 0.00002. These values are completely arbitrary, so please change them according to your experiments.

# In[ ]:


b1500.cmu1.correction.set_reference_values(corr=constants.CalibrationType.OPEN,
                                           mode=constants.DCORR.Mode.Cp_G,
                                           primary=0.00001,
                                           secondary=0.00002)

# You can retrieve the values you have set for calibration or the reference values of the open/short/load standard in the following way:

# In[ ]:


b1500.cmu1.correction.get_reference_values(corr=constants.CalibrationType.OPEN)

# #### Add CMU output frequency to the list for correction

# You can add to the list of frequencies supported by the instrument to be used for the data correction. The frequency value can be given with a certain resolution as per Table 4-18 in the programming manual.

# In[ ]:


b1500.cmu1.correction.frequency_list.add(1000)

# #### Clear CMU output frequency list

# Clear the frequency list for the correction data measurement using the following methods. Correction data will be invalid after calls to these methods, so you will have to again perform the open/short/load correction.
# 
# There are two modes in which you can clear the frequency list. First is clearing the list of frequencies:

# In[ ]:


b1500.cmu1.correction.frequency_list.clear()

# Second is clearing the list of frequencies and also setting it to a default list of frequencies (for the list of default frequencies, refer to the documentation of the ``CLCORR`` command in the programming manual):

# In[ ]:


b1500.cmu1.correction.frequency_list.clear_and_set_default()

# #### Query CMU output frequency list
# 
# It is possible to query the total number of frequencies in the list:

# In[ ]:


b1500.cmu1.correction.frequency_list.query()

# It is also possible to query the values of specific frequencies using the same method by specifying an index within the frequency list:

# In[ ]:


b1500.cmu1.correction.frequency_list.query(2)

# #### Open/Short/Load Correction

# As per description in the programming guide, we first set the oscillator level of the CMU output signal.

# In[ ]:


# Set oscillator level
b1500.cmu1.voltage_ac(30e-3)

# To perform open/short/load correction connect the open/short/load standard and execute the following command to perform and enable the correction.

# In[ ]:


b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.OPEN)
#b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.SHORT)
#b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.LOAD)

# In case you would only like to perform the correction but not enable it, you can use separate methods `perform` and `enable`.

# To check whether a correction is enabled, use the following method:

# In[ ]:


b1500.cmu1.correction.is_enabled(corr=constants.CalibrationType.OPEN)

# To disable a performed correction, use the following method:

# In[ ]:


b1500.cmu1.correction.disable(corr=constants.CalibrationType.OPEN)

# ### SMU sourcing and measuring
# The simplest measurement one can do with the B1500 are *High Speed Spot Measurements*. They work independent of the selected *Measurement Mode*.
# 
# The `voltage` and `current` Qcodes Parameters that the SMU High Level driver exposes will execute *High Speed Spot* measurements. Additionally, there are functions that let the user specify the output/measure ranges, and compliance limits.
# 
# To source a voltage/current do the following:
#   1. Configure source range, and (optionally) compliance settings
#   2. Enable the channel
#   3. Force the desired voltage
#   4. (optionally) Disable the channel
# 
# **Note: The source settings (Step 1) are persistent until changed again. So for sucessive measurements the configuration can be omitted.**

# In[ ]:


b1500.smu1.enable_outputs()

b1500.smu1.source_config(output_range=constants.VOutputRange.AUTO,
                         compliance=0.1)

b1500.smu1.voltage(1.5)

# To measure do the following:
#   1. Configure the voltage or/and current measure ranges
#   2. Enable the channel (if not yet enabled)
#   3. Do the measurement
#   4. (optionally) Disable the channel
# 
# **Note: The measure settings (Step 1) are persistent until changed again. So for sucessive measurements the configuration can be omitted.**

# In[ ]:


b1500.smu1.i_measure_range_config(i_measure_range=constants.IMeasRange.MIN_100mA)
b1500.smu1.v_measure_range_config(v_measure_range=constants.VMeasRange.FIX_2V)

b1500.smu1.enable_outputs()

cur = b1500.smu1.current()
vol = b1500.smu1.voltage()

b1500.smu1.disable_outputs()

# ### Setting up ADCs to NPLC mode
# 
# Both the mainframe driver and SMU driver implement convenience methods for controlling integration time of the *High Speed Spot* measurement, which allow setting ADC type, and setting the frequenty used NPLC mode.

# Use the following methods on the mainframe instance to set up the ADCs to NPLC mode:

# In[ ]:


# Set the high-speed ADC to NPLC mode,
# and optionally specify the number of PLCs as an arugment
# (refer to the docstring and the user manual for more information)
b1500.use_nplc_for_high_speed_adc(n=1)

# Set the high-resolution ADC to NPLC mode,
# and optionally specify the number of PLCs as an arugment
# (refer to the docstring and the user manual for more information)
b1500.use_nplc_for_high_resolution_adc(n=5)

# And then use the following methods on the SMU instances to use particular ADC for the particular SMU:

# In[ ]:


# Use high-speed ADC 
# with the settings defined above
# for the SMU 1
b1500.smu1.use_high_speed_adc()

# Use high-resoultion ADC 
# with the settings defined above
# for the SMU 2
b1500.smu2.use_high_resolution_adc()

# ## Error Message
# 
# The error messages from the instrument can be read using the following method. This method reads one error code from the head of the error queue and removes that code from the queue. The read error is returned as the response of this method.

# In[ ]:


b1500.error_message()

# Here, the response message contains an error number and an error message. In some cases the error message may also contain the additional information such as the slot number. They are separated by a semicolon (;). For example, if the error 305 occurs on the slot 1, this method returns the following response. 305,""Excess current in HPSMU.; SLOT1"" 
# 
# If no error occurred, this command returns 0,""No Error"".

# ## Low Level Interface
# 
# The Low Level Interface provides a wrapper around the FLEX command set. Multiple commands can be assembled in a sequence. Finally, the command sequence is compiled into a command string, which then can be sent to the instrument. 
# 
# Only some very minimal checks are done to the command string. For example some commands have to be the *last* command in a sequence of commands because the fill the output queue. Adding additional commands after that is not allowed.
# 
# As an example, a ""voltage source + current measurement"" is done, similar as was done above with the high level interface.

# In[ ]:


mb = MessageBuilder()

mb.cn(channels=[1])
mb.dv(chnum=1,
      voltage=1.5,
      v_range=constants.VOutputRange.AUTO,
      i_comp=0.1)
mb.ti(chnum=1,
      i_range=constants.IMeasRange.FIX_100uA)
mb.cl(channels=[1])

# Compiles the sequence of FLEX commands into a message string.
message_string = mb.message

# In[ ]:


print(message_string)

# The message string can be sent to the instrument. To parse the response of this spot measurement command, use the `KeysightB1500.parse_spot_measurement_response` static method.
# 
# `parse_spot_measurement_response` will return a `dict` that contains the measurement value together with the measurement channel, info on what was measured (current, voltage, capacitance, ...), and status information. For a detailed description, see the user manual.

# In[ ]:


response = b1500.ask(message_string)

KeysightB1500.parse_spot_measurement_response(response)

# The `MessageBuilder` object can be cleared, which allows the object to be reused to generate a new message string.

# In[ ]:


mb.clear_message_queue()
# This will produce empty string because MessageBuilder buffer was cleared
mb.message

# The `MessageBuilder` provides a *fluent* interface, which means every call on the `MessageBuilder` object always returns the object itself, with the exeption of `MessageBuilder.message` which **returns the compiled message string**.
# 
# This means that the same message as in the first example could've been assembled like this:

# In[ ]:


response = b1500.ask(
    MessageBuilder()
    .cn(channels=[1])
    .dv(
        chnum=1,
        voltage=1.5,
        v_range=constants.VOutputRange.AUTO,
        i_comp=0.1,
    )
    .ti(chnum=1, i_range=constants.IMeasRange.FIX_100uA)
    .cl(channels=[1])
    .message
)

KeysightB1500.parse_spot_measurement_response(response)

# In[ ]:



"
219,Not available,https://en.wikipedia.org/wiki/Voltmeter,"[OrderedDict([('id', 'attVdKzFaHB9VYgQa'), ('width', 1024), ('height', 549), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/L_Y_z5MZ31JwzkTa-w7MdA/q8oQkddfWIcLYu5g2u-pSozXj2C0qV4YZhGUMKuFQkjGH-G0PIo-YStSH69e8MSrfktJOnkRz3Amy8NynBkxfMFh_mluQhOq7daoQTiSHLsoSQIMwHxG6i3udGWKY8Sc/veLNfQXyHa-wkOS5bFQI8giZ7U4DCg5ZlhQf7wFb-Ic'), ('filename', 'HP3437A-FrontPanelOffAng10-1024x549.jpg'), ('size', 99233), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YvYVqtHOFUAhzv8ZZoXnvQ/QE6M49Pla0gwx0YGGHHqBOC8aFl01XS6UXVxxvnL7p6WULNBe38v5Bb1c-a5xP3EiNkM_EPY594whxsVDXGh_g/KNgGFE-LxBqexi5f3NZ8LY3wFEKAao_iTD8g_5SOM7s'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/l9RREWYGz2USYdUwaPpMoA/v7Fvx7pOqfuMwtQ4aYHsmu8u3aoxXBrmUujahbaJmTXXDHmJkIzjPSaxIKi-3e9B8LxkTn31e-6x5ArFkr34wQ/eFASXuAeZrFnnH-GvLFSvPE2Weap_iuir7eeD_RNFlU'), ('width', 955), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/M7Gs5lyBBEM8rFNo5_OogQ/0nI79PJkIIQSCAxFXJnaB5ipw3CgYA5uol9l5x63tOmJiwOV1bJbk7ZLZTsdx_nvQ1251lkzN95uW8jsnUG-8Q/r-XjZtZjE7NOiWmdkZM9pVabL5HMnrrGQfM1X_QVd0U'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,"The HP 3437A is a microprocessor controlled 3 and 1/2 digit, successive approximation voltmeter, capable of sampling voltages at rates up to 5,700 samples per second.",https://www.barbouri.com/2019/10/19/hewlett-packard-3437a-system-voltmeter/,HP 3437 A,170.0,['Multimeters'],A voltmeter is an instrument used for measuring electric potential difference between two points in an electric circuit. It is connected in parallel.,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp3437A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp3437A.html,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782622/Instruments/Multimeters/HP-3437A/HP-3437A.jpg,HP 3437A,Write a Python script that uses Pymeasure to connect to a HP 3437A Multimeters,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import ctypes
import logging
import math
from enum import IntFlag
import numpy as np
from pymeasure.instruments.hp.hplegacyinstrument import HPLegacyInstrument, StatusBitsBase

from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

c_uint8 = ctypes.c_uint8
c_uint16 = ctypes.c_uint16
c_uint32 = ctypes.c_uint32


class Status(StatusBitsBase):
    """"""
    A bitfield structure containing the assignments for the status decoding
    """"""
    _pack_ = 1
    _fields_ = [
        # Byte 0: Function, Range and Number of Digits
        (""Format"", c_uint8, 1),  # Bit 7
        (""SRQ"", c_uint8, 3),  # bit 4..6
        (""Trigger"", c_uint8, 2),  # bit 2..3
        (""Range"", c_uint8, 2),  # bit 0..1
        # Byte 1 & 2:
        (""Number"", c_uint16, 16),
        # Byte 1:
        # (""NRDGS_MSD"", c_uint8, 4),
        # (""NRDGS_2SD"", c_uint8, 4),
        # Byte 2:
        # (""NRDGS_3SD"", c_uint8, 4),
        # (""NRDGS_LSD"", c_uint8, 4),
        (""not_used"", c_uint8, 4),
        (""Delay"", c_uint32, 28),
        # Byte 3:
        # (""Not_Used"", c_uint8, 4),
        # (""Delay_MSD"", c_uint8, 4),
        # Byte 4:
        # (""Delay_2SD"", c_uint8, 4),
        # (""Delay_3SD"", c_uint8, 4),
        # Byte 5:
        # (""Delay_4SD"", c_uint8, 4),
        # (""Delay_5SD"", c_uint8, 4),
        # Byte 6:
        # (""Delay_6SD"", c_uint8, 4),
        # (""Delay_LSD"", c_uint8, 4),
        ]

    @staticmethod
    def _decode_range(r):
        """"""Method to decode current range

        :param range_undecoded: int to be decoded
        :return cur_range: float value repesenting the active measurment range
        :rtype cur_range: float

        """"""
        # range decoding
        # (cf table 3-2, page 3-5 of the manual, HPAK document 9018-05946)
        decode_map = {
           0: math.nan,
           1: 0.1,
           2: 10.0,
           3: 1.0,
        }
        return decode_map[r]

    @staticmethod
    def _decode_trigger(t):
        """"""Method to decode trigger mode

        :param status_bytes: list of bytes to be decoded
        :return trigger_mode: string with the current trigger mode
        :rtype trigger_mode: str

        """"""
        decode_map = {
           0: ""INVALID"",
           1: ""internal"",
           2: ""external"",
           3: ""hold/manual""
        }
        return decode_map[t]

    _get_process_ = {
        ""Number"": StatusBitsBase._convert_from_bcd,
        ""Delay"": StatusBitsBase._convert_from_bcd,
        ""Range"": _decode_range,
        ""Trigger"": _decode_trigger,
        }

    def __str__(self):
        """"""
        Returns a pretty formatted string showing the status of the instrument
        """"""
        ret_str = """"
        for field in self._fields_:
            ret_str = ret_str + f""{field[0]}: {getattr(self, field[0])}\n""

        return ret_str


class PackedBits(ctypes.BigEndianStructure):
    """"""
    A bitfield structure containing the assignments for the data transfer in packed/binary mode
    """"""
    _pack_ = 1
    _fields_ = [
        (""range"", c_uint8, 2),  # bit 0..1
        (""sign_bit"", c_uint8, 1),
        (""MSD"", c_uint8, 1),
        (""SSD"", c_uint8, 4),
        (""TSD"", c_uint8, 4),
        (""LSD"", c_uint8, 4), ]

    def __float__(self):
        """"""
        Return a float value from the packed data of the HP3437A

        """"""
        # range decoding
        # (cf table 3-2, page 3-5 of the manual, HPAK document 9018-05946)
        decode_map = {
           1: 0.1,
           2: 10.0,
           3: 1.0,
        }
        cur_range = decode_map[self.range]

        signbit = 1
        if self.sign_bit == 0:
            signbit = -1

        return (
            cur_range * signbit * (
                self.MSD + self.SSD / 10 + self.TSD / 100 + self.LSD / 1000
            )
        )


class HP3437A(HPLegacyInstrument):
    """"""Represents the Hewlett Packard 3737A system voltmeter
    and provides a high-level interface for interacting
    with the instrument.
    """"""
    status_desc = Status
    pb_desc = PackedBits

    def __init__(self, adapter, name=""Hewlett-Packard HP3437A"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs,
        )

    # Definitions for different specifics of this instrument
    RANGE = {
        1e-1: ""R1"",
        1: ""R2"",
        10: ""R3"",
    }

    TRIGGERS = {
        ""internal"": ""T1"",
        ""external"": ""T2"",
        ""hold"": ""T3"",
        ""manual"": ""T3"",
    }

    class SRQ(IntFlag):
        """"""Enum element for SRQ mask bit decoding""""""

        DATA_READY = 4
        IGNORE_TRIGGER = 2
        INVALID_PROGRAM = 1

    def _unpack_data(self, data):
        """"""
        Method to unpack the data from the returned bytes in packed mode

        :param data: list of bytes to be decoded
        :return ret_data: float value

        """"""
        ret_data = PackedBits.from_buffer(bytearray(data))
        return float(ret_data)

    # commands overwriting the base implementaiton
    def read_data(self):
        """"""
        Reads measured data from instrument, returns a np.array.

        (This function also takes care of unpacking the data if required)

        :return data: np.array containing the data
        """"""
        # Adjusting the timeout to match the number of counts and the delay

        current_timeout = self.adapter.connection.timeout
        time_needed = self.number_readings * self.delay
        new_timeout = min(1e6, time_needed * 3 * 1000)  # safety factor 3
        if new_timeout > current_timeout:
            if new_timeout >= 1e6:
                # Disables timeout if measurement would take more then 1000 sec
                log.info(""HP3437A: timeout deactivated"")
            self.adapter.connection.timeout = new_timeout
            log.info(""HP3437A: timeout changed to %g"", new_timeout)
        read_data = self.read_bytes(-1)
        # check if data is in packed format format
        if self.talk_ascii:
            return_value = np.array(read_data[:-2].decode(""ASCII"").split("",""),
                                    dtype=float)
        else:
            processed_data = []
            for i in range(0, len(read_data), 2):
                processed_data.append(self._unpack_data(read_data[i : i + 2]))  # noqa: E203
            return_value = np.array(processed_data)
        self.adapter.connection.timeout = current_timeout
        return return_value

    # commands/properties for instrument control
    def check_errors(self):
        """"""
        As this instrument does not have a error indication bit,
        this function alwyas returns an empty list.

        """"""
        return []

    @property
    def talk_ascii(self):
        """"""
        A boolean property, True if the instrument is set to ASCII-based communication.
        This property can be set.
        """"""
        return bool(self.status.Format)

    @talk_ascii.setter
    def talk_ascii(self, value):
        if value:
            self.write(""F1"")
        else:
            self.write(""F2"")

    @property
    def delay(self):
        """"""Return the value (float) for the delay between two measurements,
        this property can be set,

        valid range: 100ns - 0.999999s

        """"""
        return self.status.Delay * 1e-7

    @delay.setter
    def delay(self, value):
        delay_str = (
            ""D."" + format(strict_range(value, [0, 0.9999999]) * 10e6, ""07.0f"") + ""S""
        )
        self.write(delay_str)

    @property
    def number_readings(self):
        """"""Return value (int) for the number of consecutive measurements,
        this property can be set,
        valid range: 0 - 9999

        """"""
        return self.status.Number

    @number_readings.setter
    def number_readings(self, value):
        number_str = ""N"" + str(strict_range(value, [0, 9999])) + ""S""
        self.write(number_str)

    @property
    def range(self):
        """"""Return the current measurement voltage range.

        This property can be set, valid values: 0.1, 1, 10 (V).

        .. Note::

            This instrument does not have autorange capability.

            Overrange will be in indicated as 0.99,9.99 or 99.9

        """"""
        return self.status.Range

    @range.setter
    def range(self, value):
        range_str = ""R"" + format(
            round(math.log10(strict_discrete_set(value, [0.1, 1, 10])) + 2), ""d""
        )
        self.write(range_str)

    @property
    def SRQ_mask(self):
        """"""Return current SRQ mask, this property can be set,

        bit assigment for SRQ:

        =========  ==========================
        Bit (dec)  Description
        =========  ==========================
         1         SRQ when invalid program
         2         SRQ when trigger is ignored
         4         SRQ when data ready
        =========  ==========================

        """"""
        mask = self.status.SRQ
        return self.SRQ(mask)

    @SRQ_mask.setter
    def SRQ_mask(self, value):
        mask_str = ""E"" + format(strict_range(value, [0, 7]), ""o"") + ""S""
        self.write(mask_str)

    @property
    def trigger(self):
        """"""Return current selected trigger mode, this property can be set,

        Possibe values are:

        ===========  ===========================================
        Value        Explanation
        ===========  ===========================================
        internal     automatic trigger (internal)
        external     external trigger (connector on back or GET)
        hold/manual  holds the measurement/issues a manual trigger
        ===========  ===========================================

        """"""
        return self.status.Trigger

    @trigger.setter
    def trigger(self, value):
        trig_set = self.TRIGGERS[strict_discrete_set(value, self.TRIGGERS)]
        self.write(trig_set)
"
220,https://thermotron.com/pdf/_service/software-updates/3800-manual.pdf,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.","[OrderedDict([('id', 'atttu0ySpBbTH0m6E'), ('width', 319), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7lnxOVlx3jkGS_GVQylS-A/6BX_QN3KMToWVfR9ynxessrILYnJ3KJFRY4b_dYAjPQqkSufUmQddXvgCLKwGPnyKTwttRPfeA-CQh1rrSv3jUzuZtl7BWopTGLdbxvjMZA/0wq7K2KG6iRAefG738oyMcX8iE5zpCO7oZPTFhDL69M'), ('filename', 'Thermotron-3800.jpg'), ('size', 42639), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/H3TuT0YVCHKGV8Lc9uv1CQ/1cAYJOJE6WWhwSpzpjHSI4iNW87zQn4dGbwvaapNgx-Zy7Jz162IGIGIA3KzXB1B21weriiJflSP1fOKErMLxg/8djZurPo8j058jKwvY8MYJC_H5PHFFpvee3NPeg_aaM'), ('width', 19), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YKBQ2HQMZs3poSwmtseI5A/eEmE3fRkQ4F29E6gGVu04z13EifDBzgl0tFoFnKGTT_-M6qngGsXzTMlPg9tJ4jflfvs5q3-nFZRC5fm8nHRvg/hn8EXlGVn-j1XBqJSstCVoLeoAsrUHCfsal0WTaJvAc'), ('width', 319), ('height', 600)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5zt8rfY3c8OU-_kuXgSKNw/d7ED6kIQoTvQHD1zbGFkW6S4Bhijvs5Q7k3Ou_9AUJxJwf77-__5X9qcerkHVKw25F_Qo_ZQswDXeoptBEiqZg/qr17aBO40boIgYOF-feOAp5cfWDJ3K_zDDxnO4RG4Gc'), ('width', 3000), ('height', 3000)]))]))])]",89.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125971/Instruments/Vendor%20Logos/Thermotron.png,"The 3800 is a microprocessor-based programmer and controller. The programmer function allows you to program temperature, temperature/humidity, or other types of tests and store them in program memory",https://thermotron.com/pdf/_service/software-updates/3800-manual.pdf,Thermotron 3800,595.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Thermotron** is a worldwide temperature chamber, humidity chamber, and vibration testing equipment manufacturer. View our testing equipment today!

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thermotron/thermotron3800.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/thermotron/thermotron3800.html,Thermotron,"[OrderedDict([('id', 'atteXXAZkzjedpuoT'), ('width', 600), ('height', 67), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/KdtbFZXvaYkmEtAroY6iSQ/qJ-Daa7UkG_uoPhT-CItnoLyFyfpBR2syqpruvpdt_yp3jCQsUp8M6eN7Kl0nYa8syS9H-n2KTjXdC-sufHweXRWtZrzsSyEMOa9GIRgs2g/d_J_WStn1FjpOFM_-eU4Xugh5-TutcXgulv0zbDOfB0'), ('filename', 'Thermotron.jpeg'), ('size', 11067), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3X4ExWX2m4C9Qucb_56oLw/TPDAPsuRPGHPLXI9BCD0L5HEBeGa8kM-JRSHQqAFftQ0_5yaBkYNCJ9HqZKKuS7jV5__t9oNsgbAAqFNPC7ZyA/Z7HGk4C7J8PmrAcpSV6pfKqrAaG-VE3ZXLDV5mW06Es'), ('width', 322), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/JGQN_rYbZZx3DO3S_7Wy_g/RcRyf4bTdhwz9MSC7M864LjSZ77Uqdm7ZC_DFNB8XrS2FLzNJZWtsb5UdtoZ0_1P1RlP6g4z6cI7DvsgyG1I3Q/ahv10mehA3qsZTvVpkzQa67DgHT2LYehk86gWWu5dQ8'), ('width', 600), ('height', 67)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8ofGCOTMOTZh-r2u5R-m4w/hwwiYWvQV081kDTET7BPCzR2xiPcWbq-4J6pE3B2dm9Oz1PJxVQSx220oKqRq3Zw_veAzzF37JHo7I8tImAz-A/yKr1JNhargU209CX2JoRy3mjXMfQtUCSmUm6RT58uCI'), ('width', 3000), ('height', 3000)]))]))])]",https://thermotron.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782623/Instruments/Temperature%20Controllers/Thermotron-3800/Thermotron-3800.jpg,Thermotron 3800,Write a Python script that uses Pymeasure to connect to a Thermotron 3800 Temperature Controllers,3000.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range
from time import sleep
from enum import IntFlag


class Thermotron3800(Instrument):
    """""" Represents the Thermotron 3800 Oven.
    For now, this driver only supports using Control Channel 1.
    There is a 1000ms built in wait time after all write commands.
    """"""

    def __init__(self, adapter, name=""Thermotron 3800"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs
        )

    def write(self, command):
        super().write(command)
        # Insert wait time after sending command.
        # This wait time should be >1000ms for consistent results.
        sleep(1)

    id = Instrument.measurement(
        ""IDEN?"", """""" Reads the instrument identification

        :return: String
        """"""
    )

    temperature = Instrument.measurement(
        ""PVAR1?"", """""" Reads the current temperature of the oven
        via built in thermocouple. Default unit is Celsius, unless
        changed by the user.

        :return: float
        """"""
    )

    mode = Instrument.measurement(
        ""MODE?"", """""" Gets the operating mode of the oven.

        :return: Tuple(String, int)
        """""",
        get_process=lambda mode: Thermotron3800.__translate_mode(mode)
    )

    setpoint = Instrument.control(
        ""SETP1?"", ""SETP1,%g"",
        """""" A floating point property that controls the setpoint
        of the oven in Celsius. This property can be set.
        ""setpoint"" will not update until the ""run()"" command is called.
        After setpoint is set to a new value, the ""run()"" command
        must be called to tell the oven to run to the new temperature.

        :return: None
        """""",
        validator=strict_range,
        values=[-55, 150]
    )

    def run(self):
        '''
        Starts temperature forcing. The oven will ramp to the setpoint.

        :return: None
        '''
        self.write(""RUNM"")

    def stop(self):
        '''
        Stops temperature forcing on the oven.

        :return: None
        '''
        self.write(""STOP"")

    def initalize_oven(self, wait=True):
        '''
        The manufacturer recommends a 3 second wait time after after initializing the oven.
        The optional ""wait"" variable should remain true, unless the 3 second wait time is
        taken care of on the user end. The wait time is split up in the following way:
        1 second (built into the write function) +
        2 seconds (optional wait time from this function (initialize_oven)).

        :return: None
        '''
        self.write(""INIT"")
        if wait:
            sleep(2)

    class Thermotron3800Mode(IntFlag):
        """"""
        +--------+--------------------------------------+
        | Bit    | Mode                                 |
        +========+======================================+
        | 0      | Program mode                         |
        +--------+--------------------------------------+
        | 1      | Edit mode (controller in stop mode)  |
        +--------+--------------------------------------+
        | 2      | View program mode                    |
        +--------+--------------------------------------+
        | 3      | Edit mode (controller in hold mode)  |
        +--------+--------------------------------------+
        | 4      | Manual mode                          |
        +--------+--------------------------------------+
        | 5      | Delayed start mode                   |
        +--------+--------------------------------------+
        | 6      | Unused                               |
        +--------+--------------------------------------+
        | 7      | Calibration mode                     |
        +--------+--------------------------------------+
        """"""
        PROGRAM_MODE = 1
        EDIT_MODE_STOP = 2
        VIEW_PROGRAM_MODE = 4
        EDIT_MODE_HOLD = 8
        MANUAL_MODE = 16
        DELAYED_START_MODE = 32
        UNUSED = 64
        CALIBRATION_MODE = 128

    @staticmethod
    def __translate_mode(mode_coded_integer):

        mode = Thermotron3800.Thermotron3800Mode(int(mode_coded_integer))

        return mode
"
223,https://dl.cdn-anritsu.com/en-us/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/11410-01119C.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attAdxsbQanV18MZB'), ('width', 420), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/afZgtE1b9bbsdlz_NYSUVA/s-PEcPX0juY2CUaALRFLqHchf7POlKfDRLqEJWg8XOa7uIM-uRMEO83JEKorQ99ru1WySohKUB9tQvw-5irKwlG3L9z1m1wxMTAN5zcCsrE/RFy4KTpB7RuckELBw5hlEDrEBnJ1xHb2MrDRszT51Vg'), ('filename', 'anritsu-MG3690C_1.jpg'), ('size', 13503), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_F-9xW4YodDhAekBUJhhaA/r3xI2L_c16Pfaj0NWsAofaB9rl9t4V4PU8QHrO2DLegs9p64YHlImeSvqGXTPCRKgk0nK6sOFqLiXOFcOM-ISA/GGt3qckLdZ6pa5rUQU-Fqd1pxJ7YHkNNiEFHactIS3Q'), ('width', 95), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3yKKGNb5hK91kslH9R1Fzg/APpm64TFv3sOA7uK09MvEzqM85s1-Ca8INQv3Ft7Sw-xapezNW1YaqD-VeYHqK0mh9Ou20SrwXxXqCtV7awe8A/K8k3Uhou5aNb8IDYuY2l0x6pifBGCzXYUCqBkPa62Go'), ('width', 420), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xgp7mToYawFW4XnEccbZKg/mvQQw5K-tAA3g226DbsPYLxFuAQ3SvBd6b_-I30m3g-R9KdE3075zpLlG3BeWBEp5XRWKFRLrC2comQeoOitpg/IoK4Khl5irA-PrKzE3fLrZIqHPa5yjE9tcYlEft2iMI'), ('width', 3000), ('height', 3000)]))]))])]",670.0,JAPAN,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125977/Instruments/Vendor%20Logos/Anritsu.png,"The MG3690C series of broadband signal generators covers audio, HF, VHF, UHF, RF and microwave frequencies from 0.1 Hz to 70 GHz in single coaxial output and up to 500 GHz or beyond, with external multipliers",https://www.anritsu.com/en-us/test-measurement/products/mg3690c,Anritsumg MG3692 C,81.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape","**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anritsu/anritsuMG3692C.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMG3692C.html,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TRQ4_Rn8tl0yPM-RVMjuBw/kFmYa3cCjVKX_qs_g9OW7zhD_i4GEkoEppjnOVpMVuiX0JzEH1yU8nBH4mKsLSYi1uFpmyyXJiT3ttd2HQcUFfui1m7LKmPZDJtCpnY5zFU/qkJY09XNCCHcdbwxeGs4m9QAYf6HHtIptZXrVfVJEk0'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LnL4Lh9ggmFEWMhGWdT0gg/kWtki8ftAi-SCpHsi9Sw5Cp37ZLBmHCLO0BorUzi_Ec0G8orC_Ih-MEc4X9eM83qZ6GkYjFB_ByAaWFZbxhjyA/MROtjYDJdEfrz_I8_oyyWiMjzmmdKwjF0XSqSU0Dwsw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6Ic2IP80HOOT3l98fAw4uA/SLdpR9G_eKRIq4BWQT9eYpv5SuFVA2BHsIbi_FxFcEgMylu9vp2EEuBTbOC6QnxbQyInOT7hztv45kbAbOFMNg/LvfXHayFDgfCltMW4VSoM2ERLjffE9aTyhLEUsrhpBE'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tE-47WX6ExIM5eVQcREWKg/0D2mpJbdUmkE-D1ZcAIbxQtLqJDKaD_OybxyXdhv68_QyEfy26JOKxbwsiVGSk4BpUbYFWElRYLXTVYef6r3YA/xdLcUTzUj00BDRTmsWR4cpCnLkQC8H5RIRh7pkQ1C3s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782625/Instruments/RF%20Signal%20Generator/From-MG3690C-Series/From-MG3690C-Series.jpg,From MG3690C Series,Write a Python script that uses Pymeasure to connect to a From MG3690C Series RF Signal Generator,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


class AnritsuMG3692C(Instrument):
    """""" Represents the Anritsu MG3692C Signal Generator
    """"""
    power = Instrument.control(
        "":POWER?;"", "":POWER %g dBm;"",
        """""" A floating point property that represents the output power
        in dBm. This property can be set. """"""
    )
    frequency = Instrument.control(
        "":FREQUENCY?;"", "":FREQUENCY %e Hz;"",
        """""" A floating point property that represents the output frequency
        in Hz. This property can be set. """"""
    )

    def __init__(self, adapter, name=""Anritsu MG3692C Signal Generator"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    @property
    def output(self):
        """""" A boolean property that represents the signal output state.
        This property can be set to control the output.
        """"""
        return int(self.ask("":OUTPUT?"")) == 1

    @output.setter
    def output(self, value):
        if value:
            self.write("":OUTPUT ON;"")
        else:
            self.write("":OUTPUT OFF;"")

    def enable(self):
        """""" Enables the signal output.
        """"""
        self.output = True

    def disable(self):
        """""" Disables the signal output.
        """"""
        self.output = False

    def shutdown(self):
        """""" Shuts down the instrument, putting it in a safe state.
        """"""
        # TODO: Implement modulation
        self.modulation = False
        self.disable()
        super().shutdown()
"
226,https://www.keysight.com/us/en/assets/7018-02070/technical-overviews/5990-3672.pdf,https://www.atecorp.com/category/semiconductor-parameter-analyzers,"[OrderedDict([('id', 'attD3cR5iYz6YL8CW'), ('width', 582), ('height', 451), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/oj3w9u021gr8s5-rRSTxWg/Xhr3O0EEzlQtdltdQhKNWKokdAnUtB5wG_APJwzsB5B6tLhI-_1zAk6S9ZMpIWSpRZzGIB5oXCZroEX5Sw3mTuy_iw9DclOmegeWxybvLDE/bggYY_APCkOp0TrXhvTwIYla0v3r4Dbjk5Bc1u8KPac'), ('filename', '4156C.png'), ('size', 270610), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1nmbGkK7i4tJNE8w3P5ZwQ/HGFbRuNprRGlLIhQ08Mhj_cnyDepC7EHuyDjG-CSOvc8zOM23G96Dyu4XYQj-rWuuPz5tNW5tp4_0fFM_PZU1g/A3tX1Hy2W6mDmr750JZHkHip0Z0llQlgSl9ZkDqEwiI'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/R4Gh5H7d-Ziux6ayUwYF7A/xKv-mBsnZHtrDpLMaIlR2TnYcYnLe5D2LepMg859CQPxwNEMtQjjxEyd9QZMuOhDeTK1HaO6H6DaytHZRCo-Kg/LgT39ZPd5ylmC_eATnrLx8O2tQXhJDXsaNs_fB07t80'), ('width', 582), ('height', 451)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/78nn6N6Ig0fBnat273F5LA/2NrqGu6cd-NUV2oknFiL6NTBbja_apBKOT55clLW8ineDW9mpkVXOQssZC6oT_p0_fyv0E8q3soD97oLiqCucg/km1RP-CgQDFxObAHlj8AXe95nkG-ouzpLw5ox0-0A_w'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,4156C Precision Semiconductor Parameter Analyzer,https://www.keysight.com/us/en/product/4156C/precision-semiconductor-parameter-analyzer.html,Agilent 4156,17.0,['Spectrum Analyzers'],"
The semiconductor parameter analyzer is an all-in-one unit, that consists of a power supplies, voltage meters, current meters, switching matrices and LCR meters to test semiconductors","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent4156.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent4156.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782628/Instruments/Spectrum%20Analyzers/Keysight-4156C/Keysight-4156C.png,Keysight 4156C,Write a Python script that uses Pymeasure to connect to a Keysight 4156C Spectrum Analyzers,,"
",True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import time
import os
import json

import numpy as np
import pandas as pd

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              truncated_discrete_set,
                                              strict_range)

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

######
# MAIN
######


class Agilent4156(Instrument):
    """""" Represents the Agilent 4155/4156 Semiconductor Parameter Analyzer
    and provides a high-level interface for taking current-voltage (I-V) measurements.

    .. code-block:: python

        from pymeasure.instruments.agilent import Agilent4156

        # explicitly define r/w terminations; set sufficiently large timeout or None.
        smu = Agilent4156(""GPIB0::25"", read_termination = '\\n', write_termination = '\\n',
                          timeout=None)

        # reset the instrument
        smu.reset()

        # define configuration file for instrument and load config
        smu.configure(""configuration_file.json"")

        # save data variables, some or all of which are defined in the json config file.
        smu.save(['VC', 'IC', 'VB', 'IB'])

        # take measurements
        status = smu.measure()

        # measured data is a pandas dataframe and can be exported to csv.
        data = smu.get_data(path='./t1.csv')

    The JSON file is an ascii text configuration file that defines the settings of each channel
    on the instrument. The JSON file is used to configure the instrument using the convenience
    function :meth:`~.Agilent4156.configure` as shown in the example above. For example, the
    instrument setup for a bipolar transistor measurement is shown below.

    .. code-block:: json

         {
                ""SMU1"": {
                    ""voltage_name"" : ""VC"",
                    ""current_name"" : ""IC"",
                    ""channel_function"" : ""VAR1"",
                    ""channel_mode"" : ""V"",
                    ""series_resistance"" : ""0OHM""
                },

                ""SMU2"": {
                    ""voltage_name"" : ""VB"",
                    ""current_name"" : ""IB"",
                    ""channel_function"" : ""VAR2"",
                    ""channel_mode"" : ""I"",
                    ""series_resistance"" : ""0OHM""
                },

                ""SMU3"": {
                    ""voltage_name"" : ""VE"",
                    ""current_name"" : ""IE"",
                    ""channel_function"" : ""CONS"",
                    ""channel_mode"" : ""V"",
                    ""constant_value"" : 0,
                    ""compliance"" : 0.1
                },

                 ""SMU4"": {
                    ""voltage_name"" : ""VS"",
                    ""current_name"" : ""IS"",
                    ""channel_function"" : ""CONS"",
                    ""channel_mode"" : ""V"",
                    ""constant_value"" : 0,
                    ""compliance"" : 0.1
                },

                ""VAR1"": {
                    ""start"" : 1,
                    ""stop"" : 2,
                    ""step"" : 0.1,
                    ""spacing"" : ""LINEAR"",
                    ""compliance"" : 0.1
                },

                ""VAR2"": {
                    ""start"" : 0,
                    ""step"" : 10e-6,
                    ""points"" : 3,
                    ""compliance"" : 2

                }
            }

    """"""

    def __init__(self, adapter, name=""Agilent 4155/4156 Semiconductor Parameter Analyzer"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

        self.smu1 = SMU(self.adapter, 'SMU1', **kwargs)
        self.smu2 = SMU(self.adapter, 'SMU2', **kwargs)
        self.smu3 = SMU(self.adapter, 'SMU3', **kwargs)
        self.smu4 = SMU(self.adapter, 'SMU4', **kwargs)
        self.vmu1 = VMU(self.adapter, 'VMU1', **kwargs)
        self.vmu2 = VMU(self.adapter, 'VMU2', **kwargs)
        self.vsu1 = VSU(self.adapter, 'VSU1', **kwargs)
        self.vsu2 = VSU(self.adapter, 'VSU2', **kwargs)
        self.var1 = VAR1(self.adapter, **kwargs)
        self.var2 = VAR2(self.adapter, **kwargs)
        self.vard = VARD(self.adapter, **kwargs)

    analyzer_mode = Instrument.control(
        "":PAGE:CHAN:MODE?"", "":PAGE:CHAN:MODE %s"",
        """""" A string property that controls the instrument operating mode.

        - Values: :code:`SWEEP`, :code:`SAMPLING`

        .. code-block:: python

            smu.analyzer_mode = ""SWEEP""
        """""",
        validator=strict_discrete_set,
        values={'SWEEP': 'SWE', 'SAMPLING': 'SAMP'},
        map_values=True,
        check_set_errors=True,
        check_get_errors=True
    )

    integration_time = Instrument.control(
        "":PAGE:MEAS:MSET:ITIM?"", "":PAGE:MEAS:MSET:ITIM %s"",
        """""" A string property that controls the integration time.

        - Values: :code:`SHORT`, :code:`MEDIUM`, :code:`LONG`

        .. code-block:: python

            instr.integration_time = ""MEDIUM""
        """""",
        validator=strict_discrete_set,
        values={'SHORT': 'SHOR', 'MEDIUM': 'MED', 'LONG': 'LONG'},
        map_values=True,
        check_set_errors=True,
        check_get_errors=True
    )

    delay_time = Instrument.control(
        "":PAGE:MEAS:DEL?"", "":PAGE:MEAS:DEL %g"",
        """""" A floating point property that measurement delay time in seconds,
        which can take the values from 0 to 65s in 0.1s steps.

        .. code-block:: python

            instr.delay_time = 1 # delay time of 1-sec
        """""",
        validator=truncated_discrete_set,
        values=np.arange(0, 65.1, 0.1),
        check_set_errors=True,
        check_get_errors=True
    )

    hold_time = Instrument.control(
        "":PAGE:MEAS:HTIME?"", "":PAGE:MEAS:HTIME %g"",
        """""" A floating point property that measurement hold time in seconds,
        which can take the values from 0 to 655s in 1s steps.

        .. code-block:: python

            instr.hold_time = 2 # hold time of 2-secs.
        """""",
        validator=truncated_discrete_set,
        values=np.arange(0, 655, 1),
        check_set_errors=True,
        check_get_errors=True
    )

    def stop(self):
        """"""Stops the ongoing measurement

        .. code-block:: python

            instr.stop()
        """"""
        self.write("":PAGE:SCON:STOP"")

    def measure(self, period=""INF"", points=100):
        """"""
        Performs a single measurement and waits for completion in sweep mode.
        In sampling mode, the measurement period and number of points can be specified.

        :param period: Period of sampling measurement from 6E-6 to 1E11 seconds.
            Default setting is :code:`INF`.
        :param points: Number of samples to be measured, from 1 to 10001.
            Default setting is :code:`100`.

        .. code-block::python

            instr.measure() #for sweep measurement
            instr.measure(period=100, points=100) #for sampling measurement
        """"""
        if self.analyzer_mode == ""SWEEP"":
            self.write("":PAGE:SCON:MEAS:SING; *OPC?"")

        else:
            self.write(f"":PAGE:MEAS:SAMP:PER {period}"")
            self.write(f"":PAGE:MEAS:SAMP:POIN {points}"")
            self.write("":PAGE:SCON:MEAS:SING; *OPC?"")

    def disable_all(self):
        """""" Disables all channels in the instrument.

        .. code-block:: python

            instr.disable_all()
        """"""
        self.smu1.disable
        time.sleep(0.1)
        self.smu2.disable
        time.sleep(0.1)
        self.smu3.disable
        time.sleep(0.1)
        self.smu4.disable
        time.sleep(0.1)
        self.vmu1.disable
        time.sleep(0.1)
        self.vmu2.disable
        time.sleep(0.1)

    def configure(self, config_file):
        """""" Configure the channel setup and sweep using a JSON configuration file.

        (JSON is the `JavaScript Object Notation`_)

        .. _`JavaScript Object Notation`: https://www.json.org/

        :param config_file: JSON file to configure instrument channels.

        .. code-block:: python

            instr.configure('config.json')
        """"""
        self.disable_all()
        obj_dict = {'SMU1': self.smu1,
                    'SMU2': self.smu2,
                    'SMU3': self.smu3,
                    'SMU4': self.smu4,
                    'VMU1': self.vmu1,
                    'VMU2': self.vmu2,
                    'VSU1': self.vsu1,
                    'VSU2': self.vsu2,
                    'VAR1': self.var1,
                    'VAR2': self.var2,
                    'VARD': self.vard
                    }
        with open(config_file) as stream:
            try:
                instr_settings = json.load(stream)
            except json.JSONDecodeError as e:
                print(e)

        # replace dict keys with Instrument objects
        new_settings_dict = {}
        for key, value in instr_settings.items():
            new_settings_dict[obj_dict[key]] = value

        for obj, setup in new_settings_dict.items():
            for setting, value in setup.items():
                setattr(obj, setting, value)
                time.sleep(0.1)

    def save(self, trace_list):
        """""" Save the voltage or current in the instrument display list

        :param trace_list: A list of channel variables whose measured data should be saved.
            A maximum of 8 variables are allowed. If only one variable is being saved, a string
            can be specified.

        .. code-block:: python

            instr.save(['IC', 'IB', 'VC', 'VB']) #for list of variables
            instr.save('IC')    #for single variable
        """"""
        self.write("":PAGE:DISP:MODE LIST"")
        if isinstance(trace_list, list):
            if len(trace_list) > 8:
                raise RuntimeError('Maximum of 8 variables allowed')
            else:
                for name in trace_list:
                    self.write(f"":PAGE:DISP:LIST \'{name}\'"")
        elif isinstance(trace_list, str):
            self.write(f"":PAGE:DISP:LIST \'{trace_list}\'"")
        else:
            raise TypeError(
                'Must be a string if only one variable is saved, or else a list if'
                'multiple variables are being saved.'
            )

    def save_var(self, trace_list):
        """""" Save the voltage or current in the instrument variable list.

        This is useful if one or two more variables need to be saved in addition to the 8
        variables allowed by :meth:`~.Agilent4156.save`.

        :param trace_list: A list of channel variables whose measured   data should be saved.
            A maximum of 2 variables are allowed. If only one variable is being saved, a string
            can be specified.

        .. code-block:: python

            instr.save_var(['VA', 'VB'])
        """"""
        self.write("":PAGE:DISP:MODE LIST"")
        if isinstance(trace_list, list):
            if len(trace_list) > 2:
                raise RuntimeError('Maximum of 2 variables allowed')
            else:
                for name in trace_list:
                    self.write(f"":PAGE:DISP:DVAR \'{name}\'"")
        elif isinstance(trace_list, str):
            self.write(f"":PAGE:DISP:DVAR \'{trace_list}\'"")
        else:
            raise TypeError(
                'Must be a string if only one variable is saved, or else a list if'
                'multiple variables are being saved.'
            )

    @property
    def data_variables(self):
        """"""
        Get a string list of data variables for which measured data is available.

        This looks for all the variables saved by the :meth:`~.Agilent4156.save` and
        :meth:`~.Agilent4156.save_var` methods and returns it. This is useful for creation
        of dataframe headers.

        :returns: List

        .. code-block:: python

            header = instr.data_variables
        """"""
        dlist = self.ask("":PAGE:DISP:LIST?"").split(',')
        dvar = self.ask("":PAGE:DISP:DVAR?"").split(',')
        varlist = dlist + dvar
        return list(filter(None, varlist))

    def get_data(self, path=None):
        """"""
        Get the measurement data from the instrument after completion.

        If the measurement period is set to :code:`INF` in the :meth:`~.Agilent4156.measure`
        method, then the measurement must be stopped using :meth:`~.Agilent4156.stop` before
        getting valid data.

        :param path: Path for optional data export to CSV.
        :returns: Pandas Dataframe

        .. code-block:: python

            df = instr.get_data(path='./datafolder/data1.csv')
        """"""
        if int(self.ask('*OPC?')):
            header = self.data_variables
        self.write("":FORM:DATA ASC"")
        # recursively get data for each variable
        for i, listvar in enumerate(header):
            data = self.values(f"":DATA? \'{listvar}\'"")
            time.sleep(0.01)
            if i == 0:
                lastdata = data
            else:
                data = np.column_stack((lastdata, data))
                lastdata = data

        df = pd.DataFrame(data=data, columns=header, index=None)
        if path is not None:
            _, ext = os.path.splitext(path)
            if ext != "".csv"":
                path = path + "".csv""
            df.to_csv(path, index=False)

        return df

##########
# CHANNELS
##########


class SMU(Instrument):
    def __init__(self, adapter, channel, **kwargs):
        super().__init__(
            adapter,
            ""SMU of Agilent 4155/4156 Semiconductor Parameter Analyzer"",
            **kwargs
        )
        self.channel = channel.upper()

    @property
    def channel_mode(self):
        """""" A string property that controls the SMU<n> channel mode.

        - Values: :code:`V`, :code:`I` or :code:`COMM`

        VPULSE AND IPULSE are not yet supported.

        .. code-block:: python

            instr.smu1.channel_mode = ""V""
        """"""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:MODE?"")
        self.check_errors()
        return value

    @channel_mode.setter
    def channel_mode(self, mode):
        validator = strict_discrete_set
        values = [""V"", ""I"", ""COMM""]
        value = validator(mode, values)
        self.write(f"":PAGE:CHAN:{self.channel}:MODE {value}"")
        self.check_errors()

    @property
    def channel_function(self):
        """""" A string property that controls the SMU<n> channel function.

        - Values: :code:`VAR1`, :code:`VAR2`, :code:`VARD` or :code:`CONS`.

        .. code-block:: python

            instr.smu1.channel_function = ""VAR1""
        """"""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:FUNC?"")
        self.check_errors()
        return value

    @channel_function.setter
    def channel_function(self, function):
        validator = strict_discrete_set
        values = [""VAR1"", ""VAR2"", ""VARD"", ""CONS""]
        value = validator(function, values)
        self.write(f"":PAGE:CHAN:{self.channel}:FUNC {value}"")
        self.check_errors()

    @property
    def series_resistance(self):
        """""" Controls the series resistance of SMU<n>.

        - Values: :code:`0OHM`, :code:`10KOHM`, :code:`100KOHM`, or :code:`1MOHM`

        .. code-block:: python

            instr.smu1.series_resistance = ""10KOHM""

        """"""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:SRES?"")
        self.check_errors()
        return value

    @series_resistance.setter
    def series_resistance(self, sres):
        validator = strict_discrete_set
        values = [""0OHM"", ""10KOHM"", ""100KOHM"", ""1MOHM""]
        value = validator(sres, values)
        self.write(f"":PAGE:CHAN:{self.channel}:SRES {value}"")
        self.check_errors()

    @property
    def disable(self):
        """""" Deletes the settings of SMU<n>.

        .. code-block:: python

            instr.smu1.disable()
        """"""
        self.write(f"":PAGE:CHAN:{self.channel}:DIS"")
        self.check_errors()

    @property
    def constant_value(self):
        """""" Set the constant source value of SMU<n>.

        You use this command only if :meth:`~.SMU.channel_function`
        is :code:`CONS` and also :meth:`~.SMU.channel_mode` should not be :code:`COMM`.

        :param const_value: Voltage in (-200V, 200V) and current in (-1A, 1A). Voltage or current
            depends on if :meth:`~.SMU.channel_mode` is set to :code:`V` or :code:`I`.

        .. code-block:: python

            instr.smu1.constant_value = 1

        """"""
        if Agilent4156.analyzer_mode.fget(self) == ""SWEEP"":
            value = self.ask(f"":PAGE:MEAS:CONS:{self.channel}?"")
        else:
            value = self.ask(f"":PAGE:MEAS:SAMP:CONS:{self.channel}?"")
        self.check_errors()
        return value

    @constant_value.setter
    def constant_value(self, const_value):
        validator = strict_range
        values = self.__validate_cons()
        value = validator(const_value, values)
        if Agilent4156.analyzer_mode.fget(self) == 'SWEEP':
            self.write(f"":PAGE:MEAS:CONS:{self.channel} {value}"")
        else:
            self.write("":PAGE:MEAS:SAMP:CONS:{} {}"".format(
                self.channel, value))
        self.check_errors()

    @property
    def compliance(self):
        """""" Sets the *constant* compliance value of SMU<n>.

        If the SMU channel is setup as a variable (VAR1, VAR2, VARD) then compliance limits are
        set by the variable definition.

        - Value: Voltage in (-200V, 200V) and current in (-1A, 1A) based
          on :meth:`~.SMU.channel_mode`.

        .. code-block:: python

            instr.smu1.compliance = 0.1
        """"""
        if Agilent4156.analyzer_mode.fget(self) == ""SWEEP"":
            value = self.ask(f"":PAGE:MEAS:CONS:{self.channel}:COMP?"")
        else:
            value = self.ask(
                f"":PAGE:MEAS:SAMP:CONS:{self.channel}:COMP?"")
        self.check_errors()
        return value

    @compliance.setter
    def compliance(self, comp):
        validator = strict_range
        values = self.__validate_compl()
        value = validator(comp, values)
        if Agilent4156.analyzer_mode.fget(self) == 'SWEEP':
            self.write("":PAGE:MEAS:CONS:{}:COMP {}"".format(
                self.channel, value))
        else:
            self.write("":PAGE:MEAS:SAMP:CONS:{}:COMP {}"".format(
                self.channel, value))
        self.check_errors()

    @property
    def voltage_name(self):
        """""" Define the voltage name of the channel.

        If input is greater than 6 characters long or starts with a number,
        the name is autocorrected and prepended with 'a'. Event is logged.

        .. code-block:: python

            instr.smu1.voltage_name = ""Vbase""
        """"""
        value = self.ask(f""PAGE:CHAN:{self.channel}:VNAME?"")
        return value

    @voltage_name.setter
    def voltage_name(self, vname):
        value = check_current_voltage_name(vname)
        self.write(f"":PAGE:CHAN:{self.channel}:VNAME \'{value}\'"")

    @property
    def current_name(self):
        """""" Define the current name of the channel.

        If input is greater than 6 characters long or starts with a number,
        the name is autocorrected and prepended with 'a'. Event is logged.

        .. code-block:: python

            instr.smu1.current_name = ""Ibase""
        """"""
        value = self.ask(f""PAGE:CHAN:{self.channel}:INAME?"")
        return value

    @current_name.setter
    def current_name(self, iname):
        value = check_current_voltage_name(iname)
        self.write(f"":PAGE:CHAN:{self.channel}:INAME \'{value}\'"")

    def __validate_cons(self):
        """"""Validates the instrument settings for operation in constant mode.
        """"""
        if not ((self.channel_mode != 'COMM') and (
                self.channel_function == 'CONS')):
            raise ValueError(
                'Cannot set constant SMU function when SMU mode is COMMON, '
                'or when SMU function is not CONSTANT.'
            )
        else:
            values = valid_iv(self.channel_mode)
        return values

    def __validate_compl(self):
        """"""Validates the instrument compliance for operation in constant mode.
        """"""
        if not ((self.channel_mode != 'COMM') and (
                self.channel_function == 'CONS')):
            raise ValueError(
                'Cannot set constant SMU parameters when SMU mode is COMMON, '
                'or when SMU function is not CONSTANT.'
            )
        else:
            values = valid_compliance(self.channel_mode)
        return values


class VMU(Instrument):
    def __init__(self, adapter, channel, **kwargs):
        super().__init__(
            adapter,
            ""VMU of Agilent 4155/4156 Semiconductor Parameter Analyzer"",
            **kwargs
        )
        self.channel = channel.upper()

    @property
    def voltage_name(self):
        """""" Define the voltage name of the VMU channel.

        If input is greater than 6 characters long or starts with a number,
        the name is autocorrected and prepended with 'a'. Event is logged.

        .. code-block:: python

            instr.vmu1.voltage_name = ""Vanode""
        """"""
        value = self.ask(f""PAGE:CHAN:{self.channel}:VNAME?"")
        return value

    @voltage_name.setter
    def voltage_name(self, vname):
        value = check_current_voltage_name(vname)
        self.write(f"":PAGE:CHAN:{self.channel}:VNAME \'{value}\'"")

    @property
    def disable(self):
        """""" Disables the settings of VMU<n>.

        .. code-block:: python

            instr.vmu1.disable()
        """"""
        self.write(f"":PAGE:CHAN:{self.channel}:DIS"")
        self.check_errors()

    @property
    def channel_mode(self):
        """""" A string property that controls the VMU<n> channel mode.

        - Values: :code:`V`, :code:`DVOL`
        """"""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:MODE?"")
        self.check_errors()
        return value

    @channel_mode.setter
    def channel_mode(self, mode):
        validator = strict_discrete_set
        values = [""V"", ""DVOL""]
        value = validator(mode, values)
        self.write(f"":PAGE:CHAN:{self.channel}:MODE {value}"")
        self.check_errors()


class VSU(Instrument):
    def __init__(self, adapter, channel, **kwargs):
        super().__init__(
            adapter,
            ""VSU of Agilent 4155/4156 Semiconductor Parameter Analyzer"",
            **kwargs
        )
        self.channel = channel.upper()

    @property
    def voltage_name(self):
        """""" Define the voltage name of the VSU channel

        If input is greater than 6 characters long or starts with a number,
        the name is autocorrected and prepended with 'a'. Event is logged.

        .. code-block:: python

            instr.vsu1.voltage_name = ""Ve""
        """"""
        value = self.ask(f""PAGE:CHAN:{self.channel}:VNAME?"")
        return value

    @voltage_name.setter
    def voltage_name(self, vname):
        value = check_current_voltage_name(vname)
        self.write(f"":PAGE:CHAN:{self.channel}:VNAME \'{value}\'"")

    @property
    def disable(self):
        """""" Deletes the settings of VSU<n>.

        .. code-block:: python

            instr.vsu1.disable()
        """"""
        self.write(f"":PAGE:CHAN:{self.channel}:DIS"")
        self.check_errors()

    @property
    def channel_mode(self):
        """""" Get channel mode of VSU<n>.""""""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:MODE?"")
        self.check_errors()
        return value

    @property
    def constant_value(self):
        """""" Sets the constant source value of VSU<n>.

        .. code-block:: python

            instr.vsu1.constant_value = 0
        """"""
        if Agilent4156.analyzer_mode.fget(self) == ""SWEEP"":
            value = self.ask(f"":PAGE:MEAS:CONS:{self.channel}?"")
        else:
            value = self.ask(f"":PAGE:MEAS:SAMP:CONS:{self.channel}?"")
        self.check_errors()
        return value

    @constant_value.setter
    def constant_value(self, const_value):
        validator = strict_range
        values = [-200, 200]
        value = validator(const_value, values)
        if Agilent4156.analyzer_mode.fget(self) == 'SWEEP':
            self.write(f"":PAGE:MEAS:CONS:{self.channel} {value}"")
        else:
            self.write("":PAGE:MEAS:SAMP:CONS:{} {}"".format(
                self.channel, value))
        self.check_errors()

    @property
    def channel_function(self):
        """""" A string property that controls the VSU channel function.

        - Value: :code:`VAR1`, :code:`VAR2`, :code:`VARD` or :code:`CONS`.
        """"""
        value = self.ask(f"":PAGE:CHAN:{self.channel}:FUNC?"")
        self.check_errors()
        return value

    @channel_function.setter
    def channel_function(self, function):
        validator = strict_discrete_set
        values = [""VAR1"", ""VAR2"", ""VARD"", ""CONS""]
        value = validator(function, values)
        self.write(f"":PAGE:CHAN:{self.channel}:FUNC {value}"")
        self.check_errors()

#################
# SWEEP VARIABLES
#################


class VARX(Instrument):
    """""" Base class to define sweep variable settings """"""

    def __init__(self, adapter, var_name, **kwargs):
        super().__init__(
            adapter,
            ""Methods to setup sweep variables"",
            **kwargs
        )
        self.var = var_name.upper()

    @property
    def channel_mode(self):
        channels = ['SMU1', 'SMU2', 'SMU3', 'SMU4', 'VSU1', 'VSU2']
        for ch in channels:
            ch_func = self.ask(f"":PAGE:CHAN:{ch}:FUNC?"")
            if ch_func == self.var:
                ch_mode = self.ask(f"":PAGE:CHAN:{ch}:MODE?"")
        return ch_mode

    @property
    def start(self):
        """""" Sets the sweep START value.

        .. code-block:: python

            instr.var1.start = 0
        """"""
        value = self.ask(f"":PAGE:MEAS:{self.var}:STAR?"")
        self.check_errors()
        return value

    @start.setter
    def start(self, value):
        validator = strict_range
        values = valid_iv(self.channel_mode)
        set_value = validator(value, values)
        self.write(f"":PAGE:MEAS:{self.var}:STAR {set_value}"")
        self.check_errors()

    @property
    def stop(self):
        """""" Sets the sweep STOP value.

        .. code-block:: python

            instr.var1.stop = 3
        """"""
        value = self.ask(f"":PAGE:MEAS:{self.var}:STOP?"")
        self.check_errors()
        return value

    @stop.setter
    def stop(self, value):
        validator = strict_range
        values = valid_iv(self.channel_mode)
        set_value = validator(value, values)
        self.write(f"":PAGE:MEAS:{self.var}:STOP {set_value}"")
        self.check_errors()

    @property
    def step(self):
        """""" Sets the sweep STEP value.

        .. code-block:: python

            instr.var1.step = 0.1
        """"""
        value = self.ask(f"":PAGE:MEAS:{self.var}:STEP?"")
        self.check_errors()
        return value

    @step.setter
    def step(self, value):
        validator = strict_range
        values = 2 * valid_iv(self.channel_mode)
        set_value = validator(value, values)
        self.write(f"":PAGE:MEAS:{self.var}:STEP {set_value}"")
        self.check_errors()

    @property
    def compliance(self):
        """""" Sets the sweep COMPLIANCE value.

        .. code-block:: python

            instr.var1.compliance = 0.1
        """"""
        value = self.ask("":PAGE:MEAS:{}:COMP?"")
        self.check_errors()
        return value

    @compliance.setter
    def compliance(self, value):
        validator = strict_range
        values = 2 * valid_compliance(self.channel_mode)
        set_value = validator(value, values)
        self.write(f"":PAGE:MEAS:{self.var}:COMP {set_value}"")
        self.check_errors()


class VAR1(VARX):
    """""" Class to handle all the specific definitions needed for VAR1.
    Most common methods are inherited from base class.
    """"""

    def __init__(self, adapter, **kwargs):
        super().__init__(
            adapter,
            ""VAR1"",
            **kwargs
        )

    spacing = Instrument.control(
        "":PAGE:MEAS:VAR1:SPAC?"",
        "":PAGE:MEAS:VAR1:SPAC %s"",
        """"""
        Selects the sweep type of VAR1.

        - Values: :code:`LINEAR`, :code:`LOG10`, :code:`LOG25`, :code:`LOG50`.
        """""",
        validator=strict_discrete_set,
        values={'LINEAR': 'LIN', 'LOG10': 'L10',
                'LOG25': 'L25', 'LOG50': 'L50'},
        map_values=True,
        check_set_errors=True,
        check_get_errors=True
    )


class VAR2(VARX):
    """""" Class to handle all the specific definitions needed for VAR2.
    Common methods are imported from base class.
    """"""

    def __init__(self, adapter, **kwargs):
        super().__init__(
            adapter,
            ""VAR2"",
            **kwargs
        )

    points = Instrument.control(
        "":PAGE:MEAS:VAR2:POINTS?"",
        "":PAGE:MEAS:VAR2:POINTS %g"",
        """"""
        Sets the number of sweep steps of VAR2.
        You use this command only if there is an SMU or VSU
        whose function (FCTN) is VAR2.

        .. code-block:: python

            instr.var2.points = 10
        """""",
        validator=strict_discrete_set,
        values=range(1, 128),
        check_set_errors=True,
        check_get_errors=True
    )


class VARD(Instrument):
    """""" Class to handle all the definitions needed for VARD.
    VARD is always defined in relation to VAR1.
    """"""

    def __init__(self, adapter, **kwargs):
        super().__init__(
            adapter,
            ""Definitions for VARD sweep variable."",
            **kwargs
        )

    @property
    def channel_mode(self):
        channels = ['SMU1', 'SMU2', 'SMU3', 'SMU4', 'VSU1', 'VSU2']
        for ch in channels:
            ch_func = self.ask(f"":PAGE:CHAN:{ch}:FUNC?"")
            if ch_func == ""VARD"":
                ch_mode = self.ask(f"":PAGE:CHAN:{ch}:MODE?"")
        return ch_mode

    @property
    def offset(self):
        """"""
        Sets the OFFSET value of VARD.
        For each step of sweep, the output values of VAR1' are determined by the
        following equation: VARD = VAR1 X RATio + OFFSet
        You use this command only if there is an SMU or VSU whose function is VARD.

        .. code-block:: python

            instr.vard.offset = 1
        """"""
        value = self.ask("":PAGE:MEAS:VARD:OFFSET?"")
        self.check_errors()
        return value

    @offset.setter
    def offset(self, offset_value):
        validator = strict_range
        values = 2 * valid_iv(self.channel_mode)
        value = validator(offset_value, values)
        self.write(f"":PAGE:MEAS:VARD:OFFSET {value}"")
        self.check_errors()

    ratio = Instrument.control(
        "":PAGE:MEAS:VARD:RATIO?"",
        "":PAGE:MEAS:VARD:RATIO %g"",
        """"""
        Sets the RATIO of VAR1'.
        For each step of sweep, the output values of VAR1' are determined by the
        following equation: VAR1’ = VAR1 * RATio + OFFSet
        You use this command only if there is an SMU or VSU whose function
        (FCTN) is VAR1'.

        .. code-block:: python

            instr.vard.ratio = 1
        """""",
    )

    @property
    def compliance(self):
        """""" Sets the sweep COMPLIANCE value of VARD.

        .. code-block:: python

            instr.vard.compliance = 0.1
        """"""
        value = self.ask("":PAGE:MEAS:VARD:COMP?"")
        self.check_errors()
        return value

    @compliance.setter
    def compliance(self, value):
        validator = strict_range
        values = 2 * valid_compliance(self.channel_mode)
        set_value = validator(value, values)
        self.write(f"":PAGE:MEAS:VARD:COMP {set_value}"")
        self.check_errors()


def check_current_voltage_name(name):
    if (len(name) > 6) or not name[0].isalpha():
        new_name = 'a' + name[:5]
        log.info(f""Renaming {name} to {new_name}..."")
        name = new_name
    return name


def valid_iv(channel_mode):
    if channel_mode == 'V':
        values = [-200, 200]
    elif channel_mode == 'I':
        values = [-1, 1]
    else:
        raise ValueError(
            'Channel is not in V or I mode. It might be disabled.')
    return values


def valid_compliance(channel_mode):
    if channel_mode == 'I':
        values = [-200, 200]
    elif channel_mode == 'V':
        values = [-1, 1]
    else:
        raise ValueError(
            'Channel is not in V or I mode. It might be disabled.')
    return values
"
268,https://download.tek.com/datasheet/AFG3000C-Arbitrary-Function-Generator-Datasheet-75W282817.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attKlkCBf7LpB2VDF'), ('width', 1536), ('height', 904), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3BcUV6rrclQ9nu7wrRQDiw/qQwTNDuHsv4ogAqD7So9dVfyGJx-Img82MpRyMg4J0Fvfg5DVDLshO2Uornv2pvFdtrZEdh3FxZs2iJ9QqBcPHZAaGwEEE1JDepLsh0PXs8/ZNZtK2USbTojhu7lpGSV08PkKg-AsKsGolODylP0V8M'), ('filename', 'TEKAFG3152C-1.jpg'), ('size', 153756), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/VI_iFeuumJIEImXF4PLG2A/4vLR7ZJj_Tht1NLu9SFDrl_MxATV-xyjdkx1xAliI1_R3_w67VwlgA_jBBg8j8Tus6D4C9di2QRubPZAd54Zbg/Rt-9V07Hucz6L6oxqPhjX1x5r3HUo8uys1XYoQ7TcQs'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iR-3khoNcgqgSZXW6NGJkQ/FeQcT-8ZsEAb3istYXbdcN0YcYKuwtkJ3ObzT1-pabFocepa7qebSaC767BDLIHGAaYcODqlu51V_ZlV-cmSyA/yQEVe648Tyy8jj5nAn9upA_Z6nACBMcSK6qGk-MzgHo'), ('width', 870), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CBpNchYh04kq8_Su2-1AHg/KV-fiwHao7saF4NbG37IfViJyMUh3H6qxAKi5LsQU2WdJpCPxk4X4JQneLyt850ZnPyYBU6jMyW0_7w7WGuElw/H6gIm0U4TP9ZJy4GoQOukPHRC27TwUuMkqyIQ4x2i28'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125954/Instruments/Vendor%20Logos/Tektronix.png,"Users can choose from 12 different standard waveforms. Arbitrary waveforms can be generated up to 128 K in length at high sampling rates. On pulse waveforms, leading and trailing edge time can be set independently. External signals can be connected and added to the output signal. Dual-channel models can generate two identical or completely different signals. All instruments feature a highly stable time base with only ±1 ppm drift per year.",https://www.tek.com/en/datasheet/afg3000c-arbitrary-function-generator-datasheet,AFG 3152 C,541.0,['Function Generators'],"a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/tektronix/afg3152c.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/tektronix/afg3152c.html,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ncqYTpCtyDgdWNdxxXDBxQ/Q7s8z5oXvi6tbq1k33cFybfUx65eOtyRpi2AGinb2-4pWCEF1EzDGGvh1z0JmjdS_dxy3aSul7X37GzqPsgwzw/jZ-fcCg7RXdfMpf_D8YV0ndU2j_WeWmVq4hC8PoCy4E'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/iHRpskxb3G5hx41M1oQZfw/YdiiK_N_Lop4tXtCss_KcJjIoAMTMc1JBgdfUngO3puIGnRJVM2mF6P8WVnOXsz3UazWK6pz1LoH4rKO0mU23Q/H6AaavXtygbw4-juPmpUfFT5UfsuVO3UetdLjEweEvE'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IU_23iBA0g9FT8E2azeqxw/8C4VKiC_AscdAe_Wd2rrlxJMc23TMWGalGpBEMTMUqw33xYTPXSMngZwDB8RQeavfLQfLJMuDnUW0sjU9S_mlg/rtTLjxlZzLzyXkZ6nfk2hlF4hQiOCBBb80gLBjrcRuE'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vEju0pVXhXnaWLF_R16W_w/DZzMrCWT2kS8UQsJqrkzaa8sxMDE3CmBk9ciezGf6rYGCk6hab198F_U3s9hzsEcMfxYTFwuSBjrBttxGufGVA/kybZevWjhDAGwOb99KdfFBbmlDHsNDDklb8moPeRljw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782664/Instruments/Function%20Generators/AFG3152C/AFG3152C.jpg,AFG3152C,Write a Python script that uses Pymeasure to connect to a AFG3152C Function Generators,8550.0,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from math import sqrt, log10
from pymeasure.instruments import Instrument, Channel
from pymeasure.instruments.validators import strict_range, strict_discrete_set


class AFG3152CChannel(Channel):
    SHAPES = {
        ""sinusoidal"": ""SIN"",
        ""square"": ""SQU"",
        ""pulse"": ""PULS"",
        ""ramp"": ""RAMP"",
        ""prnoise"": ""PRN"",
        ""dc"": ""DC"",
        ""sinc"": ""SINC"",
        ""gaussian"": ""GAUS"",
        ""lorentz"": ""LOR"",
        ""erise"": ""ERIS"",
        ""edecay"": ""EDEC"",
        ""haversine"": ""HAV"",
    }
    FREQ_LIMIT = [1e-6, 150e6]  # Frequeny limit for sinusoidal function
    DUTY_LIMIT = [0.001, 99.999]
    AMPLITUDE_LIMIT = {
        ""VPP"": [20e-3, 10],
        ""VRMS"": list(map(lambda x: round(x / 2 / sqrt(2), 3), [20e-3, 10])),
        ""DBM"": list(
            map(lambda x: round(20 * log10(x / 2 / sqrt(0.1)), 2), [20e-3, 10])
        ),
    }  # Vpp, Vrms and dBm limits
    UNIT_LIMIT = [""VPP"", ""VRMS"", ""DBM""]
    IMP_LIMIT = [1, 1e4]

    shape = Instrument.control(
        ""function:shape?"",
        ""function:shape %s"",
        """""" A string property that controls the shape of the output.
            This property can be set."""""",
        validator=strict_discrete_set,
        values=SHAPES,
        map_values=True,
    )

    unit = Instrument.control(
        ""voltage:unit?"",
        ""voltage:unit %s"",
        """""" A string property that controls the amplitude unit.
            This property can be set."""""",
        validator=strict_discrete_set,
        values=UNIT_LIMIT,
    )

    amp_vpp = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eVPP"",
        """""" A floating point property that controls the output amplitude
            in Vpp. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""VPP""],
    )

    amp_dbm = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eDBM"",
        """""" A floating point property that controls the output amplitude
            in dBm. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""DBM""],
    )

    amp_vrms = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eVRMS"",
        """""" A floating point property that controls the output amplitude
            in Vrms. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""VRMS""],
    )

    offset = Instrument.control(
        ""voltage:offset?"",
        ""voltage:offset %e"",
        """""" A floating point property that controls the amplitude
            offset. It is always in Volt. This property can be set."""""",
    )

    frequency = Instrument.control(
        ""frequency:fixed?"",
        ""frequency:fixed %e"",
        """""" A floating point property that controls the frequency.
            This property can be set."""""",
        validator=strict_range,
        values=FREQ_LIMIT,
    )

    duty = Instrument.control(
        ""pulse:dcycle?"",
        ""pulse:dcycle %.3f"",
        """""" A floating point property that controls the duty
            cycle of pulse. This property can be set."""""",
        validator=strict_range,
        values=DUTY_LIMIT,
    )

    impedance = Instrument.control(
        ""output:impedance?"",
        ""output:impedance %d"",
        """""" A floating point property that controls the output
            impedance of the channel. Be careful with this.
            This property can be set."""""",
        validator=strict_range,
        values=IMP_LIMIT,
        cast=int,
    )

    def insert_id(self, command):
        """"""Prepend the channel id for most writes.""""""
        return f'source{self.id}:{command}'

    def enable(self):
        self.parent.write(""output%d:state on"" % self.number)

    def disable(self):
        self.parent.write(""output%d:state off"" % self.number)

    def waveform(
        self, shape=""SIN"", frequency=1e6, units=""VPP"", amplitude=1, offset=0
    ):
        """"""General setting method for a complete wavefunction""""""
        self.write(""function:shape %s"" % shape)
        self.write(""frequency:fixed %e"" % frequency)
        self.write(""voltage:unit %s"" % units)
        self.write(""voltage:amplitude %e%s"" % (amplitude, units))
        self.write(""voltage:offset %eV"" % offset)


class AFG3152C(Instrument):
    """"""Represents the Tektronix AFG 3000 series (one or two channels)
    arbitrary function generator and provides a high-level for
    interacting with the instrument.

    .. code-block:: python

        afg=AFG3152C(""GPIB::1"")        # AFG on GPIB 1
        afg.reset()                    # Reset to default
        afg.ch1.shape='sinusoidal'     # Sinusoidal shape
        afg.ch1.unit='VPP'             # Sets CH1 unit to VPP
        afg.ch1.amp_vpp=1              # Sets the CH1 level to 1 VPP
        afg.ch1.frequency=1e3          # Sets the CH1 frequency to 1KHz
        afg.ch1.enable()               # Enables the output from CH1
    """"""

    def __init__(self, adapter, name=""Tektronix AFG3152C arbitrary function generator"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ch1 = AFG3152CChannel(self, 1)
        self.ch2 = AFG3152CChannel(self, 2)

    def beep(self):
        self.write(""system:beep"")

    def opc(self):
        return int(self.ask(""*OPC?""))
"
279,https://www.thinksrs.com/downloads/pdfs/catalog/SR860c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attQcGYgznsQTMwiU'), ('width', 4428), ('height', 2540), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/84Y6I4MoZ5AvfD5-QpQY9A/QEp4xG-MPMs71NYDk_0sAAZ8v_3S47CX0SXQKxuzjiDs7uWvtUTxkC_NeOWc49WZpLq39lDA7S2p2eCbkWp7EvykEMuBE_n2K9wVpE4IISA/5n1qtFp2zIozl4tdbe-3nGxklX7gprnQTPa8CORM_BI'), ('filename', 'SR860_Lt_Wide.jpg'), ('size', 2290334), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Lqn2Pj4mBpt2HUIhsU42bQ/j5LlY-ZNMbe2OnW6lyvBKapu6PzVHTcM2UdVn2fbQ7yuL4cNhuYhOtkGTsuUVPweLJkpUvPfiPjZoxk2Rqos4A/mR3NBcCHpUjNJUqZ4RwSyGQHr_sLhtsOXwQ0ohfhmN8'), ('width', 63), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/t0PGisO4k4pdUnDMvBXV6Q/RMjTOGy5zId75ifN1xPtvDuz4ajqurskyCP6DA63YhXkDpGW4J9JSUXD9U40A12vJ87cKjRLFhYQqMnUXXhS-g/jYQGocQ0dQaaxIIw1kVXQgpE73HdNqUeQCLhZsHGjOI'), ('width', 893), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/NsxFTVf5zd6qtI0-5wnMZg/O7umToc489diKtzHI0IH2qZqAuggcAyMLS_WjPc0aKWI8MFNoIfj4eKHJtt2aGWgt9oeR6nj0wfKw9uCKuadtw/oVYONsfau-cgUD8Myq4rcweB8C6Fbt9STvI-FyDsLhk'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,"The new SR860 Lock-in Amplifier is the latest in a line of innovative lock-ins from SRS. With unparalleled analog performance, sophisticated new digital signal processing features, a thoroughly modern, intuitive user interface, and a wide range of computer connectivity options, the SR860 is the ideal choice for any synchronous detection application.",https://www.thinksrs.com/products/sr860.html,SR 860,522.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr860.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr860.html,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782674/Instruments/Lockin%20Amplifiers/SR-860/SR-860.jpg,SR 860,Write a Python script that uses Pymeasure to connect to a SR 860 Lockin Amplifiers,6495.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range
from pymeasure.instruments import Instrument


class SR860(Instrument):

    SENSITIVITIES = [
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9,
        500e-9, 1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6,
        200e-6, 500e-6, 1e-3, 2e-3, 5e-3, 10e-3, 20e-3,
        50e-3, 100e-3, 200e-3, 500e-3, 1
    ]
    TIME_CONSTANTS = [
        1e-6, 3e-6, 10e-6, 30e-6, 100e-6, 300e-6, 1e-3, 3e-3, 10e-3,
        30e-3, 100e-3, 300e-3, 1, 3, 10, 30, 100, 300, 1e3,
        3e3, 10e3, 30e3
    ]
    ON_OFF_VALUES = ['0', '1']
    SCREEN_LAYOUT_VALUES = ['0', '1', '2', '3', '4', '5']
    EXPANSION_VALUES = ['0', '1', '2,']
    CHANNEL_VALUES = ['OCH1', 'OCH2']
    OUTPUT_VALUES = ['XY', 'RTH']
    INPUT_TIMEBASE = ['AUTO', 'IN']
    INPUT_DCMODE = ['COM', 'DIF', 'common', 'difference']
    INPUT_REFERENCESOURCE = ['INT', 'EXT', 'DUAL', 'CHOP']
    INPUT_REFERENCETRIGGERMODE = ['SIN', 'POS', 'NEG', 'POSTTL', 'NEGTTL']
    INPUT_REFERENCEEXTERNALINPUT = ['50OHMS', '1MEG']
    INPUT_SIGNAL_INPUT = ['VOLT', 'CURR', 'voltage', 'current']
    INPUT_VOLTAGE_MODE = ['A', 'A-B']
    INPUT_COUPLING = ['AC', 'DC']
    INPUT_SHIELDS = ['Float', 'Ground']
    INPUT_RANGE = ['1V', '300M', '100M', '30M', '10M']
    INPUT_GAIN = ['1MEG', '100MEG']
    INPUT_FILTER = ['Off', 'On']
    LIST_PARAMETER = ['i=', '0=Xoutput', '1=Youtput', '2=Routput', 'Thetaoutput', '4=Aux IN1',
                      '5=Aux IN2', '6=Aux IN3', '7=Aux IN4', '8=Xnoise', '9=Ynoise',
                      '10=AUXOut1', '11=AuxOut2', '12=Phase', '13=Sine Out amplitude',
                      '14=DCLevel', '15I=nt.referenceFreq', '16=Ext.referenceFreq']
    LIST_HORIZONTAL_TIME_DIV = ['0=0.5s', '1=1s', '2=2s', '3=5s', '4=10s', '5=30s', '6=1min',
                                '7=2min', '8=5min', '9=10min', '10=30min', '11=1hour', '12=2hour',
                                '13=6hour', '14=12hour', '15=1day', '16=2days']

    x = Instrument.measurement(""OUTP? 0"",
                               """""" Reads the X value in Volts """"""
                               )
    y = Instrument.measurement(""OUTP? 1"",
                               """""" Reads the Y value in Volts """"""
                               )
    magnitude = Instrument.measurement(""OUTP? 2"",
                                       """""" Reads the magnitude in Volts. """"""
                                       )
    theta = Instrument.measurement(""OUTP? 3"",
                                   """""" Reads the theta value in degrees. """"""
                                   )
    phase = Instrument.control(
        ""PHAS?"", ""PHAS %0.7f"",
        """""" A floating point property that represents the lock-in phase
        in degrees. This property can be set. """""",
        validator=truncated_range,
        values=[-360, 360]
    )
    frequency = Instrument.control(
        ""FREQ?"", ""FREQ %0.6e"",
        """""" A floating point property that represents the lock-in frequency
        in Hz. This property can be set. """""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    internalfrequency = Instrument.control(
        ""FREQINT?"", ""FREQINT %0.6e"",
        """"""A floating property that represents the internal lock-in frequency in Hz
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    harmonic = Instrument.control(
        ""HARM?"", ""Harm %d"",
        """"""An integer property that controls the harmonic that is measured.
        Allowed values are 1 to 99. Can be set."""""",
        validator=strict_discrete_set,
        values=range(1, 99)
    )
    harmonicdual = Instrument.control(
        ""HARMDUAL?"", ""HARMDUAL %d"",
        """"""An integer property that controls the harmonic in dual reference mode that is measured.
        Allowed values are 1 to 99. Can be set."""""",
        validator=strict_discrete_set,
        values=range(1, 99)
    )
    sine_voltage = Instrument.control(
        ""SLVL?"", ""SLVL %0.9e"",
        """"""A floating point property that represents the reference sine-wave
        voltage in Volts. This property can be set."""""",
        validator=truncated_range,
        values=[1e-9, 2]
    )

    timebase = Instrument.control(
        ""TBMODE?"", ""TBMODE %d"",
        """"""Sets the external 10 MHZ timebase to auto(i=0) or internal(i=1)."""""",
        validator=strict_discrete_set,
        values=[0, 1],
        map_values=True
    )
    dcmode = Instrument.control(
        ""REFM?"", ""REFM %d"",
        """"""A string property that represents the sine out dc mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_DCMODE),
        validator=strict_discrete_set,
        values=INPUT_DCMODE,
        map_values=True
    )
    reference_source = Instrument.control(
        ""RSRC?"", ""RSRC %d"",
        """"""A string property that represents the reference source.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCESOURCE),
        validator=strict_discrete_set,
        values=INPUT_REFERENCESOURCE,
        map_values=True
    )
    reference_triggermode = Instrument.control(
        ""RTRG?"", ""RTRG %d"",
        """"""A string property that represents the external reference trigger mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCETRIGGERMODE),
        validator=strict_discrete_set,
        values=INPUT_REFERENCETRIGGERMODE,
        map_values=True
    )
    reference_externalinput = Instrument.control(
        ""REFZ?"", ""REFZ&d"",
        """"""A string property that represents the external reference input.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCEEXTERNALINPUT),
        validator=strict_discrete_set,
        values=INPUT_REFERENCEEXTERNALINPUT,
        map_values=True
    )
    input_signal = Instrument.control(
        ""IVMD?"", ""IVMD %d"",
        """"""A string property that represents the signal input.
        This property can be set. Allowed values are:{}"""""".format(INPUT_SIGNAL_INPUT),
        validator=strict_discrete_set,
        values=INPUT_SIGNAL_INPUT,
        map_values=True
    )
    input_voltage_mode = Instrument.control(
        ""ISRC?"", ""ISRC %d"",
        """"""A string property that represents the voltage input mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_VOLTAGE_MODE),
        validator=strict_discrete_set,
        values=INPUT_VOLTAGE_MODE,
        map_values=True
    )
    input_coupling = Instrument.control(
        ""ICPL?"", ""ICPL %d"",
        """"""A string property that represents the input coupling.
        This property can be set. Allowed values are:{}"""""".format(INPUT_COUPLING),
        validator=strict_discrete_set,
        values=INPUT_COUPLING,
        map_values=True
    )
    input_shields = Instrument.control(
        ""IGND?"", ""IGND %d"",
        """"""A string property that represents the input shield grounding.
        This property can be set. Allowed values are:{}"""""".format(INPUT_SHIELDS),
        validator=strict_discrete_set,
        values=INPUT_SHIELDS,
        map_values=True
    )
    input_range = Instrument.control(
        ""IRNG?"", ""IRNG %d"",
        """"""A string property that represents the input range.
        This property can be set. Allowed values are:{}"""""".format(INPUT_RANGE),
        validator=strict_discrete_set,
        values=INPUT_RANGE,
        map_values=True
    )
    input_current_gain = Instrument.control(
        ""ICUR?"", ""ICUR %d"",
        """"""A string property that represents the current input gain.
        This property can be set. Allowed values are:{}"""""".format(INPUT_GAIN),
        validator=strict_discrete_set,
        values=INPUT_GAIN,
        map_values=True
    )
    sensitvity = Instrument.control(
        ""SCAL?"", ""SCAL %d"",
        """""" A floating point property that controls the sensitivity in Volts,
        which can take discrete values from 2 nV to 1 V. Values are truncated
        to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True
    )
    time_constant = Instrument.control(
        ""OFLT?"", ""OFLT %d"",
        """""" A floating point property that controls the time constant
        in seconds, which can take discrete values from 10 microseconds
        to 30,000 seconds. Values are truncated to the next highest
        level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True
    )
    filter_slope = Instrument.control(
        ""OFSL?"", ""OFSL %d"",
        """"""A integer property that sets the filter slope to 6 dB/oct(i=0), 12 DB/oct(i=1),
        18 dB/oct(i=2), 24 dB/oct(i=3)."""""",
        validator=strict_discrete_set,
        values=range(0, 3)
    )
    filer_synchronous = Instrument.control(
        ""SYNC?"", ""SYNC %d"",
        """"""A string property that represents the synchronous filter.
        This property can be set. Allowed values are:{}"""""".format(INPUT_FILTER),
        validator=strict_discrete_set,
        values=INPUT_FILTER,
        map_values=True
    )
    filter_advanced = Instrument.control(
        ""ADVFILT?"", ""ADVFIL %d"",
        """"""A string property that represents the advanced filter.
        This property can be set. Allowed values are:{}"""""".format(INPUT_FILTER),
        validator=strict_discrete_set,
        values=INPUT_FILTER,
        map_values=True
    )
    frequencypreset1 = Instrument.control(
        ""PSTF? 0"", ""PSTF 0, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F1 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset2 = Instrument.control(
        ""PSTF? 1"", ""PSTF 1, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F2 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset3 = Instrument.control(
        ""PSTF? 2"", ""PSTF2, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F3 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset4 = Instrument.control(
        ""PSTF? 3"", ""PSTF3, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F4 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    sine_amplitudepreset1 = Instrument.control(
        ""PSTA? 0"", ""PSTA0, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A1 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset2 = Instrument.control(
        ""PSTA? 1"", ""PSTA1, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A2 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset3 = Instrument.control(
        ""PSTA? 2"", ""PSTA2, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A3 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset4 = Instrument.control(
        ""PSTA? 3"", ""PSTA 3, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A3 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_dclevelpreset1 = Instrument.control(
        ""PSTL? 0"", ""PSTL 0, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L1 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset2 = Instrument.control(
        ""PSTL? 1"", ""PSTL 1, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L2 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset3 = Instrument.control(
        ""PSTL? 2"", ""PSTL 2, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L3 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset4 = Instrument.control(
        ""PSTL? 3"", ""PSTL3, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L4 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )

    aux_out_1 = Instrument.control(
        ""AUXV? 0"", ""AUXV 1, %f"",
        """""" A floating point property that controls the output of Aux output 1 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac1 = aux_out_1

    aux_out_2 = Instrument.control(
        ""AUXV? 1"", ""AUXV 2, %f"",
        """""" A floating point property that controls the output of Aux output 2 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac2 = aux_out_2

    aux_out_3 = Instrument.control(
        ""AUXV? 2"", ""AUXV 3, %f"",
        """""" A floating point property that controls the output of Aux output 3 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac3 = aux_out_3

    aux_out_4 = Instrument.control(
        ""AUXV? 3"", ""AUXV 4, %f"",
        """""" A floating point property that controls the output of Aux output 4 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac4 = aux_out_4

    aux_in_1 = Instrument.measurement(
        ""OAUX? 0"",
        """""" Reads the Aux input 1 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc1 = aux_in_1

    aux_in_2 = Instrument.measurement(
        ""OAUX? 1"",
        """""" Reads the Aux input 2 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc2 = aux_in_2

    aux_in_3 = Instrument.measurement(
        ""OAUX? 2"",
        """""" Reads the Aux input 3 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc3 = aux_in_3

    aux_in_4 = Instrument.measurement(
        ""OAUX? 3"",
        """""" Reads the Aux input 4 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc4 = aux_in_4

    def snap(self, val1=""X"", val2=""Y"", val3=None):
        """"""retrieve 2 or 3 parameters at once
        parameters can be chosen by index, or enumeration as follows:

        +--------+-------------+------------------------+
        | index  | enumeration | parameter              |
        +========+=============+========================+
        | 0      | X           | X output               |
        +--------+-------------+------------------------+
        | 1      | Y           | Y output               |
        +--------+-------------+------------------------+
        | 2      | R           | R output               |
        +--------+-------------+------------------------+
        | 3      | THeta       | θ output               |
        +--------+-------------+------------------------+
        | 4      | IN1         | Aux In1                |
        +--------+-------------+------------------------+
        | 5      | IN2         | Aux In2                |
        +--------+-------------+------------------------+
        | 6      | IN3         | Aux In3                |
        +--------+-------------+------------------------+
        | 7      | IN4         | Aux In4                |
        +--------+-------------+------------------------+
        | 8      | XNOise      | Xnoise                 |
        +--------+-------------+------------------------+
        | 9      | YNOise      | Ynoise                 |
        +--------+-------------+------------------------+
        | 10     | OUT1        | Aux Out1               |
        +--------+-------------+------------------------+
        | 11     | OUT2        | Aux Out2               |
        +--------+-------------+------------------------+
        | 12     | PHAse       | Reference Phase        |
        +--------+-------------+------------------------+
        | 13     | SAMp        | Sine Out Amplitude     |
        +--------+-------------+------------------------+
        | 14     | LEVel       | DC Level               |
        +--------+-------------+------------------------+
        | 15     | FInt        | Int. Ref. Frequency    |
        +--------+-------------+------------------------+
        | 16     | FExt        | Ext. Ref. Frequency    |
        +--------+-------------+------------------------+

        :param val1: parameter enumeration/index
        :param val2: parameter enumeration/index
        :param val3: parameter enumeration/index (optional)

        Defaults:
            val1 = ""X""
            val2 = ""Y""
            val3 = None
        """"""
        if val3 is None:
            return self.values(
                command=f""SNAP? {val1}, {val2}"",
                separator="","",
                cast=float,
            )
        else:
            return self.values(
                command=f""SNAP? {val1}, {val2}, {val3}"",
                separator="","",
                cast=float,
            )

    gettimebase = Instrument.measurement(
        ""TBSTAT?"",
        """"""Returns the current 10 MHz timebase source.""""""
    )
    extfreqency = Instrument.measurement(
        ""FREQEXT?"",
        """"""Returns the external frequency in Hz.""""""
    )
    detectedfrequency = Instrument.measurement(
        ""FREQDET?"",
        """"""Returns the actual detected frequency in HZ.""""""
    )
    get_signal_strength_indicator = Instrument.measurement(
        ""ILVL?"",
        """"""Returns the signal strength indicator.""""""
    )
    get_noise_bandwidth = Instrument.measurement(
        ""ENBW?"",
        """"""Returns the equivalent noise bandwidth, in hertz.""""""
    )
    # Display Commands
    front_panel = Instrument.control(
        ""DBLK?"", ""DBLK %i"",
        """"""Turns the front panel blanking on(i=0) or off(i=1)."""""",
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    screen_layout = Instrument.control(
        ""DLAY?"", ""DLAY %i"",
        """"""A integer property that Sets the screen layout to trend(i=0), full strip chart
        history(i=1), half strip chart history(i=2), full FFT(i=3), half FFT(i=4) or big
        numerical(i=5)."""""",
        validator=strict_discrete_set,
        values=SCREEN_LAYOUT_VALUES,
        map_values=True
    )

    def screenshot(self):
        """"""Take screenshot on device
        The DCAP command saves a screenshot to a USB memory stick.
        This command is the same as pressing the [Screen Shot] key.
        A USB memory stick must be present in the front panel USB port.
        """"""
        self.write(""DCAP"")

    parameter_DAT1 = Instrument.control(
        ""CDSP? 0"", ""CDSP 0, %i"",
        """"""A integer property that assigns a parameter to data channel 1(green).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT2 = Instrument.control(
        ""CDSP? 1"", ""CDSP 1, %i"",
        """"""A integer property that assigns a parameter to data channel 2(blue).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT3 = Instrument.control(
        ""CDSP? 2"", ""CDSP 2, %i"",
        """"""A integer property that assigns a parameter to data channel 3(yellow).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT4 = Instrument.control(
        ""CDSP? 3"", ""CDSP 3, %i"",
        """"""A integer property that assigns a parameter to data channel 3(orange).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    strip_chart_dat1 = Instrument.control(
        ""CGRF? 0"", ""CGRF 0, %i"",
        """"""A integer property that turns the strip chart graph of data channel 1 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat2 = Instrument.control(
        ""CGRF? 1"", ""CGRF 1, %i"",
        """"""A integer property that turns the strip chart graph of data channel 2 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat3 = Instrument.control(
        ""CGRF? 2"", ""CGRF 2, %i"",
        """"""A integer property that turns the strip chart graph of data channel 1 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat4 = Instrument.control(
        ""CGRF? 3"", ""CGRF 3, %i"",
        """"""A integer property that turns the strip chart graph of data channel 4 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    # Strip Chart commands
    horizontal_time_div = Instrument.control(
        ""GSPD?"", ""GSDP %i"",
        """"""A integer property for the horizontal time/div according to the following table:{}
        """""".format(LIST_HORIZONTAL_TIME_DIV),
        validator=strict_discrete_set,
        values=range(0, 16)
    )

    def __init__(self, adapter, name=""Stanford Research Systems SR860 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
281,https://download.tek.com/datasheet/Series2700DAQSystemDataSheet.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'att9stL90e0gFUDnP'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bf8VywKcjhvFeRQSqB5sRg/77Sgs4iD1grodvquHkHrm9yCCoR5ObI5pHUrgDX31L7E99aHvO0sZmcK92Gass0Oaqq3jOR1k5_uBM3Nv0AdVeeiZJRB___f3mY_joaFqYg/_M59Ce_OuxVLgaxYgTapdJzsoOCTKa3KLR0qNAw1Y7E'), ('filename', '2700.webp'), ('size', 9278), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/yfyW9mOMMOzZ-pRdR4FH1w/rGk4PPTQO_IHTuUS26Eiq2IFsTulOSi2RAVBL7MHTTzzSCfiWiSlXXgLYJzmCgvNG4f-Y-fekQHpbx8v-VDJB-ly9qW-SiLjvkKBeMq7k2s/IyHTlHm6_r18fN1axdOMXrJAqlg6FToYN9Mf_Ae_YGc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OWAo4YaSHXJkWpUUB1dU_A/qW6bQWOdoAcSw2ko-Gthm957YtgGrMNDDXZ4lMzff6-vTnhrAv3EOjzXegTS4fhj0tFMJ5Qjc2rqrm__dAMtyqIgdhI6xZI3Yry8ab2C_fo/LZlIFoECKJ8Ikuqdz9QnM7qy0xAw67ly55uAKd55EAQ'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9VLy3tbdtP0MFfgwXUtM4Q/hYbAn72CL6-1Oj9ddQ8dbt8cTugg_7E792F6T4EVqbBUg-Ub0Ds5yqu5BTI5M3dnDlSJq9NHS5Ol0f_4G1SL1NLIcC1y_WqWLvqRZo0sMkk/kev5XdGwyvt40jYG-_s04WpM-08U_HvGvkhHmKKF-ro'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Model 2750 offers extended low ohms measurement capability and supports up to 5 7700 Switch cards for a maximum 200, 2-pole multiplexed channels. It also contains a built-in 20mV clamp that helps protect sensitive devices from damage and prevents self-heating errors during dry circuit testing.",https://www.tek.com/en/products/keithley/switching-and-data-acquisition-systems/2700-multimeter-data-acquisition-switch-system,Keithley 2700,260.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2700.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2700.html,Keithley,"[OrderedDict([('id', 'attvnuMuhTf4JYn8N'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mppzMHztVr1YzwtKvkQTXw/Kk6mxgpOzQUOkRNEpRSQdOvmLxC3av1WcbyPr9zoZOt9b6zXwP3ihEdhZ2z8yG9kDWWmc4XxS3ntqg4pQZSlr6B8XwTKA7ozAglOts1lHRbTRqgVNUax7h-5Ni1pZNOIjjqy6jcZNYcan3b-hKI2qQ/0aAMWyCD1ZO3CgmluidKkCeCJBfuPQj6YT2A0-trfK0'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vUKW-3G0Ymmi4HnNxpbFgQ/ZOsyXF_bRZ8MoQBftfv-C8nrybogFWO5FwbyChcsTFjMG-NhB1TpP1ZTAhhLJPQ0OT1GwvyR3UslMOTUnsU5GQ/n79m7rsTIOobAQ-IlS1pmkA5szi64BwJhAn3OKV4Ey0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cDP6Pet1vfzOCU9eaOInvA/OmaIc0EvIYvf5j-WsLhmryT-qbMpmkRkgJ1AtnkVmsR8dzF3CRw-5ufMHMbtTQz2x-najfjLeZeMlXfrgqP-kQ/i5UJRk-Uh_-vLuFPehLupzAPSDObm4FS1AEy6JF9ZGA'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6JlKNneDMUkjAy2apyt9qw/Wk4LN8PUG8hxGDyCuqJufTsPDponQMSWXt32pioMwJEzCl6kOb54ud5CRX_NLqJhZYPXhfHrT1ElwzHCrVW5Ow/ua4lEP6GwrhUJXKro33wAbSwG-lcb1KActcBy8_KBTU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782676/Instruments/Multimeters/Keithley-2700/Keithley-2700.webp,Keithley 2700,Write a Python script that uses Pymeasure to connect to a Keithley 2700 Multimeters,4220.0,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument

from .buffer import KeithleyBuffer

import numpy as np
import time

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def clist_validator(value, values):
    """""" Provides a validator function that returns a valid clist string
    for channel commands of the Keithley 2700. Otherwise it raises a
    ValueError.

    :param value: A value to test
    :param values: A range of values (range, list, etc.)
    :raises: ValueError if the value is out of the range
    """"""
    # Convert value to list of strings
    if isinstance(value, str):
        clist = [value.strip("" @(),"")]
    elif isinstance(value, (int, float)):
        clist = [f""{value:d}""]
    elif isinstance(value, (list, tuple, np.ndarray, range)):
        clist = [f""{x:d}"" for x in value]
    else:
        raise ValueError(f""Type of value ({type(value)}) not valid"")

    # Pad numbers to length (if required)
    clist = [c.rjust(2, ""0"") for c in clist]
    clist = [c.rjust(3, ""1"") for c in clist]

    # Check channels against valid channels
    for c in clist:
        if int(c) not in values:
            raise ValueError(
                f""Channel number {value:g} not valid.""
            )

    # Convert list of strings to clist format
    clist = ""(@{:s})"".format("", "".join(clist))

    return clist


def text_length_validator(value, values):
    """""" Provides a validator function that a valid string for the display
    commands of the Keithley. Raises a TypeError if value is not a string.
    If the string is too long, it is truncated to the correct length.

    :param value: A value to test
    :param values: The allowed length of the text
    """"""

    if not isinstance(value, str):
        raise TypeError(""Value is not a string."")

    return value[:values]


class Keithley2700(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2700 Multimeter/Switch System and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2700(""GPIB::1"")

    """"""

    CLIST_VALUES = list(range(101, 300))

    # Routing commands
    closed_channels = Instrument.control(
        ""ROUTe:MULTiple:CLOSe?"", ""ROUTe:MULTiple:CLOSe %s"",
        """""" Parameter that controls the opened and closed channels.
        All mentioned channels are closed, other channels will be opened.
        """""",
        validator=clist_validator,
        values=CLIST_VALUES,
        check_get_errors=True,
        check_set_errors=True,
        separator=None,
        get_process=lambda v: [
            int(vv) for vv in (v.strip("" ()@,"").split("","")) if not vv == """"
        ],
    )

    open_channels = Instrument.setting(
        ""ROUTe:MULTiple:OPEN %s"",
        """""" A parameter that opens the specified list of channels. Can only
        be set.
        """""",
        validator=clist_validator,
        values=CLIST_VALUES,
        check_set_errors=True
    )

    def get_state_of_channels(self, channels):
        """""" Get the open or closed state of the specified channels

        :param channels: a list of channel numbers, or single channel number
        """"""
        clist = clist_validator(channels, self.CLIST_VALUES)
        state = self.ask(""ROUTe:MULTiple:STATe? %s"" % clist)

        return state

    def open_all_channels(self):
        """""" Open all channels of the Keithley 2700.
        """"""
        self.write("":ROUTe:OPEN:ALL"")

    def __init__(self, adapter, name=""Keithley 2700 MultiMeter/Switch System"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

        self.check_errors()
        self.determine_valid_channels()

    def determine_valid_channels(self):
        """""" Determine what cards are installed into the Keithley 2700
        and from that determine what channels are valid.
        """"""
        self.CLIST_VALUES.clear()

        self.cards = {slot: card for slot, card in enumerate(self.options, 1)}

        for slot, card in self.cards.items():

            if card == ""none"":
                continue
            elif card == ""7709"":
                """"""The 7709 is a 6(rows) x 8(columns) matrix card, with two
                additional switches (49 & 50) that allow row 1 and 2 to be
                connected to the DMM backplane (input and sense respectively).
                """"""
                channels = range(1, 51)
            else:
                log.warning(
                    f""Card type {card} at slot {slot} is not yet implemented.""
                )
                continue

            channels = [100 * slot + ch for ch in channels]

            self.CLIST_VALUES.extend(channels)

    def close_rows_to_columns(self, rows, columns, slot=None):
        """""" Closes (connects) the channels between column(s) and row(s)
        of the 7709 connection matrix.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used
        """"""

        channels = self.channels_from_rows_columns(rows, columns, slot)
        self.closed_channels = channels

    def open_rows_to_columns(self, rows, columns, slot=None):
        """""" Opens (disconnects) the channels between column(s) and row(s)
        of the 7709 connection matrix.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used
        """"""

        channels = self.channels_from_rows_columns(rows, columns, slot)
        self.open_channels = channels

    def channels_from_rows_columns(self, rows, columns, slot=None):
        """""" Determine the channel numbers between column(s) and row(s) of the
        7709 connection matrix. Returns a list of channel numbers.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used

        """"""

        if slot is not None and self.cards[slot] != ""7709"":
            raise ValueError(""No 7709 card installed in slot %g"" % slot)

        if isinstance(rows, str) and isinstance(columns, str):
            raise ValueError(""Only one parameter can be 'all'"")
        elif isinstance(rows, str) and rows == ""all"":
            rows = list(range(1, 7))
        elif isinstance(columns, str) and columns == ""all"":
            columns = list(range(1, 9))

        if isinstance(rows, (list, tuple, np.ndarray)) and \
                isinstance(columns, (list, tuple, np.ndarray)):

            if len(rows) != len(columns):
                raise ValueError(""The length of the rows and columns do not match"")

            # Flatten (were necessary) the arrays
            new_rows = []
            new_columns = []
            for row, column in zip(rows, columns):
                if isinstance(row, int) and isinstance(column, int):
                    new_rows.append(row)
                    new_columns.append(column)
                elif isinstance(row, (list, tuple, np.ndarray)) and isinstance(column, int):
                    new_columns.extend(len(row) * [column])
                    new_rows.extend(list(row))
                elif isinstance(column, (list, tuple, np.ndarray)) and isinstance(row, int):
                    new_columns.extend(list(column))
                    new_rows.extend(len(column) * [row])

            rows = new_rows
            columns = new_columns

        # Determine channel number from rows and columns number.
        rows = np.array(rows, ndmin=1)
        columns = np.array(columns, ndmin=1)

        channels = (rows - 1) * 8 + columns

        if slot is not None:
            channels += 100 * slot

        return channels

    # system, some taken from Keithley 2400
    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2700 reported error: %d, %s"" % (code, message))
            print(code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2700 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    options = Instrument.measurement(
        ""*OPT?"",
        """"""Property that lists the installed cards in the Keithley 2700.
        Returns a dict with the integer card numbers on the position."""""",
        cast=False
    )

    ###########
    # DISPLAY #
    ###########

    text_enabled = Instrument.control(
        ""DISP:TEXT:STAT?"", ""DISP:TEXT:STAT %d"",
        """""" A boolean property that controls whether a text message can be
        shown on the display of the Keithley 2700.
        """""",
        values={True: 1, False: 0},
        map_values=True,
    )
    display_text = Instrument.control(
        ""DISP:TEXT:DATA?"", ""DISP:TEXT:DATA '%s'"",
        """""" A string property that controls the text shown on the display of
        the Keithley 2700. Text can be up to 12 ASCII characters and must be
        enabled to show.
        """""",
        validator=text_length_validator,
        values=12,
        cast=str,
        separator=""NO_SEPARATOR"",
        get_process=lambda v: v.strip(""'\""""),
    )

    def display_closed_channels(self):
        """""" Show the presently closed channels on the display of the Keithley
        2700.
        """"""

        # Get the closed channels and make a string of the list
        channels = self.closed_channels
        channel_string = "" "".join([
            str(channel % 100) for channel in channels
        ])

        # Prepend ""Closed: "" or ""C: "" to the string, depending on the length
        str_length = 12
        if len(channel_string) < str_length - 8:
            channel_string = ""Closed: "" + channel_string
        elif len(channel_string) < str_length - 3:
            channel_string = ""C: "" + channel_string

        # enable displaying text-messages
        self.text_enabled = True

        # write the string to the display
        self.display_text = channel_string
"
288,https://www.keysight.com/us/en/assets/7018-01235/data-sheets/5989-1330.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attRSrjrFB1ceymam'), ('width', 1584), ('height', 1584), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HLZ3ifKO884Ci5gyiPCfwA/WXuhHl9Ioe9XqlHsu_fgMIhibQkKaTVKlKwraNdUqUGX6YwKpn_5m8MSEflpD2b8N1iKCmqXi4hOAMDFMujvDp72ckD49SeRHqQGLiSKyF0/HCHVmsQc5oHxDRlo1GSwxnm33XVEjNAxOhu77Nsb7Zs'), ('filename', 'KTAN5767A.webp'), ('size', 26910), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xULMDbgDyFOs3Oi6iJGmTg/girAWm0yfMf88_A384xH1ooTGejhmKKi78PhdNjBBDAow8Sb73bK_RhchXqIzktQZfNr4gZZxerMbDbUw_0PL6NoL-utIWBgUX9lF3ZJ338/DcO0iwWPRLhREuZK_p3mSbwJsu-DwDOqGS-DmRkuKJQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/F706yF1q76N9IgBo8BxHZQ/NRfWX7jPgHX3Bx2fNRXfGC5UDRqBX0xa3tDC_ZF6sIz7UwyAkDHpmoQWufPNm76vtm3oGSxf0v59ZlVy7mrgsh9WIkx40pIDtr-xCTyWurs/xTLuTdBdEfOiTR8-mF42yXuYmWAnx3pZcPs8hvgtYFs'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Y_2pgH5pbd28ZSXhAbRRgQ/VJnt-T5wwQrDtuHBuh-IdNTexBjXdrQQvXBosLGeefQpvqfDum0XwE-0IHrUvfAXUjt-1vfzW_PlTEZRkcUwljjj6-fS63p1JwMdVaJ-8i8/fmnLlkG4aDXxlmPcd0J36Ru_-ANwBrKgnD4iB2bBfOc'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125973/Instruments/Vendor%20Logos/Keysight.png,"The single output, 1500 W N5767A, provides universal AC input, GPIB, LAN, USB, LXI compliance, and analog/resistance control of output voltage and current. It delivers reliable performance and enhanced capabilities in a compact 1U package.","https://www.keysight.com/us/en/product/N5767A/power-supply-60v-25a-1500w.html#:~:text=The%20single%20output%2C%201500%20W%20N5767A%2C%20provides%20universal%20AC%20input,free%20to%20control%20your%20instruments.",Keysightn 5767a,318.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightN5767A.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keysight/keysightN7776C.html,Keysight,"[OrderedDict([('id', 'att0DZYgk9msHCxq0'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lorDf0cJueFEQgfunYbnRg/Z9WH0Q399TWE836VV4XxOZREWos_7pZDQ3y0iYLxH8mNPDjE4IaVZr8qzw5hvvAnl8nUdqabUhKeO_PY1qSyKl7n1xDzKdezdSJjl4wPAxk/oPWq1ugLFkHzTpKZJ8mg4rP0HmoqXlbSL-MbDUr4ERY'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7eUwlaHCYDav9YBQeYj1-Q/fvrpevSccnhYSIgzPgj4oFLlTG-EnpronvfZtScX45JaD3cw3cmxU6oMqnOyuPc1SzVqcdxW5K_YbtaRFfGPgt6oiLegQAUue4KkDfochHc/wL8ZA187LkZA_4qYA3kpbKfCT1qGHHVwKf3vaD_mu-U'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pD9TBna4ql8asR1_enw5fg/6pTKBAZ_2bY3TGoGR8GNA4njlsr1ItYduqc7PqFqNJu8QDvvvaBYAG2d1oadE78DzFAunHWeHkH-q8zs2l1kz2VlFYm3OYUx-A20PyWeC3Y/SnV2qfsTNUxAlSH9DdvMNW_in-yBTzAfkXrw7osn-Ik'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/T8axACYgvy-T-Q1dXiTtiw/KLoabNQzICjuOcD7sE6ISDjzGtAUtH7Dc447ltw87Uol4NlAQae3enuEjpyXhLoRSZWZjTHUhWGmLgrH0QC27PccCPdgG2HL58ssX7qBR94/59e--QgC5qLdZwrd97FDEU4fWlm28TPuWuSYEJsu6t8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782680/Instruments/Power%20Supplies/Keysight-N5767A/Keysight-N5767A.webp,Keysight N5767A,Write a Python script that uses Pymeasure to connect to a Keysight N5767A Power Supplies,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

from pymeasure.adapters import VISAAdapter

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class KeysightN5767A(Instrument):
    """""" Represents the Keysight N5767A Power supply
    interface for interacting with the instrument.
    """"""
    ###############
    # Current (A) #
    ###############
    current_range = Instrument.control(
        "":CURR?"", "":CURR %g"",
        """""" A floating point property that controls the DC current range in
        Amps, which can take values from 0 to 25 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 25],
    )

    current = Instrument.measurement("":MEAS:CURR?"",
                                     """""" Reads a setting current in Amps. """"""
                                     )

    ###############
    # Voltage (V) #
    ###############
    voltage_range = Instrument.control(
        "":VOLT?"", "":VOLT %g V"",
        """""" A floating point property that controls the DC voltage range in
        Volts, which can take values from 0 to 60 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 60]
    )

    voltage = Instrument.measurement(""MEAS:VOLT?"",
                                     """""" Reads a DC voltage measurement in Volts. """"""
                                     )

    #################
    # _status (0/1) #
    #################
    _status = Instrument.measurement("":OUTP?"",
                                     """""" Read power supply current output status. """""",
                                     )

    def enable(self):
        """""" Enables the flow of current.
        """"""
        self.write("":OUTP 1"")

    def disable(self):
        """""" Disables the flow of current.
        """"""
        self.write("":OUTP 0"")

    def is_enabled(self):
        """""" Returns True if the current supply is enabled.
        """"""
        return bool(self._status)

    def __init__(self, adapter, name=""Keysight N5767A power supply"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        # Set up data transfer format
        if isinstance(self.adapter, VISAAdapter):
            self.adapter.config(
                is_binary=False,
                datatype='float32',
                converter='f',
                separator=','
            )
"
296,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/sUZnDIX-8nieD32jgr252w/NhhE9m3ihZmrN4xBUJbE4bLraR6GhpZ9j2r86wtmzw4w5VcGFpCZNCGI4yfU4bQBJ2_2HkrpMbG7n4U89RkfgQ/oKrWP5d3wFCxfQ1kNk4aE7tM78nJ98EiooiuXagcrWw'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2E0xpl91STbOPloNM64YQg/ph68iyo88kgu5nTF8w1wNmfuTNTMaovNyKmp6OMpg1j6e1dAK7gfzFAYUQEchvXleCZTFyKmAIpo9ikGP5fS0A/OhBlcoz33Nh4sRDaShARRqaWxUTh9xgwcHo2SWb00So'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rvL36QIOaxSBHW7djFWrgA/8boUIpHc8MC5pX-ZdFI7y3Qh7qMDf8Gnr2mQyKpaKoWWH5IqPhIPmAH19foOpsgUoW8go7Nb07NWsL6r9UdAew/l5B6MQfM7RMooMxyFdXtKKmRrRlhSZY9EngXo7cgC8Q'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/01SYOrKqyi853H_pFc-JIQ/wazv5KyO_3KHAoTzMn0HXVrBXDgBW3arSoyutV79748ntCc-OO9rsORV-a4M8uJDEF-wuiufipt0Xh5MTkJHmQ/g8wIFutcEGvsyV0UhUsp486hiJn7FBrDVapWAqR6UIE'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,Keithley 2450,217.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2450.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2450.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782527/Instruments/Power%20Supplies/Keithley-2450/Keithley-2450.png,Keithley 2450,Write a Python script that uses Pymeasure to connect to a Keithley 2450 Power Supplies,9549.3,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set
from .buffer import KeithleyBuffer

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2450(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2450 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2450(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2450.apply_current` and :meth:`~.Keithley2450.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    compliance_current = Instrument.control(
        "":SOUR:VOLT:ILIM?"", "":SOUR:VOLT:ILIM %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """"""
    )

    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current_delay = Instrument.control(
        "":SOUR:CURR:DEL?"", "":SOUR:CURR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_current_delay_auto = Instrument.control(
        "":SOUR:CURR:DEL:AUTO?"", "":SOUR:CURR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    compliance_voltage = Instrument.control(
        "":SOUR:CURR:VLIM?"", "":SOUR:CURR:VLIM %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage_delay = Instrument.control(
        "":SOUR:VOLT:DEL?"", "":SOUR:VOLT:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_voltage_delay_auto = Instrument.control(
        "":SOUR:VOLT:DEL:AUTO?"", "":SOUR:VOLT:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )

    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    wires = Instrument.control(
        "":SENS:RES:RSENSE?"", "":SENS:RES:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    means = Instrument.measurement(
        "":TRACe:STATistics:AVERage?"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )

    maximums = Instrument.measurement(
        "":TRACe:STATistics:MAXimum?"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    minimums = Instrument.measurement(
        "":TRACe:STATistics:MINimum?"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    standard_devs = Instrument.measurement(
        "":TRACe:STATistics:STDDev?"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Filters #
    ###########

    current_filter_type = Instrument.control(
        "":SENS:CURR:AVER:TCON?"", "":SENS:CURR:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    current_filter_count = Instrument.control(
        "":SENS:CURR:AVER:COUNT?"", "":SENS:CURR:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    current_filter_state = Instrument.control(
        "":SENS:CURR:AVER?"", "":SENS:CURR:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    voltage_filter_type = Instrument.control(
        "":SENS:VOLT:AVER:TCON?"", "":SENS:VOLT:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    voltage_filter_count = Instrument.control(
        "":SENS:VOLT:AVER:COUNT?"", "":SENS:VOLT:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    #####################
    # Output subsystem #
    #####################

    current_output_off_state = Instrument.control(
        "":OUTP:CURR:SMOD?"", "":OUTP:CURR:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    voltage_output_off_state = Instrument.control(
        "":OUTP:VOLT:SMOD?"", "":OUTP:VOLT:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2450 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2450.current_range` value or None
        """"""
        log.info(""%s is sourcing current."", self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2450.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2450 reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2450 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger.
        """"""
        return self.write(""*TRG"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
304,https://www.farnell.com/datasheets/1484285.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attWJFDYwrGd2bp0z'), ('width', 320), ('height', 181), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pk3-5QILylEYmYhT-igFWg/_0xwF3kniQy-DcnDon8E0DxUW6MFt0efhFIZ5-tnahCWumOY4AUh_cHCIU3MkDaDrutbMzTuFrPbGvLd3iFcAfcSYY4E-cWi06hkVMLqcQY/qxDT4zGDtGR8Utz4cjd7QgWlcoSESFfxudWO64kR7Jg'), ('filename', '2750.webp'), ('size', 3144), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/5aGcXQSgQfOlPTp__AMemg/n1FA4_A-VGVUvsVI7Y2avYGSOsligsoFort3jr8b97CgjLmk_awDSFScm5g62NgUIAYOD9K73UpegNkfsTG2BBgeb_xAqiTr9Z652q0lWx4/ovCtRzFP5udSHwRmHN2Iu53O-WCqKEJ-czQZv5QE1FI'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pQOwdl1khKOrayedrzQr3Q/xeBhvUujW1YYxz0Iv5yxHmK5uJOOG5MdSqakhyrqx6gOsjMf7xCrkpjQqb_2youu1A15cnsQE3Qbfe7548XjY5XU3H92CK8tC-ttSig_92Y/fl7LFGsf78sxQok4OA5iZwH0k--49nmGFmrrBjU6m_s'), ('width', 320), ('height', 181)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/O86fHo3eeuC3brVbPcknRA/DVomp6vc0P24Z92gP2UxHF0tbVuBWvNi1lcJLQndqow7oFjltDxbF7ZXAyb3gm_BGMZyvbOjoz-XtK6KEI1UUAy30VVe_oHjW-skC89xoW0/WIY9HqaI7SjRHug0f3MqcP_Tp8Hd0b4iqEKLMvJL-fk'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The 2750 offers a cost-effective, high performance, affordable alternatives to separate digital multimeters and switch systems, dataloggers/recorders, plug-in card data acquisition equipment, and VXI/PXI systems. System builders can create test solutions with a combination of channel count, cost per channel, and system performance unmatched by any other singlebox measurement system. The input modules provide the flexibility to vary the channel count from 20 to 200 (2-pole), apply a stimulus to the device under test, route signals, control system components, and make precision measurements with up to 14 functions. Robust digital I/O capabilities can be used for triggering, handshaking with other automation equipment, and alarm limit outputs. Scan rates of up to 500 channels/second (up to 3500 readings/second on a single channel) will increase test productivity.",https://www.newark.com/keithley/2750/digital-multimeter-dmm-data-acq/dp/11J1599?pf_custSiteRedirect=true,Keithley 2750,259.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2750.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2750.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782695/Instruments/Multimeters/Keithley-2750/Keithley-2750.webp,Keithley 2750,Write a Python script that uses Pymeasure to connect to a Keithley 2750 Multimeters,4220.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


def clean_closed_channels(output):
    """"""Cleans up the list returned by command "":ROUTe:CLOSe?"", such that each entry is an integer
    denoting the channel number.
    """"""
    if isinstance(output, str):
        s = output.replace(""("", """").replace("")"", """").replace(""@"", """")
        if s == """":
            return []
        else:
            return [int(s)]
    elif isinstance(output, list):
        list_final = []
        for i, entry in enumerate(output):
            if isinstance(entry, float) or isinstance(entry, int):
                list_final += [int(entry)]
            elif isinstance(entry, str):
                list_final += [int(entry.replace(""("", """").replace("")"", """").replace(""@"", """"))]
            else:
                raise ValueError(""Every entry must be a string, float, or int"")
            assert isinstance(list_final[i], int)
        return list_final
    else:
        raise ValueError(""`output` must be a string or list."")


class Keithley2750(Instrument):
    """""" Represents the Keithley2750 multimeter/switch system and provides a high-level interface for
    interacting with the instrument.
    """"""

    closed_channels = Instrument.measurement("":ROUTe:CLOSe?"",
                                             ""Reads the list of closed channels"",
                                             get_process=clean_closed_channels)

    def __init__(self, adapter, name=""Keithley 2750 Multimeter/Switch System"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def open(self, channel):
        """""" Opens (disconnects) the specified channel.

        :param int channel: 3-digit number for the channel
        :return: None
        """"""
        self.write(f"":ROUTe:MULTiple:OPEN (@{channel})"")

    def close(self, channel):
        """""" Closes (connects) the specified channel.

        :param int channel: 3-digit number for the channel
        :return: None
        """"""
        # Note: if `MULTiple` is omitted, then the specified channel will close,
        # but all other channels will open.
        self.write(f"":ROUTe:MULTiple:CLOSe (@{channel})"")

    def open_all(self):
        """""" Opens (disconnects) all the channels on the switch matrix.

        :return: None
        """"""
        self.write("":ROUTe:OPEN:ALL"")
"
305,https://download.tek.com/datasheet/1KW-73968-1_2260B_Programmable_DC_Power_Supplies_Datasheet_102122.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'att1UqqckwapnISx1'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nY0gSWVxBEE_HWUmU7PnLw/DeV7BYKjUrXs5PbEcT4TNg3e3pXbz1qUrra9f55-LdlHVkW3SI_evut3nV7VTqFdho3m73TU7dAn3IcPOHqKZoR-1vJB3brO_0H8gJJlnaw/9x06G9yKn_aLelpdfK4zO2T4wPTIgd7wkkVKz961yLI'), ('filename', '2260b.webp'), ('size', 14758), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XxdmZw33hlxOsS7_I69SQw/Td_4mdbof5HBDl5L7eHUflINABW7Ta4HlrQnC_ca-P48JzJuKlFEcq_STpWIUMaSMEGK_L7TAFJZL80qtZ2oQYK_Y-rfET5Cy1Wt6ldwaug/Qix1LIJPPNPVuZ9Xx6c1s4ExVdRFoCv3iBfmJHUANFI'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZL_TWRX_tg1LZteqTl-vzA/LlU6yLUI9ipXnzqz4_JU_GE4rAxQ5T18wGxxrByM491OD3N9JIbn1-CJE-34i9a6SKhxk3fJqBCe8gWYM0PO9YE-Xfe45vT8TjysATOKQhU/qvGoWJ1HtBMxCr8RdmQM5caBuWKUrn8RX5xcBDQFuh8'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0mI41jRAtDxlJeUNPfxYTg/b-E3FxwJuzD6tj_ywW9eCej9TPL2cTyz5LF13xZZPy_50jA0H9Mf5SnnttNTkkI6GOP1DMYbfCVbmp0u1q1ASydlls_358va-guZmF2y_xI/Rf_vslLopMYYXLkZP3vafGYz83NX3518_nEaeElyhuc'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"Source a wide range of voltages and currents with the 360W, 720W, or 1080W Series 2260B Programmable DC Power Supplies. The 360W versions can output current of 36A, 13.5A, 4.5A, or 1.44A; the 720W models can output 72A, 27A, 9A, or 2.88A; and the 1080W instruments can output 108A, 40.5A, 13.5A or 4.32A. This wide range of output voltages and current, combined with multiple interface choices, makes the Series 2260B ideal for use in a wide range of applications, including research and design, quality control, and production test.",https://www.tek.com/en/products/keithley/dc-power-supplies/2260b-series,Keithley 2260 B,202.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2260B.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2260B.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782695/Instruments/Power%20Supplies/Keithley-2260B/Keithley-2260B.webp,Keithley 2260B,Write a Python script that uses Pymeasure to connect to a Keithley 2260B Power Supplies,2110.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set

import time
import logging

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2260B(Instrument):
    """""" Represents the Keithley 2260B Power Supply (minimal implementation)
    and provides a high-level interface for interacting with the instrument.

    For a connection through tcpip, the device only accepts
    connections at port 2268, which cannot be configured otherwise.
    example connection string: 'TCPIP::xxx.xxx.xxx.xxx::2268::SOCKET'
    the read termination for this interface is \n

    .. code-block:: python

        source = Keithley2260B(""GPIB::1"")
        source.voltage = 1
        print(source.voltage)
        print(source.current)
        print(source.power)
        print(source.applied)
    """"""

    def __init__(self, adapter, name=""Keithley 2260B DC Power Supply"",
                 read_termination=""\n"", **kwargs):
        super().__init__(
            adapter,
            name,
            read_termination=read_termination,
            **kwargs
        )

    output_enabled = Instrument.control(
        ""OUTPut?"",
        ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    current_limit = Instrument.control(
        "":SOUR:CURR?"",
        "":SOUR:CURR %g"",
        """"""A floating point property that controls the source current
        in amps. This is not checked against the allowed range. Depending on
        whether the instrument is in constant current or constant voltage mode,
        this might differ from the actual current achieved."""""",
    )

    voltage_setpoint = Instrument.control(
        "":SOUR:VOLT?"",
        "":SOUR:VOLT %g"",
        """"""A floating point property that controls the source voltage
        in volts. This is not checked against the allowed range. Depending on
        whether the instrument is in constant current or constant voltage mode,
        this might differ from the actual voltage achieved."""""",
    )

    power = Instrument.measurement(
        "":MEAS:POW?"",
        """"""Reads the power (in Watt) the dc power supply is putting out.
        """""",
    )

    voltage = Instrument.measurement(
        "":MEAS:VOLT?"",
        """"""Reads the voltage (in Volt) the dc power supply is putting out.
        """""",
    )

    current = Instrument.measurement(
        "":MEAS:CURR?"",
        """"""Reads the current (in Ampere) the dc power supply is putting out.
        """""",
    )

    applied = Instrument.control(
        "":APPly?"",
        "":APPly %g,%g"",
        """"""Simultaneous control of voltage (volts) and current (amps).
        Values need to be supplied as tuple of (voltage, current). Depending on
        whether the instrument is in constant current or constant voltage mode,
        the values achieved by the instrument will differ from the ones set.
        """""",
    )

    @property
    def enabled(self):
        log.warning('Deprecated property name ""enabled"", use the identical ""output_enabled"", '
                    'instead.', FutureWarning)
        return self.output_enabled

    @enabled.setter
    def enabled(self, value):
        log.warning('Deprecated property name ""enabled"", use the identical ""output_enabled"", '
                    'instead.', FutureWarning)
        self.output_enabled = value

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', """")
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2260B reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2260B error retrieval."")

    def shutdown(self):
        """""" Disable output, call parent function""""""
        self.output_enabled = False
        super().shutdown()
"
312,https://www.farnell.com/datasheets/3677014.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'att0tCSR9EFjatbkU'), ('width', 520), ('height', 380), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0MPoe28MmR1S_lm-dC3x1Q/3tRu9yMNnAweh_ZA_8UIGDYsfZQ6-x61wv1chtmaxGAlgz-Egtr3FLV8wCJ_-aeMTaCGOZ85qdCvZg7VtknMYQ/ZWd2uXXLReoz-NQkg9Iaym8FlOUImqbsf4EiVf_jdi4'), ('filename', '4040.jpg'), ('size', 39656), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/9UX84XPxFbrLtbhBI3FVUQ/68S0lOtPuFb6SmDgcapNSOeDYaFjGFvyuAJ-ML7JTx5JExO7I_01hmxuw-Yaew9JH9G5yrFfnVOc0Z2bKRo6bA/1U7XMBkSxmmh6lDWY0XZlQONwou952Nb3p-FfAhdn2A'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-57Yja3uXKoFxTVDsYDDAg/7Xki9LLbW2448iMymH4YnJZxDm9bevw6xjb0PudBxky1qTTQRXV6QjGp1YwlqDT2C2_c8RP3xSaW4aipp4fgXQ/KACJ-6C8dr94WYP9M6OEVYaFFtYL9xgzLcTudfirCmw'), ('width', 520), ('height', 380)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7JKnV0d6LGzJEPdYYWTsDQ/VaPbzi-iQkVciPo6-LhuQRQccRA7YFAcorDVnXX5RQBN02ZKa3NK7M6YFEwhRhBzpW-3TYD6ANoUHGMiojCMvw/jNDukdR6vepByPVdP4kVXYY2wsmppbSYYCzkaGZpf8c'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692139604/Instruments/Vendor%20Logos/RohdeSchwarz.png,The Rohde & Schwarz HMP4040 power supply belongs to the HMP series and has 4 channels and a power of 384W. All four channels have an output voltage of 0-32V and an output current of 0-10A.,"https://eleshop.eu/rohde-schwarz-hmp40.html#:~:text=Details,are%20programmable%20DC%20power%20supplies.",HMP 4040,469.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/hmp.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/hmp.html,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/CpS01u_OTWzigpyIX294cA/EX_5PJyYktFu5Al55zSNyjcXLtJsFmmbuTlCPJIP440S20z80VXEZOU8y3TwjyfvjAr8kh0xDb-A3ZuBQd2qNDvw8gY7f0gUO5tuGNvudjQ/VX48XpjO9xisV9e4b9OqW21lZJ4bIlUErS1hzs8d_CE'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MyefG5SLCFh4IVEyVyhAUA/w_qFkuwLUw26XSJsiflkFgNM4soFUFffkWc0MpKgId0Ana-PViShd1ra1Uw7P9esiM7qPsjWn1oUBP8woOUC5w/ZIPgySMN9PXcVEezUO0mvcUtvLfX6IV8ce8CautxXH4'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/pxbHby4ijBkZ-MCbLaMYdg/daQthpa_MxbepZl99pXfKmWFoDVTQK3jm2CQ9Xo4rg3yCJDoSROaJzceaP2pmWlC0nRtV0t0v-TqL2XBA1u44g/0--RegDQKIvXD1tEHXkOcQX5OFePHgzhz00XmVw9fNs'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vqjISP7Yaeb9FU33xwX-8Q/yhoGrCY_Tmtyu3_wVlw59C6mVxdARdPYKdFsole1IGdCIf6FwQzHjiHT5PMCqRqnKZMm42wR_rjv_-OnaBdO6w/RO9AJA_e6QpEEeiVOUEpQSAWLkvDws_NZeyv2PiqkVY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782700/Instruments/Power%20Supplies/HMP-4040/HMP-4040.jpg,HMP 4040,Write a Python script that uses Pymeasure to connect to a HMP 4040 Power Supplies,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              truncated_range)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def process_sequence(sequence):
    """"""
    Check and prepare sequence data.

    :param sequence: Sequence data, in the form [voltage1, current1, time1,
        voltage2, current2, time2, ..., voltage128, current128, time128] with
        voltages in V, currents in A, and times in s. Dwell times are between
        0.06 and 10 s.
    :type sequence: list of float
    :return: Sequence data in the form ""Voltage1,Current1,Time1,Voltage2,
        Current2,Time2,...,Voltage128,Current128,Time128""
    :rtype: str
    """"""
    if not len(sequence) % 3 == 0:
        raise ValueError(""Sequence must contain multiple of 3 values."")
    if any(t > 10 or t < 0.06 for t in sequence[2::3]):
        raise ValueError(""Dwell times must be between 0.06 and 10 s."")
    # turn sequence data into a string
    sequence = "","".join(str(s) for s in sequence)
    return sequence


class HMP4040(Instrument):
    """"""Represents a Rohde&Schwarz HMP4040 power supply.""""""

    def __init__(self, adapter, **kwargs):
        kwargs.setdefault(""name"", ""Rohde&Schwarz HMP4040"")
        super().__init__(
            adapter, includeSCPI=True, **kwargs
        )

    # System Setting Commands -------------------------------------------------

    def beep(self):
        """"""Emit a single beep from the instrument.""""""
        self.write(""SYST:BEEP"")

    control_method = Instrument.setting(
        ""SYST:%s"",
        """"""
        Enables manual front panel ('LOC'), remote ('REM') or manual/remote
        control('MIX') control or locks the the front panel control ('RWL').
        """""",
        validator=strict_discrete_set,
        values=[""LOC"", ""REM"", ""MIX"", ""RWL""],
    )

    version = Instrument.measurement(
        ""SYST:VERS?"",
        ""The SCPI version the instrument's command set complies with."",
    )

    # Channel Selection Commands ----------------------------------------------

    selected_channel = Instrument.control(
        ""INST:NSEL?"",
        ""INST:NSEL %s"",
        ""Selected channel."",
        validator=strict_discrete_set,
        values=[1, 2, 3, 4],
        cast=int
    )

    # Voltage Settings --------------------------------------------------------

    voltage = Instrument.control(
        ""VOLT?"", ""VOLT %s"", ""Output voltage in V. Increment 0.001 V.""
    )

    min_voltage = Instrument.measurement(
        ""VOLT? MIN"", ""Minimum voltage in V.""
    )

    max_voltage = Instrument.measurement(
        ""VOLT? MAX"", ""Maximum voltage in V.""
    )

    def voltage_to_min(self):
        """"""Set voltage of the selected channel to its minimum value.""""""
        self.write(""VOLT MIN"")

    def voltage_to_max(self):
        """"""Set voltage of the selected channel to its maximum value.""""""
        self.write(""VOLT MAX"")

    voltage_step = Instrument.control(
        ""VOLT:STEP?"",
        ""VOLT:STEP %s"",
        ""Voltage step in V. Default 1 V."",
        validator=truncated_range,
        values=[0, 32.050],
    )

    def step_voltage_up(self):
        """"""Increase voltage by one step.""""""
        self.write(""VOLT UP"")

    def step_voltage_down(self):
        """"""Decrease voltage by one step.""""""
        self.write(""VOLT DOWN"")

    # Current Settings --------------------------------------------------------

    current = Instrument.control(
        ""CURR?"",
        ""CURR %s"",
        ""Output current in A. Range depends on instrument type."",
    )

    min_current = Instrument.measurement(
        ""CURR? MIN"", ""Minimum current in A.""
    )

    max_current = Instrument.measurement(
        ""CURR? MAX"", ""Maximum current in A.""
    )

    def current_to_min(self):
        """"""Set current of the selected channel to its minimum value.""""""
        self.write(""CURR MIN"")

    def current_to_max(self):
        """"""Set current of the selected channel to its maximum value.""""""
        self.write(""CURR MAX"")

    current_step = Instrument.control(
        ""CURR:STEP?"", ""CURR:STEP %s"", ""Current step in A.""
    )

    def step_current_up(self):
        """"""Increase current by one step.""""""
        self.write(""CURR UP"")

    def step_current_down(self):
        """"""Decreases current by one step.""""""
        self.write(""CURR DOWN"")

    # Combined Voltage And Current Settings -----------------------------------

    voltage_and_current = Instrument.control(
        ""APPL?"",
        ""APPL %s, %s"",
        ""Output voltage (V) and current (A)."",
    )

    # Output Settings ---------------------------------------------------------

    selected_channel_active = Instrument.control(
        ""OUTP:SEL?"",
        ""OUTPUT:SEL %s"",
        ""Set the selected channel to active or inactive or check its status."",
        values={True: 1, False: 0},
        map_values=True,
    )

    output_enabled = Instrument.control(
        ""OUTP:GEN?"",
        ""OUTP:GEN %s"",
        ""Set the output on or off or check the output status."",
        values={True: 1, False: 0},
        map_values=True,
    )

    # The following commands are for making it easier to change the selected
    # channels and activate/deactivate them.

    def set_channel_state(self, channel, state):
        """"""
        Set the state of the channel to active or inactive.

        :param channel: Channel number to set the state of.
        :type channel: int
        :param state: State of the channel, i.e. True for active, False for
            inactive.
        :type state: bool
        """"""
        # Save current selected channel before switching.
        selected_channel = self.selected_channel
        self.selected_channel = channel
        self.selected_channel_active = state
        # Restore previously selected channel.
        self.selected_channel = selected_channel

    # Measurement Commands ----------------------------------------------------

    measured_voltage = Instrument.measurement(
        ""MEAS:VOLT?"", ""Measured voltage in V.""
    )

    measured_current = Instrument.measurement(
        ""MEAS:CURR?"", ""Measured current in A.""
    )

    # Arbitrary Sequence Commands ---------------------------------------------

    def clear_sequence(self, channel):
        """"""Clear the sequence of the selected channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:CLEAR {channel}"")

    sequence = Instrument.setting(
        ""ARB:DATA %s"",
        ""Define sequence of triplets of voltage (V), current (A) and dwell ""
        ""time (s)."",
        set_process=process_sequence,
    )

    repetitions = Instrument.control(
        ""ARB:REP?"",
        ""ARB:REP %s"",
        ""Number of repetitions (0...255). If 0 is entered, the sequence is""
        ""repeated indefinitely."",
        validator=strict_discrete_set,
        values=range(256),
        cast=int,
    )

    def load_sequence(self, slot):
        """"""Load a saved waveform from internal memory (slot 1, 2 or 3).""""""
        slot = strict_discrete_set(slot, [1, 2, 3])
        self.write(f""ARB:REST {slot}"")

    def save_sequence(self, slot):
        """"""
        Save the sequence defined in the sequence property to internal memory
        (slot 1, 2 or 3).
        """"""
        slot = strict_discrete_set(slot, [1, 2, 3])
        self.write(f""ARB:SAVE {slot}"")

    def start_sequence(self, channel):
        """"""Start the sequence of the selected channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:START {channel}"")

    def stop_sequence(self, channel):
        """"""Stop the sequence defined in the sequence property of the selected
        channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:STOP {channel}"")

    def transfer_sequence(self, channel):
        """"""
        Transfer the sequence defined in the sequence property to the selected
        channel.
        """"""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:TRAN {channel}"")
"
314,https://www.keysight.com/us/en/assets/7018-02567/data-sheets/5990-5914.pdf,https://www.keysight.com/us/en/products/waveform-and-function-generators.html,"[OrderedDict([('id', 'attOk0hnMqAuS5qCp'), ('width', 1164), ('height', 578), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WMaIjR4alFor0_0IO64O3Q/dveNRpl358LkQsiZd4N1NHs2-Cv1GJUwrDtUHEbts4k0SwI5Mq8Vknq7aZSK2AK7Qml9JI_hMhkMz-tSxWJTgdwXBrQ9cnW1FaCFlxiJGeU/UB7prPEQpHazOj9fAUpRvGDyhDgUfx7pZ5w8-Rerj7g'), ('filename', 'Agilent 33521.png'), ('size', 415731), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Mxc_UFCpdIz_8bF5_ztU5w/5J6FEPncUfcwkuawWMm5XnkCirzHcCS88P8G1UQxKTcOehBscT3D306DC4-uMOmsYrWI9yS617hTW3cZtlOJag/woyOF8u6pT7eo5evBulBQvNpRi-din9xxEQM7-awiZ8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/NZ8MlSrnrK7pbpl_9U4EQA/Bkx3WMtNRHO-2fPLD72VuovDALB9PE_NEXW8jxu8nHIOznd43IANXgYyWVuHXczIyYLwl8uKvc15JIJEBERmyQ/XrX4s8jjSAFw0QRyO5m38WNcNYl0iNu6uI8hbYXFjk4'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Rwc8ofi2xt0oY4FjN13gaw/DsAAN2CWJsUXaUaaJVCB6II7osvwHQe9H_bVe88If57EA-IfszYQ1JDzkA4jR8A3EtqCiroKw2aeazktu8Zhwg/OVOfFgYxe6l7SIId1vKviAe4eij_lsePKkSO-Tq4A24'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126006/Instruments/Vendor%20Logos/Agilent.png,"Keysight 33500 Series function/arbitrary waveform generators offer the highest signal fidelity and implement a new breakthrough technology that provides you with the ability to generate more accurate arbitrary waveforms. With 10x better jitter than anything in their class, they offer unparalleled control of signal frequency for your most challenging measurements.",https://www.keysight.com/us/en/product/33521A/function--arbitrary-waveform-generator-30-mhz.html,Agilent 33521 A,9.0,['RF Signal Generator'],"Function / Arbitrary Waveform Generator, 30 MHz
","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent33500.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent33500.html,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/bHWUfdAp--cJbeKzYO83JA/wmZ6-T-Dp20hMXmzysvHRQyu0ZZVNXMEkCw9vjXcydxaS5kOVcGZhN1SYUlmQDVb03-uTox6BnaXo9KMbDkgK0lBAq4idfJ4R1G8BRmtiFw/ZCx5nWT54SQsxE0ORNeCFFrbrV8kgCcCVOYB3BpLHac'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/0BmrbPSDI2OOgeXwOMAtQA/Gw2GEHGUb1KorNNSKJCuoB_V66ZpqiABBWagOOSsrgdkSnvnJGu9FEqwuD7BDQ4OTs8j2Dhb6-4Ocrzqz3MFKr-m3QVpdM_xrA6kPe1dWYA/upBOqwUv5-nDBKh095SaC3AmedSoi4BLuDc06b9_2yA'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mBharPSxwjDHNKVC6H_iCw/beX_P7db1S3nPL85y6DoNlzaGisLpNpb5CwkvE9ZK0b0uSdMLJrkfOLyQWi6PZafGWhMVFJ6Zrx10Fo15qSTSMnyVLEGmPoEy6-aYVlnktw/B2Af0CXmx0vGozKqpi_qwVBEfENbSqFpVhDwYw5NqQE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OJ3iRAgDhaDD0H507GRubA/mIwdxMsGHHeVAH6TPPTYvuIpctRXLJ3lpJVmWIV9gTubDFRauy55Ee2dC8kjvTaVoUK9JWpwk-tdB26CgTSJHq-325RHJZ4yS7jvzt6PrQY/_Ue1EJ2r0uG6LjXk8a4natmilYtbJzMTyxPl4jNkZtE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782702/Instruments/RF%20Signal%20Generator/Keysight-33521-A/Keysight-33521-A.png,Keysight 33521A,Write a Python script that uses Pymeasure to connect to a Keysight 33521A RF Signal Generator,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Parts of this code were copied and adapted from the Agilent33220A class.

import logging
from pymeasure.instruments import Instrument, Channel
from pymeasure.instruments.validators import strict_discrete_set, strict_range
from time import time
from pyvisa.errors import VisaIOError

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


# Capitalize string arguments to allow for better conformity with other WFG's
# FIXME: Currently not used since it does not combine well with the strict_discrete_set validator
# def capitalize_string(string: str, *args, **kwargs):
#     return string.upper()


# Combine the capitalize function and validator
# FIXME: This validator is not doing anything other then self.capitalize_string
# FIXME: I removed it from this class for now
# string_validator = joined_validators(capitalize_string, strict_discrete_set)


class Agilent33500Channel(Channel):
    """"""Implementation of a base Agilent 33500 channel""""""

    shape = Instrument.control(
        ""SOUR{ch}:FUNC?"",
        ""SOUR{ch}:FUNC %s"",
        """""" A string property that controls the output waveform. Can be set to:
        SIN<USOID>, SQU<ARE>, TRI<ANGLE>, RAMP, PULS<E>, PRBS,  NOIS<E>, ARB, DC. """""",
        validator=strict_discrete_set,
        values=[""SIN"", ""SQU"", ""TRI"", ""RAMP"", ""PULS"", ""PRBS"", ""NOIS"", ""ARB"", ""DC""],
    )

    frequency = Instrument.control(
        ""SOUR{ch}:FREQ?"",
        ""SOUR{ch}:FREQ %f"",
        """""" A floating point property that controls the frequency of the output
        waveform in Hz, from 1 uHz to 120 MHz (maximum range, can be lower depending
        on your device), depending on the specified function. """""",
        validator=strict_range,
        values=[1e-6, 120e6],
    )

    amplitude = Instrument.control(
        ""SOUR{ch}:VOLT?"",
        ""SOUR{ch}:VOLT %f"",
        """""" A floating point property that controls the voltage amplitude of the
        output waveform in V, from 10e-3 V to 10 V. Depends on the output
        impedance."""""",
        validator=strict_range,
        values=[10e-3, 10],
    )

    amplitude_unit = Instrument.control(
        ""SOUR{ch}:VOLT:UNIT?"",
        ""SOUR{ch}:VOLT:UNIT %s"",
        """""" A string property that controls the units of the amplitude. Valid
        values are VPP (default), VRMS, and DBM."""""",
        validator=strict_discrete_set,
        values=[""VPP"", ""VRMS"", ""DBM""],
    )

    offset = Instrument.control(
        ""SOUR{ch}:VOLT:OFFS?"",
        ""SOUR{ch}:VOLT:OFFS %f"",
        """""" A floating point property that controls the voltage offset of the
        output waveform in V, from 0 V to 4.995 V, depending on the set
        voltage amplitude (maximum offset = (Vmax - voltage) / 2).
        """""",
        validator=strict_range,
        values=[-4.995, +4.995],
    )

    voltage_high = Instrument.control(
        ""SOUR{ch}:VOLT:HIGH?"",
        ""SOUR{ch}:VOLT:HIGH %f"",
        """""" A floating point property that controls the upper voltage of the
        output waveform in V, from -4.999 V to 5 V (must be higher than low
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-4.999, 5],
    )

    voltage_low = Instrument.control(
        ""SOUR{ch}:VOLT:LOW?"",
        ""SOUR{ch}:VOLT:LOW %f"",
        """""" A floating point property that controls the lower voltage of the
        output waveform in V, from -5 V to 4.999 V (must be lower than high
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-5, 4.999],
    )

    phase = Instrument.control(
        ""SOUR{ch}:PHAS?"",
        ""SOUR{ch}:PHAS %f"",
        """""" A floating point property that controls the phase of the output
        waveform in degrees, from -360 degrees to 360 degrees. Not available
        for arbitrary waveforms or noise."""""",
        validator=strict_range,
        values=[-360, 360],
    )

    square_dutycycle = Instrument.control(
        ""SOUR{ch}:FUNC:SQU:DCYC?"",
        ""SOUR{ch}:FUNC:SQU:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a square
        waveform function in percent, from 0.01% to 99.98%.
        The duty cycle is limited by the frequency and the minimal pulse width of
        16 ns. See manual for more details."""""",
        validator=strict_range,
        values=[0.01, 99.98],
    )

    ramp_symmetry = Instrument.control(
        ""SOUR{ch}:FUNC:RAMP:SYMM?"",
        ""SOUR{ch}:FUNC:RAMP:SYMM %f"",
        """""" A floating point property that controls the symmetry percentage
        for the ramp waveform, from 0.0% to 100.0%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_period = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:PER?"",
        ""SOUR{ch}:FUNC:PULS:PER %e"",
        """""" A floating point property that controls the period of a pulse
        waveform function in seconds, ranging from 33 ns to 1 Ms. Can be set
        and overwrites the frequency for *all* waveforms. If the period is
        shorter than the pulse width + the edge time, the edge time and pulse
        width will be adjusted accordingly. """""",
        validator=strict_range,
        values=[33e-9, 1e6],
    )

    pulse_hold = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:HOLD?"",
        ""SOUR{ch}:FUNC:PULS:HOLD %s"",
        """""" A string property that controls if either the pulse width or the
        duty cycle is retained when changing the period or frequency of the
        waveform. Can be set to: WIDT<H> or DCYC<LE>. """""",
        validator=strict_discrete_set,
        values=[""WIDT"", ""WIDTH"", ""DCYC"", ""DCYCLE""],
    )

    pulse_width = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:WIDT?"",
        ""SOUR{ch}:FUNC:PULS:WIDT %e"",
        """""" A floating point property that controls the width of a pulse
        waveform function in seconds, ranging from 16 ns to 1e6 s, within a
        set of restrictions depending on the period."""""",
        validator=strict_range,
        values=[16e-9, 1e6],
    )

    pulse_dutycycle = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:DCYC?"",
        ""SOUR{ch}:FUNC:PULS:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a pulse
        waveform function in percent, from 0% to 100%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_transition = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:TRAN?"",
        ""SOUR{ch}:FUNC:PULS:TRAN:BOTH %e"",
        """""" A floating point property that controls the edge time in
        seconds for both the rising and falling edges. It is defined as the
        time between the 10% and 90% thresholds of the edge.
        Valid values are between 8.4 ns to 1 µs."""""",
        validator=strict_range,
        values=[8.4e-9, 1e-6],
    )

    output = Instrument.control(
        ""OUTP{ch}?"",
        ""OUTP{ch} %d"",
        """""" A boolean property that turns on (True, 'on') or off (False, 'off')
        the output of the function generator."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, ""on"": 1, ""ON"": 1, False: 0, ""off"": 0, ""OFF"": 0},
    )

    output_load = Instrument.control(
        ""OUTP{ch}:LOAD?"",
        ""OUTP{ch}:LOAD %s"",
        """""" Sets the expected load resistance (should be the load impedance connected
        to the output. The output impedance is always 50 Ohm, this setting can be used
        to correct the displayed voltage for loads unmatched to 50 Ohm.
        Valid values are between 1 and 10 kOhm or INF for high impedance.
        No validator is used since both numeric and string inputs are accepted,
        thus a value outside the range will not return an error.
        """""",
    )

    burst_state = Instrument.control(
        ""SOUR{ch}:BURS:STAT?"",
        ""SOUR{ch}:BURS:STAT %d"",
        """""" A boolean property that controls whether the burst mode is on
        (True) or off (False)."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )

    burst_mode = Instrument.control(
        ""SOUR{ch}:BURS:MODE?"",
        ""SOUR{ch}:BURS:MODE %s"",
        """""" A string property that controls the burst mode. Valid values
        are: TRIG<GERED>, GAT<ED>."""""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGERED"", ""GAT"", ""GATED""],
    )

    burst_period = Instrument.control(
        ""SOUR{ch}:BURS:INT:PER?"",
        ""SOUR{ch}:BURS:INT:PER %e"",
        """""" A floating point property that controls the period of subsequent bursts.
        Has to follow the equation burst_period > (burst_ncycles / frequency) + 1 µs.
        Valid values are 1 µs to 8000 s."""""",
        validator=strict_range,
        values=[1e-6, 8000],
    )

    burst_ncycles = Instrument.control(
        ""SOUR{ch}:BURS:NCYC?"",
        ""SOUR{ch}:BURS:NCYC %d"",
        """""" An integer property that sets the number of cycles to be output
        when a burst is triggered. Valid values are 1 to 100000. This can be
        set. """""",
        validator=strict_range,
        values=range(1, 100000),
    )

    arb_file = Instrument.control(
        ""SOUR{ch}:FUNC:ARB?"",
        ""SOUR{ch}:FUNC:ARB %s"",
        """""" A string property that selects the arbitrary signal from the volatile
        memory of the device. String has to match an existing arb signal in volatile
        memory (set by :meth:`data_arb`)."""""",
    )

    arb_advance = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:ADV?"",
        ""SOUR{ch}:FUNC:ARB:ADV %s"",
        """""" A string property that selects how the device advances from data point
        to data point. Can be set to 'TRIG<GER>' or 'SRAT<E>' (default). """""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGER"", ""SRAT"", ""SRATE""],
    )

    arb_filter = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:FILT?"",
        ""SOUR{ch}:FUNC:ARB:FILT %s"",
        """""" A string property that selects the filter setting for arbitrary signals.
        Can be set to 'NORM<AL>', 'STEP' and 'OFF'. """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""NORMAL"", ""STEP"", ""OFF""],
    )

    arb_srate = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:SRAT?"",
        ""SOUR{ch}:FUNC:ARB:SRAT %f"",
        """""" An floating point property that sets the sample rate of the currently selected
        arbitrary signal. Valid values are 1 µSa/s to 250 MSa/s (maximum range, can be lower
        depending on your device)."""""",
        validator=strict_range,
        values=[1e-6, 250e6],
    )

    def data_volatile_clear(self):
        """"""
        Clear all arbitrary signals from volatile memory for a given channel.

        This should be done if the same name is used continuously to load
        different arbitrary signals into the memory, since an error will occur
        if a trace is loaded which already exists in memory.
        """"""
        self.write(""SOUR{ch}:DATA:VOL:CLE"")

    def data_arb(self, arb_name, data_points, data_format=""DAC""):
        """"""
        Uploads an arbitrary trace into the volatile memory of the device for a given channel.

        The data_points can be given as:
        comma separated 16 bit DAC values (ranging from -32767 to +32767),
        as comma separated floating point values (ranging from -1.0 to +1.0),
        or as a binary data stream.
        Check the manual for more information. The storage depends on the device type and ranges
        from 8 Sa to 16 MSa (maximum).

        :param arb_name: The name of the trace in the volatile memory. This is used to access the
                         trace.

        :param data_points: Individual points of the trace. The format depends on the format
                            parameter.

                            format = 'DAC' (default): Accepts list of integer values ranging from
                            -32767 to +32767. Minimum of 8 a maximum of 65536 points.

                            format = 'float': Accepts list of floating point values ranging from
                            -1.0 to +1.0. Minimum of 8 a maximum of 65536 points.

                            format = 'binary': Accepts a binary stream of 8 bit data.
        :param data_format: Defines the format of data_points. Can be 'DAC' (default), 'float' or
                            'binary'. See documentation on parameter data_points above.
        """"""
        if data_format == ""DAC"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""SOUR{{ch}}:DATA:ARB:DAC {arb_name}, {data_string}"")
            return
        elif data_format == ""float"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""SOUR{{ch}}:DATA:ARB {arb_name}, {data_string}"")
            return
        elif data_format == ""binary"":  # TODO: *Binary is not yet implemented*
            raise NotImplementedError(
                'The binary format has not yet been implemented. Use ""DAC"" or ""float"" instead.'
            )
        else:
            raise ValueError(
                'Undefined format keyword was used. Valid entries are ""DAC"", ""float"" and ""binary""'
            )


class Agilent33500(Instrument):
    """"""
    Represents the Agilent 33500 Function/Arbitrary Waveform Generator family.

    Individual devices are represented by subclasses.
    User can specify a channel to control, if no channel specified, a default channel
    is picked based on the device e.g. For Agilent33500B the default channel
    is channel 1. See reference manual for your device

    .. code-block:: python

        generator = Agilent33500(""GPIB::1"")

        generator.shape = 'SIN'                 # Sets default channel output signal shape to sine
        generator.ch_1.shape = 'SIN'           # Sets channel 1 output signal shape to sine
        generator.frequency = 1e3               # Sets default channel output frequency to 1 kHz
        generator.ch_1.frequency = 1e3         # Sets channel 1 output frequency to 1 kHz
        generator.ch_2.amplitude = 5           # Sets channel 2 output amplitude to 5 Vpp
        generator.ch_2.output = 'on'           # Enables channel 2 output

        generator.ch_1.shape = 'ARB'           # Set channel 1 shape to arbitrary
        generator.ch_1.arb_srate = 1e6         # Set channel 1 sample rate to 1MSa/s

        generator.ch_1.data_volatile_clear()   # Clear channel 1 volatile internal memory
        generator.ch_1.data_arb(               # Send data of arbitrary waveform to channel 1
            'test',
            range(-10000, 10000, +20),          # In this case a simple ramp
            data_format='DAC'                   # Data format is set to 'DAC'
         )
        generator.ch_1.arb_file = 'test'       # Select the transmitted waveform 'test'

    """"""

    ch_1 = Instrument.ChannelCreator(Agilent33500Channel, 1)

    ch_2 = Instrument.ChannelCreator(Agilent33500Channel, 2)

    def __init__(self, adapter, name=""Agilent 33500 Function/Arbitrary Waveform generator family"",
                 **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def beep(self):
        """"""Causes a system beep.""""""
        self.write(""SYST:BEEP"")

    shape = Instrument.control(
        ""FUNC?"",
        ""FUNC %s"",
        """""" A string property that controls the output waveform. Can be set to:
        SIN<USOID>, SQU<ARE>, TRI<ANGLE>, RAMP, PULS<E>, PRBS,  NOIS<E>, ARB, DC. """""",
        validator=strict_discrete_set,
        values=[""SIN"", ""SQU"", ""TRI"", ""RAMP"", ""PULS"", ""PRBS"", ""NOIS"", ""ARB"", ""DC""],
    )

    frequency = Instrument.control(
        ""FREQ?"",
        ""FREQ %f"",
        """""" A floating point property that controls the frequency of the output
        waveform in Hz, from 1 uHz to 120 MHz (maximum range, can be lower depending
        on your device), depending on the specified function."""""",
        validator=strict_range,
        values=[1e-6, 120e6],
    )

    amplitude = Instrument.control(
        ""VOLT?"",
        ""VOLT %f"",
        """""" A floating point property that controls the voltage amplitude of the
        output waveform in V, from 10e-3 V to 10 V. Depends on the output
        impedance."""""",
        validator=strict_range,
        values=[10e-3, 10],
    )

    amplitude_unit = Instrument.control(
        ""VOLT:UNIT?"",
        ""VOLT:UNIT %s"",
        """""" A string property that controls the units of the amplitude. Valid
        values are VPP (default), VRMS, and DBM."""""",
        validator=strict_discrete_set,
        values=[""VPP"", ""VRMS"", ""DBM""],
    )

    offset = Instrument.control(
        ""VOLT:OFFS?"",
        ""VOLT:OFFS %f"",
        """""" A floating point property that controls the voltage offset of the
        output waveform in V, from 0 V to 4.995 V, depending on the set
        voltage amplitude (maximum offset = (Vmax - voltage) / 2).
        """""",
        validator=strict_range,
        values=[-4.995, +4.995],
    )

    voltage_high = Instrument.control(
        ""VOLT:HIGH?"",
        ""VOLT:HIGH %f"",
        """""" A floating point property that controls the upper voltage of the
        output waveform in V, from -4.999 V to 5 V (must be higher than low
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-4.999, 5],
    )

    voltage_low = Instrument.control(
        ""VOLT:LOW?"",
        ""VOLT:LOW %f"",
        """""" A floating point property that controls the lower voltage of the
        output waveform in V, from -5 V to 4.999 V (must be lower than high
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-5, 4.999],
    )

    phase = Instrument.control(
        ""PHAS?"",
        ""PHAS %f"",
        """""" A floating point property that controls the phase of the output
        waveform in degrees, from -360 degrees to 360 degrees. Not available
        for arbitrary waveforms or noise."""""",
        validator=strict_range,
        values=[-360, 360],
    )

    square_dutycycle = Instrument.control(
        ""FUNC:SQU:DCYC?"",
        ""FUNC:SQU:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a square
        waveform function in percent, from 0.01% to 99.98%.
        The duty cycle is limited by the frequency and the minimal pulse width of
        16 ns. See manual for more details."""""",
        validator=strict_range,
        values=[0.01, 99.98],
    )

    ramp_symmetry = Instrument.control(
        ""FUNC:RAMP:SYMM?"",
        ""FUNC:RAMP:SYMM %f"",
        """""" A floating point property that controls the symmetry percentage
        for the ramp waveform, from 0.0% to 100.0%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_period = Instrument.control(
        ""FUNC:PULS:PER?"",
        ""FUNC:PULS:PER %e"",
        """""" A floating point property that controls the period of a pulse
        waveform function in seconds, ranging from 33 ns to 1e6 s. Can be set
        and overwrites the frequency for *all* waveforms. If the period is
        shorter than the pulse width + the edge time, the edge time and pulse
        width will be adjusted accordingly. """""",
        validator=strict_range,
        values=[33e-9, 1e6],
    )

    pulse_hold = Instrument.control(
        ""FUNC:PULS:HOLD?"",
        ""FUNC:PULS:HOLD %s"",
        """""" A string property that controls if either the pulse width or the
        duty cycle is retained when changing the period or frequency of the
        waveform. Can be set to: WIDT<H> or DCYC<LE>. """""",
        validator=strict_discrete_set,
        values=[""WIDT"", ""WIDTH"", ""DCYC"", ""DCYCLE""],
    )

    pulse_width = Instrument.control(
        ""FUNC:PULS:WIDT?"",
        ""FUNC:PULS:WIDT %e"",
        """""" A floating point property that controls the width of a pulse
        waveform function in seconds, ranging from 16 ns to 1 Ms, within a
        set of restrictions depending on the period."""""",
        validator=strict_range,
        values=[16e-9, 1e6],
    )

    pulse_dutycycle = Instrument.control(
        ""FUNC:PULS:DCYC?"",
        ""FUNC:PULS:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a pulse
        waveform function in percent, from 0% to 100%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_transition = Instrument.control(
        ""FUNC:PULS:TRAN?"",
        ""FUNC:PULS:TRAN:BOTH %e"",
        """""" A floating point property that controls the edge time in
        seconds for both the rising and falling edges. It is defined as the
        time between the 10% and 90% thresholds of the edge.
        Valid values are between 8.4 ns to 1 µs."""""",
        validator=strict_range,
        values=[8.4e-9, 1e-6],
    )

    output = Instrument.control(
        ""OUTP?"",
        ""OUTP %d"",
        """""" A boolean property that turns on (True, 'on') or off (False, 'off')
        the output of the function generator."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, ""on"": 1, ""ON"": 1, False: 0, ""off"": 0, ""OFF"": 0},
    )

    output_load = Instrument.control(
        ""OUTP:LOAD?"",
        ""OUTP:LOAD %s"",
        """""" Sets the expected load resistance (should be the load impedance connected
        to the output. The output impedance is always 50 Ohm, this setting can be used
        to correct the displayed voltage for loads unmatched to 50 Ohm.
        Valid values are between 1 and 10 kOhm or INF for high impedance.
        No validator is used since both numeric and string inputs are accepted,
        thus a value outside the range will not return an error.
        """""",
    )

    burst_state = Instrument.control(
        ""BURS:STAT?"",
        ""BURS:STAT %d"",
        """""" A boolean property that controls whether the burst mode is on
        (True) or off (False)."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )

    burst_mode = Instrument.control(
        ""BURS:MODE?"",
        ""BURS:MODE %s"",
        """""" A string property that controls the burst mode. Valid values
        are: TRIG<GERED>, GAT<ED>."""""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGERED"", ""GAT"", ""GATED""],
    )

    burst_period = Instrument.control(
        ""BURS:INT:PER?"",
        ""BURS:INT:PER %e"",
        """""" A floating point property that controls the period of subsequent bursts.
        Has to follow the equation burst_period > (burst_ncycles / frequency) + 1 µs.
        Valid values are 1 µs to 8000 s."""""",
        validator=strict_range,
        values=[1e-6, 8000],
    )

    burst_ncycles = Instrument.control(
        ""BURS:NCYC?"",
        ""BURS:NCYC %d"",
        """""" An integer property that sets the number of cycles to be output
        when a burst is triggered. Valid values are 1 to 100000. This can be
        set. """""",
        validator=strict_range,
        values=range(1, 100000),
    )

    arb_file = Instrument.control(
        ""FUNC:ARB?"",
        ""FUNC:ARB %s"",
        """""" A string property that selects the arbitrary signal from the volatile
        memory of the device. String has to match an existing arb signal in volatile
        memory (set by :meth:`data_arb`)."""""",
    )

    arb_advance = Instrument.control(
        ""FUNC:ARB:ADV?"",
        ""FUNC:ARB:ADV %s"",
        """""" A string property that selects how the device advances from data point
        to data point. Can be set to 'TRIG<GER>' or 'SRAT<E>' (default). """""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGER"", ""SRAT"", ""SRATE""],
    )

    arb_filter = Instrument.control(
        ""FUNC:ARB:FILT?"",
        ""FUNC:ARB:FILT %s"",
        """""" A string property that selects the filter setting for arbitrary signals.
        Can be set to 'NORM<AL>', 'STEP' and 'OFF'. """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""NORMAL"", ""STEP"", ""OFF""],
    )
    # TODO: This implementation is currently not working. Do not know why.
    # arb_period = Instrument.control(
    #     ""FUNC:ARB:PER?"", ""FUNC:ARB:PER %e"",
    #     """""" A floating point property that controls the period of the arbitrary signal.
    #     Limited by number of signal points. Check for instrument errors when setting
    #     this property."""""",
    #     validator=strict_range,
    #     values=[33e-9, 1e6],
    # )
    #
    # arb_frequency = Instrument.control(
    #     ""FUNC:ARB:FREQ?"", ""FUNC:ARB:FREQ %f"",
    #     """""" A floating point property that controls the frequency of the arbitrary signal.
    #     Limited by number of signal points. Check for instrument
    #     errors when setting this property."""""",
    #     validator=strict_range,
    #     values=[1e-6, 30e+6],
    # )
    #
    # arb_npoints = Instrument.measurement(
    #     ""FUNC:ARB:POIN?"",
    #     """""" Returns the number of points in the currently selected arbitrary trace. """"""
    # )
    #
    # arb_voltage = Instrument.control(
    #     ""FUNC:ARB:PTP?"", ""FUNC:ARB:PTP %f"",
    #     """""" An floating point property that sets the peak-to-peak voltage for the
    #     currently selected arbitrary signal. Valid values are 1 mV to 10 V. This can be
    #     set. """""",
    #     validator=strict_range,
    #     values=[0.001, 10],
    # )

    arb_srate = Instrument.control(
        ""FUNC:ARB:SRAT?"",
        ""FUNC:ARB:SRAT %f"",
        """""" An floating point property that sets the sample rate of the currently selected
        arbitrary signal. Valid values are 1 µSa/s to 250 MSa/s (maximum range, can be lower
        depending on your device)."""""",
        validator=strict_range,
        values=[1e-6, 250e6],
    )

    def data_volatile_clear(self):
        """"""
        Clear all arbitrary signals from volatile memory.

        This should be done if the same name is used continuously to load
        different arbitrary signals into the memory, since an error
        will occur if a trace is loaded which already exists in the memory.
        """"""
        self.write(""DATA:VOL:CLE"")

    def phase_sync(self):
        """""" Synchronize the phase of all channels.""""""
        self.write(""PHAS:SYNC"")

    def data_arb(self, arb_name, data_points, data_format=""DAC""):
        """"""
        Uploads an arbitrary trace into the volatile memory of the device.

        The data_points can be given as:
        comma separated 16 bit DAC values (ranging from -32767 to +32767),
        as comma separated floating point values (ranging from -1.0 to +1.0)
        or as a binary data stream.
        Check the manual for more information.
        The storage depends on the device type and ranges
        from 8 Sa to 16 MSa (maximum).

        :param arb_name: The name of the trace in the volatile memory. This is used to access the
                         trace.
        :param data_points: Individual points of the trace. The format depends on the format
                            parameter.
                            format = 'DAC' (default): Accepts list of integer values ranging from
                            -32767 to +32767. Minimum of 8 a maximum of 65536 points.
                            format = 'float': Accepts list of floating point values ranging from
                            -1.0 to +1.0. Minimum of 8 a maximum of 65536 points.
                            format = 'binary': Accepts a binary stream of 8 bit data.
        :param data_format: Defines the format of data_points. Can be 'DAC' (default), 'float' or
                            'binary'. See documentation on parameter data_points above.
        """"""
        if data_format == ""DAC"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""DATA:ARB:DAC {arb_name}, {data_string}"")
            return
        elif data_format == ""float"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""DATA:ARB {arb_name}, {data_string}"")
            return
        elif data_format == ""binary"":  # TODO: *Binary is not yet implemented*
            raise NotImplementedError(
                'The binary format has not yet been implemented. Use ""DAC"" or ""float"" instead.'
            )
        else:
            raise ValueError(
                'Undefined format keyword was used. Valid entries are ""DAC"", ""float"" and ""binary""'
            )

    display = Instrument.setting(
        ""DISP:TEXT '%s'"",
        """""" A string property which is displayed on the front panel of
        the device."""""",
    )

    def clear_display(self):
        """"""Removes a text message from the display.""""""
        self.write(""DISP:TEXT:CLE"")

    def trigger(self):
        """"""Send a trigger signal to the function generator.""""""
        self.write(""*TRG;*WAI"")

    def wait_for_trigger(self, timeout=3600, should_stop=lambda: False):
        """"""
        Wait until the triggering has finished or timeout is reached.

        :param timeout: The maximum time the waiting is allowed to take. If
                        timeout is exceeded, a TimeoutError is raised. If
                        timeout is set to zero, no timeout will be used.
        :param should_stop: Optional function (returning a bool) to allow the
                            waiting to be stopped before its end.

        """"""
        self.write(""*OPC?"")

        t0 = time()
        while True:
            try:
                ready = bool(self.read())
            except VisaIOError:
                ready = False

            if ready:
                return

            if timeout != 0 and time() - t0 > timeout:
                raise TimeoutError(
                    ""Timeout expired while waiting for the Agilent 33220A""
                    + "" to finish the triggering.""
                )

            if should_stop:
                return

    trigger_source = Instrument.control(
        ""TRIG:SOUR?"",
        ""TRIG:SOUR %s"",
        """""" A string property that controls the trigger source. Valid values
        are: IMM<EDIATE> (internal), EXT<ERNAL> (rear input), BUS (via trigger
        command)."""""",
        validator=strict_discrete_set,
        values=[""IMM"", ""IMMEDIATE"", ""EXT"", ""EXTERNAL"", ""BUS""],
    )

    ext_trig_out = Instrument.control(
        ""OUTP:TRIG?"",
        ""OUTP:TRIG %d"",
        """""" A boolean property that controls whether the trigger out signal is
        active (True) or not (False). This signal is output from the Ext Trig
        connector on the rear panel in Burst and Wobbel mode."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )
"
317,https://store-5445uo.mybigcommerce.com/content/5200_Magsci_version_2pg.pdf,https://en.wikipedia.org/wiki/Magnetometer,"[OrderedDict([('id', 'att1OYIIFQHiah051'), ('width', 482), ('height', 630), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GsZTkSCZLUYpYKpgUGdYsA/45PYOzxD00odqPHntZ3gurROA7U40Nuz0g1gybVPQuqkc-xzoUeEfToZSQmsQe7KdmxhnD09alMfzqzVESNCZUrBzQ71xcjkuKO2ocoSf7QvkRyFt2zbmDbMBvBV6WGEP4Q4jaP8ZOUDbkYchl19oaFezpC6bua2peOKHp7DfLc/ObM3Oicx_7KonhWGCQAhhq9yP7RW9SMWEFyvvq9cdLc'), ('filename', 'parker-meggitt-fw-bell-5280-gauss-meter-for-ndt-63e28cedadcb6.jpg'), ('size', 32552), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/DnUdDMzmgmWFFh9LwhQbGA/7JBUCxZSJuS3jbgjuv7Z1bsTgBYbR0UkeoX-iUNqiVKgeBpCPkJsed7BfLttxKjrtXa9xVC_AUgISiSVE_ApvA/cX0UDcaU_mMgGCfEnTFwiRAMXAaplHRK2OUPwzZn-lE'), ('width', 28), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rU_j8XWgqRvKmsHw0jB6Aw/lPgOn_W_01g9te532eyb2KiQw_-Rrkxl7a78SPw6PZgl0eRaDz6ngl4ApDuSJGVZbV07aRVQ3FraRy4LlXm-xw/voyPe2tL7f4k375xcYkt6Vpr_BgVvlwWbiaU5NrKOow'), ('width', 482), ('height', 630)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/tepZyDQ0Hovehm0E868BRg/Pi1zycZzxHPxTNX8IEdUnKy8bfkUfm0y0aHPMVQ3n_Wxj1tLuDepeuChCN_1p6Sr7ZJs0S8Fca52IUV8zKkT8A/alcbbbPcw2LY6kJSfo9v035jWUMbGzRGcLVS2NaYbHg'), ('width', 3000), ('height', 3000)]))]))])]",,UK (Meggit),https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125981/Instruments/Vendor%20Logos/F.W.Bell.png,"Handheld single-axis digital magnetometer gauss / tesla meter for measuring magnets, magnetism of steel, and other manufacturing and scientific applications.",https://magneticsciences.com/bell-5280-gaussmeter/,Fwbell 5080,124.0,['Multimeters'],A Gaussmeter is a device that measures magnetic field or magnetic dipole moment.,"Technology leaders in instrumentation. Designing and manufacturing **F.W. Bell** gaussmeters, probes, current sensors and Hall generators for over 60 years
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/fwbell/fwbell5080.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/fwbell/fwbell5080.html,F.W. Bell,"[OrderedDict([('id', 'attlye35NOBj3ErJe'), ('width', 373), ('height', 247), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Qt_27xOeiyAQnjMv2yc2uA/2QlB6j2CGcG4vorg7u6fkkF8oTDIUzaWecgMpyFHhfGI3-LkKFdu0jqrbdsMpeiMnSXFcxWik-Bp85n0pIN7IOIL52keQ8U4-7OAd7kwVZE/4MX7liT4jpi_SUd2DsNThFtS3gZPMDLwI6bTog9US74'), ('filename', 'fw-bell logo.jpg'), ('size', 12846), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/1fFvmM3a_H7GZTOjhTqZeg/wxn9N0ZDAxUBh4e76Reo6hkuNREUTzlogz1a2oi5-n1jzOt2meUXvohkg7crNmC6ohvqBVcs8nrLcIqYLwqldQ/wQn8K1I_l619G_x6LN3hi368xlMTFnlSsOt4KAD7qGQ'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_5x5N-QysrMFoct9D7mQnA/wrLLKMNcQT0ouQuQBQ5SQ0JJ3E-nI4KF0Ulp0SqXKh-cZaTo4yO7sKX1S8pOvcBEV9MZ7XGNwkJkDw1Ami9pbA/Zaatj6_pEbtNYp9nWbStHGlX_fnLrFbNCp3PLjEiZcM'), ('width', 373), ('height', 247)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Pw4y3DfxsNPHCFkDFDKrBA/T_Qmo1kYjGyyFqIuuWGl0UcDOWnHRfKUGzK8a7TSgj3P6kU8USLcBwwX8AhIF7353FGxmhveb8TxF3XGCfx6mg/EII9wTBzqCe3DnmXKPd4IZWLcakgVOKbwaaps41pZxo'), ('width', 3000), ('height', 3000)]))]))])]",https://fwbell.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782705/Instruments/Multimeters/F.W.-Bell-5280/F.W.-Bell-5280.jpg,F.W. Bell 5280,Write a Python script that uses Pymeasure to connect to a F.W. Bell 5280 Multimeters,750.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set
from numpy import array, float64
from time import sleep


class FWBell5080(Instrument):
    """""" Represents the F.W. Bell 5080 Handheld Gaussmeter and
    provides a high-level interface for interacting with the
    instrument

    :param port: The serial port of the instrument

    .. code-block:: python

        meter = FWBell5080('/dev/ttyUSB0')  # Connects over serial port /dev/ttyUSB0 (Linux)

        meter.units = 'gauss'               # Sets the measurement units to Gauss
        meter.range = 1                     # Sets the range to 3 kG
        print(meter.field)                  # Reads and prints a field measurement in G

        fields = meter.fields(100)          # Samples 100 field measurements
        print(fields.mean(), fields.std())  # Prints the mean and standard deviation of the samples

    """"""

    def __init__(self, adapter, name=""F.W. Bell 5080 Handheld Gaussmeter"", **kwargs):
        kwargs.setdefault('timeout', 500)
        kwargs.setdefault('baudrate', 2400)
        super().__init__(
            adapter,
            name,
            includeSCPI=True,
            **kwargs
        )

    field = Instrument.measurement(
        "":MEASure:FLUX?"",
        """""" Measure the field in the appropriate units (float).
        """""",
        # Remove units
        get_process=lambda v: float(v.replace('T', '').replace('G', '').replace('Am', ''))

    )

    UNITS = {
        'gauss': 'DC:GAUSS', 'gauss ac': 'AC:GAUSS',
        'tesla': 'DC:TESLA', 'tesla ac': 'AC:TESLA',
        'amp-meter': 'DC:AM', 'amp-meter ac': 'AC:AM'
    }

    units = Instrument.control(
        "":UNIT:FLUX?"", "":UNIT:FLUX:%s"",
        """""" Get the field units (str), which can take the
        values: 'gauss', 'gauss ac', 'tesla', 'tesla ac', 'amp-meter', and
        'amp-meter ac'. The AC versions configure the instrument to measure AC.
        """""",
        validator=strict_discrete_set,
        values=UNITS,
        map_values=True
    )

    range = Instrument.control(
        "":SENS:FLUX:RANG?"", "":SENS:FLUX:RANG %d"",
        """""" Control the maximum field range in the active units (int).
        The range unit is dependent on the current units mode (gauss, tesla, amp-meter). Value
        sets an equivalent range across units that increases in magnitude (1, 10, 100).

        +--------+--------+---------+-----------+
        | Value  | gauss  |  tesla  | amp-meter |
        +--------+--------+---------+-----------+
        | 0      | 300 G  |  30  mT | 23.88 kAm |
        +--------+--------+---------+-----------+
        | 1      | 3 kG   |  300 mT | 238.8 kAm |
        +--------+--------+---------+-----------+
        | 2      | 30 kG  |  3 T    | 2388  kAm |
        +--------+--------+---------+-----------+
        """""",
        validator=strict_discrete_set,
        values=[0, 1, 2],
        cast=int
    )

    def read(self):
        """""" Overwrites the :meth:`Instrument.read <pymeasure.instruments.Instrument.read>`
        method to remove semicolons and replace spaces with colons.
        """"""
        # To set the unit mode to DC Tesla you need to write(':UNIT:FLUX:DC:TESLA')
        # However the response from ask(':UNIT:FLUX?') is ""DC TESLA"", with no colon.
        # We replace space with colon to preserve the mapping in UNITS.
        # Semicolons may be appended to end of response from FW Bell 5080, and are removed
        return super().read().replace(' ', ':').replace(';', '')

    def reset(self):
        """""" Resets the instrument. """"""
        self.clear()

    def fields(self, samples=1):
        """""" Returns a numpy array of field samples for a given sample number.

        :param samples: The number of samples to preform
        """"""
        if samples < 1:
            raise Exception(""F.W. Bell 5080 does not support samples less than 1."")
        else:
            data = [self.field for i in range(int(samples))]
            return array(data, dtype=float64)

    def auto_range(self):
        """""" Enables the auto range functionality. """"""
        self.write("":SENS:FLUX:RANG:AUTO"")
        # Instrument needs a delay before next command
        sleep(2)
"
318,https://www.farnell.com/datasheets/1484838.pdf?_ga=2.191326378.1021018580.1687884136-1198138748.1687884136,https://en.wikipedia.org/wiki/Electrometer,"[OrderedDict([('id', 'attOW045AtVQ9t71b'), ('width', 320), ('height', 164), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Idubzw3uFfGUzHvYAdbILg/d_vrX-I_zyxDCq9Qwch0eh18CW-OAsNSBzGJjqgxDgdyGzDPER16TcDpXocrsJoRBxhmTlzTaxt6SQjDs1rcbKVWEoySKfRH5OVnhibdjNE/HxOOQTtUcrRjSsa7yzsZUgwVxV5dmlh7casqorQ_M4U'), ('filename', '6517b.webp'), ('size', 5212), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qzzvAv1YYB7blD_vUjbVng/dzfOMuZALbEDX4Z_T8MDVZU3Gd7RWSPcSMCthihlZiA0i1ierRqIgTrdgIv5cGjKpoFj0KrOCnDsYTfGzXvB8vdx-KrTvzKCXb9aW6CQK-U/FJ5Kgq60GbD68HgFVQqcEuEzkCFBbk4aoi3r6J5NS0w'), ('width', 70), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/dH_4TfiDMBGjtfH4w-LM5w/GJM2Z-nlNhzwsF9QmLieVi2diL6YwVIFfN0bHJUp2U9xrxKNLXa3gjwJc103HzKCdXAobKlQzoMOawb66aADw-Yx9gljDFXs9bsgim0MARQ/crOMnCQsfXnAFBZmpC0p6AlEPAOOEokLGxUhaVZPHuk'), ('width', 320), ('height', 164)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/oC15RYOuKSAF_mn8t2JAmw/U-Ny00q7DtQD6qfB5BY9qyTUGn5gxtTToz2NKOCG9dYaE4kFdskVRuTscmxFTKUnDPuAVQeMV3DB7RnPa_L30kCdUBjE3BVs8CnmbecSzMo/YlQhnmxB8WFu5BzM30GoyiFtRN-o1xbNyzyY2HcupZ0'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,6517B Electrometer/High Resistance Meter is capable of measuring the largest voltage range—up to 200 V—with an input impedance exceeding 200 TΩ. All this performance is built into an instrument that operates as simply as a digital multimeter.,https://www.newark.com/keithley/6517b/electrometer-high-resistance-meter/dp/56P3700,Keithley 6517 B,257.0,['Power Meters'],"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6517b.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6517b.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782706/Instruments/Power%20Meters/Keithley-6517B/Keithley-6517B.webp,Keithley 6517B,Write a Python script that uses Pymeasure to connect to a Keithley 6517B Power Meters,12100.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import re

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6517B(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6517B ElectroMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6517B(""GPIB::1"")

        keithley.apply_voltage()              # Sets up to source current
        keithley.source_voltage_range = 200   # Sets the source voltage
                                              # range to 200 V
        keithley.source_voltage = 20          # Sets the source voltage to 20 V
        keithley.enable_source()              # Enables the source output

        keithley.measure_resistance()         # Sets up to measure resistance

        keithley.ramp_to_voltage(50)          # Ramps the voltage to 50 V
        print(keithley.resistance)            # Prints the resistance in Ohms

        keithley.shutdown()                   # Ramps the voltage to 0 V
                                              # and disables output

    """"""

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    @staticmethod
    def extract_value(result):
        """""" extracts the physical value from a result object returned
            by the instrument """"""
        m = re.fullmatch(r'([+\-0-9E.]+)[A-Z]{4}', result[0])
        if m:
            return float(m.group(1))
        return None

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":MEAS?"",
        """""" Reads the current in Amps, if configured for this reading.
        """""", get_process=extract_value
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -20 and +20 mA.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-20e-3, 20e-3]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC current measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    source_current_resistance_limit = Instrument.control(
        "":SOUR:CURR:RLIM?"", "":SOUR:CURR:RLIM %g"",
        """""" Boolean property which enables or disables resistance
        current limit """""",
        cast=bool
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":MEAS:VOLT?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """""", get_process=extract_value
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC voltage measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """"""
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """""", get_process=extract_value
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 100e18 Ohms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 100e18]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the
        integration period and measurement speed. Takes values from 0.01
        to 10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively.
        """"""
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 6517B Electrometer/High Resistance Meter"", **kwargs):
        super().__init__(
            adapter, name,
            **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms,
                           from -210 POhms to 210 POhms
        :param auto_range: Enables auto_range if True, else uses the
                           resistance_range attribut
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -1000 V to 1000 V
        :param auto_range: Enables auto_range if True, else uses the
                           voltage_range attribut
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -21 mA to 21 mA
        :param auto_range: Enables auto_range if True, else uses the
                           current_range attribut
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_voltage(self, voltage_range=None):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.

        :param voltage_range: A :attr:`~.Keithley6517B.voltage_range` value
                              or None (activates auto range)
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.check_errors()

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6517B reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6517B error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Volts
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":TRIG:SOUR BUS;"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
319,https://www.intestthermal.com/temptronic/brochure-request?brochure_title=ECO-560_660_Series_ThermoStream&brand_interest=Temptronic&brand_sub_folder=temptronic&file_name=ECO-560_660_Series_ThermoStream.pdf&product=ECO%20ThermoStream&hsLang=en,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.","[OrderedDict([('id', 'attZGP0PXEl16LoZ7'), ('width', 366), ('height', 798), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rqfnJO1d8IXIa-oq8t4ckA/hYTKTtIKa8-H7dQCrrchNzMQv0nsuacaw6ELJ1O0LJ6ntL7oc7CCs8_J71LUKXmlVWynWGNFX-WHEpwNqUI80QEciscwuf0LsoJYvdn1XpA/nqHvYJDmnXbbGA2DITKl8b3DjrVhewszoySjewPOODg'), ('filename', '560 ECO Stream.webp'), ('size', 35380), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zhWsgsZ_jwHujcL7i_PmOQ/uDGqpOBPg5fov9c_semF_hvYEuzZCIpovl9n0aJoXP2KVCaCcTwgIUSinn0FNZpprcDizJSMSV_rtdG104XdleUhsueyjJjTsKh8MTzsIGg/lypg83JMk0OAplvSaJT9E2LuEng-T_zsQtLqZCfuX4Y'), ('width', 17), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/oohlz08xU1eHIEc3Gw6xhA/e8upGGlz9OgcGsw7vXhKAMD1qEREZL7NO9BUlD7mFwqlFCSAAZrVRNE1CdaXqzBTDL4bThlKa6OfPzN-1zk82Y2wpNdSod_AO6JQ8aJaqoM/1uqm-VkAX1zTB6xA65ScGLky25AEBtgGzY6D8LBJ6ds'), ('width', 366), ('height', 798)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2deVGBLOvjdV3L9N3duGvA/dc7hDUtxqdpxo0jhDu_VoOSouAXycbSH_ZT4t-j2uSe2GwGPgTLb-DNf-pzsnk3Xy4xWLbju-lgaw9Uiegr0xZTt-d7MMgnP2IrEWPpO1aQ/uxvSZs98m-RUUbnMXOeuPr6GL5iqOFX6VZMJxR1Vdzc'), ('width', 3000), ('height', 3000)]))]))])]",19.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125985/Instruments/Vendor%20Logos/Temptronic.png,The ECO-560/660 ThermoStream uses less energy while delivering high-performance temperature control with low noise and low cost.,https://www.intestthermal.com/temptronic/low-cost-thermostream/eco560-660,ECO 560,590.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_eco560.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_eco560.html,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/XkJOd2Fwd9vcwCxlWHYuVQ/Mj4zcFto3BrPOFLOgDiJd0bpi2u3YU2gCJWyUK3OqmTSUMrQ3zJmguf6SjcB-3KXYD8TAEHYL4zaFUeLJFcBoggEqNz3w2DZsgNzGWOK-GPmzprqI71Kb-SSJoeT1OzR/3bmPScz9e0R01o5_F4ME4BwK3P4G8DsmouH8CdiESg0'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/lgs8naZZFDDY_xgAouIDeA/1nfEKPkT-AFUq5MmcJ2mRR9XvszzohqDjknqySo9xmsgWJlaCBqO3LGEnL_81Cjk8cXTdCEo_sfkYiyl2E91og/9RRq8Xvxs0cMV-sW6njjL5o0u7Z-BsAdpMP3bCqaCN8'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YHM46j4C5UJtnJFaW4kxGw/fKqMItDmtOQJJHgRnWPFZoWiNzcyh3ZA4f8YfzCA_Pw8VH-WuUimbE8EtU7rniTK-kZSc8_j5nLwl6-D4cI9Dw/d3ZvtW1XBgsk6-SbAhezCQqjZ0DgtKSleP1_wZRKgrU'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/U-hY1Sy2d_2OHAR_2IFmeg/pzM0ALGEDOXV1Dc6iR6hSv-RKOkda5QWdCGKwOssrylOUa3LXbMGyo_LdusCw53TFwdtbLggMgBXRVdG7xJV9A/GLMlL87L8YChOOgVU1B6Rlif7NwNoQPHCvw_Vf96jTE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782706/Instruments/Temperature%20Controllers/ECO-560/ECO-560.webp,ECO 560,Write a Python script that uses Pymeasure to connect to a ECO 560 Temperature Controllers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ECO-560/660 ThermoStream® Systems
Operators Manual
Revision B
September, 2018
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase
from enum import IntFlag


class ECO560ErrorCode(IntFlag):
    """"""Error code enums based on ``IntFlag``.

    Used in conjunction with :attr:`~.error_code`.

        ======  ======
        Value   Enum
        ======  ======
        16384   NO_DUT_SENSOR_SELECTED
        8192    IMPROPER_SOFTWARE_VERSION
        1024    PURGE_HEAT_FAILURE
        512     FLOW_SENSOR_HARDWARE_ERROR
        256     DUT_OPEN_LOOP
        128     INTERNAL_ERROR
        64      OPEN_PURGE_TEMPERATURE_SENSOR
        32      AIR_SENSOR_OPEN
        16      LOW_INPUT_AIR_PRESSURE
        8       LOW_FLOW
        4       SETPOINT_OUT_OF_RANGE
        2       AIR_OPEN_LOOP
        1       OVERHEAT
        0       OK
        ======  ======

    """"""
    # bit 15 - reserved
    NO_DUT_SENSOR_SELECTED = 16384      # bit 14 – no DUT sensor selected
    IMPROPER_SOFTWARE_VERSION = 8192    # bit 13 – software revision error
    # bit 12 – reserved
    # bit 11 – reserved
    PURGE_HEAT_FAILURE = 1024           # bit 10 – purge heat failure
    FLOW_SENSOR_HARDWARE_ERROR = 512    # bit 9  – flow sensor hardware error
    DUT_OPEN_LOOP = 256                 # bit 8  – dut open loop
    INTERNAL_ERROR = 128                # bit 7  – internal error
    OPEN_PURGE_TEMPERATURE_SENSOR = 64  # bit 6  – open purge temperature sensor
    NO_PURGE_FLOW = 32                  # bit 5  – no purge flow
    LOW_INPUT_AIR_PRESSURE = 16         # bit 4  – low input air pressure
    LOW_FLOW = 8                        # bit 3  – low flow
    SETPOINT_OUT_OF_RANGE = 4           # bit 2  – setpoint out of range
    AIR_OPEN_LOOP = 2                   # bit 1  – air open loop
    OVERHEAT = 1                        # bit 0  – overheat
    OK = 0                              # ok state


class ECO560(ATSBase):
    """"""Represent the TemptronicECO560 instruments.
    """"""

    temperature_limit_air_low_values = [-150, 25]

    error_code_get_process = lambda v: ECO560ErrorCode(int(v))  # noqa: E731

    copy_active_setup_file = None
    # Not Implemented in ECO-560

    def __init__(self, adapter, name=""Temptronic ECO-560 Thermostream"", **kwargs):
        kwargs.setdefault('timeout', 3000)
        super().__init__(
            adapter,
            name,
            tcpip={'write_termination': '\n',
                   'read_termination': '\n'},
            **kwargs
        )
"
320,https://divapps.parker.com/divapps/emn/prior_version_compumotor/cat/english/pgs95_113_gem_servo.pdf,https://en.wikipedia.org/wiki/Motor_controller,"[OrderedDict([('id', 'att1GKkDCDEW0jJMO'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ofz60yDatO14NdSnI1AJtg/f2lsyQZ9sz_Y9f5MwmbiqEq4YjF_-9OOf_nu1XJfo8b-K6SbiAayJWK5cXw8X_GW8Ykj-CmiltKtH98hw143ZwDVB7xdBD9CsPg67jVpIws/5W5jYsljNnCYVmNAXlgdRDjLCTYz0u9_JL_4SGay63M'), ('filename', 'gv6-h20e.jpg'), ('size', 35463), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uvXkg0lXJwJZkJXS2d2jbg/XcbJpyot0SlRXd59v6cpHmgRnxC8Z0pmxuJZGx9tyE1_xC--ODfHJZ2sj5Xr9W0QauT0577LrBue5B6T5DuqwQ/0RRdlqwCrcR6nFz1oYEbszq8NE5ohekX_HlZQEpKVDY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/GGUgcKaY9VCaw15r6-md5A/HgCtXd7SPGVGDoc4cionPSUfvvSSNiDooxVipsOQr-CCDYCUYB20ENe1ZsUMy-bY5n2wqfJjXZw2YV2l3XghXA/ZfTghD4IlhCdZ3qN5FOGRGsxf7z50lVOUTg6pyNe9Es'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MjPCTQvCom_s2mvov7chHA/aQ_qwIq35869_mmHhy3btp2zJSLOpPQcjsOQqn3sGkWLa1Mw1TNiEvlNMYeIWW6Snbx160Ru_QWxVksKZ7SZLQ/_V79-ot8yFzLg1dexs9tVDYB1p2_aTmWZVc7_FrUVGo'), ('width', 3000), ('height', 3000)]))]))])]",18000.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125990/Instruments/Vendor%20Logos/Parker.png,"Incorporates all of the powerful features of the Gemini GV digital servo drive
Provides six power ranges for up to 11.8 kW of continuous power
Stand-alone servo controller and drive in one small package
Full ASCII communications capability
Control features such as registration, motion profiles, S-curve velocity profiling and conditional statements
Program storage: Up to 32 programs or 190 lines of program code
Daisy chain up to 99 units
Simplified configuration and tuning
8 programmable inputs and 6 programmable outputs
Wide range of PWM frequencies for linear motor support",https://www.parkermotion.com/products/Servo_Drive_Controllers__5336__30_32_80_567_29.html,Parkergv 6,413.0,['Servo Drive/Controllers'],"A motor controller is a device or group of devices that can coordinate in a predetermined manner the performance of an electric motor. A motor controller might include a manual or automatic means for starting and stopping the motor, selecting forward or reverse rotation, selecting and regulating the speed, regulating or limiting the torque, and protecting against overloads and electrical faults. Motor controllers may use electromechanical switching, or may use power electronics devices to regulate the speed and direction of a motor.","Parker Hannifin Corporation, originally Parker Appliance Company, usually referred to as just Parker, is an American corporation specializing in motion and control technologies.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/parker/parkerGV6.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/parker/parkerGV6.html,Parker,"[OrderedDict([('id', 'att6lk5W7YnbSjvnS'), ('width', 1024), ('height', 393), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-rQbNqxWSc-z5Ohc9rzB-Q/eGQ2r5qwvaHwbEte1Pl_tp9RAOmN719HbQd6wLCZi5qvLg8TQ6C1H_q5Qh9Hihb-4k6uOqjn21WegyNYWwDoDHVs9OlKch3qtCiML-BhIu4oAPpycMxZXtTJDhqGTqkU/rrAXyRCcGuIB3vJeQw-SKSWEYTnfTggeoVpRVBL2TpU'), ('filename', '1024px-Parker_Hannifin.svg_.png'), ('size', 12933), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/o9lx17URnAWt8fNOa12PLg/Cdfh0HLBrg1XHf6Hp1mq_u6gMNhTrlYOkqVFaXNxal6pQqdDDMdq4IesawejpNQJTZwJsLOsCSIVDcz0d_eZZQ/DSjmYqd8pFCRKcxj37y9iNnIV0U5oGz3DMIvz2xFxl8'), ('width', 94), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/gSZ4n0KdKeFeP2-rHe2haQ/O0CeW7sLTpE9xo7Rlu_kqxMqz9-Ra2pmIz9pfyuLGlAnDNENoRmc9O-va0yGeXeWpHG-5DLAMN4wwRxWu8WQYA/1wVLUdQqs1AXvSr8O7ihizsgycIDpzdfUFV8KYc5D5c'), ('width', 1024), ('height', 393)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/NFNuuUQQX8_p8dpWu8HjZw/aUTtEA-i7xGF7q5G_1ocFQBR8yIp_xyuw271601sRzgIwokyXeiv7kCfTKT9-vT_Yh1lz1A6AXIALC466jMwpg/F5e6dTf258O1pbmZBydR948S_czAXPOwfQnFVFx_EDM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.parker.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782707/Instruments/Servo%20Drive/Controllers/Gemini-GV6/Gemini-GV6.jpg,Gemini GV6,Write a Python script that uses Pymeasure to connect to a Gemini GV6 Servo Drive/Controllers,6208.0,,,Price from here: https://shop.appliedindustrialautomation.com/products/GV6-U12E-NK,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from time import sleep
import re


class ParkerGV6(Instrument):
    """""" Represents the Parker Gemini GV6 Servo Motor Controller
    and provides a high-level interface for interacting with
    the instrument
    """"""

    degrees_per_count = 0.00045  # 90 deg per 200,000 count

    def __init__(self, adapter, name=""Parker GV6 Motor Controller"", **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'baud_rate': 9600,
                  'timeout': 500,
                  },
            write_termination=""\r"",
            **kwargs
        )
        self.set_defaults()

    def read(self):
        """""" Overwrites the Instrument.read command to provide the correct
        functionality
        """"""
        # TODO seems to be broken as it does not make sense see issue #623
        return re.sub(r'\r\n\n(>|\?)? ', '', ""\n"".join(self.readlines()))

    def set_defaults(self):
        """""" Sets up the default values for the motor, which
        is run upon construction
        """"""
        self.echo = False
        self.set_hardware_limits(False, False)
        self.use_absolute_position()
        self.average_acceleration = 1
        self.acceleration = 1
        self.velocity = 3

    def reset(self):
        """""" Resets the motor controller while blocking and
        (CAUTION) resets the absolute position value of the motor
        """"""
        self.write(""RESET"")
        sleep(5)
        self.setDefault()
        self.enable()

    def enable(self):
        """""" Enables the motor to move """"""
        self.write(""DRIVE1"")

    def disable(self):
        """""" Disables the motor from moving """"""
        self.write(""DRIVE0"")

    @property
    def status(self):
        """""" Returns a list of the motor status in readable format """"""
        return self.ask(""TASF"").split(""\r\n\n"")

    def is_moving(self):
        """""" Returns True if the motor is currently moving """"""
        return self.position is None

    @property
    def angle(self):
        """""" Returns the angle in degrees based on the position
        and whether relative or absolute positioning is enabled,
        returning None on error
        """"""
        position = self.position
        if position is not None:
            return position * self.degrees_per_count
        else:
            return None

    @angle.setter
    def angle(self, angle):
        """""" Gives the motor a setpoint in degrees based on an
        angle from a relative or absolution position
        """"""
        self.position = int(angle * self.degrees_per_count**-1)

    @property
    def angle_error(self):
        """""" Returns the angle error in degrees based on the
        position error, or returns None on error
        """"""
        position_error = self.position_error
        if position_error is not None:
            return position_error * self.degrees_per_count
        else:
            return None

    @property
    def position(self):
        """""" Returns an integer number of counts that correspond to
        the angular position where 1 revolution equals 4000 counts
        """"""
        match = re.search(r'(?<=TPE)-?\d+', self.ask(""TPE""))
        if match is None:
            return None
        else:
            return int(match.group(0))

    @position.setter
    def position(self, counts):  # in counts: 4000 count = 1 rev
        """""" Gives the motor a setpoint in counts where 4000 counts
        equals 1 revolution
        """"""
        self.write(""D"" + str(int(counts)))

    @property
    def position_error(self):
        """""" Returns the error in the number of counts that corresponds
        to the error in the angular position where 1 revolution equals
        4000 counts
        """"""
        match = re.search(r'(?<=TPER)-?\d+', self.ask(""TPER""))
        if match is None:
            return None
        else:
            return int(match.group(0))

    def move(self):
        """""" Initiates the motor to move to the setpoint """"""
        self.write(""GO"")

    def stop(self):
        """""" Stops the motor during movement """"""
        self.write(""S"")

    def kill(self):
        """""" Stops the motor """"""
        self.write(""K"")

    def use_absolute_position(self):
        """""" Sets the motor to accept setpoints from an absolute
        zero position
        """"""
        self.write(""MA1"")
        self.write(""MC0"")

    def use_relative_position(self):
        """""" Sets the motor to accept setpoints that are relative
        to the last position
        """"""
        self.write(""MA0"")
        self.write(""MC0"")

    def set_hardware_limits(self, positive=True, negative=True):
        """""" Enables (True) or disables (False) the hardware
        limits for the motor
        """"""
        if positive and negative:
            self.write(""LH3"")
        elif positive and not negative:
            self.write(""LH2"")
        elif not positive and negative:
            self.write(""LH1"")
        else:
            self.write(""LH0"")

    def set_software_limits(self, positive, negative):
        """""" Sets the software limits for motion based on
        the count unit where 4000 counts is 1 revolution
        """"""
        self.write(""LSPOS%d"" % int(positive))
        self.write(""LSNEG%d"" % int(negative))

    @property
    def echo(self):
        pass

    @echo.setter
    def echo(self, enable=False):
        """""" Enables (True) or disables (False) the echoing
        of all commands that are sent to the instrument
        """"""
        if enable:
            self.write(""ECHO1"")
        else:
            self.write(""ECHO0"")

    @property
    def acceleration(self):
        pass  # TODO: Implement acceleration return value

    @acceleration.setter
    def acceleration(self, acceleration):
        """""" Sets the acceleration setpoint in revolutions per second
        squared
        """"""
        self.write(""A"" + str(float(acceleration)))

    @property
    def average_acceleration(self):
        pass  # TODO: Implement average_acceleration return value

    @average_acceleration.setter
    def average_acceleration(self, acceleration):
        """""" Sets the average acceleration setpoint in revolutions
        per second squared
        """"""
        self.write(""AA"" + str(float(acceleration)))

    @property
    def velocity(self):
        pass  # TODO: Implement velocity return value

    @velocity.setter
    def velocity(self, velocity):  # in revs/s
        """""" Sets the velocity setpoint in revolutions per second """"""
        self.write(""V"" + str(float(velocity)))
"
322,https://cdn.tmi.yokogawa.com/1/7543/files/BUGS200-01EN.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attVoxpUxYSQ6kk0I'), ('width', 800), ('height', 366), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/WOtySualr5eLXsabQbBafQ/lH_gXB9PdqddpuiYViiE2IxvqmxkH74gh904Uma0Bl1erwgOHZdVQ7PQ_bRGptHlyIKFY3gdH0pDUOVg4suhX0gJlPeBo5HbKwk-oRjL-x4/J5lQUqvFmyvqFfpdTr48vwIKiTS8Zj3AmekVmh1CfZw'), ('filename', 'gs200_4.jpg'), ('size', 54439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/2YSan3QL3-n6eMXG3n2meQ/l7sAm3lr8oJRT-KF3WVbW59rf19sn16BvYLVpeOcB_iNMaYUpa2KlZExBBR8Hs67gZWJ2th_ZhH1G0z_eieimA/dk_U64u5HeBz-ANNljHF27EjhbCCI_0UU3_ie3Ue_vY'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/N8mu2zJbffaShxt_abXSOg/xAs_BseVKtWYAz59k5Mb46Ofws4cEekDzsCs0-z5UQjpNtjwUqLWCrYChhp8vhgOmLZ_9YalZDL40IX720n7ag/C8UUcotBrdFmieInal-_kHV_OHuFavjXTDNw8SeO2LU'), ('width', 800), ('height', 366)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cgxCwKxrA0etHuy0IyMyQw/0XmAqhLnFedEB_kaU58nKatsX4qA9S8zmYesToYF69wRKVVF2upBqxtYNjN5DKkJ7a_9F3AL-4fxmpgh74Karg/B4CS7LR1MITSkWC69RcJAHDgChN40OU2hozFd0LGqNE'), ('width', 3000), ('height', 3000)]))]))])]",318.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125993/Instruments/Vendor%20Logos/Yokogawa.png,"The GS200 is a low voltage/current DC source with high accuracy, high stability, and high resolution. With its excellent traceability, stability, and 5 1/2-digit resolution, the GS200 generates extremely low-noise DC voltage and current signals that are required for many applications. Additionally, the optional monitoring feature turns the GS200 into a voltage and current measuring instrument.",https://tmi.yokogawa.com/ca/solutions/products/generators-sources/source-measure-units/gs200/,Yokogawags 200,638.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/yokogawa/yokogawags200.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/yokogawa/yokogawags200.html,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/91EkiaJqR32pXT_9j2ikkA/EA8IX6bgJJ5AWHxSJn_XsjdpYAbFM-YDdqUbrZWF93R43aeTp5aElLydj7HEdEh8wo2jzLCFOTdCKUYUpJSqs1zbr_NokqlVS5aCZUEOXdQ/4kbrVwXBbGOLMD1hKLvO7wdukSK2boAdCxBHEMhRvXw'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mLKN3BYMkiZUdn2rlRmVtw/cw3TDV5BlW5jr47wsWYGUsjqEQZbKDvc2mw_Lv9aXzgXtFoYC1bkplw5NhTSdUeNveYCSzsYG9fK-1b24lGzfQ/umhRd2RrT6tf47pL7QQ-NfYCvL9z9J5dB71Th5o0jzE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/a3VAY9DVGC-aEBfsilZ3xw/8a9ejY3MgpFLh3YMiQ-k86blOpOc7VPmtTlcvVeTvXbTwq9ckonmesZx3cT_rNdybRDFFOAT9g5kdq8SOraK_Q/uf6rR_lz7JMeO4cE-hHB-59T8gCRIwI7dhqfDVgASSo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EXvJLqLv0Q1zEcaZ4OYDWw/W05CyYIR7E-TtqueHjX1znSLYTjKMcUW9Z2jdHtLIXhVcPktYi-xnoq2dtrhqqf6FOnJ9gLxlUF3R1y-zUaZzw/5MptEU6yLCcaC2jBAtxU_UfVh58yJurgp_UIp0qIdX8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782709/Instruments/Power%20Supplies/Yokogawa-GS-200/Yokogawa-GS-200.jpg,Yokogawa GS 200,Write a Python script that uses Pymeasure to connect to a Yokogawa GS 200 Power Supplies,3499.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set, truncated_discrete_set, truncated_range
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

MIN_RAMP_TIME = 0.1  # seconds


class YokogawaGS200(Instrument):
    """""" Represents the Yokogawa GS200 source and provides a high-level interface for interacting
    with the instrument. """"""

    source_enabled = Instrument.control(
        ""OUTPut:STATe?"",
        ""OUTPut:STATe %d"",
        """"""A boolean property that controls whether the source is enabled, takes values
        True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_mode = Instrument.control(
        "":SOURce:FUNCtion?"",
        "":SOURce:FUNCtion %s"",
        """"""String property that controls the source mode. Can be either 'current' or 'voltage'."""""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        get_process=lambda s: s.strip()
    )

    source_range = Instrument.control(
        "":SOURce:RANGe?"",
        ""SOURce:RANGe %g"",
        """"""Floating point number that controls the range (either in voltage or current)
        of the output. ""Range"" refers to the maximum source level. """""",
        validator=truncated_discrete_set,
        values=[1e-3, 10e-3, 100e-3, 200e-3, 1, 10, 30]
    )

    voltage_limit = Instrument.control(
        ""SOURce:PROTection:VOLTage?"",
        ""SOURce:PROTection:VOLTage %g"",
        """"""Floating point number that controls the voltage limit. ""Limit"" refers to maximum
        value of the electrical value that is conjugate to the mode (current is conjugate to
        voltage, and vice versa). Thus, voltage limit is only applicable when in 'current' mode"""""",
        validator=truncated_range,
        values=[1, 30]
    )

    current_limit = Instrument.control(
        ""SOURce:PROTection:CURRent?"",
        ""SOURce:PROTection:CURRent %g"",
        """"""Floating point number that controls the current limit. ""Limit"" refers to maximum value
        of the electrical value that is conjugate to the mode (current is conjugate to voltage,
        and vice versa). Thus, current limit is only applicable when in 'voltage' mode"""""",
        validator=truncated_range,
        values=[1e-3, 200e-3]
    )

    def __init__(self, adapter, name=""Yokogawa GS200 Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    @property
    def source_level(self):
        """""" Floating point number that controls the output level, either a voltage or a current,
        depending on the source mode.
        """"""
        return float(self.ask("":SOURce:LEVel?""))

    @source_level.setter
    def source_level(self, level):
        if level > self.source_range * 1.2:
            raise ValueError(
                ""Level must be within 1.2 * source_range, otherwise the Yokogawa will produce an ""
                ""error.""
            )
        else:
            self.write(""SOURce:LEVel %g"" % level)

    def trigger_ramp_to_level(self, level, ramp_time):
        """"""
        Ramp the output level from its current value to ""level"" in time ""ramp_time"". This method
        will NOT wait until the ramp is finished (thus, it will not block further code evaluation).

        :param float level: final output level
        :param float ramp_time: time in seconds to ramp
        :return: None
        """"""
        if not self.source_enabled:
            raise ValueError(
                ""YokogawaGS200 source must be enabled in order to ramp to a specified level. ""
                ""Otherwise, the Yokogawa will reject the ramp.""
            )
        if ramp_time < MIN_RAMP_TIME:
            log.warning(
                f""Ramp time of {ramp_time}s is below the minimum ramp time of {MIN_RAMP_TIME}s, ""
                f""so the Yokogawa will instead be instantaneously set to the desired level.""
            )
            self.source_level = level
        else:
            # Use the Yokogawa's ""program"" mode to create the ramp
            ramp_program = (
                f"":program:edit:start;""
                f"":source:level {level};""
                f"":program:edit:end;""
            )
            # set ""interval time"" equal to ""slope time"" to make a continuous ramp
            ramp_program += (
                f"":program:interval {ramp_time};""
                f"":program:slope {ramp_time};""
            )
            # run it once
            ramp_program += (
                "":program:repeat 0;""
                "":program:run""
            )
            self.write(ramp_program)
"
324,http://www.andeen-hagerling.com/ah2700a.pdf,https://electricalacademia.com/instrumentation-and-measurements/capacitance-bridge-circuit/,"[OrderedDict([('id', 'attTIP6EtYa88Q5Do'), ('width', 500), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PYb6PE6m-4rrOj36ANXqRg/ZYqqBq-eRfBCwqKQlJtcf8FUiasrAAD-0sUuyKoux2CYtkuAoHoY_RAKKPJBPWUwM3OyztGt_E6S-YJdlyL9KeRKp8EqGYE-G_JgvXbyAZM/Kslsdu-KCyC0IM_JlrPElXFcWh6hWuuOndQbnX8IDmI'), ('filename', 'MODEL2700-500x500w.jpg'), ('size', 28499), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rBBJytSP5vWZKWCqNnvtVQ/gr8A0WmtCQr4sRHaQPhZJQXNsm95STzMYAxlfcgDQau0-qKMsp-ObFYC2hZhhGf2fKUwPRGtSyHRkXhVW-96Vg/4nuTEuMDdCwrpq9tmarCLKSwgK7-fQ_ayzcxBPhGL2k'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-InidsVnMeQRS45swLSl7Q/2KC4OXW55jZzQKZovY3vwj28h4lxVF17_cutmPdm1IDM_nAv7yQkdrEiIysnX8JuwA38pRflRc3VbYFPtWvcYg/3dEzt1Z0YlYpNeZnjdz2U3b3E7vGzz6d6-lMy_OEpos'), ('width', 500), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FSLBu-iQIH96brlCgnuf9w/fsxJrDpEmrgL9kfJaqyQlhrkhvM1ksuMT0gGVSl_u7PsQqBvbWYnBqw3QdjK9ykGvGeX2e2CVuB5M9k2GcqwMA/tzqA3SalgY0sgtHd-XfuYY2qzeh8JEg8c9ydLI5vx64'), ('width', 3000), ('height', 3000)]))]))])]",1.0,US,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126007/Instruments/Vendor%20Logos/Andeen_Hagerling.png,"The Andeen-Hagerling AH 2700A offers unparalleled stability, resolution, linearity and accuracy in a multi-frequency capacitance/loss bridge. Its numerous state-of-the-art features make it an exceptionally user-friendly instrument, measuring capacitance and loss in medium and high impedance ranges, and thus allows using three-terminal rather than five-terminal connections to the DUT (Device Under Test).

The new AH 2700A-E offers substantially improved resolution over the entire operating range, bringing a super-sensitivity that enables it to explore applications in calibration, scientific research, and manufacturing with a new precision.

The AH2700A-E is the pinnacle of decades of Andeen-Hagerling experience in bridge design and manufacture, and is complemented by its sister model, the AH2700A-E-C that offers continuous frequency scanning.",http://www.andeen-hagerling.com/ah2700a.htm,AH 2700 A,79.0,['Multimeters'],"Capacitance Bridge
A Maxwell Inductance Capacitance Bridge (known as a Maxwell Bridge) is a modified version of a Wheatstone bridge which is used to measure the self-inductance of a circuit.","**Andeen**-**Hagerling**, Inc. - manufacturers of the world's most accurate capacitance bridges and standards

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/andeenhagerling/ah2700a.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/andeenhagerling/ah2700a.html,Andeen Hagerling,"[OrderedDict([('id', 'attHkizub4S6653G8'), ('width', 375), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/w8HZCN3hkRZWjBLsyALYDg/GP_H_v14QE8z5cObyjq9fmEhIDco53VmNgjz8Obr-HyaUBBy6n50oDw9yis-A3JSbW5roCz5iDYhaEvhKOrj-x-uHw6WYNOXAv0as0aN43c/_lgsrU1TYCsm4CWuBw-99ybrtCkGQEcKY6H_dBt5wjI'), ('filename', 'AH_Logo-375x200.jpg'), ('size', 5603), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vWse7hPPSXN_2x8l5Gt6eQ/fZ_h1mFQ_4UleUfN96I7Y4tUexQElcDij_5_0U8FKO7KQSg7wqQtQIwHrdKEaBHwQGpzPDTT4ft_D8UrSTdrqw/C9MJ5jqQ6ZAdxeDKn24TD8PoWVhY6stR30CoQlz16LQ'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A41FyOu0RdPrh3lfeudpKA/z4g7cthQ9gjK3wlZ33S-h6ErwF2mmiRZtytc65J4cnQ4qrGs3OAfIDF_y1qykcuvYabC8klFBF28uqtCyDw0lQ/uL27d_KFi9JBDDb2jPWhf6eWRgAOE9aPNQVg7CwHgMc'), ('width', 375), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/M4d5r7z2xdgpKrLvj2UPLQ/8aRPBzcumkhMFg4t0cz-w4JzfQ1M4a4fa3vs6tKN3Zg8cJ7AfV_bVoReWPH7ZAZBEhnqOXNHVMMhswKVDS__sA/w8NH3QBpTtbv5Il9kXNb5uwQLFS9Do3CTiZ7_n8re_o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.andeen-hagerling.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782710/Instruments/Multimeters/2700A-Bridge/2700A-Bridge.jpg,2700A Bridge,Write a Python script that uses Pymeasure to connect to a 2700A Bridge Multimeters,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range
from .ah2500a import AH2500A


class AH2700A(AH2500A):
    """""" Andeen Hagerling 2700A Precision Capacitance Bridge implementation
    """"""
    def __init__(self, adapter, name=""Andeen Hagerling 2700A Precision Capacitance Bridge"",
                 timeout=5000, **kwargs):
        super().__init__(
            adapter,
            name=name,
            timeout=timeout,
            **kwargs
        )

    id = Instrument.measurement(
        ""*IDN?"", """""" Reads the instrument identification """"""
    )

    config = Instrument.measurement(
        ""SHOW ALL"",
        """""" Read out configuration """""",
    )

    frequency = Instrument.control(
        ""SH FR"", ""FR %.1f"",
        """"""test frequency used for the measurements. Allowed are values between
        50 and 20000 Hz. The device selects the closest possible frequency to
        the given value."""""",
        validator=strict_range,
        values=[50, 20000],
        # typical reply: ""FREQUENCY      1200.0 Hz""
        get_process=lambda v: float(AH2500A._renumeric.search(v).group(0)),
    )

    def reset(self):
        """""" Resets the instrument. """"""
        self.write(""*RST"")

    def trigger(self):
        """"""
        Triggers a new measurement without blocking and waiting for the return
        value.
        """"""
        self.write(""*TRG"")
        self._triggered = True
"
327,https://download.tek.com/datasheet/6220-6221.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attAMc0ndlQOH57r9'), ('width', 218), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Zf-Fx9fdOKOpN41H5xt_BA/FAGUmn_celvT3g7khisVPHNowlFTTp5Czuin9SYUKdP9s3DEu-tPkmQ0SgtvqLW00BaXHnQTigAo0OGjHqxBd9rRugKMnvhA5zJr1rRpG8I/dmzrOUDgCINYDO6et6LebvetY3iyiSkFiopfreKPgEg'), ('filename', '6221.webp'), ('size', 4854), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wN3_trW3lLF5eCYvBaW_lA/W3o8NM7txTU9SwQ7BeFFZqPeld-w5btesbtX7yocqRHk08QFh1BpNGhYhPTQ_36HKVKZN8wwrzVPqCgaljLh5zN8wrxf_KllL6pej4BbsKA/tSe2CngoQ_whMaR8sQ7VxK4hOmZdj-srs_rYW2kM2GU'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/YJPBCt4cLV28JRJKD_HuNQ/3uySpyLppcoMC6iNhN1-p-ijDe5MbZaEgJwjj-aaqqWBB4ytWcYYTZD5Vuu2SmbY9mdy0ZF5sB63NUlBz-Ic3GGJums-iTLIXguiCdqXzYQ/LD-XyKjaPCm0vuNifbOwCp1otrZuRlwwFzkdaVKIB2w'), ('width', 218), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/E69MTTXf0c2AQpLqbwYg-w/OYeTuq9SWHBcNXZA10-8Ptlj3boZ27miUalhLS-C_XdqWfiCN6GivKTYrNE9JBwBsJdoaKy43AzXiuGY1lelwq4PdqoDRfrjOtD5xTjN-CQ/MQ4B2usZJLC1EyTzeI8ASczqnkXlSNIQUfJ9sscmKVw'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",https://canada.newark.com/keithley/6221/source-meter-ac-dc-current-11w/dp/54K3077,Keithley 6221,213.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6221.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6221.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782550/Instruments/Power%20Supplies/Keithley-6221/Keithley-6221.webp,Keithley 6221,Write a Python script that uses Pymeasure to connect to a Keithley 6221 Power Supplies,11620.4,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument, RangeException
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6221(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6221 AC and DC current source and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6221(""GPIB::1"")
        keithley.clear()

        # Use the keithley as an AC source
        keithley.waveform_function = ""square""   # Set a square waveform
        keithley.waveform_amplitude = 0.05      # Set the amplitude in Amps
        keithley.waveform_offset = 0            # Set zero offset
        keithley.source_compliance = 10         # Set compliance (limit) in V
        keithley.waveform_dutycycle = 50        # Set duty cycle of wave in %
        keithley.waveform_frequency = 347       # Set the frequency in Hz
        keithley.waveform_ranging = ""best""      # Set optimal output ranging
        keithley.waveform_duration_cycles = 100 # Set duration of the waveform

        # Link end of waveform to Service Request status bit
        keithley.operation_event_enabled = 128  # OSB listens to end of wave
        keithley.srq_event_enabled = 128        # SRQ listens to OSB

        keithley.waveform_arm()                 # Arm (load) the waveform

        keithley.waveform_start()               # Start the waveform

        keithley.adapter.wait_for_srq()         # Wait for the pulse to finish

        keithley.waveform_abort()               # Disarm (unload) the waveform

        keithley.shutdown()                     # Disables output

    """"""

    ##########
    # OUTPUT #
    ##########

    source_enabled = Instrument.control(
        ""OUTPut?"", ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False. The convenience methods :meth:`~.Keithley6221.enable_source` and
        :meth:`~.Keithley6221.disable_source` can also be used."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_delay = Instrument.control(
        "":SOUR:DEL?"", "":SOUR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 1e-3 [seconds] and 999999.999 [seconds]."""""",
        validator=truncated_range,
        values=[1e-3, 999999.999],
    )

    output_low_grounded = Instrument.control(
        "":OUTP:LTE?"", ""OUTP:LTE %d"",
        """""" A boolean property that controls whether the low output of the triax
        connection is connected to earth ground (True) or is floating (False). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    ##########
    # SOURCE #
    ##########

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR %g"",
        """""" A floating point property that controls the source current
        in Amps. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_compliance = Instrument.control(
        "":SOUR:CURR:COMP?"", "":SOUR:CURR:COMP %g"",
        """"""A floating point property that controls the compliance of the current
        source in Volts. valid values are in range 0.1 [V] to 105 [V]."""""",
        validator=truncated_range,
        values=[0.1, 105])
    source_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -0.105 A and +0.105 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_auto_range = Instrument.control(
        "":SOUR:CURR:RANG:AUTO?"", "":SOUR:CURR:RANG:AUTO %d"",
        """""" A boolean property that controls the auto range of the current source.
        Valid values are True or False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ##################
    # WAVE FUNCTIONS #
    ##################

    waveform_function = Instrument.control(
        "":SOUR:WAVE:FUNC?"", "":SOUR:WAVE:FUNC %s"",
        """""" A string property that controls the selected wave function. Valid
        values are ""sine"", ""ramp"", ""square"", ""arbitrary1"", ""arbitrary2"",
        ""arbitrary3"" and ""arbitrary4"". """""",
        values={
            ""sine"": ""SIN"",
            ""ramp"": ""RAMP"",
            ""square"": ""SQU"",
            ""arbitrary1"": ""ARB1"",
            ""arbitrary2"": ""ARB2"",
            ""arbitrary3"": ""ARB3"",
            ""arbitrary4"": ""ARB4"",
        },
        map_values=True
    )

    waveform_frequency = Instrument.control(
        "":SOUR:WAVE:FREQ?"", "":SOUR:WAVE:FREQ %g"",
        """"""A floating point property that controls the frequency of the
        waveform in Hertz. Valid values are in range 1e-3 to 1e5. """""",
        validator=truncated_range,
        values=[1e-3, 1e5]
    )
    waveform_amplitude = Instrument.control(
        "":SOUR:WAVE:AMPL?"", "":SOUR:WAVE:AMPL %g"",
        """"""A floating point property that controls the (peak) amplitude of the
        waveform in Amps. Valid values are in range 2e-12 to 0.105. """""",
        validator=truncated_range,
        values=[2e-12, 0.105]
    )
    waveform_offset = Instrument.control(
        "":SOUR:WAVE:OFFS?"", "":SOUR:WAVE:OFFS %g"",
        """"""A floating point property that controls the offset of the waveform
        in Amps. Valid values are in range -0.105 to 0.105. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    waveform_dutycycle = Instrument.control(
        "":SOUR:WAVE:DCYC?"", "":SOUR:WAVE:DCYC %g"",
        """"""A floating point property that controls the duty-cycle of the
        waveform in percent for the square and ramp waves. Valid values are in
        range 0 to 100. """""",
        validator=truncated_range,
        values=[0, 100]
    )
    waveform_duration_time = Instrument.control(
        "":SOUR:WAVE:DUR:TIME?"", "":SOUR:WAVE:DUR:TIME %g"",
        """"""A floating point property that controls the duration of the
        waveform in seconds. Valid values are in range 100e-9 to 999999.999.
        """""",
        validator=truncated_range,
        values=[100e-9, 999999.999]
    )
    waveform_duration_cycles = Instrument.control(
        "":SOUR:WAVE:DUR:CYCL?"", "":SOUR:WAVE:DUR:CYCL %g"",
        """"""A floating point property that controls the duration of the
        waveform in cycles. Valid values are in range 1e-3 to 99999999900.
        """""",
        validator=truncated_range,
        values=[1e-3, 99999999900]
    )

    def waveform_duration_set_infinity(self):
        """""" Set the waveform duration to infinity.
        """"""
        self.write("":SOUR:WAVE:DUR:TIME INF"")

    waveform_ranging = Instrument.control(
        "":SOUR:WAVE:RANG?"", "":SOUR:WAVE:RANG %s"",
        """""" A string property that controls the source ranging of the
        waveform. Valid values are ""best"" and ""fixed"". """""",
        values={""best"": ""BEST"", ""fixed"": ""FIX""},
        map_values=True,
    )
    waveform_use_phasemarker = Instrument.control(
        "":SOUR:WAVE:PMAR:STAT?"", "":SOUR:WAVE:PMAR:STAT %s"",
        """""" A boolean property that controls whether the phase marker option
        is turned on or of. Valid values True (on) or False (off). Other
        settings for the phase marker have not yet been implemented."""""",
        values={True: 1, False: 0},
        map_values=True,
    )
    waveform_phasemarker_phase = Instrument.control(
        "":SOUR:WAVE:PMAR?"", "":SOUR:WAVE:PMAR %g"",
        """""" A numerical property that controls the phase of the phase marker."""""",
        validator=truncated_range,
        values=[-180, 180],
    )
    waveform_phasemarker_line = Instrument.control(
        "":SOUR:WAVE:PMAR:OLIN?"", "":SOUR:WAVE:PMAR:OLIN %d"",
        """""" A numerical property that controls the line of the phase marker."""""",
        validator=truncated_range,
        values=[1, 6],
    )

    def waveform_arm(self):
        """""" Arm the current waveform function. """"""
        self.write("":SOUR:WAVE:ARM"")

    def waveform_start(self):
        """""" Start the waveform output. Must already be armed """"""
        self.write("":SOUR:WAVE:INIT"")

    def waveform_abort(self):
        """""" Abort the waveform output and disarm the waveform function. """"""
        self.write("":SOUR:WAVE:ABOR"")

    def define_arbitary_waveform(self, datapoints, location=1):
        """""" Define the data points for the arbitrary waveform and copy the
        defined waveform into the given storage location.

        :param datapoints: a list (or numpy array) of the data points; all
            values have to be between -1 and 1; 100 points maximum.
        :param location: integer storage location to store the waveform in.
            Value must be in range 1 to 4.
        """"""

        # Check validity of parameters
        if not isinstance(datapoints, (list, np.ndarray)):
            raise ValueError(""datapoints must be a list or numpy array"")
        elif len(datapoints) > 100:
            raise ValueError(""datapoints cannot be longer than 100 points"")
        elif not all([x >= -1 and x <= 1 for x in datapoints]):
            raise ValueError(""all data points must be between -1 and 1"")

        if location not in [1, 2, 3, 4]:
            raise ValueError(""location must be in [1, 2, 3, 4]"")

        # Make list of strings
        datapoints = [str(x) for x in datapoints]
        data = "", "".join(datapoints)

        # Write the data points to the Keithley 6221
        self.write("":SOUR:WAVE:ARB:DATA %s"" % data)

        # Copy the written data to the specified location
        self.write("":SOUR:WAVE:ARB:COPY %d"" % location)

        # Select the newly made arbitrary waveform as waveform function
        self.waveform_function = ""arbitrary%d"" % location

    def __init__(self, adapter, name=""Keithley 6221 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """""" A boolean property that controls whether or not the display of the
        sourcemeter is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6221 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6221 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":ARM:SOUR IMM;:TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":ARM:SOUR BUS;:TRIG:SOUR BUS;"")

    def set_timed_arm(self, interval):
        """""" Sets up the measurement to be taken with the internal
        trigger at a variable sampling rate defined by the interval
        in seconds between sampling points
        """"""
        if interval > 99999.99 or interval < 0.001:
            raise RangeException(""Keithley 6221 can only be time""
                                 "" triggered between 1 mS and 1 Ms"")
        self.write("":ARM:SOUR TIM;:ARM:TIM %.3f"" % interval)

    def trigger_on_external(self, line=1):
        """""" Configures the measurement trigger to be taken from a
        specific line of an external trigger

        :param line: A trigger line from 1 to 4
        """"""
        cmd = "":ARM:SOUR TLIN;:TRIG:SOUR TLIN;""
        cmd += "":ARM:ILIN %d;:TRIG:ILIN %d;"" % (line, line)
        self.write(cmd)

    def output_trigger_on_external(self, line=1, after='DEL'):
        """""" Configures the output trigger on the specified trigger link
        line number, with the option of supplying the part of the
        measurement after which the trigger should be generated
        (default to delay, which is right before the measurement)

        :param line: A trigger line from 1 to 4
        :param after: An event string that determines when to trigger
        """"""
        self.write("":TRIG:OUTP %s;:TRIG:OLIN %d;"" % (after, line))

    def disable_output_trigger(self):
        """""" Disables the output trigger for the Trigger layer
        """"""
        self.write("":TRIG:OUTP NONE"")

    def shutdown(self):
        """""" Disables the output. """"""
        log.info(""Shutting down %s."" % self.name)
        self.disable_source()
        super().shutdown()

    ###############
    # Status bits #
    ###############

    measurement_event_enabled = Instrument.control(
        "":STAT:MEAS:ENAB?"", "":STAT:MEAS:ENAB %d"",
        """""" An integer value that controls which measurement events are
        registered in the Measurement Summary Bit (MSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    operation_event_enabled = Instrument.control(
        "":STAT:OPER:ENAB?"", "":STAT:OPER:ENAB %d"",
        """""" An integer value that controls which operation events are
        registered in the Operation Summary Bit (OSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    questionable_event_enabled = Instrument.control(
        "":STAT:QUES:ENAB?"", "":STAT:QUES:ENAB %d"",
        """""" An integer value that controls which questionable events are
        registered in the Questionable Summary Bit (QSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    standard_event_enabled = Instrument.control(
        ""ESE?"", ""ESE %d"",
        """""" An integer value that controls which standard events are
        registered in the Event Summary Bit (ESB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    srq_event_enabled = Instrument.control(
        ""*SRE?"", ""*SRE %d"",
        """""" An integer value that controls which event registers trigger the
        Service Request (SRQ) status bit. Refer to the Model 6220/6221
        Reference Manual for more information about programming the status
        bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 255],
    )

    measurement_events = Instrument.measurement(
        "":STAT:MEAS?"",
        """""" An integer value that reads which measurement events have been
        registered in the Measurement event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    operation_events = Instrument.measurement(
        "":STAT:OPER?"",
        """""" An integer value that reads which operation events have been
        registered in the Operation event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    questionable_events = Instrument.measurement(
        "":STAT:QUES?"",
        """""" An integer value that reads which questionable events have been
        registered in the Questionable event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    standard_events = Instrument.measurement(
        ""*ESR?"",
        """""" An integer value that reads which standard events have been
        registered in the Standard event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )
"
349,https://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/centre-for-bio-inspired-technology/7291001.PDF,https://en.wikipedia.org/wiki/Source_measure_unit,"[OrderedDict([('id', 'attZjpRLn6xDfl4Di'), ('width', 800), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/68_46svd2PI4pu9mvxy8CQ/iNo9TSUFYNIDC3RaXo1bpPlo-sOeemO_79PSa3RZ8AppK4g3EkcFzKzTxFXuyzWGekBoDsvIFmYNGa18pFJQH8p0UNm066Ln5wXuWqxXhTM/ELqnXttinH1ygQxNCSEFD9H5CmYY84CHywRIeoRmxU4'), ('filename', 'keithley_2600b.jpg'), ('size', 153165), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/IzuC5KOK-3nBNMYlrcSWfw/1bs_nWrHCiM9zmKw-rpLzb8lN7I8d3Mq-InuoPLbYPnozfwkwytms0m8JS0wisEi9UnjzfDAS2-XQgjYrbo1Mw/EE3_4Kixz-x4E-m9zijAKdHDTq3fMZ6E_ZPSyoRctCM'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/krknjsFsTrfgpSaDDvcHkQ/5bPlitcg-D1bB1v57v38-n7x8t2xR2_MGXx6U5q1weMrE42274x8cA4QDQ-1hbWX84rKDh9J7NMtF_jPn_VCIA/bjxxxYD8O08VmDJlVVbaRFvzfvKhoOpTbnwLNMliVWQ'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PwI3jlZ12jmdj5M4DvH-xQ/oF8bdgEhNDXEvpTR6Wa-_yBeFCOsvySJq-fTwYIJbYsvixirMuITKwmXHW6dYohyXqb3VNfdb2j9EFa4ImiiLQ/pKE7eBVpCNGwWW25AFf9-cjoQ0ihDdM5kGEKZlWqnUM'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"Series 2600A System SourceMeter instruments are Keithley’s latest I-V source measurement unit
(SMU) instruments for use as either bench-top I-V characterization tools or as building block components of multi-channel I-V test systems. For bench-top use, Series 2600A instruments feature an
embedded TSP Express Software Tool that allows users to quickly and easily perform common I-V
tests without programming or installing software. For system level applications, the Series 2600A’s
Test Script Processor (TSP) architecture, along with other new capabilities such as parallel test execution and precision timing, provides the highest throughput in the industry, lowering the cost of test.
To simplify the testing, verification, and analysis of semiconductor components, the optional ACS
Basic Edition software is also available.",https://alltest.net/categories/products/2602A-Keithley,Keithley 2600,216.0,['Power Supplies'],"A source measure unit (SMU) is a type of electronic test equipment which, as the name indicates, is capable of both sourcing and measuring at the same time.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2600.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2600.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782732/Instruments/Power%20Supplies/Keithley-2600/Keithley-2600.jpg,Keithley 2600,Write a Python script that uses Pymeasure to connect to a Keithley 2600 Power Supplies,,,,,"# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2600(Instrument):
    """"""Represents the Keithley 2600 series (channel A and B) SourceMeter""""""

    def __init__(self, adapter, name=""Keithley 2600 SourceMeter"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ChA = Channel(self, 'a')
        self.ChB = Channel(self, 'b')

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.ask('print(errorqueue.next())')
        err = err.split('\t')
        # Keithley Instruments Inc. sometimes on startup
        # if tab delimitated message is greater than one, grab first two as code, message
        # otherwise, assign code & message to returned error
        if len(err) > 1:
            err = (int(float(err[0])), err[1])
            code = err[0]
            message = err[1].replace('""', '')
        else:
            code = message = err[0]
        log.info(f""ERROR {str(code)},{str(message)} - len {str(len(err))}"")
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2600 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2600 error retrieval."")


class Channel:

    def __init__(self, instrument, channel):
        self.instrument = instrument
        self.channel = channel

    def ask(self, cmd):
        return float(self.instrument.ask(f'print(smu{self.channel}.{cmd})'))

    def write(self, cmd):
        self.instrument.write(f'smu{self.channel}.{cmd}')

    def values(self, cmd, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any key-word arguments.
        """"""
        return self.instrument.values(f'print(smu{self.channel}.{cmd})')

    def binary_values(self, cmd, header_bytes=0, dtype=np.float32):
        return self.instrument.binary_values('print(smu%s.%s)' %
                                             (self.channel, cmd,), header_bytes, dtype)

    def check_errors(self):
        return self.instrument.check_errors()

    source_output = Instrument.control(
        'source.output', 'source.output=%d',
        """"""Property controlling the channel output state (ON of OFF)
        """""",
        validator=strict_discrete_set,
        values={'OFF': 0, 'ON': 1},
        map_values=True
    )

    source_mode = Instrument.control(
        'source.func', 'source.func=%d',
        """"""Property controlling the channel soource function (Voltage or Current)
        """""",
        validator=strict_discrete_set,
        values={'voltage': 1, 'current': 0},
        map_values=True
    )

    measure_nplc = Instrument.control(
        'measure.nplc', 'measure.nplc=%f',
        """""" Property controlling the nplc value """""",
        validator=truncated_range,
        values=[0.001, 25],
        map_values=True
    )

    ###############
    # Current (A) #
    ###############
    current = Instrument.measurement(
        'measure.i()',
        """""" Reads the current in Amps """"""
    )

    source_current = Instrument.control(
        'source.leveli', 'source.leveli=%f',
        """""" Property controlling the applied source current """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    compliance_current = Instrument.control(
        'source.limiti', 'source.limiti=%f',
        """""" Property controlling the source compliance current """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    source_current_range = Instrument.control(
        'source.rangei', 'source.rangei=%f',
        """"""Property controlling the source current range """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    current_range = Instrument.control(
        'measure.rangei', 'measure.rangei=%f',
        """"""Property controlling the measurement current range """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    ###############
    # Voltage (V) #
    ###############
    voltage = Instrument.measurement(
        'measure.v()',
        """""" Reads the voltage in Volts """"""
    )

    source_voltage = Instrument.control(
        'source.levelv', 'source.levelv=%f',
        """""" Property controlling the applied source voltage """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    compliance_voltage = Instrument.control(
        'source.limitv', 'source.limitv=%f',
        """""" Property controlling the source compliance voltage """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    source_voltage_range = Instrument.control(
        'source.rangev', 'source.rangev=%f',
        """"""Property controlling the source current range """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    voltage_range = Instrument.control(
        'measure.rangev', 'measure.rangev=%f',
        """"""Property controlling the measurement voltage range """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    ####################
    # Resistance (Ohm) #
    ####################
    resistance = Instrument.measurement(
        'measure.r()',
        """""" Reads the resistance in Ohms """"""
    )

    wires_mode = Instrument.control(
        'sense', 'sense=%d',
        """"""Property controlling the resistance measurement mode: 4 wires or 2 wires"""""",
        validator=strict_discrete_set,
        values={'4': 1, '2': 0},
        map_values=True
    )

    #######################
    # Measurement Methods #
    #######################

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.
        :param nplc: Number of power line cycles (NPLC) from 0.001 to 25
        :param voltage: Upper limit of voltage in Volts, from -200 V to 200 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."" % self.channel)
        self.write('measure.v()')
        self.write('measure.nplc=%f' % nplc)
        if auto_range:
            self.write('measure.autorangev=1')
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.
        :param nplc: Number of power line cycles (NPLC) from 0.001 to 25
        :param current: Upper limit of current in Amps, from -1.5 A to 1.5 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."" % self.channel)
        self.write('measure.i()')
        self.write('measure.nplc=%f' % nplc)
        if auto_range:
            self.write('measure.autorangei=1')
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write('source.autorangei=1')
        else:
            self.write('source.autorangev=1')

    def apply_current(self, current_range=None, compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.
        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2600.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2600.current_range` value or None
        """"""
        log.info(""%s is sourcing current."" % self.channel)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.
        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2600.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2600.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."" % self.channel)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def ramp_to_voltage(self, target_voltage, steps=30, pause=0.1):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.
        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps """"""
        voltages = np.linspace(self.source_voltage, target_voltage, steps)
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def ramp_to_current(self, target_current, steps=30, pause=0.1):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.
        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps """"""
        currents = np.linspace(self.source_current, target_current, steps)
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down channel %s."" % self.channel)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.source_output = 'OFF'
"
362,https://download.flukecal.com/pub/literature/7341__Rebrand__ugeng0000.pdf,"https://us.flukecal.com/products/temperature-calibration/calibration-baths#:~:text=What%20is%20a%20temperature%20calibration,are%20different%20shapes%20and%20sizes.","[OrderedDict([('id', 'att8EUiD44cBzIsi1'), ('width', 970), ('height', 1459), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/z2hlonulODB9GOT7F9hQ0w/hfMkhlV3PuHwg-Jjb1RuuM-Vpflw_ST74vf5H183ptu4vaDLi3EH5hKDCs0vsn_Yf0vgfh93usdD3v4wfKQ6ZfycqabDis4figQMnl4UnEA/yQB9MYFc6XL39L-_1yEBjhks9lZVVCpSk274bXKSkhE'), ('filename', 'Fc-6331_04a_c.jpg'), ('size', 62022), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/go7VZr6GY_QewAlp5RH9Lg/Wodrgo_5SoW4Jz55lBiaHqwrxKzkjg8W_9ZL3QKAq6ahsot1nD7WSma-nmAVqVJHlfwALOldCWeNsvrt-VTKgQ/FPWYEC1JjcU1TUlEc5FeQ-tGZoMHRmzjdbUbRBqJPus'), ('width', 24), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/6Gsg0Vdx4c_jzeRqiIX5Sg/00tZXAaw2UcifgKIbAtTcJmBoq7uB58EGIr4Qelgns7_es50XRyWZFqciuiyePSxkPW76PHRghDTHlktuvPIBA/z7nnj5WwkPtFlEeLYTMyKpKYh9sBzecJGYY_05hjkOE'), ('width', 512), ('height', 770)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OrVR6xkmMMdTObNBMEHOXg/scBtFzpojuiKccYWcBtZcyMcscjEdw3DtAPUewAdsG_-E9XhGWw7tu-hObXXcLya7MnBf522NOCZ6eV6Taqo7w/c1jgzSz2Esf8HOgLOU6JjdV7uerXTzTOxMCltUS9tEA'), ('width', 3000), ('height', 3000)]))]))])]",700.0,US,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125987/Instruments/Vendor%20Logos/Fluke.png,"Deep-Well Compact Bath, –45 °C to 150 °C",https://eu.flukecal.com/fr/products/temperature-calibration/calibration-baths/compact-calibration-baths/bains-compacts-%C3%A0-puits-?quicktabs_product_details=3,Fluke 7341,129.0,['Temperature Controllers'],A temperature calibration bath is a calibrator having a uniform fluid enclosure that can be adjusted to specific temperatures for test points,"**Fluke** Corporation is the world leader in professional electronic test tools and software for measuring and condition monitoring.

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/fluke/fluke7341.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/fluke/fluke7341.html,Fluke,"[OrderedDict([('id', 'attC77II6inAac4Sm'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/xUTdT9qq86kPvDD59YbNqw/MDkTurDbAxEdCEPIhMGWvc6IRm82jWAwcUINLtk49XzFYiJ_kqumji9NWVeKjy4ZdrYj8gHojWnTbE0yDF4OxvStIyGlUp0DLh2gDtzkeRqAXGS2aONe3kH-Hc9l-eva/9CGJhkkvCfgGhGA7OOGhqDnm4ESgjb6im98UGTfn_y4'), ('filename', 'fluke-corporation-logo-vector.png'), ('size', 1735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/3-SY1YH_2m8uVUikar7a5g/sgCQBRXaElytmDBZCN3Z83cRULj75C2akNv0OBHCtTOFn2ss1Wa2YwIlvGzNKkqr9fTOMNXGLN9wfw-poKgf0w/OpSNZ1wLa42y52ZfBm5xH_hmol1ag01cDo8CEhv_AsE'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Z6IEClB3ALD3381OAwOqtQ/kwiSvI8er77XZ1T9HtkhalCfI5VoI5RaFI2-qBOWE8U2E6NS0Dx6Z9LXAr7sj2jdY-9k7E1NbeWOh5MWHg20dg/TNla6RqgiNS14l-l9X3k1FOT1rx6RwdnSMicDQtOr6k'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/s4W07j1gtsZhhwEyxd1Ujg/Np7HdqaocwFV50sEp1Vmr4mAAPdkqUW8I_iUCmC35lDifCjfZo6PTGq4poZjEvH3RAqy9xrhFDjW6rs4QGJmkg/bAs9Ghp81KETlzRiCFwBP1cuhxMkysUj3ZcSHhC_prY'), ('width', 3000), ('height', 3000)]))]))])]",https://us.flukecal.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782745/Instruments/Temperature%20Controllers/Fluke-7341/Fluke-7341.jpg,Fluke 7341,Write a Python script that uses Pymeasure to connect to a Fluke 7341 Temperature Controllers,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range


class Fluke7341(Instrument):
    """""" Represents the compact constant temperature bath from Fluke.
    """"""

    def __init__(self, adapter, name=""Fluke 7341"", **kwargs):
        kwargs.setdefault('timeout', 2000)
        kwargs.setdefault('write_termination', '\r\n')
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            asrl={'baud_rate': 2400},
            **kwargs
        )

    def read(self):
        """"""Read up to (excluding) `read_termination` or the whole read buffer.

        Extract the value from the response string.

        Responses are in the format ""`type`: `value` `optional information`"".
        Optional information is for example the unit (degree centigrade or Fahrenheit).
        """"""
        return super().read().split("":"")[-1]

    set_point = Instrument.control(""s"", ""s=%g"",
                                   """"""Control the temperature setpoint (float from -40 to 150 °C)
                                   The unit is as defined in property :attr:`~.unit`."""""",
                                   validator=strict_range,
                                   values=(-40, 150),
                                   preprocess_reply=lambda x: x.split()[0],
                                   )

    unit = Instrument.control(
        ""u"", ""u=%s"",
        """"""Control the temperature unit: `c` for Celsius and `f` for Fahrenheit`."""""",
        validator=strict_discrete_set,
        values=('c', 'f'),
    )

    temperature = Instrument.measurement(""t"",
                                         """"""Measure the current bath temperature.
                                         The unit is as defined in property :attr:`unit`."""""",
                                         preprocess_reply=lambda x: x.split()[0],
                                         )

    id = Instrument.measurement(""*ver"",
                                """"""Get the instrument model."""""",
                                cast=str,
                                get_process=lambda x: f""Fluke,{x[0][4:]},NA,{x[1]}"",
                                )
"
365,http://manuals.repeater-builder.com/te-files/MISCELLANEOUS/ANDEEN-HAGERLING%202500A%20Operation.pdf,https://electricalacademia.com/instrumentation-and-measurements/capacitance-bridge-circuit/,"[OrderedDict([('id', 'attf7SCnvVCz7J0a1'), ('width', 500), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ocs0AlQQaA7j-ann1ByiSQ/PMRKDjoWs0eZW8C4ZgthIRZZVX54M_SWa1RV0743yEvT9pTOw50vUhl8FdQFCKv281UnUZEh_pd3UghSzvKbp0UEn8Qu6GEAGNe2mcNkvy0/5Wsam9J0apQzMxS5fWi0hMk3MT4Y0usAwa2rczyZYmI'), ('filename', 'AH2550A-500x500w.jpg'), ('size', 25126), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZMAsNap4q9FpEFuAcvJbtw/kbG-h04fWDWM6HRpxAh3V386dChK6Yx9WvcG5igJe1ZgJ-isUC1wzsDnq0LAQu8Gjq7E7Hnoz31-61hgIXye4A/8IUboQTCrn6wPlxBJHMUAdUb3ZNmmLFYNNzWAAyEud0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/_NUHTAoTWT4ULr-p3iw_pg/rUuwS6q6vBW4JsVru0rxdTnVO4k6ciQBEU51UAs0kfZQpvBUoP-aPE_rvdMzK6w_RoM_jxenAsKNuM8lutn95w/uBFnGSE6RjIs648tHfn2PAxgBWaw68isCXPEp6pyawA'), ('width', 500), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TvaNPFjzzfvKkOC9Hx_BVQ/ulxTy8s9rlSe-YHJq0nnz3DERCxQiQ32LRMPmt6bW4bHpnYzoKG6m5OT_wRVeYQGuiDmlKgbnUsFnLSd9KwGvA/i_WW8Ym8vZHN8HXMCz5UJe6R2A-JY2tm-Oyg4RLNWOw'), ('width', 3000), ('height', 3000)]))]))])]",1.0,US,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126007/Instruments/Vendor%20Logos/Andeen_Hagerling.png,"The AH 2500A offers unparalleled stability, resolution and accuracy in a capacitance/loss1 bridge (whether manual or automatic)",http://www.andeen-hagerling.com/ah2500a.htm,AH 2500 A,76.0,['Multimeters'],A Maxwell Inductance Capacitance Bridge (known as a Maxwell Bridge) is a modified version of a Wheatstone bridge which is used to measure the self-inductance of a circuit.,"**Andeen**-**Hagerling**, Inc. - manufacturers of the world's most accurate capacitance bridges and standards

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/andeenhagerling/ah2500a.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/andeenhagerling/ah2500a.html,Andeen Hagerling,"[OrderedDict([('id', 'attHkizub4S6653G8'), ('width', 375), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/w8HZCN3hkRZWjBLsyALYDg/GP_H_v14QE8z5cObyjq9fmEhIDco53VmNgjz8Obr-HyaUBBy6n50oDw9yis-A3JSbW5roCz5iDYhaEvhKOrj-x-uHw6WYNOXAv0as0aN43c/_lgsrU1TYCsm4CWuBw-99ybrtCkGQEcKY6H_dBt5wjI'), ('filename', 'AH_Logo-375x200.jpg'), ('size', 5603), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vWse7hPPSXN_2x8l5Gt6eQ/fZ_h1mFQ_4UleUfN96I7Y4tUexQElcDij_5_0U8FKO7KQSg7wqQtQIwHrdKEaBHwQGpzPDTT4ft_D8UrSTdrqw/C9MJ5jqQ6ZAdxeDKn24TD8PoWVhY6stR30CoQlz16LQ'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A41FyOu0RdPrh3lfeudpKA/z4g7cthQ9gjK3wlZ33S-h6ErwF2mmiRZtytc65J4cnQ4qrGs3OAfIDF_y1qykcuvYabC8klFBF28uqtCyDw0lQ/uL27d_KFi9JBDDb2jPWhf6eWRgAOE9aPNQVg7CwHgMc'), ('width', 375), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/M4d5r7z2xdgpKrLvj2UPLQ/8aRPBzcumkhMFg4t0cz-w4JzfQ1M4a4fa3vs6tKN3Zg8cJ7AfV_bVoReWPH7ZAZBEhnqOXNHVMMhswKVDS__sA/w8NH3QBpTtbv5Il9kXNb5uwQLFS9Do3CTiZ7_n8re_o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.andeen-hagerling.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782748/Instruments/Multimeters/2500A-Bridge/2500A-Bridge.jpg,2500A Bridge,Write a Python script that uses Pymeasure to connect to a 2500A Bridge Multimeters,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import math
import re
import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range

log = logging.getLogger(__name__)


class AH2500A(Instrument):
    """""" Andeen Hagerling 2500A Precision Capacitance Bridge implementation
    """"""
    # regular expression to extract measurement values
    _reclv = re.compile(
        r""[FHZ0-9.=\s]*C=\s*(-?[0-9.]+)\s*PF L=\s*(-?[0-9.]+)\s*NS V=\s*(-?[0-9.]+)\s*V"")
    _renumeric = re.compile(r'[-+]?(\d*\.?\d+)')

    def __init__(self, adapter, name=None, timeout=3000,
                 write_termination=""\n"", read_termination=""\n"",
                 **kwargs):
        kwargs.setdefault(""includeSCPI"", False)
        super().__init__(
            adapter,
            name or ""Andeen Hagerling 2500A Precision Capacitance Bridge"",
            write_termination=write_termination,
            read_termination=read_termination,
            timeout=timeout,
            **kwargs
        )
        self._triggered = False

    config = Instrument.measurement(
        ""SHOW"",
        """""" Read out configuration """""",
    )

    caplossvolt = Instrument.measurement(
        ""Q"",
        """""" Perform a single capacitance, loss measurement and return the
        values in units of pF and nS. The used measurement voltage is returned
        as third value."""""",
        # lambda function is needed here since AH2500A is otherwise undefined
        get_process=lambda v: AH2500A._parse_reply(v),
    )

    vhighest = Instrument.control(
        ""SH V"", ""V %.4f"",
        """"""maximum RMS value of the used measurement voltage. Values of up to
        15 V are allowed. The device will select the best suiting range below
        the given value."""""",
        validator=strict_range,
        values=[0, 15],
        # typical replies: ""VOLTAGE    HIGHEST= 15.0    V"" or
        # ""VOLTAGE HIGHEST 1.00    V""
        get_process=lambda v: float(AH2500A._renumeric.search(v).group(0)),
    )

    @classmethod
    def _parse_reply(cls, string):
        """"""
        parse reply string from Andeen Hagerling capacitance bridges.

        :param string: reply string from the instrument. This commonly is:
          2500A:
            ""C= 1.234567    PF L= 0.000014    NS V= 0.750   V""
          2700A:
            ""F= 1000.00 HZ C= 4.20188     PF L=-0.0260      NS V= 15.0     V""
        :returns: tuple with C, L, V values
        """"""
        m = cls._reclv.match(string)
        if m is not None:
            values = tuple(map(float, m.groups()))
            return values
        # if an invalid string is returned ('EXCESS NOISE')
        if string.strip() == ""EXCESS NOISE"":
            log.warning(""Excess noise, check your experiment setup"")
            return (math.nan, math.nan, math.nan)
        else:  # some unknown return string (e.g. misconfigured units)
            raise Exception(f'Returned string ""{string}"" could not be parsed')

    def trigger(self):
        """"""
        Triggers a new measurement without blocking and waiting for the return
        value.
        """"""
        self.write(""TRG"")
        self._triggered = True

    def triggered_caplossvolt(self):
        """"""
        reads the measurement value after the device was triggered by the
        trigger function.
        """"""
        if not self._triggered:
            log.warning(
                ""Device not triggered, trigger manually for better timing"")
            self.trigger()
        self._triggered = False
        return AH2500A._parse_reply(self.read())
"
371,https://www.testequipmenthq.com/datasheets/Agilent-8657B-Datasheet.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attJm86J8SkTFF9aT'), ('width', 550), ('height', 191), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/-h0qRT4YTdUl0pUIC81wbA/vmGu05kBo1vk8Ia04-OPvYBWGsCQqsnVas6fRakUL-223Nt38Vrf0tuOUDddF99698cO9s4RNl_umGQx8OUHpA/uiHmNhsAg98D7TEVxWPbwYlmV45J9055vRuJKMJ0FTU'), ('filename', 'HP_.jpeg'), ('size', 97806), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Xa7H287sUb8AywhOfDoGpA/U1j6iHbZmyAJDLXsW_rksOWKDZmTnPV88-KOBM5kxkP0IeLNVXp0siDMWGgpjXensrVu-4uTDoWz94xt9i8U1g/lrk-GD_95Wz3bnp1_rw0k2uFTfBRVLR-nASxG6n7v_k'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/HRbbokmFniEe2rFBVqpy7g/-44wom_xpueb6MAubLIrTCSN7W1SJa9vrZwK8cC3l7ZzbgOoYbq7dgHn4mRy8Gz-hABbR_kTckM2xQF2vJBk5A/ARwidAk1_Ix6Su7bLxhVSm29XZ9tpAWmW9wu9W_1j1Q'), ('width', 550), ('height', 191)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/G2dUUYZDOwnZKGJlDnWF1g/xaHNDDvCExR5-kH--lUn2pgK2H5bFG9NlPmk8M3M_cKxSNpHTSOYgOV604Yr2Pbg7R50y2c7wBKU-geFfOgcDw/N2Vdng8pDOKlhs7SM-q2ZN4FQ_MJcg2PxFKd9l4kio8'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125999/Instruments/Vendor%20Logos/HP.png,"The Agilent Technologies 8657A and 8657B signal generators are designed to test AM, FM, and pulsed receivers as well as components.
",https://accusrc.com/product-HP-Agilent-8657B-9453,HP 8657 B,181.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp8657b.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp8657B.html,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/rUXD04crB-xLxsK4Xic7ng/AUJTafyX2GpCWk_A5bPsGE7XXMEEXklEV3G6mRavl3fTmL8-C_87vS3LFQakbq4sQKhSze8rXSq-To0XmrhvteOu_HvTYgOhNQZde6nXEgw/KLpt4JtCp1HBK7uc_1C1j04T9Vs4z81AnkvwWJT4gFU'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7_XI0TtOR9DuAmPJ3wjnHw/G6FnF46_lKs3w1sjcnIsOTOElyHR1TaBrTlF9GVMbCBZQc7-hYEU02CK9WAr-GZ87Qx0Lajdh5UvuspqN40lXAQIeXCSiO-JgNEL9HdrgUs/NIfzR1IuUBdrfMDEbvoMqMmuk4FlhZkQbxGVQYEcHvc'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/755-SO6TMZ4aWQi8zuxauA/DNe0EkL164QcvZ2Rl9xDZ-1RbL2HmMtXG8DesvPx-jSfxfSA121mj5GMR_OqUGRQ0s_sDYkdlC8Jjx_UMnKpESn-cLz6jEQBh-z3XCDhfvs/7DQuq3MRwxR-zGMFKoKIYS13pGyWp82sWm8QGzUxPGM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/nEenjCmF-uYeLU1ql38rSA/KPGDgWAVICnTQBF0_aBDBiFeUH9JbZmKAEP70ZLKAjwm3UflimLoLyTJhZknIeefc8Ho6I5Jk3TiaUlTFDfqNcXbcmTz8t-jSZ0P5znViFo/kc0AAkWhbI6n8BZ1KXELADQ5_VWaxFTYb8Jw0x203Vc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782753/Instruments/RF%20Signal%20Generator/Keysight-8657B/Keysight-8657B.jpg,Keysight 8657B,Write a Python script that uses Pymeasure to connect to a Keysight 8657B RF Signal Generator,900.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from enum import IntEnum
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class HP8657B(Instrument):
    """""" Represents the Hewlett Packard 8657B signal generator
    and provides a high-level interface for interacting
    with the instrument.
    """"""

    def __init__(self, adapter, name=""Hewlett-Packard HP8657B"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            send_end=True,
            **kwargs,
        )

    class Modulation(IntEnum):
        """"""
        IntEnum for the different modulation sources
        """"""
        EXTERNAL = 1
        INT_400HZ = 2
        INT_1000HZ = 3
        OFF = 4
        DC_FM = 5

    def check_errors(self):
        """"""
        Method to read the error status register
        as the 8657B does not support any readout of values, this will return 0 and log a warning

        """"""
        log.warning(""HP8657B Does not support error status readout"")

    def clear(self):
        """"""
        Reset the instrument to power-on default settings

        """"""
        self.adapter.connection.clear()

    id = ""HP,8657B,N/A,N/A""  #: Manual ID entry

    am_depth = Instrument.setting(
        ""AM %2.1f PC"",
        """"""
        Set the modulation depth for AM,
        usable range 0-99.9%
        """""",
        validator=strict_range,
        values=[0, 99.9],
        )

    am_source = Instrument.setting(
        ""AM S%i"",
        """"""
        Set the source for the AM function with :attr:`Modulation` enumeration.

        ==========  =======
        Value       Meaning
        ==========  =======
        OFF         no modulation active
        INT_400HZ   internal 400 Hz modulation source
        INT_1000HZ  internal 1000 Hz modulation source
        EXTERNAL    External source, AC coupling
        ==========  =======

        *Note:*
            * AM & FM can be active at the same time
            * only one internal source can be active at the time
            * use ""OFF"" to deactivate AM

        usage example:

        .. code-block:: python

            sig_gen = HP8657B(""GPIB::7"")
            ...
            sig_gen.am_source = sig_gen.Modulation.INT_400HZ    #  Enable int. 400 Hz source for AM
            sig_gen.am_depth = 50                               #  Set AM modulation depth to 50%
            ...
            sig_gen.am_source = sig_gen.Modulation.OFF          #  Turn AM off

        """""",
        validator=strict_discrete_set,
        values=Modulation,
        )

    fm_deviation = Instrument.setting(
        ""FM %3.1fKZ"",
        """"""
        Set the peak deviation in kHz for the FM function,
        useable range 0.1 - 400 kHz

        *NOTE*:
            the maximum usable deviation is depending on the output frequency, refer to the
            instrument documentation for further detail.

        """""",
        validator=strict_range,
        values=[0.1, 400],
        )

    fm_source = Instrument.setting(
        ""FM S%i"",
        """"""
        Set the source for the FM function with :attr:`Modulation` enumeration.

        ==========  =======
        Value       Meaning
        ==========  =======
        OFF         no modulation active
        INT_400HZ   internal 400 Hz modulation source
        INT_1000HZ  internal 1000 Hz modulation source
        EXTERNAL    External source, AC coupling
        DC_FM       External source, DC coupling (FM only)
        ==========  =======

        *Note:*
            * AM & FM can be active at the same time
            * only one internal source can be active at the time
            * use ""OFF"" to deactivate FM
            * refer to the documentation rearding details on use of DC FM mode

        usage example:

        .. code-block:: python

            sig_gen = HP8657B(""GPIB::7"")
            ...
            sig_gen.fm_source = sig_gen.Modulation.EXTERNAL     #  Enable external source for FM
            sig_gen.fm_deviation = 15                           #  Set FM peak deviation to 15 kHz
            ...
            sig_gen.fm_source = sig_gen.Modulation.OFF          #  Turn FM off

        """""",
        validator=strict_discrete_set,
        values=Modulation,
        )

    frequency = Instrument.setting(
        ""FR %10.0f HZ"",
        """"""
        Set the output frequency of the instrument in Hz.

        For the 8567B the valid range is 100 kHz to 2060 MHz.
        """""",
        validator=strict_range,
        values=[1.0E5, 2.060E9],
        )

    level = Instrument.setting(
        ""AP %g DM"",
        """"""
        Set the output level in dBm.

        For the 8657B the range is -143.5 to +17 dBm/

        """""",
        validator=strict_range,
        values=[-143.5, 17.0],
        )

    level_offset = Instrument.setting(
        ""AO %g DB"",
        """"""
        Set the output offset in dB, usable range -199 to +199 dB.

        """""",
        validator=strict_range,
        values=[-199.0, 199.0],
        )

    output_enabled = Instrument.setting(
        ""R%d"",
        """"""
        Control whether the output is enabled.
        """""",
        validator=strict_discrete_set,
        values={False: 2, True: 3},
        map_values=True
       )

    def reset(self):
        self.adapter.connection.clear()

    def shutdown(self):
        self.adapter.connection.clear()
        self.output_enabled = False
        self.adapter.connection.close()
        super().shutdown()
"
375,https://www.testequipmenthq.com/datasheets/KEITHLEY-2000-Datasheet.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attDkhYLQ6zcJU0mz'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/QQo7gyBiythlQsKVdcvZpg/Z9JzJ6DM0d2T3o4Ou1RR9YcpBroxFWjArmAGWW9neIqw_WkLfznV3TX23Hzpi9PTsbUw0T7xW0R23LSJY56x1ab6w8d1K1Ab-Wy_b-9br3s/u5_N4jw4oKvr-GJm9-f-DtgYJ117cqZ4A-XF7NR8klU'), ('filename', '2000.webp'), ('size', 6118), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/cdx00SUDAM9TqswYEyBCtg/BNCSTV8F9pBteW2vP8aczbEl1ZNOWqvzLnDjfNVAjrsgZok2miax-Y2-h7sgvAuXfbVZDUACdwT07m91lqXMrSzYBD8UJLSkjh6WL-2ACDU/EJ02XbQ5-63AqWZZdacpyl1vlplk6fzCU9Q5IETHORI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/A9kRN-qeZZGIzSEeyfAaiQ/i747y8PNiE_1OHlTbs2Oe1m3v-GTaLSD2OO6_N5cuapw3NfAn26H0va2zNstTnoXguDQwlkaPODnQVIwhux_J99Sd-iI1VED2iukKMwG8vk/iSxPkvPPO-KJrwyfnjUdb5ml38WQfAfvQHGrivEB1-c'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/uga6xR0JBpoJsihGeDDXmw/k-e_roiw5cqfQMm5NPPSTG5C7PfuegpkS50uCvDKoGkwT5Fp8blwtX8m46KhiIH9kb9MG4m9_HPtq-PiwiOae2oNEilOKGsVioCTHxjwQvE/w5Vxv4JrSYyzSUvSSBxz_YVj3ECH8N8d_Xjafk-40ns'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126010/Instruments/Vendor%20Logos/Keithley.png,"The Model 2000 6_-Digit Multimeter is part of Keithleys family of high performance DMMs. Based on the same high speed, low noise A/D converter technology as the Model 2001 and 2002, the 2000 is a fast, accurate, and highly stable instrument thats as easy to operate as it is to afford. It combines broad measurement ranges with superior accuracy specifications DC voltage from 100nV to 1kV (with 0.002% 90-day basic accuracy) and DC resistance from 100 to 100M (with 0.008% 90-day basic accuracy). Optional switch cards enable multiplexing up to 20 different input signals for multipoint measurement applications.",https://www.allaboutcircuits.com/test-measurement/multimeters/keithley-2000/,Keithley 2000,219.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2000.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2000.html,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Ky-3WHe7qjzZ_c0aT3BcIQ/JEXoJMkAETD22B3DpFERu1bAQxVFTUZzXATrZmHQ54mhU2MOyIWEP3WSF1SYqL7pYH_k6TdLlQyZ8ki6zc-jhPluLADeyQGmhgBmeYh1Tl-18VmBs0RJLxBcF1XQt90xU8qLDfMLuH-_IuaEp93paQ/a6YdLZoH3iRbtIOX_f3ix5-1w7eFdPanZR5YjSvCyUw'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/isoD1gtJxr2-6gtpZSOkTA/Af1WD4Ub_fpIO61Se3rnT8NZjLeY53Bb9eG6yT0l311tv_LoF4uleWoF1iGwupZ-m-TlUOwLFNF7HL_8IReTPw/3XkdC2VcSYy9N5N0KBi4UgGMX8b7KHxHhs_y7NJ9Gws'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Kw_FjiKBtF6rpJzsaxPVng/_2-fZn4Ydts6FKNZl1bmodW6D39MDE37Po1nlJkCLPmHJyFYV6TCvYhf_J6X2jDlh7_rsANqLgHoux1BxkdYuQ/9qUDuJVKRFkhetD3sfRGwFjAdBDnNtnMN4oJrIgKDug'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/FzAAAu8kmtDV1wzfR2F0xg/IZC0-3fGJmSk2fwdEWchKlhgqFEGaQb1b_tJnLbAvC-oAopxkJrH5A43eTmjzrdZIulQqr7AwqSsSZkDk-PkdQ/u1Y3jSJWOPNbYpc4-gLTGA-iyB-o0hjhggDQ48Fy8Fc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782454/Instruments/Multimeters/Keithley-2000/Keithley-2000.webp,Keithley 2000,Write a Python script that uses Pymeasure to connect to a Keithley 2000 Multimeters,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    truncated_range, truncated_discrete_set,
    strict_discrete_set
)
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2000(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2000 Multimeter and provides a high-level
    interface for interacting with the instrument.

    .. code-block:: python

        meter = Keithley2000(""GPIB::1"")
        meter.measure_voltage()
        print(meter.voltage)

    """"""
    MODES = {
        'current': 'CURR:DC', 'current ac': 'CURR:AC',
        'voltage': 'VOLT:DC', 'voltage ac': 'VOLT:AC',
        'resistance': 'RES', 'resistance 4W': 'FRES',
        'period': 'PER', 'frequency': 'FREQ',
        'temperature': 'TEMP', 'diode': 'DIOD',
        'continuity': 'CONT'
    }

    mode = Instrument.control(
        "":CONF?"", "":CONF:%s"",
        """""" A string property that controls the configuration mode for measurements,
        which can take the values: ``current`` (DC), ``current ac``,
        ``voltage`` (DC),  ``voltage ac``, ``resistance`` (2-wire),
        ``resistance 4W`` (4-wire), ``period``,
        ``temperature``, ``diode``, and ``frequency``."""""",
        validator=strict_discrete_set,
        values=MODES,
        map_values=True,
        get_process=lambda v: v.replace('""', '')
    )

    beep_state = Instrument.control(
        "":SYST:BEEP:STAT?"",
        "":SYST:BEEP:STAT %g"",
        """""" A string property that enables or disables the system status beeper,
        which can take the values: ``enabled`` and ``disabled``. """""",
        validator=strict_discrete_set,
        values={'enabled': 1, 'disabled': 0},
        map_values=True
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC current measurement in Amps, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the DC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_reference = Instrument.control(
        "":SENS:CURR:REF?"", "":SENS:CURR:REF %g"",
        """""" A floating point property that controls the DC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_digits = Instrument.control(
        "":SENS:CURR:DIG?"", "":SENS:CURR:DIG %d"",
        """""" An integer property that controls the number of digits in the DC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int,
    )
    current_ac_range = Instrument.control(
        "":SENS:CURR:AC:RANG?"", "":SENS:CURR:AC:RANG:AUTO 0;:SENS:CURR:AC:RANG %g"",
        """""" A floating point property that controls the AC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_ac_reference = Instrument.control(
        "":SENS:CURR:AC:REF?"", "":SENS:CURR:AC:REF %g"",
        """""" A floating point property that controls the AC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_ac_nplc = Instrument.control(
        "":SENS:CURR:AC:NPLC?"", "":SENS:CURR:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_ac_digits = Instrument.control(
        "":SENS:CURR:AC:DIG?"", "":SENS:CURR:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    current_ac_bandwidth = Instrument.control(
        "":SENS:CURR:AC:DET:BAND?"", "":SENS:CURR:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC current detector
        bandwidth in Hz, which can take the values 3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC voltage measurement in Volts, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the DC voltage range in
        Volts, which can take values from 0 to 1010 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    voltage_reference = Instrument.control(
        "":SENS:VOLT:REF?"", "":SENS:VOLT:REF %g"",
        """""" A floating point property that controls the DC voltage reference
        value in Volts, which can take values from -1010 to 1010 V. """""",
        validator=truncated_range,
        values=[-1010, 1010]
    )
    voltage_nplc = Instrument.control(
        "":SENS:CURRVOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_digits = Instrument.control(
        "":SENS:VOLT:DIG?"", "":SENS:VOLT:DIG %d"",
        """""" An integer property that controls the number of digits in the DC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_range = Instrument.control(
        "":SENS:VOLT:AC:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:AC:RANG %g"",
        """""" A floating point property that controls the AC voltage range in
        Volts, which can take values from 0 to 757.5 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 757.5]
    )
    voltage_ac_reference = Instrument.control(
        "":SENS:VOLT:AC:REF?"", "":SENS:VOLT:AC:REF %g"",
        """""" A floating point property that controls the AC voltage reference
        value in Volts, which can take values from -757.5 to 757.5 Volts. """""",
        validator=truncated_range,
        values=[-757.5, 757.5]
    )
    voltage_ac_nplc = Instrument.control(
        "":SENS:VOLT:AC:NPLC?"", "":SENS:VOLT:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_ac_digits = Instrument.control(
        "":SENS:VOLT:AC:DIG?"", "":SENS:VOLT:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_bandwidth = Instrument.control(
        "":SENS:VOLT:AC:DET:BAND?"", "":SENS:VOLT:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC voltage detector
        bandwidth in Hz, which can take the values  3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads a resistance measurement in Ohms for both 2-wire and 4-wire
        configurations, based on the active :attr:`~.Keithley2000.mode`. """"""
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the 2-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_reference = Instrument.control(
        "":SENS:RES:REF?"", "":SENS:RES:REF %g"",
        """""" A floating point property that controls the 2-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_digits = Instrument.control(
        "":SENS:RES:DIG?"", "":SENS:RES:DIG %d"",
        """""" An integer property that controls the number of digits in the 2-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    resistance_4W_range = Instrument.control(
        "":SENS:FRES:RANG?"", "":SENS:FRES:RANG:AUTO 0;:SENS:FRES:RANG %g"",
        """""" A floating point property that controls the 4-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_reference = Instrument.control(
        "":SENS:FRES:REF?"", "":SENS:FRES:REF %g"",
        """""" A floating point property that controls the 4-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_nplc = Instrument.control(
        "":SENS:FRES:NPLC?"", "":SENS:FRES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 4-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_4W_digits = Instrument.control(
        "":SENS:FRES:DIG?"", "":SENS:FRES:DIG %d"",
        """""" An integer property that controls the number of digits in the 4-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ##################
    # Frequency (Hz) #
    ##################

    frequency = Instrument.measurement(
        "":READ?"",
        """""" Reads a frequency measurement in Hz, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    frequency_reference = Instrument.control(
        "":SENS:FREQ:REF?"", "":SENS:FREQ:REF %g"",
        """""" A floating point property that controls the frequency reference
        value in Hz, which can take values from 0 to 15 MHz. """""",
        validator=truncated_range,
        values=[0, 15e6]
    )
    frequency_digits = Instrument.control(
        "":SENS:FREQ:DIG?"", "":SENS:FREQ:DIG %d"",
        """""" An integer property that controls the number of digits in the frequency
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    frequency_threshold = Instrument.control(
        "":SENS:FREQ:THR:VOLT:RANG?"", "":SENS:FREQ:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the frequency measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    frequency_aperature = Instrument.control(
        "":SENS:FREQ:APER?"", "":SENS:FREQ:APER %g"",
        """""" A floating point property that controls the frequency aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ##############
    # Period (s) #
    ##############

    period = Instrument.measurement(
        "":READ?"",
        """""" Reads a period measurement in seconds, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    period_reference = Instrument.control(
        "":SENS:PER:REF?"", "":SENS:PER:REF %g"",
        """""" A floating point property that controls the period reference value
        in seconds, which can take values from 0 to 1 s. """""",
        validator=truncated_range,
        values=[0, 1]
    )
    period_digits = Instrument.control(
        "":SENS:PER:DIG?"", "":SENS:PER:DIG %d"",
        """""" An integer property that controls the number of digits in the period
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    period_threshold = Instrument.control(
        "":SENS:PER:THR:VOLT:RANG?"", "":SENS:PRE:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the period measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    period_aperature = Instrument.control(
        "":SENS:PER:APER?"", "":SENS:PER:APER %g"",
        """""" A floating point property that controls the period aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ###################
    # Temperature (C) #
    ###################

    temperature = Instrument.measurement(
        "":READ?"",
        """""" Reads a temperature measurement in Celsius, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    temperature_reference = Instrument.control(
        "":SENS:TEMP:REF?"", "":SENS:TEMP:REF %g"",
        """""" A floating point property that controls the temperature reference value
        in Celsius, which can take values from -200 to 1372 C. """""",
        validator=truncated_range,
        values=[-200, 1372]
    )
    temperature_nplc = Instrument.control(
        "":SENS:TEMP:NPLC?"", "":SENS:TEMP:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the temperature measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    temperature_digits = Instrument.control(
        "":SENS:TEMP:DIG?"", "":SENS:TEMP:DIG %d"",
        """""" An integer property that controls the number of digits in the temperature
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ###########
    # Trigger #
    ###########

    trigger_count = Instrument.control(
        "":TRIG:COUN?"", "":TRIG:COUN %d"",
        """""" An integer property that controls the trigger count,
        which can take values from 1 to 9,999. """""",
        validator=truncated_range,
        values=[1, 9999],
        cast=int
    )
    trigger_delay = Instrument.control(
        "":TRIG:SEQ:DEL?"", "":TRIG:SEQ:DEL %g"",
        """""" A floating point property that controls the trigger delay
        in seconds, which can take values from 1 to 9,999,999.999 s. """""",
        validator=truncated_range,
        values=[0, 999999.999]
    )

    def __init__(self, adapter, name=""Keithley 2000 Multimeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def measure_voltage(self, max_voltage=1, ac=False):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if ac:
            self.mode = 'voltage ac'
            self.voltage_ac_range = max_voltage
        else:
            self.mode = 'voltage'
            self.voltage_range = max_voltage

    def measure_current(self, max_current=10e-3, ac=False):
        """""" Configures the instrument to measure current,
        based on a maximum current to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_current: A current in Volts to set the current range
        :param ac: False for DC current, and True for AC current
        """"""
        if ac:
            self.mode = 'current ac'
            self.current_ac_range = max_current
        else:
            self.mode = 'current'
            self.current_range = max_current

    def measure_resistance(self, max_resistance=10e6, wires=2):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if wires == 2:
            self.mode = 'resistance'
            self.resistance_range = max_resistance
        elif wires == 4:
            self.mode = 'resistance 4W'
            self.resistance_4W_range = max_resistance
        else:
            raise ValueError(""Keithley 2000 only supports 2 or 4 wire""
                             ""resistance meaurements."")

    def measure_period(self):
        """""" Configures the instrument to measure the period. """"""
        self.mode = 'period'

    def measure_frequency(self):
        """""" Configures the instrument to measure the frequency. """"""
        self.mode = 'frequency'

    def measure_temperature(self):
        """""" Configures the instrument to measure the temperature. """"""
        self.mode = 'temperature'

    def measure_diode(self):
        """""" Configures the instrument to perform diode testing.  """"""
        self.mode = 'diode'

    def measure_continuity(self):
        """""" Configures the instrument to perform continuity testing. """"""
        self.mode = 'continuity'

    def _mode_command(self, mode=None):
        if mode is None:
            mode = self.mode
        return self.MODES[mode]

    def auto_range(self, mode=None):
        """""" Sets the active mode to use auto-range,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:RANG:AUTO 1"" % self._mode_command(mode))

    def enable_reference(self, mode=None):
        """""" Enables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 1"" % self._mode_command(mode))

    def disable_reference(self, mode=None):
        """""" Disables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 0"" % self._mode_command(mode))

    def acquire_reference(self, mode=None):
        """""" Sets the active value as the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:ACQ"" % self._mode_command(mode))

    def enable_filter(self, mode=None, type='repeat', count=1):
        """""" Enables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        :param type: The type of averaging filter, either 'repeat' or 'moving'.
        :param count: A number of averages, which can take take values from 1 to 100
        """"""
        self.write("":SENS:%s:AVER:STAT 1"")
        self.write("":SENS:%s:AVER:TCON %s"")
        self.write("":SENS:%s:AVER:COUN %d"")

    def disable_filter(self, mode=None):
        """""" Disables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:AVER:STAT 0"" % self._mode_command(mode))

    def local(self):
        """""" Returns control to the instrument panel, and enables
        the panel if disabled. """"""
        self.write("":SYST:LOC"")

    def remote(self):
        """""" Places the instrument in the remote state, which is
        does not need to be explicity called in general. """"""
        self.write("":SYST:REM"")

    def remote_lock(self):
        """""" Disables and locks the front panel controls to prevent
        changes during remote operations. This is disabled by
        calling :meth:`~.Keithley2000.local`.  """"""
        self.write("":SYST:RWL"")

    def reset(self):
        """""" Resets the instrument state. """"""
        self.write("":STAT:QUEUE:CLEAR;*RST;:STAT:PRES;:*CLS;"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")
"
381,https://www.electrokit.com/uploads/productfile/41016/SPD1168X_DataSheet_DS0501X-E01A.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attbpVCbnAzAHgkQv'), ('width', 799), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/Yy2WUxK-ZhkxIxM2yhQemQ/dUY_dJYza__5iFZTo1DtjC-xkciBFd_YCR_9C0NZCBL20zhwFM9_PGi6d4sWgsQKRY-ulnCZhKGX8AKqP-_fZQzc64hDr9IuE208Bxt9FmLUYNElwdQSu8PjTYhPGkzl/5K_l4lu52qQR1ujxS2hMcdtciJBR7nkX2AZUL_1MxAA'), ('filename', '81Ls3Y2LgBL._AC_UF894,1000_QL80_.jpg'), ('size', 85769), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wHK_APu9j6mY443imAmATQ/QZP1TfxVEM1DMFTyv62T9pbU0rXTv8sO3Ov1lzhowqZ7J4xAIQzuNbAbowVpL3FyS4JzPLIMSTj2DNwfWa3jMQ/Tu2F0QfI6yEWjJpbBtfYA6ETWOz71luxcDX1tmoQ73M'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/mw4Y2Yym8TQvGCfr_nK21w/OydYVJHgFQU9GF1yBR_REQeeddCIpX004krZZTjvk5rEIX1BycfLX66OujjueiiBb2HPQSe0XQWOJplkdWnP2w/hKgtbQKJ1f6W6e0nYUm36ODVpMOj8f3RslNSJ1giOrM'), ('width', 512), ('height', 641)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/8glncNkKC5SXqBSaxPoUTA/iGveeysg4iV-1PXikNevJSqXK-2WOA5hba4u4QRUCc02rx9ML6jneDdzg-FPi9q3krJlcaRKqOPPChryOa23Eg/Ruy4WUuKvXL2rzfDKS12oFFv38iMByPXqs1Sb-G3NP0'), ('width', 3000), ('height', 3000)]))]))])]",57.0,"Shenzhen, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126014/Instruments/Vendor%20Logos/Siglent.png,"Siglent’s SPD1168X Series Programmable Linear DC Power Supply has a 2.8 inch TFT-LCD (240 * 320) color display. The SPD1168X outputs up to 128 Watts of power and has a Voltage range of 0-16 V and Current range of 0-8 A. The Voltage resolution is 1 uV while the Current resolution is 1 mA.

Because higher currents supplied through smaller gauge wire or longer distances can cause a drop in voltage to the supplied load, the SPD1168X incorporates Remote Sensing in order to measure the actual supplied voltage at the load. The remote sensed voltage is fed back to the power supply and output voltage is adjusted almost instantaneously.",https://siglentna.com/product/spd1168x/,Siglent SPD 1168 X,504.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","**iglent** is a China-based manufacturer specializing in electronic test & measurement instruments. Siglent founders began a preliminary study of digital oscilloscopes in 2002. It founded in 2007, and now Siglent has extended its product line to include digital oscilloscopes, function / arbitrary waveform generators, RF generators，digital multi-meters, DC power supplies, spectrum analyzers, spectrum & vector network analyzers, isolated handheld oscilloscopes, DC electronic loads and other general test instruments.Siglent also manufactured entry-level products for Lecroy.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/siglenttechnologies/siglent_spd1168x.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/siglenttechnologies/siglent_spd1168x.html,Siglent Technologies,"[OrderedDict([('id', 'attzuZfmx06hyyd2m'), ('width', 500), ('height', 304), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ovri_IqzfyTkltYKQf-5cw/fUefYEBFp44ZfgvrRFbEsxg5b-EgoBSh0S9X5t1baT-f36g1gHacA5dSoDLOIy6ilS0xVjJjgxBYIlnBTKEYT6T2iFx4crpsFTWfAqCO--Q/KoaoL7zZoZlZ-BUGWPgsp-uU4810G8foAaN5wg_4rsw'), ('filename', 'New-Siglent-Logo.png'), ('size', 3479), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/EUOwxjHRDkR2ZXIsLitEVQ/V6LI0p2NivPfKsOes95120SaGjrVG7DUVaBiWK0RVsCnrg8xFAyQry2WQYK6oZ1ZG-nTDtxkKt0ptfqLzR_N2Q/TaM6PpOpi12pqlBZme25jC9OsK3H5lpNjIcZ9h-ZIbM'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/7KUO2e0Bf6BrEl-H8av2Bw/vq__ajdEO0-pZ31cDiWXwYheijYwaAIRWTuNd39my6YGmsf31Cm0HjSbpeNcPAMNSomCYizTN8S4yfdiOrJaaA/GoDmhKCSdF5IJhNtcrXVmIcPe2R0yB3GxU5-ZZ0kInQ'), ('width', 500), ('height', 304)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/ZRQAVhXToHyxANCi45K_Jg/MfK_GwT0G27Gs5SYTaHMhjcKiN3_KT7k8NYjh1HaTDQUs779ziDIOjTK_iJqlmGDVJTYD0blNEQy6fznjzIztA/bkudePH6v2RxzvbXjRUx7WXWdNWWbxXAy6PMdOiFHaI'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782760/Instruments/Power%20Supplies/SPD1168X-Power-Supply/SPD1168X-Power-Supply.jpg,SPD1168X Power Supply,Write a Python script that uses Pymeasure to connect to a SPD1168X Power Supply Power Supplies,265.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.siglenttechnologies.siglent_spdbase import (SPDSingleChannelBase,
                                                                       SPDChannel)


class SPD1168X(SPDSingleChannelBase):
    """"""Represent the Siglent SPD1168X Power Supply.
    """"""

    ch_1 = Instrument.ChannelCreator(SPDChannel, 1)

    def __init__(self, adapter, name=""Siglent Technologies SPD1168X Power Supply"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
392,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/39370/IPS120-10.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attmQ7Nb3HgLUBAiu'), ('width', 700), ('height', 700), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/v7SRR1pQ_fmSQ-9g64qp_g/FK_zMWFe5s52TAa_mr1x_QXItd18TH39NWsFx98Wvkq0YvgpjlnhuRLnvcKr1aHs8ZuuH28r8ypx15f9nWTEYtowtubDWXJ4RO_mC8qESJs/bYkJ0na9KMRyRGERmPJuyrcepH67v4CUo6uNrxsylbA'), ('filename', 'Mercury_IPS_E1-120.jpg'), ('size', 22336), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/qB1FULeNFG68iKrjsGnR3w/FmkTxUf22svJav_kCZKdURPOBsusEfLuwsqHGVxFJVDIjSd2xA9SmoQIcktzXXjXWXKlCjg9JtBHmku2oORn0Q/yVOVWSolII5NHOqsUblXU6EROzdp27Eb_I9cB-LlgLA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/AoC-Bo75yT2jt9GEy_rejw/9e6xPuascF0oGev_Oq-9XgUe3vFG7pe6uO74DERaZIAL0-4VkIOJXfFhiV_Wv5kKsWi1O0nfjHs0be3USxS66w/e9OKJzmfrIkK_Sqqwh_6GjzmP1VCyVDt7fXKksIz7aE'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OaktDUVLFRMHINII4Ilodg/urLVkLsWsBhfpbhJM_aGbDKOptiUYnvD7mOs47daohLMk7S8V7JucbREhoKvozZN8DIXCzlc_ZDYqJ8chR4fFA/j18RzvxdIi0ORHYQ8u8VQEkfopzp1A_nc026olTWsAI'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692125988/Instruments/Vendor%20Logos/Oxford_Instruments.png,MERC-IPS-120 MercuryIPS 120 A 10 V superconducting magnet power supply. The Mercury iPS is configurable and is made up of two units: The Mercury main unit E1-060 and Mercury secondary slave unit E1-061.,https://estore.oxinst.com/eu/products/system-spares/magnet-systems/mercury-electronics-and-cables/zidE1-120,IPS 120  10,406.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/oxfordinstruments/ips120_10.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/oxfordinstruments/IPS120_10.html,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/TmODz0hi9OJUWi8T_d03Sg/Z2IpZm1otBFaV4dd1Z-YtqnyJyVrn1XmjrAJ-f5S_iVw7bPjL7yB9-iP7oED2Apt8U7BWIgETKyocFr_7AB4ANlqGjCMDVi0jOaDoDmBEeY/fb6Rw-KSmBuKxPZBvzrwQHM2Od5u72NtOxyRcoYmp1k'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/wLs8zjCAwM09gWDMI3xu8Q/oeHC2OPJ20vnWtvfKmZUu5tq6Qs8soCa05gu5GwUon7E_fXVQPnVlYkLXr8b89l5PSrYNLwdT0-CaM0qfQxfkQ/-ax23cOalgUh6YtKYQnXV1PHde7iBMdvwmUkMoLyC4g'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/jgZc4LIcvZHeQFduBTSAqA/Ekyj1R3Uue0-wDCxuF4HJMJgjIi6LufK6pQen9vYQvrGtTJ02DFBb9vf_SftJYHGiiKwYcBl1y0ZxBQRsYc_9g/zsDCrHyIVVMco4QM3Ug2jLafjuWb_kNyFMD1jMv7l3E'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/PhngqIRF78CMgJpGxBi3aA/Q4c_1vbgbHc9v_mECxRUCccMTG-Ca72dEMwKqczOB_oBg3yhQVaWSPj9-Cyp88i9XS_-NvyHrb6FmV0sZXsnhg/yJDJjhkTUYCH-6uR2EfIACKa09g3qImdFcMG16-hnng'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782768/Instruments/Power%20Supplies/IPS-120-10/IPS-120-10.jpg,IPS 120  10,Write a Python script that uses Pymeasure to connect to a IPS 120  10 Power Supplies,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging
from time import sleep, time

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set
from pymeasure.instruments.validators import truncated_range

from .base import OxfordInstrumentsBase

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class MagnetError(ValueError):
    """""" Exception that is raised for issues regarding the state of the magnet or power supply. """"""
    pass


class SwitchHeaterError(ValueError):
    """""" Exception that is raised for issues regarding the state of the superconducting switch. """"""
    pass


class IPS120_10(OxfordInstrumentsBase):
    """"""Represents the Oxford Superconducting Magnet Power Supply IPS 120-10.

    .. code-block:: python

        ips = IPS120_10(""GPIB::25"")  # Default channel for the IPS

        ips.enable_control()         # Enables the power supply and remote control

        ips.train_magnet([           # Train the magnet after it has been cooled-down
            (11.8, 1.0),
            (13.9, 0.4),
            (14.9, 0.2),
            (16.0, 0.1),
        ])

        ips.set_field(12)           # Bring the magnet to 12 T. The switch heater will
                                    # be turned off when the field is reached and the
                                    # current is ramped back to 0 (i.e. persistent mode).

        print(self.field)           # Print the current field (whether in persistent or
                                    # non-persistent mode)

        ips.set_field(0)            # Bring the magnet to 0 T. The persistent mode will be
                                    # turned off first (i.e. current back to set-point and
                                    # switch-heater on); afterwards the switch-heater will
                                    # again be turned off.

        ips.disable_control()       # Disables the control of the supply, turns off the
                                    # switch-heater and clamps the output.

    :param clear_buffer: A boolean property that controls whether the instrument
        buffer is clear upon initialisation.
    :param switch_heater_heating_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned on before the heater is expected to be heated.
    :param switch_heater_cooling_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned off before the heater is expected to be cooled down.
    :param field_range: A numeric value or a tuple of two values to indicate the
        lowest and highest allowed magnetic fields. If a numeric value is provided
        the range is expected to be from :code:`-field_range` to :code:`+field_range`.
        The default range is -7 to +7 Tesla.

    """"""

    _SWITCH_HEATER_HEATING_DELAY = 20  # Seconds
    _SWITCH_HEATER_COOLING_DELAY = 20  # Seconds

    _SWITCH_HEATER_SET_VALUES = {
        False: 0,  # Heater off
        True: 1,  # Heater on, with safety checks
        ""Force"": 2,  # Heater on, without safety checks
    }
    _SWITCH_HEATER_GET_VALUES = {
        0: False,  # Heater off, Switch closed, Magnet at zero
        1: True,  # Heater on, Switch open
        2: False,  # Heater off, Switch closed, Magnet at field
        5: ""Heater fault, low heater current"",  # Heater on but current is low
        8: ""No switch fitted"",  # No switch fitted
    }

    def __init__(self,
                 adapter,
                 name=""Oxford IPS"",
                 clear_buffer=True,
                 switch_heater_heating_delay=None,
                 switch_heater_cooling_delay=None,
                 field_range=None,
                 **kwargs):

        super().__init__(
            adapter=adapter,
            name=name,
            **kwargs
        )

        if switch_heater_heating_delay is not None:
            self._SWITCH_HEATER_HEATING_DELAY = switch_heater_heating_delay
        if switch_heater_cooling_delay is not None:
            self._SWITCH_HEATER_COOLING_DELAY = switch_heater_cooling_delay

        if field_range is not None:
            if isinstance(field_range, (float, int)):
                self.field_setpoint_values = [-field_range, +field_range]
            elif isinstance(field_range, (list, tuple)):
                self.field_setpoint_values = field_range

        # Clear the buffer in order to prevent communication problems
        if clear_buffer:
            self.adapter.connection.clear()

    version = Instrument.measurement(
        ""V"",
        """""" A string property that returns the version of the IPS. """""",
    )

    control_mode = Instrument.control(
        ""X"", ""C%d"",
        """""" A string property that sets the IPS in `local` or `remote` and `locked`
        or `unlocked`, locking the LOC/REM button. Allowed values are:

        =====   =================
        value   state
        =====   =================
        LL      local & locked
        RL      remote & locked
        LU      local & unlocked
        RU      remote & unlocked
        =====   =================
        """""",
        preprocess_reply=lambda v: v[6],
        cast=int,
        validator=strict_discrete_set,
        values={""LL"": 0, ""RL"": 1, ""LU"": 2, ""RU"": 3},
        map_values=True,
    )

    current_measured = Instrument.measurement(
        ""R1"",
        """""" A floating point property that returns the measured magnet current of
        the IPS in amps. """""",
        dynamic=True,
    )

    demand_current = Instrument.measurement(
        ""R0"",
        """""" A floating point property that returns the demand magnet current of
        the IPS in amps. """""",
        dynamic=True,
    )

    demand_field = Instrument.measurement(
        ""R7"",
        """""" A floating point property that returns the demand magnetic field of
        the IPS in Tesla. """""",
        dynamic=True,
    )

    persistent_field = Instrument.measurement(
        ""R18"",
        """""" A floating point property that returns the persistent magnetic field of
        the IPS in Tesla. """""",
        dynamic=True,
    )

    switch_heater_status = Instrument.control(
        ""X"", ""H%d"",
        """""" An integer property that returns the switch heater status of
        the IPS. Use the :py:attr:`~switch_heater_enabled` property for controlling
        and reading the switch heater. When using this property, the user
        is referred to the IPS120-10 manual for the meaning of the integer
        values. """""",
        preprocess_reply=lambda v: v[8],
        cast=int,
    )

    @property
    def switch_heater_enabled(self):
        """""" A boolean property that controls whether the switch heater
        is enabled or not. When the switch heater is enabled (:code:`True`), the
        switch is closed and the switch is open and the current in the
        magnet can be controlled; when the switch heater is disabled
        (:code:`False`) the switch is closed and the current in the magnet cannot
        be controlled.

        When turning on the switch heater with :code:`True`, the switch heater is
        only activated if the current of the power supply matches the last
        recorded current in the magnet.

        .. warning::
            These checks can be omitted by using :code:`""Force""` in stead of
            :code:`True`. Caution: Not performing these checks can cause serious
            damage to both the power supply and the magnet.

        After turning on the switch heater it is necessary to wait several
        seconds for the switch the respond.

        Raises a :class:`.SwitchHeaterError` if the system reports a 'heater fault'
        or if no switch is fitted on the system upon getting the status.
        """"""
        status_value = self.switch_heater_status
        status = self._SWITCH_HEATER_GET_VALUES[status_value]

        if isinstance(status, str):
            raise SwitchHeaterError(
                ""IPS 120-10: switch heater status reported issue with ""
                ""switch heater: %s"" % status)

        return status

    @switch_heater_enabled.setter
    def switch_heater_enabled(self, value):

        status_value = self._SWITCH_HEATER_SET_VALUES[value]

        if status_value == 2:
            log.info(""IPS 120-10: Turning on the switch heater without any safety checks."")

        self.switch_heater_status = status_value

    current_setpoint = Instrument.control(
        ""R0"", ""I%f"",
        """""" A floating point property that controls the magnet current set-point of
        the IPS in ampere. """""",
        validator=truncated_range,
        values=[0, 120],  # Ampere
        dynamic=True,
    )

    field_setpoint = Instrument.control(
        ""R8"", ""J%f"",
        """""" A floating point property that controls the magnetic field set-point of
        the IPS in Tesla. """""",
        validator=truncated_range,
        values=[-7, 7],  # Tesla
        dynamic=True,
    )

    sweep_rate = Instrument.control(
        ""R9"", ""T%f"",
        """""" A floating point property that controls the sweep-rate of
        the IPS in Tesla/minute. """""",
        dynamic=True,
    )

    activity = Instrument.control(
        ""X"", ""A%d"",
        """""" A string property that controls the activity of the IPS. Valid values
        are ""hold"", ""to setpoint"", ""to zero"" and ""clamp"" """""",
        preprocess_reply=lambda v: v[4],
        cast=int,
        values={""hold"": 0, ""to setpoint"": 1, ""to zero"": 2, ""clamp"": 4},
        map_values=True,
    )

    sweep_status = Instrument.measurement(
        ""X"",
        """""" A string property that returns the current sweeping mode of the IPS. """""",
        preprocess_reply=lambda v: v[11],
        cast=int,
        values={""at rest"": 0, ""sweeping"": 1, ""sweep limiting"": 2, ""sweeping & sweep limiting"": 3},
        map_values=True,
    )

    @property
    def field(self):
        """""" Property that returns the current magnetic field value in Tesla.
        """"""

        try:
            heater_on = self.switch_heater_enabled
        except SwitchHeaterError as e:
            log.error(""IPS 120-10: Switch heater status reported issue: %s"" % e)
            field = self.demand_field
        else:
            if heater_on:
                field = self.demand_field
            else:
                field = self.persistent_field

        return field

    def enable_control(self):
        """""" Enable active control of the IPS by setting control to remote and
        turning off the clamp.
        """"""
        log.debug(""start enabling control"")
        self.control_mode = ""RU""

        # Turn off clamping if still clamping
        if self.activity == ""clamp"":
            self.activity = ""hold""

        # Turn on switch-heater if field at zero
        if self.field == 0:
            log.debug(""enabling switch heater"")
            self.switch_heater_enabled = True

    def disable_control(self):
        """""" Disable active control of the IPS (if at 0T) by turning off the switch heater,
        clamping the output and setting control to local.
        Raise a :class:`.MagnetError` if field not at 0T. """"""
        log.debug(""start disabling control"")
        if not self.field == 0:
            raise MagnetError(""IPS 120-10: field not at 0T; cannot disable the supply. "")

        log.debug(""disabling switch heater"")
        self.switch_heater_enabled = False
        self.activity = ""clamp""
        self.control_mode = ""LU""

    def enable_persistent_mode(self):
        """""" Enable the persistent magnetic field mode.
         Raise a :class:`.MagnetError` if the magnet is not at rest. """"""
        # Check if system idle
        log.debug(""enabling persistent mode"")
        if not self.sweep_status == ""at rest"":
            raise MagnetError(""IPS 120-10: magnet not at rest; cannot enable persistent mode"")

        if not self.switch_heater_enabled:
            log.debug(""magnet already in persistent mode"")
            return  # Magnet already in persistent mode
        else:
            self.activity = ""hold""
            self.switch_heater_enabled = False
            log.info(""IPS 120-10: Wait for for switch heater delay"")
            sleep(self._SWITCH_HEATER_COOLING_DELAY)
            self.activity = ""to zero""
            self.wait_for_idle()

    def disable_persistent_mode(self):
        """""" Disable the persistent magnetic field mode.
         Raise a :class:`.MagnetError` if the magnet is not at rest. """"""
        # Check if system idle
        log.debug(""disabling persistent mode"")
        if not self.sweep_status == ""at rest"":
            raise MagnetError(""IPS 120-10: magnet not at rest; cannot disable persistent mode"")

        # Check if the setpoint equals the persistent field
        if not self.field == self.field_setpoint:
            log.warning(""IPS 120-10: field setpoint and persistent field not identical; ""
                        ""setting the setpoint to the persistent field."")
            self.field_setpoint = self.field

        if self.switch_heater_enabled:
            log.debug(""magnet already in demand mode or at 0 field"")
            return  # Magnet already in demand mode or at 0 field
        else:
            log.debug(""set activity to 'to setpoint'"")
            self.activity = ""to setpoint""
            self.wait_for_idle()
            log.debug(""set activity to 'hold'"")
            self.activity = ""hold""
            log.debug(""enable switch heater"")
            self.switch_heater_enabled = True
            log.info(""IPS 120-10: Wait for for switch heater delay"")
            sleep(self._SWITCH_HEATER_HEATING_DELAY)

    def wait_for_idle(self, delay=1, max_wait_time=None, should_stop=lambda: False):
        """""" Wait until the system is at rest (i.e. current of field not ramping).

        :param delay: Time in seconds between each query into the state of the instrument.
        :param max_wait_time: Maximum time in seconds to wait before is at rest. If the system is
            not at rest within this time a :class:`TimeoutError` is raised. :code:`None` is
            interpreted as no maximum time.
        :param should_stop: A function that returns :code:`True` when this function should return
            early.
        """"""
        log.debug(""waiting for magnet to be idle"")
        start_time = time()

        while True:
            log.debug(""sleeping for %d s"", delay)
            sleep(delay)

            log.debug(""checking the status of the sweep"")
            status = self.sweep_status

            if status == ""at rest"":
                log.debug(""status is 'at rest', waiting is done"")
                break
            if should_stop():
                log.debug(""external function signals to stop waiting"")
                break

            if max_wait_time is not None and time() - start_time > max_wait_time:
                raise TimeoutError(""IPS 120-10: Magnet not idle within max wait time."")

    def set_field(self, field, sweep_rate=None, persistent_mode_control=True):
        """""" Change the applied magnetic field to a new specified magnitude.
        If allowed (via `persistent_mode_control`) the persistent mode will be turned off
        if needed and turned on when the magnetic field is reached.
        When the new field set-point is 0, the set-point of the instrument will not be changed
        but rather the `to zero` functionality will be used. Also, the persistent mode will not
        turned on upon reaching the 0T field in this case.

        :param field: The new set-point for the magnetic field in Tesla.
        :param sweep_rate: A numeric value that controls the rate with which to change
            the magnetic field in Tesla/minute.
        :param persistent_mode_control: A boolean that controls whether the persistent mode
            may be turned off (if needed before sweeping) and on (when the field is reached);
            if set to :code:`False` but the system is in persistent mode, a :class:`.MagnetError`
            will be raised and the magnetic field will not be changed.

        """"""

        # Check if field needs changing
        if self.field == field:
            return

        if self.switch_heater_enabled:
            pass  # Magnet in demand mode
            log.debug(""Magnet in demand mode, continuing"")
        else:
            # Magnet in persistent mode
            log.debug(""Magnet in persistent mode"")
            if persistent_mode_control:
                log.debug(""trying to disable persistent mode"")
                self.disable_persistent_mode()
            else:
                raise MagnetError(
                    ""IPS 120-10: magnet is in persistent mode but cannot turn off ""
                    ""persistent mode because persistent_mode_control == False. ""
                )

        if sweep_rate is not None:
            log.debug(""setting the sweep rate to %s"", sweep_rate)
            self.sweep_rate = sweep_rate

        if field == 0:
            log.debug(""setting activity to 'to zero' - running down the field"")
            self.activity = ""to zero""
        else:
            log.debug(""setting activity to 'to setpoint'"")
            self.activity = ""to setpoint""
            log.debug(""setting the field_setpoint to %d"", field)
            self.field_setpoint = field

        log.debug(""waiting for magnet to be finished"")
        self.wait_for_idle()
        log.debug(""sleeping for additional 10s (whatever the reason)"")
        sleep(10)

        if persistent_mode_control and field != 0:
            log.debug(
                ""persistent mode control is on, and setpoint_field !=0 - enabling persistent mode""
            )
            self.enable_persistent_mode()

    def train_magnet(self, training_scheme):
        """""" Train the magnet after cooling down. Afterwards, set the field
        back to 0 tesla (at last-used ramp-rate).

        :param training_scheme: The training scheme as a list of tuples; each
            tuple should consist of a (field [T], ramp-rate [T/min]) pair.
        """"""

        for (field, rate) in training_scheme:
            self.set_field(field, rate, persistent_mode_control=False)

        self.set_field(0)
"
395,https://www.thinksrs.com/downloads/pdfs/catalog/SR510530c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attTfE5nBuJLi6efo'), ('width', 3969), ('height', 1716), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/63JzhEKHbYI8cU2COubCwg/xRt-XPX8E4f6Aa1jkxAViRTC_YuvCCb8x4kvkJVv8ICCbPV0YNaUqieagvgasjqVXHrxLOOycRkKg9MIij1kAsvcepA1JhkvuL4pE7VtJ_4/IEX-8MA65VODKIW6sonhSwXcJ2HrgqrdgXyiM8m6ckk'), ('filename', 'SR530 Main Pic.jpg'), ('size', 1598439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/LBkMi1n0_Y844fEMLxmiYw/S-Bhsjhub2blKo302c7oe1hP4J2hg7qTBNgwafFfS9lLwH9bDrWyrqzNG4fUlcJmtAbtVmy-y5L8z1RGljovag/Bk5t2g19L1q6XYqR5jiTiV3PNBuIs2MCEwBcV2VYIh8'), ('width', 83), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eqvYSHRkMGunvhsCWHKn6Q/MzdqIgTv9zrhH4CtHq8DTWPcTZQJaUPMNX12875L8Wr1nTFGRuQRQQ2R7E5p_hklthm6MwBdrzTui6ebIcWsHg/hFnHUTpQaumG_KaTyl_YMsEPwunoj0eKFJ5hFJd4VUQ'), ('width', 1184), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/MEQM4svRuPd0ea4XRKJAbg/JxJOkpR2KNCOKYT4WmdgIwetmAuNu4tB5GHhakCrPcarNFMaglFxo3TPHM8bCMnK8Jw1aea3bOsu-LBgR9DDRQ/4aUnmQrudXVB2quN6LjfMwCVmkWsz81K2u81pFR9Yek'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692126012/Instruments/Vendor%20Logos/Stanford_Research.png,The SR510 is analog lock-in amplifiers which can measure AC signals as small as nanovolts in the presence of much larger noise levels.,https://www.thinksrs.com/products/sr510530.htm,SR 510,524.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr510.py,Pymeasure,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr510.html,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/vAdn9RCqNR29j-qU1vOlIw/0xBdAVPfPzXB76LVwfRwrZm6vcYo5o-ooGCfY7TjQH0Sz8evvKFnHhJz5Nc135yxNgQldE625x0WqHklseZaztBqkp_QXFWe3JH-4pLdVBU/G2j4tnR1coxkZuHu89mJqYVmc9VxzgO8dHjCegwm2SE'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/eMMwtKEmQzTWNSw5_-u8Jw/mNoR6RjXIykAaNkCZU9yGcccPVx5wTkKBxoE-RbDnAnn8yjm8tU1yr_y2IVoxb8eYTqGwt7MTpz2kSvAreybFQ/Vs1OxR6JJ62ZQPYYMgucrbsEWOeGRxQdwVrCL4Vu28Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/OBuLCflOPMgndH3DxsZ6pQ/zIdQCF5XWG4S_HCfQQq_UHes3YjYoC_eBFzZ9T5Bg3fiz8qvS_HCIZ9xAL1aH83Zv13HMtshA4BSror_2OU8uw/SE1s-GvQRTvdSIlSVn4pgSIx0PmaRXyXxw2iHQjw9-o'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692252000000/zd3Y5GkNZy0WXbdZfaz5dA/zArTMFGsuSth_ZzSeXydm-rG4Gv90WQ6bYY_bGFevZvW0rQ0fr8ACcptniZg_laIMpuJeCU5-CiULki1gJZ2GQ/3nLVgQXA2hrZjsqH1jzZh44jWWMn9dQRm1CIvpVViGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782770/Instruments/Lockin%20Amplifiers/SR-510/SR-510.jpg,SR 510,Write a Python script that uses Pymeasure to connect to a SR 510 Lockin Amplifiers,2495.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, truncated_discrete_set


class SR510(Instrument):
    TIME_CONSTANTS = {1e-3: 1, 3e-3: 2, 10e-3: 3, 30e-3: 4, 100e-3: 5,
                      300e-3: 6, 1: 7, 3: 8, 10: 9, 30: 10, 100: 11, }

    SENSITIVITIES = {10e-9: 1, 20e-9: 2, 50e-9: 3, 100e-9: 4, 200e-9: 5, 500e-9: 6,
                     1e-6: 7, 2e-6: 8, 5e-6: 9, 10e-6: 10, 20e-6: 11, 50e-6: 12, 100e-6: 13,
                     200e-6: 14, 500e-6: 15, 1e-3: 16, 2e-3: 17, 5e-3: 18, 10e-3: 19, 20e-3: 20,
                     50e-3: 21, 100e-3: 22, 200e-3: 23, 500e-3: 24, }

    phase = Instrument.control(
        ""P"", ""P %g"",
        """"""A float property that represents the SR510 reference to input
        phase offset in degrees. Queries return values between -180 and
        180 degrees. This property can be set with a range of values
        between -999 to 999 degrees. Set values are mapped internal in the
        lockin to -180 and 180 degrees."""""",
        validator=truncated_range,
        values=[-999, 999],
    )

    time_constant = Instrument.control(
        ""T1"", ""T1,%d"",
        """"""A float property that represents the SR510 PRE filter time constant.
        This property can be set."""""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True,
    )

    sensitivity = Instrument.control(
        ""G"", ""G%d"",
        """"""A float property that represents the SR510 sensitivity value.
           This property can be set."""""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True,
    )

    frequency = Instrument.measurement(
        ""F"",
        """"""A float property representing the SR510 input reference frequency"""""",
    )

    status = Instrument.measurement(
        ""Y"",
        """"""A string property representing the bits set within the SR510 status byte"""""",
        get_process=lambda s: bin(int(s))[2:],
    )

    output = Instrument.measurement(
        ""Q"",
        """"""A float property that represents the SR510 output voltage in Volts."""""",
    )

    def __init__(self, adapter, name=""Stanford Research Systems SR510 Lock-in amplifier"",
                 **kwargs):
        kwargs.setdefault('write_termination', '\r')
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs,
        )
"
