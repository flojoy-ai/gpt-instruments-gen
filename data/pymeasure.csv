,"Yearly revenue (millions, USD)",Vendor headquarters,Device Description,Device,Field 1,Vendor wikipedia or cruncbase description,Library,Vendor,Vendor logo,Vendor website,ChatGPT prompt,Category description link,Device Category,Category Description,Corrected device name,Device datasheet (PDF),Device picture,Device Description Link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Python docs link,Device Price,ChatGPT code,Obsolete,Notes,docstring
6,21.4,"Westerville, Ohio, USA","Flexible probe configurations to suit your application.
Several sensor types available with different performance characteristics.
Most suited for field levels from earth field to very large electromagnets.
Application-specific probe customization available.",Lakeshore 421,354.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Pymeasure,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Pymeasure to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Magnetometer,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.",,https://www.lakeshore.com/docs/default-source/product-downloads/421_manual.pdf?sfvrsn=df2b523_1,"[OrderedDict([('id', 'attfRIGys26mJGLmT'), ('width', 673), ('height', 349), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ED9I-hCX6j9u6trqmAMfig/JH6z3oFqY07-CXdJFAgl_ENnerzJmhTeuSN4VNBtx6YwtjopXfw0nSHI60sqzhKEcQJ4Xf7o1th-CFRkwcs1CKrPOPvUUnq1MzfwZ_jKNns/fRIT-PYoDZ_Fv2LfCtaQtpWxjAMR5P_Yy-ihRxID12M'), ('filename', 'image.png'), ('size', 131267), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YpHFnNWj2y92BnqK6mYk_w/5lHhsmu1GCVM1k5jEGsgZnBXD5uELrM2Z7ycfZ-9o8uDIEUwWBt9rFJvkXz0d-48hn0E1kHy6BhbEPIFUKsRoQ/pdBZLhcUTQQl0yckEUJW1ZZPsx8izhDwr0ZR4YzsJNA'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bry40wu6qUlL8GSG1gAfjw/qCGPTuf07MW0bn4eQzMPao6wJG7JrwmRC3LOsaoAn4NYBUAM8cEBnkr0jQCHvabveoKt1TkpCicus1a3cGeQ8g/HNuiWCYxOGLc0QT7NDFX9_MiJaQL6VzQHEfmW9tEW_E'), ('width', 673), ('height', 349)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eogRv8R0EDUxmXFELjL3ZA/yQGSzldQmQW1oYKJv7Y9vBzsZsL_1NSqCBOm95vYaev_RvyRIos1kVgid0MMbpbqLFl0rlVeQgOJRmx7Nzi49w/8x9Q57mjjIpnjnwhAXK_KvX4nRnWl4_YOUHlo8qRaaU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/magnetic-products/hall-probes/400-series-hall-probes,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore421.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore421.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set

import numpy as np
from time import time, sleep


class LakeShore421(Instrument):
    """"""
    Represents the Lake Shore 421 Gaussmeter and provides a high-level interface for interacting
    with the instrument.

    .. code-block:: python

        gaussmeter = LakeShore421(""COM1"")
        gaussmeter.unit = ""T""               # Set units to Tesla
        gaussmeter.auto_range = True        # Turn on auto-range
        gaussmeter.fast_mode = True         # Turn on fast-mode


    A delay of 50 ms is ensured between subsequent writes, as the instrument cannot correctly
    handle writes any faster.
    """"""

    MULTIPLIERS = {1e3: 'k', 1: '', 1e-3: 'm', 1e-6: 'n'}
    PROBE_TYPES = {""High Sensitivity"": 0,
                   ""High Stability"": 1,
                   ""Ultra-High Sensitivity"": 2}
    RANGES = [30e3, 3e3, 300, 30]  # in Gauss
    RANGE_MULTIPLIER_PROBE = [1, 10, 0.01]
    RANGE_MULTIPLIER_UNIT = {'G': 1, 'T': 1e-4}
    UNITS = ['G', 'T']
    WRITE_DELAY = 0.05

    def __init__(self, adapter, name=""Lake Shore 421 Gaussmeter"", baud_rate=9600, **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'baud_rate': baud_rate, 'data_bits': 7, 'stop_bits': 10, 'parity': 1},
            read_termination='\r',
            write_termination='\n',
            **kwargs
        )
        self.last_write_time = time()

    def _raw_to_field(self, field_raw, multiplier_name):
        if not field_raw == ""OL"":
            multiplier = getattr(self, multiplier_name)
            field = multiplier * field_raw
        else:
            field = np.nan

        return field

    def _field_to_raw(self, field, multiplier_name):
        multiplier = getattr(self, multiplier_name)
        return field / multiplier

    field_raw = Instrument.measurement(
        ""FIELD?"",
        """""" Returns the field in the current units and multiplier
        """""",
    )

    field_multiplier = Instrument.measurement(
        ""FIELDM?"",
        """""" Returns the field multiplier for the returned magnetic field.
        """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def field(self):
        """""" Returns the field in the current units. This property takes into
        account the field multiplier. Returns np.nan if field is out of range.
        """"""
        return self._raw_to_field(self.field_raw, ""field_multiplier"")

    unit = Instrument.control(
        ""UNIT?"", ""UNIT %s"",
        """""" A string property that controls the units used by the gaussmeter.
        Valid values are G (Gauss), T (Tesla). """""",
        validator=strict_discrete_set,
        values=UNITS,
    )

    field_range_raw = Instrument.control(
        ""RANGE?"", ""RANGE %d"",
        """""" A integer property that controls the field range of the
        meter. Valid values are 0 (highest) to 3 (lowest). """""",
        validator=truncated_discrete_set,
        values=range(4),
        cast=int,
    )

    @property
    def field_range(self):
        """""" A floating point property that controls the field range of the
        meter in the current unit (G or T). Valid values are 30e3, 3e3, 300,
        30 (when in Gauss), or 0.003, 0.03, 0.3, and 3 (when in Tesla).
        """"""
        probe_multiplier = self.RANGE_MULTIPLIER_PROBE[self.PROBE_TYPES[self.probe_type]]
        unit_multiplier = self.RANGE_MULTIPLIER_UNIT[self.unit]
        range = self.RANGES[self.field_range_raw]
        return np.round(range * probe_multiplier * unit_multiplier, 3)

    @field_range.setter
    def field_range(self, range):
        probe_multiplier = self.RANGE_MULTIPLIER_PROBE[self.PROBE_TYPES[self.probe_type]]
        unit_multiplier = self.RANGE_MULTIPLIER_UNIT[self.unit]
        ranges = np.array(self.RANGES) * probe_multiplier * unit_multiplier
        range = truncated_discrete_set(range, values=ranges)
        range = np.round(range / (probe_multiplier * unit_multiplier), 3)

        self.field_range_raw = self.RANGES.index(range)

    auto_range = Instrument.control(
        ""AUTO?"", ""AUTO %d"",
        """""" A boolean property that controls the auto-range option of the
        meter. Valid values are True and False. Note that the auto-range is
        relatively slow and might not suffice for rapid measurements.
        """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    fast_mode = Instrument.control(
        ""FAST?"", ""FAST %d"",
        """""" A boolean property that controls the fast-mode option of the
        meter. Valid values are True and False. When enabled, the relative
        mode, Max Hold mode, alarms, and autorange are disabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    field_mode = Instrument.control(
        ""ACDC?"", ""ACDC %d"",
        """""" A string property that controls whether the gaussmeter measures
        AC or DC magnetic fields. Valid values are ""AC"" and ""DC"". """""",
        validator=strict_discrete_set,
        values={""DC"": 0, ""AC"": 1},
        map_values=True,
    )

    def zero_probe(self, wait=True):
        """""" Reset the probe value to 0. It is normally used with a zero gauss
        chamber, but may also be used with an open probe to cancel the Earth
        magnetic field. To cancel larger magnetic fields, the relative mode
        should be used.

        :param bool wait:
            Wait for 20 seconds after issuing the command to allow the
            resetting to finish.

        """"""
        self.write(""ZCAL"")
        if wait:
            sleep(20)

    probe_type = Instrument.measurement(
        ""TYPE?"",
        """""" Returns type of field-probe used with the gaussmeter. Possible
        values are High Sensitivity, High Stability, or Ultra-High Sensitivity.
        """""",
        values=PROBE_TYPES,
        map_values=True,
    )

    serial_number = Instrument.measurement(
        ""SNUM?"",
        """""" Returns the serial number of the probe. """"""
    )

    display_filter_enabled = Instrument.control(
        ""FILT?"", ""FILT %d"",
        """""" A boolean property that controls the display filter to make it
        more readable when the probe is exposed to a noisy field. The filter
        function makes a linear average of 8 readings and settles in
        approximately 2 seconds. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    front_panel_locked = Instrument.control(
        ""LOCK?"", ""LOCK %d"",
        """""" A boolean property that locks or unlocks all front panel entries
        except pressing the Alarm key to silence alarms. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    front_panel_brightness = Instrument.control(
        ""BRIGT?"", ""BRIGT %d"",
        """""" An integer property that controls the brightness of the from panel
        display. Valid values are 0 (dimmest) to 7 (brightest). """""",
        validator=strict_discrete_set,
        values=range(8),
    )

    # MAX HOLD
    max_hold_enabled = Instrument.control(
        ""MAX?"", ""MAX %d"",
        """""" A boolean property that enables or disables the Max Hold function to
        store the largest field since the last reset (with max_hold_reset). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    max_hold_field_raw = Instrument.measurement(
        ""MAXR?"",
        """""" Returns the largest field since the last reset in the current units
        and multiplier.
        """""",
    )

    max_hold_multiplier = Instrument.measurement(
        ""FIELDM?"",
        """""" Returns the multiplier for the returned max hold field.
        """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def max_hold_field(self):
        """""" Returns the largest field since the last reset in the current units.
        This property takes into account the field multiplier. Returns np.nan if
        field is out of range.
        """"""
        return self._raw_to_field(self.max_hold_field_raw, ""max_hold_multiplier"")

    def max_hold_reset(self):
        """""" Clears the stored Max Hold value. """"""
        self.write(""MAXC"")

    # RELATIVE MODE
    relative_mode_enabled = Instrument.control(
        ""REL?"", ""REL %d"",
        """""" A boolean property that enables or disables the relative mode to
        see small variations with respect to a given setpoint. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    relative_field_raw = Instrument.measurement(
        ""RELR?"",
        """""" Returns the relative field in the current units and the current
        multiplier. """""",
    )

    relative_multiplier = Instrument.measurement(
        ""RELRM?"",
        """""" Returns the relative field multiplier for the returned magnetic
        field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def relative_field(self):
        """""" Returns the relative field in the current units. This property
        takes into account the field multiplier. Returns np.nan if field is
        out of range.
        """"""
        return self._raw_to_field(self.relative_field_raw, ""relative_multiplier"")

    relative_setpoint_raw = Instrument.control(
        ""RELS?"", ""RELS %g"",
        """""" Property that controls the setpoint for the relative field mode in
        the current units and multiplier. """""",
    )

    relative_setpoint_multiplier = Instrument.measurement(
        ""RELRM?"",
        """""" Returns the multiplier for the setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def relative_setpoint(self):
        """""" Property that controls the setpoint for the relative field mode in
        the current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.relative_setpoint_raw, ""relative_setpoint_multiplier"")

    @relative_setpoint.setter
    def relative_setpoint(self, value):
        self.relative_setpoint_raw = self._field_to_raw(value, ""relative_setpoint_multiplier"")

    # ALARM MODE
    alarm_mode_enabled = Instrument.control(
        ""ALARM?"", ""ALARM %d"",
        """""" A boolean property that enables or disables the alarm mode. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_audible = Instrument.control(
        ""ALMB?"", ""ALMB %d"",
        """""" A boolean property that enables or disables the audible alarm
        beeper. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_in_out = Instrument.control(
        ""ALMB?"", ""ALMB %d"",
        """""" A string property that controls whether an active alarm is caused
        when the field reading is inside (""Inside"") or outside (""Outside"") of
        the high and low setpoint values. """""",
        validator=strict_discrete_set,
        values={""Inside"": 1, ""Outside"": 0},
        map_values=True,
    )

    alarm_active = Instrument.measurement(
        ""ALMS?"",
        """""" A boolean property that returns whether the alarm is triggered. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_sort_enabled = Instrument.control(
        ""ALMSORT?"", ""ALMSORT %d"",
        """""" A boolean property that enables or disables the alarm Sort Pass/Fail
        function. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    alarm_low_raw = Instrument.measurement(
        ""ALML?"", ""ALML %g"",
        """""" Property that controls the lower setpoint for the alarm mode in the
        current units and multiplier. """""",
    )

    alarm_low_multiplier = Instrument.measurement(
        ""ALMLM?"",
        """""" Returns the multiplier for the lower alarm setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def alarm_low(self):
        """""" Property that controls the lower setpoint for the alarm mode in the
        current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.alarm_low_raw, ""alarm_low_multiplier"")

    @alarm_low.setter
    def alarm_low(self, value):
        self.alarm_low_raw = self._field_to_raw(value, ""alarm_low_multiplier"")

    alarm_high_raw = Instrument.measurement(
        ""ALMH?"", ""ALMH %g"",
        """""" Property that controls the upper setpoint for the alarm mode in the
        current unit and multiplier. """""",
    )

    alarm_high_multiplier = Instrument.measurement(
        ""ALMHM?"",
        """""" Returns the multiplier for the upper alarm setpoint field. """""",
        values=MULTIPLIERS,
        map_values=True,
    )

    @property
    def alarm_high(self):
        """""" Property that controls the upper setpoint for the alarm mode in the
        current units. This takes into account the field multiplier. """"""
        return self._raw_to_field(self.alarm_high_raw, ""alarm_high_multiplier"")

    @alarm_high.setter
    def alarm_high(self, value):
        self.alarm_high_raw = self._field_to_raw(value, ""alarm_high_multiplier"")

    def shutdown(self):
        """""" Closes the serial connection to the system. """"""
        self.adapter.connection.close()
        super().shutdown()

    ###################################################
    # Redefined methods to ensure time between writes #
    ###################################################

    def delay_write(self):
        if self.WRITE_DELAY is None:
            return

        while time() - self.last_write_time < self.WRITE_DELAY:
            sleep(self.WRITE_DELAY / 10)

        self.last_write_time = time()

    def write(self, command):
        self.delay_write()
        super().write(command)
"
8,24.9,"Sunnyvale, California","The SR570 is a low-noise current preamplifier capable of current gains as large as 1 pA/V. High gain and bandwidth, low noise, and many convenient features make the SR570 ideal for a variety of photonic, low temperature and other measurements.",SR 570,520.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Pymeasure,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Pymeasure to connect to a {Device name} Preamplifier,"https://en.wikipedia.org/wiki/Preamplifier#:~:text=A%20preamplifier%2C%20also%20known%20as,power%20amplifier%20and%20a%20loudspeaker.",['Preamplifier'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker. Without this, the final signal would be noisy or distorted. They are typically used to amplify signals from analog sensors such as microphones and pickups. Because of this, the preamplifier is often placed close to the sensor to reduce the effects of noise and interference.",,https://www.thinksrs.com/downloads/pdfs/catalog/SR570c.pdf,"[OrderedDict([('id', 'atthbLSs7aLIhAPMD'), ('width', 2630), ('height', 1420), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8UFm8alVpp5t2Qpbf9jljA/dq4C_pMoIoBdHxohR6TtmbqGOzdVx7D8xYZRciZeROW2xKKx3VQQO0TFb9t4gr5-mtmsaszDBhjd_RyYGbYk-nAr3h5GmzPFIHlcP8FVSrc/Ep5bD9nusGPyluOqVvLuV06YEaee-H7S3r76hENwI0s'), ('filename', 'SR570 MainPic.jpg'), ('size', 543919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Kxb1IY7AkUYJ0La8HAFl4g/Vwept1HS2oaStgbo2kEQoboGx9Rh5lcgMWmBzivpSlPDBYAQ0akTnFn3k7gwcQHtVMoMgTJ5OBgxpwTI_aceRg/H_vhOh1IAQrcjxAIJ_KcFCYFq1QFGQ5OAmjty8yry_s'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/64cHslRfcuttIdsN2sUBsQ/GGxjtNnIwDyGZsAdjwUeZRey4lZDsa8PLXybNV90sMj9UT2VS1jzTQcGLfk3K8c574LEC_G3LVIlFJNIQjgwAw/7s5uS7rZU2_Kw2Gae-LVmKpw_mD7Q28L-FRPaQdismM'), ('width', 948), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nZluPHsZQ2yNRh8ZdMVKTw/UAD0c_77Tax277qcxqcr5HyQ1tFuU1CDlqpPqMqBJdSR54IMPIIMkbONmw8H3SiQa2DDzofRyVKM8y-QK8AN8A/BhL3_BDDIpzzemGxhOwwIw9cKg_ROfRojpz57Vsecpg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr570.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr570.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr570.html,2750.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range


class SR570(Instrument):

    def __init__(self, adapter, name=""Stanford Research Systems SR570 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    SENSITIVITIES = [
        1e-12, 2e-12, 5e-12, 10e-12, 20e-12, 50e-12, 100e-12, 200e-12, 500e-12,
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9, 500e-9,
        1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6, 200e-6, 500e-6,
        1e-3
    ]

    FREQUENCIES = [
        0.03, 0.1, 0.3, 1, 3, 10, 30, 100, 300, 1e3, 3e3, 1e4, 3e4,
        1e5, 3e5, 1e6
    ]

    FILT_TYPES = ['6dB Highpass', '12dB Highpass', '6dB Bandpass',
                  '6dB Lowpass', '12dB Lowpass', 'none']

    BIAS_LIMITS = [-5, 5]

    OFFSET_CURRENTS = [
        1e-12, 2e-12, 5e-12, 10e-12, 20e-12, 50e-12, 100e-12, 200e-12, 500e-12,
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9, 500e-9,
        1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6, 200e-6, 500e-6,
        1e-3, 2e-3, 5e-3
    ]

    GAIN_MODES = [
        'Low Noise', 'High Bandwidth', 'Low Drift'
    ]

    sensitivity = Instrument.setting(
        ""SENS %d"",
        """""" A floating point value that sets the sensitivity of the
        amplifier, which takes discrete values in a 1-2-5 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 1 pA/V to 1 mA/V."""""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True)

    filter_type = Instrument.setting(
        ""FLTT %d"",
        """""" A string that sets the filter type.
        Allowed values are: {}"""""".format(FILT_TYPES),
        validator=truncated_discrete_set,
        values=FILT_TYPES,
        map_values=True)

    low_freq = Instrument.setting(
        ""LFRQ %d"",
        """""" A floating point value that sets the lowpass frequency of the
        amplifier, which takes a discrete value in a 1-3 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 0.03 Hz to 1 MHz."""""",
        validator=truncated_discrete_set,
        values=FREQUENCIES,
        map_values=True)

    high_freq = Instrument.setting(
        ""HFRQ %d"",
        """""" A floating point value that sets the highpass frequency of the
        amplifier, which takes a discrete value in a 1-3 sequence.
        Values are truncated to the closest allowed value if not exact.
        Allowed values range from 0.03 Hz to 1 MHz."""""",
        validator=truncated_discrete_set,
        values=FREQUENCIES,
        map_values=True)

    bias_level = Instrument.setting(
        ""BSLV %g"",
        """""" A floating point value in V that sets the bias voltage level of the
        amplifier, in the [-5V,+5V] limits.
        The values are up to 1 mV precision level."""""",
        validator=truncated_range,
        values=BIAS_LIMITS,
        set_process=lambda v: int(1000 * v))

    offset_current = Instrument.setting(
        ""BSLV %f"",
        """""" A floating point value in A that sets the absolute value
        of the offset current of the amplifier, in the [1pA,5mA] limits.
        The offset current takes discrete values in a 1-2-5 sequence.
        Values are truncated to the closest allowed value if not exact. """""",
        validator=truncated_discrete_set,
        values=OFFSET_CURRENTS,
        map_values=True)

    offset_current_sign = Instrument.setting(
        ""IOSN %d"",
        """""" An string that sets the offset current sign.
        Allowed values are: 'positive' and 'negative'. """""",
        validator=strict_discrete_set,
        values={'positive': 1, 'negative': 0},
        map_values=True)

    gain_mode = Instrument.setting(
        ""GNMD %d"",
        """""" A string that sets the gain mode.
        Allowed values are: {}"""""".format(GAIN_MODES),
        validator=truncated_discrete_set,
        values=GAIN_MODES,
        map_values=True)

    invert_signal_sign = Instrument.setting(
        ""INVT %d"",
        """""" An boolean sets the signal invert sense.
        Allowed values are: True (inverted) and False (not inverted). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    bias_enabled = Instrument.setting(
        ""BSON %d"",
        """""" Boolean that turns the bias on or off.
        Allowed values are: True (bias on) and False (bias off)"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    offset_current_enabled = Instrument.setting(
        ""IOON %d"",
        """""" Boolean that turns the offset current on or off.
        Allowed values are: True (current on) and False (current off)."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    front_blanked = Instrument.setting(
        ""BLNK %d"",
        """""" Boolean that blanks(True) or un-blanks (False) the front panel"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    signal_inverted = Instrument.setting(
        ""INVT %d"",
        """""" Boolean that inverts the signal if True"""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True)

    ####################
    # Methods        #
    ####################

    def enable_bias(self):
        """"""Turns the bias voltage on""""""
        self.bias_enabled = True

    def disable_bias(self):
        """"""Turns the bias voltage off""""""
        self.bias_enabled = False

    def enable_offset_current(self):
        """"""""Enables the offset current """"""
        self.offset_current_enabled = True

    def disable_offset_current(self):
        """"""""Disables the offset current """"""
        self.offset_current_enabled = False

    def clear_overload(self):
        """"""""Reset the filter capacitors to clear an overload condition""""""
        self.write(""ROLD"")

    def blank_front(self):
        """"""""Blanks the frontend output of the device""""""
        self.front_blanked = True

    def unblank_front(self):
        """"""Un-blanks the frontend output of the device""""""
        self.front_blanked = False
"
10,19.0,USA,"Advanced Temperature Source for fast and precise thermal conditioning of components, parts, hybrids, modules, sub-assemblies, and printed circuit boards.",ATS 545,589.0,"**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",Pymeasure,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/na4BsJwlkqnuz1GWqxCV8g/8wSkZbZICUx-sWQn0mySlDB9smvlFs1-SDNJBCEB7oYSXz0MCl_3jtc9OqrfTGYRk_xBEyzTaulvgg2MYz0jU0QjvIXLed4O7LRuPARqZLTuR1Q78RJg_NYRH2zNoWVf/C3xMCyDJFEaabeVi51UFlWAjoGOacMN2IIZ6m1TzJEo'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7LM1FMdjsBNqNDVMgxqZ7Q/d1YtGTAB2BOTlYx4v1Et8YBP5WMaRw81P-S_hyaQY0EWcZ4a8Q56MNU55u0X3ftLT9mL-Wi_Lt1jws1RSQu-wA/Y0r4Sg_aR6Q3yBZwwWGN9kqZtgYrXtYUAMCN5Hb7qwM'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Z_PgK_5CwclJGyIfTUx3A/4oiK1H_smeqwPEb8SfQGnbaoPj05nFJUqDLsmTnIYNm6JP5awVfpqHHL09x0sT862YBMeRbvjdRzNL2DonfSNQ/ARBzmImWLfvEtAjovr3AWxWG3RPMeSnG2vZcJa1XZT0'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QaO1zUTsPkXAzHmYqbUQxg/bOJHt3CC4PShuZ0yDuiTw9c68CGwNAhBzq1_5WE7Iz8_8TR_RPSil1-IcBKGG3_KQctxujlYPCdWQuFruWsPZQ/AdtFsIajUdOnVt0LVkN4IOIlu7AqpNshZTBk_YXgjbo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.",['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",,https://maximinstruments.com/pdf_files/TEMPTRONIC_ATS_545M_Datasheet.pdf,"[OrderedDict([('id', 'att9EQfTMzTFmVkvx'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/y4vFfqErW41zX5lgDgs9iQ/aXj38bWyvxk_D04B6kuqSZCGH1qeeoPJdCpp3-WoXeFlFH7PI4ZJ9NEZ-enDmtNljvlTPEbUCxAgmhs3Y7fjwPs2Ng6AFgtQQXXUg-yz_xY/mKqplzsmfD7t6YwUv0G4HIXUTpcYOxyAG20aMdw42s8'), ('filename', 'image.jpeg'), ('size', 12730), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lGw01qOuY1CaQrFBSzwg9Q/QfLKHqmby6rTcwdZFQKcSFbsEmTecoYeR8RvRnYkSYdc-m8VcscO9HLqLSuQ8HD3899iAZoSRg6uWRhurv6FZQ/pbjAaqrw3qMdKdSNQ_OI5g6gWTRWua7uYla7idd4-nU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MEzw2pyLsapvJ09DPDlXTg/8xrN-O92rxf_FLVkO6q4yLwUTobGucxCvFI3qr9-t5aqsfmpobjiLGYDczJRJ5ZPUkidwtIqZqzlOzpmesgcmA/6n6onKcBx935XkPph1dcR7s_o9zcTTeFdoiDQ25f6_0'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xzYqmDelOqSgwssfu9QlSw/9FSLw_GLanR54AbNAZpywQtOL8H7mquzFTiWff6LxIDABtD6WbqGb8BlZ4BzgUtwaF-PfSC5saoxBTo420RIlw/YYsqrdL_QfWGqxijDzM-G9H3j2U4gxigMoDK9Ul7Anw'), ('width', 3000), ('height', 3000)]))]))])]",https://maximinstruments.com/products/temptronic_ats_545_m_thermostream__80_to_225c,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_ats545.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_ats545.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ATS-545 & -645
THERMOSTREAM
Interface & Applications Manual
Revision B
November, 2015
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase


class ATS545(ATSBase):
    """"""Represents the TemptronicATS545 instrument.

    Coding example

    .. code-block:: python

        ts = ATS545('ASRL3::INSTR')  # replace adapter address
        ts.configure()  # basic configuration (defaults to T-DUT)
        ts.start()  # starts flow (head position not changed)
        ts.set_temperature(25)  # sets temperature to 25 degC
        ts.wait_for_settling()  # blocks script execution and polls for settling
        ts.shutdown(head=False)  # disables thermostream, keeps head down

    """"""

    temperature_limit_air_low_values = [-80, 25]

    mode_values = {'manual': 10,    # 5 in ATSbase
                   'program': 0,    # 6 in ATSbase
                   'initial': 63},  # after power up, reading is 63

    def next_setpoint(self):
        """"""not implemented in ATS545

        set ``self.set_point_number`` instead
        """"""
        raise NotImplementedError

    def __init__(self, adapter, name=""Temptronic ATS-545 Thermostream"", **kwargs):
        super().__init__(adapter, name, **kwargs)
"
20,318.0,Japan,"The 7651 is a general-purpose DC source developed on YOKOGAWA's state-of-the-art DC standard technology. The dual multiplying D/A converter has enabled the compatibility of high-speed response and high resolution. The 7651 also provides high accuracy and stability. In addition to the source function (current supply), the sink function (current absorption) is also available, so the 7651 can be used as not only DC voltage/current source but also high-precision electronic load. Further, a series of powerful functions to meet the system use such as the programming function up to 50 steps, the IC memory card capable of storing 7 patterns of programs, and GP-IB interface are provided as standard. This 7651 can be used for a wide range of fields from R & D to production line, service and maintenance.",Yokogawa 7651,639.0,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",Pymeasure,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UaAsDYNLAOdUQ4cG-gVBw/NTY986xzNYwKbonHbWwWC4LeHEHqycOQeXYwRbRUCHdcuhOKGAvrvBoatXQsD5bpSMp051hQO8G6Z1_BiSG1VC6MM2RwFw-JgfT3HK4pXZo/cdsfM51bauCXQpD2o4jMtv4J_4Pc6fMk_dJlEKX20e0'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0FZ2eqXGORQw7KhD8ggQhA/54nn9VVUA8rLZTUqpQNJJRRABVqmHyYpr39PgVnaWermrd9uQk4oKjA-U_ElbfbtDYyDeyOy0wUoLtc2W5106g/xl6wqD05nzCPSKrDuCKrzZgEG0XSnoQSadmaYKdpFJM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HaEWyRlZBthPGsYttIxnHQ/Dg6dnKGNXLv3Mh6hmw3-ew1Frbuj6oI01Vn3HH6YZCGh51cSS68iCmPrXpZJPdTo-4wfWlWjjSEU4Ca-zmtRlQ/eXk6rUTl5KsnGehm3vQUBE5QCuNLX-D5bbpf0_IxIrM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IbzTBl4xKhTim-kj9IZJWw/jqTaszS54GnOhLIRvMV0S3ODA6kF-CfXSMb2hQnB7aSuYMsMIsRnYenR7US3v50OI9A0DzAtFvhKHusA-qJEaw/o46lbBXBsIcuUNQKSTjhxI0hmLRfL48B90X8oBZ96jI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ",,https://cdn.tmi.yokogawa.com/IM7651-01E.is.pdf,"[OrderedDict([('id', 'attI6RnDjug8zxuhg'), ('width', 800), ('height', 502), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9NCyMaa88_Zc-eKVBGsEJA/7K_8XnPnZ4nlXQOTXBfO5tcLwKg4weFgGFlPfkF4nY2gpx-qf9KVxJ4xXZJRxYzzy4Rj9-fW7QSd7hNMepygMvdzl2kDcTUC0bo3pSFl7Jk/9uTLBg3pduNXNrHzYgf-GUYxzLLj8beVHHK1Ripp89A'), ('filename', '7651_lg.jpg'), ('size', 302628), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Hadpql77qCDc0U_vp2P0BQ/tWtoIs4b4tyA3TqbCfAQNKPXfIAcxREFKjza-DSYU9vlflQSFjQxkzQO4025n_GANJINdduFyP0W-GPRFKQuKQ/UHdlXDvM63pBfal_OC8-KquexzqNgS-BJrXbDiv_byA'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cMCW8Uoqit6sCsPeOqEq6g/a3gGR6xNaQdu8p2Z_gQ6EHyt3xF8wW22_kAgS0dpn1VUrF00FcRKL_LfXuBKJ7qlR4FH84FKzsSDKenk0VYbhg/Fn9wK56mnP0VuqYLI8BpB0Vztw069sLZkrUbhV-WCzU'), ('width', 800), ('height', 502)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/09YTAvxlYUTYot8Brf-p3g/vR6NxMthAi5TPYEtVTKS7vsERzM--4-VuRAsZIi3PQ8feybG4DgCZmiZ3IyN8tW6XdN15YO1-NhLkPYqyKhcEg/klHCEwq7_cib3750_Okqc4zGa25sMUuBSJXBm-0tdLw'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/discontinued/7651-programmable-dc-source/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/yokogawa/yokogawa7651.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/yokogawa/yokogawa7651.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging
from time import sleep
import re

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    truncated_discrete_set, strict_discrete_set,
    truncated_range
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Yokogawa7651(Instrument):
    """""" Represents the Yokogawa 7651 Programmable DC Source
    and provides a high-level for interacting with the instrument.

    .. code-block:: python

        yoko = Yokogawa7651(""GPIB::1"")

        yoko.apply_current()                # Sets up to source current
        yoko.source_current_range = 10e-3   # Sets the current range to 10 mA
        yoko.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        yoko.source_current = 0             # Sets the source current to 0 mA

        yoko.enable_source()                # Enables the current output
        yoko.ramp_to_current(5e-3)          # Ramps the current to 5 mA

        yoko.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    @staticmethod
    def _find(v, key):
        """""" Returns a value by parsing a current panel setting output
        string array, which is returned with a call to ""OS;E"". This
        is used for Instrument.control methods, and should not be
        called directly by the user.
        """"""
        status = ''.join(v.split(""\r\n\n"")[1:-1])
        keys = re.findall(r'[^\dE+.-]+', status)
        values = re.findall(r'[\dE+.-]+', status)
        if key not in keys:
            raise ValueError(""Invalid key used to search for status of Yokogawa 7561"")
        else:
            return values[keys.index(key)]

    source_voltage = Instrument.control(
        ""OD;E"", ""S%g;E"",
        """""" A floating point property that controls the source voltage
        in Volts, if that mode is active. """"""
    )
    source_current = Instrument.control(
        ""OD;E"", ""S%g;E"",
        """""" A floating point property that controls the source current
        in Amps, if that mode is active. """"""
    )
    source_voltage_range = Instrument.control(
        ""OS;E"", ""R%d;E"",
        """""" A floating point property that sets the source voltage range
        in Volts, which can take values: 10 mV, 100 mV, 1 V, 10 V, and 30 V.
        Voltages are truncted to an appropriate value if needed. """""",
        validator=truncated_discrete_set,
        values={10e-3: 2, 100e-3: 3, 1: 4, 10: 5, 30: 6},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'R'))
    )
    source_current_range = Instrument.control(
        ""OS;E"", ""R%d;E"",
        """""" A floating point property that sets the current voltage range
        in Amps, which can take values: 1 mA, 10 mA, and 100 mA.
        Currents are truncted to an appropriate value if needed. """""",
        validator=truncated_discrete_set,
        values={1e-3: 4, 10e-3: 5, 100e-3: 6},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'R'))
    )
    source_mode = Instrument.control(
        ""OS;E"", ""F%d;E"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Yokogawa7651.apply_current` and :meth:`~.Yokogawa7651.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 5, 'voltage': 1},
        map_values=True,
        get_process=lambda v: int(Yokogawa7651._find(v, 'F'))
    )
    compliance_voltage = Instrument.control(
        ""OS;E"", ""LV%g;E"",
        """""" A floating point property that sets the compliance voltage
        in Volts, which can take values between 1 and 30 V. """""",
        validator=truncated_range,
        values=[1, 30],
        get_process=lambda v: int(Yokogawa7651._find(v, 'LV'))
    )
    compliance_current = Instrument.control(
        ""OS;E"", ""LA%g;E"",
        """""" A floating point property that sets the compliance current
        in Amps, which can take values from 5 to 120 mA. """""",
        validator=truncated_range,
        values=[5e-3, 120e-3],
        get_process=lambda v: float(Yokogawa7651._find(v, 'LA')) * 1e-3,  # converts A to mA
        set_process=lambda v: v * 1e3,  # converts mA to A
    )

    def __init__(self, adapter, name=""Yokogawa 7651 Programmable DC Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

        self.write(""H0;E"")  # Set no header in output data

    @property
    def id(self):
        """""" Returns the identification of the instrument """"""
        return self.ask(""OS;E"").split('\r\n\n')[0]

    @property
    def source_enabled(self):
        """""" Reads a boolean value that is True if the source is enabled,
        determined by checking if the 5th bit of the OC flag is a binary 1.
        """"""
        oc = int(self.ask(""OC;E"")[5:])
        return oc & 0b10000

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""O1;E"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""O0;E"")

    def apply_current(self, max_current=1e-3, compliance_voltage=1):
        """""" Configures the instrument to apply a source current, which can
        take optional parameters that defer to the :attr:`~.Yokogawa7651.source_current_range`
        and :attr:`~.Yokogawa7651.compliance_voltage` properties. """"""
        self.source_mode = 'current'
        self.source_current_range = max_current
        self.compliance_voltage = compliance_voltage

    def apply_voltage(self, max_voltage=1, compliance_current=10e-3):
        """""" Configures the instrument to apply a source voltage, which can
        take optional parameters that defer to the :attr:`~.Yokogawa7651.source_voltage_range`
        and :attr:`~.Yokogawa7651.compliance_current` properties. """"""
        self.source_mode = 'voltage'
        self.source_voltage_range = max_voltage
        self.compliance_current = compliance_current

    def ramp_to_current(self, current, steps=25, duration=0.5):
        """""" Ramps the current to a value in Amps by traversing a linear spacing
        of current steps over a duration, defined in seconds.

        :param steps: A number of linear steps to traverse
        :param duration: A time in seconds over which to ramp
        """"""
        start_current = self.source_current
        stop_current = current
        pause = duration / steps
        if (start_current != stop_current):
            currents = np.linspace(start_current, stop_current, steps)
            for current in currents:
                self.source_current = current
                sleep(pause)

    def ramp_to_voltage(self, voltage, steps=25, duration=0.5):
        """""" Ramps the voltage to a value in Volts by traversing a linear spacing
        of voltage steps over a duration, defined in seconds.

        :param steps: A number of linear steps to traverse
        :param duration: A time in seconds over which to ramp
        """"""
        start_voltage = self.source_voltage
        stop_voltage = voltage
        pause = duration / steps
        if (start_voltage != stop_voltage):
            voltages = np.linspace(start_voltage, stop_voltage, steps)
            for voltage in voltages:
                self.source_voltage = voltage
                sleep(pause)

    def shutdown(self):
        """""" Shuts down the instrument, and ramps the current or voltage to zero
        before disabling the source. """"""

        # Since voltage and current are set the same way, this
        # ramps either the current or voltage to zero
        self.ramp_to_current(0.0, steps=25)
        self.source_current = 0.0
        self.disable_source()
        super().shutdown()
"
25,19.0,USA,"Temptronic ATS-525 Thermostream -60° to +225°C
",ATS 525,588.0,"**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",Pymeasure,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/na4BsJwlkqnuz1GWqxCV8g/8wSkZbZICUx-sWQn0mySlDB9smvlFs1-SDNJBCEB7oYSXz0MCl_3jtc9OqrfTGYRk_xBEyzTaulvgg2MYz0jU0QjvIXLed4O7LRuPARqZLTuR1Q78RJg_NYRH2zNoWVf/C3xMCyDJFEaabeVi51UFlWAjoGOacMN2IIZ6m1TzJEo'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7LM1FMdjsBNqNDVMgxqZ7Q/d1YtGTAB2BOTlYx4v1Et8YBP5WMaRw81P-S_hyaQY0EWcZ4a8Q56MNU55u0X3ftLT9mL-Wi_Lt1jws1RSQu-wA/Y0r4Sg_aR6Q3yBZwwWGN9kqZtgYrXtYUAMCN5Hb7qwM'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Z_PgK_5CwclJGyIfTUx3A/4oiK1H_smeqwPEb8SfQGnbaoPj05nFJUqDLsmTnIYNm6JP5awVfpqHHL09x0sT862YBMeRbvjdRzNL2DonfSNQ/ARBzmImWLfvEtAjovr3AWxWG3RPMeSnG2vZcJa1XZT0'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QaO1zUTsPkXAzHmYqbUQxg/bOJHt3CC4PShuZ0yDuiTw9c68CGwNAhBzq1_5WE7Iz8_8TR_RPSil1-IcBKGG3_KQctxujlYPCdWQuFruWsPZQ/AdtFsIajUdOnVt0LVkN4IOIlu7AqpNshZTBk_YXgjbo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.",['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",,https://maximinstruments.com/pdf_files/TEMPTRONIC_ATS_525_Datasheet.pdf,"[OrderedDict([('id', 'attv44gopB7g3ibT9'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/i0FiGU0EyLaP-_0qv1jmpg/hn0-de8fausLNJFvXWLoCFIknaHqJIvt_D628p0H3A_W_h-w4wZy1qJoC7smj5Ke06yj-M2y7cutboYHNx0lXNM_e0moMq5CfG-MT_hm62M/TqV98P0anFWIf08W_RUM6OtOUOdRVUf_fMUIQuGFkNQ'), ('filename', 'image (1).jpeg'), ('size', 15626), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WByeUVVkGgppDjrrzCwzzQ/y9jO2VmPp1KNRgPe4lFpbCVs7hbB1rsmkKnF_zSO_DDoTmcTH51K7eCZxW8pjFSHolWgkFSsZq3Ce2BXXE7czA/Enjs5xiN4ihy9SCS7gLuKBPmA3P--6RYE-U_JeCPPpE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4WStAo7bS6kbiwNed8rU0Q/d0Hjhcl9gYzYpA3bzH5Fpt2YwaSKu3LGkfpH9acBksQSE9BrSBpBRxqn0_FiOV3YaPmrPWyntJsMUW9N7XbTOg/5ewqdTohOQ6IExArEFg5oL2IinbwQSqfVJf6FNa9NHg'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QALI2hNbvN32o1qgTChSfQ/O55as6OVLGpMFCnhMymFIGz-I97dYtwEfiAHthngNMF1NTc5-LnZhY_CbzYQOePQa3CxrewSnabOPONPfU_Xcg/JqLK9R21LJ9iEQPbI5OCv_LBTfTOnXuhJoS3Df-2MpM'), ('width', 3000), ('height', 3000)]))]))])]",https://maximinstruments.com/products/temptronic_ats_525_thermostream__60_to_225c,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_ats525.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_ats525.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ATS-515/615, ATS 525/625 & ATS 535/635 ThermoStream® Systems
Interface & Applications Manual
Revision E
September, 2019
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase
from pymeasure.instruments.instrument import Instrument


class ATS525(ATSBase):
    """"""Represent the TemptronicATS525 instruments.
    """"""

    temperature_limit_air_low_values = [-60, 25]

    system_current = Instrument.measurement(
        ""AMPS?"",
        """"""Operating current.
        """""",
    )

    def __init__(self, adapter, name=""Temptronic ATS-525 Thermostream"", **kwargs):
        super().__init__(adapter, name, **kwargs)
"
31,110.6,"Cleveland, Ohio, United States",,Buffer,251.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a {Device name} ,,,,,,,,,,,,,,
35,19.0,USA,"Temptronic ThermoStreams are portable systems that deliver clean dry air for precision temperature testing or conditioning of electronics (ICs, MEMS, transceivers, or circuits) and materials. No other systems can bring your test subjects to temperature faster with precise control",Ats_base,586.0,"**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",Pymeasure,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/na4BsJwlkqnuz1GWqxCV8g/8wSkZbZICUx-sWQn0mySlDB9smvlFs1-SDNJBCEB7oYSXz0MCl_3jtc9OqrfTGYRk_xBEyzTaulvgg2MYz0jU0QjvIXLed4O7LRuPARqZLTuR1Q78RJg_NYRH2zNoWVf/C3xMCyDJFEaabeVi51UFlWAjoGOacMN2IIZ6m1TzJEo'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7LM1FMdjsBNqNDVMgxqZ7Q/d1YtGTAB2BOTlYx4v1Et8YBP5WMaRw81P-S_hyaQY0EWcZ4a8Q56MNU55u0X3ftLT9mL-Wi_Lt1jws1RSQu-wA/Y0r4Sg_aR6Q3yBZwwWGN9kqZtgYrXtYUAMCN5Hb7qwM'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Z_PgK_5CwclJGyIfTUx3A/4oiK1H_smeqwPEb8SfQGnbaoPj05nFJUqDLsmTnIYNm6JP5awVfpqHHL09x0sT862YBMeRbvjdRzNL2DonfSNQ/ARBzmImWLfvEtAjovr3AWxWG3RPMeSnG2vZcJa1XZT0'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QaO1zUTsPkXAzHmYqbUQxg/bOJHt3CC4PShuZ0yDuiTw9c68CGwNAhBzq1_5WE7Iz8_8TR_RPSil1-IcBKGG3_KQctxujlYPCdWQuFruWsPZQ/AdtFsIajUdOnVt0LVkN4IOIlu7AqpNshZTBk_YXgjbo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,Write a Python script that uses Pymeasure to connect to a Thermostream ATS Series Temperature Controllers,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.",['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",Thermostream ATS Series,https://www.intestthermal.com/temptronic/brochure-request?brochure_title=ATS-605%20THERMOSTREAM%C2%AE%20DATASHEET%20AND%20SPECIFICATIONS&brand_interest=Temptronic&brand_sub_folder=temptronic&file_name=TemperatureForcing_ATS605.pdf&product=ThermoStream&hsLang=en,"[OrderedDict([('id', 'attyo4eqCkUStqLEV'), ('width', 250), ('height', 537), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eDfgBlyIcpnNBE4oFedewg/kppZt856sVRTB5ayMDX8XqiPhwhPnWOTOv1oRfhBlejAX7RBQyhKl7jGFO3udGXNt2yrXXHU8O1ht0J6P1FjmAd_qC1SQhux1OK1bP0ZQ9FHPeBLQAlkrJQz-JLAV-Lp/CUDTI2cQCtp3Kq227LIP23F9aPjwT67La2ELLWoj9UE'), ('filename', 'ThermoStream-ATS-710-250.webp'), ('size', 11590), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r-GFHKTHN24btzs2w2DnIA/cYIMEMN6Ae7a_5qgwhM5pBuFgk1Czn_YGHFG8L95BnDrtDCggaKUD419D-6BI7-Nlkcy6Ff_gFEbyu-wMUtgHDFbNAoBhIR373_IHO1K43Y/LlhX6STaQArJiEvmwbT_0s0lnRSHgsiC5tM7c3LyBP0'), ('width', 17), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1GBiyO6Mz44NNlYl2kHU-g/u7mNploQra4DsvpliDpfJuRB0evnvawtIAA_OO6qwZFwYaZz3Gl-5JdT4hI2PRibGBqhwMuyPZNUTyi0OUr4ynLJqYvk4UAJ1EdSkAIpnfs/5J7FUQ5JcVmCXG1VIqIc8BMFzkQwWpDJ-GM3KtE5zlU'), ('width', 250), ('height', 537)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2oOTbhs1s-cSUSmgd3hcwQ/sWEIDX9nwv2Gbxbw0-ylOO0XpXPAffpCMMFxme90S2PoZoaZyuHptYa68CXuthU5pWgeLdf7naje3E4eEPj7SwGwFJ_aC95n8QbFCxxTR8Y/edBbMXNewpCwauStNgxZlkHpfKbSH1Q4e4JzfGcQXFQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic/thermostream,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_base.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_base.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""Implementation of an interface driver for ThermoStream® (TS) Systems devices.

# Reference Document for implementation:
ATS-515/615, ATS 525/625 & ATS 535/635 ThermoStream® Systems
Interface & Applications Manual
Revision E
September, 2019

# Safety hints
In case of script error, make sure thermostream will be shut down.
This can be established by e.g. means of try, finally statements.
Another way is by polling ``error_code`` integer status flags.
No automatic safety measures are part of this driver implementation.

""""""
import logging
import time
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              truncated_range,
                                              strict_range
                                              )

from enum import IntFlag

log = logging.getLogger(__name__)  # https://docs.python.org/3/howto/logging.html#library-config
log.addHandler(logging.NullHandler())


class TemperatureStatusCode(IntFlag):
    """"""Temperature status enums based on ``IntFlag``

    Used in conjunction with :attr:`~.temperature_condition_status_code`.

        ======  ======
        Value   Enum
        ======  ======
        32      CYCLING_STOPPED
        16      END_OF_ALL_CYCLES
        8       END_OF_ONE_CYCLE
        4       END_OF_TEST
        2       NOT_AT_TEMPERATURE
        1       AT_TEMPERATURE
        0       NO_STATUS
        ======  ======

    """"""

    CYCLING_STOPPED = 32  # bit 5 -- cycling stopped(""stop on fail"" signal was received)
    END_OF_ALL_CYCLES = 16  # bit 4 -- end of all cycles
    END_OF_ONE_CYCLE = 8   # bit 3 -- end of one cycle
    END_OF_TEST = 4   # bit 2 -- end of test (test time has elapsed)
    NOT_AT_TEMPERATURE = 2   # bit 1 -- not at temperature
    AT_TEMPERATURE = 1   # bit 0 -- at temperature (soak time has elapsed)
    NO_STATUS = 0   # bit 0 -- no temperature status indication


class ErrorCode(IntFlag):
    """"""Error code enums based on ``IntFlag``.

    Used in conjunction with :attr:`~.error_code`.

        ======  ======
        Value   Enum
        ======  ======
        16384   NO_DUT_SENSOR_SELECTED
        4096    BVRAM_FAULT
        2048    NVRAM_FAULT
        1024    NO_LINE_SENSE
        512     FLOW_SENSOR_HARDWARE_ERROR
        128     INTERNAL_ERROR
        32      AIR_SENSOR_OPEN
        16      LOW_INPUT_AIR_PRESSURE
        8       LOW_FLOW
        2       AIR_OPEN_LOOP
        1       OVERHEAT
        0       OK
        ======  ======

    """"""
    # bit 15 – reserved
    NO_DUT_SENSOR_SELECTED = 16384  # bit 14 – no DUT sensor selected
    # bit 13 – reserved
    BVRAM_FAULT = 4096   # bit 12 – BVRAM fault
    NVRAM_FAULT = 2048   # bit 11 – NVRAM fault
    NO_LINE_SENSE = 1024   # bit 10 – No Line Sense
    FLOW_SENSOR_HARDWARE_ERROR = 512    # bit 9  – flow sensor hardware error
    # bit 8  – reserved
    INTERNAL_ERROR = 128    # bit 7  – internal error
    # bit 6  – reserved
    AIR_SENSOR_OPEN = 32     # bit 5  – air sensor open
    LOW_INPUT_AIR_PRESSURE = 16     # bit 4  – low input air pressure
    LOW_FLOW = 8      # bit 3  – low flow
    # bit 2  – reserved
    AIR_OPEN_LOOP = 2      # bit 1  – air open loop
    OVERHEAT = 1      # bit 0  – overheat
    OK = 0  # ok state


class ATSBase(Instrument):
    """"""The base class for Temptronic ATSXXX instruments.
    """"""

    remote_mode = Instrument.setting(
        ""%s"",
        """"""``True`` disables TS GUI but displays a “Return to local"" switch."""""",
        validator=strict_discrete_set,
        values={True: ""%RM"", False: r""%GL""},
        map_values=True
    )

    maximum_test_time = Instrument.control(
        ""TTIM?"", ""TTIM %g"",
        """"""Control maximum allowed test time (s).

        :type: float

        This prevents TS from staying at a single temperature forever.
        Valid range: 0 to 9999
        """""",
        validator=truncated_range,
        values=[0, 9999]
    )

    dut_mode = Instrument.control(
        ""DUTM?"", ""DUTM %g"",
        """""" ``On`` enables DUT mode, ``OFF`` enables air mode

        :type: string

        """""",
        validator=strict_discrete_set,
        values={'ON': 1, 'OFF': 0},
        map_values=True
    )

    dut_type = Instrument.control(
        ""DSNS?"", ""DSNS %g"",
        """"""Control DUT sensor type.

        :type: string

        Possible values are:

        ======  ======
        String  Meaning
        ======  ======
        ''      no DUT
        'T'     T-DUT
        'K'     K-DUT
        ======  ======

        Warning: If in DUT mode without DUT being connected, TS flags DUT error

        """""",
        validator=strict_discrete_set,
        values={None: 0, 'T': 1, 'K': 2},
        map_values=True
    )

    dut_constant = Instrument.control(
        ""DUTC?"", ""DUTC %g"",
        """"""Control thermal constant (default 100) of DUT.

        :type: float

        Lower values indicate lower thermal mass, higher values indicate higher
        thermal mass respectively.
        """""",
        validator=truncated_range,
        values=[20, 500]
    )

    head = Instrument.control(
        ""HEAD?"", ""HEAD %s"",
        """"""Control TS head position.

        :type: string

        ``down``: transfer head to lower position
        ``up``:   transfer head to elevated position
        """""",
        validator=strict_discrete_set,
        values={'up': 0, 'down': 1},
        map_values=True
    )

    enable_air_flow = Instrument.setting(
        ""FLOW %g"",
        """"""Set TS air flow.

        ``True`` enables air flow, ``False`` disables it

        :type: bool

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    temperature_limit_air_low = Instrument.control(
        ""LLIM?"", ""LLIM %g"",
        """"""Control lower air temperature limit.

        :type: float

        Valid range between -99 to 25 (°C). Setpoints below current value cause
        “out of range” error in TS.
        """""",
        validator=truncated_range,
        values=[-99, 25],
        dynamic=True
    )

    temperature_limit_air_high = Instrument.control(
        ""ULIM?"", ""ULIM %g"",
        """"""upper air temperature limit.

        :type: float

        Valid range between 25 to 255 (°C). Setpoints above current value cause
        “out of range” error in TS.
        """""",
        validator=truncated_range,
        values=[25, 225]
    )

    temperature_limit_air_dut = Instrument.control(
        ""ADMD?"", ""ADMD %g"",
        """"""Air to DUT temperature limit.

        :type: float

        Allowed difference between nozzle air and DUT temperature during
        settling. Valid range between 10 to 300 °C in 1 degree increments.
        """""",
        validator=truncated_range,
        values=[10, 300]
    )

    temperature_setpoint = Instrument.control(
        ""SETP?"", ""SETP %g"",
        """"""Set or get selected setpoint's temperature.

        :type: float

        Valid range is -99.9 to 225.0 (°C) or as indicated by
        :attr:`~.temperature_limit_air_high`
        and :attr:`~.temperature_limit_air_low`.
        Use convenience function :meth:`~ATSBase.set_temperature`
        to prevent unexpected behavior.
        """""",
        validator=truncated_range,
        values=[-99.9, 225]
    )

    temperature_setpoint_window = Instrument.control(
        ""WNDW?"", ""WNDW %g"",
        """"""Setpoint's temperature window.

        :type: float

        Valid range is between 0.1 to 9.9 (°C). Temperature status register
        flags ``at temperature`` in case soak time elapsed while temperature
        stays in between bounds given by this value around the current setpoint.
        """""",
        validator=truncated_range,
        values=[0.1, 9.9]
    )

    temperature_soak_time = Instrument.control(
        ""SOAK?"", ""SOAK %g"",
        """"""
        Set the soak time for the currently selected setpoint.

        :type: float

        Valid range is between  0 to 9999 (s). Lower values shorten cycle times.
        Higher values increase cycle times, but may reduce settling errors.
        See :attr:`~.temperature_setpoint_window` for further information.
        """""",
        validator=truncated_range,
        values=[0.0, 9999]
    )

    temperature = Instrument.measurement(
        ""TEMP?"",
        """"""Read current temperature with 0.1 °C resolution.

        :type: float

        Temperature readings origin depends on :attr:`dut_mode` setting.
        Reading higher than 400 (°C) indicates invalidity.
        """"""
    )

    temperature_condition_status_code = Instrument.measurement(
        ""TECR?"",
        """"""Temperature condition status register.

        :type: :class:`.TemperatureStatusCode`
        """""",
        values=[0, 255],
        get_process=lambda v: TemperatureStatusCode(int(v)),
    )

    set_point_number = Instrument.control(
        ""SETN?"", ""SETN %g"",
        """"""Select a setpoint to be the current setpoint.

        :type: int

        Valid range is 0 to 17 when on the Cycle screen or
        or 0 to 2 in case of operator screen (0=hot, 1=ambient, 2=cold).
        """""",
        validator=truncated_range,
        values=[0, 17]
    )

    local_lockout = Instrument.setting(
        ""%s"",
        """"""``True`` disables TS GUI, ``False`` enables it.
        """""",
        validator=strict_discrete_set,
        values={True: r""%LL"", False: r""%GL""},
        map_values=True
    )

    auxiliary_condition_code = Instrument.measurement(
        ""AUXC?"",
        """"""Read out auxiliary condition status register.

        :type: int

        Relevant flags are:

        ======  ======
        Bit     Meaning
        ======  ======
        10      None
         9      Ramp mode
         8      Mode: 0 programming, 1 manual
         7      None
         6      TS status: 0 start-up, 1 ready
         5      Flow: 0 off, 1 on
         4      Sense mode: 0 air, 1 DUT
         3      Compressor: 0 on, 1 off (heating possible)
         2      Head: 0 lower, upper
         1      None
         0      None
        ======  ======

        Refere to chapter 4 in the manual

        """""",
    )

    copy_active_setup_file = Instrument.setting(
        ""CFIL %g"",
        """"""Copy active setup file (0) to setup n (1 - 12).

        :type: int
        """""",
        validator=strict_range,
        values=[1, 12]
    )

    compressor_enable = Instrument.setting(
        ""COOL %g"",
        """""" ``True`` enables compressors, ``False`` disables it.

        :type: Boolean

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    total_cycle_count = Instrument.control(
        ""CYCC?"", ""CYCC %g"",
        """"""Set or read current cycle count (1 - 9999).

        :type: int

        Sending 0 will stop cycling

        """""",
        validator=truncated_range,
        values=[0, 9999]
    )

    cycling_enable = Instrument.setting(
        ""CYCL %g"",
        """"""CYCL Start/stop cycling.

        :type: bool

        cycling_enable = True  (start cycling)
        cycling_enable = False (stop cycling)
        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    current_cycle_count = Instrument.measurement(
        ""CYCL?"",
        """"""Read the number of cycles to do

        :type: int

        """""",
    )

    error_code = Instrument.measurement(
        ""EROR?"",  # it is indeed EROR
        """"""Read the device-specific error register (16 bits).

        :type: :class:`ErrorCode`
        """""",
        get_process=lambda v: ErrorCode(int(v)),
    )

    nozzle_air_flow_rate = Instrument.measurement(
        ""FLWR?"",
        """"""Read main nozzle air flow rate in scfm.
        """"""
    )

    main_air_flow_rate = Instrument.measurement(
        ""FLRL?"",
        """"""Read main nozzle air flow rate in liters/sec.
        """"""
    )

    learn_mode = Instrument.control(
        ""LRNM?"", ""LRNM %g"",
        """"""Control DUT automatic tuning (learning).

        :type: bool
            ``False``: off
            ``True``:  automatic tuning on

        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    ramp_rate = Instrument.control(
        ""RAMP?"", ""RAMP %g"",
        """"""Control ramp rate (K / min).

        :type: float

        allowed values:
        nn.n: 0 to 99.9 in 0.1 K per minute steps.
        nnnn: 100 to 9999 in 1 K per minute steps.
        """""",
        validator=strict_discrete_set,
        values={i/10 for i in range(1000)} | {i for i in range(100, 10000)}
    )

    dynamic_temperature_setpoint = Instrument.measurement(
        ""SETD?"",
        """"""Read the dynamic temperature setpoint.

        :type: float
        """"""
    )

    load_setup_file = Instrument.setting(
        ""SFIL %g"",
        """"""loads setup file SFIL.

        Valid range is between 1 to 12.

        :type: int
        """""",
        validator=strict_range,
        values=[1, 12]
    )

    temperature_event_status = Instrument.measurement(
        ""TESR?"",
        """""" temperature event status register.

        :type: :class:`.TemperatureStatusCode`

        Hint: Reading will clear register content.

        """""",
    )

    air_temperature = Instrument.measurement(
        ""TMPA?"",
        """"""Read air temperature in 0.1 °C increments.

        :type: float
        """"""
    )

    dut_temperature = Instrument.measurement(
        ""TMPD?"",
        """"""Read DUT temperature, in 0.1 °C increments.

        :type: float

        """"""
    )

    mode = Instrument.measurement(
        ""WHAT?"",
        """"""Returns a string indicating what the system is doing at the time the query is processed.

        :type: string

        """""",
        values={'manual': 5,
                'program': 6,
                },
        map_values=True,
        dynamic=True
    )

    def __init__(self, adapter, name=""ATSBase"", **kwargs):
        super().__init__(adapter, name=name, query_delay=0.05, **kwargs)

    def reset(self):
        """"""Reset (force) the System to the Operator screen.

        :returns: self

        """"""
        self.write(""RSTO"")

        return self

    def enter_cycle(self):
        """"""Enter Cycle by sending ``RMPC 1``.

        :returns: self

        """"""
        self.write(""RMPC 1"")

        return self

    def enter_ramp(self):
        """"""Enter Ramp by sending ``RMPS 0``.

        :returns: self
        """"""
        self.write(""RMPS 0"")

        return self

    def clear(self):
        """"""Clear device-specific errors.

        See :attr:`~.error_code` for further information.
        """"""
        self.write(""CLER"")

        return self

    def next_setpoint(self):
        """"""Step to the next setpoint during temperature cycling.
        """"""
        self.write(""NEXT"")

    def configure(self,
                  temp_window=1,
                  dut_type='T',
                  soak_time=30,
                  dut_constant=100,
                  temp_limit_air_low=-60,
                  temp_limit_air_high=220,
                  temp_limit_air_dut=50,
                  maximum_test_time=1000
                  ):
        """"""Convenience method for most relevant configuration properties.

        :param dut_type:
            string: indicating which DUT type to use
        :param soak_time:
            float: elapsed time in soak_window before settling is indicated
        :param soak_window:
            float: Soak window size or temperature settlings bounds (K)
        :param dut_constant:
            float: time constant of DUT, higher values indicate higher thermal mass
        :param temp_limit_air_low:
            float: minimum flow temperature limit (°C)
        :param temp_limit_air_high:
            float: maximum flow temperature limit (°C)
        :param temp_limit_air_dut:
            float: allowed temperature difference (K) between DUT and Flow
        :param maximum_test_time:
            float: maximum test time (seconds) for a single temperature point (safety)

        :returns: self
        """"""

        self.temperature_setpoint_window = temp_window

        self.temperature_limit_air_low = temp_limit_air_low

        self.temperature_limit_air_high = temp_limit_air_high

        self.dut_type = dut_type

        self.maximum_test_time = maximum_test_time

        if dut_type is None:
            self.dut_mode = 'OFF'
        else:
            self.dut_constant = dut_constant
            self.dut_mode = 'ON'

        self.temperature_limit_air_dut = temp_limit_air_dut

        self.temperature_soak_time = soak_time

        # logging:

        wd = self.temperature_setpoint_window

        airflwlimlow = self.temperature_limit_air_low

        airflwlimhigh = self.temperature_limit_air_high

        dut = self.dut_type

        tst_time = self.maximum_test_time

        airdutlim = self.temperature_limit_air_dut

        sktime = self.temperature_soak_time

        message = (
            ""Configuring TS finished, reading back:\n""
            f""DUT type: {dut}\n""
            f""Temperature Window: {wd} K\n""
            f""Maximum test time: {tst_time} s\n""
            f""Air flow temperature limit low: {airflwlimlow:.1f} K\n""
            f""Air flow temperature limit high: {airflwlimhigh:.1f} K\n""
            f""Air to DUT temperature limit: {airdutlim} degC\n""
            f""Soak time {sktime} s\n""
        )

        log.info(message)

        return self

    def set_temperature(self, set_temp):
        """"""sweep to a specified setpoint.

        :param set_temp:
            target temperature for DUT (float)

        :returns: self
        """"""
        if self.mode == 'manual':
            message = f""new set point temperature: {set_temp:.1f} Deg""
            log.info(message)

            if set_temp <= 20:
                self.set_point_number = 2  # cold
            elif set_temp < 30:
                self.set_point_number = 1  # ambient
            elif set_temp >= 30:
                self.set_point_number = 0  # hot
            else:
                raise ValueError(f""Temperature {set_temp} is impossible to set!"")

        self.temperature_setpoint = set_temp  # fixed typo in attr name

        return self

    def wait_for_settling(self, time_limit=300):
        """"""block script execution until TS is settled.

        :param time_limit:
            set the maximum blocking time within TS has to settle (float).

        :returns: self

        Script execution is blocked until either TS has settled
        or time_limit has been exceeded (float).
        """"""

        time.sleep(1)
        t = 0
        t_start = time.time()
        while not self.at_temperature():  # assert at temperature
            time.sleep(1)
            t = time.time() - t_start

            tstatus = self.temperature_condition_status_code

            message = (""temp_set= %4.1f deg, ""
                       ""temp= %4.1f deg, ""
                       ""time= %.2f s, ""
                       ""status= %s""
                       )

            log.info(message,
                     self.temperature_setpoint,
                     self.temperature,
                     t,
                     tstatus)

            if t > time_limit:
                log.info('no settling achieved')
                break
        log.info('finished this temperature point')

        return self

    def shutdown(self, head=False):
        """"""Turn down TS (flow and remote operation).

        :param head: Lift head if ``True``

        :returns: self
        """"""

        self.enable_air_flow = 0
        self.remote_mode = False
        if head:
            self.head = 'up'
        super().shutdown()

        return self

    def start(self, enable_air_flow=True):
        """"""start TS in remote mode.

        :param enable_air_flow: flow starts if ``True``

        :returns: self
        """"""

        self.remote_mode = 1
        self.enable_air_flow = enable_air_flow  # enable TS

        return self

    def error_status(self):
        """"""Returns error status code (maybe used for logging).

        :returns: :class:`ErrorCode`
        """"""
        code = self.error_code
        if not code == 0:
            log.warning('%s', code)
        return code

    def cycling_stopped(self):
        """""":returns: ``True`` if cycling has stopped.
        """"""
        return TemperatureStatusCode.CYCLING_STOPPED in self.temperature_condition_status_code

    def end_of_all_cycles(self):
        """""":returns: ``True`` if cycling has stopped.
        """"""
        return TemperatureStatusCode.END_OF_ALL_CYCLES in self.temperature_condition_status_code

    def end_of_one_cycle(self):
        """""":returns: ``True`` if TS is at end of one cycle.
        """"""
        return TemperatureStatusCode.END_OF_ONE_CYCLE in self.temperature_condition_status_code

    def end_of_test(self):
        """""":returns: ``True`` if TS is at end of test.
        """"""
        return TemperatureStatusCode.END_OF_TEST in self.temperature_condition_status_code

    def not_at_temperature(self):
        """""":returns: ``True`` if not at temperature.
        """"""
        return TemperatureStatusCode.NOT_AT_TEMPERATURE in self.temperature_condition_status_code

    def at_temperature(self):
        """""":returns: ``True`` if at temperature.
        """"""
        return TemperatureStatusCode.AT_TEMPERATURE in self.temperature_condition_status_code
"
36,5420.0,USA,"E4408B ESA-L Basic Spectrum Analyzer, 9 kHz to 26.5 GHz",Agilent 4408 B,5.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT - E4408B ESA-L Spectrum Analyzers,https://www.keysight.com/us/en/products/spectrum-analyzers-signal-analyzers.html,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals.,KEYSIGHT - E4408B ESA-L,https://www.keysight.com/us/en/assets/9018-03334/technical-specifications/9018-03334.pdf,"[OrderedDict([('id', 'attOfX0N01dkZoP6V'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHwJvTCZwzJ4mu4GbztM7Q/PD9MNB77529cQBI9IzYjTgjmdDDTB5kjCSlkMwvI_2_4aXxJWMqo1C4SMldTG4YErwOoeCIB6SYoLxZWBsmLNxEdkZuKW8sEwiI-8oSQ3JE/OWysc0vcKVYoEczz12G029oFcC6iYjxY8uNluXDFCU0'), ('filename', 'E4408B.webp'), ('size', 15404), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/s8tzod-P_eh6aIkDCQMqcA/jxGFbJo92-QgcD_rPj26uSAb_HG0QfgHgFTWfvDPZD-7rkNYBPDFPOBm-xJ3YWZu1JacdGKYoVEyJzu07V8q2ozzBYsnlovcqGt5_stYvrU/oQBXd_2AzPHvl22X_bvi2qsxKBms2GFTovjzYDNHQMU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/c7fmKEohd8DSBcxFoAjlDA/hAuweMfrDcWGZpaqH-x2Pp4KoXlr2XalWeFa_RxbkdnA3dtA0GI5tswNYaxe2bTrhW6Rhv47iwWUWC41Mmk_1qH2MMgsxlkY_RelqOOdxpY/tYftFwPpXeRy7VDsNFh2tqbMBvXx5iVgzkD6MvSPkxg'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eGr3G-nOPD97kd-0Ar98pQ/IT8vJkkFBU9635Lz148He8rNEzzciHhB5MhMLxucqWQZcg8VCcLy7EwT_ESYNsBjQs8xrF-vKMHf_yQZQ-Eidz7ASbIIkENH8ZRk2s3V9D8/-YHwWMMG1EBHG4xl7bpDkzspNsXiB-Etxh2dGrAIS1I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E4408B/esa-l-basic-spectrum-analyzer-9khz-26-5ghz.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilentE4408B.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentE4408B.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

from io import StringIO
import numpy as np
import pandas as pd


class AgilentE4408B(Instrument):
    """""" Represents the AgilentE4408B Spectrum Analyzer
    and provides a high-level interface for taking scans of
    high-frequency spectrums
    """"""

    start_frequency = Instrument.control(
        "":SENS:FREQ:STAR?;"", "":SENS:FREQ:STAR %e Hz;"",
        """""" A floating point property that represents the start frequency
        in Hz. This property can be set.
        """"""
    )
    stop_frequency = Instrument.control(
        "":SENS:FREQ:STOP?;"", "":SENS:FREQ:STOP %e Hz;"",
        """""" A floating point property that represents the stop frequency
        in Hz. This property can be set.
        """"""
    )
    frequency_points = Instrument.control(
        "":SENSe:SWEEp:POINts?;"", "":SENSe:SWEEp:POINts %d;"",
        """""" An integer property that represents the number of frequency
        points in the sweep. This property can take values from 101 to 8192.
        """""",
        validator=truncated_range,
        values=[101, 8192],
        cast=int
    )
    frequency_step = Instrument.control(
        "":SENS:FREQ:CENT:STEP:INCR?;"", "":SENS:FREQ:CENT:STEP:INCR %g Hz;"",
        """""" A floating point property that represents the frequency step
        in Hz. This property can be set.
        """"""
    )
    center_frequency = Instrument.control(
        "":SENS:FREQ:CENT?;"", "":SENS:FREQ:CENT %e Hz;"",
        """""" A floating point property that represents the center frequency
        in Hz. This property can be set.
        """"""
    )
    sweep_time = Instrument.control(
        "":SENS:SWE:TIME?;"", "":SENS:SWE:TIME %.2e;"",
        """""" A floating point property that represents the sweep time
        in seconds. This property can be set.
        """"""
    )

    def __init__(self, adapter, name=""Agilent E4408B Spectrum Analyzer"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    @property
    def frequencies(self):
        """""" Returns a numpy array of frequencies in Hz that
        correspond to the current settings of the instrument.
        """"""
        return np.linspace(
            self.start_frequency,
            self.stop_frequency,
            self.frequency_points,
            dtype=np.float64
        )

    def trace(self, number=1):
        """""" Returns a numpy array of the data for a particular trace
        based on the trace number (1, 2, or 3).
        """"""
        self.write("":FORMat:TRACe:DATA ASCII;"")
        data = np.loadtxt(
            StringIO(self.ask("":TRACE:DATA? TRACE%d;"" % number)),
            delimiter=',',
            dtype=np.float64
        )
        return data

    def trace_df(self, number=1):
        """""" Returns a pandas DataFrame containing the frequency
        and peak data for a particular trace, based on the
        trace number (1, 2, or 3).
        """"""
        return pd.DataFrame({
            'Frequency (GHz)': self.frequencies * 1e-9,
            'Peak (dB)': self.trace(number)
        })
"
43,367.3,"Abingdon, United Kingdom","Oxford Intelligent Temperature Controller ITC 502. Oxford Instruments ITC502 Intelligent Temperature Controller (Model 611-968) is a three term controller. It has the capability of monitoring up to three thermometers at the same time, and supplying heat to control the temperature of one part of the cryostat. The sensor interface can be configured to suit a wide range of thermometers (typically within the temperature range of 0.25 to 500 K).",ITC 503,404.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Pymeasure,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ITC503.pdf,"[OrderedDict([('id', 'attrty3FFFzJUtuMr'), ('width', 1600), ('height', 1200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RH3YRUSS9ERKB8q-jM70aQ/qdNMc_mch5YZQ4h02mTEBgGaw6E81uSvan8vTptJXgIbCKJwhsoF8NrkLBYj4Wmun2sy6MP0OioOfJOGpaxiK8j_wnkT9pSvBAskdmtFyng/IENsL28l3pancpHu_l1atefBNH5C9XCnUu-dzLU7EAE'), ('filename', 's-l1600.jpg'), ('size', 266225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GW89RwgwO4pvasVvfcf5Tg/2FgsDvXMJ9jsbLNsqeY5pC-M4MaKMHplsqmyn5WkEzo6TeevaiH6O6Gq08yqQ_R367tG_aW8Vv5jrG855zY34g/6G1UKUqTtQrjoqtXWvKMmMWOdPioPNTa0-ffh16u74U'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bDnIMvdXj3XkU8eawHAxZQ/6IRsy_lzyBdtznDuD708zr-hvWhqp0FCBWUihAxKb0LZHCLGY9y7pfHm0JuUKTsley79QMBoovDnuTQBEuPl8Q/jZHsIJKMxbK37KV6tIcQYdUvPtp4KKW-RUeL2fHSv3Y'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PBo8E1H8YsHxrFvWdJb1LQ/rsn_O1SZ5J4CHu9uErNvVQdV22KI_4gFRnmQZUoxUSmtimRRYGXLeOD0qRVUyq0zEbko5T0dTRD56BJBfvamvQ/8e3O9oHD1FCA4aL7-qeaQmWxfrPWV16VP8KR6aHN1tg'), ('width', 3000), ('height', 3000)]))]))])]",https://picclick.com/Oxford-Intelligent-Temperature-Controller-ITC-502-132299188022.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/oxfordinstruments/itc503.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/oxfordinstruments/ITC503.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging
from time import sleep, time
import numpy
from enum import IntFlag

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_range, strict_range

from .base import OxfordInstrumentsBase


# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def pointer_validator(value, values):
    """""" Provides a validator function that ensures the passed value is
    a tuple or a list with a length of 2 and passes every item through
    the strict_range validator.

    :param value: A value to test
    :param values: A range of values (passed to strict_range)
    :raises: TypeError if the value is not a tuple or a list
    :raises: IndexError if the value is not of length 2
    """"""

    if not isinstance(value, (list, tuple)):
        raise TypeError('{:g} is not a list or tuple'.format(value))
    if not len(value) == 2:
        raise IndexError('{:g} is not of length 2'.format(value))
    return tuple(strict_range(v, values) for v in value)


class ITC503(OxfordInstrumentsBase):
    """"""Represents the Oxford Intelligent Temperature Controller 503.

    .. code-block:: python

        itc = ITC503(""GPIB::24"")        # Default channel for the ITC503

        itc.control_mode = ""RU""         # Set the control mode to remote
        itc.heater_gas_mode = ""AUTO""    # Turn on auto heater and flow
        itc.auto_pid = True             # Turn on auto-pid

        print(itc.temperature_setpoint) # Print the current set-point
        itc.temperature_setpoint = 300  # Change the set-point to 300 K
        itc.wait_for_temperature()      # Wait for the temperature to stabilize
        print(itc.temperature_1)        # Print the temperature at sensor 1

    """"""

    def __init__(self,
                 adapter,
                 name=""Oxford ITC503"",
                 clear_buffer=True,
                 min_temperature=0,
                 max_temperature=1677.7,
                 **kwargs):

        super().__init__(
            adapter=adapter,
            name=name,
            **kwargs,
        )

        # Clear the buffer in order to prevent communication problems
        if clear_buffer:
            self.adapter.connection.clear()

        self.temperature_setpoint_values = [min_temperature, max_temperature]

    class FLOW_CONTROL_STATUS(IntFlag):
        """""" IntFlag class for decoding the flow control status. Contains the following
        flags:

        === ======================  ==============================================
        bit flag                    meaning
        === ======================  ==============================================
        4   HEATER_ERROR_SIGN       Sign of heater-error; True means negative
        3   TEMPERATURE_ERROR_SIGN  Sign of temperature-error; True means negative
        2   SLOW_VALVE_ACTION       Slow valve action occurring
        1   COOLDOWN_TERMINATION    Cooldown-termination occurring
        0   FAST_COOLDOWN           Fast-cooldown occurring
        === ======================  ==============================================

        """"""
        HEATER_ERROR_SIGN = 16
        TEMPERATURE_ERROR_SIGN = 8
        SLOW_VALVE_ACTION = 4
        COOLDOWN_TERMINATION = 2
        FAST_COOLDOWN = 1

    version = Instrument.measurement(
        ""V"",
        """""" A string property that returns the version of the IPS. """""",
        preprocess_reply=lambda v: v,
    )

    control_mode = Instrument.control(
        ""X"", ""C%d"",
        """""" A string property that sets the ITC in `local` or `remote` and `locked`
        or `unlocked`, locking the LOC/REM button. Allowed values are:

        =====   =================
        value   state
        =====   =================
        LL      local & locked
        RL      remote & locked
        LU      local & unlocked
        RU      remote & unlocked
        =====   =================
        """""",
        preprocess_reply=lambda v: v[5:6],
        cast=int,
        validator=strict_discrete_set,
        values={""LL"": 0, ""RL"": 1, ""LU"": 2, ""RU"": 3},
        map_values=True,
    )

    heater_gas_mode = Instrument.control(
        ""X"", ""A%d"",
        """""" A string property that sets the heater and gas flow control to
        `auto` or `manual`. Allowed values are:

        ======   =======================
        value    state
        ======   =======================
        MANUAL   heater & gas manual
        AM       heater auto, gas manual
        MA       heater manual, gas auto
        AUTO     heater & gas auto
        ======   =======================
        """""",
        preprocess_reply=lambda v: v[3:4],
        cast=int,
        validator=strict_discrete_set,
        values={""MANUAL"": 0, ""AM"": 1, ""MA"": 2, ""AUTO"": 3},
        map_values=True,
    )

    heater = Instrument.control(
        ""R5"", ""O%f"",
        """""" A floating point property that represents the heater output power
        as a percentage of the maximum voltage. Can be set if the heater is in
        manual mode. Valid values are in range 0 [off] to 99.9 [%]. """""",
        validator=truncated_range,
        values=[0, 99.9]
    )

    heater_voltage = Instrument.measurement(
        ""R6"",
        """""" A floating point property that represents the heater output power
        in volts. For controlling the heater, use the :class:`ITC503.heater`
        property. """""",
    )

    gasflow = Instrument.control(
        ""R7"", ""G%f"",
        """""" A floating point property that controls gas flow when in manual
        mode. The value is expressed as a percentage of the maximum gas flow.
        Valid values are in range 0 [off] to 99.9 [%]. """""",
        validator=truncated_range,
        values=[0, 99.9]
    )

    proportional_band = Instrument.control(
        ""R8"", ""P%f"",
        """""" A floating point property that controls the proportional band
        for the PID controller in Kelvin. Can be set if the PID controller
        is in manual mode. Valid values are 0 [K] to 1677.7 [K]. """""",
        validator=truncated_range,
        values=[0, 1677.7]
    )

    integral_action_time = Instrument.control(
        ""R9"", ""I%f"",
        """""" A floating point property that controls the integral action time
        for the PID controller in minutes. Can be set if the PID controller
        is in manual mode. Valid values are 0 [min.] to 140 [min.]. """""",
        validator=truncated_range,
        values=[0, 140]
    )

    derivative_action_time = Instrument.control(
        ""R10"", ""D%f"",
        """""" A floating point property that controls the derivative action time
        for the PID controller in minutes. Can be set if the PID controller
        is in manual mode. Valid values are 0 [min.] to 273 [min.]. """""",
        validator=truncated_range,
        values=[0, 273]
    )

    auto_pid = Instrument.control(
        ""X"", ""L%d"",
        """""" A boolean property that sets the Auto-PID mode on (True) or off (False).
        """""",
        preprocess_reply=lambda v: v[12:13],
        cast=int,
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    sweep_status = Instrument.control(
        ""X"", ""S%d"",
        """""" An integer property that sets the sweep status. Values are:

        =========   =========================================
        value       meaning
        =========   =========================================
        0           Sweep not running
        1           Start sweep / sweeping to first set-point
        2P - 1      Sweeping to set-point P
        2P          Holding at set-point P
        =========   =========================================
        """""",
        preprocess_reply=lambda v: v[7:9],
        cast=int,
        validator=strict_range,
        values=[0, 32]
    )

    temperature_setpoint = Instrument.control(
        ""R0"", ""T%f"",
        """""" A floating point property that controls the temperature set-point of
        the ITC in kelvin. """""",
        validator=truncated_range,
        values=[0, 1677.7],  # Kelvin, 0 - 1677.7K is the maximum range of the instrument
        dynamic=True,
    )

    temperature_1 = Instrument.measurement(
        ""R1"",
        """""" Reads the temperature of the sensor 1 in Kelvin. """""",
    )

    temperature_2 = Instrument.measurement(
        ""R2"",
        """""" Reads the temperature of the sensor 2 in Kelvin. """""",
    )

    temperature_3 = Instrument.measurement(
        ""R3"",
        """""" Reads the temperature of the sensor 3 in Kelvin. """""",
    )

    temperature_error = Instrument.measurement(
        ""R4"",
        """""" Reads the difference between the set-point and the measured
        temperature in Kelvin. Positive when set-point is larger than
        measured. """""",
    )

    front_panel_display = Instrument.setting(
        ""F%d"",
        """""" A string property that controls what value is displayed on
        the front panel of the ITC. Valid values are:
        'temperature setpoint', 'temperature 1', 'temperature 2',
        'temperature 3', 'temperature error', 'heater', 'heater voltage',
        'gasflow', 'proportional band', 'integral action time',
        'derivative action time', 'channel 1 freq/4', 'channel 2 freq/4',
        'channel 3 freq/4'.
        """""",
        validator=strict_discrete_set,
        map_values=True,
        values={
            ""temperature setpoint"": 0,
            ""temperature 1"": 1,
            ""temperature 2"": 2,
            ""temperature 3"": 3,
            ""temperature error"": 4,
            ""heater"": 5,
            ""heater voltage"": 6,
            ""gasflow"": 7,
            ""proportional band"": 8,
            ""integral action time"": 9,
            ""derivative action time"": 10,
            ""channel 1 freq/4"": 11,
            ""channel 2 freq/4"": 12,
            ""channel 3 freq/4"": 13,
        },
    )

    x_pointer = Instrument.setting(
        ""x%d"",
        """""" An integer property to set pointers into tables for loading and
        examining values in the table. The significance and valid values for
        the pointer depends on what property is to be read or set. """""",
        validator=strict_range,
        values=[0, 128]
    )

    y_pointer = Instrument.setting(
        ""y%d"",
        """""" An integer property to set pointers into tables for loading and
        examining values in the table. The significance and valid values for
        the pointer depends on what property is to be read or set. """""",
        validator=strict_range,
        values=[0, 128]
    )

    pointer = Instrument.setting(
        ""$x%d\r$y%d"",
        """""" A tuple property to set pointers into tables for loading and
        examining values in the table, of format (x, y). The significance
        and valid values for the pointer depends on what property is to be
        read or set. The value for x and y can be in the range 0 to 128. """""",
        validator=pointer_validator,
        values=[0, 128]
    )

    sweep_table = Instrument.control(
        ""r"", ""s%f"",
        """""" A property that controls values in the sweep table. Relies on
        :class:`ITC503.x_pointer` and :class:`ITC503.y_pointer` (or
        :class:`ITC503.pointer`) to point at the location in the table that is
        to be set or read.

        The x-pointer selects the step of the sweep (1 to 16); the y-pointer
        selects the parameter:

        =========   =======================
        y-pointer   parameter
        =========   =======================
        1           set-point temperature
        2           sweep-time to set-point
        3           hold-time at set-point
        =========   =======================
        """""",
    )

    auto_pid_table = Instrument.control(
        ""q"", ""p%f"",
        """""" A property that controls values in the auto-pid table. Relies on
        :class:`ITC503.x_pointer` and :class:`ITC503.y_pointer` (or
        :class:`ITC503.pointer`) to point at the location in the table that
        is to be set or read.

        The x-pointer selects the table entry (1 to 16); the y-pointer
        selects the parameter:

        =========   =======================
        y-pointer   parameter
        =========   =======================
        1           upper temperature limit
        2           proportional band
        3           integral action time
        4           derivative action time
        =========   =======================
        """""",
    )

    target_voltage_table = Instrument.control(
        ""t"", ""v%f"",
        """""" A property that controls values in the target heater voltage table.
        Relies on the :class:`ITC503.x_pointer` to select the entry in the table
        that is to be set or read (1 to 64).
        """""",
    )

    gasflow_configuration_parameter = Instrument.control(
        ""d"", ""c%f"",
        """""" A property that controls the gas flow configuration parameters.
        Relies on the :class:`ITC503.x_pointer` to select which parameter
        is set or read:

        =========   =====================================
        x-pointer   parameter
        =========   =====================================
        1           valve gearing
        2           target table & features configuration
        3           gas flow scaling
        4           temperature error sensitivity
        5           heater voltage error sensitivity
        6           minimum gas valve in auto
        =========   =====================================
        """""",
    )

    gasflow_control_status = Instrument.measurement(
        ""m"",
        """""" A property that reads the gas-flow control status. Returns
        the status in the form of a :class:`ITC503.FLOW_CONTROL_STATUS`
        IntFlag. """""",
        cast=int,
        get_process=lambda v: ITC503.FLOW_CONTROL_STATUS(v),
    )

    target_voltage = Instrument.measurement(
        ""n"",
        """""" A float property that reads the current heater target voltage
        with which the actual heater voltage is being compared. Only valid
        if gas-flow in auto mode. """""",
    )

    valve_scaling = Instrument.measurement(
        ""o"",
        """""" A float property that reads the valve scaling parameter. Only
        valid if gas-flow in auto mode. """""",
    )

    def wait_for_temperature(self,
                             error=0.01,
                             timeout=3600,
                             check_interval=0.5,
                             stability_interval=10,
                             thermalize_interval=300,
                             should_stop=lambda: False,
                             ):
        """"""
        Wait for the ITC to reach the set-point temperature.

        :param error: The maximum error in Kelvin under which the temperature
                      is considered at set-point
        :param timeout: The maximum time the waiting is allowed to take. If
                        timeout is exceeded, a TimeoutError is raised. If
                        timeout is None, no timeout will be used.
        :param check_interval: The time between temperature queries to the ITC.
        :param stability_interval: The time over which the temperature_error is
                                   to be below error to be considered stable.
        :param thermalize_interval: The time to wait after stabilizing for the
                                    system to thermalize.
        :param should_stop: Optional function (returning a bool) to allow the
                            waiting to be stopped before its end.
        """"""

        number_of_intervals = int(stability_interval / check_interval)
        stable_intervals = 0
        attempt = 0

        t0 = time()
        while True:
            temp_error = self.temperature_error
            if abs(temp_error) < error:
                stable_intervals += 1
            else:
                stable_intervals = 0
                attempt += 1

            if stable_intervals >= number_of_intervals:
                break

            if timeout is not None and (time() - t0) > timeout:
                raise TimeoutError(
                    ""Timeout expired while waiting for the Oxford ITC305 to ""
                    ""reach the set-point temperature""
                )

            if should_stop():
                return

            sleep(check_interval)

        if attempt == 0:
            return

        t1 = time() + thermalize_interval
        while time() < t1:
            sleep(check_interval)
            if should_stop():
                return

        return

    def program_sweep(self, temperatures, sweep_time, hold_time, steps=None):
        """"""
        Program a temperature sweep in the controller. Stops any running sweep.
        After programming the sweep, it can be started using
        OxfordITC503.sweep_status = 1.

        :param temperatures: An array containing the temperatures for the sweep
        :param sweep_time: The time (or an array of times) to sweep to a
                           set-point in minutes (between 0 and 1339.9).
        :param hold_time: The time (or an array of times) to hold at a
                          set-point in minutes (between 0 and 1339.9).
        :param steps: The number of steps in the sweep, if given, the
                      temperatures, sweep_time and hold_time will be
                      interpolated into (approximately) equal segments
        """"""
        # Check if in remote control
        if not self.control_mode.startswith(""R""):
            raise AttributeError(
                ""Oxford ITC503 not in remote control mode""
            )

        # Stop sweep if running to be able to write the program
        self.sweep_status = 0

        # Convert input np.ndarrays
        temperatures = numpy.array(temperatures, ndmin=1)
        sweep_time = numpy.array(sweep_time, ndmin=1)
        hold_time = numpy.array(hold_time, ndmin=1)

        # Make steps array
        if steps is None:
            steps = temperatures.size
        steps = numpy.linspace(1, steps, steps)

        # Create interpolated arrays
        interpolator = numpy.round(
            numpy.linspace(1, steps.size, temperatures.size))
        temperatures = numpy.interp(steps, interpolator, temperatures)

        interpolator = numpy.round(
            numpy.linspace(1, steps.size, sweep_time.size))
        sweep_time = numpy.interp(steps, interpolator, sweep_time)

        interpolator = numpy.round(
            numpy.linspace(1, steps.size, hold_time.size))
        hold_time = numpy.interp(steps, interpolator, hold_time)

        # Pad with zeros to wipe unused steps (total 16) of the sweep program
        padding = 16 - temperatures.size
        temperatures = numpy.pad(temperatures, (0, padding), 'constant',
                                 constant_values=temperatures[-1])
        sweep_time = numpy.pad(sweep_time, (0, padding), 'constant')
        hold_time = numpy.pad(hold_time, (0, padding), 'constant')

        # Setting the arrays to the controller
        for line, (setpoint, sweep, hold) in \
                enumerate(zip(temperatures, sweep_time, hold_time), 1):
            self.pointer = (line, 1)
            self.sweep_table = setpoint

            self.pointer = (line, 2)
            self.sweep_table = sweep

            self.pointer = (line, 3)
            self.sweep_table = hold

    def wipe_sweep_table(self):
        """""" Wipe the currently programmed sweep table. """"""
        self.write(""w"")
"
48,3500.0,"Irvine, California, United States","This is a Newport ESP300 1 Axis Motion Controller, Model number ESP300-1NN111. It has a 150 Watt power supply and the driver module is rated at 3 amps. This is Newport's most universal motion controller, as it will drive most of Newports actuators and motorized stages. If your Newport stage is an ESP model, this controller will recognize it on power up, and allow you to drive it right away- basically a plug-and-play operation! This unit has been tested and is working correctly.",ESP 300,387.0,"Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",Pymeasure,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eJF3UbuXimfV1ihP9bpJbA/aUuQ3ySKJ3Ck7iVo_ttsIYwQYPIPPbW-ymksVpBwfMe-w5ld6x3Jh8N8iEcxVd2FJlnsRm4kZ8Z0AlnnXvdLsLjgt2lHWAUg5pGRgiWing0/cQ7xieJDgP0gXAdYteL8KICPVcN6GPgJHEIBNF93VoM'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sUivBL_K7azt26iNB3Tshw/xhA4U9s8liX3z0U23n6TKINZ4QI7N9tsDVuO1SP0WhZc_oXoUBHeNsKyb7dZH8w-nsltXwRFd7PaocFJ-MdUcQ/EKtnn7Re9BcgDyKHCIBYI98vX1ZWnm1SKaAE33PmUXQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ii7mKuM-BnbGEVA8WXszCg/hRwzRTc7Orc7Ckc-pcBWPqOG2cLXBR-VPFP40XU6keLSWkwjLcNVphU3uWS8R7GvT0DYir1pNTc1wydz5QeqbA/yOl2VlnroxlPhZM7jhR2Ndj749JLIlLNhHUsAwMzq78'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YAUQVRx7gEmmEhPpt9cbAQ/aTYL4VMJe9WxFwtJerL5-KZ6n1bszVY8CRHFuLc-7NDV2R770SqIBOLoVhDQHB1ELoEEkn2F9xJWqK6ok9DhPw/lJaUVpWFk-Sx7N9ATCoaKUz88h2gxXL3ClbGSaaq5Xc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Positional Controller,https://en.wikipedia.org/wiki/Motion_control,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.",,https://www.equipx.net/uploads/Newport/NewportESP300.pdf,"[OrderedDict([('id', 'attHUDXWzAcLoQk6L'), ('width', 290), ('height', 174), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JVfijBfNiZhS167o9rdf1w/_DFCvpLg8GcQVvB1y1SdRPuT0V3Hqv_9EGNedvgATQzJAeeHetXvaAJNd1_-S0xr5EzWLxfcEEb6N-FYH3XHz4fkyTocjh8YLdKo74XiBSA/Gy-SNhS4-8Tg3sylGl1WhgsbpiCwtD3KRjqXvxjIIHg'), ('filename', 'download.jpg'), ('size', 4725), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vBEA0fZ5MHd1pGDWzxcSsg/sBtJDEMHNCe3GXrdXHZCxFJG_qOJlP-9GxKwcObclRwBIjEUwQz7C930t7oesSlEYSndHg2lJwi7uOzmiltEAg/FCQBXmb4KAvxYWjZl0Jqvf0cAJFkAaIxK16n0-WVxM8'), ('width', 60), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YFNWyer3nZVm52zygJIARQ/Mz2eJOV8DzYsvb5w70-JXCjFTqnoxVGz-KCEGtaDhsHaxdggnfzFIEvVaggqgdaqLd5YI7UcRHySkG1-Uhf45Q/Lw7ivFUlAZ-sgenBibmvMIP3yJoCw5Om-9dBx6DuZWo'), ('width', 290), ('height', 174)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SrrJBRL7Y0bqZ4N5f7hzXA/Wm3RreU7iO_ou3WzShrth1Jqs5TC_y3j68Ghgi8E4Eyg8WU6Zu8PUSlAdu6NpU3BIqsT4dI1uGnutpxH24dexA/gA9ctMEKseYr6Gp-DKKOMIZ5RULm8F70NhkmvtE8Qfg'), ('width', 3000), ('height', 3000)]))]))])]",http://www.lightglassoptics.com/Newport-ESP300-One-Axis-Motion-Controller-ESP300-1NN111_p_1241.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/newport/esp300.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/newport/esp300.html,1630.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from time import sleep

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set


class AxisError(Exception):
    """""" Raised when a particular axis causes an error for
    the Newport ESP300. """"""

    MESSAGES = {
        '00': 'MOTOR TYPE NOT DEFINED',
        '01': 'PARAMETER OUT OF RANGE',
        '02': 'AMPLIFIER FAULT DETECTED',
        '03': 'FOLLOWING ERROR THRESHOLD EXCEEDED',
        '04': 'POSITIVE HARDWARE LIMIT DETECTED',
        '05': 'NEGATIVE HARDWARE LIMIT DETECTED',
        '06': 'POSITIVE SOFTWARE LIMIT DETECTED',
        '07': 'NEGATIVE SOFTWARE LIMIT DETECTED',
        '08': 'MOTOR / STAGE NOT CONNECTED',
        '09': 'FEEDBACK SIGNAL FAULT DETECTED',
        '10': 'MAXIMUM VELOCITY EXCEEDED',
        '11': 'MAXIMUM ACCELERATION EXCEEDED',
        '12': 'Reserved for future use',
        '13': 'MOTOR NOT ENABLED',
        '14': 'Reserved for future use',
        '15': 'MAXIMUM JERK EXCEEDED',
        '16': 'MAXIMUM DAC OFFSET EXCEEDED',
        '17': 'ESP CRITICAL SETTINGS ARE PROTECTED',
        '18': 'ESP STAGE DEVICE ERROR',
        '19': 'ESP STAGE DATA INVALID',
        '20': 'HOMING ABORTED',
        '21': 'MOTOR CURRENT NOT DEFINED',
        '22': 'UNIDRIVE COMMUNICATIONS ERROR',
        '23': 'UNIDRIVE NOT DETECTED',
        '24': 'SPEED OUT OF RANGE',
        '25': 'INVALID TRAJECTORY MASTER AXIS',
        '26': 'PARAMETER CHARGE NOT ALLOWED',
        '27': 'INVALID TRAJECTORY MODE FOR HOMING',
        '28': 'INVALID ENCODER STEP RATIO',
        '29': 'DIGITAL I/O INTERLOCK DETECTED',
        '30': 'COMMAND NOT ALLOWED DURING HOMING',
        '31': 'COMMAND NOT ALLOWED DUE TO GROUP',
        '32': 'INVALID TRAJECTORY MODE FOR MOVING'
    }

    def __init__(self, code):
        self.axis = str(code)[0]
        self.error = str(code)[1:]
        self.message = self.MESSAGES[self.error]

    def __str__(self):
        return ""Newport ESP300 axis {} reported the error: {}"".format(
            self.axis, self.message)


class GeneralError(Exception):
    """""" Raised when the Newport ESP300 has a general error.
    """"""

    MESSAGES = {
        '1': 'PCI COMMUNICATION TIME-OUT',
        '4': 'EMERGENCY SOP ACTIVATED',
        '6': 'COMMAND DOES NOT EXIST',
        '7': 'PARAMETER OUT OF RANGE',
        '8': 'CABLE INTERLOCK ERROR',
        '9': 'AXIS NUMBER OUT OF RANGE',
        '13': 'GROUP NUMBER MISSING',
        '14': 'GROUP NUMBER OUT OF RANGE',
        '15': 'GROUP NUMBER NOT ASSIGNED',
        '17': 'GROUP AXIS OUT OF RANGE',
        '18': 'GROUP AXIS ALREADY ASSIGNED',
        '19': 'GROUP AXIS DUPLICATED',
        '16': 'GROUP NUMBER ALREADY ASSIGNED',
        '20': 'DATA ACQUISITION IS BUSY',
        '21': 'DATA ACQUISITION SETUP ERROR',
        '23': 'SERVO CYCLE TICK FAILURE',
        '25': 'DOWNLOAD IN PROGRESS',
        '26': 'STORED PROGRAM NOT STARTED',
        '27': 'COMMAND NOT ALLOWED',
        '29': 'GROUP PARAMETER MISSING',
        '30': 'GROUP PARAMETER OUT OF RANGE',
        '31': 'GROUP MAXIMUM VELOCITY EXCEEDED',
        '32': 'GROUP MAXIMUM ACCELERATION EXCEEDED',
        '22': 'DATA ACQUISITION NOT ENABLED',
        '28': 'STORED PROGRAM FLASH AREA FULL',
        '33': 'GROUP MAXIMUM DECELERATION EXCEEDED',
        '35': 'PROGRAM NOT FOUND',
        '37': 'AXIS NUMBER MISSING',
        '38': 'COMMAND PARAMETER MISSING',
        '34': 'GROUP MOVE NOT ALLOWED DURING MOTION',
        '39': 'PROGRAM LABEL NOT FOUND',
        '40': 'LAST COMMAND CANNOT BE REPEATED',
        '41': 'MAX NUMBER OF LABELS PER PROGRAM EXCEEDED'
    }

    def __init__(self, code):
        self.error = str(code)
        self.message = self.MESSAGES[self.error]

    def __str__(self):
        return ""Newport ESP300 reported the error: %s"" % (
            self.message)


class Axis:
    """""" Represents an axis of the Newport ESP300 Motor Controller,
    which can have independent parameters from the other axes.
    """"""

    position = Instrument.control(
        ""TP"", ""PA%g"",
        """""" A floating point property that controls the position
        of the axis. The units are defined based on the actuator.
        Use the :meth:`~.wait_for_stop` method to ensure the position
        is stable.
        """"""
    )
    enabled = Instrument.measurement(
        ""MO?"",
        """""" Returns a boolean value that is True if the motion for
        this axis is enabled.
        """""",
        cast=bool
    )
    left_limit = Instrument.control(
        ""SL?"", ""SL%g"",
        """""" A floating point property that controls the left software
        limit of the axis. """"""
    )
    right_limit = Instrument.control(
        ""SR?"", ""SR%g"",
        """""" A floating point property that controls the right software
        limit of the axis. """"""
    )
    units = Instrument.control(
        ""SN?"", ""SN%d"",
        """""" A string property that controls the displacement units of the
        axis, which can take values of: enconder count, motor step, millimeter,
        micrometer, inches, milli-inches, micro-inches, degree, gradient, radian,
        milliradian, and microradian.
        """""",
        validator=strict_discrete_set,
        values={
            'encoder count': 0, 'motor step': 1, 'millimeter': 2,
            'micrometer': 3, 'inches': 4, 'milli-inches': 5,
            'micro-inches': 6, 'degree': 7, 'gradient': 8,
            'radian': 9, 'milliradian': 10, 'microradian': 11
        },
        map_values=True
    )
    motion_done = Instrument.measurement(
        ""MD?"",
        """""" Returns a boolean that is True if the motion is finished.
        """""",
        cast=bool
    )

    def __init__(self, axis, controller):
        self.axis = str(axis)
        self.controller = controller

    def ask(self, command):
        command = self.axis + command
        return self.controller.ask(command)

    def write(self, command):
        command = self.axis + command
        self.controller.write(command)

    def values(self, command, **kwargs):
        command = self.axis + command
        return self.controller.values(command, **kwargs)

    def enable(self):
        """""" Enables motion for the axis. """"""
        self.write(""MO"")

    def disable(self):
        """""" Disables motion for the axis. """"""
        self.write(""MF"")

    def home(self, type=1):
        """""" Drives the axis to the home position, which may be the negative
        hardware limit for some actuators (e.g. LTA-HS).
        type can take integer values from 0 to 6.
        """"""
        home_type = strict_discrete_set(type, [0, 1, 2, 3, 4, 5, 6])
        self.write(""OR%d"" % home_type)

    def define_position(self, position):
        """""" Overwrites the value of the current position with the given
        value. """"""
        self.write(""DH%g"" % position)

    def zero(self):
        """""" Resets the axis position to be zero at the current poisiton.
        """"""
        self.write(""DH"")

    def wait_for_stop(self, delay=0, interval=0.05):
        """""" Blocks the program until the motion is completed. A further
        delay can be specified in seconds.
        """"""
        self.write(""WS%d"" % (delay * 1e3))
        while not self.motion_done:
            sleep(interval)


class ESP300(Instrument):
    """""" Represents the Newport ESP 300 Motion Controller
    and provides a high-level for interacting with the instrument.

    By default this instrument is constructed with x, y, and phi
    attributes that represent axes 1, 2, and 3. Custom implementations
    can overwrite this depending on the avalible axes. Axes are controlled
    through an :class:`Axis <pymeasure.instruments.newport.esp300.Axis>`
    class.
    """"""

    error = Instrument.measurement(
        ""TE?"",
        """""" Get an error code from the motion controller.
        """""",
        cast=int
    )

    def __init__(self, adapter, name=""Newport ESP 300 Motion Controller"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        # Defines default axes, which can be overwritten
        self.x = Axis(1, self)
        self.y = Axis(2, self)
        self.phi = Axis(3, self)

    def clear_errors(self):
        """""" Clears the error messages by checking until a 0 code is
        recived. """"""
        while self.error != 0:
            continue

    @property
    def errors(self):
        """""" Get a list of error Exceptions that can be later raised, or
        used to diagnose the situation.
        """"""
        errors = []

        code = self.error
        while code != 0:
            if code > 100:
                errors.append(AxisError(code))
            else:
                errors.append(GeneralError(code))
            code = self.error
        return errors

    @property
    def axes(self):
        """""" Get a list of the :class:`Axis <pymeasure.instruments.newport.esp300.Axis>`
        objects that are present. """"""
        axes = []
        directory = dir(self)
        for name in directory:
            if name == 'axes':
                continue  # Skip this property
            try:
                item = getattr(self, name)
                if isinstance(item, Axis):
                    axes.append(item)
            except TypeError:
                continue
            except Exception as e:
                raise e
        return axes

    def enable(self):
        """""" Enables all of the axes associated with this controller.
        """"""
        for axis in self.axes:
            axis.enable()

    def disable(self):
        """""" Disables all of the axes associated with this controller.
        """"""
        for axis in self.axes:
            axis.disable()

    def shutdown(self):
        """""" Shuts down the controller by disabling all of the axes.
        """"""
        self.disable()
        super().shutdown()
"
54,5420.0,USA,"Turbo charge your production line with the Keysight 34450A 5.5-digit multimeter with OLED display. With its fast speed of up to 190 readings per second, you can increase your manufacturing throughput tremendously.",Agilent 34450 A,11.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT - 34450A Multimeters,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.",KEYSIGHT - 34450A,https://www.keysight.com/us/en/assets/7018-03659/product-fact-sheets/5991-1206.pdf,"[OrderedDict([('id', 'attOj9CAu6oVexCXp'), ('width', 1156), ('height', 650), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cSZ806G-ns8KDOJDZsk6Yw/wah87juerY6k83oyyofgrxDFVChYYWQGft0TSMPMys_ODDoHW-VM6vC5zZcVuNQPkMJpLKypITKfFrqCQMx3xC-4gmNKH9iEjxjh--4CrGc/M3pGPJifyrAdlOp6Qq-ZVJYvHJEXyHwuq_o2bT1HZP0'), ('filename', '34450A.png'), ('size', 398092), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LTgg3809a2OQ5xnsac0uHw/wTVPZzBjoFus_Fj79lrl4x4pVVGsByWpe9ZLAn14P2yUBbRtP9L_iAS8jkWIImT-Z8FHEgdbLmJGFIDdI30RZQ/p7SKb9v3uL7AvFA9oiBaXEVu68GcS_mAsjr2JxkRp0c'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rvuQ6NGXt2FnmusbGxwDFw/3xDy2irxQDAN_UGVD6TvBzWwzkv0BG2AvfR5rT3RLPgXwkW2UGY919-E622to3JjwY5YJet8jNyiHrCAHoJn6A/JPCe37obObdnjnoGLRpIiH3k1yb82lnNy3hUq3Wszok'), ('width', 911), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Vh8OB0vvYq0aNQ6_qhXhPA/LFKC_bkf7gtnUGuR3SR8jtKaeQ_XzU9hYWQe_ZLnCFa3vkiMyjQqGbelB_gc8ZxXfGWfSFSeeFlvlI8qx2E02Q/zPr_XYfP-KEfH4JBNt8lUU75sBZYvP4rX3u5d1vcjdo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/34450A/digital-multimeter-5-5-digit-oled-display.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent34450A.py,https://www.keysight.com/us/en/lib/software-detail/driver/34400-digital-multimeters-python-instrument-drivers.html,1138.0,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Agilent34450A(Instrument):
    """"""
    Represent the HP/Agilent/Keysight 34450A and related multimeters.

    .. code-block:: python

        dmm = Agilent34450A(""USB0::..."")
        dmm.reset()
        dmm.configure_voltage()
        print(dmm.voltage)
        dmm.shutdown()

    """"""

    BOOLS = {True: 1, False: 0}

    MODES = {'current': 'CURR', 'ac current': 'CURR:AC',
             'voltage': 'VOLT', 'ac voltage': 'VOLT:AC',
             'resistance': 'RES', '4w resistance': 'FRES',
             'current frequency': 'FREQ:ACI', 'voltage frequency': 'FREQ:ACV',
             'continuity': 'CONT',
             'diode': 'DIOD',
             'temperature': 'TEMP',
             'capacitance': 'CAP'}

    @property
    def mode(self):
        get_command = "":configure?""
        vals = self._conf_parser(self.values(get_command))
        # Return only the mode parameter
        inv_modes = {v: k for k, v in self.MODES.items()}
        mode = inv_modes[vals[0]]
        return mode

    @mode.setter
    def mode(self, value):
        """""" A string parameter that sets the measurement mode of the multimeter. Can be ""current"",
        ""ac current"", ""voltage"", ""ac voltage"", ""resistance"", ""4w resistance"", ""current frequency"",
        ""voltage frequency"", ""continuity"", ""diode"", ""temperature"", or ""capacitance"".""""""
        if value in self.MODES:
            if value not in ['current frequency', 'voltage frequency']:
                self.write(':configure:' + self.MODES[value])
            else:
                if value == 'current frequency':
                    self.mode = 'ac current'
                else:
                    self.mode = 'ac voltage'
                self.write("":configure:freq"")
        else:
            raise ValueError(f'Value {value} is not a supported mode for this device.')

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement("":READ?"",
                                     """""" Reads a DC current measurement in Amps, based on the
                                     active :attr:`~.Agilent34450A.mode`. """"""
                                     )
    current_ac = Instrument.measurement("":READ?"",
                                        """""" Reads an AC current measurement in Amps, based on the
                                        active :attr:`~.Agilent34450A.mode`. """"""
                                        )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %s"",
        """""" A property that controls the DC current range in
        Amps, which can take values 100E-6, 1E-3, 10E-3, 100E-3, 1, 10,
        as well as ""MIN"", ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-6, 1E-3, 10E-3, 100E-3, 1, 10, ""MIN"", ""DEF"", ""MAX""]
    )
    current_auto_range = Instrument.control(
        "":SENS:CURR:RANG:AUTO?"", "":SENS:CURR:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for DC current. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    current_resolution = Instrument.control(
        "":SENS:CURR:RES?"", "":SENS:CURR:RES %s"",
        """""" A property that controls the resolution in the DC current
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", and ""DEF"" (3.00E-5). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    current_ac_range = Instrument.control(
        "":SENS:CURR:AC:RANG?"", "":SENS:CURR:AC:RANG:AUTO 0;:SENS:CURR:AC:RANG %s"",
        """""" A property that controls the AC current range in Amps, which can take
        values 10E-3, 100E-3, 1, 10, as well as ""MIN"", ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[10E-3, 100E-3, 1, 10, ""MIN"", ""MAX"", ""DEF""]
    )
    current_ac_auto_range = Instrument.control(
        "":SENS:CURR:AC:RANG:AUTO?"", "":SENS:CURR:AC:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for AC current. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    current_ac_resolution = Instrument.control(
        "":SENS:CURR:AC:RES?"", "":SENS:CURR:AC:RES %s"",
        """""" An property that controls the resolution in the AC current
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement("":READ?"",
                                     """""" Reads a DC voltage measurement in Volts, based on the
                                     active :attr:`~.Agilent34450A.mode`. """"""
                                     )
    voltage_ac = Instrument.measurement("":READ?"",
                                        """""" Reads an AC voltage measurement in Volts, based on the
                                        active :attr:`~.Agilent34450A.mode`. """"""
                                        )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %s"",
        """""" A property that controls the DC voltage range in Volts, which
        can take values 100E-3, 1, 10, 100, 1000, as well as ""MIN"", ""MAX"", or
        ""DEF"" (10 V). Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 1000, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_auto_range = Instrument.control(
        "":SENS:VOLT:RANG:AUTO?"", "":SENS:VOLT:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for DC voltage. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    voltage_resolution = Instrument.control(
        "":SENS:VOLT:RES?"", "":SENS:VOLT:RES %s"",
        """""" A property that controls the resolution in the DC voltage
        readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_ac_range = Instrument.control(
        "":SENS:VOLT:AC:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:AC:RANG %s"",
        """""" A property that controls the AC voltage range in Volts, which can
        take values 100E-3, 1, 10, 100, 750, as well as ""MIN"", ""MAX"", or ""DEF""
        (10 V).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 750, ""MAX"", ""MIN"", ""DEF""]
    )
    voltage_ac_auto_range = Instrument.control(
        "":SENS:VOLT:AC:RANG:AUTO?"", "":SENS:VOLT:AC:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for AC voltage. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    voltage_ac_resolution = Instrument.control(
        "":SENS:VOLT:AC:RES?"", "":SENS:VOLT:AC:RES %s"",
        """""" A property that controls the resolution in the AC voltage readings,
        which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement("":READ?"",
                                        """""" Reads a resistance measurement in Ohms for 2-wire
                                        configuration, based on the active
                                        :attr:`~.Agilent34450A.mode`. """"""
                                        )
    resistance_4w = Instrument.measurement("":READ?"",
                                           """""" Reads a resistance measurement in Ohms for
                                           4-wire configuration, based on the active
                                           :attr:`~.Agilent34450A.mode`. """"""
                                           )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %s"",
        """""" A property that controls the 2-wire resistance range in Ohms, which can
        take values 100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, as well as ""MIN"", ""MAX"",
        or ""DEF"" (1E3).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_auto_range = Instrument.control(
        "":SENS:RES:RANG:AUTO?"", "":SENS:RES:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for 2-wire resistance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    resistance_resolution = Instrument.control(
        "":SENS:RES:RES?"", "":SENS:RES:RES %s"",
        """""" A property that controls the resolution in the 2-wire
        resistance readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_4w_range = Instrument.control(
        "":SENS:FRES:RANG?"", "":SENS:FRES:RANG:AUTO 0;:SENS:FRES:RANG %s"",
        """""" A property that controls the 4-wire resistance range
        in Ohms, which can take values 100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6,
        as well as ""MIN"", ""MAX"", or ""DEF"" (1E3).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100, 1E3, 10E3, 100E3, 1E6, 10E6, 100E6, ""MAX"", ""MIN"", ""DEF""]
    )
    resistance_4w_auto_range = Instrument.control(
        "":SENS:FRES:RANG:AUTO?"", "":SENS:FRES:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for 4-wire resistance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    resistance_4w_resolution = Instrument.control(
        "":SENS:FRES:RES?"", "":SENS:FRES:RES %s"",
        """""" A property that controls the resolution in the 4-wire
        resistance readings, which can take values 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
        as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6). """""",
        validator=strict_discrete_set,
        values=[3.00E-5, 2.00E-5, 1.50E-6, ""MAX"", ""MIN"", ""DEF""]
    )

    ##################
    # Frequency (Hz) #
    ##################

    frequency = Instrument.measurement("":READ?"",
                                       """""" Reads a frequency measurement in Hz, based on the
                                       active :attr:`~.Agilent34450A.mode`. """"""
                                       )
    frequency_current_range = Instrument.control(
        "":SENS:FREQ:CURR:RANG?"", "":SENS:FREQ:CURR:RANG:AUTO 0;:SENS:FREQ:CURR:RANG %s"",
        """""" A property that controls the current range in Amps for frequency on AC current
        measurements, which can take values 10E-3, 100E-3, 1, 10, as well as ""MIN"",
        ""MAX"", or ""DEF"" (100 mA).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[10E-3, 100E-3, 1, 10, ""MIN"", ""MAX"", ""DEF""]
    )
    frequency_current_auto_range = Instrument.control(
        "":SENS:FREQ:CURR:RANG:AUTO?"", "":SENS:FREQ:CURR:RANG:AUTO %d"",
        """""" Boolean property that toggles auto ranging for AC current in frequency measurements."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    frequency_voltage_range = Instrument.control(
        "":SENS:FREQ:VOLT:RANG?"", "":SENS:FREQ:VOLT:RANG:AUTO 0;:SENS:FREQ:VOLT:RANG %s"",
        """""" A property that controls the voltage range in Volts for frequency on AC voltage
        measurements, which can take values 100E-3, 1, 10, 100, 750,
        as well as ""MIN"", ""MAX"", or ""DEF"" (10 V).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, 10, 100, 750, ""MAX"", ""MIN"", ""DEF""]
    )
    frequency_voltage_auto_range = Instrument.control(
        "":SENS:FREQ:VOLT:RANG:AUTO?"", "":SENS:FREQ:VOLT:RANG:AUTO %d"",
        """"""Boolean property that toggles auto ranging for AC voltage in frequency measurements. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )
    frequency_aperture = Instrument.control(
        "":SENS:FREQ:APER?"", "":SENS:FREQ:APER %s"",
        """""" A property that controls the frequency aperture in seconds,
        which sets the integration period and measurement speed. Takes values
        100 ms, 1 s, as well as ""MIN"", ""MAX"", or ""DEF"" (1 s). """""",
        validator=strict_discrete_set,
        values=[100E-3, 1, ""MIN"", ""MAX"", ""DEF""]
    )

    ###################
    # Temperature (C) #
    ###################

    temperature = Instrument.measurement(
        "":READ?"",
        """""" Reads a temperature measurement in Celsius, based on the active :attr:`~.Agilent34450A.mode`.
        """"""  # noqa: E501
    )

    #############
    # Diode (V) #
    #############

    diode = Instrument.measurement(
        "":READ?"",
        """""" Reads a diode measurement in Volts, based on the active :attr:`~.Agilent34450A.mode`.
        """"""
    )

    ###################
    # Capacitance (F) #
    ###################

    capacitance = Instrument.measurement(
        "":READ?"",
        """""" Reads a capacitance measurement in Farads, based on the active :attr:`~.Agilent34450A.mode`.
        """"""  # noqa: E501
    )
    capacitance_range = Instrument.control(
        "":SENS:CAP:RANG?"", "":SENS:CAP:RANG:AUTO 0;:SENS:CAP:RANG %s"",
        """""" A property that controls the capacitance range
        in Farads, which can take values 1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6,
        1E-3, 10E-3, as well as ""MIN"", ""MAX"", or ""DEF"" (1E-6).
        Auto-range is disabled when this property is set. """""",
        validator=strict_discrete_set,
        values=[1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6, 1E-3, 10E-3, ""MAX"", ""MIN"", ""DEF""]
    )
    capacitance_auto_range = Instrument.control(
        "":SENS:CAP:RANG:AUTO?"", "":SENS:CAP:RANG:AUTO %d"",
        """""" A boolean property that toggles auto ranging for capacitance. """""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    ####################
    # Continuity (Ohm) #
    ####################

    continuity = Instrument.measurement("":READ?"",
                                        """""" Reads a continuity measurement in Ohms,
                                        based on the active :attr:`~.Agilent34450A.mode`. """"""
                                        )

    def __init__(self, adapter, name=""HP/Agilent/Keysight 34450A Multimeter"", **kwargs):
        super().__init__(
            adapter, name, timeout=10000, **kwargs
        )
        # Configuration changes can necessitate up to 8.8 secs (per datasheet)
        self.check_errors()

    def configure_voltage(self, voltage_range=""AUTO"", ac=False, resolution=""DEF""):
        """""" Configures the instrument to measure voltage.

        :param voltage_range: A voltage in Volts to set the voltage range.
                DC values can be 100E-3, 1, 10, 100, 1000, as well as ""MIN"", ""MAX"",
                ""DEF"" (10 V), or ""AUTO"". AC values can be 100E-3, 1, 10, 100, 750,
                as well as ""MIN"", ""MAX"", ""DEF"" (10 V), or ""AUTO"".
        :param ac: False for DC voltage, True for AC voltage
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5,
                1.50E-6 (5 1/2 digits), as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if ac is True:
            self.mode = 'ac voltage'
            self.voltage_ac_resolution = resolution
            if voltage_range == ""AUTO"":
                self.voltage_ac_auto_range = True
            else:
                self.voltage_ac_range = voltage_range
        elif ac is False:
            self.mode = 'voltage'
            self.voltage_resolution = resolution
            if voltage_range == ""AUTO"":
                self.voltage_auto_range = True
            else:
                self.voltage_range = voltage_range
        else:
            raise TypeError('Value of ac should be a boolean.')

    def configure_current(self, current_range=""AUTO"", ac=False, resolution=""DEF""):
        """""" Configures the instrument to measure current.

        :param current_range: A current in Amps to set the current range.
                DC values can be 100E-6, 1E-3, 10E-3, 100E-3, 1, 10, as well as ""MIN"",
                ""MAX"", ""DEF"" (100 mA), or ""AUTO"". AC values can be 10E-3, 100E-3, 1, 10,
                as well as ""MIN"", ""MAX"", ""DEF"" (100 mA), or ""AUTO"".
        :param ac: False for DC current, and True for AC current
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
                as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if ac is True:
            self.mode = 'ac current'
            self.current_ac_resolution = resolution
            if current_range == ""AUTO"":
                self.current_ac_auto_range = True
            else:
                self.current_ac_range = current_range
        elif ac is False:
            self.mode = 'current'
            self.current_resolution = resolution
            if current_range == ""AUTO"":
                self.current_auto_range = True
            else:
                self.current_range = current_range
        else:
            raise TypeError('Value of ac should be a boolean.')

    def configure_resistance(self, resistance_range=""AUTO"", wires=2, resolution=""DEF""):
        """""" Configures the instrument to measure resistance.

        :param resistance_range: A resistance in Ohms to set the resistance range, can be 100,
                1E3, 10E3, 100E3, 1E6, 10E6, 100E6, as well as ""MIN"", ""MAX"", ""DEF"" (1E3), or ""AUTO"".
        :param wires: Number of wires used for measurement, can be 2 or 4.
        :param resolution: Desired resolution, can be 3.00E-5, 2.00E-5, 1.50E-6 (5 1/2 digits),
                as well as ""MIN"", ""MAX"", or ""DEF"" (1.50E-6).
        """"""
        if wires == 2:
            self.mode = 'resistance'
            self.resistance_resolution = resolution
            if resistance_range == ""AUTO"":
                self.resistance_auto_range = True
            else:
                self.resistance_range = resistance_range
        elif wires == 4:
            self.mode = '4w resistance'
            self.resistance_4w_resolution = resolution
            if resistance_range == ""AUTO"":
                self.resistance_4w_auto_range = True
            else:
                self.resistance_4w_range = resistance_range
        else:
            raise ValueError(""Incorrect wires value, Agilent 34450A only supports 2 or 4 wire""
                             ""resistance meaurement."")

    def configure_frequency(self, measured_from=""voltage_ac"",
                            measured_from_range=""AUTO"", aperture=""DEF""):
        """""" Configures the instrument to measure frequency.

        :param measured_from: ""voltage_ac"" or ""current_ac""
        :param measured_from_range: range of measured_from. AC voltage can have ranges 100E-3,
                                    1, 10, 100, 750, as well as ""MIN"", ""MAX"", ""DEF"" (10 V),
                                    or ""AUTO"". AC current can have ranges 10E-3, 100E-3, 1, 10,
                                    as well as ""MIN"", ""MAX"", ""DEF"" (100 mA), or ""AUTO"".
        :param aperture: Aperture time in Seconds, can be 100 ms, 1 s, as well as ""MIN"", ""MAX"",
                        or ""DEF"" (1 s).
        """"""
        if measured_from == ""voltage_ac"":
            self.mode = ""voltage frequency""
            if measured_from_range == ""AUTO"":
                self.frequency_voltage_auto_range = True
            else:
                self.frequency_voltage_range = measured_from_range
        elif measured_from == ""current_ac"":
            self.mode = ""current frequency""
            if measured_from_range == ""AUTO"":
                self.frequency_current_auto_range = True
            else:
                self.frequency_current_range = measured_from_range
        else:
            raise ValueError('Incorrect value for measured_from parameter. Use '
                             '""voltage_ac"" or ""current_ac"".')
        self.frequency_aperture = aperture

    def configure_temperature(self):
        """""" Configures the instrument to measure temperature.
        """"""
        self.mode = 'temperature'

    def configure_diode(self):
        """""" Configures the instrument to measure diode voltage.
        """"""
        self.mode = 'diode'

    def configure_capacitance(self, capacitance_range=""AUTO""):
        """""" Configures the instrument to measure capacitance.

        :param capacitance_range: A capacitance in Farads to set the capacitance range, can be
                                    1E-9, 10E-9, 100E-9, 1E-6, 10E-6, 100E-6, 1E-3, 10E-3,
                                    as well as ""MIN"", ""MAX"", ""DEF"" (1E-6), or ""AUTO"".
        """"""
        self.mode = 'capacitance'
        if capacitance_range == ""AUTO"":
            self.capacitance_auto_range = True
        else:
            self.capacitance_range = capacitance_range

    def configure_continuity(self):
        """""" Configures the instrument to measure continuity.
        """"""
        self.mode = 'continuity'

    def beep(self):
        """""" Sounds a system beep.
        """"""
        self.write("":SYST:BEEP"")

    def _conf_parser(self, conf_values):
        """"""
        Parse the string of configuration parameters read from Agilent34450A with
        command "":configure?"" and returns a list of parameters.

        Use cases:

        ['""CURR +1.000000E-01', '+1.500000E-06""'] from Instrument.measurement or Instrument.control
        '""CURR +1.000000E-01,+1.500000E-06""'      from Instrument.ask

        becomes

        [""CURR"", +1000000E-01, +1.500000E-06]
        """"""
        # If not already one string, get one string

        if isinstance(conf_values, list):
            one_long_string = ', '.join(map(str, conf_values))
        else:
            one_long_string = conf_values

        # Split string in elements
        list_of_elements = re.split(r'[""\s,]', one_long_string)

        # Eliminate empty string elements
        list_without_empty_elements = list(filter(lambda v: v != '', list_of_elements))

        # Convert numbers from str to float, where applicable
        for i, v in enumerate(list_without_empty_elements):
            try:
                list_without_empty_elements[i] = float(v)
            except ValueError as e:
                log.error(e)

        return list_without_empty_elements
"
67,110.6,"Cleveland, Ohio, United States","The dual channel Battery/Charger Simulator was designed specifically for development and test applications of portable, battery-operated products, such as cellular and cordless telephones, mobile radios, and pagers. This precision DC power supply product has ultrafast transient response so it can have output characteristics identical to actual batteries. This supply employs a unique variable output resistance so the voltage output can emulate a battery's response. It provides stable voltage outputs, even when a device-under-test (DUT) makes the rapid transition from the standby (low current) state to the RF transmission (high current) state. In addition, they can monitor DUT power consumption by measuring both DC currents and pulse load currents. The battery-simulator channel can be programmed to operate like a discharged rechargeable battery, sinking current from a separate charger.",Keithley 2306,269.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,https://www.farnell.com/datasheets/1626633.pdf,"[OrderedDict([('id', 'attXtmEnOSGHQOZvU'), ('width', 320), ('height', 138), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/U5QaMxm6ZjpZj9vTRziWSg/mQ2Y8IAwCMmMB7r40llPG4o6im1VOA1xFnX0CUawAtEekIdbsZ9yV9hjJUuL81JT4EMYu6EbFVKqYeif7xNwwbM73gY70ht3T_Kv5FgG86Y/EHETvnq-yVH0prJzaQNV24kZ_IMXymKd60mtGhtBmZ8'), ('filename', '2306.webp'), ('size', 2692), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ammok7qJ8bYjuEh_AK-JfA/5RbJ0jIJUiVgvD-isqmcNMDYkp9IkhmyOtCqsRE8uiUIxl6boXFnM4uDY1nXkPvme11xLCgEzrRq4OrZApb6AV1t-6DIWKP0yvPeGcsDPUc/I-J3ioIt6E6iGFYHhtqd1VYI25H595NeqGDEnMV60ZY'), ('width', 83), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WM4ZTfhsQONojhWRH3GKuQ/8yQrb-ATSUAL8INS4yFfqgd_zzQg84pkAQiSN7GIUlwT83b5LNfr256C_tjDAWb6LYBsgm7X63TYS6nQ9jswn9ZX2A8K1kbD2X_NhdGVTDo/XUk-jRvh-3e2IC7SPkCRrXDPw74sa2JHaG56SwhEv-Y'), ('width', 320), ('height', 138)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NQqh6KcT5BpQPjWaKEPRFQ/5bWMCRa4j2rAlfyzYtcI0SSSDr8sSmPQnRsETid7v0soiPMWhey3G0VbuR9FoXIkm11y6HkbfXGDXQBeMYRGsL9MD-8D6XYwMqQOA0dfJQs/FXkQBFb0-Y5tTBatLN_229KUV-vITpBEdqJZA7-Jlkg'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2306/battery-charger-simulator-15v/dp/58T8423,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2306.py,https://pymeasure.readthedocs.io/en/stable/api/instruments/keithley/keithley2306.html,7450.4,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Channel():
    """""" Implementation of a Keithley 2306 channel. """"""

    enabled = Instrument.control(
        "":OUTPUT<ch>:STAT?"", "":OUTPUT<ch>:STAT %d"",
        """"""A boolean property that controls whether the output is enabled, takes
        values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    bandwidth = Instrument.control(
        "":OUTPUT<ch>:BAND?"", "":OUTPUT<ch>:BAND %s"",
        """"""A string property that controls the output bandwidth when the output
        is enabled and the current range is set to 5 A. Takes values 'HIGH' or
        'LOW'. If the output is disabled or the current range is set to 5 mA the
        bandwidth is 'LOW'. """""",
        validator=strict_discrete_set,
        values={'low': 'LOW', 'high': 'HIGH'},
        map_values=True,
    )

    sense_mode = Instrument.control(
        "":SENS<ch>:FUNC?"", "":SENS<ch>:FUNC \""%s\"""",
        """"""A string property that controls the channel sense mode, which can
        take the values 'voltage', 'current', 'dvm', 'pulse_current',
        or 'long_integration'. """""",
        validator=strict_discrete_set,
        values={'voltage': 'VOLT', 'current': 'CURR', 'dvm': 'DVM',
                'pulse_current': 'PCUR', 'long_integration': 'LINT'},
        map_values=True,
        get_process=lambda v: v.replace('""', ''),
    )

    nplc = Instrument.control(
        "":SENS<ch>:NPLC?"", "":SENS<ch>:NPLC %g"",
        """"""A floating point property that controls the number of power line
        cycles (NPLC) for voltage, current, and DVM measurements. Takes
        values from 0.01 to 10. """""",
        validator=truncated_range,
        values=[0.01, 10],
    )

    average_count = Instrument.control(
        "":SENS<ch>:AVER?"", "":SENS<ch>:AVER %d"",
        """"""An integer property that controls the average count for voltage,
        current, and DVM measurements. Takes values from 1 to 10. """""",
        validator=truncated_range,
        values=[1, 10],
    )

    current_range = Instrument.control(
        "":SENS<ch>:CURR:RANG?"", "":SENS<ch>:CURR:RANG %g"",
        """"""A floating point property that controls the current range which
        takes values of 5 mA and 5 A (or 500 mA and 5 A for the 2306-PJ)."""""",
        validator=strict_discrete_set,
        values=[0.005, 0.5, 5],
    )

    current_range_auto = Instrument.control(
        "":SENS<ch>:CURR:RANG:AUTO?"", "":SENS<ch>:CURR:RANG:AUTO %d"",
        """"""A boolean point property that controls whether current range
        is in auto mode. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_average_count = Instrument.control(
        "":SENS<ch>:PCUR:AVER?"", "":SENS<ch>:PCUR:AVER %d"",
        """"""An integer property that controls the average count for pulse
        current measurements. Takes values from 1 to either 100 if
        pulse_current_measure_enabled is set to True, 5000 otherwise. """""",
        validator=truncated_range,
        values=[1, 5000],
    )

    pulse_current_measure_enabled = Instrument.control(
        "":SENS<ch>:PCUR:SYNC?"", "":SENS<ch>:PCUR:SYNC %d"",
        """"""A boolean property that controls whether pulse current
        measurements are enabled (True) or whether the channel is in
        digitization mode (False). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_trigger_delay = Instrument.control(
        "":SENS<ch>:PCUR:SYNC:DEL?"", "":SENS<ch>:PCUR:SYNC:DEL %g"",
        """"""A floating point property that controls the pulse current trigger
        delay in seconds. Takes values from 0 to either 0.1 if
        pulse_current_measure_enabled is set to True, 5 otherwise."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    pulse_current_trigger_level = Instrument.control(
        "":SENS<ch>:PCUR:SYNC:TLEV?"", "":SENS<ch>:PCUR:SYNC:TLEV %g"",
        """"""A floating point property that controls the pulse current trigger
        level in amps. Takes values between 0 and 5."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    pulse_current_mode = Instrument.control(
        "":SENS<ch>:PCUR:MODE?"", "":SENS<ch>:PCUR:MODE %s"",
        """"""A string property that controls the pulse current measurement
        mode, which can take the values 'high', 'low', or 'average'. """""",
        validator=strict_discrete_set,
        values={'high': 'HIGH', 'low': 'LOW', 'average': 'AVER'},
        map_values=True,
    )

    def pulse_current_time_auto(self):
        """"""Arranges for the instrument to control integration times. """"""
        self.write("":SENS<ch>:PCUR:TIME:AUTO"")

    pulse_current_time_high = Instrument.control(
        "":SENS<ch>:PCUR:TIME:HIGH?"", "":SENS<ch>:PCUR:TIME:HIGH %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for high pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_low = Instrument.control(
        "":SENS<ch>:PCUR:TIME:LOW?"", "":SENS<ch>:PCUR:TIME:LOW %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for low pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_average = Instrument.control(
        "":SENS<ch>:PCUR:TIME:AVER?"", "":SENS<ch>:PCUR:TIME:AVER %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for average pulse measurements. Takes on values between
        33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_time_digitize = Instrument.control(
        "":SENS<ch>:PCUR:TIME:DIG?"", "":SENS<ch>:PCUR:TIME:DIG %g"",
        """"""A floating point property that controls the integration time (in
        seconds) for digitizing or burst pulse measurements. Takes on values
        between 33.33333e-06 and 0.8333. """""",
        validator=truncated_range,
        values=[33.33333e-06, 0.8333],
    )

    pulse_current_fast_enabled = Instrument.control(
        "":SENS<ch>:PCUR:FAST?"", "":SENS<ch>:PCUR:FAST %d"",
        """"""A boolean property that controls whether pulse current fast readings
        are enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_search_enabled = Instrument.control(
        "":SENS<ch>:PCUR:SEAR?"", "":SENS<ch>:PCUR:SEAR %d"",
        """"""A boolean property that controls whether pulse current search
        is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_detect_enabled = Instrument.control(
        "":SENS<ch>:PCUR:DET?"", "":SENS<ch>:PCUR:DET %d"",
        """"""A boolean property that controls whether pulse current detection
        mode is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_timeout = Instrument.control(
        "":SENS<ch>:PCUR:TOUT?"", "":SENS<ch>:PCUR:TOUT %g"",
        """"""A floating point property that controls the pulse current timeout
        in seconds, which takes on values between 0.005 and 32. """""",
        validator=truncated_range,
        values=[0.005, 32],
    )

    long_integration_trigger_edge = Instrument.control(
        "":SENS<ch>:LINT:TEDG?"", "":SENS<ch>:LINT:TEDG %s"",
        """"""A string property that controls the long integration trigger edge,
         which can take the values 'rising', 'falling', or 'neither'. """""",
        validator=strict_discrete_set,
        values={'rising': 'RISING', 'falling': 'FALLING', 'neither': 'NEITHER'},
        map_values=True,
    )

    long_integration_time = Instrument.control(
        "":SENS<ch>:LINT:TIME?"", "":SENS<ch>:LINT:TIME %g"",
        """"""A floating point property that controls the long integration time
        in seconds, which takes on values in the range of 0.850 for 60 Hz and
         0.840 for 50 Hz up to 60. """""",
        validator=truncated_range,
        values=[0.840, 60],
    )

    def long_integration_time_auto(self):
        """"""Arranges for the instrument to control integration times. """"""
        self.write("":SENS<ch>:LINT:TIME:AUTO"")

    long_integration_trigger_level = Instrument.control(
        "":SENS<ch>:LINT:TLEV?"", "":SENS<ch>:LINT:TLEV %g"",
        """"""A floating point property that controls the long integration trigger
        level in amps, which takes values between 0 and 5. """""",
        validator=truncated_range,
        values=[0, 5],
    )

    long_integration_timeout = Instrument.control(
        "":SENS<ch>:LINT:TOUT?"", "":SENS<ch>:LINT:TOUT %g"",
        """"""A floating point property that controls the long integration timeout
        in seconds, which takes values between 1 and 63. """""",
        validator=truncated_range,
        values=[1, 63],
    )

    long_integration_fast_enabled = Instrument.control(
        "":SENS<ch>:LINT:FAST?"", "":SENS<ch>:LINT:FAST %d"",
        """"""A boolean property that controls whether long integration fast
        readings are enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    long_integration_search_enabled = Instrument.control(
        "":SENS<ch>:LINT:SEAR?"", "":SENS<ch>:LINT:SEAR %d"",
        """"""A boolean property that controls whether long integration search
        is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    long_integration_detect_enabled = Instrument.control(
        "":SENS<ch>:LINT:DET?"", "":SENS<ch>:LINT:DET %d"",
        """"""A boolean property that controls whether long integration detection
        mode is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_voltage = Instrument.control(
        "":SOUR<ch>:VOLT?"", "":SOUR<ch>:VOLT %g"",
        """"""A floating point property that controls the source voltage in volts,
        which takes values between 0 and 15. """""",
        validator=truncated_range,
        values=[0, 15],
    )

    source_voltage_protection = Instrument.control(
        "":SOUR<ch>:VOLT:PROT?"", "":SOUR<ch>:VOLT:PROT %g"",
        """"""A floating point property that controls the source voltage protection
        offset in volts, which takes values between 0 and 8. """""",
        validator=truncated_range,
        values=[0, 8],
    )

    source_voltage_protection_enabled = Instrument.measurement(
        "":SOUR<ch>:VOLT:PROT:STAT?"",
        """"""A boolean property that returns the source voltage protection state.
        If this property is True, the source has been shut off in accordance
        with the source voltage protection settings. If this property is False,
        the source has not been shut off due to voltage protection. """""",
        cast=bool
    )

    source_voltage_protection_clamp_enabled = Instrument.control(
        "":SOUR<ch>:VOLT:PROT:CLAM?"", "":SOUR<ch>:VOLT:PROT:CLAM %d"",
        """"""A boolean property that controls whether source voltage protection
        clamp is enabled. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_current_limit = Instrument.control(
        "":SOUR<ch>:CURR?"", "":SOUR<ch>:CURR %g"",
        """"""A floating point property that controls the source current limit in
        amps, which takes values between 0.006 and 5. """""",
        validator=truncated_range,
        values=[0.006, 5],
    )

    source_current_limit_type = Instrument.control(
        "":SOUR<ch>:CURR:TYPE?"", "":SOUR<ch>:CURR:TYPE %s"",
        """"""A string property that controls source current limit type, which can
        take the values 'limit' or 'trip'. """""",
        validator=strict_discrete_set,
        values={'limit': 'LIM', 'trip': 'TRIP'},
        map_values=True,
    )

    source_current_limit_enabled = Instrument.measurement(
        "":SOUR<ch>:CURR:STAT?"",
        """"""A boolean property that returns the source current limit state. If
        this property is True, the source is in either in current limit mode,
        or has tripped (shut off), based on the `source_current_limit_type`
        setting. If this property is False, the source is not being limited and
        has not been tripped. """""",
        cast=bool
    )

    last_reading = Instrument.measurement(
        "":FETCH<ch>?"",
        """"""A floating point property that returns the last reading. """"""
    )

    last_readings = Instrument.measurement(
        "":FETCH<ch>:ARR?"",
        """"""A floating point array property that returns the last readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    reading = Instrument.measurement(
        "":READ<ch>?"",
        """"""A floating point property that triggers and returns a reading
        in accordance with sense_mode. """"""
    )

    readings = Instrument.measurement(
        "":READ<ch>:ARR?"",
        """"""A floating point array property that triggers and returns readings
        in accordance with sense_mode. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    measured_voltage = Instrument.measurement(
        "":MEAS<ch>:VOLT?"",
        """"""A floating point property that triggers and returns a voltage
        reading. """"""
    )

    measured_voltages = Instrument.measurement(
        "":MEAS<ch>:ARR:VOLT?"",
        """"""A floating point array property that triggers and returns
        voltage readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    measured_current = Instrument.measurement(
        "":MEAS<ch>:CURR?"",
        """"""A floating point property that triggers and returns a current
        reading. """"""
    )

    measured_currents = Instrument.measurement(
        "":MEAS<ch>:ARR:CURR?"",
        """"""A floating point array property that triggers and returns
        current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    dvm_voltage = Instrument.measurement(
        "":MEAS<ch>:DVM?"",
        """"""A floating point property that triggers and returns a DVM voltage
        reading. """"""
    )

    dvm_voltages = Instrument.measurement(
        "":MEAS<ch>:ARR:DVM?"",
        """"""A floating point array property that triggers and returns
        DVM voltage readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    pulse_current = Instrument.measurement(
        "":MEAS<ch>:PCUR?"",
        """"""A floating point property that returns a pulse current reading. """"""
    )

    pulse_currents = Instrument.measurement(
        "":MEAS<ch>:ARR:PCUR?"",
        """"""A floating point array property that triggers and returns
        pulse current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    long_integration_current = Instrument.measurement(
        "":MEAS<ch>:LINT?"",
        """"""A floating point property that returns a long integration current
        reading. """"""
    )

    long_integration_currents = Instrument.measurement(
        "":MEAS<ch>:ARR:LINT?"",
        """"""A floating point array property that triggers and returns
        long integration current readings. """""",
        get_process=lambda v: v if isinstance(v, list) else [v]
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        return self.instrument.values(command.replace(""<ch>"", str(self.number)),
                                      **kwargs)

    def write(self, command):
        self.instrument.write(command.replace(""<ch>"", str(self.number)))


class BatteryChannel(Channel):
    """""" Implementation of a Keithley 2306 battery channel. """"""

    impedance = Instrument.control(
        "":OUTPUT<ch>:IMP?"", "":OUTPUT<ch>:IMP %g"",
        """"""A floating point property that controls the output impedance in ohms.
        Takes values from 0 to 1, in 10 milliohm steps."""""",
        validator=truncated_range,
        values=[0, 1],
    )

    pulse_current_step_enabled = Instrument.control(
        "":SENS<ch>:PCUR:STEP?"", "":SENS<ch>:PCUR:STEP %d"",
        """"""A boolean property that controls whether a series of pulse current
        step measurements is enabled."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    pulse_current_step_up_count = Instrument.control(
        "":SENS<ch>:PCUR:STEP:UP?"", "":SENS<ch>:PCUR:STEP:UP %d"",
        """"""An integer property that controls the number of up steps. Takes
        values from 0 to 20 (max is both up and down combined). """""",
        validator=truncated_range,
        values=[0, 20],
    )

    pulse_current_step_down_count = Instrument.control(
        "":SENS<ch>:PCUR:STEP:DOWN?"", "":SENS<ch>:PCUR:STEP:DOWN %d"",
        """"""An integer property that controls the number of down steps. Takes
        values from 0 to 20 (max is both up and down combined). """""",
        validator=truncated_range,
        values=[0, 20],
    )

    pulse_current_step_time = Instrument.control(
        "":SENS<ch>:PCUR:STEP:TIME?"", "":SENS<ch>:PCUR:STEP:TIME %g"",
        """"""A floating point property that controls the integration time for up
        plus down steps in seconds. Takes values from 33.33333e-06 to 100e-3. """""",
        validator=truncated_range,
        values=[33.33333e-06, 100e-3],
    )

    pulse_current_step_timeout = Instrument.control(
        "":SENS<ch>:PCUR:STEP:TOUT?"", "":SENS<ch>:PCUR:STEP:TOUT %g"",
        """"""A floating point property that controls the integration timeout for
        pulse current steps in seconds (for all but the first step). Takes values
        from 2e-3 to 200e-3. """""",
        validator=truncated_range,
        values=[2e-3, 200e-3],
    )

    pulse_current_step_timeout_initial = Instrument.control(
        "":SENS<ch>:PCUR:STEP:TOUT:INIT?"", "":SENS<ch>:PCUR:STEP:TOUT:INIT %g"",
        """"""A floating point property that controls the integration timeout for
        the initial pulse current step in seconds. Takes values from 10e-3
        to 60. """""",
        validator=truncated_range,
        values=[10e-3, 60],
    )

    pulse_current_step_delay = Instrument.control(
        "":SENS<ch>:PCUR:STEP:DEL?"", "":SENS<ch>:PCUR:STEP:DEL %g"",
        """"""A floating point property that controls the pulse current step delay
        in seconds. Takes values from 0 to 100e-3 in 10e-6 increments. """""",
        validator=truncated_range,
        values=[0, 100e-3],
    )

    pulse_current_step_range = Instrument.control(
        "":SENS<ch>:PCUR:STEP:RANG?"", "":SENS<ch>:PCUR:STEP:RANG %g"",
        """"""A floating point property that controls the pulse current step trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    pulse_current_trigger_level_range = Instrument.control(
        "":SENS<ch>:PCUR:SYNC:TLEV:RANG?"", "":SENS<ch>:PCUR:SYNC:TLEV:RANG %g"",
        """"""A floating point property that controls the pulse current trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    long_integration_trigger_level_range = Instrument.control(
        "":SENS<ch>:LINT:TLEV:RANG?"", "":SENS<ch>:LINT:TLEV:RANG %g"",
        """"""A floating point property that controls the long integration trigger
        level range in amps. Takes values of 100e-3, 1, or 5. """""",
        validator=strict_discrete_set,
        values=[100e-3, 1, 5],
    )

    def pulse_current_step(self, step_number):
        """"""Create a new current step point for this instrument.

        :param: step_number:
            int: the number of the step to be created
        :type: :class:`.Step`

        """"""
        return Step(self.instrument, step_number)


class Step():
    """""" Implementation of a Keithley 2306 step. """"""

    trigger_level = Instrument.control(
        "":SENS:PCUR:STEP:TLEV<step>?"", "":SENS:PCUR:STEP:TLEV<step> %g"",
        """"""A floating point property that controls the pulse current step trigger
        level range in amps. Takes values from 0 up to the range set via
        pulse_current_step_range."""""",
        validator=truncated_range,
        values=[0, 5],
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        return self.instrument.values(command.replace(""<step>"", str(self.number)),
                                      **kwargs)

    def write(self, command):
        self.instrument.write(command.replace(""<step>"", str(self.number)))


class Relay():
    """""" Implementation of a Keithley 2306 relay. """"""

    closed = Instrument.control(
        ""?"", "" %s"",
        """"""A boolean property that controls whether the relay is closed (True)
        or open (False). """""",
        validator=strict_discrete_set,
        values={True: 'ONE', False: 'ZERO'},
        map_values=True
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        return self.instrument.values("":OUTP:REL%d%s"" % (
            self.number, command), **kwargs)

    def write(self, command):
        self.instrument.write("":OUTP:REL%d%s"" % (self.number, command))


class Keithley2306(Instrument):
    """""" Represents the Keithley 2306 Dual Channel Battery/Charger Simulator.
    """"""

    def __init__(self, adapter, name=""Keithley 2306"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ch1 = BatteryChannel(self, 1)
        self.ch2 = Channel(self, 2)
        self.relay1 = Relay(self, 1)
        self.relay2 = Relay(self, 2)
        self.relay3 = Relay(self, 3)
        self.relay4 = Relay(self, 4)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """"""A boolean property that controls whether the display is enabled,
        takes values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    display_brightness = Instrument.control(
        "":DISP:BRIG?"", "":DISP:BRIG %g"",
        """"""A floating point property that controls the display brightness,
        takes values beteween 0.0 and 1.0. A blank display is 0.0,
        1/4 brightness is for values less or equal to 0.25, otherwise 1/2
        brightness for values less than or equal to 0.5, otherwise 3/4
        brightness for values less than or equal to 0.75, otherwise full
        brightness. """""",
        validator=truncated_range,
        values=[0, 1],
    )

    display_channel = Instrument.control(
        "":DISP:CHAN?"", "":DISP:CHAN %d"",
        """"""An integer property that controls the display channel, takes
        values 1 or 2. """""",
        validator=strict_discrete_set,
        values=[1, 2],
    )

    display_text_data = Instrument.control(
        "":DISP:TEXT:DATA?"", "":DISP:TEXT:DATA \""%s\"""",
        """"""A string property that control text to be displayed, takes strings
        up to 32 characters. """""",
        get_process=lambda v: v.replace('""', '')
    )

    display_text_enabled = Instrument.control(
        "":DISP:TEXT:STAT?"", "":DISP:TEXT:STAT %d"",
        """"""A boolean property that controls whether display text is enabled,
        takes values True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    both_channels_enabled = Instrument.setting(
        "":BOTHOUT%s"",
        """"""A boolean setting that controls whether both channel outputs are
        enabled, takes values of True or False. """""",
        validator=strict_discrete_set,
        values={True: ""ON"", False: ""OFF""},
        map_values=True,
    )

    def ch(self, channel_number):
        """"""Get a channel from this instrument.

        :param: channel_number:
            int: the number of the channel to be selected
        :type: :class:`.Channel`

        """"""
        if channel_number == 1:
            return self.ch1
        elif channel_number == 2:
            return self.ch2
        else:
            raise ValueError(""Invalid channel number. Must be 1 or 2."")

    def relay(self, relay_number):
        """"""Get a relay channel from this instrument.

        :param: relay_number:
            int: the number of the relay to be selected
        :type: :class:`.Relay`

        """"""
        if relay_number == 1:
            return self.relay1
        elif relay_number == 2:
            return self.relay2
        elif relay_number == 3:
            return self.relay3
        elif relay_number == 4:
            return self.relay4
        else:
            raise ValueError(""Invalid relay number. Must be 1, 2, 3, or 4"")
"
68,5420.0,USA,"The new Keysight N7776C top line tunable laser source is designed to reach best-in-class accuracy in static and swept operation for outstanding test efficiency. Two-way sweeps up to 200 nm/s speed with sub-picometer repeatability and without impacting the specified dynamic accuracy accelerate wavelength-dependent alignment processes and the automated calibration of wavelength-selective devices. Shorter time to testing and faster swept-wavelength tests help reduce test cost per device, improve test margins and lower the cost of ownership.

",Keysightn 7776 C,319.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Pymeasure,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT N7776C Lasers,https://en.wikipedia.org/wiki/Laser_diode,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction",KEYSIGHT N7776C,https://www.keysight.com/us/en/assets/3119-1067/data-sheets/5992-4217.pdf,"[OrderedDict([('id', 'attyzP9nvI5xJDqWR'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cBorXeOnYJR_i3tbtcv_4w/dZDUHO-_Ad8gqS3Ho_BmaqB7GByr3VCz98QVG3PkKu0WRCDdKpC3q4ydsHjakAzjTkuimNx7hYC9xiAeePunclgnkjLGWCda8Mr4EhGE7B578wLNg_4HHEjY6QjDwN7J/lCYODbEXR9eQFYc8fCQT1kr2rkPVSJGayemiVLR8AU0'), ('filename', 'N7776C_FR_TRANS_SHAD_1600x900.png'), ('size', 1045757), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7_DAgjIKsgWkSI1p-84YTg/9A9CRoCWvqfgkQrTRCMw_bE3iqMqWvFQ0VguJNJifg167YxFXPmLgiRmgZfUmDxOGD5UcPIdgpuB9XkPWqLCCw/1GDy16mSH7AJbaJH5fNKF5c5K1anDAAgXYWoGGYgxUw'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Vts0RkMHrvM4J7U7tDMG_A/ecq7_N2K9tHiy4CraeGVDoeo32gL5FWhxCMpYa-iuixOc8Z6NMMidh1iY160R6L7ChksI4h-kV2189b5ekbtmQ/xcT3AKyRucYzrUJHgYGpubwZe86OxAYfNoeh_gEPtaE'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ooTJzt5uXJQSqQEuvZWOfg/dT0SFStiKgTcNP01WckJjj0DDGATmdhVwYKMXhHKzLEHHmTv4haqcMKz9DKUCZy0klASneAw9_GtjI7q9vptNw/YLaI1fsmG0zhbNiLerCtq7Pdtx0B5aTMP23mnRipSZ0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/N7776C/tunable-laser-source-high-power-lowest-sse-top-line.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightN7776C.py,,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

WL_RANGE = [1480, 1620]
LOCK_PW = 1234


class KeysightN7776C(Instrument):
    """"""
    This represents the Keysight N7776C Tunable Laser Source interface.

    .. code-block:: python

        laser = N7776C(address)
        laser.sweep_wl_start = 1550
        laser.sweep_wl_stop = 1560
        laser.sweep_speed = 1
        laser.sweep_mode = 'CONT'
        laser.output_enabled = 1
        while laser.sweep_state == 1:
            log.info('Sweep in progress.')
        laser.output_enabled = 0

    """"""

    def __init__(self, adapter, name=""N7776C Tunable Laser Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs)

    locked = Instrument.control(
        ':LOCK?', ':LOCK %g,' + str(LOCK_PW),
        """""" Boolean property controlling the lock state (True/False) of the laser source"""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    output_enabled = Instrument.control(
        'SOUR0:POW:STAT?', 'SOUR0:POW:STAT %g',
        """""" Boolean Property that controls the state (on/off) of the laser source """""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0}
    )

    _output_power_mW = Instrument.control(
        'SOUR0:POW?', 'SOUR0:POW %f mW',
        """""" Floating point value indicating the laser output power in mW."""""",
        get_process=lambda v: v * 1e3
    )

    _output_power_dBm = Instrument.control(
        'SOUR0:POW?', 'SOUR0:POW %f dBm',
        """""" Floating point value indicating the laser output power in dBm.""""""
    )

    _output_power_unit = Instrument.control(
        'SOUR0:POW:UNIT?', 'SOUR0:POW:UNIT %g',
        """""" String parameter controlling the power unit used internally by the laser."""""",
        map_values=True,
        values={'dBm': 0, 'mW': 1}
    )

    @property
    def output_power_mW(self):
        self._output_power_unit = 'mW'
        return self._output_power_mW

    @output_power_mW.setter
    def output_power_mW(self, new_power):
        self._output_power_mW = new_power

    @property
    def output_power_dBm(self):
        self._output_power_unit = 'dBm'
        return self._output_power_dBm

    @output_power_dBm.setter
    def output_power_dBm(self, new_power):
        self._output_power_dBm = new_power

    trigger_out = Instrument.control(
        'TRIG0:OUTP?', 'TRIG0:OUTP %s',
        """""" Specifies if and at which point in a sweep cycle an output trigger
        is generated and arms the module. """""",
        validator=strict_discrete_set,
        values=['DIS', 'STF', 'SWF', 'SWST']
    )

    trigger_in = Instrument.control('TRIG0:INP?', 'TRIG0:INP %s',
                                    """""" Sets the incoming trigger response and arms the module. """""",
                                    validator=strict_discrete_set,
                                    values=['IGN', 'NEXT', 'SWS'])

    wavelength = Instrument.control('sour0:wav?', 'sour0:wav %fnm',
                                    """""" Absolute wavelength of the output light (in nanometers)"""""",
                                    validator=strict_range,
                                    values=WL_RANGE,
                                    get_process=lambda v: v * 1e9)

    sweep_wl_start = Instrument.control('sour0:wav:swe:star?', 'sour0:wav:swe:star %fnm',
                                        """""" Start Wavelength (in nanometers) for a sweep."""""",
                                        validator=strict_range,
                                        values=WL_RANGE,
                                        get_process=lambda v: v * 1e9)
    sweep_wl_stop = Instrument.control('sour0:wav:swe:stop?', 'sour0:wav:swe:stop %fnm',
                                       """""" End Wavelength (in nanometers) for a sweep."""""",
                                       validator=strict_range,
                                       values=WL_RANGE,
                                       get_process=lambda v: v * 1e9)

    sweep_step = Instrument.control('sour0:wav:swe:step?', 'sour0:wav:swe:step %fnm',
                                    """""" Step width of the sweep (in nanometers)."""""",
                                    validator=strict_range,
                                    values=[0.0001, WL_RANGE[1] - WL_RANGE[0]],
                                    get_process=lambda v: v * 1e9)
    sweep_speed = Instrument.control('sour0:wav:swe:speed?', 'sour0:wav:swe:speed %fnm/s',
                                     """""" Speed of the sweep (in nanometers per second)."""""",
                                     validator=strict_discrete_set,
                                     values=[0.5, 1, 50, 80, 200],
                                     get_process=lambda v: v * 1e9)
    sweep_mode = Instrument.control('sour0:wav:swe:mode?', 'sour0:wav:swe:mode %s',
                                    """""" Sweep mode of the swept laser source """""",
                                    validator=strict_discrete_set,
                                    values=['STEP', 'MAN', 'CONT'])
    sweep_twoway = Instrument.control('sour0:wav:swe:rep?', 'sour0:wav:swe:rep %s',
                                      """"""Sets the repeat mode. Applies in stepped,continuous and
                                      manual sweep mode."""""",
                                      validator=strict_discrete_set,
                                      map_values=True,
                                      values={False: 'ONEW', True: 'TWOW'})
    _sweep_params_consistent = Instrument.measurement(
        'sour0:wav:swe:chec?',
        """"""Returns whether the currently set sweep parameters (sweep mode, sweep start,
        stop, width, etc.) are consistent. If there is a
        sweep configuration problem, the laser source is not
        able to pass a wavelength sweep."""""")

    sweep_points = Instrument.measurement(
        'sour0:read:points? llog',
        """"""Returns the number of datapoints that the :READout:DATA?
        command will return."""""")

    sweep_state = Instrument.control('sour0:wav:swe?', 'sour0:wav:swe %g',
                                     """""" State of the wavelength sweep. Stops, starts, pauses
                                     or continues a wavelength sweep. Possible state values are
                                     0 (not running),
                                     1 (running) and
                                     2 (paused).
                                     Refer to the N7776C user manual for exact usage of the
                                     paused option. """""",
                                     validator=strict_discrete_set,
                                     values=[0, 1, 2])

    wl_logging = Instrument.control('SOUR0:WAV:SWE:LLOG?', 'SOUR0:WAV:SWE:LLOG %g',
                                    """""" State (on/off) of the lambda logging feature of the
                                    laser source."""""",
                                    validator=strict_discrete_set,
                                    map_values=True,
                                    values={True: 1, False: 0})

    def valid_sweep_params(self):
        response = int(self._sweep_params_consistent[0])
        if response == 0:
            return True
        elif response == 368:
            log.warning('End Wavelength <= Start Wavelength.')
        elif response == 369:
            log.warning('Sweep time too small.')
        elif response == 370:
            log.warning('Sweep time too big.')
        elif response == 371:
            log.warning('Trigger Frequency too large.')
        elif response == 372:
            log.warning('Stepsize too small.')
        elif response == 373 or response == 378:
            log.warning('Number of triggers exceeds allowed limit.')
        elif response == 374:
            log.warning('The only allowed modulation source with lambda logging \
                        function is coherence control.')
        elif response == 375:
            log.warning('Lambda logging only works Step Finished output trigger configuration')
        elif response == 376:
            log.warning('Lambda logging can only be done in continuous sweep mode')
        elif response == 377:
            log.warning('The step size must be a multiple of the smallest possible step size')
        elif response == 379:
            log.warning('Continuous Sweep and Modulation on.')
        elif response == 380:
            log.warning('Start Wavelength is too small.')
        elif response == 381:
            log.warning('End Wavelength is too large.')
        else:
            log.warning('Unknown Error!')
        return False

    def next_step(self):
        """"""
        Performs the next sweep step in stepped sweep if it is paused or in manual mode.
        """"""
        self.write('sour0:wav:swe:step:next')

    def previous_step(self):
        """"""
        Performs one sweep step backwards in stepped sweep if its paused or in manual mode.
        """"""
        self.write('sour0:wav:swe:step:prev')

    def get_wl_data(self):
        """"""
        Function returning the wavelength data logged in the internal memory of the laser
        """"""
        # Using pyvisa's method bypassing the normal read.
        return np.array(self.adapter.connection.query_binary_values('sour0:read:data? llog',
                        datatype=u'd'))

    def close(self):
        """"""
        Fully closes the connection to the instrument through the adapter connection.
        """"""
        self.adapter.close()
"
69,5800.0,USA,"The TDS1000 Series and TDS2000 Series digital storage oscilloscopes deliver an unbeatable combination of superior performance, unmatched ease-of-use, and affordability in an ultra lightweight, portable package.",TDS 2000,540.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Pymeasure,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a TDS2000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TDS2000,https://download.tek.com/datasheet/3GW_15314_6.pdf,"[OrderedDict([('id', 'attdL6BvdnNPHWFdN'), ('width', 500), ('height', 344), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KJcMT-_ZklOcjWI3k_sKBQ/40MLl_b5sZV5QTK7-WkDVYfxC_0A_MBMWGcXwHD6zPTL4Zw3Npa0HQv2DNRISnBzgUP7heekt-iq_FcMKKprw2cCnzUBkbPNhcfPgCURfuo/eSswnQfHTp2vR8nKG9j48QEXhwEoZ6Bj3kZ0EbmnERw'), ('filename', 'TDS2000C-1.jpg'), ('size', 27591), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dtgH31lPEfu11TpyHUcMCg/IoesnjEFg-b6A8VfOaDV_jT8TswENvTPtyxpo6WolsvcGyD0uHBi4yjlwKNBBvo2yYDipmpyjIP3NFUuLZaq9w/nHaVDEz_Y9gEstiYYSyFtvmmqKd9CIjuWCaqw2e1-b4'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/K-keKD-it2fbxTrA84848Q/hv4iZY4pJGP0ilG_qazH8SyE3iMBN4bDfBlzy3dzWAo631Vw2YualWIV4ke2OJUz-nVQ34e1w9rw-XYLxHXt0Q/6XEqR4BfFf0e-BmvUBsNl0NrxLnRLDyj-hNSh_RSYSc'), ('width', 500), ('height', 344)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nVHDt8Kz9n92wSTzcxmG8Q/RNM_kv7h3qNZODdA7QUYNBHsVIDjk7PQ3wMdiLto8J-zSEnEg_AkKcvtxV_Vq3aZ2Kc-fCJIfgw8LcOz9KPqfw/99AWtfzPvegjVryxRQ09P1de4NVgzIJagWVD-E1gOQk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/oscilloscopes/tds2000-digital-storage-oscilloscope,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/tektronix/tds2000.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/tektronix/tds2000.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


class TDS2000(Instrument):
    """""" Represents the Tektronix TDS 2000 Oscilloscope
    and provides a high-level for interacting with the instrument
    """"""

    class Measurement:

        SOURCE_VALUES = ['CH1', 'CH2', 'MATH']

        TYPE_VALUES = [
            'FREQ', 'MEAN', 'PERI', 'PHA', 'PK2', 'CRM',
            'MINI', 'MAXI', 'RIS', 'FALL', 'PWI', 'NWI'
        ]

        UNIT_VALUES = ['V', 's', 'Hz']

        def __init__(self, parent, preamble=""MEASU:IMM:""):
            self.parent = parent
            self.preamble = preamble

        @property
        def value(self):
            return self.parent.values(""%sVAL?"" % self.preamble)

        @property
        def source(self):
            return self.parent.ask(""%sSOU?"" % self.preamble).strip()

        @source.setter
        def source(self, value):
            if value in TDS2000.Measurement.SOURCE_VALUES:
                self.parent.write(f""{self.preamble}SOU {value}"")
            else:
                raise ValueError(""Invalid source ('{}') provided to {}"".format(
                                 self.parent, value))

        @property
        def type(self):
            return self.parent.ask(""%sTYP?"" % self.preamble).strip()

        @type.setter
        def type(self, value):
            if value in TDS2000.Measurement.TYPE_VALUES:
                self.parent.write(f""{self.preamble}TYP {value}"")
            else:
                raise ValueError(""Invalid type ('{}') provided to {}"".format(
                                 self.parent, value))

        @property
        def unit(self):
            return self.parent.ask(""%sUNI?"" % self.preamble).strip()

        @unit.setter
        def unit(self, value):
            if value in TDS2000.Measurement.UNIT_VALUES:
                self.parent.write(f""{self.preamble}UNI {value}"")
            else:
                raise ValueError(""Invalid unit ('{}') provided to {}"".format(
                                 self.parent, value))

    def __init__(self, adapter, name=""Tektronix TDS 2000 Oscilliscope"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.measurement = TDS2000.Measurement(self)
"
70,13.0,Denmark,The System 8500 Power Supply program offers the ultrastable Model 854 specially designed for powering magnets in MRI applications,Danfysik 8500,116.0,"Danfysik accelerator system and accelerator components are in service at most particle accelerator facilities worldwide
",Pymeasure,Danfysik,"[OrderedDict([('id', 'atths1QV2NfuQ9sTz'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t1vIJ5JV_SG7hBFYBaTJEg/er27iZlJM4wriXoQ4Pelz1JHWnseakitTGfhWT6eAmRt-Cgm5yMeFtbhd1BvhdldxSYJpn6Yf2DJvhifmQ7BOl5Ej-Czp3S3Zf6SexPFaGQ/DLU2m6JH-1BpCOs8ZeGIfwh3sf1vRt06AuKXHv-wr38'), ('filename', '52408-27d3b659.png'), ('size', 3404), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2RonDtgZSpTBLOi2FqwmZA/gipTU1YvrDZyQkk_9_K_sr9NyVpbYzKTOxfRwUaqHYfJmHP3xBB_6mcc3BMxiIhYFM_HkDzXZfy9GQk7bYXVhQ/sEoJlpVI4OMUAuQlHTQHP7MWXEC_uufdQS1JFHKh5uA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SQlrdaYY6Or-aTlBNXs_kg/T-gXptvQQq7NJJyfaXjHsTMNDZvfIEu2AlV7l0ZQD4Xj1cjfp6a-1xYmYXvPJ4LG4-wxfXweJ4-c_XnGlE8GEQ/N8mh7WuHfvqnoM4-MHvZwTiXkvk89JhIJXR_crHE1EM'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/w9Y0omAykC4sEwyxGM5glA/0RxAAjBeTZqab7bzGwfd7lTAsJPPpQQpOMvo5dEx1R8__MnyTq6qBqulpKJJCLg6D9Nvnm63kJe-D1C9i-TONQ/oMcUkM4KCJrqL2i-Qi-WXPlFMEcrnCfRXkBEI6f_quw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.danfysik.com/en,Write a Python script that uses Pymeasure to connect to a SYSTEM 8500 - Model 854 Power Supplies,https://www.danfysik.com/en/products/power-supplies/superconducting/,['Power Supplies'],"Power Supply for Super conducting Application
",SYSTEM 8500 - Model 854,https://www.danfysik.com/media/1098/model-854-datasheet.pdf,"[OrderedDict([('id', 'attXQedGaxRf2PkVA'), ('width', 545), ('height', 342), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/STD4zTGirHNX_QOl7HW3fg/bpLc8PK2mfaR_42t-gKYaIxksfACO8zl25KrzVX_lySSYSBKhFrJd7wZYJYzH6qdjrGIVGibM92H9tLIEJt-fRzJcsCQyqv9Ijxjje4buL8/3obstSMikit2kJ0XMYn7CvBp-aHZfzekqpQmA7r9gFo'), ('filename', '9f5a4387.jpg'), ('size', 55923), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8t4D4a8DtlKxImNxKl0nMg/pq845sUAe-JHUAPxOePM1ZKAjntybtRwQ9kuB466zEVCyKJ7vCjHNy9o3T1YIi69yqv0C4Dc0uo5K31PXmRV8g/efLBDCF0_Lk-g82-PD_QLdZMBkR6ig6-zIMYR4QRJl4'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EK8xDlylgb84mr8s3toJWQ/y1LmW3I0ZUyrdc1TgRCCIfNOBA4-Bo7BgYas1igfCmd64gH2EbSMTr4Wc_dNIXLPn3q2R_fSuZNRWvE64kzHnA/WX1rwEBoh9fnz3bNql6rZQ3n5wQo8wopX3CN-AQsOqM'), ('width', 545), ('height', 342)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eL0SG7TGqRP0TI082Dj8hw/U4TDvSLstWAwCRhtW4UI0mU6WpWY-aOoEOzy3lLcIP3o6lvrMwTnRiWw2SP_kq5ZQSdFgbUrtZHrXJd-bpiAVg/FuGyuBq5N6KRMvlwzD4Ss1EgV9tA76sog8JV_nSE89U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.danfysik.com/media/1098/model-854-datasheet.pdf,https://github.com/pymeasure/pymeasure/blob/master/docs/api/instruments/danfysik/danfysik8500.rst,https://pymeasure.readthedocs.io/en/latest/api/instruments/danfysik/danfysik8500.html,,,,Github Project too ld,"##########################
Danfysik 8500 Power Supply
##########################

.. autoclass:: pymeasure.instruments.danfysik.Danfysik8500
    :members:
    :show-inheritance:"
76,24.9,"Sunnyvale, California","The SG380 Series RF Signal Generators use a unique, innovative architecture (Rational Approximation Frequency Synthesis) to deliver ultra-high frequency resolution (1 µHz), excellent phase noise, and versatile modulation capabilities (AM, FM, ØM, pulse modulation and sweeps) at a fraction of the cost of competing designs. The standard models produce sine waves from DC to 2.025 GHz (SG382), 4.05 GHz (SG384) and 6.075 GHz (SG386).",SG 380,518.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Pymeasure,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Pymeasure to connect to a {Device name} RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",,https://www.thinksrs.com/downloads/pdfs/catalog/SG380c.pdf,"[OrderedDict([('id', 'attJpMTKKFLWIt0jZ'), ('width', 2916), ('height', 2136), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VoDX3fKOR54Ppw-0SWCkhQ/Xjzwd-IYS4RzBQwnymQrEbdmOiKHc52OVRtacRLOUyy7fyFKeadiwUORZedGpR4cpSMmX4hBqSB5vemIL6e39knHPOLJ6QeKv8e5-snbaGE/JSZPJpfYyrlMXCc1mSjdXz8lCUcuqVv_B7cOlPARO7c'), ('filename', 'SG382 ReflectR.jpg'), ('size', 1271602), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xohSoqfB66TrrppPOecDQw/awJZ9RmXMaa1NaMVlg7ypWGdFlINf462zfXymoNBybaRJQxtSEG12RjAj1rSpe0TuhIXMXBPZfohFTfArNDiBg/qVUvYlj_mnWfGAKboe71CBJQPGk6H_FofXAVsh-LG70'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8pFhd5_CtThsmw1Ioev2BA/sN-vcBBYYAMhsF0l2tOyCZxanGDuzDSBDKmVP3q17G2RoIIjNED7iIiT4Cto1q1T_JVWcx-OpNi7HgTorFqkpQ/IOevsZGoYHZb4qgnkWpM5tfT41rbizp7MI965FEdcDQ'), ('width', 699), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kqcKvrABi7p-tytcS2nkpQ/GaWZX-VLiiJWEtWzHPn6q0h20e_OYn-3-sp8DKDpiUscmmyu1_4XXDvnHPGyXmHLFVqt-9hmzi3MVr2kjJ2hGg/Q-6Uxqr366IdoWrXWlH3sw5BIBEC8w4QMEpi_LO4T78'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sg380.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sg380.py,,3900.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range


class SG380(Instrument):

    MOD_TYPES_VALUES = ['AM', 'FM', 'PM', 'SWEEP', 'PULSE', 'BLANK', 'IQ']

    MOD_FUNCTIONS = ['SINE', 'RAMP', 'TRIANGLE', 'SQUARE', 'NOISE', 'EXTERNAL']

    MIN_RF = 0.0

    MAX_RF = 4E9

    # TODO: restrict modulation depth to allowed values (depending on
    # frequency)
    fm_dev = Instrument.control(
        ""FDEV?"", ""FDEV%.6f"",
        """""" A floating point property that represents the modulation frequency
        deviation in Hz. This property can be set. """"""
    )

    rate = Instrument.control(
        ""RATE?"", ""RATE%.6f"",
        """""" A floating point property that represents the modulation rate
        in Hz. This property can be set. """"""
    )

    def __init__(self, adapter, name=""Stanford Research Systems SG380 RF Signal Generator"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    @property
    def has_doubler(self):
        """"""Gets the modulation type""""""
        return bool(self.ask(""OPTN? 2""))

    @property
    def has_IQ(self):
        """"""Gets the modulation type""""""
        return bool(self.ask(""OPTN? 3""))

    @property
    def frequency(self):
        """"""Gets RF frequency""""""
        return float(self.ask(""FREQ?""))

    @frequency.setter
    def frequency(self, frequency):
        """"""Defines RF frequency""""""
        if self.has_doubler:
            truncated_range(frequency, (SG380.MIN_RF, 2 * SG380.MAX_RF))
        else:
            truncated_range(frequency, (SG380.MIN_RF, SG380.MAX_RF))
        self.write(""FREQ%.6f"" % frequency)

    @property
    def mod_type(self):
        """"""Gets the modulation type""""""
        return SG380.MOD_TYPES_VALUES[int(self.ask(""TYPE?""))]

    @mod_type.setter
    def mod_type(self, type_):
        """"""Defines the modulation type""""""
        if type_ not in SG380.MOD_TYPES_VALUES:
            raise RuntimeError('Undefined modulation type')
        elif (type_ == 'IQ') and not self.has_IQ:
            raise RuntimeError('IQ option not installed')
        else:
            index = SG380.MOD_TYPES_VALUES.index(type_)
        self.write(""TYPE%d"" % index)

    @property
    def mod_function(self):
        """"""Gets the modulation function""""""
        return SG380.MOD_FUNCTIONS[int(self.ask(""MFNC?""))]

    @mod_function.setter
    def mod_func(self, function):
        """"""Defines the modulation function""""""
        if function not in SG380.MOD_FUNCTIONS:
            index = 1
        else:
            index = SG380.MOD_FUNCTIONS.index(function)
        self.write(""MFNC%d"" % index)
"
81,5.0,Switzerland,"The APSINXXG is an analog signal generator (analog signal source) series covering RF and microwave frequency ranges from 9 kHz to 12, 20 and 26.5 GHz
",Apsin 12 G,75.0,"**AnaPico** is an ISO 9001:2015 certified technology leader, developing, manufacturing and supplying RF and MW test & measurement instruments

",Pymeasure,Anapico,"[OrderedDict([('id', 'att5A0dfCy70SahVz'), ('width', 400), ('height', 267), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M-D_ZXNzAd8XBmM7kldZ_A/n1sMuVb7lThfOFMqyIvY8qiPldatw_eSSm3FjATLR-f4DWAn5Y9Iiw2gWQo5VaQFuq2xD_C8gJMyd9B5T_IE5Dx7--gssSLON4Klm2UQZWU/SGg7z-2hYWZT5x-0J7X-aCDqSvTBwXtqN9HCltW3Kok'), ('filename', 'logo-e1591109604777.png'), ('size', 18323), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/riwQ0R9KTEI0jiU3EjkwvQ/tNh1J4ld-VxUJ2Er0g0iyuVVTRxVnUBNGwLh0cgEtQtN_o97-arrCeMfQv3uaaC9OZ6vwZ5EGNta1nwclwQzIA/zYxwCbkYQKrgt-kp4rjZ1XIJS2QyJWncMWPtHSMYP4Y'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Kodj7PunmyxQCRbyoSdkA/eOtByYJ7D-h74PdYTQAqJa0eNZb2nWT34jgF3BPLQKZc1qvnAPMuI6VAh3IrAYumNP194WJhJXJjAXli7tG5Ow/NWqWN8ifmEcnTJA2dMvEYMRG96d06R4r6MKMGvdLTMA'), ('width', 400), ('height', 267)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqUeYhPOCXFSFMxGPFubkg/uxFdy_WCcjzx_OILYQkHYz4_XVeNZldWhb2X8dLT3TihRhEoHC6V42baC0YndhvT5nIa-wpGeUp1fkqL_VIaTA/YxpQxLhiEHPVqX9vTtZlmJYxvbL-R-nYqh38izDzhaE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anapico.com/,Write a Python script that uses Pymeasure to connect to a Apsin 26G RF Signal Generator,https://www.anapico.com/category/rf-signal-generators/single-output-rf-and-microwave-signal-generators/,['RF Signal Generator']," Single-Output RF and Microwave Signal Generators
",Apsin 26G,"https://www.anapico.com/products/rf-signal-generators/single-output-rf-and-microwave-signal-generators/apsin-g-series-up-to-26-ghz/#:~:text=and%20outdoor%20fields.-,Download%20Datasheet,-Request%20for%20Quote","[OrderedDict([('id', 'attyViCZFSH3ReANV'), ('width', 100), ('height', 67), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g6OYI7iNShnEZxI7g8mIfw/A2aNOAcEUmaJ-2hSEZolzGE17mLJNuHGGwADayyac-6REj0hJA9FoJf6MZvZIcWN3BetXa5EXKsLOwX50FkO90kMwEl4KyxMbuisWcA8GEg/-kPnz2-OZbCGns3h-oXNesQWm3NhKDpRmy10fNYaatA'), ('filename', 'nerator_100.png'), ('size', 12427), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/N9UwhSGo1Wj4aGpYaG4_NQ/uE8zMn_pSxYaaFKEeBGnPa7dqX8_CHG6YXwGvh3otPAuzY-_jPiplbOE0puJQjKNaRhX7ObAUO_S1aHEIBQqMQ/QlFYjdzjB8fqSqSHRDWUknVf2hFZFdKiEE5VkBGeOQs'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NLcnU_j8W74s2nwAByevpQ/S5h1C8HiZFlc32WBuKHHmqC4wLD_aUMm3jMz0J0MV500N7j_4bj-Sb_k1SioS6Ojayfzn7q3Wk6QbHroGi3jtQ/94U5bZPLGlNaEWwIKE92NtQ637QLQdmhFK1P5birwNI'), ('width', 100), ('height', 67)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/swTHaJkat4RER0RuqbSq9Q/Mh8sO42RqUgsEDy_bxew1sMYvBjQGIrBhF1QtcD4VJt1_-8mJ10mVqsBrjQgbRqASpF9cDo4xNq3SDlAV-xAZQ/XK8oqG7h6dGZXu4CRK2AcDC0Ny6IOVM0eipc5rN2ptY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anapico.com/products/rf-signal-generators/single-output-rf-and-microwave-signal-generators/apsin-g-series-up-to-26-ghz/,https://pymeasure.readthedocs.io/en/latest/api/instruments/anapico/apsin12G.html,https://www.anapico.com/downloads/software-and-firmware/,,"
",,,
83,5420.0,USA,"The E4980A precision LCR meter provides the best combination of accuracy, speed, and versatility for a wide range of component measurements.",Agilent E4980,34.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT E4980A Multimeters,https://www.keysight.com/us/en/products/lcr-meters-impedance-measurement-products/bench-top-lcr-meters.html,['Multimeters'],"An LCR meter is a type of electronic test equipment used to measure the inductance (L), capacitance (C), and resistance (R) of an electronic component.[1]",KEYSIGHT E4980A,https://www.keysight.com/us/en/assets/7018-01355/data-sheets/5989-4435.pdf,"[OrderedDict([('id', 'attuZHiWXbmDgcXF9'), ('width', 1156), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Xsicoa-lYWwIpXK5EvacNw/imVE58EJXSNqdpvh9C6qGu9DBOJ_d5ysqTPC4f6OirH2fpFJ2LtS6bmoU_jGkIK5L2VkNj_x8yoFvhenP_khUA/7kjq8RB2eh3q9d5IUx710wKIi4nH8_DmlhwYkSJlB5s'), ('filename', 'LCR.png'), ('size', 475849), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_wDJtpHYjqPBwVR7XrNUJw/FF3WVwyK3PqvCh1cnV1U7fISJZujIcShohQN1hStuoVx2r7nS2cFlibs5qXKuFZ11B58L53fpr_tEWSXGxr4fA/r0-xKjECnLliA_ontjXeFCg0qTtNMxjeNUoxAWQoegw'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YKiPIilsme352TJth0Nraw/IpWpqjOcwPzsTHn_wQAQYpIwId0Tb6rnege6XadYmzppgz40Ri9tmDz8w0-BgNWUkipMUe5HnKb8peR5zgS4kA/VoKfZvkJHxyfDij1nnuKCpktsrILgxS-r8CPSF4VAls'), ('width', 769), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4JDu0zvrF6lPQyu8tMdCJQ/z-4H2cnpXFJ53hSHwTh3-vSlzgN5cpWMGHBVR3Ir2Ga_htrEaJrtQxDVZwBSVFGySHEhZrFLXs5AOSha1a9eOw/JqV6DjRaKSLb3NkMBEn1gRMqXVoFinThXu8PAAJOmzw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E4980A/precision-lcr-meter-20-hz-2-mhz.html,https://github.com/MariaPoliti/LCR/blob/master/setup.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentE4980.html,24253.0,,,,"import os

import setuptools
from setuptools import setup

setup(name='LCR',
      version=""0.1"",
      description='package to operate an Agilent/Keysight A4980E LCR meter \
                    using python',
      description_content_type='text/markdown; \
                                charset=UTF-8; variant=GFM',
      long_description=open('README.md', 'r').read(),
      long_description_content_type='text/markdown; \
                                     charset=UTF-8; variant=GFM',
      url='https://github.com/EISy-as-Py/hardy',
      license='MIT',
      author='Maria Polit',
      python_requires=""~=3.5"",

      packages=setuptools.find_packages())

classifiers = (""Programming Language :: Python :: 3"",
               ""License :: OSI Approved :: MIT License"",
               ""Operating System :: OS Independent"")
"
85,5420.0,USA,"The Agilent 8722ES Vector Network Analyzer (VNA) allows users to test a RF device’s amplitude and phase with one instrument. It works within 50 MHz to 40 GHz and enables the complete characterization of a device or network.

",Agilent 8722 ES,14.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT 8722ES  Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT 8722ES ,https://www.keysight.com/us/en/assets/7018-06749/technical-overviews/5091-3645.pdf,"[OrderedDict([('id', 'att2KtkUGjyFWiD7D'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/m_1lOuGwhz2PKyT8u-djZg/X-vJQJDsGmTKIoYkPsfNyZWU-GwnIUF6osTWgnbCphRh7eTD-UBAEjTqYjD9JZ4-EZS68BPrZcv1lAX8Tj7kicULyUN_jyS7SiVMo6SuqSA/_0AZ5GeoM8MsDgUAIsfr9amYTiW6WaCVMLb7bZkiakY'), ('filename', '8722ES.webp'), ('size', 15050), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/15I6qYIZubUEYK34U4VOSQ/pFeoDAdbHAiGNwOsRVhsHCrcde8r2lPWvVUWgkUrhIfK4FDuEeFIk5S3QPdq7ADl2YPGuHANqtlt_g4Pq-cB79nmiurM-WpnSmBzHgqFVys/jUg-l7aO_xwKnGQXPd0yyqqK2FuTsRINYdrc3F5y0AU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XDnQwpl0efyBGt6SIU1bog/E7bhL_gJMmrjk9osok3bW_vTOyhHtIQUsDUFi0ExY8tVW-9ptt9UH0U4uvV_V1qtMeZnBaqU_TkoPBlA_Sy8u85Yaxbo-3eVWRIRrEGhWbw/QqvtifZ1HSrCCbTeKO6hk-mXxNEan6PVXOdi4VthQOs'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7xu6gROsKsY8HNXLh5OcSA/0W9QZIAndx-tU9kFF36HyNCAar0yrWMnPWvwP5eEajWBa4VHTvBD6LrCYs6zHxWM-jpmrsNqACY0m49Hw0rDnmynr_qFySwp468K1iLEGX4/SMAP8cyatBODXNVUMk3QieL14tpYVXY7pB_IKIt1zmo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.cmc.ca/agilent-8722es-s-parameter-vector-network-analyzer-40-ghz/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent8722ES.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent8722ES.html,,"
",True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument, discreteTruncate, RangeException
from pyvisa import VisaIOError

import numpy as np
import re
from io import BytesIO
import warnings


class Agilent8722ES(Instrument):
    """""" Represents the Agilent8722ES Vector Network Analyzer
    and provides a high-level interface for taking scans of the
    scattering parameters.
    """"""

    SCAN_POINT_VALUES = [3, 11, 21, 26, 51, 101, 201, 401, 801, 1601]
    SCATTERING_PARAMETERS = (""S11"", ""S12"", ""S21"", ""S22"")
    S11, S12, S21, S22 = SCATTERING_PARAMETERS

    start_frequency = Instrument.control(
        ""STAR?"", ""STAR %e Hz"",
        """""" A floating point property that represents the start frequency
        in Hz. This property can be set.
        """"""
    )
    stop_frequency = Instrument.control(
        ""STOP?"", ""STOP %e Hz"",
        """""" A floating point property that represents the stop frequency
        in Hz. This property can be set.
        """"""
    )
    sweep_time = Instrument.control(
        ""SWET?"", ""SWET%.2e"",
        """""" A floating point property that represents the sweep time
        in seconds. This property can be set.
        """"""
    )
    averages = Instrument.control(
        ""AVERFACT?"", ""AVERFACT%d"",
        """""" An integer representing the number of averages to take. Note that
        averaging must be enabled for this to take effect. This property can be set.
        """""",
        cast=lambda x: int(float(x))  # need float() to convert scientific notation in strings
    )
    averaging_enabled = Instrument.control(
        ""AVERO?"", ""AVERO%d"",
        """""" A bool that indicates whether or not averaging is enabled. This property
        can be set."""""",
        cast=bool
    )

    def __init__(self, adapter, name=""Agilent 8722ES Vector Network Analyzer"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def set_fixed_frequency(self, frequency):
        """""" Sets the scan to be of only one frequency in Hz """"""
        self.start_frequency = frequency
        self.stop_frequency = frequency
        self.scan_points = 3

    @property
    def parameter(self):
        for parameter in Agilent8722ES.SCATTERING_PARAMETERS:
            if int(self.values(""%s?"" % parameter)) == 1:
                return parameter
        return None

    @parameter.setter
    def parameter(self, value):
        if value in Agilent8722ES.SCATTERING_PARAMETERS:
            self.write(""%s"" % value)
        else:
            raise Exception(""Invalid scattering parameter requested""
                            "" for Agilent 8722ES"")

    @property
    def scan_points(self):
        """""" Gets the number of scan points
        """"""
        search = re.search(r""\d\.\d+E[+-]\d{2}$"", self.ask(""POIN?""),
                           re.MULTILINE)
        if search:
            return int(float(search.group()))
        else:
            raise Exception(""Improper message returned for the""
                            "" number of points"")

    @scan_points.setter
    def scan_points(self, points):
        """""" Sets the number of scan points, truncating to an allowed
        value if not properly provided
        """"""
        points = discreteTruncate(points, Agilent8722ES.SCAN_POINT_VALUES)
        if points:
            self.write(""POIN%d"" % points)
        else:
            raise RangeException(""Maximum scan points (1601) for""
                                 "" Agilent 8722ES exceeded"")

    def set_IF_bandwidth(self, bandwidth):
        """""" Sets the resolution bandwidth (IF bandwidth) """"""
        allowedBandwidth = [10, 30, 100, 300, 1000, 3000, 3700, 6000]
        bandwidth = discreteTruncate(bandwidth, allowedBandwidth)
        if bandwidth:
            self.write(""IFBW%d"" % bandwidth)
        else:
            raise RangeException(""Maximum IF bandwidth (6000) for Agilent ""
                                 ""8722ES exceeded"")

    def set_averaging(self, averages):
        """"""Sets the number of averages and enables/disables averaging. Should be
        between 1 and 999""""""
        averages = int(averages)
        if not 1 <= averages <= 999:
            assert RangeException(""Set"", averages, ""must be in the range 1 to 999"")
        self.averages = averages
        self.averaging_enabled = (averages > 1)

    def disable_averaging(self):
        """"""Disables averaging""""""
        warnings.warn(
            ""Don't use disable_averaging(), use averaging_enabled = False instead"", FutureWarning)
        self.averaging_enabled = False

    def enable_averaging(self):
        """"""Enables averaging""""""
        warnings.warn(
            ""Don't use enable_averaging(), use averaging_enabled = True instead"", FutureWarning)
        self.averaging_enabled = True

    def is_averaging(self):
        """""" Returns True if averaging is enabled """"""
        warnings.warn(""Don't use is_averaging(), use averaging_enabled instead"", FutureWarning)
        return self.averaging_enabled

    def restart_averaging(self, averages):
        warnings.warn(""Don't use restart_averaging(), use scan_single() instead"", FutureWarning)
        self.scan_single()

    def scan(self, averages=None, blocking=None, timeout=None, delay=None):
        """""" Initiates a scan with the number of averages specified and
        blocks until the operation is complete.
        """"""
        if averages is not None or blocking is not None or timeout is not None or delay is not None:
            warnings.warn(
                ""averages, blocking, timeout, and delay arguments are no longer used by scan()"",
                FutureWarning
            )
        self.write(""*CLS"")
        self.scan_single()
        # All queries will block until the scan is done, so use NOOP? to check.
        # These queries will time out after several seconds though,
        # so query repeatedly until the scan finishes.
        while True:
            try:
                self.ask(""NOOP?"")
            except VisaIOError as e:
                if e.abbreviation != ""VI_ERROR_TMO"":
                    raise e
            else:
                break

    def scan_single(self):
        """""" Initiates a single scan """"""
        if self.averaging_enabled:
            self.write(""NUMG%d"" % self.averages)
        else:
            self.write(""SING"")

    def scan_continuous(self):
        """""" Initiates a continuous scan """"""
        self.write(""CONT"")

    @property
    def frequencies(self):
        """""" Returns a list of frequencies from the last scan
        """"""
        return np.linspace(
            self.start_frequency,
            self.stop_frequency,
            num=self.scan_points
        )

    @property
    def data_complex(self):
        """""" Returns the complex power from the last scan
        """"""
        # TODO: Implement binary transfer instead of ASCII
        data = np.loadtxt(
            BytesIO(self.ask(""FORM4;OUTPDATA"").encode()),
            delimiter=',',
            dtype=np.float32
        )
        data_complex = data[:, 0] + 1j * data[:, 1]
        return data_complex

    @property
    def data_log_magnitude(self):
        """""" Returns the absolute magnitude values in dB from the last scan
        """"""
        return 20 * np.log10(self.data_magnitude)

    @property
    def data_magnitude(self):
        """""" Returns the absolute magnitude values from the last scan
        """"""
        return np.abs(self.data_complex)

    @property
    def data_phase(self):
        """""" Returns the phase in degrees from the last scan
        """"""
        return np.degrees(np.angle(self.data_complex))

    @property
    def data(self):
        """""" Returns the real and imaginary data from the last scan
        """"""
        warnings.warn(""Don't use this function, use data_complex instead"", FutureWarning)
        data_complex = self.data_complex
        return data_complex.real, data_complex.complex

    def log_magnitude(self, real, imaginary):
        """""" Returns the magnitude in dB from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use log_magnitude(), use data_log_magnitude instead"", FutureWarning)
        return 20 * np.log10(self.magnitude(real, imaginary))

    def magnitude(self, real, imaginary):
        """""" Returns the magnitude from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use magnitude(), use data_magnitude"", FutureWarning)
        return np.sqrt(real**2 + imaginary**2)

    def phase(self, real, imaginary):
        """""" Returns the phase in degrees from a real and imaginary
        number or numpy arrays
        """"""
        warnings.warn(""Don't use phase(), use data_phase instead"", FutureWarning)
        return np.arctan2(imaginary, real) * 180 / np.pi
"
86,5420.0,USA,"The DSOX1102G oscilloscope provides 70, 100 MHz of bandwidth on 2 analog channels, and waveform generator

",Keysightdsox 1102 G,317.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Pymeasure,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT DSOX1102G Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization.",KEYSIGHT DSOX1102G,https://www.keysight.com/us/en/assets/7018-05520/data-sheets/5992-1965.pdf,"[OrderedDict([('id', 'atttRJnawtGzIOFlp'), ('width', 2000), ('height', 1120), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bozHhK_zZH2a6dDtLoe7cA/zq_osirAtMpEcXeQkceYJLePcMfw3JkbSw_LEtTcegMphTqGgIYe2E101aMsntXrXmOP95qVnX1ymXpWHIp3vXrxT8apaqq7nplFDcJZulU/ZKs5ZbmzszCgRSr7Au1sKyXJSJ4XZPWOGxzYpxXs_VY'), ('filename', '06AC0355-40.jpg'), ('size', 217676), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wAgMKR1Bhmh_vu0_Y7Dscw/rQNM6jMNGv6uxfG9vr6VM03vm1j_jkHvrl8Of5yb2aGAeGcS0X9fF5qwYCaXxyPmv_FQqHM1G7cs_rh2tMm9Qg/2spgUpnqvCtz4X4hqwS3NKB9ozyhnhwovhkc_5sgQD0'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hE8w0dQf6c8CLDLGozqhKw/2fkCjIYnN_keLlGA6QSkBOFS84nKLtst5ElsY-A-soifHFIiEz38NiaC8OsPlJLPYmdjLJjA0d3-kRxVF21O3Q/tfnjp3io35FJZITKBc4jXkxhWtc6mLycHbkJZarVYkU'), ('width', 914), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YEbvB3wIbWUwwylYCiZEHQ/aPM7_nYKoPhmSNZ32zm8zptoshpu_JpTE9t0r6NGRLY4nvfMpyhnLl1tVoY76iWCr8tqiWjr4XlSFNmEZFUUMA/l-jJCDKz7xt9HnWCZa9rYx0F8rdnpezbgM89WkR3EJI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/DSOX1102G/oscilloscope-70-100-mhz-2-analog-channels.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightDSOX1102G.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keysight/keysightDSOX1102G.html?highlight=dsox1102G,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Channel():
    """""" Implementation of a Keysight DSOX1102G Oscilloscope channel.

    Implementation modeled on Channel object of Tektronix AFG3152C instrument. """"""

    BOOLS = {True: 1, False: 0}

    bwlimit = Instrument.control(
        ""BWLimit?"", ""BWLimit %d"",
        """""" A boolean parameter that toggles 25 MHz internal low-pass filter."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    coupling = Instrument.control(
        ""COUPling?"", ""COUPling %s"",
        """""" A string parameter that determines the coupling (""ac"" or ""dc"")."""""",
        validator=strict_discrete_set,
        values={""ac"": ""AC"", ""dc"": ""DC""},
        map_values=True
    )

    display = Instrument.control(
        ""DISPlay?"", ""DISPlay %d"",
        """""" A boolean parameter that toggles the display."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    invert = Instrument.control(
        ""INVert?"", ""INVert %d"",
        """""" A boolean parameter that toggles the inversion of the input signal."""""",
        validator=strict_discrete_set,
        values=BOOLS,
        map_values=True
    )

    label = Instrument.control(
        ""LABel?"", 'LABel ""%s""',
        """""" A string to label the channel. Labels with more than 10 characters are truncated to 10
        characters. May contain commonly used ASCII characters. Lower case characters are converted
        to upper case."""""",
        get_process=lambda v: str(v[1:-1])
    )

    offset = Instrument.control(
        ""OFFSet?"", ""OFFSet %f"",
        """""" A float parameter to set value that is represented at center of screen in
        Volts. The range of legal values varies depending on range and scale. If the specified
        value is outside of the legal range, the offset value is automatically set to the nearest
        legal value.
        """"""
    )

    probe_attenuation = Instrument.control(
        ""PROBe?"", ""PROBe %f"",
        """""" A float parameter that specifies the probe attenuation. The probe attenuation
        may be from 0.1 to 10000."""""",
        validator=strict_range,
        values=[0.1, 10000]
    )

    range = Instrument.control(
        ""RANGe?"", ""RANGe %f"",
        """""" A float parameter that specifies the full-scale vertical axis in Volts.
        When using 1:1 probe attenuation, legal values for the range are from 8 mV to 40V.""""""
    )

    scale = Instrument.control(
        ""SCALe?"", ""SCALe %f"",
        """"""A float parameter that specifies the vertical scale, or units per division, in Volts.""""""
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any key-word arguments.
        """"""
        return self.instrument.values("":channel%d:%s"" % (
            self.number, command), **kwargs)

    def ask(self, command):
        self.instrument.ask("":channel%d:%s"" % (self.number, command))

    def write(self, command):
        self.instrument.write("":channel%d:%s"" % (self.number, command))

    def setup(self, bwlimit=None, coupling=None, display=None, invert=None, label=None, offset=None,
              probe_attenuation=None, vertical_range=None, scale=None):
        """""" Setup channel. Unspecified settings are not modified. Modifying values such as
        probe attenuation will modify offset, range, etc. Refer to oscilloscope documentation and
        make multiple consecutive calls to setup() if needed.

        :param bwlimit: A boolean, which enables 25 MHz internal low-pass filter.
        :param coupling: ""ac"" or ""dc"".
        :param display: A boolean, which enables channel display.
        :param invert: A boolean, which enables input signal inversion.
        :param label: Label string with max. 10 commonly used ASCII characters.
        :param offset: Numerical value represented at center of screen, must be inside
            the legal range.
        :param probe_attenuation: Probe attenuation values from 0.1 to 1000.
        :param vertical_range: Full-scale vertical axis of the selected channel. When using 1:1
            probe attenuation, legal values for the range are  from 8mV to 40 V. If the probe
            attenuation is changed, the range value is multiplied by the probe attenuation factor.
        :param scale: Units per division. """"""

        if vertical_range is not None and scale is not None:
            log.warning(
                'Both ""vertical_range"" and ""scale"" are specified. Specified ""scale"" has priority.')

        if probe_attenuation is not None:
            self.probe_attenuation = probe_attenuation
        if bwlimit is not None:
            self.bwlimit = bwlimit
        if coupling is not None:
            self.coupling = coupling
        if display is not None:
            self.display = display
        if invert is not None:
            self.invert = invert
        if label is not None:
            self.label = label
        if offset is not None:
            self.offset = offset
        if vertical_range is not None:
            self.range = vertical_range
        if scale is not None:
            self.scale = scale

    @property
    def current_configuration(self):
        """""" Read channel configuration as a dict containing the following keys:
            - ""CHAN"": channel number (int)
            - ""OFFS"": vertical offset (float)
            - ""RANG"": vertical range (float)
            - ""COUP"": ""dc"" or ""ac"" coupling (str)
            - ""IMP"": input impedance (str)
            - ""DISP"": currently displayed (bool)
            - ""BWL"": bandwidth limiting enabled (bool)
            - ""INV"": inverted (bool)
            - ""UNIT"": unit (str)
            - ""PROB"": probe attenuation (float)
            - ""PROB:SKEW"": skew factor (float)
            - ""STYP"": probe signal type (str)
        """"""

        # Using the instrument's ask method because Channel.ask() adds the prefix "":channelX:"", and
        # to query the configuration details, we actually need to ask "":channelX?"", without a
        # second "":""
        ch_setup_raw = self.instrument.ask("":channel%d?"" % self.number).strip(""\n"")

        # ch_setup_raw hat the following format:
        # :CHAN1:RANG +40.0E+00;OFFS +0.00000E+00;COUP DC;IMP ONEM;DISP 1;BWL 0;
        # INV 0;LAB ""1"";UNIT VOLT;PROB +10E+00;PROB:SKEW +0.00E+00;STYP SING

        # Cut out the "":CHANx:"" at beginning and split string
        ch_setup_splitted = ch_setup_raw[7:].split("";"")

        # Create dict of setup parameters
        ch_setup_dict = dict(map(lambda v: v.split("" ""), ch_setup_splitted))

        # Add ""CHAN"" key
        ch_setup_dict[""CHAN""] = ch_setup_raw[5]

        # Convert values to specific type
        to_str = [""COUP"", ""IMP"", ""UNIT"", ""STYP""]
        to_bool = [""DISP"", ""BWL"", ""INV""]
        to_float = [""OFFS"", ""PROB"", ""PROB:SKEW"", ""RANG""]
        to_int = [""CHAN""]
        for key in ch_setup_dict:
            if key in to_str:
                ch_setup_dict[key] = str(ch_setup_dict[key])
            elif key in to_bool:
                ch_setup_dict[key] = (ch_setup_dict[key] == ""1"")
            elif key in to_float:
                ch_setup_dict[key] = float(ch_setup_dict[key])
            elif key in to_int:
                ch_setup_dict[key] = int(ch_setup_dict[key])
        return ch_setup_dict


class KeysightDSOX1102G(Instrument):
    """""" Represents the Keysight DSOX1102G Oscilloscope interface for interacting
    with the instrument.

    Refer to the Keysight DSOX1102G Oscilloscope Programmer's Guide for further details about
    using the lower-level methods to interact directly with the scope.

    .. code-block:: python

        scope = KeysightDSOX1102G(resource)
        scope.autoscale()
        ch1_data_array, ch1_preamble = scope.download_data(source=""channel1"", points=2000)
        # ...
        scope.shutdown()

    Known issues:

    - The digitize command will be completed before the operation is. May lead to
      VI_ERROR_TMO (timeout) occuring when sending commands immediately after digitize.
      Current fix: if deemed necessary, add delay between digitize and follow-up command
      to scope.
    """"""

    BOOLS = {True: 1, False: 0}

    def __init__(self, adapter, name=""Keysight DSOX1102G Oscilloscope"", **kwargs):
        super().__init__(
            adapter, name, timeout=6000, **kwargs
        )
        # Account for setup time for timebase_mode, waveform_points_mode
        self.ch1 = Channel(self, 1)
        self.ch2 = Channel(self, 2)

    #################
    # Channel setup #
    #################

    def autoscale(self):
        """""" Autoscale displayed channels. """"""
        self.write("":autoscale"")

    ##################
    # Timebase Setup #
    ##################

    @property
    def timebase(self):
        """""" Read timebase setup as a dict containing the following keys:
            - ""REF"": position on screen of timebase reference (str)
            - ""MAIN:RANG"": full-scale timebase range (float)
            - ""POS"": interval between trigger and reference point (float)
            - ""MODE"": mode (str)""""""
        return self._timebase()

    timebase_mode = Instrument.control(
        "":TIMebase:MODE?"", "":TIMebase:MODE %s"",
        """""" A string parameter that sets the current time base. Can be ""main"",
        ""window"", ""xy"", or ""roll""."""""",
        validator=strict_discrete_set,
        values={""main"": ""MAIN"", ""window"": ""WIND"", ""xy"": ""XY"", ""roll"": ""ROLL""},
        map_values=True
    )

    timebase_offset = Instrument.control(
        "":TIMebase:POSition?"", "":TIMebase:REFerence CENTer;:TIMebase:POSition %f"",
        """""" A float parameter that sets the time interval in seconds between the trigger
        event and the reference position (at center of screen by default).""""""
    )

    timebase_range = Instrument.control(
        "":TIMebase:RANGe?"", "":TIMebase:RANGe %f"",
        """""" A float parameter that sets the full-scale horizontal time in seconds for the
        main window.""""""
    )

    timebase_scale = Instrument.control(
        "":TIMebase:SCALe?"", "":TIMebase:SCALe %f"",
        """""" A float parameter that sets the horizontal scale (units per division) in seconds
        for the main window.""""""
    )

    ###############
    # Acquisition #
    ###############

    acquisition_type = Instrument.control(
        "":ACQuire:TYPE?"", "":ACQuire:TYPE %s"",
        """""" A string parameter that sets the type of data acquisition. Can be ""normal"", ""average"",
        ""hresolution"", or ""peak""."""""",
        validator=strict_discrete_set,
        values={""normal"": ""NORM"", ""average"": ""AVER"", ""hresolution"": ""HRES"", ""peak"": ""PEAK""},
        map_values=True
    )

    acquisition_mode = Instrument.control(
        "":ACQuire:MODE?"", "":ACQuire:MODE %s"",
        """""" A string parameter that sets the acquisition mode. Can be ""realtime"" or ""segmented""."""""",
        validator=strict_discrete_set,
        values={""realtime"": ""RTIM"", ""segmented"": ""SEGM""},
        map_values=True
    )

    def run(self):
        """""" Starts repetitive acquisitions.

        This is the same as pressing the Run key on the front panel.
        """"""
        self.write("":run"")

    def stop(self):
        """"""  Stops the acquisition. This is the same as pressing the Stop key on the front panel.""""""
        self.write("":stop"")

    def single(self):
        """""" Causes the instrument to acquire a single trigger of data.
        This is the same as pressing the Single key on the front panel. """"""
        self.write("":single"")

    _digitize = Instrument.setting(
        "":DIGitize %s"",
        """""" Acquire waveforms according to the settings of the :ACQuire commands and specified
        source, as a string parameter that can take the following values: ""channel1"", ""channel2"",
        ""function"", ""math"", ""fft"", ""abus"", or ""ext"". """""",
        validator=strict_discrete_set,
        values={""channel1"": ""CHAN1"", ""channel2"": ""CHAN2"", ""function"": ""FUNC"", ""math"": ""MATH"",
                ""fft"": ""FFT"", ""abus"": ""ABUS"", ""ext"": ""EXT""},
        map_values=True
    )

    def digitize(self, source: str):
        """""" Acquire waveforms according to the settings of the :ACQuire commands. Ensure a delay
        between the digitize operation and further commands, as timeout may be reached before
        digitize has completed.
        :param source: ""channel1"", ""channel2"", ""function"", ""math"", ""fft"", ""abus"", or ""ext"".""""""
        self._digitize = source

    waveform_points_mode = Instrument.control(
        "":waveform:points:mode?"", "":waveform:points:mode %s"",
        """""" A string parameter that sets the data record to be transferred with the waveform_data
         method. Can be ""normal"", ""maximum"", or ""raw""."""""",
        validator=strict_discrete_set,
        values={""normal"": ""NORM"", ""maximum"": ""MAX"", ""raw"": ""RAW""},
        map_values=True
    )
    waveform_points = Instrument.control(
        "":waveform:points?"", "":waveform:points %d"",
        """""" An integer parameter that sets the number of waveform points to be transferred with
        the waveform_data method. Can be any of the following values:
        100, 250, 500, 1000, 2 000, 5 000, 10 000, 20 000, 50 000, 62 500.

        Note that the oscilloscope may provide less than the specified nb of points. """""",
        validator=strict_discrete_set,
        values=[100, 250, 500, 1000, 2000, 5000, 10000, 20000, 50000, 62500]
    )
    waveform_source = Instrument.control(
        "":waveform:source?"", "":waveform:source %s"",
        """""" A string parameter that selects the analog channel, function, or reference waveform
        to be used as the source for the waveform methods. Can be ""channel1"", ""channel2"",
        ""function"", ""fft"", ""wmemory1"", ""wmemory2"", or ""ext""."""""",
        validator=strict_discrete_set,
        values={""channel1"": ""CHAN1"", ""channel2"": ""CHAN2"", ""function"": ""FUNC"", ""fft"": ""FFT"",
                ""wmemory1"": ""WMEM1"", ""wmemory2"": ""WMEM2"", ""ext"": ""EXT""},
        map_values=True
    )
    waveform_format = Instrument.control(
        "":waveform:format?"", "":waveform:format %s"",
        """""" A string parameter that controls how the data is formatted when sent from the
        oscilloscope. Can be ""ascii"", ""word"" or ""byte"". Words are transmitted in big endian by
        default."""""",
        validator=strict_discrete_set,
        values={""ascii"": ""ASC"", ""word"": ""WORD"", ""byte"": ""BYTE""},
        map_values=True
    )

    @property
    def waveform_preamble(self):
        """""" Get preamble information for the selected waveform source as a dict with the following keys:
            - ""format"": byte, word, or ascii (str)
            - ""type"": normal, peak detect, or average (str)
            - ""points"": nb of data points transferred (int)
            - ""count"": always 1 (int)
            - ""xincrement"": time difference between data points (float)
            - ""xorigin"": first data point in memory (float)
            - ""xreference"": data point associated with xorigin (int)
            - ""yincrement"": voltage difference between data points (float)
            - ""yorigin"": voltage at center of screen (float)
            - ""yreference"": data point associated with yorigin (int)""""""  # noqa: E501
        return self._waveform_preamble()

    @property
    def waveform_data(self):
        """""" Get the binary block of sampled data points transmitted using the IEEE 488.2 arbitrary
        block data format.""""""
        # Other waveform formats raise UnicodeDecodeError
        self.waveform_format = ""ascii""

        data = self.values("":waveform:data?"")
        # Strip header from first data element
        data[0] = float(data[0][10:])

        return data

    ################
    # System Setup #
    ################

    @property
    def system_setup(self):
        """""" A string parameter that sets up the oscilloscope. Must be in IEEE 488.2 format.
        It is recommended to only set a string previously obtained from this command.""""""
        return self.ask("":system:setup?"")

    @system_setup.setter
    def system_setup(self, setup_string):
        self.write("":system:setup "" + setup_string)

    def ch(self, channel_number):
        if channel_number == 1:
            return self.ch1
        elif channel_number == 2:
            return self.ch2
        else:
            raise ValueError(""Invalid channel number. Must be 1 or 2."")

    def clear_status(self):
        """""" Clear device status. """"""
        self.write(""*CLS"")

    def factory_reset(self):
        """""" Factory default setup, no user settings remain unchanged. """"""
        self.write(""*RST"")

    def default_setup(self):
        """""" Default setup, some user settings (like preferences) remain unchanged. """"""
        self.write("":SYSTem:PRESet"")

    def timebase_setup(self, mode=None, offset=None, horizontal_range=None, scale=None):
        """""" Set up timebase. Unspecified parameters are not modified. Modifying a single parameter
        might impact other parameters. Refer to oscilloscope documentation and make multiple
        consecutive calls to channel_setup if needed.

        :param mode: Timebase mode, can be ""main"", ""window"", ""xy"", or ""roll"".
        :param offset: Offset in seconds between trigger and center of screen.
        :param horizontal_range: Full-scale range in seconds.
        :param scale: Units-per-division in seconds.""""""

        if mode is not None:
            self.timebase_mode = mode
        if offset is not None:
            self.timebase_offset = offset
        if horizontal_range is not None:
            self.timebase_range = horizontal_range
        if scale is not None:
            self.timebase_scale = scale

    def download_image(self, format_=""png"", color_palette=""color""):
        """""" Get image of oscilloscope screen in bytearray of specified file format.

        :param format_: ""bmp"", ""bmp8bit"", or ""png""
        :param color_palette: ""color"" or ""grayscale""
        """"""
        query = f"":DISPlay:DATA? {format_}, {color_palette}""
        # Using binary_values query because default interface does not support binary transfer
        img = self.binary_values(query, header_bytes=10, dtype=np.uint8)
        return bytearray(img)

    def download_data(self, source, points=62500):
        """""" Get data from specified source of oscilloscope. Returned objects are a np.ndarray of
        data values (no temporal axis) and a dict of the waveform preamble, which can be used to
        build the corresponding time values for all data points.

        Multimeter will be stopped for proper acquisition.

        :param source: measurement source, can be ""channel1"", ""channel2"", ""function"", ""fft"",
            ""wmemory1"", ""wmemory2"", or ""ext"".
        :param points: integer number of points to acquire. Note that oscilloscope may return fewer
            points than specified, this is not an issue of this library. Can be 100, 250, 500, 1000,
            2000, 5000, 10000, 20000, 50000, or 62500.

        :return data_ndarray, waveform_preamble_dict: see waveform_preamble property for dict
            format.
        """"""
        # TODO: Consider downloading from multiple sources at the same time.
        self.waveform_source = source
        self.waveform_points_mode = ""normal""
        self.waveform_points = points

        preamble = self.waveform_preamble
        data_bytes = self.waveform_data
        return np.array(data_bytes), preamble

    def _timebase(self):
        """"""
        Reads setup data from timebase and converts it to a more convenient dict of values.
        """"""
        tb_setup_raw = self.ask("":timebase?"").strip(""\n"")

        # tb_setup_raw hat the following format:
        # :TIM:MODE MAIN;REF CENT;MAIN:RANG +1.00E-03;POS +0.0E+00

        # Cut out the "":TIM:"" at beginning and split string
        tb_setup_splitted = tb_setup_raw[5:].split("";"")

        # Create dict of setup parameters
        tb_setup = dict(map(lambda v: v.split("" ""), tb_setup_splitted))

        # Convert values to specific type
        to_str = [""MODE"", ""REF""]
        to_float = [""MAIN:RANG"", ""POS""]
        for key in tb_setup:
            if key in to_str:
                tb_setup[key] = str(tb_setup[key])
            elif key in to_float:
                tb_setup[key] = float(tb_setup[key])

        return tb_setup

    def _waveform_preamble(self):
        """"""
        Reads waveform preamble and converts it to a more convenient dict of values.
        """"""
        vals = self.values("":waveform:preamble?"")
        # Get values to dict
        vals_dict = dict(zip([""format"", ""type"", ""points"", ""count"", ""xincrement"", ""xorigin"",
                              ""xreference"", ""yincrement"", ""yorigin"", ""yreference""], vals))
        # Map element values
        format_map = {0: ""BYTE"", 1: ""WORD"", 4: ""ASCII""}
        type_map = {0: ""NORMAL"", 1: ""PEAK DETECT"", 2: ""AVERAGE"", 3: ""HRES""}
        vals_dict[""format""] = format_map[int(vals_dict[""format""])]
        vals_dict[""type""] = type_map[int(vals_dict[""type""])]

        # Correct types
        to_int = [""points"", ""count"", ""xreference"", ""yreference""]
        to_float = [""xincrement"", ""xorigin"", ""yincrement"", ""yorigin""]
        for key in vals_dict:
            if key in to_int:
                vals_dict[key] = int(vals_dict[key])
            elif key in to_float:
                vals_dict[key] = float(vals_dict[key])

        return vals_dict
"
87,,UK,The Delta Elektronika BV Model SM70-45D Programmable DC Power Supply 0-70V 0-45A,SM 7045 D,118.0,"**Telonic Instruments** is one of the leading Suppliers of Kikusui, Rigol and Lab-Power power supplies and frequency converters.

",Pymeasure,Delta Elektronika,"[OrderedDict([('id', 'attzAHv8lUsC6VDSs'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PoID2iGNM3dG2PqzsWr4PA/fXnbmbBeuKe38qBljdpgchgJA-G0Fs42VBllHlKCLwIHn2zB0vuLXyYEiWiF8ufalxbu3kNMOvLPzJZO5c1Y6Id3-kPNxO9zRBpLHwqjvZ4/wNYYwA2ErHJXEq7lkdNFUDmCmURAuODJqPsztQcKgc4'), ('filename', '4nhdMXDm_400x400.jpeg'), ('size', 11508), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MtVx1_mdVpbgi2_SovGL_w/Wqp5xHlaPp9svohuxb9zh-eMvHPZyI-3Wppfl4DOJ4ohhhENIG3GQPoaD1AohqNw42h-clIT5qNFvPTTx0KysQ/NhJYBkU9o2taeyDhPBsR0FTK7oNaM1Uq793lXriOIMQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oVqsSB8xYjwMscGkh281OA/d7VSLNmCXx9CneNtfMWdUtY4wi2LO1RfIaqJ8BXalkPAjPrPEM0Yh7EEUN7fxC3vtWfy9ZNyn7cga0rG-KQrvQ/kCPBLAlv3Jfi5EK4zw63E1yriZs-wNdtBF4172vukfU'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LokzgNF9SThqJwFVOCMTfw/CTq6B7FtVtODemJtEEWym_uzKksWvPmF3qsCX2II9oh9kdzVQSyN9gYD-Ninxn6gqiDHAh6LOtlsCXjq09Sg2Q/AOelFdfgg2RK7UAlN5ZECApPYdTA3oQZEo4cHWgk-mQ'), ('width', 3000), ('height', 3000)]))]))])]",https://telonic.co.uk/jg/wp-content/uploads/2021/05/Delta-SM800-Product-Manual.pdf,Write a Python script that uses Pymeasure to connect to a SM 70-45D Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],A power supply is an electrical device that supplies electric power to an electrical load.,SM 70-45D,,"[OrderedDict([('id', 'attK4c98JrVXpCkgN'), ('width', 100), ('height', 100), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GJKg49Nd11PtGYi204oOFw/wYJjzJmYNiVVZn-f6gGkopQ-70U9LRX0dyVL2m0AKoCtBqM_s89nO-VvAtyy3b6wp1CZL6BJAykgV9It-QHCXfEYyUPnCEub979LZIBU36Cayv4iyxWWqGUoa_M4zdLj/vPc93FFttoRoBaAIgScONKAZNFY9qOenTt8z1aLhf8Y'), ('filename', 'Delta-SM800-Front-100x100.jpg'), ('size', 2540), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uPoLhbTv8nWa93nE7G_dgw/zUNe77PqchC1q6meZARiJdlmNhf2iz-X0DXg_GFfLZUwu0UxoMR4oVoscpeeFwAbqX30IbzFTd7R-UQ7exTw1w/C8X7U0WO83WSdJGgFMN_rDXTTVkv3svLMZ1cuiMGHjg'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L6iZsGnj8_5gRRaYHUYeNA/HTjU3Fe_m5IOjclVNJtLv5xgybvYXqL2zhuEJ1lb0YTbx4j3ZDTnFI-8ECfHfScgr88ERpQSlb-O37rJdhoXEQ/jx1xG3vzmKI8TaqgjQnQDbxYpycWF_5LBCuH9nUGww4'), ('width', 100), ('height', 100)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gogAT7oY8SDLLo_G9l_RwQ/iTJka_c-N2ulo0nCH15PwH4V0ualrnV5CLX5rzMTvrGIXQ_yk1QZqqcD2R2otwytqMCFMrb7drZ3h-pmDPTIEA/e1ayypiMzxWj4X4jmsAoFuCszHBuGCU8W4J8cwc5X40'), ('width', 3000), ('height', 3000)]))]))])]",https://telonic.co.uk/product/delta-elektronika-sm70-45d-programmable-dc-power-supply-0-70v-0-45a/,,https://buildmedia.readthedocs.org/media/pdf/pymeasure/latest/pymeasure.pdf,,,,,
89,5420.0,USA,"33120A Function / Arbitrary Waveform Generator, 15 MHz",HP 33120 A,183.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a Keysight 33120A Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies.",Keysight 33120A,https://www.keysight.com/us/en/assets/7018-06809/data-sheets/5968-0125.pdf,"[OrderedDict([('id', 'atthuVvJN2I1Q1oWs'), ('width', 2641), ('height', 1171), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wMzIskU64oqkJ6Zrrtx1Nw/a0qJFpREod-b3axsleaI_mAryImiz8FKOy15ArZG12irKRveLBGONp42w291fY82ACJBDXPZoxhBfq7JgKr8b_KJW_-MazQ83REf711dL4U/R-kYLLOfmZvGhm9E6vM6CIk-ajbyipFyc_80orPBX-8'), ('filename', 'SgLabs_HP_33120A_1.jpeg'), ('size', 381447), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kKb4o-xtiGQXFU1dlueXpA/5X3c2B6vPVtT2mDpHJE7-qTQHxXJugWoUCwE7cRPxrc2vyODcGJVH2NHXPS8A3G_CB-ND2AyWOD3IC08Nk6v4w/iOrc3FeD7Yykd_CrAPjR0Cbz9-WobtQvKG3sfYh7S4E'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/81YBtbu42Gr65C0CA45n2g/eEH7LIQO5OYSVYJ121RNbzUI2m67A-__7sdQ3pu2ntahcAVu5PrchPWljZj7Y-AJgqNCQT9zPgC5VEXi-mKBoA/xUVhCzqb4bGunBPb3gV2X_jre9AqJhn9hDj11oleXh0'), ('width', 1155), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xKTCgBbT2MClRVIRiPFwxg/3fGv_40CvqV_UrTh5ozbHK_QHTcdC7kob9bK2Jxev676Oztnzgg4sblMHvbSS2NhtGYe0lSXS6mBn1Mce6ZGjQ/Z5x8TabiCCwFwE50N3o5K0_y84LaUU3nQVHjCw-RTwg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/33120A/function--arbitrary-waveform-generator-15-mhz.html,https://github.com/heeres/qtlab/blob/master/instrument_plugins/HP_33120A.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp33120A.html,400.0,,,,"# HP_33120A.py class, to perform the communication between the Wrapper and the device
# Pieter de Groot <pieterdegroot@gmail.com>, 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from instrument import Instrument
import visa
import types
import logging
from time import sleep

#TODO
#1 put modes/shapes/status as parameter with list of options?
#   burst_state { on, off }
#   trigger_state { cont, external, gpib }
#   function_shape { see below }
#2 put above in get_all()

class HP_33120A(Instrument):
    '''
    This is the python driver for the HP 33120A
    arbitrary waveform generator

    Usage:
    Initialize with
    <name> = instruments.create('<name>', 'HP_33120A', address='<GPIB address>',
        reset=<bool>)
    '''

    def __init__(self, name, address, reset=False):
        '''
        Initializes the HP_33120A, and communicates with the wrapper.

        Input:
            name (string)    : name of the instrument
            address (string) : GPIB address
            reset (bool)     : resets to default values, default=false

        Output:
            None
        '''
        Instrument.__init__(self, name, tags=['physical'])

        self._address = address
        self._visainstrument = visa.instrument(self._address)

        self.add_parameter('frequency',
                type=types.FloatType,
                flags=Instrument.FLAG_GETSET,
                minval=10e-3, maxval=1e6,
                units='Hz')
        self.add_parameter('amplitude',
                type=types.FloatType,
                flags=Instrument.FLAG_GETSET,
                minval=-10, maxval=10,
                units='V')
        self.add_parameter('offset',
                type=types.FloatType,
                flags=Instrument.FLAG_GETSET,
                minval=-10, maxval=10,
                units='V')
        self.add_parameter('burst_count',
                type=types.IntType,
                flags=Instrument.FLAG_GETSET,
                minval=1, maxval=10000,
                units='#')
        self.add_parameter('burst_status',
                type=types.StringType,
                flags=Instrument.FLAG_GETSET,
                option_list=(
                    'on',
                    'off'
                ))


        self.add_function('reset')
        self.add_function('get_all')
        self.add_function('send_trigger')

        if reset:
            self.reset()
        else:
            self.get_all()

    def get_all(self):
        self.get_frequency()
        sleep(0.1)
        self.get_amplitude()
        sleep(0.1)
        self.get_offset()
        sleep(0.1)
        self.get_burst_count()
        sleep(0.1)

    def reset(self):
        logging.info(__name__ + ' : Resetting instrument')
        self._visainstrument.write('*RST')
        sleep(0.1)
        self.get_all()

    def get_error(self):
        logging.debug(__name__ + ' : Getting one error from error list')
        return self._visainstrument.ask('SYST:ERR?')

# Trigger

    def set_trigger_continuous(self):
        logging.debug(__name__ + ' : Set trigger to continuous')
        self._visainstrument.write('TRIG:SOUR IMM')

    def set_trigger_external(self):
        logging.debug(__name__ + ' : Set trigger to external')
        self._visainstrument.write('TRIG:SOUR EXT')

    def set_trigger_gpib(self):
        logging.debug(__name__ + ' : Set trigger to gpib')
        self._visainstrument.write('TRIG:SOUR BUS')

    def get_trigger_state(self):
        logging.debug(__name__ + ' : Getting trigger state')
        return self._visainstrument.ask('TRIG:SOUR?')

    def send_trigger(self):
        logging.debug(__name__ + ' : Sending Trigger')
        self._visainstrument.write('*TRG')

# Burst

    def do_set_burst_count(self, cnt):
        logging.debug(__name__ + ' : Setting burst count')
        self._visainstrument.write('BM:NCYC %d' % cnt)

    def do_get_burst_count(self):
        logging.debug(__name__ + ' : Getting burst count')
        return float(self._visainstrument.ask('BM:NCYC?'))

    def do_set_burst_status(self, stat):
        '''
        stat: { ON OFF }
        '''
        logging.debug(__name__ + ' : Setting burst status')
        self._visainstrument.write('BM:STAT %s' % stat)

    def do_get_burst_status(self):
        '''
        stat: { ON OFF }
        '''
        logging.debug(__name__ + ' : Getting burst status')
        return self._visainstrument.ask('BM:STAT?')

# Shape

    def set_function_shape(self, shape):
        '''
        shape : { SIN, SQU, TRI, RAMP, NOIS, DC, USER }
        '''
        logging.debug(__name__ + ' : Sending Trigger')
        self._visainstrument.write('SOUR:FUNC:SHAP %s' % shape)

    def get_function_shape(self):
        logging.debug(__name__ + ' : Getting function shape')
        return self._visainstrument.ask('SOUR:FUNC:SHAP?')

# Parameters

    def do_set_frequency(self, freq):
        logging.debug(__name__ + ' : Setting frequency')
        self._visainstrument.write('SOUR:FREQ %f' % freq)

    def do_get_frequency(self):
        logging.debug(__name__ + ' : Getting frequency')
        return self._visainstrument.ask('SOUR:FREQ?')

    def do_set_amplitude(self, amp):
        logging.debug(__name__ + ' : Setting amplitude')
        self._visainstrument.write('SOUR:VOLT %f' % amp)

    def do_get_amplitude(self):
        logging.debug(__name__ + ' : Getting amplitude')
        return self._visainstrument.ask('SOUR:VOLT?')

    def do_set_offset(self, offset):
        logging.debug(__name__ + ' : Setting offset')
        self._visainstrument.write('SOUR:VOLT:OFFS %f' % offset)

    def do_get_offset(self):
        logging.debug(__name__ + ' : Getting offset')
        return self._visainstrument.ask('SOUR:VOLT:OFFS?')

"
95,367.3,"Abingdon, United Kingdom",,Adapters,405.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Pymeasure,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Pymeasure to connect to a {Device name} ,,,,,,,,,,,,,,
100,5420.0,USA,8116A 50 MHZ PULSE/FUNCTION GENERATOR,HP 8116 A,187.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a Keisight 8116A Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies.",Keisight 8116A,https://www.keysight.com/us/en/assets/9018-05117/user-manuals/9018-05117.pdf,"[OrderedDict([('id', 'attFCic0uc57SntNt'), ('width', 700), ('height', 431), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zMwepooylI49AfxFFO5smA/1Ssdk5COkojrw3QzZJqwGNRqtpUe9wEx1ufEdtg0EFQzBiZHyn4C4nYA3EBBMdVpjF5555CDPHHO6waIeQRyRfgmAEBWU5-FKuto_sE6V2Y/7sMOcaTfjvCzLPk1sjVRMGb3qMQ_lzi1FMZaP4goJg8'), ('filename', 'prod_8116a1.jpg'), ('size', 178718), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZJZTmA-VjYEbX2UINhSKIQ/SAxqI3tPCvedvDjnvCox3hGgdGaua7QGZTlV5akjGjLw0GjnXseHQa0nPJFfwPgjOilojurfPyG5M-FrBp2o1w/C4VY3EnPtLVAIjFbwpIP2g8jpHhxzU5Uw_TAa45VJ_g'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NaulsbXNrET3uSg_M9Ra-g/IWoM24IqGAJWQA9NrsyAcruNFlZyssim664rnSFqBfsmIKL84f6sBXXXFXFDX6f3964XCI7YYTJbSzw_DKajzA/9D26zygxfNN-GuPi4KwuyQ5AZMCWQJCev1C1lmIvYBY'), ('width', 700), ('height', 431)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/x1Iqrxcn3QYwDE8FwXhoiA/yNCnqk9JaAhYaIsdCD5VvTg7cjrNYx_s-8yeFQwblGKCfKsnGI9DG2i1wjb8qTQKPZG8pGQb9_wmV3lUaK1wtw/F6TvNCRVPUGXOcu8bFQuix6CemYokAxbfdgGqtG2VWY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/8116A/50-mhz-pulsefunction-generator.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp8116a.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp8116A.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import numpy as np
from enum import Enum, IntFlag
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set, strict_range, truncated_discrete_set
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Status(IntFlag):
    """""" IntFlag type for the GPIB status byte which is returned by the :py:attr:`status` property.
    When the timing_error or programming_error flag is set, a more detailed error description
    can be obtained by calling :py:method:`check_errors()`.
    """"""
    timing_error = 1 << 0
    programming_error = 1 << 1
    syntax_error = 1 << 2
    system_failure = 1 << 3
    autovernier_in_progress = 1 << 4
    sweep_in_progress = 1 << 5
    service_request = 1 << 6
    buffer_not_empty = 1 << 7


class HP8116A(Instrument):
    """""" Represents the Hewlett-Packard 8116A 50 MHz Pulse/Function Generator
    and provides a high-level interface for interacting with the instrument.
    The resolution for all floating point instrument parameters is 3 digits.
    """"""

    def __init__(self, adapter, name=""Hewlett-Packard 8116A"", **kwargs):
        kwargs.setdefault('read_termination', '\r\n')
        kwargs.setdefault('write_termination', '\r\n')
        kwargs.setdefault('send_end', True)
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs
        )
        self.has_option_001 = self._check_has_option_001()

    class Digit(Enum):
        """""" Enum of the digits used with the autovernier
        (see :py:meth:`HP8116A.start_autovernier()`).
        """"""
        MOST_SIGNIFICANT = 'M'
        SECOND_SIGNIFICANT = 'S'
        LEAST_SIGNIFICANT = 'L'

    class Direction(Enum):
        """""" Enum of the directions used with the autovernier
        (see :py:meth:`HP8116A.start_autovernier()`).
        """"""
        UP = 'U'
        DOWN = 'D'

    OPERATING_MODES = {
        'normal': 'M1',
        'triggered': 'M2',
        'gate': 'M3',
        'external_width': 'M4',

        # Option 001 only
        'internal_sweep': 'M5',
        'external_sweep': 'M6',
        'internal_burst': 'M7',
        'external_burst': 'M8',
    }

    OPERATING_MODES_INV = {v: k for k, v in OPERATING_MODES.items()}

    CONTROL_MODES = {
        'off': 'CT0',
        'FM': 'CT1',
        'AM': 'CT2',
        'PWM': 'CT3',
        'VCO': 'CT4',
    }

    CONTROL_MODES_INV = {v: k for k, v in CONTROL_MODES.items()}

    TRIGGER_SLOPES = {
        'off': 'T0',
        'positive': 'T1',
        'negative': 'T2',
    }

    TRIGGER_SLOPES_INV = {v: k for k, v in TRIGGER_SLOPES.items()}

    SHAPES = {
        'dc': 'W0',
        'sine': 'W1',
        'triangle': 'W2',
        'square': 'W3',
        'pulse': 'W4',
    }

    SHAPES_INV = {v: k for k, v in SHAPES.items()}

    _units_frequency = {
        'milli': 'MZ',
        'no_prefix': 'HZ',
        'kilo': 'KHZ',
        'mega': 'MHZ',
    }

    _units_voltage = {
        'milli': 'MV',
        'no_prefix': 'V',
    }

    _units_time = {
        'nano': 'NS',
        'micro': 'US',
        'milli': 'MS',
        'no_prefix': 'S',
    }

    _si_prefixes = {
        'nano': 1e-9,
        'micro': 1e-6,
        'milli': 1e-3,
        'no_prefix': 1,
        'kilo': 1e3,
        'mega': 1e6,
    }

    @staticmethod
    def _get_value_with_unit(value, units):
        """""" Convert a floating point value to a string with 3 digits resolution
        and the appropriate unit.

        :param value: The value to convert.
        :param units: Dictionary containing a mapping of SI-prefixes to the unit strings
            the instrument uses, eg. 'milli' -> 'MZ' for millihertz.
        """"""
        if value < 1e-6:
            value_str = f'{value*1e9:.3g} {units[""nano""]}'
        elif value < 1e-3:
            value_str = f'{value*1e6:.3g} {units[""micro""]}'
        elif value < 1:
            value_str = f'{value*1e3:.3g} {units[""milli""]}'
        elif value < 1e3:
            value_str = f'{value:.3g} {units[""no_prefix""]}'
        elif value < 1e6:
            value_str = f'{value*1e-3:.3g} {units[""kilo""]}'
        else:
            value_str = f'{value*1e-6:.3g} {units[""mega""]}'

        return value_str

    @staticmethod
    def _parse_value_with_unit(value_str, units):
        """""" Convert a string with a value and a unit as returned by the HP8116A to a float.

        :param value_str: The string to parse.
        :param units: Dictionary containing a mapping of SI-prefixes to the unit strings
            the instrument uses, eg. 'milli' -> 'MZ' for millihertz.
        """"""

        # Example value_str: 'FRQ 1.00KHZ'
        # Digits and unit are always positioned the same for all parameters
        value_str = value_str.strip()
        value = float(value_str[3:8].strip())
        unit = value_str[8:].strip()
        units_inverse = {v: k for k, v in units.items()}
        value *= HP8116A._si_prefixes[units_inverse[unit]]

        return value

    def _generate_1_2_5_sequence(min, max):
        """""" Generate a list of a 1-2-5 sequence between min and max. """"""
        exp_min = int(np.log10(min))
        exp_max = int(np.log10(max))

        seq_1_2_5 = np.array([1, 2, 5])
        sequence = np.array([seq_1_2_5 * (10 ** exp) for exp in range(exp_min - 1, exp_max + 1)])
        sequence = sequence.flatten()
        sequence = sequence[(sequence >= min) & (sequence <= max)]

        return list(sequence)

    def _boolean_control(identifier, state_index, docs, inverted=False, **kwargs):
        return Instrument.control(
            'CST', identifier + '%d', docs,
            validator=strict_discrete_set,
            values=[True, False],
            get_process=lambda x: inverted ^ bool(int(x[state_index][1])),
            set_process=lambda x: int(inverted ^ x),
            **kwargs
        )

    # Instrument communication #

    def write(self, command):
        """""" Write a command to the instrument and wait until the 8116A has interpreted it. """"""
        super().write(command)

        # We need to read the status byte and wait until the buffer_not_empty bit
        # is cleared because some older units lock up if we don't.
        self._wait_for_commands_processed()

    def ask(self, command, num_bytes=None):
        """""" Write a command to the instrument, read the response, and return the response as ASCII text.

        :param command: The command to send to the instrument.
        :param num_bytes: The number of bytes to read from the instrument. If not specified,
                          the number of bytes is automatically determined by the command.
        """"""  # noqa: E501
        self.write(command)

        if num_bytes is None:
            if command == 'CST':
                # We usually only need the first 29 bytes of the state response since they contain
                # the current boolean parameters. The other parameters all have corresponding
                # 'interrogate' commands.
                num_bytes = 29
            elif command[0] == 'I':
                num_bytes = 14

        # The first character is always a space or a leftover character from the previous command,
        # when the number of bytes read was too large or too small.
        bytes = self.read_bytes(num_bytes)[1:]
        return bytes.decode('ascii').strip(' ,\r\n')

    operating_mode = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the operating mode of the instrument.
        Possible values (without Option 001) are: 'normal', 'triggered', 'gate', 'external_width'.
        With Option 001, 'internal_sweep', 'external_sweep', 'external_width', 'external_pulse'
        are also available.
        """""",
        validator=strict_discrete_set,
        values=OPERATING_MODES,
        map_values=True,
        get_process=lambda x: HP8116A.OPERATING_MODES_INV[x[0]]
    )

    control_mode = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the control mode of the instrument.
        Possible values are 'off', 'FM', 'AM', 'PWM', 'VCO'.
        """""",
        validator=strict_discrete_set,
        values=CONTROL_MODES,
        map_values=True,
        get_process=lambda x: HP8116A.CONTROL_MODES_INV[x[1]]
    )

    trigger_slope = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the slope the trigger triggers on.
        Possible values are: 'off', 'positive', 'negative'.
        """""",
        validator=strict_discrete_set,
        values=TRIGGER_SLOPES,
        map_values=True,
        get_process=lambda x: HP8116A.TRIGGER_SLOPES_INV[x[2]]
    )

    shape = Instrument.control(
        'CST', '%s',
        """""" A string property that controls the shape of the output waveform.
        Possible values are: 'dc', 'sine', 'triangle', 'square', 'pulse'.
        """""",
        validator=strict_discrete_set,
        values=SHAPES,
        map_values=True,
        get_process=lambda x: HP8116A.SHAPES_INV[x[3]]
    )

    haversine_enabled = _boolean_control(
        'H', 4,
        """""" A boolean property that controls whether a haversine/havertriangle signal
        is generated when in 'triggered', 'internal_burst' or 'external_burst' operating mode.
        """""",
    )

    autovernier_enabled = _boolean_control(
        'A', 5,
        """""" A boolean property that controls whether the autovernier is enabled. """""",
        check_set_errors=True
    )

    limit_enabled = _boolean_control(
        'L', 6,
        """""" A boolean property that controls whether parameter limiting is enabled. """""",
    )

    complement_enabled = _boolean_control(
        'C', 7,
        """""" A boolean property that controls whether the complement
        of the signal is generated.
        """""",
    )

    output_enabled = _boolean_control(
        'D', 8,
        """""" A boolean property that controls whether the output is enabled. """""",
        inverted=True,  # The actual command is ""Disable output""...
    )

    frequency = Instrument.control(
        'IFRQ', 'FRQ %s',
        """""" A floating point value that controls the frequency of the
        output in Hz. The allowed frequency range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    duty_cycle = Instrument.control(
        'IDTY', 'DTY %s %%',
        """""" An integer value that controls the duty cycle of the output in percent.
        The allowed range generally is 10 % to 90 %, but it also depends on the current frequency.
        It is valid for all shapes except 'pulse', where :py:attr:`pulse_width` is used instead.
        """""",
        validator=strict_range,
        values=[10, 90.0001],
        cast=int,
        # get_process=lambda x: int(x[6:8])
    )

    pulse_width = Instrument.control(
        'IWID', 'WID %s',
        """""" A floating point value that controls the pulse width.
        The allowed pulse width range is 8 ns to 999 ms.
        The pulse width may not be larger than the period.
        """""",
        validator=strict_range,
        values=[8e-9, 999.001e-3],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    amplitude = Instrument.control(
        'IAMP', 'AMP %s',
        """""" A floating point value that controls the amplitude of the
        output in V. The allowed amplitude range generally is 10 mV to 16 V,
        but it is also limited by the current offset.
        """""",
        validator=strict_range,
        values=[10e-3, 16.001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    offset = Instrument.control(
        'IOFS', 'OFS %s',
        """""" A floating point value that controls the offset of the
        output in V. The allowed offset range generally is -7.95 V to 7.95 V,
        but it is also limited by the amplitude.
        """""",
        validator=strict_range,
        values=[-7.95, 7.95001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    high_level = Instrument.control(
        'IHIL', 'HIL %s',
        """""" A floating point value that controls the high level of the
        output in V. The allowed high level range generally is -7.9 V to 8 V,
        but it must be at least 10 mV greater than the low level.
        """""",
        validator=strict_range,
        values=[-7.9, 8.001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    low_level = Instrument.control(
        'ILOL', 'LOL %s',
        """""" A floating point value that controls the low level of the
        output in V. The allowed low level range generally is -8 V to 7.9 V,
        but it must be at least 10 mV less than the high level.
        """""",
        validator=strict_range,
        values=[-8, 7.9001],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_voltage),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_voltage)
    )

    burst_number = Instrument.control(
        'IBUR', 'BUR %s #',
        """""" An integer value that controls the number of periods generated in a burst.
        The allowed range is 1 to 1999. It is only valid for units with Option 001
        in one of the burst modes.
        """""",
        validator=strict_range,
        values=[1, 1999],
        get_process=lambda x: int(x[4:8])
    )

    repetition_rate = Instrument.control(
        'IRPT', 'RPT %s',
        """""" A floating point value that controls the repetition rate (= the time between bursts)
        in 'internal_burst' mode. The allowed range is 20 ns to 999 ms.
        """""",
        validator=strict_range,
        values=[20e-9, 999.001e-3],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    sweep_start = Instrument.control(
        'ISTA', 'STA %s',
        """""" A floating point value that controls the start frequency in both sweep modes.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_stop = Instrument.control(
        'ISTP', 'STP %s',
        """""" A floating point value that controls the stop frequency in both sweep modes.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_marker_frequency = Instrument.control(
        'IMRK', 'MRK %s',
        """""" A floating point value that controls the frequency marker in both sweep modes.
        At this frequency, the marker output switches from low to high.
        The allowed range is 1 mHz to 52.5 MHz.
        """""",
        validator=strict_range,
        values=[1e-3, 52.5001e6],
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_frequency),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_frequency)
    )

    sweep_time = Instrument.control(
        'ISWT', 'SWT %s',
        """""" A floating point value that controls the sweep time per decade in both sweep modes.
        The sweep time is selectable in a 1-2-5 sequence between 10 ms and 500 s.
        """""",
        validator=truncated_discrete_set,
        values=_generate_1_2_5_sequence(10e-3, 500),
        set_process=lambda x: HP8116A._get_value_with_unit(x, HP8116A._units_time),
        get_process=lambda x: HP8116A._parse_value_with_unit(x, HP8116A._units_time)
    )

    @property
    def status(self):
        """""" Returns the status byte of the 8116A as an IntFlag-type enum. """"""
        return Status(self.adapter.connection.read_stb())

    @property
    def complete(self):
        return not (self.status & Status.buffer_not_empty)

    @property
    def options(self):
        """""" Return the device options installed. The only possible option is 001. """"""
        if self.has_option_001:
            return ['001']
        else:
            return []

    def start_autovernier(self, control, digit, direction, start_value=None):
        """""" Start the autovernier on the specified control.

        :param control: The control to change, pass as :code:`HP8116A.some_control`. Allowed
                        controls are frequency, amplitude, offset, duty_cycle, and pulse_width
        :param digit: The digit to change, type: :py:class:`HP8116A.Digit`.
        :param direction: The direction in which to change the control,
                          type: :py:class:`HP8116A.Direction`.
        :param start_value: An optional value to start the autovernier at. If not specified,
                            the current value of the control is used.
        """"""
        if not self.autovernier_enabled:
            raise RuntimeError('Autovernier has to be enabled first.')

        if control not in (HP8116A.frequency, HP8116A.amplitude, HP8116A.offset,
                           HP8116A.duty_cycle, HP8116A.pulse_width):
            raise ValueError('Control must be one of frequency, amplitude, offset, ' +
                             'duty_cycle, or pulse_width.')

        start_value = control.fget(self) if start_value is None else start_value
        # The control always has to be set to select it for the autovernier.
        control.fset(self, start_value)

        self.write(digit.value + direction.value)

    def GPIB_trigger(self):
        """""" Initate trigger via low-level GPIB-command (aka GET - group execute trigger). """"""
        self.adapter.connection.assert_trigger()

    def reset(self):
        """""" Initatiate a reset (like a power-on reset) of the 8116A. """"""
        self.adapter.connection.clear()
        self._wait_for_commands_processed()

    def shutdown(self):
        """""" Gracefully close the connection to the 8116A. """"""
        self.adapter.connection.clear()
        self.adapter.connection.close()
        super().shutdown()

    def check_errors(self):
        """""" Check for errors in the 8116A.

        :return: list of error entries or empty list if no error occurred.
        """"""
        errors_response = self.ask('IERR', 100).split('\r\n')[0].strip(' ,\r\n')
        errors = errors_response.split('ERROR')[:-1]
        errors = [e.strip() + "" ERROR"" for e in errors]

        if errors[0] == 'NO ERROR':
            return []
        else:
            for error in errors:
                log.error(f'{self.name}: {error}')
            return errors

    def _wait_for_commands_processed(self, timeout=1):
        """""" Wait until the commands have been processed by the 8116A. """"""
        start = time.time()
        while not self.complete:
            time.sleep(0.001)
            if time.time() - start > timeout:
                raise RuntimeError('Timeout waiting for commands to be processed.')

    def _check_has_option_001(self):
        """""" Return True if the 8116A has option 001 and False otherwise.

        This is done by checking the length of the response to the CST (current status) command
        which includes sweep parameters and burst parameters only if the 8116A has option 001.
        """"""

        # The longest possible state string is 163 characters long including termination characters
        state_string = self.ask('CST', 163).split('\r\n')[0].strip(' ,\r\n')

        if len(state_string) == 159:
            return True
        elif len(state_string) == 87:
            return False
        else:
            log.warning('Could not determine if 8116A has option 001. Assuming it has.')
            return True
"
107,21.4,"Westerville, Ohio, USA","Lake Shore Model 425 gaussmeter provides high-end functionality and performance in an affordable desktop instrument. Magnet testing and sorting have never been easier. When used in combination with the built-in relay and audible alarm features, the Model 425 takes the guesswork out of pass/fail criteria. Additional features including DC to 10 kHz AC frequency response, max hold and relative measurement make the Model 425 the ideal tool for your manufacturing, quality control and R&D flux density measurement applications. Put the Model 425 gaussmeter to use with confidence knowing it’s supported by industry leading experts in magnet measurement instrument, sensor, and Hall probe technology.",Lakeshore 425,346.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Pymeasure,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Pymeasure to connect to a {Device name} Power Meters,https://en.wikipedia.org/wiki/Magnetometer,['Power Meters'],"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.",,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/425.pdf?sfvrsn=1581d8be_6,"[OrderedDict([('id', 'attqoQm3frhx3s4le'), ('width', 505), ('height', 268), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/poLvWiyXEqKUEQ_HupeBTA/vbZDxE4qG6wzgCyG8CzDYRJRkChn91GgKZsg2qH-TUdiKWsShZwmnXUjzrvQfDH3ep468YQnHp7B0RkrUQXvLQ/loBKYrHoiXTUHzkpmGAldV6nZ6KA0q0IZ2_a5GVNV5c'), ('filename', '425.png'), ('size', 159132), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FQ5u9YAYB1fZyiwVztQJww/cuY76TSzKZ71o6oGBLMzw801XEotvZTfQW8SAayPMJxLJzfKvx-IfgnIeuesNV28jmOt8jDJ7RDorjoKW0Y9fA/WLQf_qIJu6-LqTHbqLNrqsSAwo3Wvm3tlkTrzUDhbGI'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/j5OaZU1J-YPwS2SC1hDpkg/M2I771myA5XOhyxZVNTbrb2sA799yGp-ciAgEfRRjBHrgjkLhRhPxWcNqOZD5mZxQSpZMavKihNq1rZOiDzblg/qlHzi-nezQzbRDSrzRUo8nallipMh6ahlMn7QWjeCi4'), ('width', 505), ('height', 268)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bSBJRejjiL3hci93z0pebg/BjgA6fiVIF6tjPgouEZVjAmoyhzchvEiHv8SxlelvLJVrig0l2o4sDUsXRDh6YP98USA5RzufyC0USd4GhAiOg/yA4ZpXvgLjddXTgA530rt7EQwjqovBaRtiGz9yV1dsA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-425-gaussmeter,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore425.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore425.html,2315.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, truncated_discrete_set

from time import sleep
import numpy as np


class LakeShore425(Instrument):
    """""" Represents the LakeShore 425 Gaussmeter and provides
    a high-level interface for interacting with the instrument

    To allow user access to the LakeShore 425 Gaussmeter in Linux,
    create the file:
    :code:`/etc/udev/rules.d/52-lakeshore425.rules`, with contents:

    .. code-block:: none

        SUBSYSTEMS==""usb"",ATTRS{idVendor}==""1fb9"",ATTRS{idProduct}==""0401"",MODE=""0666"",SYMLINK+=""lakeshore425""

    Then reload the udev rules with:

    .. code-block:: bash

        sudo udevadm control --reload-rules
        sudo udevadm trigger

    The device will be accessible through :code:`/dev/lakeshore425`.
    """"""

    field = Instrument.measurement(
        ""RDGFIELD?"",
        """""" Returns the field in the current units """"""
    )
    unit = Instrument.control(
        ""UNIT?"", ""UNIT %d"",
        """""" A string property that controls the units of the instrument,
        which can take the values of G, T, Oe, or A/m. """""",
        validator=strict_discrete_set,
        values={'G': 1, 'T': 2, 'Oe': 3, 'A/m': 4},
        map_values=True
    )
    range = Instrument.control(
        ""RANGE?"", ""RANGE %d"",
        """""" A floating point property that controls the field range in
        units of Gauss, which can take the values 35, 350, 3500, and
        35,000 G. """""",
        validator=truncated_discrete_set,
        values={35: 1, 350: 2, 3500: 3, 35000: 4},
        map_values=True
    )

    def __init__(self, adapter, name=""LakeShore 425 Gaussmeter"", **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'write_termination': ""\n"",
                  'read_termination': ""\n"",  # from manual
                  'baud_rate': 57600,
                  'timeout': 500,
                  'parity': 1,  # odd
                  'data_bits': 7
                  },
            **kwargs
        )

    def auto_range(self):
        """""" Sets the field range to automatically adjust """"""
        self.write(""AUTO"")

    def dc_mode(self, wideband=True):
        """""" Sets up a steady-state (DC) measurement of the field """"""
        if wideband:
            self.mode = (1, 0, 1)
        else:
            self.mode(1, 0, 2)

    def ac_mode(self, wideband=True):
        """""" Sets up a measurement of an oscillating (AC) field """"""
        if wideband:
            self.mode = (2, 1, 1)
        else:
            self.mode = (2, 1, 2)

    @property
    def mode(self):
        return tuple(self.values(""RDGMODE?""))

    @mode.setter
    def mode(self, value):
        """""" Provides access to directly setting the mode, filter, and
        bandwidth settings
        """"""
        mode, filter, band = value
        self.write(""RDGMODE %d,%d,%d"" % (mode, filter, band))

    def zero_probe(self):
        """""" Initiates the zero field sequence to calibrate the probe """"""
        self.write(""ZPROBE"")

    def measure(self, points, has_aborted=lambda: False, delay=1e-3):
        """"""Returns the mean and standard deviation of a given number
        of points while blocking
        """"""
        data = np.zeros(points, dtype=np.float32)
        for i in range(points):
            if has_aborted():
                break
            data[i] = self.field
            sleep(delay)
        return data.mean(), data.std()
"
108,21.4,"Westerville, Ohio, USA","The Model 331 cryogenic temperature controller combines the easy operation and unsurpassed reliability of the Model 330 with improved sensor input and interface flexibility, including compatibility with negative temperature coefficient (NTC) resistance temperature detectors (RTDs). Backed by the Lake Shore tradition of excellence in cryogenic sensors and instrumentation, the Model 331 temperature controller sets the standard for mid-price range temperature control instruments.",Lakeshore 331,365.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Pymeasure,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_331_l.pdf?sfvrsn=5d8525f8_1,"[OrderedDict([('id', 'attW95TFgpWcCokKy'), ('width', 505), ('height', 273), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jw6Dap96MqGyvFE4UDJmRQ/iscsVbRY6lEwb-P4S04t4LSkEBEYloKsvBtHbiVxiKHJ-tUfrZ04VGQwCOsPax8-lJgSiM_ZDPlOGWYlsVvlDw/DyuR_y--Wx4D9U4RVfKxWxAZtiwnt8j8qj6CrvlsgN4'), ('filename', '331.png'), ('size', 155224), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/v2WpbcQmr-4DiIZHl8sMEA/CNXrHUP36NeNA6X5scdcCPdyYsN8Az8cpxU3JUW6FpylcG5tPh_Cy9iA1GKd0pl-MwdmFYh9uCzxKc0sEbfsSA/FYkFo0yyQ6dmhEuvO0GILIurQwMVBCMekXqSILkaXIc'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/O_66sv_XHWJR9hdX2L6AiQ/HbqwS-ebGw-L5ywFIBeuNauMjYYOYtE7Q8_U-SM4H4in4tH3eN5ocIVPbEy6j_Sq8SRmG2jRoUjLl-wjJNSUmQ/8rxIgMOBz2m8pfYzeOdKNy_Znx1A9tMiyetYYTOvqaY'), ('width', 505), ('height', 273)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wznOa7lidlnO03IO59xWrQ/91uSw9Trwv1Cppn4xGeu2_skFpH8pAj1liliuZkk-R6rNIH1XsAqig48C65oUOcT29N2AVttc2Ue36zLH8Kh1A/DlAmNqc5omhCthmYuidodSUP6P8ELJIwl1TzOZ_YsHI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-331-cryogenic-temperature-controller,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/lakeshore/lakeshore331.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/lakeshore/lakeshore331.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.lakeshore.lakeshore_base import LakeShoreTemperatureChannel, \
    LakeShoreHeaterChannel

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class LakeShore331(Instrument):
    """""" Represents the Lake Shore 331 Temperature Controller and provides
    a high-level interface for interacting with the instrument. Note that the
    331 provides two input channels (A and B) and two output channels (1 and 2).
    This driver makes use of the :ref:`LakeShoreChannels`.

    .. code-block:: python

        controller = LakeShore331(""GPIB::1"")

        print(controller.output_1.setpoint)         # Print the current setpoint for loop 1
        controller.output_1.setpoint = 50           # Change the loop 1 setpoint to 50 K
        controller.output_1.heater_range = 'low'    # Change the heater range to low.
        controller.input_A.wait_for_temperature()   # Wait for the temperature to stabilize.
        print(controller.input_A.temperature)       # Print the temperature at sensor A.
    """"""
    input_A = Instrument.ChannelCreator(LakeShoreTemperatureChannel, 'A')

    input_B = Instrument.ChannelCreator(LakeShoreTemperatureChannel, 'B')

    output_1 = Instrument.ChannelCreator(LakeShoreHeaterChannel, 1)

    output_2 = Instrument.ChannelCreator(LakeShoreHeaterChannel, 2)

    def __init__(self, adapter, name=""Lakeshore Model 336 Temperature Controller"", **kwargs):
        kwargs.setdefault('read_termination', ""\r\n"")
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
112,5.0,"Edinburgh, United Kingdom","The RP100 is a two channel, sink-source power supply
designed to drive the CS100 series strain cells and the FC100
series stress cells. This power supply can be used in conjunction
with the corresponding range of compatible Razorbill Instruments
products to tune the electronic properties of materials by applying
controlled strains and stresses to the material. ",Razorbillrp 100,441.0,"Manufacturer of precision instruments intended for use in fundamental physics and space applications. The company manufactures electromechanical mechanisms to apply tunable uniaxial strains at low temperatures and high magnetic fields and provides expertise in the field of design for cryogenic environments, compliant mechanisms and compact systems for applying and measuring strain, enabling clients to incorporate a number of unique key technologies that allow them to have such high performance and repeatability.

",Pymeasure,Razorbill,"[OrderedDict([('id', 'attKAoLkJBDty1WX0'), ('width', 389), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XPAHTHzEijkqQ2Iy2YyU-g/xDkpX8MAP4bRs6ys2FnZoIVPl0kUoyWfOmbXSLdWR5kP-SCtCcbfeUeuMHetFfJ0_Sxo9mCeN7ADh_E3AjB2ZtndwiE58rx0AmFhWOgW0u0/kzbLGif8Ow4o74ic4IaGhCA0A_52z1IxER5PhLFSyLQ'), ('filename', 'xrfz14rxhnve5cmpv58y.jpg'), ('size', 4388), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zWZ0V3PEy42fP3o6WXD4Mg/SZTlE4ZAF4DODYXg1GRb41SIc5B4X-AvlmgvXXNktUC4B1MNOw24LiGtiJg7FAzP-PA1cAp54VatqQWYTKfrlw/ytvjV6looCQi87xEfkwZ3L7SIvzqdFqH5SQKFAm_xKw'), ('width', 93), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l-EmVWh8X3sm8KSi4NjmWg/OU75R8ApOPn90WsJkgxI699hQxXEezeQ-fYdgcFepq6u4Fby59OuFVPDF9ras94isASD6Wbu99aXDlD3sPGePQ/Z-ZUpMELO6MCaKr_Fm-bLi53SZoWNIcANcf-zdqoKCw'), ('width', 389), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JwS4SrH-vbjnJEtAn0JDPA/A7_tAsb1q6uv7j66wMznjo3xnrw-eEhjuI4yB-NKL23k4LrFm1F_aVBrnTekauJbAMXpJrI100blIWdjvZ-BCA/1qJcihuyYAQ52Z5wUvel9ue4FdIjlDNe4E59R0ZqUEQ'), ('width', 3000), ('height', 3000)]))]))])]",https://razorbillinstruments.com/,Write a Python script that uses Pymeasure to connect to a Razorbill RP100 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Razorbill RP100,https://razorbillinstruments.com/wp-content/uploads/2018/10/RP100-Manual-v6.1-1.pdf,"[OrderedDict([('id', 'attZaMT95mRfMJMtO'), ('width', 1596), ('height', 709), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9FXj7cjsRXMagnfAb0vjeg/Mq6Z5u9HYfBRAHlASUxR8IvIKJegRhyQ4WJvXCSrYWlLNQCR7xAZyS5dLmSXJWtornSvD8TJdP-VJ8PPWZd95TKW5P97lvLUQMXRWkKksmU/L_GE_Sy5MVlnZRHxRQcnssW9OnsnwG6-LSk9HCjKthY'), ('filename', 'rendering7.jpeg'), ('size', 105627), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IlKTYCwssE2SIkatu76n1w/m120cjc4snz_sxMmbXyinXyWbVFHJBQZ5-ERIxd5OPh7GgDNPB07beKLZltBkuMiunp2C5G-lmL3w-P5J95cqQ/1iBmU1Vmu-g0QdKKxIHWJBPIojO3aToCTawwhD5_A3g'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/awG3TBeZHpkD2mjcO9N4hg/FPLlqbmO8G2Oi3R0oTU3ACOkWRCfqXHkPD3uzqjWX_-BDivSiDgg5E7iK9bBW75Lp7EpSG_ODRFPv4aH_Ec4Lw/ptOcCHXOOJY5dWKKFp8oZZxwdOl1l-2CWZLPHDDJ8xo'), ('width', 1153), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7bbe361OP-26vN76xrrDyw/k9OkiHDM3L86EWKjXunbJ3aqHgI5jpWyiaw_-yroE3-L7_LdukYZQiZE8gV5PGBGTGu90h8IcuFYbA0nMhkTbw/qOudQ7OhAuZ5_lqFFHE-eWneMSuCMjz9D3rDYQJMqgQ'), ('width', 3000), ('height', 3000)]))]))])]",https://razorbillinstruments.com/wp-content/uploads/2018/10/RP100-Manual-v6.1-1.pdf,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/razorbill/razorbillRP100.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/razorbill/razorbillRP100.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              strict_range)


class razorbillRP100(Instrument):
    """"""Represents Razorbill RP100 strain cell controller

    .. code-block:: python

        scontrol = razorbillRP100(""ASRL/dev/ttyACM0::INSTR"")

        scontrol.output_1 = True      # turns output on
        scontrol.slew_rate_1 = 1      # sets slew rate to 1V/s
        scontrol.voltage_1 = 10       # sets voltage on output 1 to 10V

    """"""

    output_1 = Instrument.control(""OUTP1?"", ""OUTP1 %d"",
                                  """"""Turns output of channel 1 on or off"""""",
                                  validator=strict_discrete_set,
                                  values={True: 1, False: 0},
                                  map_values=True)

    output_2 = Instrument.control(""OUTP2?"", ""OUTP2 %d"",
                                  """"""Turns output of channel 2 on or off"""""",
                                  validator=strict_discrete_set,
                                  values={True: 1, False: 0},
                                  map_values=True)

    voltage_1 = Instrument.control(""SOUR1:VOLT?"", ""SOUR1:VOLT %g"",
                                   """"""Sets or queries the output voltage of channel 1"""""",
                                   validator=strict_range,
                                   values=[-230, 230])

    voltage_2 = Instrument.control(""SOUR2:VOLT?"", ""SOUR2:VOLT %g"",
                                   """"""Sets or queries the output voltage of channel 2"""""",
                                   validator=strict_range,
                                   values=[-230, 230])

    slew_rate_1 = Instrument.control(
        ""SOUR1:VOLT:SLEW?"", ""SOUR1:VOLT:SLEW %g"",
        """"""Sets or queries the source slew rate in volts/sec of channel 1"""""",
        validator=strict_range,
        values=[0.1 * 10e-3, 100 * 10e3]
    )

    slew_rate_2 = Instrument.control(
        ""SOUR2:VOLT:SLEW?"", ""SOUR2:VOLT:SLEW %g"",
        """"""Sets or queries the source slew rate in volts/sec of channel 2"""""",
        validator=strict_range,
        values=[0.1 * 10e-3, 100 * 10e3]
    )

    instant_voltage_1 = Instrument.measurement(
        ""SOUR1:VOLT:NOW?"",
        """"""Returns the instantaneous output of source one in volts""""""
    )

    instant_voltage_2 = Instrument.measurement(
        ""SOUR2:VOLT:NOW?"",
        """"""Returns the instanteneous output of source two in volts""""""
    )

    contact_voltage_1 = Instrument.measurement(
        ""MEAS1:VOLT?"",
        """"""Returns the Voltage in volts present at the front panel output of channel 1""""""
    )

    contact_voltage_2 = Instrument.measurement(
        ""MEAS2:VOLT?"",
        """"""Returns the Voltage in volts present at the front panel output of channel 2""""""
    )

    contact_current_1 = Instrument.measurement(
        ""MEAS1:CURR?"",
        """"""Returns the current in amps present at the front panel output of channel 1""""""
    )

    contact_current_2 = Instrument.measurement(
        ""MEAS2:CURR?"",
        """"""Returns the current in amps present at the front panel output of channel 2""""""
    )

    def __init__(self, adapter, name=""Razorbill RP100 Piezo Stack Powersupply"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        self.timeout = 20
"
118,367.3,"Abingdon, United Kingdom",,PS 120  10,411.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Pymeasure,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,,,,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/oxfordinstruments/ps120_10.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/oxfordinstruments/PS120_10.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


from .ips120_10 import IPS120_10


def PS_custom_get_process(v):
    """"""Adjust the received value, for working with the PS 120-10 """"""
    return v * 1e-2


def PS_custom_set_process(v):
    """"""Convert float to proper int value, for working with the PS 120-10 """"""
    return int(v * 1e2)


class PS120_10(IPS120_10):
    """"""Represents the Oxford Superconducting Magnet Power Supply PS 120-10.

    .. code-block:: python

        ps = PS120_10(""GPIB::25"")   # Default channel for the IPS

        ps.enable_control()         # Enables the power supply and remote control

        ps.train_magnet([           # Train the magnet after it has been cooled-down
            (11.8, 1.0),
            (13.9, 0.4),
            (14.9, 0.2),
            (16.0, 0.1),
        ])

        ps.set_field(12)            # Bring the magnet to 12 T. The switch heater will
                                    # be turned off when the field is reached and the
                                    # current is ramped back to 0 (i.e. persistent mode).

        print(self.field)           # Print the current field (whether in persistent or
                                    # non-persistent mode)

        ps.set_field(0)             # Bring the magnet to 0 T. The persistent mode will be
                                    # turned off first (i.e. current back to set-point and
                                    # switch-heater on); afterwards the switch-heater will
                                    # again be turned off.

        ps.disable_control()        # Disables the control of the supply, turns off the
                                    # switch-heater and clamps the output.

    :param clear_buffer: A boolean property that controls whether the instrument
        buffer is clear upon initialisation.
    :param switch_heater_heating_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned on before the heater is expected to be heated.
    :param switch_heater_cooling_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned off before the heater is expected to be cooled down.
    :param field_range: A numeric value or a tuple of two values to indicate the
        lowest and highest allowed magnetic fields. If a numeric value is provided
        the range is expected to be from :code:`-field_range` to :code:`+field_range`.

    """"""

    def __init__(self,
                 adapter,
                 name=""Oxford PS"",
                 **kwargs):

        super().__init__(
            adapter=adapter,
            name=name,
            **kwargs,
        )

    current_measured_get_process = PS_custom_get_process

    demand_current_get_process = PS_custom_get_process

    demand_field_get_process = PS_custom_get_process

    persistent_field_get_process = PS_custom_get_process

    current_setpoint_get_process = PS_custom_get_process
    current_setpoint_set_process = PS_custom_set_process
    current_setpoint_set_command = ""I%d""

    field_setpoint_get_process = PS_custom_get_process
    field_setpoint_set_process = PS_custom_set_process
    field_setpoint_set_command = ""J%d""

    sweep_rate_get_process = PS_custom_get_process
    sweep_rate_set_process = PS_custom_set_process
    sweep_rate_set_command = ""T%d""
"
119,700.0,US,"Fluke 3000 FC Series Wireless Multimeter
",Fluke 3000,126.0,"**Fluke** Corporation is the world leader in professional electronic test tools and software for measuring and condition monitoring.

",Pymeasure,Fluke,"[OrderedDict([('id', 'attC77II6inAac4Sm'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9WWA4UjSWVTpWMMEjsR6vg/jZSq-z9vRcV08YGF397tLMPsv24Hsen54jg7YwdvLY5S1LdNMCG4UT1e1XEJNJah3ez0r4jV1l-U1xsIg_eukzTq7MzdlAFUlWPPQ_AOUUU_YiFBru8S7xamJhfYx_3a/TvX-lQsa7EdTHBKWrW-VFrSIc_8zwOppO_udCzsvYC0'), ('filename', 'fluke-corporation-logo-vector.png'), ('size', 1735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IjPQZO64bHfSRGAqoYNJuw/dq0yUEkV1WvvB7b3iKkTQO45ujT7f14s4AK_RyMyYa0hpFOyxvUS_bT-tri-LqikcGWQ80Nc4QvpDOEtoNOtDQ/XJxuwIbaOtdhS-z-SuImchIlC16auoQAGZCSJqrc51Q'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jGOrb0UaNe5Q_i4uqiPOlA/4nCn6K7uowMN_VYEoMaTi7XMcRg5ifnly8R1yal5VElzER4qXlDT_1p52mE5PVL6P1WSHgKEVUYdl2uIvvoMmw/reFtSzwDWFTjW7Lo7v1maVc8WKhEBAtbWEnz7911crE'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/H6wJOaHQV_41xbu9wufRlw/RXrDmPfI0Svzem4iwAu49OUaxRppwW7MRoT1tZUsw2p44WW9JuoDWaLqT8WF5a0xGIXKy93iqhSpi7HrtQDJmw/K76LWM7xD0Hk99xPqI_Qcq3lCGE6Y3ZpsHx4SWp8UrA'), ('width', 3000), ('height', 3000)]))]))])]",https://us.flukecal.com/,Write a Python script that uses Pymeasure to connect to a Fluke 3000 FC Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Fluke 3000 FC,https://www.fluke.com/en-ca/product/electrical-testing/digital-multimeters/fluke-3000-fc#,"[OrderedDict([('id', 'attQlzIXLwmsONZUS'), ('width', 640), ('height', 640), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2np5nfDB86-SuTdENH6soQ/aOIFEXDmeM95nPc9hLXW1OkkP_xA1xRw-2_vV-4ywtt9E5slrerv5zKSbq--QZQlhwW8icqslfimooejsdrjAgsrl9uAS8Z5_BYGEDHJeLw/E6PeqVin7Wl2ubDYpCfJ76A0YMOMbZGhBr9UsRylWPI'), ('filename', 'MFG_FLK_3000 FC.webp'), ('size', 18214), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xuHBzb5c7HDyoCQ5zzTbrg/7ocAZRiQtp9QJg6GCFO8wgEkj7O_80EvjZXxK2HkDRaPGkkF-4zYmx9XBANstEjvOtyaJpp5CdV_do7hq-iD0tmFtnYaa1ikEdG8M68WFmA/_LiYEoh-bLzI6ugDMCzKuCUO8fQof4kD6zevSzv0hMo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ryf9mmjdnBSAG8R9u9_Vig/MONR0D11RIpLryfquHscRbpwCB6E6NaJtNso52AoxZq18r2OWl5m3zgZzrtO8wtpS_oVuMBcpnZq7T7hJldJ19v_HOs3pqCsm5ZyPd0fpoc/iKnliMsvMc2IzzTXvFZ_JbV9kf_J6ZXusEgjhvLNNyA'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SunGL2LW-aCChO5LC8Yzyw/_8Easszv99B_EGpK2Dn3bzNW1jWKZJ5WFGQghAMVOJ_KCFIzS-IMlGf0cZxbC_hfYRBAWJo_yjZPy2-QiYD5Cc6d8Amoz7xUlR1DOfEX390/vCHpM3WtTWoc_E3DTipBtlWZYc_X-CGxIk06bTfXvqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.fluke.com/en-ca/product/electrical-testing/digital-multimeters/fluke-3000-fc,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/fluke/fluke3000.html,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/fluke/fluke3000.html,480.0,,,,
129,110.6,"Cleveland, Ohio, United States","Keithley’s Standard Series 2400 Source Measure Unit (SMU) Instruments offer four-quadrant precision voltage and current source/load coupled with measurement. Each SMU instrument is both a highly stable DC power source and a true instrument-grade 6½-digit multimeter. The power source characteristics include low noise, precision, and readback. The multimeter capabilities include high repeatability and low noise.",Keithley 2400,270.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-2400-Datasheet.pdf,"[OrderedDict([('id', 'attFCwQhJ4waLZGsg'), ('width', 327), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ufM9niuYoxIqNOZhZ6C-ew/ncGFMJTq6JXc3xeEJwO-HdOvCTZeRz2xtT6xisW2VmC3xZdVm3emtOpPuffoxOxHANIRw7QbgXftUsoTX4hSR3tw9EidUaGKNm7xoPcnbv0/kMGQ9cu0KbZ0jws896dyOQk4vl1yHBOGnbJVv5ZHV7M'), ('filename', '2400.webp'), ('size', 10742), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2hYIsb3W4uCpf6cEK92ORw/kWA0bz799rNdks3QxCSMxnhUlaGrNPrapQAwBqG7Zd8vErwWyyKfo5nPUrT6WLGdBh_zQsLiFJtogHXmN5ZMK0NJObPdnHhnH4C0r2iMrcU/XKIrAHx_-g9SQLaFbBhoakI2KSl-qZntQ85scnqwP8k'), ('width', 38), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/23PRKGoP3FUGhD9roP1lrQ/-9NkQMMg0mPbZsSQenA6RH07wUt24ZmCMDsEVPHJYz143xONzFWOWZRg4rWXHQlRrM7DXVX043gqYXXBGkTkhSi-HqCkvsKydM4fWsbjBww/Bt800-nWeS1c5z1fKtJ1YzFi7G-Ofd3eODSLxu2ZaeI'), ('width', 327), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1XfEbUYOO0xMqV3JUkbkag/nXCjuiDj8PVuqVxlatzaBPg5ce4CSu1mLqH_oF5XBUijTlPnZfpHuxcfCyQ8bfwb6R15dDL73B8Sa_9iY6O7rT0CtwuX6JFotZL_K2refUU/eI-oPkMeTjLzZKHYfvnI7XgnnryNxa1PcQfJ6FSigP0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/source-measure-units/2400-standard-series-sourcemeter,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2400.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2400.html,13000.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument, RangeException
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

from .buffer import KeithleyBuffer


log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2400(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2400 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2400(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2400.apply_current` and :meth:`~.Keithley2400.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.control(
        ""OUTPut?"", ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False. The convenience methods :meth:`~.Keithley2400.enable_source` and
        :meth:`~.Keithley2400.disable_source` can also be used."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    auto_output_off = Instrument.control(
        "":SOUR:CLE:AUTO?"", "":SOUR:CLE:AUTO %d"",
        """""" A boolean property that enables or disables the auto output-off.
        Valid values are True (output off after measurement) and False (output
        stays on after measurement). """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    source_delay = Instrument.control(
        "":SOUR:DEL?"", "":SOUR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_delay_auto = Instrument.control(
        "":SOUR:DEL:AUTO?"", "":SOUR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    auto_zero = Instrument.control(
        "":SYST:AZER:STAT?"", "":SYST:AZER:STAT %s"",
        """""" A property that controls the auto zero option. Valid values are
        True (enabled) and False (disabled) and 'ONCE' (force immediate). """""",
        values={True: 1, False: 0, ""ONCE"": ""ONCE""},
        map_values=True,
    )

    line_frequency = Instrument.control(
        "":SYST:LFR?"", "":SYST:LFR %d"",
        """""" An integer property that controls the line frequency in Hertz.
        Valid values are 50 and 60. """""",
        validator=strict_discrete_set,
        values=[50, 60],
        cast=int,
    )

    line_frequency_auto = Instrument.control(
        "":SYST:LFR:AUTO?"", "":SYST:LFR:AUTO %d"",
        """""" A boolean property that enables or disables auto line frequency.
        Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    measure_concurent_functions = Instrument.control(
        "":SENS:FUNC:CONC?"", "":SENS:FUNC:CONC %d"",
        """""" A boolean property that enables or disables the ability to measure
        more than one function simultaneously. When disabled, volts function
        is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    compliance_current = Instrument.control(
        "":SENS:CURR:PROT?"", "":SENS:CURR:PROT %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )
    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )
    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    compliance_voltage = Instrument.control(
        "":SENS:VOLT:PROT?"", "":SENS:VOLT:PROT %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )
    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )
    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    wires = Instrument.control(
        "":SYSTEM:RSENSE?"", "":SYSTEM:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 2500],
        cast=int
    )
    means = Instrument.measurement(
        "":CALC3:FORM MEAN;:CALC3:DATA?;"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )
    maximums = Instrument.measurement(
        "":CALC3:FORM MAX;:CALC3:DATA?;"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )
    minimums = Instrument.measurement(
        "":CALC3:FORM MIN;:CALC3:DATA?;"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )
    standard_devs = Instrument.measurement(
        "":CALC3:FORM SDEV;:CALC3:DATA?;"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Trigger #
    ###########

    trigger_count = Instrument.control(
        "":TRIG:COUN?"", "":TRIG:COUN %d"",
        """""" An integer property that controls the trigger count,
        which can take values from 1 to 9,999. """""",
        validator=truncated_range,
        values=[1, 2500],
        cast=int
    )
    trigger_delay = Instrument.control(
        "":TRIG:SEQ:DEL?"", "":TRIG:SEQ:DEL %g"",
        """""" A floating point property that controls the trigger delay
        in seconds, which can take values from 0 to 999.9999 s. """""",
        validator=truncated_range,
        values=[0, 999.9999]
    )

    ###########
    # Filters #
    ###########

    filter_type = Instrument.control(
        "":SENS:AVER:TCON?"", "":SENS:AVER:TCON %s"",
        """""" A String property that controls the filter's type.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    filter_count = Instrument.control(
        "":SENS:AVER:COUNT?"", "":SENS:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    filter_state = Instrument.control(
        "":SENS:AVER?"", "":SENS:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    #####################
    # Output subsystem #
    #####################

    output_off_state = Instrument.control(
        "":OUTP:SMOD?"", "":OUTP:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2400 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."" % self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:MODE MAN;""
                   "":SENS:RES:NPLC %f;:FORM:ELEM RES;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."" % self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;:FORM:ELEM VOLT;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."" % self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;:FORM:ELEM CURR;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2400.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2400.current_range` value or None
        """"""
        log.info(""%s is sourcing current."" % self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2400.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2400.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."" % self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """""" A boolean property that controls whether or not the display of the
        sourcemeter is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2400 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2400 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":ARM:SOUR IMM;:TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":ARM:COUN 1;:ARM:SOUR BUS;:TRIG:SOUR BUS;"")

    def set_trigger_counts(self, arm, trigger):
        """""" Sets the number of counts for both the sweeps (arm) and the
        points in those sweeps (trigger), where the total number of
        points can not exceed 2500
        """"""
        if arm * trigger > 2500 or arm * trigger < 0:
            raise RangeException(""Keithley 2400 has a combined maximum ""
                                 ""of 2500 counts"")
        if arm < trigger:
            self.write("":ARM:COUN %d;:TRIG:COUN %d"" % (arm, trigger))
        else:
            self.write("":TRIG:COUN %d;:ARM:COUN %d"" % (trigger, arm))

    def sample_continuously(self):
        """""" Causes the instrument to continuously read samples
        and turns off any buffer or output triggering
        """"""
        self.disable_buffer()
        self.disable_output_trigger()
        self.trigger_immediately()

    def set_timed_arm(self, interval):
        """""" Sets up the measurement to be taken with the internal
        trigger at a variable sampling rate defined by the interval
        in seconds between sampling points
        """"""
        if interval > 99999.99 or interval < 0.001:
            raise RangeException(""Keithley 2400 can only be time""
                                 "" triggered between 1 mS and 1 Ms"")
        self.write("":ARM:SOUR TIM;:ARM:TIM %.3f"" % interval)

    def trigger_on_external(self, line=1):
        """""" Configures the measurement trigger to be taken from a
        specific line of an external trigger

        :param line: A trigger line from 1 to 4
        """"""
        cmd = "":ARM:SOUR TLIN;:TRIG:SOUR TLIN;""
        cmd += "":ARM:ILIN %d;:TRIG:ILIN %d;"" % (line, line)
        self.write(cmd)

    def output_trigger_on_external(self, line=1, after='DEL'):
        """""" Configures the output trigger on the specified trigger link
        line number, with the option of supplying the part of the
        measurement after which the trigger should be generated
        (default to delay, which is right before the measurement)

        :param line: A trigger line from 1 to 4
        :param after: An event string that determines when to trigger
        """"""
        self.write("":TRIG:OUTP %s;:TRIG:OLIN %d;"" % (after, line))

    def disable_output_trigger(self):
        """""" Disables the output trigger for the Trigger layer
        """"""
        self.write("":TRIG:OUTP NONE"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def status(self):
        return self.ask(""status:queue?;"")

    def RvsI(self, startI, stopI, stepI, compliance, delay=10.0e-3, backward=False):
        num = int(float(stopI - startI) / float(stepI)) + 1
        currRange = 1.2 * max(abs(stopI), abs(startI))
        # self.write("":SOUR:CURR 0.0"")
        self.write("":SENS:VOLT:PROT %g"" % compliance)
        self.write("":SOUR:DEL %g"" % delay)
        self.write("":SOUR:CURR:RANG %g"" % currRange)
        self.write("":SOUR:SWE:RANG FIX"")
        self.write("":SOUR:CURR:MODE SWE"")
        self.write("":SOUR:SWE:SPAC LIN"")
        self.write("":SOUR:CURR:STAR %g"" % startI)
        self.write("":SOUR:CURR:STOP %g"" % stopI)
        self.write("":SOUR:CURR:STEP %g"" % stepI)
        self.write("":TRIG:COUN %d"" % num)
        if backward:
            currents = np.linspace(stopI, startI, num)
            self.write("":SOUR:SWE:DIR DOWN"")
        else:
            currents = np.linspace(startI, stopI, num)
            self.write("":SOUR:SWE:DIR UP"")
        self.connection.timeout = 30.0
        self.enable_source()
        data = self.values("":READ?"")

        self.check_errors()
        return zip(currents, data)

    def RvsIaboutZero(self, minI, maxI, stepI, compliance, delay=10.0e-3):
        data = []
        data.extend(self.RvsI(minI, maxI, stepI, compliance=compliance, delay=delay))
        data.extend(self.RvsI(minI, maxI, stepI, compliance=compliance, delay=delay, backward=True))
        self.disable_source()
        data.extend(self.RvsI(-minI, -maxI, -stepI, compliance=compliance, delay=delay))
        data.extend(self.RvsI(-minI, -maxI, -stepI, compliance=compliance, delay=delay,
                              backward=True))
        self.disable_source()
        return data

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."" % self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
134,2940.0,Japan,The Advantest R3765CG/R3767CG network analyzers are vector network analyzers that incorporate a new RF circuit analysis technique.,Advantestr 3767 CG,1.0,"Advantest manufactures and sells semiconductor and component test system products and mechatronics-related products.
",Pymeasure,Advantest,"[OrderedDict([('id', 'attoXUfAlOUSTI5he'), ('width', 153), ('height', 19), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kriaqJAXdjEUNmhaWqU_Ww/V4rcnVZXDt3df7VHtXg4mzia9ciTXoPlmL8rABazh15z_hwDUKB8CDc1NmbVNW7f6bv6qSp2AdfPL4XPGA0yvX6aSZhL3sI4h1YBGBqFwNU/dT1m_crlECIbrcsDzChkcjVMrVY56U_fl0ZsWZ6vu70'), ('filename', 'advantest-logo.gif'), ('size', 912), ('type', 'image/gif'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xJJzDt35Gyum1fBfqTomxA/kTp3BFicWItP0uVzwtnrnlt7252dVDnwjhjem--DhTTolXzd7Vp6WJwTe8uclYY5kCqv2mcuWptgW7UzWArqMg/sCHukeqi7HHhLrI3uYcbq4WJVBsPFyBJq9zEuX25v0Q'), ('width', 153), ('height', 19)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/P7A4vWRYyGikfiZGAv1IXw/fV6VFdijxdgPZY35GN8h262LWXo_m7kQC-tfCkEbzHhn6fm5j9nzC0Mq-AbdqcPC3KiBBwKTINdPyutj0QCvFQ/Z79Dn0JnGIHBG_VYtfCnrzEq3bj-CVKmEomNwLwc0T4'), ('width', 153), ('height', 19)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yqJGLfhEAeyQgcopoYBn0A/m_UjL4O75rZclQcLAC7A4cfSR0EzeZkqJEcUqiRaxHGOJOW0Qe0oGYA9oFtw6qC8YUiFiLcx-7BNc9Wwr8HHag/1epazg79U4qJilv4SWML45DpISrZ9GAeh6bdlIhMe_E'), ('width', 3000), ('height', 3000)]))]))])]",http://www.advantest.com/,Write a Python script that uses Pymeasure to connect to a Advantest R3767CG Network Analyzer,https://www.keysight.com/blogs/tech/rfmw/2019/03/08/network-analyzer-basics-you-need-to-know,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",Advantest R3767CG,https://www.testequipmenthq.com/datasheets/ADVANTEST-R3767CG-Datasheet.pdf,"[OrderedDict([('id', 'att1uDag9L17iJOra'), ('width', 260), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VLT2QTQn0RnlOUXPgKg-sg/XcUElvU5n_jG6ZKdPv60WxAEWlJ8rG01-dUVQR6wYStJeV97L6SRt1t7WzbhfFm6AHdJkzXwpM2pd2ke43-PZPBf75WzQKJWBv-HeCvpT-obtaTtf6naf-sS1QXi8IDt/SU99ccmJVFJ-c-aHx5BVa7bb0rIHoMlNWxHr6NbCVhM'), ('filename', 'Advantest-R3766AH-23367.jpg'), ('size', 13704), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Tl_mHwwimb2UpaZZMGvlqw/vEFOBSkX97O4q4W3lysvXBDd0FN6mDTryQ9DbLvpJAT2RHbg_7hVuhN49UHt_DOykIGk-nzuZRYx8waOXRHJ9Q/ixSqxGcclWdBYbeJX2CSwTq1RmW0IRA-Aa6gAso7jAc'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xHB69UniHfiXEjpl4m_zog/tKv5NgTpGLP_J8VlDFHs8gBwTMzlQ_rnKZh1iyF6kZllD525wCeUGZ8O9RCYEUdJ2lbpMXJowdbg4SvKuu5t2w/EoLy2qVrmVeSwLKOxoOqnErfT1hEy2qxyIyLEg6f3jE'), ('width', 260), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-qdJhvpz-cCK825Rd-_2Nw/JLE51Jf0n6X6xkOhAOZIX45EcmcnuOeLP9TehqDmgnnQpK62e6aJLyjtIEjj3617GuyqjQKPCOOyKrqLKb9RPQ/v7ZstfcR9S1ACsTx-kfblkKDXt5C5sSnCJqnhwBU3Po'), ('width', 3000), ('height', 3000)]))]))])]",https://www.testequipmenthq.com/datasheets/ADVANTEST-R3765CG-Datasheet.pdf,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/advantest/advantestR3767CG.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/advantest/advantestR3767CG.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range


class AdvantestR3767CG(Instrument):
    """""" Represents the Advantest R3767CG VNA. Implements controls to change the analysis
        range and to retreve the data for the trace.
    """"""

    id = Instrument.measurement(
        ""*IDN?"", """""" Reads the instrument identification """"""
    )

    center_frequency = Instrument.control(
        "":FREQ:CENT?"", "":FREQ:CENT %d"",
        """"""Center Frequency in Hz"""""",
        validator=strict_range,
        values=[300000, 8000000000]
    )

    span_frequency = Instrument.control(
        "":FREQ:SPAN?"", "":FREQ:SPAN %d"",
        """"""Span Frequency in Hz"""""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    start_frequency = Instrument.control(
        "":FREQ:STAR?"", "":FREQ:STAR %d"",
        """""" Starting frequency in Hz """""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    stop_frequency = Instrument.control(
        "":FREQ:STOP?"", "":FREQ:STOP %d"",
        """""" Stoping frequency in Hz """""",
        validator=strict_range,
        values=[1, 8000000000]
    )

    trace_1 = Instrument.measurement(
        ""TRAC:DATA? FDAT1"", """""" Reads the Data array from trace 1 after formatting """"""
    )

    def __init__(self, adapter, name=""Advantest R3767CG"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

        # Tell unit to operate in IEEE488.2-1987 command mode.
        self.write(""OLDC OFF"")
"
136,2500.0,"Munich, Germany","Generation of standard TV signals (standards B&G, D&K, L&L, I, M, N, K1) including stereo/dual sound and NICAM
Double-sideband test modulator for all IFs between 32 and 46 MHz
RF upconverter, 5 to 1000 MHz, with high frequency resolution (1 Hz)",SFM,468.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Pymeasure,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Pymeasure to connect to a {Device name} RF Signal Generator,https://en.wikipedia.org/wiki/Television_transmitter,['RF Signal Generator'],"A television transmitter is a transmitter that is used for terrestrial (over-the-air) television broadcasting. It is an electronic device that radiates radio waves that carry a video signal representing moving images, along with a synchronized audio channel, which is received by television receivers ('televisions' or 'TVs') belonging to a public audience, which display the image on a screen. A television transmitter, together with the broadcast studio which originates the content, is called a television station. Television transmitters must be licensed by governments, and are restricted to a certain frequency channel and power level. They transmit on frequency channels in the VHF and UHF bands. Since radio waves of these frequencies travel by line of sight, they are limited by the horizon to reception distances of 40–60 miles depending on the height of transmitter station.",,https://www.testequipmenthq.com/datasheets/Rohde-Schwarz-SFM-Datasheet.pdf,"[OrderedDict([('id', 'attZfK0euyafNAfDM'), ('width', 275), ('height', 183), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TwujMFWOXep4j7fJzfNZUQ/7jusI204etdCXoc3jF7UzId9Az560TsyuiQ0d_lMSTdcF0q_szMZVe5flNT0QzaMqUAEq5qoDCbpfkXn7IS1XaemBThG_syxP8KiezfmxDg/niSMLtc4X4Jq0ldRqKYTElM1qxD8AWUE1clA4yCFJdc'), ('filename', 'download (3).jpg'), ('size', 5928), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l0EhikIyEXwElYGv5yeplg/dlLQTXlnMj55cFewYjOUV2o17z0Tur36x08zR5JTwD066EapLG7Kz9TjOkJ-jU5xzHi-Rul0diuXWR9f1zhe0g/WA9E-U1dIXonPzPMtg66OLNoySHUjvbgUciQfFlPoiU'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bYLj6o7LdN6GA5HKZXREqg/mWj_v9nIJeqRrdtx6EQP2-swVvggpqz9SkYxEgs00QpnRiGYMFpJgjHlIROGIQGliYJGwAmqRWqs0SC2qqFjAA/WGGYurjzSEtNU1shfp1w8cUrDAVK6rkX7sf6XXumAqw'), ('width', 275), ('height', 183)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9xwlRUSOZbzvUOnfvCOdaw/TZWnHsrgZQD6GZlbXf0KK1bxHJ_al_Li9FGM7zoF_bLHuhjjQxS-CifXv3VClascEC4O3Edb3sZe3Nw80187oQ/ep0K4AUT01G0dZWSUwTXbTo17xILym2v21M8qUitw6o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.testwall.com/product/rohde-schwarz-sfm/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/sfm.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/sfm.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Sound_Channel:
    """"""
    Class object for the two sound channels

    refere also to chapter 3.6.6.7 of the user manual
    """"""
    modulation_degree = Instrument.control(
        ""AUD:DEGR?"",
        ""AUD:DEGR %g"",
        """""" A float property that controls the modulation depth for the audio signal
        (Note: only for the use of AM in Standard L)

        valid range: 0 .. 1 (100%)
        """""",
        validator=strict_range,
        values=[0, 1],
    )

    deviation = Instrument.control(
        ""AUD:DEV?"",
        ""AUD:DEV %d"",
        """""" A int property that controls deviation of the selected audio signal

        valid range: 0 .. 110 kHz
        """""",
        validator=strict_range,
        values=[0, 1.1E5],
    )

    frequency = Instrument.control(
        ""AUD:FREQ?"",
        ""AUD:FREQ %d"",
        """""" A int property that controls the frequency of the internal sound generator

        valid range: 300 Hz .. 15 kHz
        """""",
        validator=strict_range,
        values=[300, 1.5E4],
    )

    use_external_source = Instrument.control(
        ""FREQ:SOUR?"",
        ""FREQ:SOUR %s"",
        """""" A bool property for the audio source selection

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal audio generator(s)
        True    External signal source
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    modulation_enabled = Instrument.control(
        ""AUD:FREQ:STAT?"",
        ""AUD:FREQ:STAT %s"",
        """""" A bool property that controls the audio modulation status

        ======  =======
        Value   Meaning
        ======  =======
        False   modulation disabled
        True    modulation enabled
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    carrier_frequency = Instrument.control(
        ""CARR:FREQ?"",
        ""CARR:FREQ %g"",
        """""" A float property that controls the frequency of the sound carrier

        valid range: 32 .. 46 MHz

        """""",
        validator=strict_range,
        values=[38.75E6, 52.75E6],
    )

    carrier_level = Instrument.control(
        ""CARR:LEV?"",
        ""CARR:LEV %g"",
        """""" A float property that controls the level of the audio carrier in dB
        relative to the vision carrier (0dB)

        valid range: -34 .. -6 dB
        """""",
        validator=strict_range,
        values=[-34, 6],
    )

    carrier_enabled = Instrument.control(
        ""CARR:STAT?"",
        ""CARR:STAT %s"",
        """""" A bool property that controls if the audio carrier is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    preemphasis_time = Instrument.control(
        ""PRE:MODE?"",
        ""PRE:MODE %s"",
        """""" A int property that controls if the mode of the preemphasis for the audio signal

        ======  =======
        Value   Meaning
        ======  =======
        50      50 us preemphasis
        75      75 us preemphasis
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={50: ""US50"", 75: ""US75""},
        map_values=True,
    )

    preemphasis_enabled = Instrument.control(
        ""PRE:STAT?"",
        ""PRE:STAT %s"",
        """""" A bool property that controls if the preemphasis for the audio is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any keyword arguments.
        """"""
        return self.instrument.values(""SOUR:TEL:MOD:SOUN%d:%s"" % (
                                      self.number, command), **kwargs)

    def ask(self, command):
        self.instrument.ask(""SOUR:TEL:MOD:SOUN:%d:%s"" % (self.number, command))

    def write(self, command):
        self.instrument.write(""SOUR:TEL:MOD:SOUN:%d:%s"" % (self.number, command))

    def read(self):
        self.instrument.read()


class SFM(Instrument):
    """""" Represents the Rohde&Schwarz SFM TV test transmitter
    interface for interacting with the instrument.

    .. Note::
        The current implementation only works with the first system in this unit.

        Further source extension for system 2-6 would be required.

        The intermodulation subsystem is also not yet implmented.

    """"""

    def __init__(self, adapter, name=""Rohde&Schwarz SFM"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=True,
            **kwargs
        )
        self.sound1 = Sound_Channel(self, 1)
        self.sound2 = Sound_Channel(self, 2)

    def calibration(self, number=1, subsystem=None):
        """"""
        Function to either calibrate the whole modulator, when subsystem parameter is omitted,
        or calibrate a subsystem of the modulator.

        Valid subsystem selections: ""NICam, VISion, SOUNd1, SOUNd2, CODer""

        """"""
        if subsystem is None:
            self.write(""CAL:MOD%d"" % (number))
        else:
            self.write(
                ""CAL:MOD%d:%s"" % (
                    number,
                    strict_discrete_set(subsystem,
                                        [""NIC"", ""NICAM"", ""VIS"", ""VISION"", ""SOUN1"",
                                         ""SOUND1"", ""SOUN2"", ""SOUND2"", ""COD"", ""CODER""])
                )
            )

    # INST (Manual 3.6.4)
    system_number = Instrument.control(
        ""INST:SEL?"",
        ""INST:SEL:%s"",
        """"""A int property for the selected systems (if more than 1 available)

        * Minimum 1
        * Maximum 6

        """""",
        validator=strict_discrete_set,
        values={1: ""SYS1"", 2: ""SYS2"", 3: ""SYS3"", 4: ""SYS4"", 5: ""SYS5"", 6: ""SYS6""},
        map_values=True,
        check_set_errors=True,
    )

    R75_out = Instrument.control(
        ""ROUT:CHAN:OUTP:IMP?"",
        ""ROUT:CHAN:OUTP:IMP %s"",
        """""" A bool property that controls the use of the 75R output (if installed)

        ======  =======
        Value   Meaning
        ======  =======
        False   50R output active (N)
        True    75R output active (BNC)
        ======  =======

        refer also to chapter 3.6.5 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""LOW"", True: ""HIGH""},
        map_values=True,
    )

    ext_ref_base_unit = Instrument.control(
        ""ROUT:REF:CLOCK:BAS?"",
        ""ROUT:REF:CLOCK:BAS %s"",
        """""" A bool property for the external reference for the basic unit

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal 10 MHz is used
        True    External 10 MHz is used
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    ext_ref_extension = Instrument.control(
        ""ROUT:REF:CLOCK:EXT?"",
        ""ROUT:REF:CLOCK:EXT %s"",
        """""" A bool property for the external reference for the extension frame

        ======  =======
        Value   Meaning
        ======  =======
        False   Internal 10 MHz is used
        True    External 10 MHz is used
        ======  =======
        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    ext_vid_connector = Instrument.control(
        ""ROUT:TEL:VID:EXT?"",
        ""ROUT:TEL:VID:EXT %s"",
        """"""A string property controlling which connector is used as the input of the video source

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        HIGH    Front connector - Hi-Z
        LOW     Front connector - 75R
        REAR1   Rear connector 1
        REAR2   Rear connector 2
        AUTO    Automatic assignment
        ======  =======
        """""",
        validator=strict_discrete_set,
        values=[""HIGH"", ""LOW"", ""REAR1"", ""REAR2"", ""AUTO""],
    )

    channel_table = Instrument.control(
        ""SOUR:FREQ:CHAN:TABL ?"",
        ""SOUR:FREQ:CHAN:TABL %s"",
        """"""A string property controlling which channel table is used

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        DEF     Default channel table
        USR1    User table No. 1
        USR2    User table No. 2
        USR3    User table No. 3
        USR4    User table No. 4
        USR5    User table No. 5
        ======  =======

        refer also to chapter 3.6.6.1 of the manual
        """""",
        validator=strict_discrete_set,
        values=[""DEF"", ""USR1"", ""USR2"", ""USR3"", ""USR4"", ""USR5""],
    )

    normal_channel = Instrument.control(
        ""SOUR:FREQ:CHAN:NORM ?"",
        ""SOUR:FREQ:CHAN:NORM %d"",
        """"""A int property controlling the current selected regular/normal channel number
        valid selections are based on the country settings.
        """""",
    )

    special_channel = Instrument.control(
        ""SOUR:FREQ:CHAN:SPEC ?"",
        ""SOUR:FREQ:CHAN:SPEC %d"",
        """"""A int property controlling the current selected special channel number
        valid selections are based on the country settings.
        """""",
    )

    def channel_up_relative(self):
        """"""
        Increases the output frequency to the next higher channel/special channel
        based on the current country settings
        """"""
        Instrument.write(self, ""SOUR:CHAN:REL UP"")

    def channel_down_relative(self):
        """"""
        Decreases the output frequency to the next low channel/special channel
        based on the current country settings
        """"""
        Instrument.write(self, ""SOUR:CHAN:REL DOWN"")

    channel_sweep_start = Instrument.control(
        ""SOUR:FREQ:CHAN:STAR?"",
        ""SOUR:FREQ:CHAN:STAR %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    channel_sweep_stop = Instrument.control(
        ""SOUR:FREQ:CHAN:STOP?"",
        ""SOUR:FREQ:CHAN:STOP %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    channel_sweep_step = Instrument.control(
        ""SOUR:FREQ:CHAN:STEP?"",
        ""SOUR:FREQ:CHAN:STEP %g"",
        """"""A float property controlling the start frequency for channel sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    cw_frequency = Instrument.control(
        ""SOUR:FREQ:CW?"",
        ""SOUR:FREQ:CW %g"",
        """"""A float property controlling the CW-frequency in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    frequency = Instrument.control(
        ""SOUR:FREQ:FIXED?"",
        ""SOUR:FREQ:FIXED %g"",
        """"""A float property controlling the frequency in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    frequency_mode = Instrument.control(
        ""SOUR:FREQ:MODE?"",
        ""SOUR:FREQ:MODE %s"",
        """"""A string property controlling which the unit is used in

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        CW      Continous wave mode
        FIXED   fixed frequency mode
        CHSW    Channel sweep
        RFSW    Frequency sweep
        ======  =======

        .. Note::
            selecting the sweep mode, will start the sweep imemdiately!

        """""",
        validator=strict_discrete_set,
        values=[""CW"", ""FIXED"", ""CHSW"", ""RFSW""],
    )

    high_frequency_resolution = Instrument.control(
        ""SOUR:FREQ:RES?"",
        ""SOUR:FREQ:RES %s"",
        """""" A property that controls the frequency resolution,

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        False   Low resolution (1000Hz)
        True    High resolution (1Hz)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""LOW"", True: ""HIGH""},
        map_values=True,
    )

    rf_sweep_center = Instrument.control(
        ""SOUR:FREQ:CENTER?"",
        ""SOUR:FREQ:CENTER %g"",
        """"""A float property controlling the center frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_start = Instrument.control(
        ""SOUR:FREQ:STAR?"",
        ""SOUR:FREQ:STAR %g"",
        """"""A float property controlling the start frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_stop = Instrument.control(
        ""SOUR:FREQ:STOP?"",
        ""SOUR:FREQ:STOP %g"",
        """"""A float property controlling the stop frequency for sweep in Hz

        * Minimum 5 MHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[5E6, 1E9]
    )

    rf_sweep_step = Instrument.control(
        ""SOUR:FREQ:STEP?"",
        ""SOUR:FREQ:STEP %g"",
        """"""A float property controlling the stepwidth for sweep in Hz,

        * Minimum 1 kHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[1E3, 1E9]
    )

    rf_sweep_span = Instrument.control(
        ""SOUR:FREQ:SPAN?"",
        ""SOUR:FREQ:SPAN %g"",
        """"""A float property controlling the sweep span in Hz,

        * Minimum 1 kHz
        * Maximum 1 GHz
        """""",
        validator=strict_range,
        values=[1E3, 1E9]
    )

    level = Instrument.control(
        ""SOUR:POW:LEV?"",
        ""SOUR:POW:LEV %g DBM"",
        """"""A float property controlling the output level in dBm,

        * Minimum -99dBm
        * Maximum 10dBm (depending on output mode)

        refer also to chapter 3.6.6.2 of the manual
        """""",
        validator=strict_range,
        values=[-99, 10],
    )

    level_mode = Instrument.control(
        ""SOUR:POW:LEV:MODE?"",
        ""SOUR:POW:LEV:MODE %s"",
        """"""A string property controlling the output attenuator and linearity mode

        Possible selections are:

        ======  ====================  =================
        Value   Meaning               max. output level
        ======  ====================  =================
        NORM    Normal mode           +6 dBm
        LOWN    low noise mode        +10 dBm
        CONT    continous mode        +10 dBm
        LOWD    low distortion mode   +0 dBm
        ======  ====================  =================

        Contiuous mode allows up to 14 dB of level setting without use of the mechanical attenuator.
        """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""LOWN"", ""CONT"", ""LOWD""]
    )

    rf_out_enabled = Instrument.control(
        ""SOUR:POW:STAT?"",
        ""SOUR:POW:STATE %s"",
        """""" A bool property that controls the status of the RF-output

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    def coder_adjust(self):
        """"""
        Starts the automatic setting of the differential deviation

        refer also to chapter 3.6.6.4 of the manual

        """"""
        self.write(""SOUR:TEL:MOD:COD:ADJ"")

    coder_id_frequency = Instrument.control(
        ""SOUR:TEL:MOD:COD:IDENT:FREQ?"",
        ""SOUR:TEL:MOD:COD:IDENT:FREQ %d"",
        """""" A int property that controls the frequency of the identification of the coder

        valid range 0 .. 200 Hz
        """""",
        validator=strict_range,
        values=[0, 200],
    )

    coder_modulation_degree = Instrument.control(
        ""SOUR:TEL:MOD:COD:MOD:DEGR?"",
        ""SOUR:TEL:MOD:COD:MOD:DEGR %g"",
        """""" A float property that controls the modulation degree of the identification of the coder

        valid range: 0 .. 0.9
        """""",
        validator=strict_range,
        values=[0, 0.9],
    )

    coder_pilot_frequency = Instrument.control(
        ""SOUR:TEL:MOD:COD:PIL:FREQ?"",
        ""SOUR:TEL:MOD:COD:PIL:FREQ %d"",
        """""" A int property that controls the pilot frequency of the coder

        valid range: 40 .. 60 kHz
        """""",
        validator=strict_range,
        values=[5E4, 6E4],
    )

    coder_pilot_deviation = Instrument.control(
        ""SOUR:TEL:MOD:COD:PIL:FREQ:DEV?"",
        ""SOUR:TEL:MOD:COD:PIL:FREQ:DEV %d"",
        """""" A int property that controls deviation of the pilot frequency of the coder

        valid range: 1 .. 4 kHz
        """""",
        validator=strict_range,
        values=[1E3, 4E3],
    )

    external_modulation_power = Instrument.control(
        ""SOUR:TEL:MOD:EXT:POW?"",
        ""SOUR:TEL:MOD:EXT:POW %d"",
        """""" A int property that controls the setting for the external modulator output power

        valid range: -7..0 dBm

        refer also to chapter 3.6.6.5 of the manual
        """""",
        validator=strict_range,
        values=[-7, 0],
    )

    external_modulation_frequency = Instrument.control(
        ""SOUR:TEL:MOD:EXT:FREQ?"",
        ""SOUR:TEL:MOD:EXT:FREQ %d"",
        """""" A int property that controls the setting for the external modulator frequency

        valid range: 32 .. 46 MHz
        """""",
        validator=strict_range,
        values=[32e6, 46e6],
    )

    nicam_mode = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:MODE?"",
        ""SOUR:TEL:MOD:NIC:AUD:MODE %s"",
        """""" A string property that controls the signal type to be sent via NICAM

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        MON     Mono sound + NICAM data
        STER    Stereo sound
        DUAL    Dual channel sound
        DATA    NICAM data only
        ======  =======

        refer also to chapter 3.6.6.6 of the manual

        """""",
        validator=strict_discrete_set,
        values=[""MON"", ""STER"", ""DUAL"", ""DATA""],
    )

    nicam_audio_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:FREQ?"",
        ""SOUR:TEL:MOD:NIC:AUD:FREQ %d"",
        """""" A int property that controls the frequency of the internal sound generator

        valid range: 0 Hz .. 15 kHz
        """""",
        validator=strict_range,
        values=[0, 1.5E4],
    )

    nicam_preemphasis_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:PRE?"",
        ""SOUR:TEL:MOD:NIC:AUD:PRE %d"",
        """""" A bool property that controls the status of the J17 preemphasis

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_audio_volume = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:VOL?"",
        ""SOUR:TEL:MOD:NIC:AUD:VOL %g"",
        """""" A float property that controls the audio volume in the NICAM  modulator in dB

        valid range: 0..60 dB

        """""",
        validator=strict_range,
        values=[0, 60],
    )

    nicam_data = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:DATA?"",
        ""SOUR:TEL:MOD:NIC:AUD:DATA %d"",
        """""" A int property that controls the data in the NICAM  modulator

        valid range: 0 .. 2047
        """""",
        validator=strict_range,
        values=[0, 2047],
        cast=int
    )

    nicam_additional_bits = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:ADD?"",
        ""SOUR:TEL:MOD:NIC:AUD:ADD %d"",
        """""" A int property that controls the additional data in the NICAM  modulator

        valid range: 0 .. 2047
        """""",
        validator=strict_range,
        values=[0, 2047],
    )

    nicam_control_bits = Instrument.control(
        ""SOUR:TEL:MOD:NIC:AUD:CONT?"",
        ""SOUR:TEL:MOD:NIC:AUD:CONT %d"",
        """""" A int property that controls the additional data in the NICAM  modulator

        valid range: 0 .. 3
        """""",
        validator=strict_range,
        values=[0, 3],
    )

    nicam_bit_error_rate = Instrument.control(
        ""SOUR:TEL:MOD:NIC:BIT?"",
        ""SOUR:TEL:MOD:NIC:BIT %g"",
        """""" A float property that controls the artifical bit error rate.

        valid range: 1.2E-7 .. 2E-3
        """""",
        validator=strict_range,
        values=[1.2E-7, 2E-3],
    )

    nicam_bit_error_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:BIT:STAT?"",
        ""SOUR:TEL:MOD:NIC:BIT:STAT %d"",
        """""" A bool property that controls the status of an artifical bit error rate to be applied

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_carrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:FREQ?"",
        ""SOUR:TEL:MOD:NIC:CARR:FREQ %g"",
        """""" A float property that controls the frequency of the NICAM carrier

        valid range: 33.05 MHz +/- 0.2 Mhz

        """""",
        validator=strict_range,
        values=[32.85E6, 33.25E6],
    )

    nicam_intercarrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:NIC:INT:FREQ?"",
        ""SOUR:TEL:MOD:NIC:INT:FREQ %g"",
        """""" A float property that controls the inter-carrier frequency of the NICAM carrier

        valid range: 5 .. 9 MHz
        """""",
        validator=strict_range,
        values=[5E6, 9E6],
    )

    nicam_carrier_level = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:LEV?"",
        ""SOUR:TEL:MOD:NIC:CARR:LEV %g"",
        """""" A float property that controls the value of the NICAM carrier

        valid range: -40 .. -13 dB
        """""",
        validator=strict_range,
        values=[-40, 13],
    )

    nicam_carrier_enabled = Instrument.control(
        ""SOUR:TEL:MOD:NIC:CARR:STAT?"",
        ""SOUR:TEL:MOD:NIC:CARR:STAT %s"",
        """""" A bool property that controls if the NICAM carrier is switched on or off
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    nicam_IQ_inverted = Instrument.control(
        ""SOUR:TEL:MOD:NIC:MODE?"",
        ""SOUR:TEL:MOD:NIC:MODE %s"",
        """""" A bool property that controls if the NICAM IQ signals are inverted or not

        ======  =======
        Value   Meaning
        ======  =======
        False   normal (IQ)
        True    inverted (QI)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={False: ""IQ"", True: ""QI""},
        map_values=True,
    )

    nicam_source = Instrument.control(
        ""SOUR:TEL:MOD:NIC:SOUR?"",
        ""SOUR:TEL:MOD:NIC:SOUR %s"",
        """""" A string property that controls the signal source for NICAM

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        INT     Internal audio generator(s)
        EXT     External audio source
        CW      Continous wave signal
        RAND    Random data stream
        TEST    Test signal
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""INT"", ""EXT"", ""CW"", ""RAND"", ""TEST""],
    )

    nicam_test_signal = Instrument.control(
        ""SOUR:TEL:MOD:NIC:TEST?"",
        ""SOUR:TEL:MOD:NIC:TEST %s"",
        """""" A int property that controls the selection of the test signal applied

        ======  =======
        Value   Meaning
        ======  =======
        1       Test signal 1 (91 kHz square wave, I&Q 90deg apart)
        2       Test signal 2 (45.5 kHz square wave, I&Q 90deg apart)
        3       Test signal 3 (182 kHz sine wave, I&Q in phase)
        ======  =======

        """""",
        validator=strict_discrete_set,
        values={1: ""TST1"", 2: ""TST2"", 3: ""TST3""},
        map_values=True,
    )

    external_modulation_source = Instrument.control(
        ""SOUR:MOD:SOUR?"",
        ""SOUR:MOD:SOUR %s"",
        """""" A bool property for the modulation source selection

        refer also to chapter 3.6.6.8 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""INT"", True: ""EXT""},
        map_values=True,
    )

    modulation_enabled = Instrument.control(
        ""SOUR:MOD:STAT?"",
        ""SOUR:MOD:STAT %s"",
        """""" A bool property that controls the modulation status
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_carrier_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CARR:STAT?"",
        ""SOUR:TEL:MOD:VIS:CARR:STAT %s"",
        """""" A bool property that controls the vision carrier status

        refer also to chapter 3.6.6.9 of the manual

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_carrier_frequency = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CARR:FREQ?"",
        ""SOUR:TEL:MOD:VIS:CARR:FREQ %g"",
        """""" A float property that controls the frequency of the vision carrier

        valid range: 32 .. 46 MHz
        """""",
        validator=strict_range,
        values=[32E6, 46E6],
    )

    vision_average_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:AVER:STAT?"",
        ""SOUR:TEL:MOD:VIS:AVER:STAT %s"",
        """""" A bool property that controls the average mode for the vision system
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_balance = Instrument.control(
        ""SOUR:TEL:MOD:VIS:BAL?"",
        ""SOUR:TEL:MOD:VIS:BAL %g"",
        """""" A float property that controls the balance of the vision modulator

        valid range: -0.5 .. 0.5
        """""",
        validator=strict_range,
        values=[-0.5, 0.5],
    )

    vision_clamping_average = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:AVER?"",
        ""SOUR:TEL:MOD:VIS:CLAM:AVER %g"",
        """""" A float property that controls the operation point of the vision modulator

        valid range: -0.5 .. 0.5
        """""",
        validator=strict_range,
        values=[-0.5, 0.5],
    )

    vision_clamping_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:STAT?"",
        ""SOUR:TEL:MOD:VIS:CLAM:STAT %s"",
        """""" A bool property that controls the clamping behavior of the vision modulator

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_clamping_mode = Instrument.control(
        ""SOUR:TEL:MOD:VIS:CLAM:TYPE?"",
        ""SOUR:TEL:MOD:VIS:CLAM:TYPE %s"",
        """""" A string property that controls the clamping mode of the vision modulator

        Possible selections are HARD or SOFT
        """""",
        validator=strict_discrete_set,
        values=[""HARD"", ""SOFT""],
    )

    vision_precorrection_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:PREC?"",
        ""SOUR:TEL:MOD:VIS:PREC %s"",
        """""" A bool property that controls the precorrection behavior of the vision modulator
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_residual_carrier_level = Instrument.control(
        ""SOUR:TEL:MOD:VIS:RES?"",
        ""SOUR:TEL:MOD:VIS:RES %g"",
        """""" A float property that controls the value of the residual carrier

        valid range: 0 .. 0.3 (30%)
        """""",
        validator=strict_range,
        values=[0, 0.3],
    )

    vision_videosignal_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:VID?"",
        ""SOUR:TEL:MOD:VIS:VID %s"",
        """""" A bool property that controls if the video signal is switched on or off

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    vision_sideband_filter_enabled = Instrument.control(
        ""SOUR:TEL:MOD:VIS:VSBF?"",
        ""SOUR:TEL:MOD:VIS:VSBF %s"",
        """""" A bool property that controls the use of the VSBF (vestigal sideband filter)
        in the vision modulator
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    lower_sideband_enabled = Instrument.control(
        ""SOUR:TEL:SID?"",
        ""SOUR:TEL:SID %s"",
        """""" A bool property that controls the use of the lower sideband

        refer also to chapter 3.6.6.10 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: ""UPP"", True: ""LOW""},
        map_values=True,
    )

    sound_mode = Instrument.control(
        ""SOUR:TEL:SOUN?"",
        ""SOUR:TEL:SOUN %s"",
        """""" A string property that controls the type of audio signal

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        MONO    MOnoaural sound
        PIL     pilot-carrier + mono
        BTSC    BTSC + mono
        STER    Stereo sound
        DUAL    Dual channel sound
        NIC     NICAM + Mono
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""MONO"", ""PIL"", ""BTSC"", ""STER"", ""DUAL"", ""NIC""],
    )

    TV_standard = Instrument.control(
        ""SOUR:TEL:STAN?"",
        ""SOUR:TEL:STAN %s"",
        """""" A string property that controls the type of video standard

        Possible values are:

        ======  ======  ======
        Value   Lines   System
        ======  ======  ======
        BG      625     PAL
        DK      625     SECAM
        I       625     PAL
        K1      625     SECAM
        L       625     SECAM
        M       525     NTSC
        N       625     NTSC
        ======  ======  ======

        Please confirm with the manual about the details for these settings.
        """""",
        validator=strict_discrete_set,
        values=[""BG"", ""DK"", ""I"", ""K1"", ""L"", ""M"", ""N""],
    )

    TV_country = Instrument.control(
        ""SOUR:TEL:STAN:COUN?"",
        ""SOUR:TEL:STAN:COUN %s"",
        """""" A string property that controls the country specifics of the
        video/sound system to be used

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        BG_G    BG General
        DK_G    DK General
        I_G     I General
        L_G     L General
        GERM    Germany
        BELG    Belgium
        NETH    Netherlands
        FIN     Finland
        AUST    Australia
        BG_T    BG Th
        DENM    Denmark
        NORW    Norway
        SWED    Sweden
        GUS     Russia
        POL1    Poland
        POL2    Poland
        HUNG    Hungary
        CHEC    Czech Republic
        CHINA1  China
        CHINA2  China
        GRE     Great Britain
        SAFR    South Africa
        FRAN    France
        USA     United States
        KOR     Korea
        JAP     Japan
        CAN     Canada
        SAM     South America
        ======  =======

        Please confirm with the manual about the details for these settings.
        """""",
        validator=strict_discrete_set,
        values=[""BG_G"", ""DK_G"", ""I_G"", ""L_G"", ""GERM"", ""BELG"", ""NETH"",
                ""FIN"", ""AUST"", ""BG_T"", ""DENM"", ""NORW"", ""SWED"", ""GUS"", ""POL1"", ""POL2"",
                ""HUNG"", ""CHEC"", ""CHINA1"", ""CHINA2"", ""GRE"", ""SAFR"", ""FRAN"", ""USA"",
                ""KOR"", ""JAP"", ""CAN"", ""SAM""],
    )

    output_voltage = Instrument.control(
        ""SOUR:VOLT:LEV?"",
        ""SOUR:VOLT:LEV %g"",
        """"""A float property controlling the output level in Volt,

        Minimum 2.50891e-6, Maximum 0.707068 (depending on output mode)
        refer also to chapter 3.6.6.12 of the manual
        """""",
        validator=strict_range,
        values=[2.508910e-6, 0.7070168],
    )

    event_reg = Instrument.measurement(
        ""STAT:OPER:EVEN?"",
        """"""
        Content of the event register of the Status Operation Register
        refer also to chapter 3.6.7 of the manual
        """""",
        cast=int,
    )

    status_reg = Instrument.measurement(
        ""STAT:OPER:COND?"",
        """"""
        Content of the condition register of the Status Operation Register
        """""",
        cast=int,
    )

    operation_enable_reg = Instrument.control(
        ""STAT:OPER:ENAB?"",
        ""STAT:OPER:ENAB %d"",
        """"""
        Content of the enable register of the Status Operation Register

        Valid range: 0...32767
        """""",
        cast=int,
        validator=strict_range,
        values=[0, 32767]
    )

    def status_preset(self):
        """""" partly resets the SCPI status reporting structures
        """"""
        self.write(""STAT:PRES"")

    questionable_event_reg = Instrument.measurement(
        ""STAT:QUES:EVEN?"",
        """"""
        Content of the event register of the Status Questionable Operation Register
        """""",
        cast=int,
    )

    questionanble_status_reg = Instrument.measurement(
        ""STAT:QUES:COND?"",
        """"""
        Content of the condition register of the Status Questionable Operation Register
        """""",
        cast=int,
    )

    questionable_operation_enable_reg = Instrument.control(
        ""STAT:QUES:ENAB?"",
        ""STAT:QUES:ENAB %d"",
        """"""
        Content of the enable register of the Status Questionable Operation Register

        Valid range 0...32767
        """""",
        cast=int,
        validator=strict_range,
        values=[0, 32767]
    )

    beeper_enabled = Instrument.control(
        ""SYST:BEEP:STATE?"",
        ""SYST:BEEP:STATE %s"",
        """""" A bool property that controls the beeper status,

        refer also to chapter 3.6.8 of the manual
        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    status_info_shown = Instrument.control(
        ""SYST:DISP:UPDATE:STATE?"",
        ""SYST:DISP:UPDATE:STATE %s"",
        """""" A bool property that controls if the display shows infomation during remote control

        """""",
        validator=strict_discrete_set,
        values={False: 0, True: 1},
        map_values=True,
    )

    gpib_address = Instrument.control(
        ""SYST:COMM:GPIB:ADDR?"",
        ""SYST:COMM:GPIB:ADDR %d"",
        """""" A int property that controls the GPIB address of the unit

        valid range:  0..30
        """""",
        validator=strict_range,
        values=[0, 30],
    )

    remote_interfaces = Instrument.control(
        ""SYST:COM:REM?"",
        ""SYST:COM:REM %s"",
        """"""A string property controlling the selection of interfaces for remote control

        Possible selections are:

        ======  =======
        Value   Meaning
        ======  =======
        OFF     no remote control
        GPIB    GPIB only enabled
        SER     RS232 only enabled
        BOTH    GPIB & RS232 enabled
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""OFF"", ""GPIB"", ""SER"", ""BOTH""]
    )

    serial_baud = Instrument.control(
        ""SYST:COMM:SER:BAUD?"",
        ""SYST:COMM:SER:BAUD %g"",
        """""" A int property that controls the serial communication speed ,

        Possible values are: 110,300,600,1200,4800,9600,19200
        """""",
        validator=strict_discrete_set,
        values=[110, 300, 600, 1200, 4800, 9600, 19200],
    )

    serial_bits = Instrument.control(
        ""SYST:COMM:SER:BITS?"",
        ""SYST:COMM:SER:BITS %g"",
        """""" A int property that controls the number of bits used in serial communication

        Possible values are: 7 or 8
        """""",
        validator=strict_discrete_set,
        values=[7, 8],
    )

    serial_flowcontrol = Instrument.control(
        ""SYST:COMM:SER:PACE?"",
        ""SYST:COMM:SER:PACE %s"",
        """""" A string property that controls the serial handshake type used in serial communication

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        NONE    no flow-control/handshake
        XON     XON/XOFF flow-control
        ACK     hardware handshake with RTS&CTS
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""NONE"", ""XON"", ""ACK""],
    )

    serial_parity = Instrument.control(
        ""SYST:COMM:SER:PAR?"",
        ""SYST:COMM:SER:PAR %s"",
        """""" A string property that controls the parity type used for serial communication

        Possible values are:

        ======  =======
        Value   Meaning
        ======  =======
        NONE    no parity
        EVEN    even parity
        ODD     odd parity
        ONE     parity bit fixed to 1
        ZERO    parity bit fixed to 0
        ======  =======

        """""",
        validator=strict_discrete_set,
        values=[""NONE"", ""EVEN"", ""ODD"", ""ONE"", ""ZERO""],
    )

    serial_stopbits = Instrument.control(
        ""SYST:COMM:SER:SBIT?"",
        ""SYST:COMM:SER:SBIT %g"",
        """""" A int property that controls the number of stop-bits used in serial communication,

        Possible values are: 1 or 2
        """""",
        validator=strict_discrete_set,
        values=[1, 2],
    )

    date = Instrument.measurement(
        ""SYST:DATE?"",
        """"""
        A list property for the date of the RTC in the unit
        """""",
    )

    time = Instrument.measurement(
        ""SYST:TIME?"",
        """"""
        A list property for the time of the RTC in the unit
        """""",
    )

    basic_info = Instrument.measurement(
        ""SYST:INF:BAS?"",
        """"""
        A String property containing infomation about the hardware modules installed in the unit
        """""",
    )

    subsystem_info = Instrument.measurement(
        ""SYST:INF:SUBS?"",
        """"""
        A String property containing infomation about the system configuration
        """""",
    )

    scale_volt = Instrument.control(
        ""UNIT:VOLT?"",
        ""UNIT:VOLT %s"",
        """""" A string property that controls the unit to be used for voltage entries on the unit

        Possible values are:
        AV,FV, PV, NV, UV, MV, V, KV, MAV, GV, TV, PEV, EV,
        DBAV, DBFV, DBPV, DBNV, DBUV, DBMV, DBV, DBKV, DBMAv, DBGV, DBTV, DBPEv, DBEV

        refer also to chapter 3.6.9 of the manual
        """""",
        validator=strict_discrete_set,
        values=[""AV"", ""FV"", ""PV"", ""NV"", ""UV"", ""MV"", ""V"", ""KV"", ""MAV"", ""GV"",
                ""TV"", ""PEV"", ""EV"", ""DBAV"", ""DBFV"", ""DBPV"", ""DBNV"", ""DBUV"",
                ""DBMV"", ""DBV"", ""DBKV"", ""DBMAv"", ""DBGV"", ""DBTV"", ""DBPEv"", ""DBEV""],
    )
"
141,5420.0,USA,"The HP 3478A 5.5 digit DMM with HP-IB interface
",HP 3478 A,186.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a Keysight 3478A Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Keysight 3478A,https://www.keysight.com/us/en/assets/9018-05398/user-manuals/9018-05398.pdf,"[OrderedDict([('id', 'attFQwLe4SfLaRgSf'), ('width', 1204), ('height', 656), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/3Gq8gP1DOJJjFjEaOnZtYA/3aoPs0CYm71nBTGNWCwqut6yvUT0MnA0dF9gqcCz5RelbT28gW6tZETfahY41Jy6ULPCbYw4zJ4vd7SIJxRu2euvkTCb2OSAia1kgQsxF5k/qCJ2NhBDl_tR8xDzoUZ9eSiQmIBcidkM89jRtW293EI'), ('filename', 'img3050.jpg'), ('size', 114606), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0EnL5ClkwTSVYd1klt_Reg/n1eU0TKmHorYHwOqu7_7VWYZkkS-3u4RDy7NLNT0BfboOw94Yqb1xbqZmN19FGBmJKTF8f_Fie6nV-EERuUhNg/_8CtsMePUs1Mlwv9YZ5s_zBYYx4ZbgQw-5tw5rkHstI'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/W7rUXmqfaAogqPxdm4Gs1A/hp6nv_9YQZ6woaCJQqiburQoL5VbT3jc2olNbWVY5F0OFcgzFK8uneQj5nc-kvh2a6xR_ZOMowj1YXTNBl1zeA/Yp19viSgH366uQYsdYu9ACoziPo6Jh-GC4E_uWM-1hc'), ('width', 940), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fER6Mt2yKC_FX_h1EIvAsg/NSyug1_nG6tm3K8Tcup2KGMlKCuWzyACmVagwOq7BUqdXEGOM0eFYeAoq2Dw_acJ_dYq9NGpluohe78xUCRMaQ/rRNztsvBfeAEw1VYHwBum221ZyH8iuu-K9Y00m1TixY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/3478A/55-digit-dmm-with-hpib-interface.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp3478A.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp3478A.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import ctypes
import logging
import math
from enum import IntFlag
from pymeasure.instruments.hp.hplegacyinstrument import HPLegacyInstrument, StatusBitsBase
from pymeasure.instruments.validators import strict_discrete_set, strict_range


log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

c_uint8 = ctypes.c_uint8


class SRQ(ctypes.BigEndianStructure):
    """"""Support class for the SRQ handling
    """"""
    _fields_ = [
        (""power_on"", c_uint8, 1),
        (""not_assigned_1"", c_uint8, 1),
        (""calibration"", c_uint8, 1),
        (""front_panel_button"", c_uint8, 1),
        (""internal_error"", c_uint8, 1),
        (""syntax_error"", c_uint8, 1),
        (""not_assigned_2"", c_uint8, 1),
        (""data_ready"", c_uint8, 1),
    ]

    def __str__(self):
        """"""
        Returns a pretty formatted string showing the status of the instrument

        """"""
        ret_str = """"
        for field in self._fields_:
            ret_str = ret_str + f""{field[0]}: {hex(getattr(self, field[0]))}\n""

        return ret_str


class Status(StatusBitsBase):
    """"""
    Support-Class with the bit assignments for the 5 status byte of the HP3478A
    """"""

    _fields_ = [
        # Byte 1: Function, Range and Number of Digits
        (""function"", c_uint8, 3),  # bit 5..7
        (""range"", c_uint8, 3),  # bit 2..4
        (""digits"", c_uint8, 2),  # bit 0..1
        # Byte 2: Status Bits
        (""res1"", c_uint8, 1),
        (""ext_trig"", c_uint8, 1),
        (""cal_enable"", c_uint8, 1),
        (""front_rear"", c_uint8, 1),
        (""fifty_hz"", c_uint8, 1),
        (""auto_zero"", c_uint8, 1),
        (""auto_range"", c_uint8, 1),
        (""int_trig"", c_uint8, 1),
        # Byte 3: Serial Poll Mask (SRQ)
        # (""SRQ_PON"", c_uint8, 1),
        # (""res3"", c_uint8, 1),
        # (""SRQ_cal_error"", c_uint8, 1),
        # (""SRQ_front_panel"", c_uint8, 1),
        # (""SRQ_internal_error"", c_uint8, 1),
        # (""SRQ_syntax_error"", c_uint8, 1),
        # (""res2"", c_uint8, 1),
        # (""SRQ_data_rdy"", c_uint8, 1),
        (""SRQ"", SRQ),
        # Byte 4: Error Information
        # (""res5"", c_uint8, 1),
        # (""res4"", c_uint8, 1),
        # (""ERR_AD_Link"", c_uint8, 1),
        # (""ERR_AD"", c_uint8, 1),
        # (""ERR_slope"", c_uint8, 1),
        # (""ERR_ROM"", c_uint8, 1),
        # (""ERR_RAM"", c_uint8, 1),
        # (""ERR_cal"", c_uint8, 1),
        (""Error_Status"", c_uint8, 8),
        # Byte 5: DAC Value
        (""DAC_value"", c_uint8, 8),
    ]


class HP3478A(HPLegacyInstrument):
    """""" Represents the Hewlett Packard 3478A 5 1/2 digit multimeter
    and provides a high-level interface for interacting
    with the instrument.
    """"""
    status_desc = Status

    def __init__(self, adapter, name=""Hewlett-Packard HP3478A"", **kwargs):
        kwargs.setdefault('read_termination', '\r\n')
        kwargs.setdefault('send_end', True)
        super().__init__(
            adapter,
            name,
            **kwargs,
        )

    # Definitions for different specifics of this instrument
    MODES = {""DCV"": ""F1"",
             ""ACV"": ""F2"",
             ""R2W"": ""F3"",
             ""R4W"": ""F4"",
             ""DCI"": ""F5"",
             ""ACI"": ""F6"",
             ""Rext"": ""F7"",
             }

    INV_MODES = {v: k for k, v in MODES.items()}

    RANGES = {""DCV"": {3E-2: ""R-2"", 3E-1: ""R-1"", 3: ""R0"", 30: ""R1"", 300: ""R2"",
                      ""auto"": ""RA""},
              ""ACV"": {3E-1: ""R-1"", 3: ""R0"", 30: ""R1"", 300: ""R2"", ""auto"": ""RA""},
              ""R2W"": {30: ""R1"", 300: ""R2"", 3E3: ""R3"", 3E4: ""R4"", 3E5: ""R5"",
                      3E6: ""R6"", 3E7: ""R7"", ""auto"": ""RA""},
              ""R4W"": {30: ""R1"", 300: ""R2"", 3E3: ""R3"", 3E4: ""R4"", 3E5: ""R5"",
                      3E6: ""R6"", 3E7: ""R7"", ""auto"": ""RA""},
              ""DCI"": {3E-1: ""R-1"", 3: ""R0"", ""auto"": ""RA""},
              ""ACI"": {3E-1: ""R-1"", 3: ""R0"", ""auto"": ""RA""},
              ""Rext"": {3E7: ""R7"", ""auto"": ""RA""},
              }

    TRIGGERS = {
        ""auto"": ""T1"",
        ""internal"": ""T1"",
        ""external"": ""T2"",
        ""single"": ""T3"",
        ""hold"": ""T4"",
        ""fast"": ""T5"",
    }

    class ERRORS(IntFlag):
        """"""Enum element for errror bit decoding
        """"""
        AD_LINK = 32  # AD link error
        AD_SELFCHK = 16  # AD self check error
        AD_SLOPE = 8  # AD slope error
        ROM = 4  # Control ROM error
        RAM = 2  # RAM selftest failed
        CALIBRATION = 1  # Calibration checksum error or cal range issue
        NO_ERR = 0  # Should be obvious

    # commands/properties for instrument control
    @property
    def active_connectors(self):
        """"""Return selected connectors (""front""/""back""), based on front-panel selector switch
        """"""
        selection = self.status.front_rear
        if selection == 1:
            return ""front""
        else:
            return ""back""

    @property
    def auto_range_enabled(self):
        """""" Property describing the auto-ranging status

        ======  ============================================
        Value   Status
        ======  ============================================
        True    auto-range function activated
        False   manual range selection / auto-range disabled
        ======  ============================================

        The range can be set with the :py:attr:`range` property
        """"""
        selection = self.status.auto_range
        return bool(selection)

    @property
    def auto_zero_enabled(self):
        """""" Return auto-zero status, this property can be set

        ======  ==================
        Value   Status
        ======  ==================
        True    auto-zero active
        False   auto-zero disabled
        ======  ==================

        """"""
        selection = self.status.auto_zero
        return bool(selection)

    @auto_zero_enabled.setter
    def auto_zero_enabled(self, value):
        az_set = int(value)
        az_str = ""Z"" + str(int(strict_discrete_set(az_set, [0, 1])))
        self.write(az_str)

    @property
    def calibration_enabled(self):
        """"""Return calibration enable switch setting,
        based on front-panel selector switch

        ======  ===================
        Value   Status
        ======  ===================
        True    calbration possible
        False   calibration locked
        ======  ===================

        """"""
        selection = self.status.cal_enable
        return bool(selection)

    def check_errors(self):
        """"""
        Method to read the error status register

        :return error_status: one byte with the error status register content
        :rtype error_status: int
        """"""
        # Read the error status register only one time for this method, as
        # the manual states that reading the error status register also clears it.
        current_errors = self.error_status
        if current_errors != 0:
            log.error(""HP3478A error detected: %s"", self.ERRORS(current_errors))
        return self.ERRORS(current_errors)

    error_status = HPLegacyInstrument.measurement(
        ""E"",
        """"""Checks the error status register

        """""",
        cast=int,
    )

    def display_reset(self):
        """""" Reset the display of the instrument.

        """"""
        self.write(""D1"")

    display_text = HPLegacyInstrument.setting(
        ""D2%s"",
        """"""Displays up to 12 upper-case ASCII characters on the display.

        """""",
        set_process=(lambda x: str.upper(x[0:12])),
    )

    display_text_no_symbol = HPLegacyInstrument.setting(
        ""D3%s"",
        """"""Displays up to 12 upper-case ASCII characters on the display and
        disables all symbols on the display.

        """""",
        set_process=(lambda x: str.upper(x[0:12])),
    )

    measure_ACI = HPLegacyInstrument.measurement(
        MODES[""ACI""],
        """"""
        Returns the measured value for AC current as a float in A.

        """""",
    )

    measure_ACV = HPLegacyInstrument.measurement(
        MODES[""ACV""],
        """"""
        Returns the measured value for AC Voltage as a float in V.

        """""",
    )

    measure_DCI = HPLegacyInstrument.measurement(
        MODES[""DCI""],
        """"""
        Returns the measured value for DC current as a float in A.

        """""",
    )

    measure_DCV = HPLegacyInstrument.measurement(
        MODES[""DCV""],
        """"""
        Returns the measured value for DC Voltage as a float in V.

        """""",
    )

    measure_R2W = HPLegacyInstrument.measurement(
        MODES[""R2W""],
        """"""
        Returns the measured value for 2-wire resistance as a float in Ohm.

        """""",
    )

    measure_R4W = HPLegacyInstrument.measurement(
        MODES[""R4W""],
        """"""
        Returns the measured value for 4-wire resistance as a float in Ohm.

        """""",
    )

    measure_Rext = HPLegacyInstrument.measurement(
        MODES[""Rext""],
        """"""
        Returns the measured value for extended resistance mode (>30M, 2-wire)
        resistance as a float in Ohm.
        """""",
    )

    @property
    def mode(self):
        """"""Return current selected measurement mode, this propery can be set.
        Allowed values are

        ====  ==============================================================
        Mode  Function
        ====  ==============================================================
        ACI   AC current
        ACV   AC voltage
        DCI   DC current
        DCV   DC voltage
        R2W   2-wire resistance
        R4W   4-wire resistance
        Rext  extended resistance method (requires additional 10 M resistor)
        ====  ==============================================================
        """"""
        current_mode = self.INV_MODES[""F"" + str(self.status.function)]
        return current_mode

    @mode.setter
    def mode(self, value):
        mode_set = self.MODES[strict_discrete_set(value, self.MODES)]
        self.write(mode_set)

    @property
    def range(self):
        """"""Returns the current measurement range, this property can be set.

        Valid values are :

        ====  =======================================
        Mode  Range
        ====  =======================================
        ACI   0.3, 3, auto
        ACV   0.3, 3, 30, 300, auto
        DCI   0.3, 3, auto
        DCV   0.03, 0.3, 3, 30, 300, auto
        R2W   30, 300, 3000, 3E4, 3E5, 3E6, 3E7, auto
        R4W   30, 300, 3000, 3E4, 3E5, 3E6, 3E7, auto
        Rext  3E7, auto
        ====  =======================================

        """"""
        cur_mode = self.INV_MODES[""F"" + str(self.status.function)]
        if cur_mode == ""DCV"":
            correction_factor = 3
        elif cur_mode in [""ACV"", ""ACI"", ""DCI""]:
            correction_factor = 2
        else:
            correction_factor = 0
        current_range = 3 * math.pow(10, self.status.range - correction_factor)
        return current_range

    @range.setter
    def range(self, value):
        cur_mode = self.mode
        value = strict_discrete_set(value, self.RANGES[cur_mode])
        set_range = self.RANGES[cur_mode][value]
        self.write(set_range)

    @property
    def resolution(self):
        """"""Returns current selected resolution, this property can be set.

        Possible values are 3,4 or 5 (for 3 1/2, 4 1/2 or 5 1/2 digits of resolution)
        """"""
        number_of_digit = 6 - self.status.digits
        return number_of_digit

    @resolution.setter
    def resolution(self, value):
        resolution_string = ""N"" + str(strict_discrete_set(value, [3, 4, 5]))
        self.write(resolution_string)

    @property
    def SRQ_mask(self):
        """"""Return current SRQ mask, this property can be set,

        bit assigment for SRQ:

        =========  ==========================
        Bit (dec)  Description
        =========  ==========================
         1         SRQ when Data ready
         4         SRQ when Syntax error
         8         SRQ when internal error
        16         front panel SQR button
        32         SRQ by invalid calibration
        =========  ==========================

        """"""

        return self.status.SRQ

    @SRQ_mask.setter
    def SRQ_mask(self, value):
        self.write(f""M{strict_range(value, [0, 63]):02o}"")

    @property
    def trigger(self):
        """"""Return current selected trigger mode, this property can be set

        Possibe values are:

        ========  ===========================================
        Value     Meaning
        ========  ===========================================
        auto      automatic trigger (internal)
        internal  automatic trigger (internal)
        external  external trigger (connector on back or GET)
        hold      holds the measurement
        fast      fast trigger for AC measurements
        ========  ===========================================

        """"""
        status = self.status
        i_trig = status.int_trig
        e_trig = status.ext_trig
        if i_trig == 0:
            if e_trig == 0:
                trigger_mode = ""hold""
            else:
                trigger_mode = ""external""
        else:
            trigger_mode = ""internal""
        return trigger_mode

    @trigger.setter
    def trigger(self, value):
        trig_set = self.TRIGGERS[strict_discrete_set(value, self.TRIGGERS)]
        self.write(trig_set)

    @property
    def calibration_data(self):
        """"""Read or write the calibration data as an array of 256 values between 0 and 15.

        The calibration data of an HP 3478A is stored in a 256x4 SRAM that is
        permanently powered by a 3v Lithium battery. When the battery runs
        out, the calibration data is lost, and recalibration is required.

        When read, this property fetches and returns the calibration data so that it can be
        backed up.

        When assigned a value, it similarly expects an array of 256 values between 0 and 15,
        and writes the values back to the instrument.

        When writing, exceptions are raised for the following conditions:

        * The CAL ENABLE switch at the front of the instrument is not set to ON.
        * The array with values does not contain exactly 256 elements.
        * The array with values does not pass a verification check.

        IMPORTANT: changing the calibration data results in permanent loss of
        the previous data. Use with care!

        """"""
        cal_data = []
        for addr in range(0, 256):
            # To fetch one nibble: 'W<address>', where address is a raw 8-bit number.
            cmd = bytes([ord('W'), addr])
            self.write_bytes(cmd)
            rvalue = self.read_bytes(1)[0]
            # 'W' command reads a nibble from the SRAM, but then adds a value of 64 to return
            # it as an ASCII value.
            if rvalue < 64 or rvalue >= 80:
                raise Exception(""calibration nibble out of range"")
            cal_data.append(rvalue-64)

        return cal_data

    @calibration_data.setter
    def calibration_data(self, cal_data):
        """"""Setter to write the calibration data.

        """"""

        if not self.calibration_enabled:
            raise Exception(""CAL ENABLE switch not set to ON"")

        self.write_calibration_data(cal_data, True)

    def write_calibration_data(self, cal_data, verify_calibration_data=True):
        """"""Method to write calibration data.

        The cal_data parameter format is the same as the ``calibration_data`` property.

        Verification of the cal_data array can be bypassed by setting
        ``verify_calibration_data`` to ``False``.

        """"""
        if verify_calibration_data and not self.verify_calibration_data(cal_data):
            raise ValueError(""cal_data verification fail."")

        for addr in range(0, 256):
            # To write one nibble: 'X<address><byte>', where address and byte are raw 8-bit numbers.
            cmd = bytes([ord('X'), addr, cal_data[addr]])
            self.write_bytes(cmd)
        pass

    def verify_calibration_entry(self, cal_data, entry_nr):
        """"""Verify the checksum of one calibration entry.

        Expects an array of 256 values with calibration data, and an entry
        number from 0 to 18.

        Returns True when the checksum of the specified calibration entry
        is correct.

        """"""
        if len(cal_data) != 256:
            raise Exception(""cal_data must contain 256 values"")

        sum = 0
        for idx in range(0, 13):
            val = cal_data[entry_nr*13 + idx + 1]
            if idx != 11:
                sum += val
            else:
                sum += val*16
        return sum == 255

    def verify_calibration_data(self, cal_data):
        """"""Verify the checksums of all calibration entries.

        Expects an array of 256 values with calibration data.

        :return calibration_correct: True when all checksums are correct.
        :rtype calibration_correct: boolean

        """"""
        for entry_nr in range(0, 19):
            if entry_nr in [5, 16, 18]:
                continue
            if not self.verify_calibration_entry(cal_data, entry_nr):
                return False
        return True
"
142,110.6,"Cleveland, Ohio, United States","The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",Keithley 2450,262.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zcMA96mtJXYCOkb6kupHvQ/1ps5TsoRXCKsgqMySssYHoFSmhIRx4aO-XnriClXx2hps3be9sz0iHDjxaiFc2bdN99oaalDnhvz83JRJ2LXAg/J1L5e2oVFP6WmjIXtPMyOo7kKZDtigkNccvN0QWJA34'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ESnqh5TwnjrQtEeabYPoKQ/gk-ujrmURPBE0ke1R-mZFeYnploc5mrcLGXwHxpcXfGfOItUvhXTJ1KRqyYJLMLNoSMzDToglmnmEQjpZsdwTg/qTqGV6hlOyYZ6j4G7XL77nIdu-oeP4zuKe9dbycKwEs'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Y0IFHnD1gpxXWlPcN-aBbQ/RlwATNebPwv7UNuAkR02xj2TEzcSh2Ye-f3e9d3lzb121zFJXuYOGNpgR-1F3aCyWbF7GgrgiOPmwozG206Egg/EBNyEc-Z__pKX6YJcEGkA5oqXfg9V0_TPk-5cMCIkb4'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V2pJhiB2HJsrbTpZR7Dp7A/T_kRNu7Kg6c6wkrPBNFQGCjoxUfansX8IVfb2CJkIAHvd4S9I2WVDht-qUlbycmblE2XD4ztWCmchWmJeTZ5QQ/Kx6THN0HbSzRC4X-fUuyOxlQhk-jZ_QK51SSOiIvs40'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2450.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2450.html,9549.3,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set
from .buffer import KeithleyBuffer

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2450(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2450 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2450(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2450.apply_current` and :meth:`~.Keithley2450.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    compliance_current = Instrument.control(
        "":SOUR:VOLT:ILIM?"", "":SOUR:VOLT:ILIM %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """"""
    )

    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current_delay = Instrument.control(
        "":SOUR:CURR:DEL?"", "":SOUR:CURR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_current_delay_auto = Instrument.control(
        "":SOUR:CURR:DEL:AUTO?"", "":SOUR:CURR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    compliance_voltage = Instrument.control(
        "":SOUR:CURR:VLIM?"", "":SOUR:CURR:VLIM %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage_delay = Instrument.control(
        "":SOUR:VOLT:DEL?"", "":SOUR:VOLT:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_voltage_delay_auto = Instrument.control(
        "":SOUR:VOLT:DEL:AUTO?"", "":SOUR:VOLT:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )

    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    wires = Instrument.control(
        "":SENS:RES:RSENSE?"", "":SENS:RES:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    means = Instrument.measurement(
        "":TRACe:STATistics:AVERage?"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )

    maximums = Instrument.measurement(
        "":TRACe:STATistics:MAXimum?"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    minimums = Instrument.measurement(
        "":TRACe:STATistics:MINimum?"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    standard_devs = Instrument.measurement(
        "":TRACe:STATistics:STDDev?"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Filters #
    ###########

    current_filter_type = Instrument.control(
        "":SENS:CURR:AVER:TCON?"", "":SENS:CURR:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    current_filter_count = Instrument.control(
        "":SENS:CURR:AVER:COUNT?"", "":SENS:CURR:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    current_filter_state = Instrument.control(
        "":SENS:CURR:AVER?"", "":SENS:CURR:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    voltage_filter_type = Instrument.control(
        "":SENS:VOLT:AVER:TCON?"", "":SENS:VOLT:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    voltage_filter_count = Instrument.control(
        "":SENS:VOLT:AVER:COUNT?"", "":SENS:VOLT:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    #####################
    # Output subsystem #
    #####################

    current_output_off_state = Instrument.control(
        "":OUTP:CURR:SMOD?"", "":OUTP:CURR:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    voltage_output_off_state = Instrument.control(
        "":OUTP:VOLT:SMOD?"", "":OUTP:VOLT:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2450 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2450.current_range` value or None
        """"""
        log.info(""%s is sourcing current."", self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2450.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2450 reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2450 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger.
        """"""
        return self.write(""*TRG"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
173,57.0,"Shenzhen, China","Siglent’s SPD1305X Series Programmable Linear DC Power Supply has a 2.8 inch TFT-LCD (240 * 320) color display. The SPD1305X outputs up to 150 Watts of power and has a Voltage range of 0-30 V and Current range of 0-5 A. The Voltage resolution is 1 uV while the Current resolution is 1 mA.

Because higher currents supplied through smaller gauge wire or longer distances can cause a drop in voltage to the supplied load, the SPD1305X incorporates Remote Sensing in order to measure the actual supplied voltage at the load. The remote sensed voltage is fed back to the power supply and output voltage is adjusted almost instantaneously.",Siglent SPD 1305 X,500.0,"**iglent** is a China-based manufacturer specializing in electronic test & measurement instruments. Siglent founders began a preliminary study of digital oscilloscopes in 2002. It founded in 2007, and now Siglent has extended its product line to include digital oscilloscopes, function / arbitrary waveform generators, RF generators，digital multi-meters, DC power supplies, spectrum analyzers, spectrum & vector network analyzers, isolated handheld oscilloscopes, DC electronic loads and other general test instruments.Siglent also manufactured entry-level products for Lecroy.
",Pymeasure,Siglent Technologies,"[OrderedDict([('id', 'attzuZfmx06hyyd2m'), ('width', 500), ('height', 304), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6rfr-yNAPASVtUBWM90kTQ/NZEbagRadUjDIXKkFPP6J0eUX3aZWS3mG4UG_fCIHrmB18GydvusPRiPLPxsCbc1tMXe_gB4ivrpEL-6nyN65ZnVGKZbuhhRSEqJAdsyCck/e-TgR98p0y_1AdLljtY2nYSH3ctZ3okQJKO6uVjeaW8'), ('filename', 'New-Siglent-Logo.png'), ('size', 3479), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MWGbuhdnHluts1tr83KI2w/a7sRXTtX_SYigN6qqluRky0JPXzkxIvO8YPTbG9TJaOzsGq7HsSyTPc4V6nq03uYC7dg6gzd6QLj1jgt77Hbiw/O1aftFG75gQzakU4-TPAsSGuDi_xFnItguj2F_MkzQA'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r9C8oauPliGmoHScjFJXDA/wwJfM99TFDZmxySU-KxnRy9kFsRPkuWsAfTAqBkbPt6Zgt7FZzic8X60Yk9_D9qR92SC6-8evU8yYLMoPw43qA/ddzibM1DYi_YhddyclXr2si35RYFwOqWcGCbEc2fhS4'), ('width', 500), ('height', 304)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YALrWvjtXtlLW6y-xgPsmg/--hyRe3jfSaj_tPBt2HugZGe0J-n3npGfyE4v2FS50nuF51lPCaRnzBT5ogr5FD1yAorYiRHmUFbHQvrUk_kkw/OBqrPoila1EFvLVk-xbCpZryV0PQudHTHxIpXApS17o'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/,Write a Python script that uses Pymeasure to connect to a SPD1305X Power Supply Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",SPD1305X Power Supply,https://www.electrokit.com/uploads/productfile/41016/SPD1168X_DataSheet_DS0501X-E01A.pdf,"[OrderedDict([('id', 'attsg6pyZAwOVcumH'), ('width', 799), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ps_yCDbBFCAfa5_nOOmP3Q/m4GdkTh2P9fvFtnROxKsKHP5Q3UufgOM85z5mERo_7_Gw9ZpfmX9mnmEICxYR78ts3rmmPuF3cMa1ZUhpmiqqK-Jg-Dj_h016wvwYNaLqtahF4rj_uYqWPfsOxt9biZR/A17s4c2MX85shYZm3OYb3YjaGZt7NOiSyephHS146a0'), ('filename', '71+Pg3OmZeL._AC_UF894,1000_QL80_.jpg'), ('size', 88161), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CDYaqSVP9V0QFdRQCilQDA/tHuGbQWvzerqzLA62GgoxA2_v8I5DetfeE3u7CUTCxZvQ20FvuP8acPaT-DVbBYL_1FulCuQ7QdWTB5M0FbVQQ/vlnYN34GxY8NzRV_C8CUKZQ_tXFn5YE4bLIMK1DAX54'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Q1206-AS_hSZ-RoiU2pJfw/eRkARpwBhdYNLtZSjYicBhqIEDBSkpNokaMF0vvlS4dLbmkolwNhuXFZkX3Eqk6-G-4Cf2nYTTkV2F2YYPkPFQ/xn4q0qlPUUGHp9zj6l7ucuRKgQL7adIXtcTMJovlS7M'), ('width', 512), ('height', 641)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/emyND_pav-6Zgd5IBhqNgw/W4gObHSekU1A4PQZFyZ6HKUaaQEt5E4iBDWazV36P2JDPvHRmoUamXzIy__AmqJSks8PeMbkb2cSbayGQoIU2g/0z1uI69UYg5Oq4C4HQUy3hs8ioKL1fetOOV7sXkbHCU'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/product/spd1305x/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/siglenttechnologies/siglent_spd1305x.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/siglenttechnologies/siglent_spd1305x.html,285.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.siglenttechnologies.siglent_spdbase import (SPDSingleChannelBase,
                                                                       SPDChannel)


class SPD1305X(SPDSingleChannelBase):
    """"""Represent the Siglent SPD1305X Power Supply.
    """"""

    voltage_range = [0, 30]
    current_range = [0, 5]
    ch_1 = Instrument.ChannelCreator(SPDChannel, 1,
                                     voltage_range=voltage_range,
                                     current_range=current_range)

    def __init__(self, adapter, name=""Siglent Technologies SPD1305X Power Supply"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

        self.ch_1.voltage_setpoint_values = self.voltage_range
        self.ch_1.current_limit_values = self.current_range
"
175,670.0,JAPAN,"The MS9740A supports nine application measurement modes (DFBLD, FP-LD, LED, PMD, Opt. Amp, Opt. Amp (Multi-channel), WDM, LD Module, WDM Filter) for measurement targets","Anritsums MS9749A

",83.0,"**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",Pymeasure,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZmPX4SuNFgpMC_FPYiQp0A/6rWlWETVEOsIG9eJaj7_HTtV4hpuaE5l5bXyhr6NHnX0i81eC-0UIcs_cuAtlRHC1ckl4WcdZseU6UfHX9LgizKTfFhnlmi_mOI2QTBczaA/ACB8i35qnE5qyKeqpZvOW-6SzP-h9ly7vNUgqSnOkwI'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XqeyQwMMQY-YTrsX1BfYAw/-uFNzgN2_iTHUL0tDM3qm9KiEA5U7ZSYUpkonisEjFCewWcVcEa6QdxmNtrkvxTOe0mtTzUqbG0uJPypTwBOIw/jP4kJ0e_UWOU-Sh5XsFbSnOL5xYdeXxYG75IaJDFXgw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zEGLkzKKiX4QgM-iJ5cwWw/OyOUjkwIahhWOEYJj_RB4VnN-8glL3UpVHI97X01JmUf_h3pkWFb0lvq6FmQwNjqpR38W0WmFYhVYbyvZSMPzA/IiFsssiUUcXbrl2HJnNH7JBo7hT5clI_HR6R6JRInM0'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RA-RtnFL2ID2eDcIiPhpvg/UTpEZfHBFpEc3DGfU6xpZolvvsJ7_ICf8wQqIHTS8Kx2gb0qpcy6G_qvT9kl5FiKRFZEd7wGRbiLzuUemx084w/uY4PuCcoPcH1rUWC-B9-drfFjgki7yiZ44npIPL4H1c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,Write a Python script that uses Pymeasure to connect to a MS9740A Spectrum Analyzers,https://en.wikipedia.org/wiki/Spectrum_analyzer,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument.,MS9740A,https://dl.cdn-anritsu.com/en-en/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/ms9740a-e11000.pdf,"[OrderedDict([('id', 'attx5Gv1mQAH0GHFA'), ('width', 420), ('height', 310), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2N8tzcVYiVrimCMrierS6w/4x3BwVp-VricKT-qSyTNV0fqmd5B4YYviaAvr0FAMQWF014Ja3ucBoDuSywP6eMjH1U2DBpWyoqDbNKlSoQGunbNvb_qmE3-5NR5MOPz9THKR82owMWGc41VkoMxsnor/PLrXW0PRahJvRk8wu5ywohyJziV6M7l7BqxnQFcCR0s'), ('filename', 'ms9740a-opticalspectrumanalyzer.png'), ('size', 100654), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xTHiYW9gNjKNlci_Iv-KJg/Bzae0VYvkNfswwCWwVDAJ9el6qX9iaL1DqfBAfNa_rRshVqT3RsMbxgE0Jxx8l2WAMdqvqqYGAW-7nOlRVcarA/oFUithm_JwJWYTpxVbrXeAGg6UTKRpWT0QSzLa1BsnA'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oJNhIGk1dpC3npoPebxOyw/9zr5VGIQZmL7IhHqvchK2CZOEvvLwOJ6fVr4M8iXnJ6ft-KJpgsaYh_VkfLbahb6jq2cGTItFm0ClW15hNEUig/0_LPrAk5NLPZ5HYYvRkH2Hh7AlW80f-FriJ1Ri7Xm-E'), ('width', 420), ('height', 310)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wywKPtg89-CUdE656M9jxg/5VgjSCk_8nCFyyRMKw6E7mJRuhuDQmz6sHWEAvvWsxMqd6B5rDg43IlK876vLyQmeC__pPEcj0PLCd9kieVU9w/lNjtnAmTHnLH4L6f98Jmov9ylkfLRi2knC3pDDW14Dc'), ('width', 3000), ('height', 3000)]))]))])]",https://dl.cdn-anritsu.com/en-en/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/ms9740a-e11000.pdf,,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMS9740A.html,,"
",,,
188,24.9,"Sunnyvale, California",SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,SR 830,521.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Pymeasure,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Pymeasure to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,"[OrderedDict([('id', 'attNaj1PW0Au0Ue7A'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UkvoX3FrigK3aiWaVoS_3A/dMwcYDTrzZvb7zKKETnrQZDr6TTcQaliEx6Fbah618lHP4L1O11q0GDamwoNNfua2p6dTnLqvipTnRqyy6XnIO9YhkFGufPQqofGeogN1Zs/52W3jSDxJgf72Q7STnJCzyOwB0VfL0wHztlGJxcW8qA'), ('filename', 'SR830_FP_Wide1.jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ReVW0iKIB3nNDXuziK3Yxg/iAf-SWtwFMSsdozQjGyYZu7LgKN77RayoIBZWHwEyiqt8pqfebj_D9MRJHY9Zd_aM2-PXo9WlkLBma29rMSUgQ/0dotHi8bhgkg0bEQbz0VK999Xc_9Rcwu8-VmKHjrGd8'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7_BcH9jE98857QzqxfNqYg/E6THw00DciQ2PG8x_cbTVumeejYFV0ysrydlqzUPE0ji7_ZvXLUMPs1naPFjsMBOwjfzMlgo_xwWqrfEdBPhzw/VT-0ApTPDlFi6dOVm4cPy8mu4OkUQNTk3SoRwx6ZCFY'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g4rtJBVtoCBzLQf37gH5Cg/uPB7U5dWBYNpvQWHbRuMhNrMipM_anoNO5SLUL9jCFQWOWwAzrleEcFvO8SSId6iPmvJZC9wcoSd9Of2QPoMnw/oAKtaqvcqxvP8W-9bKPznBguL2CAtvt1qPbv9QFvLYk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr810830.htm,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr830.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr830.html,4250.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import time
import numpy as np
from enum import IntFlag
from pymeasure.instruments import Instrument, discreteTruncate
from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range


class LIAStatus(IntFlag):
    """""" IntFlag type that is returned by the lia_status property.
    """"""
    NO_ERROR = 0
    INPUT_OVERLOAD = 1
    FILTER_OVERLOAD = 2
    OUTPUT_OVERLOAD = 4
    REF_UNLOCK = 8
    FREQ_RANGE_CHANGE = 16
    TC_CHANGE = 32
    TRIGGER = 64
    UNUSED = 128


class ERRStatus(IntFlag):
    """""" IntFlag type that is returned by the err_status property.
    """"""
    NO_ERROR = 0
    BACKUP_ERR = 2
    RAM_ERR = 4
    ROM_ERR = 16
    GPIB_ERR = 32
    DSP_ERR = 64
    MATH_ERR = 128


class SR830(Instrument):

    SAMPLE_FREQUENCIES = [
        62.5e-3, 125e-3, 250e-3, 500e-3, 1, 2, 4, 8, 16,
        32, 64, 128, 256, 512
    ]
    SENSITIVITIES = [
        2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9,
        500e-9, 1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6,
        200e-6, 500e-6, 1e-3, 2e-3, 5e-3, 10e-3, 20e-3,
        50e-3, 100e-3, 200e-3, 500e-3, 1
    ]
    TIME_CONSTANTS = [
        10e-6, 30e-6, 100e-6, 300e-6, 1e-3, 3e-3, 10e-3,
        30e-3, 100e-3, 300e-3, 1, 3, 10, 30, 100, 300, 1e3,
        3e3, 10e3, 30e3
    ]
    FILTER_SLOPES = [6, 12, 18, 24]
    EXPANSION_VALUES = [1, 10, 100]
    RESERVE_VALUES = ['High Reserve', 'Normal', 'Low Noise']
    CHANNELS = ['X', 'Y', 'R']
    INPUT_CONFIGS = ['A', 'A - B', 'I (1 MOhm)', 'I (100 MOhm)']
    INPUT_GROUNDINGS = ['Float', 'Ground']
    INPUT_COUPLINGS = ['AC', 'DC']
    INPUT_NOTCH_CONFIGS = ['None', 'Line', '2 x Line', 'Both']
    REFERENCE_SOURCES = ['External', 'Internal']
    SNAP_ENUMERATION = {""x"": 1, ""y"": 2, ""r"": 3, ""theta"": 4,
                        ""aux in 1"": 5, ""aux in 2"": 6, ""aux in 3"": 7, ""aux in 4"": 8,
                        ""frequency"": 9, ""ch1"": 10, ""ch2"": 11}
    REFERENCE_SOURCE_TRIGGER = ['SINE', 'POS EDGE', 'NEG EDGE']
    INPUT_FILTER = ['Off', 'On']

    sine_voltage = Instrument.control(
        ""SLVL?"", ""SLVL%0.3f"",
        """""" A floating point property that represents the reference sine-wave
        voltage in Volts. This property can be set. """""",
        validator=truncated_range,
        values=[0.004, 5.0]
    )
    frequency = Instrument.control(
        ""FREQ?"", ""FREQ%0.5e"",
        """""" A floating point property that represents the lock-in frequency
        in Hz. This property can be set. """""",
        validator=truncated_range,
        values=[0.001, 102000]
    )
    phase = Instrument.control(
        ""PHAS?"", ""PHAS%0.2f"",
        """""" A floating point property that represents the lock-in phase
        in degrees. This property can be set. """""",
        validator=truncated_range,
        values=[-360, 729.99]
    )
    x = Instrument.measurement(""OUTP?1"",
                               """""" Reads the X value in Volts. """"""
                               )
    y = Instrument.measurement(""OUTP?2"",
                               """""" Reads the Y value in Volts. """"""
                               )

    lia_status = Instrument.measurement(
        ""LIAS?"",
        """""" Reads the value of the lockin amplifier (LIA) status byte. Returns a binary string with
            positions within the string corresponding to different status flags:

            +----+--------------------------------------+
            |Bit | Status                               |
            +====+======================================+
            | 0  | Input/Amplifier overload             |
            +----+--------------------------------------+
            | 1  | Time constant filter overload        |
            +----+--------------------------------------+
            | 2  | Output overload                      |
            +----+--------------------------------------+
            | 3  | Reference unlock                     |
            +----+--------------------------------------+
            | 4  | Detection frequency range switched   |
            +----+--------------------------------------+
            | 5  | Time constant changed indirectly     |
            +----+--------------------------------------+
            | 6  | Data storage triggered               |
            +----+--------------------------------------+
            | 7  | unused                               |
            +----+--------------------------------------+
            """""",
        get_process=lambda s: LIAStatus(int(s)),
    )

    err_status = Instrument.measurement(
        ""ERRS?"",
        """"""Reads the value of the lockin error (ERR) status byte. Returns an IntFlag type with
        positions within the string corresponding to different error flags:

        +----+--------------------------------------+
        |Bit | Status                               |
        +====+======================================+
        | 0  | unused                               |
        +----+--------------------------------------+
        | 1  | backup error                         |
        +----+--------------------------------------+
        | 2  | RAM error                            |
        +----+--------------------------------------+
        | 3  | unused                               |
        +----+--------------------------------------+
        | 4  | ROM error                            |
        +----+--------------------------------------+
        | 5  | GPIB error                           |
        +----+--------------------------------------+
        | 6  | DSP error                            |
        +----+--------------------------------------+
        | 7  | DSP error                            |
        +----+--------------------------------------+
        """""",
        get_process=lambda s: ERRStatus(int(s)),
    )

    @property
    def xy(self):
        """""" Reads the X and Y values in Volts. """"""
        return self.snap()

    magnitude = Instrument.measurement(""OUTP?3"",
                                       """""" Reads the magnitude in Volts. """"""
                                       )
    theta = Instrument.measurement(""OUTP?4"",
                                   """""" Reads the theta value in degrees. """"""
                                   )
    channel1 = Instrument.control(
        ""DDEF?1;"", ""DDEF1,%d,0"",
        """""" A string property that represents the type of Channel 1,
        taking the values X, R, X Noise, Aux In 1, or Aux In 2.
        This property can be set."""""",
        validator=strict_discrete_set,
        values=['X', 'R', 'X Noise', 'Aux In 1', 'Aux In 2'],
        map_values=True
    )
    channel2 = Instrument.control(
        ""DDEF?2;"", ""DDEF2,%d,0"",
        """""" A string property that represents the type of Channel 2,
        taking the values Y, Theta, Y Noise, Aux In 3, or Aux In 4.
        This property can be set."""""",
        validator=strict_discrete_set,
        values=['Y', 'Theta', 'Y Noise', 'Aux In 3', 'Aux In 4'],
        map_values=True
    )
    sensitivity = Instrument.control(
        ""SENS?"", ""SENS%d"",
        """""" A floating point property that controls the sensitivity in Volts,
        which can take discrete values from 2 nV to 1 V. Values are truncated
        to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True
    )
    time_constant = Instrument.control(
        ""OFLT?"", ""OFLT%d"",
        """""" A floating point property that controls the time constant
        in seconds, which can take discrete values from 10 microseconds
        to 30,000 seconds. Values are truncated to the next highest
        level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True
    )
    filter_slope = Instrument.control(
        ""OFSL?"", ""OFSL%d"",
        """""" An integer property that controls the filter slope, which
        can take on the values 6, 12, 18, and 24 dB/octave. Values are
        truncated to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=FILTER_SLOPES,
        map_values=True
    )
    filter_synchronous = Instrument.control(
        ""SYNC?"", ""SYNC %d"",
        """"""A boolean property that controls the synchronous filter.
        This property can be set. Allowed values are: True or False """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )
    harmonic = Instrument.control(
        ""HARM?"", ""HARM%d"",
        """""" An integer property that controls the harmonic that is measured.
        Allowed values are 1 to 19999. Can be set. """""",
        validator=strict_discrete_set,
        values=range(1, 19999),
    )
    input_config = Instrument.control(
        ""ISRC?"", ""ISRC %d"",
        """""" An string property that controls the input configuration. Allowed
        values are: {}"""""".format(INPUT_CONFIGS),
        validator=strict_discrete_set,
        values=INPUT_CONFIGS,
        map_values=True
    )
    input_grounding = Instrument.control(
        ""IGND?"", ""IGND %d"",
        """""" An string property that controls the input shield grounding. Allowed
        values are: {}"""""".format(INPUT_GROUNDINGS),
        validator=strict_discrete_set,
        values=INPUT_GROUNDINGS,
        map_values=True
    )
    input_coupling = Instrument.control(
        ""ICPL?"", ""ICPL %d"",
        """""" An string property that controls the input coupling. Allowed
        values are: {}"""""".format(INPUT_COUPLINGS),
        validator=strict_discrete_set,
        values=INPUT_COUPLINGS,
        map_values=True
    )
    input_notch_config = Instrument.control(
        ""ILIN?"", ""ILIN %d"",
        """""" An string property that controls the input line notch filter
        status. Allowed values are: {}"""""".format(INPUT_NOTCH_CONFIGS),
        validator=strict_discrete_set,
        values=INPUT_NOTCH_CONFIGS,
        map_values=True
    )
    reference_source = Instrument.control(
        ""FMOD?"", ""FMOD %d"",
        """""" An string property that controls the reference source. Allowed
        values are: {}"""""".format(REFERENCE_SOURCES),
        validator=strict_discrete_set,
        values=REFERENCE_SOURCES,
        map_values=True
    )
    reference_source_trigger = Instrument.control(
        ""RSLP?"", ""RSLP %d"",
        """""" A string property that controls the reference source triggering. Allowed
             values are: {}"""""".format(REFERENCE_SOURCE_TRIGGER),
        validator=strict_discrete_set,
        values=REFERENCE_SOURCE_TRIGGER,
        map_values=True
    )

    aux_out_1 = Instrument.control(
        ""AUXV?1;"", ""AUXV1,%f;"",
        """""" A floating point property that controls the output of Aux output 1 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac1 = aux_out_1

    aux_out_2 = Instrument.control(
        ""AUXV?2;"", ""AUXV2,%f;"",
        """""" A floating point property that controls the output of Aux output 2 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac2 = aux_out_2

    aux_out_3 = Instrument.control(
        ""AUXV?3;"", ""AUXV3,%f;"",
        """""" A floating point property that controls the output of Aux output 3 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac3 = aux_out_3

    aux_out_4 = Instrument.control(
        ""AUXV?4;"", ""AUXV4,%f;"",
        """""" A floating point property that controls the output of Aux output 4 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac4 = aux_out_4

    aux_in_1 = Instrument.measurement(
        ""OAUX?1;"",
        """""" Reads the Aux input 1 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc1 = aux_in_1

    aux_in_2 = Instrument.measurement(
        ""OAUX?2;"",
        """""" Reads the Aux input 2 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc2 = aux_in_2

    aux_in_3 = Instrument.measurement(
        ""OAUX?3;"",
        """""" Reads the Aux input 3 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc3 = aux_in_3

    aux_in_4 = Instrument.measurement(
        ""OAUX?4;"",
        """""" Reads the Aux input 4 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc4 = aux_in_4

    def __init__(self, adapter, name=""Stanford Research Systems SR830 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )

    def auto_gain(self):
        self.write(""AGAN"")

    def auto_reserve(self):
        self.write(""ARSV"")

    def auto_phase(self):
        self.write(""APHS"")

    def auto_offset(self, channel):
        """""" Offsets the channel (X, Y, or R) to zero """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        self.write(""AOFF %d"" % channel)

    def get_scaling(self, channel):
        """""" Returns the offset precent and the exapnsion term
        that are used to scale the channel in question
        """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        offset, expand = self.ask(""OEXP? %d"" % channel).split(',')
        return float(offset), self.EXPANSION_VALUES[int(expand)]

    def set_scaling(self, channel, precent, expand=0):
        """""" Sets the offset of a channel (X=1, Y=2, R=3) to a
        certain precent (-105% to 105%) of the signal, with
        an optional expansion term (0, 10=1, 100=2)
        """"""
        if channel not in self.CHANNELS:
            raise ValueError('SR830 channel is invalid')
        channel = self.CHANNELS.index(channel) + 1
        expand = discreteTruncate(expand, self.EXPANSION_VALUES)
        self.write(""OEXP %i,%.2f,%i"" % (channel, precent, expand))

    def output_conversion(self, channel):
        """""" Returns a function that can be used to determine
        the signal from the channel output (X, Y, or R)
        """"""
        offset, expand = self.get_scaling(channel)
        sensitivity = self.sensitivity
        return lambda x: (x / (10. * expand) + offset) * sensitivity

    @property
    def sample_frequency(self):
        """""" Gets the sample frequency in Hz """"""
        index = int(self.ask(""SRAT?""))
        if index == 14:
            return None  # Trigger
        else:
            return SR830.SAMPLE_FREQUENCIES[index]

    @sample_frequency.setter
    def sample_frequency(self, frequency):
        """"""Sets the sample frequency in Hz (None is Trigger)""""""
        assert type(frequency) in [float, int, type(None)]
        if frequency is None:
            index = 14  # Trigger
        else:
            frequency = discreteTruncate(frequency, SR830.SAMPLE_FREQUENCIES)
            index = SR830.SAMPLE_FREQUENCIES.index(frequency)
        self.write(""SRAT%f"" % index)

    def aquireOnTrigger(self, enable=True):
        self.write(""TSTR%d"" % enable)

    @property
    def reserve(self):
        return SR830.RESERVE_VALUES[int(self.ask(""RMOD?""))]

    @reserve.setter
    def reserve(self, reserve):
        if reserve not in SR830.RESERVE_VALUES:
            index = 1
        else:
            index = SR830.RESERVE_VALUES.index(reserve)
        self.write(""RMOD%d"" % index)

    def is_out_of_range(self):
        """""" Returns True if the magnitude is out of range
        """"""
        return int(self.ask(""LIAS?2"")) == 1

    def quick_range(self):
        """""" While the magnitude is out of range, increase
        the sensitivity by one setting
        """"""
        self.write('LIAE 2,1')
        while self.is_out_of_range():
            self.write(""SENS%d"" % (int(self.ask(""SENS?"")) + 1))
            time.sleep(5.0 * self.time_constant)
            self.write(""*CLS"")
        # Set the range as low as possible
        newsensitivity = 1.15 * abs(self.magnitude)
        if self.input_config in ('I (1 MOhm)', 'I (100 MOhm)'):
            newsensitivity = newsensitivity * 1e6
        self.sensitivity = newsensitivity

    @property
    def buffer_count(self):
        query = self.ask(""SPTS?"")
        if query.count(""\n"") > 1:
            return int(re.match(r""\d+\n$"", query, re.MULTILINE).group(0))
        else:
            return int(query)

    def fill_buffer(self, count, has_aborted=lambda: False, delay=0.001):
        ch1 = np.empty(count, np.float32)
        ch2 = np.empty(count, np.float32)
        currentCount = self.buffer_count
        index = 0
        while currentCount < count:
            if currentCount > index:
                ch1[index:currentCount] = self.buffer_data(1, index, currentCount)
                ch2[index:currentCount] = self.buffer_data(2, index, currentCount)
                index = currentCount
                time.sleep(delay)
            currentCount = self.buffer_count
            if has_aborted():
                self.pause_buffer()
                return ch1, ch2
        self.pauseBuffer()
        ch1[index : count + 1] = self.buffer_data(1, index, count)  # noqa: E203
        ch2[index : count + 1] = self.buffer_data(2, index, count)  # noqa: E203
        return ch1, ch2

    def buffer_measure(self, count, stopRequest=None, delay=1e-3):
        self.write(""FAST0;STRD"")
        ch1 = np.empty(count, np.float64)
        ch2 = np.empty(count, np.float64)
        currentCount = self.buffer_count
        index = 0
        while currentCount < count:
            if currentCount > index:
                ch1[index:currentCount] = self.buffer_data(1, index, currentCount)
                ch2[index:currentCount] = self.buffer_data(2, index, currentCount)
                index = currentCount
                time.sleep(delay)
            currentCount = self.buffer_count
            if stopRequest is not None and stopRequest.isSet():
                self.pauseBuffer()
                return (0, 0, 0, 0)
        self.pauseBuffer()
        ch1[index:count] = self.buffer_data(1, index, count)
        ch2[index:count] = self.buffer_data(2, index, count)
        return (ch1.mean(), ch1.std(), ch2.mean(), ch2.std())

    def pause_buffer(self):
        self.write(""PAUS"")

    def start_buffer(self, fast=False):
        if fast:
            self.write(""FAST2;STRD"")
        else:
            self.write(""FAST0;STRD"")

    def wait_for_buffer(self, count, has_aborted=lambda: False,
                        timeout=60, timestep=0.01):
        """""" Wait for the buffer to fill a certain count
        """"""
        i = 0
        while not self.buffer_count >= count and i < (timeout / timestep):
            time.sleep(timestep)
            i += 1
            if has_aborted():
                return False
        self.pauseBuffer()

    def get_buffer(self, channel=1, start=0, end=None):
        """""" Aquires the 32 bit floating point data through binary transfer
        """"""
        if end is None:
            end = self.buffer_count
        return self.binary_values(""TRCB?%d,%d,%d"" % (
            channel, start, end - start))

    def reset_buffer(self):
        self.write(""REST"")

    def trigger(self):
        self.write(""TRIG"")

    def snap(self, val1=""X"", val2=""Y"", *vals):
        """""" Method that records and retrieves 2 to 6 parameters at a single
        instant. The parameters can be one of: X, Y, R, Theta, Aux In 1,
        Aux In 2, Aux In 3, Aux In 4, Frequency, CH1, CH2.
        Default is ""X"" and ""Y"".

        :param val1: first parameter to retrieve
        :param val2: second parameter to retrieve
        :param vals: other parameters to retrieve (optional)
        """"""
        if len(vals) > 4:
            raise ValueError(""No more that 6 values (in total) can be captured""
                             ""simultaneously."")

        # check if additional parameters are given as a list
        if len(vals) == 1 and isinstance(vals[0], (list, tuple)):
            vals = vals[0]

        # make a list of all vals
        vals = [val1, val2] + list(vals)

        vals_idx = [str(self.SNAP_ENUMERATION[val.lower()]) for val in vals]

        command = ""SNAP? "" + "","".join(vals_idx)
        return self.values(command)
"
206,670.0,JAPAN,"The MS9710C provides excellent wavelength accuracy, waveform shape, and new features
",Anritsums MS9710 C,82.0,"**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",Pymeasure,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZmPX4SuNFgpMC_FPYiQp0A/6rWlWETVEOsIG9eJaj7_HTtV4hpuaE5l5bXyhr6NHnX0i81eC-0UIcs_cuAtlRHC1ckl4WcdZseU6UfHX9LgizKTfFhnlmi_mOI2QTBczaA/ACB8i35qnE5qyKeqpZvOW-6SzP-h9ly7vNUgqSnOkwI'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XqeyQwMMQY-YTrsX1BfYAw/-uFNzgN2_iTHUL0tDM3qm9KiEA5U7ZSYUpkonisEjFCewWcVcEa6QdxmNtrkvxTOe0mtTzUqbG0uJPypTwBOIw/jP4kJ0e_UWOU-Sh5XsFbSnOL5xYdeXxYG75IaJDFXgw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zEGLkzKKiX4QgM-iJ5cwWw/OyOUjkwIahhWOEYJj_RB4VnN-8glL3UpVHI97X01JmUf_h3pkWFb0lvq6FmQwNjqpR38W0WmFYhVYbyvZSMPzA/IiFsssiUUcXbrl2HJnNH7JBo7hT5clI_HR6R6JRInM0'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RA-RtnFL2ID2eDcIiPhpvg/UTpEZfHBFpEc3DGfU6xpZolvvsJ7_ICf8wQqIHTS8Kx2gb0qpcy6G_qvT9kl5FiKRFZEd7wGRbiLzuUemx084w/uY4PuCcoPcH1rUWC-B9-drfFjgki7yiZ44npIPL4H1c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,Write a Python script that uses Pymeasure to connect to a MS9710C Spectrum Analyzers,https://en.wikipedia.org/wiki/Spectrum_analyzer,['Spectrum Analyzers'],A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument.,MS9710C,https://dl.cdn-anritsu.com/en-us/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/MS9710C_E11000.pdf,"[OrderedDict([('id', 'att0T5rZRurNk2dQN'), ('width', 300), ('height', 250), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8Hb4KId0ZBxELBp1T3MboA/dIC8VK6HfGMyb5IAoQdtVF7YdcmPifTQOinGJvSm0EbciaigyYn77RNkQwlq-l73ZD6GZuCqqq2ZoXkR9fHFoJwYG9q4s2NXJ4lYWFnSvzo/1xcaHskA9sw7KHIOiSe7nlIs2ryno-a9hvWtcfYRyco'), ('filename', 'MS9710C.jpeg'), ('size', 48894), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mZXZaVFZ55AU_Bvf5ATmeA/CrVdA--IBmwcW_Kj75ma3hO3TKRJ9NBmRUiA_z_xQn7n04bfvYBfgeW-zJjwBCAlvi1nqXm4NtThmepVUzN0bQ/7kLeHXBy4JnlnzXQC2HH8MhRQy0zHW7RjSZxtDouUAQ'), ('width', 43), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-GhVqVJi0X4mN1l09c8ILw/yxmAZSRq9c1ZwJ6VlQAjbgb-lOax19WtTrZpAzQAioz5PuT910MoUZpdY-H-ahBP61M48l1yFvB3RDHJR_8R8A/zrpiYC3Pnf4YLCSh3ZXdWqycAwQiaL_--D6KvPvSFA4'), ('width', 300), ('height', 250)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZwtLy94YIxUwUU1NGX5vUQ/hDrVzO1D4yvCJ6nifM8FkjMWhf_CELTyooJTm2hp7wv98WqF1YOKR2wFz9eSkclHB4tsEz0jF9NCIn1DFadV0g/ZjNFIvpdImjvAbXqlQ7IOHnbtAPu71o7NgikWz_ugaM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/test-measurement/products/ms9710c,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/anritsu/anritsuMS9710C.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMS9710C.html,,"
",True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
import logging
from time import sleep
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set,
    truncated_discrete_set,
    truncated_range,
    joined_validators
)
import re

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

# Analysis Results with Units, ie -24.5DBM -> (-24.5, 'DBM')
r_value_units = re.compile(r""([-\d]*\.\d*)(.*)"")

# Join validators to allow for special sets of characters
truncated_range_or_off = joined_validators(strict_discrete_set, truncated_range)


def _int_or_neg_one(v):
    try:
        return int(v)
    except ValueError:
        return -1


def _parse_trace_peak(vals):
    """"""Parse the returned value from a trace peak query.""""""
    l, p = vals
    res = [l]
    m = r_value_units.match(p)
    if m is not None:
        data = list(m.groups())
        data[0] = float(data[0])
        res.extend(data)
    else:
        res.append(float(p))
    return res


class AnritsuMS9710C(Instrument):
    """"""Anritsu MS9710C Optical Spectrum Analyzer.""""""

    def __init__(self, adapter, name=""Anritsu MS9710C Optical Spectrum Analyzer"", **kwargs):
        """"""Constructor.""""""
        self.analysis_mode = None
        super().__init__(adapter, name=name, **kwargs)

    #############
    #  Mappings #
    #############
    ONOFF = [""ON"", ""OFF""]
    ONOFF_MAPPING = {True: 'ON', False: 'OFF', 1: 'ON', 0: 'OFF', 'ON': 'ON', 'OFF': 'OFF'}

    ######################
    #  Status Registers  #
    ######################

    ese2 = Instrument.control(
        ""ESE2?"", ""ESE2 %d"",
        ""Extended Event Status Enable Register 2"",
        get_process=int
    )

    esr2 = Instrument.control(
        ""ESR2?"", ""ESR2 %d"",
        ""Extended Event Status Register 2"",
        get_process=_int_or_neg_one
    )

    ###########
    #  Modes  #
    ###########

    measure_mode = Instrument.measurement(
        ""MOD?"", ""Returns the current Measure Mode the OSA is in."",
        values={None: 0, ""SINGLE"": 1.0, ""AUTO"": 2.0, ""POWER"": 3.0},
        map_values=True
    )

    ####################################
    # Spectrum Parameters - Wavelength #
    ####################################
    wavelength_center = Instrument.control(
        'CNT?', 'CNT %g', ""Center Wavelength of Spectrum Scan in nm."")

    wavelength_span = Instrument.control(
        'SPN?', 'SPN %g', ""Wavelength Span of Spectrum Scan in nm."")

    wavelength_start = Instrument.control(
        'STA?', 'STA %g', ""Wavelength Start of Spectrum Scan in nm."")

    wavelength_stop = Instrument.control(
        'STO?', 'STO %g', ""Wavelength Stop of Spectrum Scan in nm."")

    wavelength_marker_value = Instrument.control(
        'MKV?', 'MKV %s',
        ""Wavelength Marker Value (wavelength or freq.?)"",
        validator=strict_discrete_set,
        values=[""WL"", ""FREQ""]
    )

    wavelength_value_in = Instrument.control(
        'WDP?', 'WDP %s',
        ""Wavelength value in Vacuum or Air"",
        validator=strict_discrete_set,
        values=[""VACUUM"", ""AIR""]
    )

    level_scale = Instrument.measurement(
        'LVS?', ""Current Level Scale"",
        values=[""LOG"", ""LIN""]
    )

    level_log = Instrument.control(
        ""LOG?"", ""LOG %f"", ""Level Log Scale (/div)"",
        validator=truncated_range, values=[0.1, 10.0]
    )

    level_lin = Instrument.control(
        ""LIN?"", ""LIN %f"", ""Level Linear Scale (/div)"",
        validator=truncated_range, values=[1e-12, 1]
    )

    level_opt_attn = Instrument.control(
        ""ATT?"", ""ATT %s"", ""Optical Attenuation Status (ON/OFF)"",
        validator=strict_discrete_set,
        values=ONOFF
    )

    resolution = Instrument.control(
        ""RES?"", ""RES %f"", ""Resolution (nm)"",
        validator=truncated_discrete_set,
        values=[0.05, 0.07, 0.1, 0.2, 0.5, 1.0]
    )

    resolution_actual = Instrument.control(
        ""ARES?"", ""ARES %s"", ""Resolution Actual (ON/OFF)"",
        validator=strict_discrete_set,
        values=ONOFF,
        map_values=True

    )

    resolution_vbw = Instrument.control(
        ""VBW?"", ""VBW %s"", ""Video Bandwidth Resolution"",
        validator=strict_discrete_set,
        values=[""1MHz"", ""100kHz"", ""10kHz"", ""1kHz"", ""100Hz"", ""10Hz""]
    )

    average_point = Instrument.control(
        ""AVT?"", ""AVT %d"",
        ""Number of averages to take on each point (2-1000), or OFF"",
        validator=truncated_range_or_off,
        values=[[""OFF""], [2, 1000]]
    )

    average_sweep = Instrument.control(
        ""AVS?"", ""AVS %d"",
        ""Number of averages to make on a sweep (2-1000) or OFF"",
        validator=truncated_range_or_off,
        values=[[""OFF""], [2, 1000]]
    )

    sampling_points = Instrument.control(
        ""MPT?"", ""MPT %d"", ""Number of sampling points"",
        validator=truncated_discrete_set,
        values=[51, 101, 251, 501, 1001, 2001, 5001],
        get_process=lambda v: int(v)
    )

    #####################################
    #  Analysis Peak Search Parameters  #
    #####################################

    peak_search = Instrument.control(
        ""PKS?"", ""PKS %s"", ""Peak Search Mode"",
        validator=strict_discrete_set,
        values=[""PEAK"", ""NEXT"", ""LAST"", ""LEFT"", ""RIGHT""]
    )

    dip_search = Instrument.control(
        ""DPS?"", ""DPS %s"", ""Dip Search Mode"",
        validator=strict_discrete_set,
        values=[""DIP"", ""NEXT"", ""LAST"", ""LEFT"", ""RIGHT""]
    )

    analysis = Instrument.control(
        ""ANA?"", ""ANA %s"", ""Analysis Control""
    )

    analysis_result = Instrument.measurement(
        ""ANAR?"", ""Read back anaysis result from current scan.""
    )

    ##########################
    #  Data Memory Commands  #
    ##########################

    data_memory_a_size = Instrument.measurement(
        'DBA?',
        ""Returns the number of points sampled in data memory register A.""
    )

    data_memory_b_size = Instrument.measurement(
        'DBB?',
        ""Returns the number of points sampled in data memory register B.""
    )

    data_memory_a_condition = Instrument.measurement(
        ""DCA?"",
        """"""Returns the data condition of data memory register A.
        Starting wavelength, and a sampling point (l1, l2, n).""""""
    )

    data_memory_b_condition = Instrument.measurement(
        ""DCB?"",
        """"""Returns the data condition of data memory register B.
        Starting wavelength, and a sampling point (l1, l2, n).""""""
    )

    data_memory_a_values = Instrument.measurement(
        ""DMA?"",
        ""Reads the binary data from memory register A.""
    )

    data_memory_b_values = Instrument.measurement(
        ""DMA?"",
        ""Reads the binary data from memory register B.""
    )

    data_memory_select = Instrument.control(
        ""MSL?"", ""MSL %s"",
        ""Memory Data Select."",
        validator=strict_discrete_set,
        values=[""A"", ""B""]
    )

    ###########################
    #  Trace Marker Commands  #
    ###########################

    trace_marker_center = Instrument.setting(
        ""TMC %s"", ""Trace Marker at Center. Set to 1 or True to initiate command"",
        map_values=True,
        values={True: ''}
    )

    trace_marker = Instrument.control(
        ""TMK?"", ""TMK %f"",
        ""Sets the trace marker with a wavelength.  Returns the trace wavelength and power."",
        get_process=_parse_trace_peak
    )

    @property
    def wavelengths(self):
        """"""Return a numpy array of the current wavelengths of scans.""""""
        return np.linspace(
            self.wavelength_start,
            self.wavelength_stop,
            self.sampling_points
        )

    def read_memory(self, slot=""A""):
        """"""Read the scan saved in a memory slot.""""""
        cond_attr = f""data_memory_{slot.lower()}_condition""
        data_attr = f""data_memory_{slot.lower()}_values""

        scan = getattr(self, cond_attr)
        wavelengths = np.linspace(scan[0], scan[1], int(scan[2]))
        power = np.fromstring(getattr(self, data_attr), sep=""\r\n"")

        return wavelengths, power

    def wait(self, n=3, delay=1):
        """"""Query OPC Command and waits for appropriate response.""""""
        log.info(""Wait for OPC"")
        res = self.ask(""*OPC?"")
        n_attempts = n
        while res == '':
            log.debug(f""Empty OPC Response. {n_attempts} remaining"")
            if n_attempts == 0:
                break
            n_attempts -= 1
            sleep(delay)
            res = self.read().strip()

        log.debug(res)

    def wait_for_sweep(self, n=20, delay=0.5):
        """"""Wait for a sweep to stop.

        This is performed by checking bit 1 of the ESR2.
        """"""
        log.debug(""Waiting for spectrum sweep"")

        while self.esr2 != 3 and n > 0:
            log.debug(f""Wait for sweep [{n}]"")
            # log.debug(""ESR2: {}"".format(esr2))
            sleep(delay)
            n -= 1

        if n <= 0:
            log.warning(f""Sweep Timeout Occurred ({int(delay * n)} s)"")

    def single_sweep(self, **kwargs):
        """"""Perform a single sweep and wait for completion.""""""
        log.debug(""Performing a Spectrum Sweep"")
        self.clear()
        self.write('SSI')
        self.wait_for_sweep(**kwargs)

    def center_at_peak(self, **kwargs):
        """"""Center the spectrum at the measured peak.""""""
        self.write(""PKC"")
        self.wait(**kwargs)

    def measure_peak(self):
        """"""Measure the peak and return the trace marker.""""""
        self.peak_search = ""PEAK""
        return self.trace_marker
"
207,550.0,USA,"The PM100USB Power and Energy Meter Interface is compatible with all our C-Series photodiode, thermal, and pyroelectric sensors except for the ES408C Fast Pyroelectric Sensor. Our C-Type standard photodiode, slim photodiode, integrating sphere, and fiber sensors can collectively measure optical powers from 100 pW to 20 W. Our thermal power sensors measure optical powers from 10 µW to 200 W. Compatible C-Series pyroelectric energy sensors can measure energies from 10 µJ to 15 J and repetition rates up to 2 kHz. Note that the ES408C sensor for repetition rates up to 10 kHz, also available below, is not recommended for use with the PM100USB interface, which supports a maximum repetition rate of 3 kHz. Alternatively, other unamplified anode- or cathode-grounded photodiodes with up to 5 mA photocurrent, thermal elements with a maximum output voltage of 1 V, or energy sensors with voltage outputs from 100 mV to 100 V may be used.

This interface can be operated and powered by a PC via the mini-USB port. A readout rate of 300 samples per second allows active signal monitoring while the interface is in use.",Thorlabspm 100 USB,615.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Pymeasure,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Pymeasure to connect to a PM100USB Power Meters,https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037,['Power Meters'],These interfaces provide communication between an attached sensor and a PC or other external control unit. They are designed to be controlled via an external device or operated autonomously using the analog output; there are no controls or display screens.,PM100USB,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,"[OrderedDict([('id', 'attE3gJZRoLQpO3nR'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u9yxz2mGJwXk9-sqJ-jA-w/1kfa_6mTm5oW6Oc43Cm0iZ9UHdASNSpt1GBrUnyot5Mnz3Y0vClYN5-px_DnnZvx-N8Y9uKoQ6RhuoKFIOMOEHu7ENLiZkc5LsD3wYjch28/u5xYF5zpMeuPxAaHkfRE34l4MQCB61ySgdx5LyM6vA8'), ('filename', '8135_PM100USB_SGL.jpg'), ('size', 136075), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DMPm05o62axN-oGlsHAJRw/awYpa6kU-vzlFUHMzAel4aBtaaixEpOySDV_zVTo10jfQrd2q25yr9qNJEodfLHwMVJB9GpfbEiJAV5LyWHAzA/UpD6jT-fj1HEBRwWqgb69lm8XpyxWvaTdkhfdBADm1U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BdYfwbP9HF317VUk2iAOvA/gX_qmzcN4FYo6SIupA93Mw28Nvv2ql6dhOWBNM1GFEkMLLMsBCS-7SMsQjgSndij9TPcJY61U9iV4elm559jTg/9bH9OFVqgwrySW8OJp16C-jiPrFhcPTpRG6-NpsFddk'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RBdLXvxYWXR5TrCYpQ2H4w/Ot_TJejADKRgrnsUOk9dPTe1bjSf-OZ3aXTDTCHGEqwfEvPdzgCxYbbqZfNv73XRsd6UQcyptMGiyrrBmvM9eQ/nxIOoYJ1jjOvl3kFhSiqEH_H26yZha7s0hRgaKkJk2w'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=4037&pn=PM100USB,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thorlabs/thorlabspm100usb.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/thorlabs/thorlabspm100usb.html,487.99,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class ThorlabsPM100USB(Instrument):
    """"""Represents Thorlabs PM100USB powermeter.""""""

    def __init__(self, adapter, name=""ThorlabsPM100USB powermeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        self._set_flags()

    wavelength_min = Instrument.measurement(
        ""SENS:CORR:WAV? MIN"", ""Measure minimum wavelength, in nm""
    )

    wavelength_max = Instrument.measurement(
        ""SENS:CORR:WAV? MAX"", ""Measure maximum wavelength, in nm""
    )

    @property
    def wavelength(self):
        """"""Control the wavelength in nm.""""""
        value = self.values(""SENSE:CORR:WAV?"")[0]
        return value

    @wavelength.setter
    def wavelength(self, value):
        """"""Wavelength in nm.""""""
        if self.wavelength_settable:
            # Store min and max wavelength to only request them once.
            if not hasattr(self, ""_wavelength_min""):
                self._wavelength_min = self.wavelength_min
            if not hasattr(self, ""_wavelength_max""):
                self._wavelength_max = self.wavelength_max

            value = truncated_range(
                value, [self._wavelength_min, self._wavelength_max]
            )
            self.write(f""SENSE:CORR:WAV {value}"")
        else:
            raise AttributeError(
                f""{self.sensor_name} does not allow setting the wavelength.""
            )

    @property
    def power(self):
        """"""Measure the power in W.""""""
        if self.is_power_sensor:
            return self.values(""MEAS:POW?"")[0]
        else:
            raise AttributeError(f""{self.sensor_name} is not a power sensor."")

    @property
    def energy(self):
        """"""Measure the energy in J.""""""
        if self.is_energy_sensor:
            return self.values(""MEAS:ENER?"")[0]
        else:
            raise AttributeError(
                f""{self.sensor_name} is not an energy sensor.""
            )

    def _set_flags(self):
        """"""Get sensor info and write flags.""""""
        response = self.values(""SYST:SENSOR:IDN?"")
        if response[0] == ""no sensor"":
            raise OSError(""No sensor connected."")
        self.sensor_name = response[0]
        self.sensor_sn = response[1]
        self.sensor_cal_msg = response[2]
        self.sensor_type = response[3]
        self.sensor_subtype = response[4]
        _flags_str = response[5]

        # interpretation of the flags, see p. 49 of the manual:
        # https://www.thorlabs.de/_sd.cfm?fileName=17654-D02.pdf&partNumber=PM100D

        # Convert to binary representation and pad zeros to 9 bit for sensors
        # where not all flags are present.
        _flags_str = format(int(_flags_str), ""09b"")
        # Reverse the order so it matches the flag order from the manual, i.e.
        # from decimal values from 1 to 256.
        _flags_str = _flags_str[::-1]

        # Convert to boolean.
        self.flags = [x == ""1"" for x in _flags_str]

        # setting the flags; _dn are unused; decimal values as comments
        (
            self.is_power_sensor,  # 1
            self.is_energy_sensor,  # 2
            _d4,  # 4
            _d8,  # 8
            self.response_settable,  # 16
            self.wavelength_settable,  # 32
            self.tau_settable,  # 64
            _d128,  # 128
            self.has_temperature_sensor,  # 256
        ) = self.flags
"
209,6200.0,US,"The model 7270 sets a new standard for general-purpose DSP lock-in amplifiers.
",Ametek 7270,68.0,"Since 1930, our talented and diverse workforce has been delivering **differentiated technology solutions** to create strong, sustainable and profitable growth.

",Pymeasure,Ametek,"[OrderedDict([('id', 'attRA8RkXtCHdQBNb'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IfFxy49sfO5gKXTT74nJYQ/SmyftxosABpeN5fjGx6cf0Za_fL4RMzRGibanAZnDuHbpZMqX_nVLxSXxETyuV_H2vsIYQJcDIl2X1oonLH4yoA9ArYEUSLW6ncofvqB4sM/7Gz4O8Ix5r60drDXJrJYapG5mfUOGEieczmG_VUfWRI'), ('filename', 'ametek-vector-logo.png'), ('size', 3631), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ACp6qN9VjYsHcr11gzZVLQ/BX_R8nzhFidFneOAHU21p65MRemFrvhmETOS_PAzBQIdwSUDoq9Vg01Va7gP4U3I8gwsCTQ79fFPhFBAd4gTGQ/jGvO-XJ122UV30I5QUay4Susxz5_H3IocJefJGEUvCA'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_YW97F3klQ-JVJ-Omcesiw/lIIK2qLz9O23rZNX4w5Oh5pID7KffEYRAQDf1ciZ6lCymLN_IUYDGPOSVkbWvF9NiQ5ceibk6kEM7-NPSrmA3g/0IIlsBY7fqKuamd92nZ7mp9RaYUFovHscsVIfefLJDc'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/It_2fGIj-CKB4zwr4jXktw/CL7FwjbrmITK9RsdjT_VTA0yqebGAePnxVr57Fgz2aP_pn-dA7csQOlp73JzSbFTSqeCJlguBYDcYAkiG_9VYA/pC3LIlzyII-YDJZDtQiZ9JY5n1mQH2H_D65u-ho1L4A'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ametek.com/,Write a Python script that uses Pymeasure to connect to a Ametek 7270 Lockin Amplifiers,https://en.wikipedia.org/wiki/Lock-in_amplifier,['Lockin Amplifiers'],A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment,Ametek 7270,https://www.ameteksi.com/-/media/ameteksi/download_links/documentations/7270/model_7270.pdf,"[OrderedDict([('id', 'attHoI3NQpJoD6CN6'), ('width', 450), ('height', 450), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zMy9ln9NV7Nfd25vraSD5A/n8t4ppPKojOIwICRdRCM4NTOG7w-AJ23aUNdndEPLqzXJ_oipdcEJSiDefeWkZEA_KF9fDxrmhfvUSbF1e9phqR4WJ2awYYkiFgfVCfG21BbkwJVQ-E_XyhkgFTXgJHB/OT_fJq43-2O7uOYFlP5ENoejoR47IkAqNxSSHWJTUEE'), ('filename', 'Detection-synchrone-LockIn_7270.jpg'), ('size', 12509), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/y-QkqkDqHrlLBPDfn4YZdA/ftiRZPbs2W51ame4qSLs_Qaclfnolyd38fKvKcwmwWd0McDkx1QygveWL5UbIkn9JDHpS5piRPV0L-MmShbp7g/uRQVS6NqQMm354rodBmj9m-tHkgN_gAYaTwoOqUx2WI'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ORjcrIaON_mr6Jnh_8Bgsg/oVua0wg9isguZJlnh_4nzirNo-rOtNhSDaliihF3Il6ulOTlqga-gxqEdSEZllfT9DttnyQ3kEaWPuATg3i37Q/N8OqZ5_g0oDphluzM9bFslHrxKAh_nkLAnpBMV9Sy_8'), ('width', 450), ('height', 450)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tP-UAx3TShafEpuP_xvqTQ/84344Ji301hbMtgHkRccLpTlKk8Kx0BHV7JG2tierZt82xGWdOWOAGVGzFL2jWRMOorYVlD1KfVd1zG2lOB8pg/EmIgNyZBKoqJRI900tt4yJ3S952Vv0KtR8v6BbRzog0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ameteksi.com/-/media/ameteksi/download_links/documentations/7270/model_7270.pdf,https://github.com/pymeasure/pymeasure/tree/master/docs/api/instruments/ametek,https://pymeasure.readthedocs.io/en/latest/api/instruments/ametek/ametek7270.html,,"
",,Not a real Script for Github,
215,2500.0,"Munich, Germany","The R&S FSL series Spectrum Analyzer – are a lightweight and compact range of spectrum analyzer for cost-conscious users who want the functionality of high-end instruments.

These analyzers are ideal for a large number of applications in development, service and production.",FSL,471.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Pymeasure,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Pymeasure to connect to a {Device name} Spectrum Analyzers,https://en.wikipedia.org/wiki/Spectrum_analyzer,['Spectrum Analyzers'],"A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals. The input signal that most common spectrum analyzers measure is electrical; however, spectral compositions of other signals, such as acoustic pressure waves and optical light waves, can be considered through the use of an appropriate transducer. Spectrum analyzers for other types of signals also exist, such as optical spectrum analyzers which use direct optical techniques such as a monochromator to make measurements.",,https://rapid-tech.com.au/wp-content/uploads/2020/06/RS-FSL-Datasheet.pdf,"[OrderedDict([('id', 'attgVn4mkgcYBvVCi'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uqq_et9oj6GrrP1OlcsNUA/sbj7I0rBAjwuStlMg2SIc8jGFqU1KAxa_T3ePE_0u1CUS-w6n4tME9a-pwIyJsE9waRk-Pkn8poTZyJdo5nf0L3Gx5NbLJ7s8Bt_KZCbKc_F9fVTt_G40ozRHu-r5evidfmt8bLY9WPdDsTyRqddCFKL4dq_INoV70ZVKKSdXhg/jElBttfqskclxYrIoo8444o2rsVLXhnCHIIJXY6yTWY'), ('filename', 'fsl18-spectrum-analyzer-front-view-rohde-schwarz_200_1315_640_360_5.jpg'), ('size', 38239), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ErGp03oGkXG20EhEmVmmxA/pVXdlZETJC4POMqcEv--WNnEY5sUbWlb5r6jgtz0VZnyukuIwNxk9eitNDBMKiyA7SGQbec6f1d6r4gBR2RtNQ/PcYWDbjCa4QbmFGMYXnj6-VuJwkAXnfKL5QNCsylS50'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/s2CvEwvzyaMw5GSVdS2uHQ/fTbyb8yFsyd-bBVXl2HBP0ASu-YdNQAFdfbhcA9NcL5tPY_-3Qdsap2YX0HWcGQIrsNLZUqm3Gk4s6dLdIAMyw/Ojpul0HxqPlq56vmsJIK1Xfl-OTpuf45e_YwIVNOkAo'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1FfeuyMU1pBL_vCKL4zkxA/1BgMC954EqoHS-QBBt6ZcMostKBGuVsaxQByag57Zz_6izugxSLbL9kB-QYrZm8WtmTg1uqngzN4tX8AVH5J-g/kONmT1Md72arhsdRkoYZl0yjXZsqJeKAYc0U5TZk2hI'), ('width', 3000), ('height', 3000)]))]))])]",https://rapid-tech.com.au/rs-fsl-spectrum-analyzer-9-khz-to-3-ghz-6-ghz-or-18-ghz/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/fsl.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/fsl.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

import numpy as np
from pymeasure.instruments.validators import strict_discrete_set
from pymeasure.instruments import Instrument

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def _number_or_auto(value):
    # helper for the bandwidth setting
    if isinstance(value, str) and value.upper() == ""AUTO"":
        return "":AUTO ON""
    else:
        # There is no space in the set commands, so we have to add it
        return "" "" + str(value)


class FSL(Instrument):
    """"""
    Represents a Rohde&Schwarz FSL spectrum analyzer.

    All physical values that can be set can either be as a string of a value
    and a unit (e.g. ""1.2 GHz"") or as a float value in the base units (Hz,
    dBm, etc.).
    """"""

    def __init__(self, adapter, name=""Rohde&Schwarz FSL"", **kwargs):
        super().__init__(
            adapter, name, includeSCPI=True, **kwargs
        )

    # Frequency settings ------------------------------------------------------

    freq_span = Instrument.control(
        ""FREQ:SPAN?"",
        ""FREQ:SPAN %s"",
        ""Frequency span in Hz."",
    )

    freq_center = Instrument.control(
        ""FREQ:CENT?"",
        ""FREQ:CENT %s"",
        ""Center frequency in Hz."",
    )

    freq_start = Instrument.control(
        ""FREQ:STAR?"",
        ""FREQ:STAR %s"",
        ""Start frequency in Hz."",
    )

    freq_stop = Instrument.control(
        ""FREQ:STOP?"",
        ""FREQ:STOP %s"",
        ""Stop frequency in Hz."",
    )

    attenuation = Instrument.control(
        ""INP:ATT?"",
        ""INP:ATT %s"",
        ""Attenuation in dB."",
    )

    res_bandwidth = Instrument.control(
        ""BAND:RES?"",
        # There is no space between RES and %s on purpose, see _number_or_auto.
        ""BAND:RES%s"",
        ""Resolution bandwidth in Hz. Can be set to 'AUTO'"",
        set_process=_number_or_auto,
    )

    video_bandwidth = Instrument.control(
        ""BAND:VID?"",
        ""BAND:VID%s"",
        ""Video bandwidth in Hz. Can be set to 'AUTO'"",
        set_process=_number_or_auto,
    )

    # Sweeping ----------------------------------------------------------------

    sweep_time = Instrument.control(
        ""SWE:TIME?"",
        # No space between TIME and %s on purpose, see _number_or_auto.
        ""SWE:TIME%s"",
        ""Sweep time in s. Can be set to 'AUTO'."",
        set_process=_number_or_auto,
    )

    continuous_sweep = Instrument.control(
        ""INIT:CONT?"",
        ""INIT:CONT %s"",
        ""Continuous (True) or single sweep (False)"",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    def single_sweep(self):
        """"""Perform a single sweep with synchronization.""""""
        self.write(""INIT; *WAI"")

    def continue_single_sweep(self):
        """"""Continue with single sweep with synchronization.""""""
        self.write(""INIT:CONM; *WAI"")

    # Traces ------------------------------------------------------------------

    def read_trace(self, n_trace=1):
        """"""
        Read trace data.

        :param n_trace: The trace number (1-6). Default is 1.
        :return: 2d numpy array of the trace data, [[frequency], [amplitude]].
        """"""
        y = np.array(self.values(f""TRAC{n_trace}? TRACE{n_trace}""))
        x = np.linspace(self.freq_start, self.freq_stop, len(y))
        return np.array([x, y])

    trace_mode = Instrument.control(
        ""DISP:TRAC:MODE?"",
        ""DISP:TRAC:MODE %s"",
        ""Trace mode ('WRIT', 'MAXH', 'MINH', 'AVER' or 'VIEW')"",
        validator=strict_discrete_set,
        values=[""WRIT"", ""MAXH"", ""MINH"", ""AVER"", ""VIEW""],
    )

    # Markers -----------------------------------------------------------------

    def create_marker(self, num=1, is_delta_marker=False):
        """"""
        Create a marker.

        :param num: The marker number (1-4)
        :param is_delta_marker: True if the marker is a delta marker, default
            is False.
        :return: The marker object.
        """"""
        return self.Marker(self, num, is_delta_marker)

    class Marker:
        def __init__(self, instrument, num, is_delta_marker):
            """"""
            Marker and Delta Marker class.

            :param instrument: The FSL instrument.
            :param num: The marker number (1-4)
            :param is_delta_marker: True if the marker is a delta marker,
                defaults to False.
            """"""
            self.instrument = instrument
            self.is_delta_marker = is_delta_marker
            # Building the marker name for the commands.
            if self.is_delta_marker:
                # Smallest delta marker number is 2.
                self.name = ""DELT"" + str(max(2, num))
            else:
                self.name = ""MARK""
                if num > 1:
                    # Marker 1 doesn't get a number.
                    self.name = self.name + str(num)

            self.activate()

        def read(self):
            return self.instrument.read()

        def write(self, command):
            self.instrument.write(f""CALC:{self.name}:{command}"")

        def ask(self, command):
            return self.instrument.ask(f""CALC:{self.name}:{command}"")

        def values(self, command, **kwargs):
            """"""
            Reads a set of values from the instrument through the adapter,
            passing on any keyword arguments.
            """"""
            return self.instrument.values(
                f""CALC:{self.name}:{command}"", **kwargs
            )

        def activate(self):
            """"""Activate a marker.""""""
            self.write(""STAT ON"")

        def disable(self):
            """"""Disable a marker.""""""
            self.write(""STAT OFF"")

        x = Instrument.control(
            ""X?"", ""X %s"", ""Position of marker on the frequency axis in Hz.""
        )

        y = Instrument.control(
            ""Y?"", ""Y %s"", ""Amplitude of the marker position in dBm.""
        )

        peak_excursion = Instrument.control(
            ""PEXC?"",
            ""PEXC %s"",
            ""Peak excursion in dB."",
        )

        def to_trace(self, n_trace=1):
            """"""
            Set marker to trace.

            :param n_trace: The trace number (1-6). Default is 1.
            """"""
            self.write(f""TRAC {n_trace}"")

        def to_peak(self):
            """"""Set marker to highest peak within the span.""""""
            self.write(""MAX"")

        def to_next_peak(self, direction=""right""):
            """"""
            Set marker to next peak.

            :param direction: Direction of the next peak ('left' or 'right' of
                the current position).
            """"""
            self.write(f""MAX:{direction}"")

        def zoom(self, value):
            """"""
            Zoom in to a frequency span or by a factor.

            :param value: The value to zoom in by. If a number is passed it is
                interpreted as a factor. If a string (number with unit) is
                passed it is interpreted as a frequency span.
            """"""
            self.write(f""FUNC:ZOOM {value}; *WAI"")
"
226,,,,Dpseriesmotorcontroller,73.0,,Pymeasure,Anaheim Automation,,,Write a Python script that uses Pymeasure to connect to a DP Series Motor Controller ,,,,DP Series Motor Controller,,,,,,,"
",,,
229,75.0,Germany,"The iBeam smart is the ultimate choice when looking for a high-performance, ultra-reliable OEM single mode diode laser system. Record values at output power, combined with excellent power and beam pointing stability are setting the standard in the class of compact diode lasers. Its flexible, µ-processor based electronics will make system integration a snap. Features as FINE, SKILL and AUTOPULSE are capable to solve common problems of your application.",Ibeamsmart,624.0,"TOPTICA Photonics is a manufacturer of [lasers](https://en.wikipedia.org/wiki/Laser) for quantum technologies, biophotonics and material inspection
",Pymeasure,Toptica,"[OrderedDict([('id', 'attdPu3r6YQ3XuoNe'), ('width', 469), ('height', 107), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mWHgA4oi1FvYJqyZ8prvcg/ab6Vc1q_KDv4EAJjFJu_f_ktpmfgnhSu-3vQRFm_Zc-SiTLTIE3ZdEW36rwLwA5F2joKRHJ7pkMPHbByRT9kI02DFPAylcb3QkRIr6z7UJs/RJw39hAWhzt-NvBCfndI38tTdbfWr62Hr3tNipIC9RU'), ('filename', 'download.png'), ('size', 4105), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6x7K5pk6uOw9bsJabP_ZAw/nLrk3rksEqL6rGQ7pgnMbnCS2pDNUmswJcQJu0ce5CVrmueAlZgjnraYNZlzBWUmwUlYN2uKdu8bLj3rRg346A/tZ5Ihy0FMk_e896KBi8fTr8V-W6UTJMzPgKUelY1MVQ'), ('width', 158), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Sep7micXa-kZc1ZG03CqHQ/Y-tdVUC-Z_8ugLYE_Iz04EsQeQTYL5JD_No6LuDyhBnxV5-ZI-sWJuI5w5p9vUZzFISz1Qzvb6KPyYKOoPpq0w/X-IlFSN1lqfPsROtBh_o0YLcvZegBtnSwYq45b3JZ0g'), ('width', 469), ('height', 107)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/snWR4CX2YFVtZ2SHj54ztQ/K9H0u9OKDjypS_b3q0GZwzTkXZutZUvtF3p-Vtt-_CBP0sTd7mvjpuAlpdjIy5osTQ8gW6zqvcuiWUtAlnO2dQ/HIzbtECsnM2f8fSVCa0X17ptzkkhPxTdtQ08_FuU-sA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/,Write a Python script that uses Pymeasure to connect to a iBeam smart Lasers,https://en.wikipedia.org/wiki/Laser_diode,['Lasers'],"A laser diode (LD, also injection laser diode or ILD, or diode laser) is a semiconductor device similar to a light-emitting diode in which a diode pumped directly with electrical current can create lasing conditions at the diode's junction",iBeam smart,https://www.toptica.com/fileadmin/Editors_English/11_brochures_datasheets/01_brochures/toptica_BR_iBeam_smart_family.pdf,"[OrderedDict([('id', 'attTnJTuWKGQlwm5Y'), ('width', 1200), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/G83xOLx4uihlo6yIq1dLzg/KiCEbVYXbkjn82tR7IWE0xx7bzbHGU6iEgZQpDvsYDtHGcBTj3DnX6r748TVQP59mQo00KAZ12TH7hOM9j7Sdhvq-gG5jICSGxQ_rIOifGsjpuY3U-mRcPYhjBU4H_90kHawjdYaMlETm0cqtO0iXw/ZDci6HJIfMPvtRwCn7qdfBgbIHfhNqF3RwVUN1cGftg'), ('filename', 'toptica_ibeam_smart_3_colors_1200x350_b.jpg'), ('size', 161267), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/punTFgG70jV-IsORPIA_1Q/4wz9JfJgOAofrQ_8LAeUVH52hye-CHfukh0yO2RWEnrOD0ApP9sMLkiVkPJQSPQPImu3wmv4TCOERdo3rU-2pw/F8lffGB-579b2W80kQsBsU29FvkQOpP8CANInN9fEp4'), ('width', 123), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sutRVLEwIKd0yMTI2mZoOg/7MoeeTP96-rwB0qAb0BxEmRKScSGS44KRxixZg6ZtlISfJeIBJ10Eo2o6E34ChrfynlQSZWjhiEaYRenMBzWeg/PpHpElRjKLAAnghPfQLLXfTDRrdFfZqYFOpX0gnECZ8'), ('width', 1200), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/X0hbv8COICVWrjrUCuJZHw/AxGEqWgjVm7X2WSSobYmXNuDCJfGf5gAR1cGdYjY-hXUhBXrYUJxbNAa0cGQiAkmajj_f7KlMZMTSnSgVNsFMQ/Qp6ZoPWg5MRJnWkIWIwokkCMczgTp69_EZ5WxGyJWBs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.toptica.com/products/single-mode-diode-lasers/ibeam-smart,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/toptica/ibeamsmart.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/toptica/ibeamsmart.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import re
import time
from warnings import warn

from pyvisa.errors import VisaIOError

from pymeasure.instruments import Channel, Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def _deprecation_warning(text):
    def func(x):
        warn(text, FutureWarning)
        return x

    return func


def _deprecation_warning_channels(property_name):
    def func(x):
        warn(f'Deprecated property name ""{property_name}"", use the channels '
             '""enabled"" property instead.', FutureWarning)
        return x

    return func


def deprecated_strict_discrete_set(value, values):
    warn(""This property is deprecated, use channels instead."", FutureWarning)
    return strict_discrete_set(value, values)


class DriverChannel(Channel):
    """"""A laser diode driver channel for the IBeam Smart laser.""""""

    power = Channel.setting(
        ""ch {ch} pow %f mic"",
        """"""Set the output power in µW (float up to 200000)."""""",
        check_set_errors=True,
        validator=strict_range,
        values=[0, 200000],
    )

    enabled = Channel.control(
        ""sta ch {ch}"",
        ""%s {ch}"",
        """"""Control the enabled state of the driver channel."""""",
        validator=strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en"" if v else ""di"",
        check_set_errors=True,
    )


class IBeamSmart(Instrument):
    """""" IBeam Smart laser diode

    For the usage of the different diode driver channels, see the manual

    .. code::

        laser = IBeamSmart(""SomeResourceString"")
        laser.emission = True
        laser.ch_2.power = 1000  # µW
        laser.ch_2.enabled = True
        laser.shutdown()

    :param adapter: pyvisa resource name or adapter instance.
    :param baud_rate: The baud rate you have set in the instrument.
    :param \\**kwargs: Any valid key-word argument for VISAAdapter.
    """"""
    _reg_value = re.compile(r""\w+\s+=\s+(\w+)"")

    ch_1 = Instrument.ChannelCreator(DriverChannel, 1)

    ch_2 = Instrument.ChannelCreator(DriverChannel, 2)

    ch_3 = Instrument.ChannelCreator(DriverChannel, 3)

    ch_4 = Instrument.ChannelCreator(DriverChannel, 4)

    ch_5 = Instrument.ChannelCreator(DriverChannel, 5)

    def __init__(self, adapter, name=""Toptica IBeam Smart laser diode"",
                 baud_rate=115200,
                 **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            read_termination='\r\n',
            write_termination='\r\n',
            asrl={'baud_rate', baud_rate},
            **kwargs
        )
        # configure communication mode: no repeating and no command prompt
        self.write('echo off')
        self.write('prom off')
        time.sleep(0.04)
        # clear the initial messages from the controller
        try:
            self.adapter.flush_read_buffer()
        except AttributeError:
            log.warning(""Adapter does not have 'flush_read_buffer' method."")
        self.ask('talk usual')

    def read(self):
        """"""Read a reply of the instrument and extract the values, if possible.

        Reads a reply of the instrument which consists of at least two
        lines. The initial ones are the reply to the command while the last one
        should be '[OK]' which acknowledges that the device is ready to receive
        more commands.

        Note: '[OK]' is always returned as last message even in case of an
        invalid command, where a message indicating the error is returned
        before the '[OK]'

        Value extraction: extract <value> from 'name = <value> [unit]'.
        If <value> can not be identified the orignal string is returned.

        :return: string containing the ASCII response of the instrument (without '[OK]').
        """"""
        reply = super().read()  # read back the LF+CR which is always sent back
        if reply != """":
            raise ValueError(
                f""Error, no empty line at begin of message, instead '{reply}'"")
        msg = []
        try:
            while True:
                line = super().read()
                if line == '[OK]':
                    break
                msg.append(line)
        except VisaIOError:
            reply = '\n'.join(msg)
            try:
                self.adapter.connection.flush_read_buffer()
            except AttributeError:
                log.warning(""Adapter does not have 'flush_read_buffer' method."")
            raise ValueError(f""Flush buffer failed after '{reply}'"")
        reply = '\n'.join(msg)
        r = self._reg_value.search(reply)
        if r:
            return r.groups()[0]
        else:
            return reply

    def check_set_errors(self):
        """"""Check for errors after having gotten a property and log them.

        Checks if the last reply is only '[OK]', otherwise a ValueError is
        raised and the read buffer is flushed because one has to assume that
        some communication is out of sync.
        """"""
        reply = self.read()
        if reply:
            # anything else than '[OK]'.
            self.adapter.connection.flush_read_buffer()
            log.error(f""Setting a property failed with reply '{reply}'."")
            raise ValueError(f""Setting a property failed with reply '{reply}'."")
        return []

    version = Instrument.measurement(
        ""ver"", """"""Get Firmware version number."""""",
    )

    serial = Instrument.measurement(
        ""serial"", """"""Get Serial number of the laser system."""""",
    )

    temp = Instrument.measurement(
        ""sh temp"",
        """"""Measure the temperature of the laser diode in degree centigrade."""""",
    )

    system_temp = Instrument.measurement(
        ""sh temp sys"",
        """"""Measure base plate (heatsink) temperature in degree centigrade."""""",
    )

    current = Instrument.measurement(
        ""sh cur"",
        """"""Measure the laser diode current in mA."""""",
    )

    emission = Instrument.control(
        ""sta la"", ""la %s"",
        """"""Control emission status of the laser diode driver (bool)."""""",
        validator=strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""on"" if v else ""off"",
        check_set_errors=True,
    )

    laser_enabled = Instrument.control(
        ""sta la"", ""la %s"",
        """"""Control emission status of the laser diode driver (bool).

        .. deprecated:: 0.12 Use attr:`emission` instead.
        """""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""on"" if v else ""off"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning(
            ""Property `laser_enabled` is deprecated, use `emission` instead.""),
    )

    channel1_enabled = Instrument.control(
        ""sta ch 1"", ""%s"",
        """"""Control status of Channel 1 of the laser (bool).

        .. deprecated:: 0.12 Use :attr:`ch_1.enabled` instead.
        """""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en 1"" if v else ""di 1"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning_channels(""channel1_enabled""),
    )

    channel2_enabled = Instrument.control(
        ""sta ch 2"", ""%s"",
        """"""Control status of Channel 2 of the laser (bool).

        .. deprecated:: 0.12 Use :attr:`ch_2.enabled` instead."""""",
        validator=deprecated_strict_discrete_set,
        values=[True, False],
        get_process=lambda s: True if s == 'ON' else False,
        set_process=lambda v: ""en 2"" if v else ""di 2"",
        check_set_errors=True,
        preprocess_reply=_deprecation_warning_channels(""channel2_enabled""),
    )

    power = Instrument.control(
        ""sh pow"", ""ch pow %f mic"",
        """"""Control actual output power in µW of the laser system. In pulse mode
        this means that the set value might not correspond to the readback
        one (float up to 200000)."""""",
        validator=strict_range,
        values=[0, 200000],
        check_set_errors=True,
    )

    def enable_continous(self):
        """"""Enable countinous emmission mode.""""""
        self.write('di ext')
        self.check_set_errors()
        self.emission = True
        self.ch_2.enabled = True

    def enable_pulsing(self):
        """"""Enable pulsing mode.

        The optical output is controlled by a digital
        input signal on a dedicated connnector on the device.""""""
        self.emission = True
        self.ch_2.enabled = True
        self.write('en ext')
        self.check_set_errors()

    def disable(self):
        """"""Shutdown all laser operation.""""""
        self.write('di 0')
        self.check_set_errors()
        self.emission = False

    def shutdown(self):
        """"""Brings the instrument to a safe and stable state.""""""
        self.disable()
        super().shutdown()
"
230,550.0,USA,"The PRO8000 Chassis can accept up to 8 modules and is ideally suited for the needs of large test setups. This made-to-order chassis can be custom configured with up to eight modules that best meet individual experimental needs prior to purchase. The chassis can also be ordered empty, without any pre-installed modules. The empty slots of the PRO8000 can be covered using PRO8000-C front cover plates.",Thorlabspro 8000,619.0,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",Pymeasure,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B34kPd8TDySPykIqGnAQbw/aiiK819WYExx3Ptf5wMW9occy5nw036iAflUYeUKd3P4oIOtDcjE-9n_aPuC9CIL6NqW9upoWnPw1MNj_dT272K3sQl6HrzLFUheR7vbgDA/McPpt4BKHE-5dfRkgnw9sy91ZT_2J2U6zhqPJLIpSMo'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-IvxdwJZrNBEfbQllhNmjw/R2XVDzJm1eKjim2p3oPbkO0dTIqE8mJXIfagvk20zhFxQhu6OksXnXxFX3T7Js0XghjhysXg1U4hrYSY20fgqw/ePugtvTHT0veIoRZ7driznLOXT78vezhqu8vI9Qr9tw'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7MaR2gHuTGamIUDR6lpP_Q/h_TMBraNTFAgmrgYDRJVXnE24Tce3lEenhhkhf4x6E7N8W4ioeCEy-FmPSScWXQSKR9mNqK7eHTYLngjLCjurg/xbql1i-E8yIE38xfkhyh6Ea8xj3EnIOpH7RBtQWLpFs'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aM50-TKhPPqIT7mVMqCDNQ/NqK_Klj2IUd6BRR-rB9c_jzWWg3VIMr5gAf0IasH4eMUL0PkDhO0dpciWLQyN8Z40DMSviJxYrXeZh8qiz8g5Q/IrYPj2E85dh2q1sQ4SOYb_I8-A87BkF7ZS7m31_8sM0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,Write a Python script that uses Pymeasure to connect to a PRO8000 Laser Diode Controllers,https://www.newport.com/c/laser-diode-controllers,['Laser Diode Controllers'],"Laser diode controllers have an integrated precision laser diode driver and high stability temperature controller. Multiple levels of laser diode protection are built into each instrument including isolated power supplies, slow start, adjustable current limit and compliance voltage, intermittent contact protection, and output shorting relays. To complement our line of laser diode controllers, ILX Lightwave offers a wide variety of laser diode mounts and fixtures with standard interconnection cables.",PRO8000,https://www.thorlabs.com/_sd.cfm?fileName=19570-D02.pdf&partNumber=PM100USB,"[OrderedDict([('id', 'att9arouLgpPtpqWm'), ('width', 600), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ffjSLtAbA-vC7alDUSWNvA/gwx-CyPdhN2AZFjFsHybvnqJwjClvdbfea_D6_48q6Aw4wod_P2L0tyETLy4Brsbz9mubrSqCJyb5Y3rZSsa5EJT6JXdVkjqFmXjlxFPeis/N217RXbz5FO6YViDjLWzKJToUJH9hfxipoPwL6jgazc'), ('filename', '1649_PRO8000_2_SGL.jpg'), ('size', 42451), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/U2-1AbwZPaHMIAnFhRgtPg/_lTZ4_GfkwKA5OVx40LYyyHB6pntQb28gc9UVVaTD6-UPiw4bM-1pHYO5tedb9fdnxbyVy3qopk7_5mKrHVh3w/p-NvbMI1mJySOSfkdP05QN1sSS0vxHC_SwCm_aFpQVk'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WGpcj2heo97qGa1AWdZ_6A/wfCKVzsdul1BGldbWQuLRakaQyKAxgR5zThbMB36-_Q47rKsMzxEK0d72ve5N_7fiQ7LK9CHD4JbvyumWRLi5w/C8NGjNb9n9JH7M9la21k2wBv7rdjxwwSgz6i_mH3usc'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yYzqF29Mb6JaA_S_QSICCg/cLlwAuWnQXNvb1uOJkZuKE3P4-SoFdKCQhj3M7ZMkaN3PeNlZvteqOdGeP8ixpzW9iwIJ1pTkDdw3BU2a77jXg/dOyrIQUj3RrM8aPQ914UY8nIN7w8AkhttS2hpjc3Ev8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=895&pn=PRO8000,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thorlabs/thorlabspro8000.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/thorlabs/thorlabspro8000.html,2966.31,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set


class ThorlabsPro8000(Instrument):
    """"""Represents Thorlabs Pro 8000 modular laser driver""""""
    SLOTS = range(1, 9)
    LDC_POLARITIES = ['AG', 'CG']
    STATUS = ['ON', 'OFF']

    def __init__(self, adapter, name=""Thorlabs Pro 8000"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.write(':SYST:ANSW VALUE')

    # Code for general purpose commands (mother board related)
    slot = Instrument.control("":SLOT?"", "":SLOT %d"",
                              ""Control slot selection. Allowed values are: {}"""""".format(SLOTS),
                              validator=strict_discrete_set,
                              values=SLOTS,
                              map_values=False)

    # Code for LDC-xxxx daughter boards (laser driver)
    LDCCurrent = Instrument.control("":ILD:SET?"", "":ILD:SET %g"",
                                    """"""Control laser current."""""")

    LDCCurrentLimit = Instrument.control(
        "":LIMC:SET?"", "":LIMC:SET %g"",
        """"""Set Software current Limit (value must be lower than hardware current limit).""""""
    )

    LDCPolarity = Instrument.control(
        "":LIMC:SET?"", "":LIMC:SET %s"",
        f""""""Set laser diode polarity. Allowed values are: {LDC_POLARITIES}"""""",
        validator=strict_discrete_set,
        values=LDC_POLARITIES,
        map_values=False
    )

    LDCStatus = Instrument.control(
        "":LASER?"", "":LASER %s"",
        """"""Set laser diode status. Allowed values are: {}"""""".format(
            STATUS),
        validator=strict_discrete_set,
        values=STATUS,
        map_values=False
    )

    # Code for TED-xxxx daughter boards (TEC driver)
    TEDStatus = Instrument.control("":TEC?"", "":TEC %s"",
                                   f""""""Control TEC status. Allowed values are: {STATUS}"""""",
                                   validator=strict_discrete_set,
                                   values=STATUS,
                                   map_values=False)

    TEDSetTemperature = Instrument.control("":TEMP:SET?"", "":TEMP:SET %g"",
                                           """"""Control TEC temperature"""""")
"
234,5420.0,USA," It provides a wide range of measurement capabilities to cover the electrical characterization and evaluation of devices, materials, semiconductors, active/passive components, or virtually any other type of electronic device with uncompromised measurement reliability and efficiency. The B1500A modular architecture gives you the flexibility to upgrade when needed.",Agilentb 1500,4.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT - B1500A Spectrum Analyzers,https://www.keysight.com/us/en/products/parameter-device-analyzers-curve-tracer.html,['Spectrum Analyzers'],"The Keysight B1500A semiconductor parameter analyzer is an all-in-one device characterization analyzer supporting IV, CV, pulse/dynamic IV and more.",KEYSIGHT - B1500A,https://www.keysight.com/us/en/assets/7018-03960/technical-overviews/5991-2443.pdf,"[OrderedDict([('id', 'atthxudEM2qtOPtJ2'), ('width', 478), ('height', 269), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r0fS4ij6xtCr6q8HkeYvdA/KKyuwJjgOKkpGbwSaO1aMHEWbuQOEwK0nZzeSKemms6nnMGmErxcsCI6bvf-VGqz6OYB3MLo0h5ewXSZE5v1W4gA0uspHWS1AEXHqSZJ2dY/R8yiR9jVt_QsicvKU9iCLkNt7uzFk_EyDTsXEupVMiE'), ('filename', 'B1500A.webp'), ('size', 16664), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/y2j2AApbBaBX5pjKWnnSeA/H-ll61OegQqQsyvjaDqcY_5iTh_br6Fe1qdEHgmklug7D05aofjQPMeqoMeO3UigDBjuzG_s_qOOsABwYKx2TiadtFAsfOJdiPg9zfzpWD4/Q56Ep0OuNKJ9Jq2E8uvMs-XJ1ejC03WKc9rMqpmjRmw'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YsfWAkLB8neC8YSIcxsS8w/aJXz_bwsGSq0nAUtgrkg7vBYmMFg5RlgXfHppgB5I3L5grCeqeWfrLk0aUbpokJqJxebw7dICLS4A-p64uHhYgy8waxqctEFqXHPTHzXTok/LbX6Mx9Ktpt6qjmpZzwiUIHK_RvafgcncMLL6L9Iq0U'), ('width', 478), ('height', 269)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4rH4RRm7swB5CZwLmmOBCg/ggZy_dMqxiCra57wYeCybEUkH80L9wbrXFBXvTwsz0qxlLTM8lP4RP96prb3rX8VmHBFbRexPraNsBRYdbRu4fAj0jo6l4Y14jVG7I9LIwo/hco3ZYkyQLzHeEkcc5aAA8U68rgP_PCTZsFYIx6yiaw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/products/parameter-device-analyzers-curve-tracer/precision-current-voltage-analyzers/b1500a-semiconductor-device-parameter-analyzer.html,https://github.com/qcodes/qcodes/blob/master/docs/examples/driver_examples/Qcodes%20example%20with%20Keysight%20B1500%20Parameter%20Analyzer.ipynb,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilentB1500.html,,"
",,,"#!/usr/bin/env python
# coding: utf-8

# <h1>Table of Contents<span class=""tocSkip""></span></h1>
# <div class=""toc""><ul class=""toc-item""><li><span><a href=""#Qcodes-example-with-Keysight-B1500-Semiconductor-Parameter-Analyzer"" data-toc-modified-id=""Qcodes-example-with-Keysight-B1500-Semiconductor-Parameter-Analyzer-1""><span class=""toc-item-num"">1&nbsp;&nbsp;</span>Qcodes example with Keysight B1500 Semiconductor Parameter Analyzer</a></span><ul class=""toc-item""><li><span><a href=""#Instrument-Short-info"" data-toc-modified-id=""Instrument-Short-info-1.1""><span class=""toc-item-num"">1.1&nbsp;&nbsp;</span>Instrument Short info</a></span><ul class=""toc-item""><li><span><a href=""#Physical-grouping"" data-toc-modified-id=""Physical-grouping-1.1.1""><span class=""toc-item-num"">1.1.1&nbsp;&nbsp;</span>Physical grouping</a></span></li><li><span><a href=""#Logical-grouping"" data-toc-modified-id=""Logical-grouping-1.1.2""><span class=""toc-item-num"">1.1.2&nbsp;&nbsp;</span>Logical grouping</a></span></li></ul></li><li><span><a href=""#Qcodes-driver-info"" data-toc-modified-id=""Qcodes-driver-info-1.2""><span class=""toc-item-num"">1.2&nbsp;&nbsp;</span>Qcodes driver info</a></span><ul class=""toc-item""><li><span><a href=""#Integer-Flags-and-Constants-used-in-the-driver"" data-toc-modified-id=""Integer-Flags-and-Constants-used-in-the-driver-1.2.1""><span class=""toc-item-num"">1.2.1&nbsp;&nbsp;</span>Integer Flags and Constants used in the driver</a></span></li><li><span><a href=""#High-level-interface"" data-toc-modified-id=""High-level-interface-1.2.2""><span class=""toc-item-num"">1.2.2&nbsp;&nbsp;</span>High level interface</a></span></li><li><span><a href=""#Low-level-interface"" data-toc-modified-id=""Low-level-interface-1.2.3""><span class=""toc-item-num"">1.2.3&nbsp;&nbsp;</span>Low level interface</a></span></li></ul></li><li><span><a href=""#Programming-Examples"" data-toc-modified-id=""Programming-Examples-1.3""><span class=""toc-item-num"">1.3&nbsp;&nbsp;</span>Programming Examples</a></span><ul class=""toc-item""><li><span><a href=""#Initializing-the-instrument"" data-toc-modified-id=""Initializing-the-instrument-1.3.1""><span class=""toc-item-num"">1.3.1&nbsp;&nbsp;</span>Initializing the instrument</a></span></li></ul></li><li><span><a href=""#High-Level-Interface"" data-toc-modified-id=""High-Level-Interface-1.4""><span class=""toc-item-num"">1.4&nbsp;&nbsp;</span>High Level Interface</a></span><ul class=""toc-item""><li><span><a href=""#Identifying-and-selecting-installed-modules"" data-toc-modified-id=""Identifying-and-selecting-installed-modules-1.4.1""><span class=""toc-item-num"">1.4.1&nbsp;&nbsp;</span>Identifying and selecting installed modules</a></span></li><li><span><a href=""#Enabling-/-Disabling-channels"" data-toc-modified-id=""Enabling-/-Disabling-channels-1.4.2""><span class=""toc-item-num"">1.4.2&nbsp;&nbsp;</span>Enabling / Disabling channels</a></span></li><li><span><a href=""#Perform-self-calibration"" data-toc-modified-id=""Perform-self-calibration-1.4.3""><span class=""toc-item-num"">1.4.3&nbsp;&nbsp;</span>Perform self calibration</a></span></li><li><span><a href=""#Performing-sampling-measurements"" data-toc-modified-id=""Performing-sampling-measurements-1.4.4""><span class=""toc-item-num"">1.4.4&nbsp;&nbsp;</span>Performing sampling measurements</a></span></li><li><span><a href=""#CV-Sweep"" data-toc-modified-id=""CV-Sweep-1.4.5""><span class=""toc-item-num"">1.4.5&nbsp;&nbsp;</span>CV Sweep</a></span></li><li><span><a href=""#IV-Sweep"" data-toc-modified-id=""IV-Sweep-1.4.6""><span class=""toc-item-num"">1.4.6&nbsp;&nbsp;</span>IV Sweep</a></span></li><li><span><a href=""#Performing-phase-compensation"" data-toc-modified-id=""Performing-phase-compensation-1.4.7""><span class=""toc-item-num"">1.4.7&nbsp;&nbsp;</span>Performing phase compensation</a></span></li><li><span><a href=""#Performing-Open/Short/Load-correction"" data-toc-modified-id=""Performing-Open/Short/Load-correction-1.4.8""><span class=""toc-item-num"">1.4.8&nbsp;&nbsp;</span>Performing Open/Short/Load correction</a></span><ul class=""toc-item""><li><span><a href=""#Set-and-get-reference-values"" data-toc-modified-id=""Set-and-get-reference-values-1.4.8.1""><span class=""toc-item-num"">1.4.8.1&nbsp;&nbsp;</span>Set and get reference values</a></span></li><li><span><a href=""#Add-CMU-output-frequency-to-the-list-for-correction"" data-toc-modified-id=""Add-CMU-output-frequency-to-the-list-for-correction-1.4.8.2""><span class=""toc-item-num"">1.4.8.2&nbsp;&nbsp;</span>Add CMU output frequency to the list for correction</a></span></li><li><span><a href=""#Clear-CMU-output-frequency-list"" data-toc-modified-id=""Clear-CMU-output-frequency-list-1.4.8.3""><span class=""toc-item-num"">1.4.8.3&nbsp;&nbsp;</span>Clear CMU output frequency list</a></span></li><li><span><a href=""#Query-CMU-output-frequency-list"" data-toc-modified-id=""Query-CMU-output-frequency-list-1.4.8.4""><span class=""toc-item-num"">1.4.8.4&nbsp;&nbsp;</span>Query CMU output frequency list</a></span></li><li><span><a href=""#Open/Short/Load-Correction"" data-toc-modified-id=""Open/Short/Load-Correction-1.4.8.5""><span class=""toc-item-num"">1.4.8.5&nbsp;&nbsp;</span>Open/Short/Load Correction</a></span></li></ul></li><li><span><a href=""#SMU-sourcing-and-measuring"" data-toc-modified-id=""SMU-sourcing-and-measuring-1.4.9""><span class=""toc-item-num"">1.4.9&nbsp;&nbsp;</span>SMU sourcing and measuring</a></span></li><li><span><a href=""#Setting-up-ADCs-to-NPLC-mode"" data-toc-modified-id=""Setting-up-ADCs-to-NPLC-mode-1.4.10""><span class=""toc-item-num"">1.4.10&nbsp;&nbsp;</span>Setting up ADCs to NPLC mode</a></span></li></ul></li><li><span><a href=""#Error-Message"" data-toc-modified-id=""Error-Message-1.5""><span class=""toc-item-num"">1.5&nbsp;&nbsp;</span>Error Message</a></span></li><li><span><a href=""#Low-Level-Interface"" data-toc-modified-id=""Low-Level-Interface-1.6""><span class=""toc-item-num"">1.6&nbsp;&nbsp;</span>Low Level Interface</a></span></li></ul></li></ul></div>

# # Qcodes example with Keysight B1500 Semiconductor Parameter Analyzer

# ## Instrument Short info
# Here a short introduction on how the B1500 measurement system is composed is given. For a detailed overview it is strongly recommended to refer to the *B1500 Programming Guide* and also the *Parametric Measurement Handbook* by Keysight.
# 
# ### Physical grouping
# The Keysight B1500 Semiconductor Parameter Analyzer consists of a *Mainframe* and can be equipped with various instrument *Modules*. 10 *Slots* are available in which up to 10 *modules* can be installed (some *modules* occupy two *slots*). Each *module* can have one or two *channels*.
# 
# ### Logical grouping
# The measurements are typically done in one of the 20 measurement modes. The modes can be roughly subdivided into 
#   - Spot measurements
#       - **High Speed Spot Measurements**
#   - Pulsed Spot measurement
#   - Sweep Measurements
#   - Search Measurements
# 
# The **High Speed Spot (HSS)** Mode is essentually just a fancy way of saying to take readings and forcing constant voltages/currents. The *HSS* commands work at any time, independent of the currenttly selected Measurment Mode.
# 
# With the exception of the *High Speed Spot Measurement Mode*, the other modes have to be activated and configured by the user.

# ## Qcodes driver info
# As can be seen already from the instrument short info, the instrument is very versatile, but also very complex. Hence the driver will eventually consist of two layers:
#   - The Low Level interface allows one to utilize all functions of the driver by offering a thin wrapper around the FLEX command set that the B1500 understands. 
#   - A Higher Level interface that provides a convenient access to the more frequently used features. Not all features are available via the high level interface.
# 
# The two driver levels can be used at the same time, so even if some functionality is not yet implemented in the high-level interface, the user can send a corresponding low-level command.
# 
# ### Integer Flags and Constants used in the driver
# Both the high-level and the low-level interface use integer constants in many commands. For user convienience, the `qcodes.instrument_drivers.Keysight.keysightb1500.constants` provides more descriptive Python Enums for these constants. Although bare integer values can still be used, it is highly recommended to use the enumerations in order to avoid mistakes.
# 
# ### High level interface
# The high level exposes instrument functionality via QCodes Parameters and Python methods on the mainframe object and the individual instrument module objects. For example, *High Speed Spot* Measurement commands for forcing constant voltages/currents or for taking simple readings are implemented.
# 
# ### Low level interface
# The Low Level interface (`MessageBuilder` class) provides a wrapper function for each FLEX command. From the low-level, the full functionality of the instrument can be controlled.
# 
# The `MessageBuilder` assembles a message string which later can be sent to the instrument using the low level `write` and `ask` methods. One can also use the `MessageBuilder` to write FLEX complex measurement routines that are stored in the B1500 and can be executed at a later point. This can be done to enable fast execution.

# ## Programming Examples

# ### Initializing the instrument

# In[1]:


from IPython.display import Markdown, display
from matplotlib import pyplot as plt
from pyvisa.errors import VisaIOError

import qcodes as qc
from qcodes.dataset import (
    Measurement,
    initialise_database,
    load_or_create_experiment,
    plot_dataset,
)
from qcodes.instrument_drivers.Keysight import KeysightB1500
from qcodes.instrument_drivers.Keysight.keysightb1500 import MessageBuilder, constants


# In[2]:


station = qc.Station() # Create a station to hold all the instruments


# In[3]:


#Note: If there is no physical instrument connected 
#the following code will try to load a simulated instrument

try:
    #TODO change that address according to your setup
    b1500 = KeysightB1500('spa', address='GPIB21::17::INSTR')
    display(Markdown(""**Note: using physical instrument.**""))
except (ValueError, VisaIOError):
    # Either there is no VISA lib installed or there was no real instrument found at the
    # specified address => use simulated instrument
    b1500 = KeysightB1500('SPA',
                          address='GPIB::1::INSTR',
                          pyvisa_sim_file=""keysight_b1500.yaml"")
    display(Markdown(""**Note: using simulated instrument. Functionality will be limited.**""))


# In[4]:


station.add_component(b1500)


# ## High Level Interface
# 
# Here is an example of using high-level interface.
# 

# ### Identifying and selecting installed modules
# As mentioned above, the B1500 is a modular instrument, and contains multiple cards. When initializing the driver, the driver requests the installed modules from the B1500 and exposes them to the user via multiple ways.
# 
# The first way to address a certain module is e.g. as follows:

# In[ ]:


b1500.smu1 # first SMU in the system
b1500.cmu1 # first CMU in the system
b1500.smu2 # second SMU in the system


# In[ ]:


b1500.cmu1.phase_compensation_mode()


# The naming scheme is - `b1500.<instrument class as lower case><number>`, where number is `1` for the first instrument in its class, `2` for the second instrument in its class and so on. (*Not the channel or slot number!*)
# 
# Next to this direct access - which is simple and good for direct user interaction - the modules are also exposed via multiple data structures through which they can be adressed:
#   - by slot number
#   - by module kind (such as SMU, or CMU)
#   - by channel number
# 
# This can be more convenient for programmatic selection of the modules.

# Instrument modules are installed in slots (numbered 1-11) and can be selected by the slot number:

# In[ ]:


b1500.by_slot


# All modules are also grouped by module kind (see `constants.ModuleKind` for list of known kinds of modules):

# In[ ]:


b1500.by_kind


# For example, let's list all SMU modules:

# In[ ]:


b1500.by_kind['SMU']


# Lastly, there is dictionary of all module channels:

# In[ ]:


# For the simulation driver:
# Note how the B1530A module has two channels.
# The first channel number is the same as the slot number (6).
# The second channel has a `02` appended to the channel number.
b1500.by_channel


# **Note: For instruments with only one channel, channel number is the same as the slot number. However there are instruments with 2 channels per card. For these instruments the second channel number will differ from the slot number.**
# 
# **Note for the simulated instrument: The simulation driver will list a B1530A module with 2 channels as example.**
# 
# In general, the slot- and channel numbers can be passed as integers. However (especially in the case of the channel numbers for multi-channel instruments) it is recommended to use the Python enums defined in `qcodes.instrument_drivers.Keysight.keysightb1500.constants`:

# In[ ]:


# Selecting a module by channel number using the Enum
m1 = b1500.by_channel[constants.ChNr.SLOT_01_CH1]

# Without enum
m2 = b1500.by_channel[1]

# And we assert that we selected the same module:
assert m1 is m2


# ### Enabling / Disabling channels
# 
# Before sourcing or doing a measurement, the respective channel has to be enabled. There are two ways to enable/disable a channel:
#   - By directly addressing the module
#   - By addressing the mainframe and specifying which channel(s) to be enabled
# 
# The second method is useful if multiple channels shall be enabled, or for programmatic en-/disabling of channels. It also allows to en-/disable all channels with one call.

# In[ ]:


# Direct addressing the module
b1500.smu1.enable_outputs()
b1500.smu1.disable_outputs()


# In[ ]:


# Enabling via the mainframe

# enable one channel
b1500.enable_channels([1])

# enable multiple channels
b1500.enable_channels([1, 2])

# disable multiple channels
b1500.disable_channels([1, 2]) 

# disable all channels
b1500.disable_channels()


# ### Perform self calibration
# 
# Calibration takes about 30 seconds (the visa timeout for it is controlled by `b1500.calibration_time_out` attribute).

# In[ ]:


b1500.self_calibration()


# ### Performing sampling measurements

# This section outlines steps to perform sampling measurement. 

# Set a sample rate and number of samples. 

# In[ ]:


# Number of spot measurments made per second and stored in a buffer. 
sample_rate = 0.02
# Total number of spot measurements. 
nsamples = 100


# Assign timing parameters to SMU. 

# In[ ]:


b1500.smu1.timing_parameters(0, sample_rate, nsamples)


# Autozero is generally disabled for sampling measurement. 

# In[ ]:


b1500.autozero_enabled(False)


# Set SMU to sampling mode. 

# In[ ]:


b1500.smu1.measurement_mode(constants.MM.Mode.SAMPLING)


# SMU is configured with by assigning voltage output range, input output range and compliance. While forcing voltage, current should be the compliance and vice versa.
# 

# In[ ]:


b1500.smu1.source_config(output_range=constants.VOutputRange.AUTO,
                       compliance=1e-7, 
                       compl_polarity=None, 
                       min_compliance_range=constants.IOutputRange.AUTO
                      )


# Set the averaging to 1 otherwise the measurement takes 10 times more time. 

# In[ ]:


b1500.use_nplc_for_high_speed_adc(n=1)


# Set the voltage

# In[ ]:


b1500.smu1.enable_outputs()
b1500.smu1.voltage(1e-6)


# We are now ready to start the sampling measurement. We first initialize the database and create-new/load-old experiment. Then we register our dependent and independent parameters and start the measurement. 
# 
# **Note** that the default values of label and units are not defined for the parameter sampling measurement trace. Hence we first set them according to what is being measured: in this case we will measure current in A. It is important to set the label and the unit before the measurement in order to have this information when looking at the acquired data, for example when plotting it with `plot_dataset` as shown below.

# In[ ]:


b1500.smu1.sampling_measurement_trace.label = 'Current'
b1500.smu1.sampling_measurement_trace.unit = 'A'
# Automatic assignment of the label and unit based on
# the settings of the instrument can be implemented
# upon request.


# In[ ]:


initialise_database()
exp = load_or_create_experiment(experiment_name='dummy_sampling_measurement',
                          sample_name=""no sample"")
meas  = Measurement(exp=exp)
meas.register_parameter(b1500.smu1.sampling_measurement_trace)

with meas.run() as datasaver:
    datasaver.add_result((b1500.smu1.sampling_measurement_trace, b1500.smu1.sampling_measurement_trace.get()))


# Thanks to the `label` and `unit` set above for the `sampling_measurement_trace` parameter, the `plot_dataset` function is able to produce a plot with a useful label for the vertical axis, see below:

# In[ ]:


plot_dataset(datasaver.dataset)


# Check compliance: For the values which are compliant the output is one and for others it is zero. A quick to visualize of your measurements are compliant is to plot the compliance data and look if any value of zero.

# In[ ]:


data_compliance = b1500.smu1.sampling_measurement_trace.compliance()


# In[ ]:


plt.plot(data_compliance)
plt.xlabel('Measurements')
_ = plt.ylabel('Compliance status')


# The channel number of the measured data can be obtained in the following way. 

# In[ ]:


data_channel = b1500.smu1.sampling_measurement_trace.data.channel
data_channel[:5]


# If you want to know the type of the measured data, for ex 'I' or 'V' the following method can be used.

# In[ ]:


data_type = b1500.smu1.sampling_measurement_trace.data.type
data_type[:5]


# The measurement status can be obtained using:

# In[ ]:


data_status = b1500.smu1.sampling_measurement_trace.data.status
data_status[:5]


# The variable 'data_status' is a list of strings of measurement status for each data point. One can look at the meaning of the statuses in `constants.MeasurementStatus` class. It enlists meaning of all possible measurement status. For example: in case the measurement status is 'C' its meaning can be found as following.

# In[ ]:


constants.MeasurementStatus.N


# In[ ]:


constants.MeasurementStatus.C


# ### CV Sweep

# MFCMU has two modes of measurement. The first is spot measurement and this here is sweep measurement. As the name suggest sweep measurement execute the measurement once for the whole list of voltages and saves the output in the buffer untill measurment is completed.
# 
# The function below sets up properly the parameters to run the sweep measurements. Look at the docstring of ``setup_staircase_cv`` to know more about each argument of the function. 

# In[13]:


b1500.cmu1.enable_outputs()


# In[14]:


b1500.cmu1.setup_staircase_cv(
    v_start=0,
    v_end=1,
    n_steps=201,
    freq=1e3,
    ac_rms=250e-3,
    post_sweep_voltage_condition=constants.WMDCV.Post.STOP,
    adc_mode=constants.ACT.Mode.PLC,
    adc_coef=5,
    imp_model=constants.IMP.MeasurementMode.Cp_D,
    ranging_mode=constants.RangingMode.AUTO,
    fixed_range_val=None,
    hold_delay=0,
    delay=0,
    step_delay=225e-3,
    trigger_delay=0,
    measure_delay=0,
    abort_enabled=constants.Abort.ENABLED,
    sweep_mode=constants.SweepMode.LINEAR,
    volt_monitor=False)


# If the setup function does not output any error then we are ready for the measurement. 

# In[15]:


initialise_database()
exp = load_or_create_experiment(
    experiment_name='dummy_capacitance_measurement',
    sample_name=""no sample""
)
meas = Measurement(exp=exp)

meas.register_parameter(b1500.cmu1.run_sweep)

with meas.run() as datasaver:
    res = b1500.cmu1.run_sweep() 
    datasaver.add_result((b1500.cmu1.run_sweep,res))


# The ouput of the ``run_sweep`` is a primary parameter (Capacitance) and a secondary parameter (Dissipation). The type of primary and secondary parameter  depends on the impedance model set in the ``setup_staircase_cv`` function (or via the corresponding ``impedance_model`` parameter). The setpoints of both the parameters are the same voltage values as defined by ``setup_staircase_cv`` (behind the scenes, those values are available in the ``cv_sweep_voltages`` parameter). 

# In[16]:


plot_dataset(datasaver.dataset)


# In[17]:


b1500.cmu1.run_sweep.status_summary()


# ### IV Sweep

# This section explains the IV Staircase sweep measurements. 

# Enable the channels. 

# In[5]:


b1500.smu1.enable_outputs()
b1500.smu2.enable_outputs()


# In[6]:


# Always good to do for the safety of the measured sample
b1500.smu2.voltage(0)
b1500.smu1.voltage(0)


# Setting up smu1 and smu2 for running the staircase sweep. One of the smu's is used for sweep. Both the smu's are used for acquiring data. It is possible to acquire data with more SMUs, that depends on the measurement mode (see below), so refer to the instrument manual for information on how many 'channels' can be measured with which measurement mode. In the setup below, smu1 is used to sweep over the sweep voltages -3 to 3 in 201 steps.

# In[7]:


b1500.smu1.setup_staircase_sweep(
    v_src_range = constants.VOutputRange.AUTO,
    v_start = 3,
    v_end = -3,
    n_steps = 201,
    av_coef = 5,
    step_delay = 0.225,
    abort_enabled = constants.Abort.ENABLED,
    i_meas_range = constants.IMeasRange.FIX_10nA,
    i_comp = 1e-8,
    sweep_mode = constants.SweepMode.LINEAR,
    # and there are more arguments with default values
    # that might need to be changed for your
    # particular measurement situation
)


# `smu2` is kept at constant voltage and at different compliance and measurement range settings.

# In[8]:


b1500.smu2.voltage(10e-3)
b1500.smu2.enable_filter(True)
b1500.smu2.measurement_operation_mode(constants.CMM.Mode.COMPLIANCE_SIDE)
b1500.smu2.current_measurement_range(constants.IMeasRange.FIX_10uA)


# `b1500.set_measurement_mode` is used to define measurement mode and the channels from which data is extracted from. Here, channels correspond to SMU1 and SMU2 respectively - the SMU which is setup to run the sweep needs to go **FIRST**.

# In[9]:


b1500.set_measurement_mode(
    mode=constants.MM.Mode.STAIRCASE_SWEEP,
    channels=(b1500.smu1.channels[0], b1500.smu2.channels[0])
)
# SMUs have only one channel so using `channels[0]` is enough
# This might be improved in the future for better clarity and user convenience.


# `run_iv_staircase_sweep` is used to run the sweep

# In[10]:


initialise_database()
exp = load_or_create_experiment(
    experiment_name='dummy_iv_sweep_measurement',
    sample_name=""no sample""
)
meas = Measurement(exp=exp)

# As per user needs, names and labels of the parameters inside the 
# MultiParameter can be adjusted to reflect what is actually being
# measured using the convenient `set_names_labels_and_units` method.
# The setpoint name/label/unit (the independent sweep 'parameter')
# can be additionally customized using `set_setpoint_name_label_and_unit`
# method.
# Below is an example of using `set_names_labels_and_units`:
b1500.run_iv_staircase_sweep.set_names_labels_and_units(
    names=('gate_current', 'source_drain_current'),
    labels=('Gate current', 'Source-drain current'),
)
# The number of names (and labels) MUST be the same as the number of channels,
# and the order of the names should match the order of channels, as passed to
# `set_measurement_mode` method.

meas.register_parameter(b1500.run_iv_staircase_sweep)

with meas.run() as datasaver:
    res = b1500.run_iv_staircase_sweep() 
    datasaver.add_result((b1500.run_iv_staircase_sweep, res))

# In production code, remeber to revert the names/labels of the
# run_iv_staircase_sweep MultiParameter in order to avoid confusion.


# In[11]:


plot_dataset(datasaver.dataset)


# In[12]:


b1500.run_iv_staircase_sweep.status_summary()


# ### Performing phase compensation

# The phase compensation is performed to adjust the phase zero.
# 
# One must take care of two things before executing the phase compensation. First, make sure that all the channel outputs are enabled else instrument throws an error. 

# In[ ]:


b1500.run_iv_staircase_sweep.measurement_status()


# Second, the phase compensation mode must be set to manual.  

# In[ ]:


b1500.cmu1.phase_compensation_mode(constants.ADJ.Mode.MANUAL)


# Now the phase compensation can be performed as follows. This operation takes about 30 seconds (the visa timeout for this operation is set via `b1500.cmu1.phase_compensation_timeout` attribute).

# In[ ]:


b1500.cmu1.phase_compensation()


# Note that `phase_compensation` method also supports loading data of previously performed phase compensation. To use that, explicitly pass the operation mode argument:

# In[ ]:


b1500.cmu1.phase_compensation(constants.ADJQuery.Mode.USE_LAST)


# ### Performing Open/Short/Load correction

# #### Set and get reference values

# Use the following method to set the calibration values or reference values of the open/short/load standard. Here, we are using open correction with Cp-G mode. The primary reference value, which is the value for Cp (in F), is set to 0.00001, and the secondary reference value, which is the value of G (in S), is set to 0.00002. These values are completely arbitrary, so please change them according to your experiments.

# In[ ]:


b1500.cmu1.correction.set_reference_values(corr=constants.CalibrationType.OPEN,
                                           mode=constants.DCORR.Mode.Cp_G,
                                           primary=0.00001,
                                           secondary=0.00002)


# You can retrieve the values you have set for calibration or the reference values of the open/short/load standard in the following way:

# In[ ]:


b1500.cmu1.correction.get_reference_values(corr=constants.CalibrationType.OPEN)


# #### Add CMU output frequency to the list for correction

# You can add to the list of frequencies supported by the instrument to be used for the data correction. The frequency value can be given with a certain resolution as per Table 4-18 in the programming manual.

# In[ ]:


b1500.cmu1.correction.frequency_list.add(1000)


# #### Clear CMU output frequency list

# Clear the frequency list for the correction data measurement using the following methods. Correction data will be invalid after calls to these methods, so you will have to again perform the open/short/load correction.
# 
# There are two modes in which you can clear the frequency list. First is clearing the list of frequencies:

# In[ ]:


b1500.cmu1.correction.frequency_list.clear()


# Second is clearing the list of frequencies and also setting it to a default list of frequencies (for the list of default frequencies, refer to the documentation of the ``CLCORR`` command in the programming manual):

# In[ ]:


b1500.cmu1.correction.frequency_list.clear_and_set_default()


# #### Query CMU output frequency list
# 
# It is possible to query the total number of frequencies in the list:

# In[ ]:


b1500.cmu1.correction.frequency_list.query()


# It is also possible to query the values of specific frequencies using the same method by specifying an index within the frequency list:

# In[ ]:


b1500.cmu1.correction.frequency_list.query(2)


# #### Open/Short/Load Correction

# As per description in the programming guide, we first set the oscillator level of the CMU output signal.

# In[ ]:


# Set oscillator level
b1500.cmu1.voltage_ac(30e-3)


# To perform open/short/load correction connect the open/short/load standard and execute the following command to perform and enable the correction.

# In[ ]:


b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.OPEN)
#b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.SHORT)
#b1500.cmu1.correction.perform_and_enable(corr=constants.CalibrationType.LOAD)


# In case you would only like to perform the correction but not enable it, you can use separate methods `perform` and `enable`.

# To check whether a correction is enabled, use the following method:

# In[ ]:


b1500.cmu1.correction.is_enabled(corr=constants.CalibrationType.OPEN)


# To disable a performed correction, use the following method:

# In[ ]:


b1500.cmu1.correction.disable(corr=constants.CalibrationType.OPEN)


# ### SMU sourcing and measuring
# The simplest measurement one can do with the B1500 are *High Speed Spot Measurements*. They work independent of the selected *Measurement Mode*.
# 
# The `voltage` and `current` Qcodes Parameters that the SMU High Level driver exposes will execute *High Speed Spot* measurements. Additionally, there are functions that let the user specify the output/measure ranges, and compliance limits.
# 
# To source a voltage/current do the following:
#   1. Configure source range, and (optionally) compliance settings
#   2. Enable the channel
#   3. Force the desired voltage
#   4. (optionally) Disable the channel
# 
# **Note: The source settings (Step 1) are persistent until changed again. So for sucessive measurements the configuration can be omitted.**

# In[ ]:


b1500.smu1.enable_outputs()

b1500.smu1.source_config(output_range=constants.VOutputRange.AUTO,
                         compliance=0.1)

b1500.smu1.voltage(1.5)


# To measure do the following:
#   1. Configure the voltage or/and current measure ranges
#   2. Enable the channel (if not yet enabled)
#   3. Do the measurement
#   4. (optionally) Disable the channel
# 
# **Note: The measure settings (Step 1) are persistent until changed again. So for sucessive measurements the configuration can be omitted.**

# In[ ]:


b1500.smu1.i_measure_range_config(i_measure_range=constants.IMeasRange.MIN_100mA)
b1500.smu1.v_measure_range_config(v_measure_range=constants.VMeasRange.FIX_2V)

b1500.smu1.enable_outputs()

cur = b1500.smu1.current()
vol = b1500.smu1.voltage()

b1500.smu1.disable_outputs()


# ### Setting up ADCs to NPLC mode
# 
# Both the mainframe driver and SMU driver implement convenience methods for controlling integration time of the *High Speed Spot* measurement, which allow setting ADC type, and setting the frequenty used NPLC mode.

# Use the following methods on the mainframe instance to set up the ADCs to NPLC mode:

# In[ ]:


# Set the high-speed ADC to NPLC mode,
# and optionally specify the number of PLCs as an arugment
# (refer to the docstring and the user manual for more information)
b1500.use_nplc_for_high_speed_adc(n=1)

# Set the high-resolution ADC to NPLC mode,
# and optionally specify the number of PLCs as an arugment
# (refer to the docstring and the user manual for more information)
b1500.use_nplc_for_high_resolution_adc(n=5)


# And then use the following methods on the SMU instances to use particular ADC for the particular SMU:

# In[ ]:


# Use high-speed ADC 
# with the settings defined above
# for the SMU 1
b1500.smu1.use_high_speed_adc()

# Use high-resoultion ADC 
# with the settings defined above
# for the SMU 2
b1500.smu2.use_high_resolution_adc()


# ## Error Message
# 
# The error messages from the instrument can be read using the following method. This method reads one error code from the head of the error queue and removes that code from the queue. The read error is returned as the response of this method.

# In[ ]:


b1500.error_message()


# Here, the response message contains an error number and an error message. In some cases the error message may also contain the additional information such as the slot number. They are separated by a semicolon (;). For example, if the error 305 occurs on the slot 1, this method returns the following response. 305,""Excess current in HPSMU.; SLOT1"" 
# 
# If no error occurred, this command returns 0,""No Error"".

# ## Low Level Interface
# 
# The Low Level Interface provides a wrapper around the FLEX command set. Multiple commands can be assembled in a sequence. Finally, the command sequence is compiled into a command string, which then can be sent to the instrument. 
# 
# Only some very minimal checks are done to the command string. For example some commands have to be the *last* command in a sequence of commands because the fill the output queue. Adding additional commands after that is not allowed.
# 
# As an example, a ""voltage source + current measurement"" is done, similar as was done above with the high level interface.

# In[ ]:


mb = MessageBuilder()

mb.cn(channels=[1])
mb.dv(chnum=1,
      voltage=1.5,
      v_range=constants.VOutputRange.AUTO,
      i_comp=0.1)
mb.ti(chnum=1,
      i_range=constants.IMeasRange.FIX_100uA)
mb.cl(channels=[1])

# Compiles the sequence of FLEX commands into a message string.
message_string = mb.message


# In[ ]:


print(message_string)


# The message string can be sent to the instrument. To parse the response of this spot measurement command, use the `KeysightB1500.parse_spot_measurement_response` static method.
# 
# `parse_spot_measurement_response` will return a `dict` that contains the measurement value together with the measurement channel, info on what was measured (current, voltage, capacitance, ...), and status information. For a detailed description, see the user manual.

# In[ ]:


response = b1500.ask(message_string)

KeysightB1500.parse_spot_measurement_response(response)


# The `MessageBuilder` object can be cleared, which allows the object to be reused to generate a new message string.

# In[ ]:


mb.clear_message_queue()
# This will produce empty string because MessageBuilder buffer was cleared
mb.message


# The `MessageBuilder` provides a *fluent* interface, which means every call on the `MessageBuilder` object always returns the object itself, with the exeption of `MessageBuilder.message` which **returns the compiled message string**.
# 
# This means that the same message as in the first example could've been assembled like this:

# In[ ]:


response = b1500.ask(
    MessageBuilder()
    .cn(channels=[1])
    .dv(
        chnum=1,
        voltage=1.5,
        v_range=constants.VOutputRange.AUTO,
        i_comp=0.1,
    )
    .ti(chnum=1, i_range=constants.IMeasRange.FIX_100uA)
    .cl(channels=[1])
    .message
)

KeysightB1500.parse_spot_measurement_response(response)


# In[ ]:




"
241,5420.0,USA,"The HP 3437A is a microprocessor controlled 3 and 1/2 digit, successive approximation voltmeter, capable of sampling voltages at rates up to 5,700 samples per second.",HP 3437 A,170.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a HP 3437A Multimeters,https://en.wikipedia.org/wiki/Voltmeter,['Multimeters'],A voltmeter is an instrument used for measuring electric potential difference between two points in an electric circuit. It is connected in parallel.,HP 3437A,Not available,"[OrderedDict([('id', 'attVdKzFaHB9VYgQa'), ('width', 1024), ('height', 549), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/65yjMFFbowTqK7pwF8ep7w/dbGZ2NOz70N1KGUVtliVUWRSSsdr9QrQ26eo3INfyOanQ2zS0kn3Toob0iFQm_cOQK38K3i-DUdYzm6PEGWHNnhKblGF_MPtm2ml3cjyZXFkZxf8lhFcWoCVoq8Bn1cS/f5_UImo9KnUhW_8aTnAg9SVHPmjIdkYBMFOMOEuU-ic'), ('filename', 'HP3437A-FrontPanelOffAng10-1024x549.jpg'), ('size', 99233), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9p3U9ZpuY9ZiraSAH8FqdQ/MN9meJhoB_V3mC4vX-GKoCSvuJtYfy6OLDPwv0Xjz6eLwtRNlukiHf7r8Pp2bj4hq9vh1LzN8n1H7mbwYAiCzQ/dtsqbWDPdA_DLAm0tYpjxGDq9sniwAgQkpv4osj1ZiY'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/llK23n0bNrJTVgPBT909Ww/oRemSMELAje07pwaGcyJ2BI_k-CbpwdXAqZTy5GpQRSHK6c77K_fCddQjTpxvXE_lp5ssXveEQCbOonyuldviw/dJACG8044kvpshr2a785BJt_HwSPnlXJBL9-KC_1K3g'), ('width', 955), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qClqNjtZAj8kPOwLqPoWHw/Xdtk3Z_Q0FsRW0_MulMRX770Z6fLeqIZl8lFqUiq1tjEVugmxGWS2PNQTQnV-w1MuJcOHdS8hgV2aLtjtj-Lyg/uB0vMXSVsWORKCbZlK55VseCNq9hdnr9x03EKEKBu6k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.barbouri.com/2019/10/19/hewlett-packard-3437a-system-voltmeter/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp3437A.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp3437A.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import ctypes
import logging
import math
from enum import IntFlag
import numpy as np
from pymeasure.instruments.hp.hplegacyinstrument import HPLegacyInstrument, StatusBitsBase

from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

c_uint8 = ctypes.c_uint8
c_uint16 = ctypes.c_uint16
c_uint32 = ctypes.c_uint32


class Status(StatusBitsBase):
    """"""
    A bitfield structure containing the assignments for the status decoding
    """"""
    _pack_ = 1
    _fields_ = [
        # Byte 0: Function, Range and Number of Digits
        (""Format"", c_uint8, 1),  # Bit 7
        (""SRQ"", c_uint8, 3),  # bit 4..6
        (""Trigger"", c_uint8, 2),  # bit 2..3
        (""Range"", c_uint8, 2),  # bit 0..1
        # Byte 1 & 2:
        (""Number"", c_uint16, 16),
        # Byte 1:
        # (""NRDGS_MSD"", c_uint8, 4),
        # (""NRDGS_2SD"", c_uint8, 4),
        # Byte 2:
        # (""NRDGS_3SD"", c_uint8, 4),
        # (""NRDGS_LSD"", c_uint8, 4),
        (""not_used"", c_uint8, 4),
        (""Delay"", c_uint32, 28),
        # Byte 3:
        # (""Not_Used"", c_uint8, 4),
        # (""Delay_MSD"", c_uint8, 4),
        # Byte 4:
        # (""Delay_2SD"", c_uint8, 4),
        # (""Delay_3SD"", c_uint8, 4),
        # Byte 5:
        # (""Delay_4SD"", c_uint8, 4),
        # (""Delay_5SD"", c_uint8, 4),
        # Byte 6:
        # (""Delay_6SD"", c_uint8, 4),
        # (""Delay_LSD"", c_uint8, 4),
        ]

    @staticmethod
    def _decode_range(r):
        """"""Method to decode current range

        :param range_undecoded: int to be decoded
        :return cur_range: float value repesenting the active measurment range
        :rtype cur_range: float

        """"""
        # range decoding
        # (cf table 3-2, page 3-5 of the manual, HPAK document 9018-05946)
        decode_map = {
           0: math.nan,
           1: 0.1,
           2: 10.0,
           3: 1.0,
        }
        return decode_map[r]

    @staticmethod
    def _decode_trigger(t):
        """"""Method to decode trigger mode

        :param status_bytes: list of bytes to be decoded
        :return trigger_mode: string with the current trigger mode
        :rtype trigger_mode: str

        """"""
        decode_map = {
           0: ""INVALID"",
           1: ""internal"",
           2: ""external"",
           3: ""hold/manual""
        }
        return decode_map[t]

    _get_process_ = {
        ""Number"": StatusBitsBase._convert_from_bcd,
        ""Delay"": StatusBitsBase._convert_from_bcd,
        ""Range"": _decode_range,
        ""Trigger"": _decode_trigger,
        }

    def __str__(self):
        """"""
        Returns a pretty formatted string showing the status of the instrument
        """"""
        ret_str = """"
        for field in self._fields_:
            ret_str = ret_str + f""{field[0]}: {getattr(self, field[0])}\n""

        return ret_str


class PackedBits(ctypes.BigEndianStructure):
    """"""
    A bitfield structure containing the assignments for the data transfer in packed/binary mode
    """"""
    _pack_ = 1
    _fields_ = [
        (""range"", c_uint8, 2),  # bit 0..1
        (""sign_bit"", c_uint8, 1),
        (""MSD"", c_uint8, 1),
        (""SSD"", c_uint8, 4),
        (""TSD"", c_uint8, 4),
        (""LSD"", c_uint8, 4), ]

    def __float__(self):
        """"""
        Return a float value from the packed data of the HP3437A

        """"""
        # range decoding
        # (cf table 3-2, page 3-5 of the manual, HPAK document 9018-05946)
        decode_map = {
           1: 0.1,
           2: 10.0,
           3: 1.0,
        }
        cur_range = decode_map[self.range]

        signbit = 1
        if self.sign_bit == 0:
            signbit = -1

        return (
            cur_range * signbit * (
                self.MSD + self.SSD / 10 + self.TSD / 100 + self.LSD / 1000
            )
        )


class HP3437A(HPLegacyInstrument):
    """"""Represents the Hewlett Packard 3737A system voltmeter
    and provides a high-level interface for interacting
    with the instrument.
    """"""
    status_desc = Status
    pb_desc = PackedBits

    def __init__(self, adapter, name=""Hewlett-Packard HP3437A"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs,
        )

    # Definitions for different specifics of this instrument
    RANGE = {
        1e-1: ""R1"",
        1: ""R2"",
        10: ""R3"",
    }

    TRIGGERS = {
        ""internal"": ""T1"",
        ""external"": ""T2"",
        ""hold"": ""T3"",
        ""manual"": ""T3"",
    }

    class SRQ(IntFlag):
        """"""Enum element for SRQ mask bit decoding""""""

        DATA_READY = 4
        IGNORE_TRIGGER = 2
        INVALID_PROGRAM = 1

    def _unpack_data(self, data):
        """"""
        Method to unpack the data from the returned bytes in packed mode

        :param data: list of bytes to be decoded
        :return ret_data: float value

        """"""
        ret_data = PackedBits.from_buffer(bytearray(data))
        return float(ret_data)

    # commands overwriting the base implementaiton
    def read_data(self):
        """"""
        Reads measured data from instrument, returns a np.array.

        (This function also takes care of unpacking the data if required)

        :return data: np.array containing the data
        """"""
        # Adjusting the timeout to match the number of counts and the delay

        current_timeout = self.adapter.connection.timeout
        time_needed = self.number_readings * self.delay
        new_timeout = min(1e6, time_needed * 3 * 1000)  # safety factor 3
        if new_timeout > current_timeout:
            if new_timeout >= 1e6:
                # Disables timeout if measurement would take more then 1000 sec
                log.info(""HP3437A: timeout deactivated"")
            self.adapter.connection.timeout = new_timeout
            log.info(""HP3437A: timeout changed to %g"", new_timeout)
        read_data = self.read_bytes(-1)
        # check if data is in packed format format
        if self.talk_ascii:
            return_value = np.array(read_data[:-2].decode(""ASCII"").split("",""),
                                    dtype=float)
        else:
            processed_data = []
            for i in range(0, len(read_data), 2):
                processed_data.append(self._unpack_data(read_data[i : i + 2]))  # noqa: E203
            return_value = np.array(processed_data)
        self.adapter.connection.timeout = current_timeout
        return return_value

    # commands/properties for instrument control
    def check_errors(self):
        """"""
        As this instrument does not have a error indication bit,
        this function alwyas returns an empty list.

        """"""
        return []

    @property
    def talk_ascii(self):
        """"""
        A boolean property, True if the instrument is set to ASCII-based communication.
        This property can be set.
        """"""
        return bool(self.status.Format)

    @talk_ascii.setter
    def talk_ascii(self, value):
        if value:
            self.write(""F1"")
        else:
            self.write(""F2"")

    @property
    def delay(self):
        """"""Return the value (float) for the delay between two measurements,
        this property can be set,

        valid range: 100ns - 0.999999s

        """"""
        return self.status.Delay * 1e-7

    @delay.setter
    def delay(self, value):
        delay_str = (
            ""D."" + format(strict_range(value, [0, 0.9999999]) * 10e6, ""07.0f"") + ""S""
        )
        self.write(delay_str)

    @property
    def number_readings(self):
        """"""Return value (int) for the number of consecutive measurements,
        this property can be set,
        valid range: 0 - 9999

        """"""
        return self.status.Number

    @number_readings.setter
    def number_readings(self, value):
        number_str = ""N"" + str(strict_range(value, [0, 9999])) + ""S""
        self.write(number_str)

    @property
    def range(self):
        """"""Return the current measurement voltage range.

        This property can be set, valid values: 0.1, 1, 10 (V).

        .. Note::

            This instrument does not have autorange capability.

            Overrange will be in indicated as 0.99,9.99 or 99.9

        """"""
        return self.status.Range

    @range.setter
    def range(self, value):
        range_str = ""R"" + format(
            round(math.log10(strict_discrete_set(value, [0.1, 1, 10])) + 2), ""d""
        )
        self.write(range_str)

    @property
    def SRQ_mask(self):
        """"""Return current SRQ mask, this property can be set,

        bit assigment for SRQ:

        =========  ==========================
        Bit (dec)  Description
        =========  ==========================
         1         SRQ when invalid program
         2         SRQ when trigger is ignored
         4         SRQ when data ready
        =========  ==========================

        """"""
        mask = self.status.SRQ
        return self.SRQ(mask)

    @SRQ_mask.setter
    def SRQ_mask(self, value):
        mask_str = ""E"" + format(strict_range(value, [0, 7]), ""o"") + ""S""
        self.write(mask_str)

    @property
    def trigger(self):
        """"""Return current selected trigger mode, this property can be set,

        Possibe values are:

        ===========  ===========================================
        Value        Explanation
        ===========  ===========================================
        internal     automatic trigger (internal)
        external     external trigger (connector on back or GET)
        hold/manual  holds the measurement/issues a manual trigger
        ===========  ===========================================

        """"""
        return self.status.Trigger

    @trigger.setter
    def trigger(self, value):
        trig_set = self.TRIGGERS[strict_discrete_set(value, self.TRIGGERS)]
        self.write(trig_set)
"
242,89.0,USA,"The 3800 is a microprocessor-based programmer and controller. The programmer function allows you to program temperature, temperature/humidity, or other types of tests and store them in program memory",Thermotron 3800,595.0,"**Thermotron** is a worldwide temperature chamber, humidity chamber, and vibration testing equipment manufacturer. View our testing equipment today!

",Pymeasure,Thermotron,"[OrderedDict([('id', 'atteXXAZkzjedpuoT'), ('width', 600), ('height', 67), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/v8LqezYvVygtyfBJM-Ftxw/auDXvoYlRw3dQcwYQjpotK5xbw6dnKw5NQFkgXpKZMRR9vQv4y1nxwiJ7lT7DYonOYmpnmhYboOhq41u4PA7_CPWPYTpt-3pNEpFkVvZQf8/o0HHAE9lhRJTXKEj9TnUwuZetLkBQ6rCWu3gkzeT6MY'), ('filename', 'Thermotron.jpeg'), ('size', 11067), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hqetNo0eMvafbOH7-i7qjQ/-QUseiUR2z6lxUSAdyOedg_qFoU5kUX2BJLPHcZEUOJJL5l3E_MauxnMcUgZVdqny4AvLGUOkAMxpC304sEb9w/ZFQrGRIp6aY7_GmGwMsMJs9Qte8WZJlfHQVjiTrpx4o'), ('width', 322), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/w-CgVcfAljf1VhSlPVGROA/j61SNZO9lAxbMm7ZrNQoaA_br7buuidnCwX9K31JtSM4YMH_6XVfFaBVtMv6KMpXclWjLBNn-SiqhHi295YnKQ/uGUm4FKdHQqmyeX_xCJIyo8PBx5T079FouzXzwg9ejI'), ('width', 600), ('height', 67)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AUXwZxyVTyr_W7tVqZabzw/5w7L-tcuW3Vq-0eEMqIcxiUlTt9fhn5RvNnO_o5AeI_7dX6DcxwoKBOaUwQj1KR3pGLBoXEJ6P4fOsKKoL0H4A/14gXOEEy4lw-f-3_nDAkntDliLs7A5RHST7z6cqNBvk'), ('width', 3000), ('height', 3000)]))]))])]",https://thermotron.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.",['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",,https://thermotron.com/pdf/_service/software-updates/3800-manual.pdf,"[OrderedDict([('id', 'attNiNZTtkgWns3Qf'), ('width', 800), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q4HsXKA6lEzYig-WjqduKA/7YUkpSNfEJfJae1wqBGlG5d5Nz_M0-IrVO_B9HeLXJnRglutRwEGOFyBJ6lRjID5BuGqHRZe94AVJN-INxKImOPQ2hUWWX8TNv7MIZRBWCEDyyMbLzZD4zJ57oV08snb/xtDjKaF4Wyc1jKbinECjADfTcbJGr1r5-ATYvPx62Ao'), ('filename', 'f81eb98742ad4c9bbe1f8e508e1155d1.jpg'), ('size', 30474), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1XM4IHHfAbrkWJ9dV6ySxg/uthL94sY_zJSrNzBRaat0Rx8tl8Irupcwynk7RMaXa5Hsuh2msP-zGOXLmBbL1UjLCVYBAfeZnWQpJ_0Is_NIg/sf6EWAvyl9iPXMR1LFQlub8VEOXCZ8wMNbjDrw-7s8Q'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eh3iwySOiP0xsW3R5tx6PA/ql8BYb2n1h7EJgck9TBtXjywCsaiCU9conRcoUjZJ_GwiAHenBE8dv6lUZ4uu505FpocXGjCj_B4cn-NYTs9qw/gWYKKdNv7ptALICP6lhda27QbQmSy-0BfLTKYXOCqyA'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fczzoqWFjfh_UmaMjjaCJg/zmj6AIfjspIVe947g2RZCLVG1H1TiQYAeKkpijFuhLUOxXAqxSUSEtCTV3slRzq16GafQm9CcMLBYJlJVaU_1g/XaYel_5GZWfWBfnaliPVEDAsoHenEwzaQIJIodUI9gs'), ('width', 3000), ('height', 3000)]))]))])]",https://thermotron.com/pdf/_service/software-updates/3800-manual.pdf,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/thermotron/thermotron3800.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/thermotron/thermotron3800.html,3000.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range
from time import sleep
from enum import IntFlag


class Thermotron3800(Instrument):
    """""" Represents the Thermotron 3800 Oven.
    For now, this driver only supports using Control Channel 1.
    There is a 1000ms built in wait time after all write commands.
    """"""

    def __init__(self, adapter, name=""Thermotron 3800"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs
        )

    def write(self, command):
        super().write(command)
        # Insert wait time after sending command.
        # This wait time should be >1000ms for consistent results.
        sleep(1)

    id = Instrument.measurement(
        ""IDEN?"", """""" Reads the instrument identification

        :return: String
        """"""
    )

    temperature = Instrument.measurement(
        ""PVAR1?"", """""" Reads the current temperature of the oven
        via built in thermocouple. Default unit is Celsius, unless
        changed by the user.

        :return: float
        """"""
    )

    mode = Instrument.measurement(
        ""MODE?"", """""" Gets the operating mode of the oven.

        :return: Tuple(String, int)
        """""",
        get_process=lambda mode: Thermotron3800.__translate_mode(mode)
    )

    setpoint = Instrument.control(
        ""SETP1?"", ""SETP1,%g"",
        """""" A floating point property that controls the setpoint
        of the oven in Celsius. This property can be set.
        ""setpoint"" will not update until the ""run()"" command is called.
        After setpoint is set to a new value, the ""run()"" command
        must be called to tell the oven to run to the new temperature.

        :return: None
        """""",
        validator=strict_range,
        values=[-55, 150]
    )

    def run(self):
        '''
        Starts temperature forcing. The oven will ramp to the setpoint.

        :return: None
        '''
        self.write(""RUNM"")

    def stop(self):
        '''
        Stops temperature forcing on the oven.

        :return: None
        '''
        self.write(""STOP"")

    def initalize_oven(self, wait=True):
        '''
        The manufacturer recommends a 3 second wait time after after initializing the oven.
        The optional ""wait"" variable should remain true, unless the 3 second wait time is
        taken care of on the user end. The wait time is split up in the following way:
        1 second (built into the write function) +
        2 seconds (optional wait time from this function (initialize_oven)).

        :return: None
        '''
        self.write(""INIT"")
        if wait:
            sleep(2)

    class Thermotron3800Mode(IntFlag):
        """"""
        +--------+--------------------------------------+
        | Bit    | Mode                                 |
        +========+======================================+
        | 0      | Program mode                         |
        +--------+--------------------------------------+
        | 1      | Edit mode (controller in stop mode)  |
        +--------+--------------------------------------+
        | 2      | View program mode                    |
        +--------+--------------------------------------+
        | 3      | Edit mode (controller in hold mode)  |
        +--------+--------------------------------------+
        | 4      | Manual mode                          |
        +--------+--------------------------------------+
        | 5      | Delayed start mode                   |
        +--------+--------------------------------------+
        | 6      | Unused                               |
        +--------+--------------------------------------+
        | 7      | Calibration mode                     |
        +--------+--------------------------------------+
        """"""
        PROGRAM_MODE = 1
        EDIT_MODE_STOP = 2
        VIEW_PROGRAM_MODE = 4
        EDIT_MODE_HOLD = 8
        MANUAL_MODE = 16
        DELAYED_START_MODE = 32
        UNUSED = 64
        CALIBRATION_MODE = 128

    @staticmethod
    def __translate_mode(mode_coded_integer):

        mode = Thermotron3800.Thermotron3800Mode(int(mode_coded_integer))

        return mode
"
247,670.0,JAPAN,"The MG3690C series of broadband signal generators covers audio, HF, VHF, UHF, RF and microwave frequencies from 0.1 Hz to 70 GHz in single coaxial output and up to 500 GHz or beyond, with external multipliers",Anritsumg MG3692 C,81.0,"**Anritsu** Has Testing Solutions for Automotive, Government, Data Center, & IoT Industries. Test Solutions for IoT Devices, Government Radar, Automotive, & Signal Integrity.
",Pymeasure,Anritsu,"[OrderedDict([('id', 'attthRx89ny57l7IM'), ('width', 555), ('height', 322), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZmPX4SuNFgpMC_FPYiQp0A/6rWlWETVEOsIG9eJaj7_HTtV4hpuaE5l5bXyhr6NHnX0i81eC-0UIcs_cuAtlRHC1ckl4WcdZseU6UfHX9LgizKTfFhnlmi_mOI2QTBczaA/ACB8i35qnE5qyKeqpZvOW-6SzP-h9ly7vNUgqSnOkwI'), ('filename', 'anritsu-logo-2021-v2.png'), ('size', 19028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XqeyQwMMQY-YTrsX1BfYAw/-uFNzgN2_iTHUL0tDM3qm9KiEA5U7ZSYUpkonisEjFCewWcVcEa6QdxmNtrkvxTOe0mtTzUqbG0uJPypTwBOIw/jP4kJ0e_UWOU-Sh5XsFbSnOL5xYdeXxYG75IaJDFXgw'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zEGLkzKKiX4QgM-iJ5cwWw/OyOUjkwIahhWOEYJj_RB4VnN-8glL3UpVHI97X01JmUf_h3pkWFb0lvq6FmQwNjqpR38W0WmFYhVYbyvZSMPzA/IiFsssiUUcXbrl2HJnNH7JBo7hT5clI_HR6R6JRInM0'), ('width', 555), ('height', 322)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RA-RtnFL2ID2eDcIiPhpvg/UTpEZfHBFpEc3DGfU6xpZolvvsJ7_ICf8wQqIHTS8Kx2gb0qpcy6G_qvT9kl5FiKRFZEd7wGRbiLzuUemx084w/uY4PuCcoPcH1rUWC-B9-drfFjgki7yiZ44npIPL4H1c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/,Write a Python script that uses Pymeasure to connect to a From MG3690C Series RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape",From MG3690C Series,https://dl.cdn-anritsu.com/en-us/test-measurement/files/Brochures-Datasheets-Catalogs/Brochure/11410-01119C.pdf,"[OrderedDict([('id', 'attAdxsbQanV18MZB'), ('width', 420), ('height', 160), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SsGSACI0lR-Jzdwm39MDzw/4N-w5OIKZvYJAJKUzEq6REWXq4lc0mTeVZooGmpy53BsAvpKg6GVl4vPmihFZb3zimu1fv5hLll3cHXKwxxxHIBTQlyXrYD9-meO6oc2_wk/bkHTAUApUMErD2WMItKRinYQOFmoGcU1z_Dqdz_KzN0'), ('filename', 'anritsu-MG3690C_1.jpg'), ('size', 13503), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/o_Pom7t_PHbjNlk8dJHXMg/oaZ5iUC8scf19vpZ6TORWwk0WCwwIXwaliwCNkU9P2RiVx9v4k_IJhlhspA4btM6wEgDxFYjW2O-CvZUfevk5w/K1taZFSelDeCeKJ817JNMllovgJlU_6VimIEhnwrRFI'), ('width', 95), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IvFndzJjD6HjfYMGXcpf-g/GDkbaqTsKNKoTk9q4me17LzZfgdGOcZaZ32rzWrE0gfsg3Bx-QGW82E-VYWctLenNm20U8iHpyjgdsqZLesMpA/RY-mcw4Qgup8TrvaIYXShY0EqC810H-r__bogPyaKo4'), ('width', 420), ('height', 160)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-F95Fkd-wP_DpZ61VxaXLg/y1SHMxtxqe3rl2nLmIwwjQ5ipMYNlEHTY8svWtqFNoTlLbiSzzZpMZWdrMK_UYigBqJrWTQEj_4z1B_NsOHwjA/EflCFzkUpXd4edQxCDcNHFS2kk4T2PuTl4PCtiHodDk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.anritsu.com/en-us/test-measurement/products/mg3690c,,https://pymeasure.readthedocs.io/en/latest/api/instruments/anritsu/anritsuMG3692C.html,,,,,
250,5420.0,USA,4156C Precision Semiconductor Parameter Analyzer,Agilent 4156,17.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT 4156C Spectrum Analyzers,https://www.atecorp.com/category/semiconductor-parameter-analyzers,['Spectrum Analyzers'],"
The semiconductor parameter analyzer is an all-in-one unit, that consists of a power supplies, voltage meters, current meters, switching matrices and LCR meters to test semiconductors",KEYSIGHT 4156C,https://www.keysight.com/us/en/assets/7018-02070/technical-overviews/5990-3672.pdf,"[OrderedDict([('id', 'attD3cR5iYz6YL8CW'), ('width', 582), ('height', 451), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hGTDIgXT5E3DhlKIXBRs0A/M0p8DsGLaFl8MwJhMqae0PhfkXE8nP2jW__mP-QyO_lxX0ap9oJ1n62cAnhQSzoxiIY6_UichgaRa2LzbFzxxuJ1O7Uhnqp31yE4lUoQfFc/o_BLQaugo2dwHtusrwOjVCg4LbiM2blAJMPZOE1WskE'), ('filename', '4156C.png'), ('size', 270610), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tl6t6ZaMh6JlEvI4WMQ89g/7Kjb8dvkWgrI0kMG1WWTd2gdbWOVg1AlrZpGBKLl2tY37oXHNFurEBnfrs1EssmRjqc-we64SBXSNy0Bgz8TiA/vHbHZayZdOi5gB5_O5DE-WhG_dDjV9Dufbdpc9zen3k'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mK1YlwZE08omLdssZw0lCw/Lq-kS_X0i4sbne8_Tsngv22wOt4dxECAVYVMHyyd1zCEtDIi63OYzKjf5Fni5ML-V0Ic0d8X_EBg2n2ZvIXUCA/X_RZh07nTzWCNuU4NPl3TBDGnXXLRhI00bJrKpFCYaA'), ('width', 582), ('height', 451)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TNRsfuFsvjSHqgNR5vXEtg/8cF_SVIRiqNec8BGhDseSGNyW1C53vThhSEViM4_G4g8OMN-S876W36V5Oyl25t9CQ0dpuyNHqOeqwNDcYPPXA/4TpI0FzTv_lhmQSz5fxFYjnb2goOmAqD8gynTgesrcQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/4156C/precision-semiconductor-parameter-analyzer.html,https://github.com/leobrowning92/pa-control/blob/master/hp4156c.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent4156.html,,"
",True,,"#!/var/run/python
# Agilent Parameter Analyser Sweep function script.


# Import the HP4156C class

# The HP4156C class includes the metaclass visa

# This allows the HP4156C to wrap the visa class
# When wrapped the HP4156C class takes care of all the visa syntax
# and translates parameter analyser settings into visa commands
import sys,visa,os
import numpy as np


class hp4156c(object):
	def __init__(self,device_id=''):
		self.deviceName = ""HEWLETT-PACKARD,4156C,0,03.04:04.05:01.00""
		self.device_id = device_id
		self._initialise()

	def _initialise(self):
		""""""Iterates through all devices on the GPIB bus until it finds the
		parameter analyser with ID _self.deviceName. If no parameter analyser found
		the initiation is aborted and a sys.exit is called""""""
		print(""HP4156C Initialisation"")
		rm = visa.ResourceManager()
		_devices = rm.list_resources()
		print(_devices)
		for _x in range(0,len(_devices)):
			print(_devices[_x])
			try:
				self.pa = rm.open_resource((_devices[_x]))
				self.device_id = self.pa.ask(""*IDN?"").encode().rstrip()
				if(self.device_id == self.deviceName):
					print(""Found device %s""%self.device_id)
					break
			except:
				print(""Could not connect to device %s""%_devices[_x])
		if(self.device_id != self.deviceName):
			print(""Could not find the parameter analyser."")
			print(""Exiting."")
			sys.exit()
		else:
			self.pa.write(""*rst"")
		print(""Connected to device %s""%_devices[_x])
	def reset(self):
		"""""" Calls a reset command on the parameter analyser""""""
		self.pa.write(""*rst"")

	def measurementMode(self, mode, intTime):
		"""""" Sets the parameter analyser operation mode and integration time""""""
		if(mode == ""SWEEP"" or mode == ""SAMPLE"" or mode == ""QSCV"") and (intTime == ""SHORT"" or intTime == ""MEDIUM"" or intTime == ""LONG""):
			self.pa.write("":PAGE:CHAN:MODE "" + mode)
			self.pa.write("":PAGE:MEAS:MSET:ITIM "" + intTime)
		else:
			print(""Invalid measurement mode or integration time. Exiting."")
			sys.exit()

	def _stringSmuMod(self,arg):
		"""""" Formats the smu argument2 into SCPI ASCII text """"""
		arg[0] = ""'"" + arg[0] + ""'""
		arg[2] = ""'"" + arg[2] + ""'""
		return arg

	def smu(self, arg1, arg2):
		""""""Sets up the SMU specified in arg1 with the parameters specified in
		arg2 """"""
		self.arg2 = self._stringSmuMod(arg2)
		self.smuSetup = ["":PAGE:CHAN:""+arg1+"":VNAME %s"","":PAGE:CHAN:""+arg1+"":FUNC %s"","":PAGE:CHAN:""+arg1+"":INAME %s"","":PAGE:CHAN:""+arg1+"":MODE %s"","":PAGE:MEAS:CONS:""+arg1+"" %s"","":PAGE:MEAS:CONS:""+arg1+"":COMP %s""]
		self.pa.write(self.smuSetup[0] %self.arg2[0])
		self.pa.write(self.smuSetup[1] %self.arg2[1])
		self.pa.write(self.smuSetup[2] %self.arg2[2])
		self.pa.write("":PAGE:DISP:LIST %s"" % self.arg2[2])
		self.pa.write(self.smuSetup[3] %self.arg2[3])
		if arg2[1] != ""VAR1"" and arg2[1] != ""VAR2"" and arg2[3] != ""COMM"" and arg2[1] != ""VAR1\'"":
			self.pa.write(self.smuSetup[4] % arg2[4])
			self.pa.write(self.smuSetup[5] % arg2[5])

	def disableSmu(self,arg):
		""""""Disables all SMUs specified in arg""""""
		for i in arg:
			self.pa.write("":PAGE:CHAN:"" + i + "":DIS"")

	def _varStringMod(self, arg):
		""""""format conversion for variable arguments to parameter analyser
		ascii""""""
		arg[0] = ""'"" + arg[0] + ""'""
		return arg

	## arg1 is the smu number
	## arg2 is the parameters for a sweep. [LIN:LOG SING:DOUB STAR STEP STOP COMP]
	def var(self, arg1, arg2):
		""""""Variable parameters, allowing step changes to be implemented""""""
		string = "":PAGE:MEAS:"" + arg1 + "":""
		if arg1 == ""VAR1"":
			self.pa.write(string + ""SPAC %s"" % arg2[0])
			self.pa.write(string + ""MODE %s"" % arg2[1])
			self.pa.write(string + ""STAR %s"" % arg2[2])
			self.pa.write(string + ""STEP %s"" % arg2[3])
			self.pa.write(string + ""STOP %s"" % arg2[4])
			self.pa.write(string + ""COMP %s"" % arg2[5])
		elif arg1 == ""VAR2"":
			self.pa.write(string + ""MODE %s"" % arg2[1])
			self.pa.write(string + ""STAR %s"" % arg2[2])
			self.pa.write(string + ""POIN %s"" % arg2[4])
			self.pa.write(string + ""STEP %s"" % arg2[3])
			self.pa.write(string + ""COMP %s"" % arg2[5])

	def _daqStringMod(self,arg):
		""""""Format conversion for obtained data""""""
		self.stuff = []
		for i in arg:
			self.stuff.append(""\'""+i+""\'"")
		return self.stuff

	def daq(self, values):
		"""""" Obtain stored data from the parameter analyser. Includes code for
		the case when the stored data length exceeds the maximum data length of
		a retrieve command""""""
		#self.data = self._daqStringMod(arg)
		self.values=values #necessary for saving data
		self.data =[[]]*len(values)
		self.pa.timeout=120000
		for x in range(0,len(values)):
			try:
				print(""Obtaining %s data values"" % values[x])
				self.pa.write("":DATA? %s""%values[x])
			except:
				print(""Command Timeout!"")
			read = self.pa.read() # returns unicode string of values
			#decodes string and adds to data array
			self.data[x] = [float(a) for a in read.encode().rstrip().split("","")]
			print(""Obtained %d data values for %s"" % (len(self.data[x]),values[x]))
		self.pa.timeout=3000
		self.data=np.transpose(np.array(self.data))
		print (""data in an {} array"".format(self.data.shape))

	def save_data(self,fname,savedir):
		header=""""
		for val in self.values:
			header=header+val+"",""
		np.savetxt(os.path.join(savedir,fname), self.data, delimiter=',', header=header[:-1], comments="""")
	def collect_data(self,values,fname,savedir):
		""""""combines data acquisition and saving in a single function""""""
		self.daq(values)
		self.save_data(fname, savedir)

	def single(self):
		""""""Initiate a single measurement using entered parameters""""""
		self.pa.write("":PAGE:SCON:SING"")
		self.pa.write(""*WAI"")
		self.pa.timeout=1e6 #if you need more than 11.6 days you're fucked
		self.pa.ask(""*OPC?"")
		self.pa.timeout=10


	def continuous(self):
		""""""Initiate continuous measurements using entered parameters""""""
		self.pa.write("":PAGE:SCON:CONT"")
		self.pa.write(""*WAI"")

	def visualiseTwoYs(self, x, y1, y2):
		""""""Displays results on the parameter analysers display. This is
		superfluous to requirements as the gui handles this""""""
		self.x = self._varStringMod(x)
		self.y1 = self._varStringMod(y1)
		self.y2 = self._varStringMod(y2)
		self.pa.write("":PAGE:DISP:GRAP:GRID ON"")
		self.pa.write("":PAGE:DISP:GRAP:X:NAME %s"" % self.x[0])
		self.pa.write("":PAGE:DISP:GRAP:Y1:NAME %s"" % self.y1[0])
		self.pa.write("":PAGE:DISP:GRAP:Y2:NAME %s"" % self.y2[0])
		self.pa.write("":PAGE:DISP:GRAP:X:SCAL %s"" % self.x[1])
		self.pa.write("":PAGE:DISP:GRAP:Y1:SCAL %s"" % self.y1[1])
		self.pa.write("":PAGE:DISP:GRAP:Y2:SCAL %s"" % self.y2[1])
		self.pa.write("":PAGE:DISP:GRAP:X:MIN %s"" % self.x[2])
		self.pa.write("":PAGE:DISP:GRAP:Y1:MIN %s"" % self.y1[2])
		self.pa.write("":PAGE:DISP:GRAP:Y2:MIN %s"" % self.y2[2])
		self.pa.write("":PAGE:DISP:GRAP:X:MAX %s"" % self.x[3])
		self.pa.write("":PAGE:DISP:GRAP:Y1:MAX %s"" % self.y1[3])
		self.pa.write("":PAGE:DISP:GRAP:Y2:MAX %s"" % self.y2[3])

	def visualise(self, x ,y1):
		""""""Displays results on the parameter analysers display. This is
		superfluous to requirements as gui will handle this""""""
		self.x = self._varStringMod(x)
		self.y1 = self._varStringMod(y1)
		self.pa.write("":PAGE:DISP:GRAP:GRID ON"")
		self.pa.write("":PAGE:DISP:GRAP:X:NAME %s"" % self.x[0])
		self.pa.write("":PAGE:DISP:GRAP:Y1:NAME %s"" % self.y1[0])
		self.pa.write("":PAGE:DISP:GRAP:X:SCAL %s"" % self.x[1])
		self.pa.write("":PAGE:DISP:GRAP:Y1:SCAL %s"" % self.y1[1])
		self.pa.write("":PAGE:DISP:GRAP:X:MIN %s"" % self.x[2])
		self.pa.write("":PAGE:DISP:GRAP:Y1:MIN %s"" % self.y1[2])
		self.pa.write("":PAGE:DISP:GRAP:X:MAX %s"" % self.x[3])
		self.pa.write("":PAGE:DISP:GRAP:Y1:MAX %s"" % self.y1[3])

	def abort(self):
		""""""Does not do anything currently. This function could be useful if we
		implement continuous reading mode""""""
		self.pa.write("":PAGE:SCON:STOP"")
		pass

	def stress(self, term, func, mode, name, value=0.0, duration=0):
		""""""
		Sets up the stress conditions for the 4156.
		Default duration is free-run, no time limit to applied stress.
		""""""
		self.name=self._varStringMod(name)
		self.pa.write("":PAGE:STR:SET:DUR %s"" % duration)
		self.pa.write("":PAGE:STR:%s:NAME %s"" % (term,self.name))
		self.pa.write("":PAGE:STR:%s:FUNC %s"" % (term,func))
		self.pa.write("":PAGE:STR:%s:MODE %s"" % (term,mode))
		self.pa.write("":PAGE:STR:SET:CONS:%s %s"" % (term,value))
		pass

	def merger(self, *lists):
		""""""Combines any number of lists of equal length.""""""
		self.merged=[]
		for i in range(len(lists[0][0])):
			self.temp=[]
			for j in range(len(lists[0])):
				self.temp.append(lists[0][j][i])
			self.merged.append(self.temp)
		return self.merged

	def get_error(self, v=True):
		""""""Returns the first value in the error register""""""
		err=self.pa.ask("":SYST:ERR?"")
		if v:
			print(err)
		return err
"
251,1657.0,"Austin, Texas, USA","NI-DAQmx is the driver software you use to communicate with and control your NI data acquisition (DAQ) devices. It includes an extensive library of functions and VIs you can call from your application software, such as LabVIEW or LabWindows/CVI, to program your devices.",Daqmx,392.0,"A producer of automated test equipment and virtual instrumentation software. Common applications include data acquisition, instrument control and machine vision. 
",Pymeasure,National Instruments,"[OrderedDict([('id', 'attXAVi8mGWUwkEk7'), ('width', 960), ('height', 541), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/buqaMhTGWSsLDsPp_ibFaQ/De8HjydUx3EOCX_p1f2SSDo9dGCp11ixF2oTBsR7CR6yGYXYE_XR4FWNSn3MqZ20E_25rrfDoA8lE2RfAkuP7Q/mRTYDKwu5YneGKzi9In5jj7Q0Jc2rufjx4bGgEHckdg'), ('filename', '0x0.webp'), ('size', 3600), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Pv0WHzZMcUe18sDTIk-6mg/jr5uhXQ9KZen3aLRHNCAvPFX560knZg5OC3GuZHWWZUlwbT5OU_POa-kuo1PD5qEWl5eEs1dnPwCnMthpfYMxWBP2ALfrZR8zjpqzA1TrFQ/MbyuehtfHbxyhnrazXO_aVtHoiJ-YxS2aY_z_AlOlI4'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/H2ohCz7JKiucuuY1yKqARA/PC2AnJ8K6bupw239v_vXHNw2Bw02LZLYgFDZExIJ_IYgHKZF3aKphU6VgFnEXdi_JSVfBWTNow1CPi7pJroA801RTFAurSQsjnCQd46i1tI/iQUX1GjeerVvwDnChxusHAS0iRltSIlZ9OIhT6aWeyI'), ('width', 909), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FbZiry0wuZILUwoQONwY7w/TPig8INn4HxQab3cUodGEZ-LmxYwwAgZ-P2q9uDSN0Ldk6LIqGUZwq8U0ONnHe4UeVnJel-tkU0whlEnSfHvMB2WbUcP1DTtJGt-UvawHkI/mGxqe-xjeAIUQCHVOUg5_cDcuiJu0KrjzJiiqkUQRMI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ni.com/en-ca.html,Write a Python script that uses Pymeasure to connect to a {Device name} ,,,,,,,https://www.ni.com/docs/en-US/bundle/ni-daqmx/page/daqhelp/nidaqoverview.html,,,,,,,
295,5800.0,USA,"Users can choose from 12 different standard waveforms. Arbitrary waveforms can be generated up to 128 K in length at high sampling rates. On pulse waveforms, leading and trailing edge time can be set independently. External signals can be connected and added to the output signal. Dual-channel models can generate two identical or completely different signals. All instruments feature a highly stable time base with only ±1 ppm drift per year.",AFG 3152 C,541.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Pymeasure,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a AFG3152C Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.",AFG3152C,https://download.tek.com/datasheet/AFG3000C-Arbitrary-Function-Generator-Datasheet-75W282817.pdf,"[OrderedDict([('id', 'attKlkCBf7LpB2VDF'), ('width', 1536), ('height', 904), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Jsyl4_7fsfpqJDc3Sd_0cQ/qDE5CW0h1KvSju5rCEj9KSBKQIdRh7B897TwGRlsyBxjZpeham-YWyg8xZsxEcz7GT6gZ1F4RENkhwYdSMztpnrb0gnYZVxaRY6leL4W1m8/LlvJWmYqy99L-vLx-rxuTV0IMCf9lAxr4HWc6Vwhlf0'), ('filename', 'TEKAFG3152C-1.jpg'), ('size', 153756), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gVOI0Cbiqip7nMhTnE2W3g/npso_vcUn6W_1lz8K-6IA5v9HAs7fgRqIvC7qgkq-NBscbUxZRxmUEgHpf2Sdn9EhyoLTx8CM-gU0g-fQlQGTQ/sbCef0aq8-cXhAZp7ttJSMEUp21GhfZgMh46hU9pGgg'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/P0NE-Orm9mPSUm4U-A4BpA/-xN1_BGVbvisEsBM_EcHWWzDtL7ryaQLJ_TUkjVgz_b8_XFiJRUqicM0EWSUANAT7qCAgsT7R_vJUam6mgQYlg/YffqqX4f-EOAn0WKhfLkWRW6wcBqNh8CxM72Ry0Fusw'), ('width', 870), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UVlz61jKny6mOGPelYuPzg/tdOlyNOt1bFj2HAxUvAynFP2CjEECqgdgKFg05iGsysDRKelOGD6vq7jXGD7W7KTLhwYrjgtZW30sVWky5bPsg/Z-k--Sq11WpBVGfQCu7EDaZX-Ek3hVIsrLcxprP5Uj8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/afg3000c-arbitrary-function-generator-datasheet,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/tektronix/afg3152c.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/tektronix/afg3152c.html,8550.0,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from math import sqrt, log10
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_range, strict_discrete_set


class Channel:
    SHAPES = {
        ""sinusoidal"": ""SIN"",
        ""square"": ""SQU"",
        ""pulse"": ""PULS"",
        ""ramp"": ""RAMP"",
        ""prnoise"": ""PRN"",
        ""dc"": ""DC"",
        ""sinc"": ""SINC"",
        ""gaussian"": ""GAUS"",
        ""lorentz"": ""LOR"",
        ""erise"": ""ERIS"",
        ""edecay"": ""EDEC"",
        ""haversine"": ""HAV"",
    }
    FREQ_LIMIT = [1e-6, 150e6]  # Frequeny limit for sinusoidal function
    DUTY_LIMIT = [0.001, 99.999]
    AMPLITUDE_LIMIT = {
        ""VPP"": [20e-3, 10],
        ""VRMS"": list(map(lambda x: round(x / 2 / sqrt(2), 3), [20e-3, 10])),
        ""DBM"": list(
            map(lambda x: round(20 * log10(x / 2 / sqrt(0.1)), 2), [20e-3, 10])
        ),
    }  # Vpp, Vrms and dBm limits
    UNIT_LIMIT = [""VPP"", ""VRMS"", ""DBM""]
    IMP_LIMIT = [1, 1e4]

    shape = Instrument.control(
        ""function:shape?"",
        ""function:shape %s"",
        """""" A string property that controls the shape of the output.
            This property can be set."""""",
        validator=strict_discrete_set,
        values=SHAPES,
        map_values=True,
    )

    unit = Instrument.control(
        ""voltage:unit?"",
        ""voltage:unit %s"",
        """""" A string property that controls the amplitude unit.
            This property can be set."""""",
        validator=strict_discrete_set,
        values=UNIT_LIMIT,
    )

    amp_vpp = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eVPP"",
        """""" A floating point property that controls the output amplitude
            in Vpp. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""VPP""],
    )

    amp_dbm = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eDBM"",
        """""" A floating point property that controls the output amplitude
            in dBm. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""DBM""],
    )

    amp_vrms = Instrument.control(
        ""voltage:amplitude?"",
        ""voltage:amplitude %eVRMS"",
        """""" A floating point property that controls the output amplitude
            in Vrms. This property can be set."""""",
        validator=strict_range,
        values=AMPLITUDE_LIMIT[""VRMS""],
    )

    offset = Instrument.control(
        ""voltage:offset?"",
        ""voltage:offset %e"",
        """""" A floating point property that controls the amplitude
            offset. It is always in Volt. This property can be set."""""",
    )

    frequency = Instrument.control(
        ""frequency:fixed?"",
        ""frequency:fixed %e"",
        """""" A floating point property that controls the frequency.
            This property can be set."""""",
        validator=strict_range,
        values=FREQ_LIMIT,
    )

    duty = Instrument.control(
        ""pulse:dcycle?"",
        ""pulse:dcycle %.3f"",
        """""" A floating point property that controls the duty
            cycle of pulse. This property can be set."""""",
        validator=strict_range,
        values=DUTY_LIMIT,
    )

    impedance = Instrument.control(
        ""output:impedance?"",
        ""output:impedance %d"",
        """""" A floating point property that controls the output
            impedance of the channel. Be careful with this.
            This property can be set."""""",
        validator=strict_range,
        values=IMP_LIMIT,
        cast=int,
    )

    def __init__(self, instrument, number):
        self.instrument = instrument
        self.number = number

    def values(self, command, **kwargs):
        """"""Reads a set of values from the instrument through the adapter,
        passing on any key-word arguments.
        """"""
        return self.instrument.values(
            ""source%d:%s"" % (self.number, command), **kwargs
        )

    def ask(self, command):
        return self.instrument.ask(""source%d:%s"" % (self.number, command))

    def write(self, command):
        self.instrument.write(""source%d:%s"" % (self.number, command))

    def read(self):
        return self.instrument.read()

    def enable(self):
        self.instrument.write(""output%d:state on"" % self.number)

    def disable(self):
        self.instrument.write(""output%d:state off"" % self.number)

    def waveform(
        self, shape=""SIN"", frequency=1e6, units=""VPP"", amplitude=1, offset=0
    ):
        """"""General setting method for a complete wavefunction""""""
        self.instrument.write(
            ""source%d:function:shape %s"" % (self.number, shape)
        )
        self.instrument.write(
            ""source%d:frequency:fixed %e"" % (self.number, frequency)
        )
        self.instrument.write(
            ""source%d:voltage:unit %s"" % (self.number, units)
        )
        self.instrument.write(
            ""source%d:voltage:amplitude %e%s"" % (self.number, amplitude, units)
        )
        self.instrument.write(
            ""source%d:voltage:offset %eV"" % (self.number, offset)
        )


class AFG3152C(Instrument):
    """"""Represents the Tektronix AFG 3000 series (one or two channels)
    arbitrary function generator and provides a high-level for
    interacting with the instrument.

    .. code-block:: python

        afg=AFG3152C(""GPIB::1"")        # AFG on GPIB 1
        afg.reset()                    # Reset to default
        afg.ch1.shape='sinusoidal'     # Sinusoidal shape
        afg.ch1.unit='VPP'             # Sets CH1 unit to VPP
        afg.ch1.amp_vpp=1              # Sets the CH1 level to 1 VPP
        afg.ch1.frequency=1e3          # Sets the CH1 frequency to 1KHz
        afg.ch1.enable()               # Enables the output from CH1
    """"""

    def __init__(self, adapter, name=""Tektronix AFG3152C arbitrary function generator"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ch1 = Channel(self, 1)
        self.ch2 = Channel(self, 2)

    def beep(self):
        self.write(""system:beep"")

    def opc(self):
        return int(self.ask(""*OPC?""))
"
306,24.9,"Sunnyvale, California","The new SR860 Lock-in Amplifier is the latest in a line of innovative lock-ins from SRS. With unparalleled analog performance, sophisticated new digital signal processing features, a thoroughly modern, intuitive user interface, and a wide range of computer connectivity options, the SR860 is the ideal choice for any synchronous detection application.",SR 860,522.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Pymeasure,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Pymeasure to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://www.thinksrs.com/downloads/pdfs/catalog/SR860c.pdf,"[OrderedDict([('id', 'attQcGYgznsQTMwiU'), ('width', 4428), ('height', 2540), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-iFh5mb80RRY-na2RmDL8A/ykG-HKwwyXeFiw60NvSItiJb1Ma3UkuCMY4tNhd6YB603yDMVDDAHFHRFa5ANcbE6pqxQhFKFrZaoqJVbwwti-qIByNqLRwL0zoQR8-uhsg/ie4tzj-1oYMjMxd0w_4atZA_faCOvgDwtFuNRHW3QFg'), ('filename', 'SR860_Lt_Wide.jpg'), ('size', 2290334), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9yH-Oasgn48lXinwR0u72Q/gb_QioT63QTALKBCBpidPFxuUyax78PTd7R8TeECEkgGmfH5NcYflAWHJFqjzsUvlRYZ_TCoYlh49WasdaV0Tw/CYLMjTfpix51HeR2FJc1mgmX-Hju0JvRwV-Sa_aiWZg'), ('width', 63), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jTLN3ulEI0kO4w6TlaBLCQ/gR4xItfD3Mde8Puj2HWVbN5yR9SrP-nUPMySku4EtZSPfLvK1en1Gj2c9BvZyBBVN3K70WvArqwyIpDyTSfwKw/nx7rguDp4m0VgYj2FZZQViufUpU1rmk0q5fh5ZWbftw'), ('width', 893), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ooTAKGeEJeSZRrlsL0gzEQ/qN6HavLxist3eW5j7JQp4Ug_4SDPZDPL2IN7E-MZKtK6U72FUNNcSh_pugQoq2SRl2boBAZ0Ue2hz9ZYPGRRrw/JQ7W979XAhIohA8dzaksWGaEd0bXb6p-Eb7QOlRzAPw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr860.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr860.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr860.html,6495.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments.validators import strict_discrete_set, \
    truncated_discrete_set, truncated_range
from pymeasure.instruments import Instrument


class SR860(Instrument):

    SENSITIVITIES = [
        1e-9, 2e-9, 5e-9, 10e-9, 20e-9, 50e-9, 100e-9, 200e-9,
        500e-9, 1e-6, 2e-6, 5e-6, 10e-6, 20e-6, 50e-6, 100e-6,
        200e-6, 500e-6, 1e-3, 2e-3, 5e-3, 10e-3, 20e-3,
        50e-3, 100e-3, 200e-3, 500e-3, 1
    ]
    TIME_CONSTANTS = [
        1e-6, 3e-6, 10e-6, 30e-6, 100e-6, 300e-6, 1e-3, 3e-3, 10e-3,
        30e-3, 100e-3, 300e-3, 1, 3, 10, 30, 100, 300, 1e3,
        3e3, 10e3, 30e3
    ]
    ON_OFF_VALUES = ['0', '1']
    SCREEN_LAYOUT_VALUES = ['0', '1', '2', '3', '4', '5']
    EXPANSION_VALUES = ['0', '1', '2,']
    CHANNEL_VALUES = ['OCH1', 'OCH2']
    OUTPUT_VALUES = ['XY', 'RTH']
    INPUT_TIMEBASE = ['AUTO', 'IN']
    INPUT_DCMODE = ['COM', 'DIF', 'common', 'difference']
    INPUT_REFERENCESOURCE = ['INT', 'EXT', 'DUAL', 'CHOP']
    INPUT_REFERENCETRIGGERMODE = ['SIN', 'POS', 'NEG', 'POSTTL', 'NEGTTL']
    INPUT_REFERENCEEXTERNALINPUT = ['50OHMS', '1MEG']
    INPUT_SIGNAL_INPUT = ['VOLT', 'CURR', 'voltage', 'current']
    INPUT_VOLTAGE_MODE = ['A', 'A-B']
    INPUT_COUPLING = ['AC', 'DC']
    INPUT_SHIELDS = ['Float', 'Ground']
    INPUT_RANGE = ['1V', '300M', '100M', '30M', '10M']
    INPUT_GAIN = ['1MEG', '100MEG']
    INPUT_FILTER = ['Off', 'On']
    LIST_PARAMETER = ['i=', '0=Xoutput', '1=Youtput', '2=Routput', 'Thetaoutput', '4=Aux IN1',
                      '5=Aux IN2', '6=Aux IN3', '7=Aux IN4', '8=Xnoise', '9=Ynoise',
                      '10=AUXOut1', '11=AuxOut2', '12=Phase', '13=Sine Out amplitude',
                      '14=DCLevel', '15I=nt.referenceFreq', '16=Ext.referenceFreq']
    LIST_HORIZONTAL_TIME_DIV = ['0=0.5s', '1=1s', '2=2s', '3=5s', '4=10s', '5=30s', '6=1min',
                                '7=2min', '8=5min', '9=10min', '10=30min', '11=1hour', '12=2hour',
                                '13=6hour', '14=12hour', '15=1day', '16=2days']

    x = Instrument.measurement(""OUTP? 0"",
                               """""" Reads the X value in Volts """"""
                               )
    y = Instrument.measurement(""OUTP? 1"",
                               """""" Reads the Y value in Volts """"""
                               )
    magnitude = Instrument.measurement(""OUTP? 2"",
                                       """""" Reads the magnitude in Volts. """"""
                                       )
    theta = Instrument.measurement(""OUTP? 3"",
                                   """""" Reads the theta value in degrees. """"""
                                   )
    phase = Instrument.control(
        ""PHAS?"", ""PHAS %0.7f"",
        """""" A floating point property that represents the lock-in phase
        in degrees. This property can be set. """""",
        validator=truncated_range,
        values=[-360, 360]
    )
    frequency = Instrument.control(
        ""FREQ?"", ""FREQ %0.6e"",
        """""" A floating point property that represents the lock-in frequency
        in Hz. This property can be set. """""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    internalfrequency = Instrument.control(
        ""FREQINT?"", ""FREQINT %0.6e"",
        """"""A floating property that represents the internal lock-in frequency in Hz
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    harmonic = Instrument.control(
        ""HARM?"", ""Harm %d"",
        """"""An integer property that controls the harmonic that is measured.
        Allowed values are 1 to 99. Can be set."""""",
        validator=strict_discrete_set,
        values=range(1, 99)
    )
    harmonicdual = Instrument.control(
        ""HARMDUAL?"", ""HARMDUAL %d"",
        """"""An integer property that controls the harmonic in dual reference mode that is measured.
        Allowed values are 1 to 99. Can be set."""""",
        validator=strict_discrete_set,
        values=range(1, 99)
    )
    sine_voltage = Instrument.control(
        ""SLVL?"", ""SLVL %0.9e"",
        """"""A floating point property that represents the reference sine-wave
        voltage in Volts. This property can be set."""""",
        validator=truncated_range,
        values=[1e-9, 2]
    )

    timebase = Instrument.control(
        ""TBMODE?"", ""TBMODE %d"",
        """"""Sets the external 10 MHZ timebase to auto(i=0) or internal(i=1)."""""",
        validator=strict_discrete_set,
        values=[0, 1],
        map_values=True
    )
    dcmode = Instrument.control(
        ""REFM?"", ""REFM %d"",
        """"""A string property that represents the sine out dc mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_DCMODE),
        validator=strict_discrete_set,
        values=INPUT_DCMODE,
        map_values=True
    )
    reference_source = Instrument.control(
        ""RSRC?"", ""RSRC %d"",
        """"""A string property that represents the reference source.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCESOURCE),
        validator=strict_discrete_set,
        values=INPUT_REFERENCESOURCE,
        map_values=True
    )
    reference_triggermode = Instrument.control(
        ""RTRG?"", ""RTRG %d"",
        """"""A string property that represents the external reference trigger mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCETRIGGERMODE),
        validator=strict_discrete_set,
        values=INPUT_REFERENCETRIGGERMODE,
        map_values=True
    )
    reference_externalinput = Instrument.control(
        ""REFZ?"", ""REFZ&d"",
        """"""A string property that represents the external reference input.
        This property can be set. Allowed values are:{}"""""".format(INPUT_REFERENCEEXTERNALINPUT),
        validator=strict_discrete_set,
        values=INPUT_REFERENCEEXTERNALINPUT,
        map_values=True
    )
    input_signal = Instrument.control(
        ""IVMD?"", ""IVMD %d"",
        """"""A string property that represents the signal input.
        This property can be set. Allowed values are:{}"""""".format(INPUT_SIGNAL_INPUT),
        validator=strict_discrete_set,
        values=INPUT_SIGNAL_INPUT,
        map_values=True
    )
    input_voltage_mode = Instrument.control(
        ""ISRC?"", ""ISRC %d"",
        """"""A string property that represents the voltage input mode.
        This property can be set. Allowed values are:{}"""""".format(INPUT_VOLTAGE_MODE),
        validator=strict_discrete_set,
        values=INPUT_VOLTAGE_MODE,
        map_values=True
    )
    input_coupling = Instrument.control(
        ""ICPL?"", ""ICPL %d"",
        """"""A string property that represents the input coupling.
        This property can be set. Allowed values are:{}"""""".format(INPUT_COUPLING),
        validator=strict_discrete_set,
        values=INPUT_COUPLING,
        map_values=True
    )
    input_shields = Instrument.control(
        ""IGND?"", ""IGND %d"",
        """"""A string property that represents the input shield grounding.
        This property can be set. Allowed values are:{}"""""".format(INPUT_SHIELDS),
        validator=strict_discrete_set,
        values=INPUT_SHIELDS,
        map_values=True
    )
    input_range = Instrument.control(
        ""IRNG?"", ""IRNG %d"",
        """"""A string property that represents the input range.
        This property can be set. Allowed values are:{}"""""".format(INPUT_RANGE),
        validator=strict_discrete_set,
        values=INPUT_RANGE,
        map_values=True
    )
    input_current_gain = Instrument.control(
        ""ICUR?"", ""ICUR %d"",
        """"""A string property that represents the current input gain.
        This property can be set. Allowed values are:{}"""""".format(INPUT_GAIN),
        validator=strict_discrete_set,
        values=INPUT_GAIN,
        map_values=True
    )
    sensitvity = Instrument.control(
        ""SCAL?"", ""SCAL %d"",
        """""" A floating point property that controls the sensitivity in Volts,
        which can take discrete values from 2 nV to 1 V. Values are truncated
        to the next highest level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True
    )
    time_constant = Instrument.control(
        ""OFLT?"", ""OFLT %d"",
        """""" A floating point property that controls the time constant
        in seconds, which can take discrete values from 10 microseconds
        to 30,000 seconds. Values are truncated to the next highest
        level if they are not exact. """""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True
    )
    filter_slope = Instrument.control(
        ""OFSL?"", ""OFSL %d"",
        """"""A integer property that sets the filter slope to 6 dB/oct(i=0), 12 DB/oct(i=1),
        18 dB/oct(i=2), 24 dB/oct(i=3)."""""",
        validator=strict_discrete_set,
        values=range(0, 3)
    )
    filer_synchronous = Instrument.control(
        ""SYNC?"", ""SYNC %d"",
        """"""A string property that represents the synchronous filter.
        This property can be set. Allowed values are:{}"""""".format(INPUT_FILTER),
        validator=strict_discrete_set,
        values=INPUT_FILTER,
        map_values=True
    )
    filter_advanced = Instrument.control(
        ""ADVFILT?"", ""ADVFIL %d"",
        """"""A string property that represents the advanced filter.
        This property can be set. Allowed values are:{}"""""".format(INPUT_FILTER),
        validator=strict_discrete_set,
        values=INPUT_FILTER,
        map_values=True
    )
    frequencypreset1 = Instrument.control(
        ""PSTF? 0"", ""PSTF 0, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F1 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset2 = Instrument.control(
        ""PSTF? 1"", ""PSTF 1, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F2 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset3 = Instrument.control(
        ""PSTF? 2"", ""PSTF2, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F3 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    frequencypreset4 = Instrument.control(
        ""PSTF? 3"", ""PSTF3, %0.6e"",
        """"""A floating point property that represents the preset frequency for the F4 preset button.
        This property can be set."""""",
        validator=truncated_range,
        values=[0.001, 500000]
    )
    sine_amplitudepreset1 = Instrument.control(
        ""PSTA? 0"", ""PSTA0, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A1 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset2 = Instrument.control(
        ""PSTA? 1"", ""PSTA1, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A2 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset3 = Instrument.control(
        ""PSTA? 2"", ""PSTA2, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A3 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_amplitudepreset4 = Instrument.control(
        ""PSTA? 3"", ""PSTA 3, %0.9e"",
        """"""Floating point property representing the preset sine out amplitude, for the A3 preset button.
        This property can be set."""""",  # noqa: E501
        validator=truncated_range,
        values=[1e-9, 2]
    )
    sine_dclevelpreset1 = Instrument.control(
        ""PSTL? 0"", ""PSTL 0, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L1 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset2 = Instrument.control(
        ""PSTL? 1"", ""PSTL 1, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L2 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset3 = Instrument.control(
        ""PSTL? 2"", ""PSTL 2, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L3 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )
    sine_dclevelpreset4 = Instrument.control(
        ""PSTL? 3"", ""PSTL3, %0.3e"",
        """"""A floating point property that represents the preset sine out dc level for the L4 button.
        This property can be set."""""",
        validator=truncated_range,
        values=[-5, 5]
    )

    aux_out_1 = Instrument.control(
        ""AUXV? 0"", ""AUXV 1, %f"",
        """""" A floating point property that controls the output of Aux output 1 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac1 = aux_out_1

    aux_out_2 = Instrument.control(
        ""AUXV? 1"", ""AUXV 2, %f"",
        """""" A floating point property that controls the output of Aux output 2 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac2 = aux_out_2

    aux_out_3 = Instrument.control(
        ""AUXV? 2"", ""AUXV 3, %f"",
        """""" A floating point property that controls the output of Aux output 3 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac3 = aux_out_3

    aux_out_4 = Instrument.control(
        ""AUXV? 3"", ""AUXV 4, %f"",
        """""" A floating point property that controls the output of Aux output 4 in
        Volts, taking values between -10.5 V and +10.5 V.
        This property can be set."""""",
        validator=truncated_range,
        values=[-10.5, 10.5]
    )
    # For consistency with other lock-in instrument classes
    dac4 = aux_out_4

    aux_in_1 = Instrument.measurement(
        ""OAUX? 0"",
        """""" Reads the Aux input 1 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc1 = aux_in_1

    aux_in_2 = Instrument.measurement(
        ""OAUX? 1"",
        """""" Reads the Aux input 2 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc2 = aux_in_2

    aux_in_3 = Instrument.measurement(
        ""OAUX? 2"",
        """""" Reads the Aux input 3 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc3 = aux_in_3

    aux_in_4 = Instrument.measurement(
        ""OAUX? 3"",
        """""" Reads the Aux input 4 value in Volts with 1/3 mV resolution. """"""
    )
    # For consistency with other lock-in instrument classes
    adc4 = aux_in_4

    def snap(self, val1=""X"", val2=""Y"", val3=None):
        """"""retrieve 2 or 3 parameters at once
        parameters can be chosen by index, or enumeration as follows:

        +--------+-------------+------------------------+
        | index  | enumeration | parameter              |
        +========+=============+========================+
        | 0      | X           | X output               |
        +--------+-------------+------------------------+
        | 1      | Y           | Y output               |
        +--------+-------------+------------------------+
        | 2      | R           | R output               |
        +--------+-------------+------------------------+
        | 3      | THeta       | θ output               |
        +--------+-------------+------------------------+
        | 4      | IN1         | Aux In1                |
        +--------+-------------+------------------------+
        | 5      | IN2         | Aux In2                |
        +--------+-------------+------------------------+
        | 6      | IN3         | Aux In3                |
        +--------+-------------+------------------------+
        | 7      | IN4         | Aux In4                |
        +--------+-------------+------------------------+
        | 8      | XNOise      | Xnoise                 |
        +--------+-------------+------------------------+
        | 9      | YNOise      | Ynoise                 |
        +--------+-------------+------------------------+
        | 10     | OUT1        | Aux Out1               |
        +--------+-------------+------------------------+
        | 11     | OUT2        | Aux Out2               |
        +--------+-------------+------------------------+
        | 12     | PHAse       | Reference Phase        |
        +--------+-------------+------------------------+
        | 13     | SAMp        | Sine Out Amplitude     |
        +--------+-------------+------------------------+
        | 14     | LEVel       | DC Level               |
        +--------+-------------+------------------------+
        | 15     | FInt        | Int. Ref. Frequency    |
        +--------+-------------+------------------------+
        | 16     | FExt        | Ext. Ref. Frequency    |
        +--------+-------------+------------------------+

        :param val1: parameter enumeration/index
        :param val2: parameter enumeration/index
        :param val3: parameter enumeration/index (optional)

        Defaults:
            val1 = ""X""
            val2 = ""Y""
            val3 = None
        """"""
        if val3 is None:
            return self.values(
                command=f""SNAP? {val1}, {val2}"",
                separator="","",
                cast=float,
            )
        else:
            return self.values(
                command=f""SNAP? {val1}, {val2}, {val3}"",
                separator="","",
                cast=float,
            )

    gettimebase = Instrument.measurement(
        ""TBSTAT?"",
        """"""Returns the current 10 MHz timebase source.""""""
    )
    extfreqency = Instrument.measurement(
        ""FREQEXT?"",
        """"""Returns the external frequency in Hz.""""""
    )
    detectedfrequency = Instrument.measurement(
        ""FREQDET?"",
        """"""Returns the actual detected frequency in HZ.""""""
    )
    get_signal_strength_indicator = Instrument.measurement(
        ""ILVL?"",
        """"""Returns the signal strength indicator.""""""
    )
    get_noise_bandwidth = Instrument.measurement(
        ""ENBW?"",
        """"""Returns the equivalent noise bandwidth, in hertz.""""""
    )
    # Display Commands
    front_panel = Instrument.control(
        ""DBLK?"", ""DBLK %i"",
        """"""Turns the front panel blanking on(i=0) or off(i=1)."""""",
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    screen_layout = Instrument.control(
        ""DLAY?"", ""DLAY %i"",
        """"""A integer property that Sets the screen layout to trend(i=0), full strip chart
        history(i=1), half strip chart history(i=2), full FFT(i=3), half FFT(i=4) or big
        numerical(i=5)."""""",
        validator=strict_discrete_set,
        values=SCREEN_LAYOUT_VALUES,
        map_values=True
    )

    def screenshot(self):
        """"""Take screenshot on device
        The DCAP command saves a screenshot to a USB memory stick.
        This command is the same as pressing the [Screen Shot] key.
        A USB memory stick must be present in the front panel USB port.
        """"""
        self.write(""DCAP"")

    parameter_DAT1 = Instrument.control(
        ""CDSP? 0"", ""CDSP 0, %i"",
        """"""A integer property that assigns a parameter to data channel 1(green).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT2 = Instrument.control(
        ""CDSP? 1"", ""CDSP 1, %i"",
        """"""A integer property that assigns a parameter to data channel 2(blue).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT3 = Instrument.control(
        ""CDSP? 2"", ""CDSP 2, %i"",
        """"""A integer property that assigns a parameter to data channel 3(yellow).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    parameter_DAT4 = Instrument.control(
        ""CDSP? 3"", ""CDSP 3, %i"",
        """"""A integer property that assigns a parameter to data channel 3(orange).
        This parameters can be set. Allowed values are:{}"""""".format(LIST_PARAMETER),
        validator=strict_discrete_set,
        values=range(0, 16)
    )
    strip_chart_dat1 = Instrument.control(
        ""CGRF? 0"", ""CGRF 0, %i"",
        """"""A integer property that turns the strip chart graph of data channel 1 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat2 = Instrument.control(
        ""CGRF? 1"", ""CGRF 1, %i"",
        """"""A integer property that turns the strip chart graph of data channel 2 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat3 = Instrument.control(
        ""CGRF? 2"", ""CGRF 2, %i"",
        """"""A integer property that turns the strip chart graph of data channel 1 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    strip_chart_dat4 = Instrument.control(
        ""CGRF? 3"", ""CGRF 3, %i"",
        """"""A integer property that turns the strip chart graph of data channel 4 off(i=0) or on(i=1).
        """""",  # noqa: E501
        validator=strict_discrete_set,
        values=ON_OFF_VALUES,
        map_values=True
    )
    # Strip Chart commands
    horizontal_time_div = Instrument.control(
        ""GSPD?"", ""GSDP %i"",
        """"""A integer property for the horizontal time/div according to the following table:{}
        """""".format(LIST_HORIZONTAL_TIME_DIV),
        validator=strict_discrete_set,
        values=range(0, 16)
    )

    def __init__(self, adapter, name=""Stanford Research Systems SR860 Lock-in amplifier"",
                 **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
308,110.6,"Cleveland, Ohio, United States","The Model 2750 offers extended low ohms measurement capability and supports up to 5 7700 Switch cards for a maximum 200, 2-pole multiplexed channels. It also contains a built-in 20mV clamp that helps protect sensitive devices from damage and prevents self-heating errors during dry circuit testing.",Keithley 2700,260.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'attvnuMuhTf4JYn8N'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uaCeSM2dT68xSPssQ5gNxA/UCZCSh7nuCRY0MGn5laoUB39HK_CYTMdBLCXfgKpjTLcAspKAemkrMHAvdA5j6-aGY_1GkfyvKj-71Oc5W65efh0zL9AiSchdgM12kNfZnt_hBVYmzJqK2T-8FKJnoI5RYE1PCwfFtVGjjoAedw0DQ/NwgwFp0U00uEtsFGuk9FVtU979IyzgcmqkncZX-zM4A'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/668DbxvkTbkW-G7Jda_j7w/Ya71ZHvwMTl_nw5u9u6oOQwd3ZL0L4Z0ikswtlU-w-0Nfhn5ncl8yKKvmypSxuV4V72ztXIx0C6jta4yWUIHtA/B1s4A3KGJvRUSgwHsSUqhPaTL_rycE0QdBCdmQlZVYg'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kOvVYxrlr_RW02jIW-SeBQ/-AF4tmFE8hsVdJ0O3Yvsrn79vTaF-u5lRDYkcBS40TiCZrYi6dakfU5YwrhkhYQUrnCQBs2yLMPPyR-Wj8nAYg/lylasGkxpwmmCuNvNo9Dv1voO2PVO4wN7ie2Rio2vjI'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6XdHZgMxb50RY9Y_lgFnoA/Hj_6UuF7KX9nn-zAOqMlVyxWD-aBg5c-yCX0dh98zSCMWXu8mCM9-V9oN6ztKqp3_DwrEcWgQV8FcHsceEIb7A/GI4leNo00qgeSkCGrIwnCw6qK5o06yT4CEeyVCaDZHo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 2700 Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Keithley 2700,https://download.tek.com/datasheet/Series2700DAQSystemDataSheet.pdf,"[OrderedDict([('id', 'att9stL90e0gFUDnP'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yIMsO2tBJQWj9woF2Qr6_Q/8RZBKvKUDLDG7VAjgW5g-q1NwI22Sa1DASCnleW4cSdTwXtkpm5HvfSWI_XEAM8jnt5g05hrYOrP0x1ovxI2ED9YN8tKIEIQ0POXxWSejes/RGv94a7fxyBCgEzvTLxmYFvZc1msNpGnCgq-o7QCBGw'), ('filename', '2700.webp'), ('size', 9278), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ThHTk848qO5weiBiDnFyow/KXFn1iG0HgmrtFQDz8p7igchP9wADDAh7D85cNGMt_PITK3iI-LA1m2PwKcnDAheZb4h_lrdqGgDR2WXqhTHUPzFfmv7K6arGPWhAO2vJZc/Lk0968HXjonRz_I02ZxuXt94-FVwJB3g2vNY4UMqG34'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLzW2m87JC6crS7TXz0N5Q/OzmcuBzp8UDbGgDj7nEFPBh89XqvNs9qORcvLq7QcKvFyuFuYw49rhPyqPjIgYoEazb_ZtIAX6YEyBe_JbsNIby2auYm0KehvyMN10QpEdA/r-OFofJzjeG3wynihK3K4WBfFqbMcvjalSnsQo6YWQA'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KksPn3ZurMnPIVDh9mtfnA/r-4C1OS8oVCArPjD5QoJcDPyga2SzLEh2BRG6sj-7iq9QR9uQ33txEwirpSh2a2frH4018gqaKTtnpnx7FuGZ2lqHGF9wfm_nvGsbhWx5wI/8UgtdiXrHWJSKiYyS-_tA-asRD_l6avrAjFJFKwGp5I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/switching-and-data-acquisition-systems/2700-multimeter-data-acquisition-switch-system,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2700.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2700.html,4220.0,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument

from .buffer import KeithleyBuffer

import numpy as np
import time

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def clist_validator(value, values):
    """""" Provides a validator function that returns a valid clist string
    for channel commands of the Keithley 2700. Otherwise it raises a
    ValueError.

    :param value: A value to test
    :param values: A range of values (range, list, etc.)
    :raises: ValueError if the value is out of the range
    """"""
    # Convert value to list of strings
    if isinstance(value, str):
        clist = [value.strip("" @(),"")]
    elif isinstance(value, (int, float)):
        clist = [f""{value:d}""]
    elif isinstance(value, (list, tuple, np.ndarray, range)):
        clist = [f""{x:d}"" for x in value]
    else:
        raise ValueError(f""Type of value ({type(value)}) not valid"")

    # Pad numbers to length (if required)
    clist = [c.rjust(2, ""0"") for c in clist]
    clist = [c.rjust(3, ""1"") for c in clist]

    # Check channels against valid channels
    for c in clist:
        if int(c) not in values:
            raise ValueError(
                f""Channel number {value:g} not valid.""
            )

    # Convert list of strings to clist format
    clist = ""(@{:s})"".format("", "".join(clist))

    return clist


def text_length_validator(value, values):
    """""" Provides a validator function that a valid string for the display
    commands of the Keithley. Raises a TypeError if value is not a string.
    If the string is too long, it is truncated to the correct length.

    :param value: A value to test
    :param values: The allowed length of the text
    """"""

    if not isinstance(value, str):
        raise TypeError(""Value is not a string."")

    return value[:values]


class Keithley2700(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2700 Multimeter/Switch System and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2700(""GPIB::1"")

    """"""

    CLIST_VALUES = list(range(101, 300))

    # Routing commands
    closed_channels = Instrument.control(
        ""ROUTe:MULTiple:CLOSe?"", ""ROUTe:MULTiple:CLOSe %s"",
        """""" Parameter that controls the opened and closed channels.
        All mentioned channels are closed, other channels will be opened.
        """""",
        validator=clist_validator,
        values=CLIST_VALUES,
        check_get_errors=True,
        check_set_errors=True,
        separator=None,
        get_process=lambda v: [
            int(vv) for vv in (v.strip("" ()@,"").split("","")) if not vv == """"
        ],
    )

    open_channels = Instrument.setting(
        ""ROUTe:MULTiple:OPEN %s"",
        """""" A parameter that opens the specified list of channels. Can only
        be set.
        """""",
        validator=clist_validator,
        values=CLIST_VALUES,
        check_set_errors=True
    )

    def get_state_of_channels(self, channels):
        """""" Get the open or closed state of the specified channels

        :param channels: a list of channel numbers, or single channel number
        """"""
        clist = clist_validator(channels, self.CLIST_VALUES)
        state = self.ask(""ROUTe:MULTiple:STATe? %s"" % clist)

        return state

    def open_all_channels(self):
        """""" Open all channels of the Keithley 2700.
        """"""
        self.write("":ROUTe:OPEN:ALL"")

    def __init__(self, adapter, name=""Keithley 2700 MultiMeter/Switch System"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

        self.check_errors()
        self.determine_valid_channels()

    def determine_valid_channels(self):
        """""" Determine what cards are installed into the Keithley 2700
        and from that determine what channels are valid.
        """"""
        self.CLIST_VALUES.clear()

        self.cards = {slot: card for slot, card in enumerate(self.options, 1)}

        for slot, card in self.cards.items():

            if card == ""none"":
                continue
            elif card == ""7709"":
                """"""The 7709 is a 6(rows) x 8(columns) matrix card, with two
                additional switches (49 & 50) that allow row 1 and 2 to be
                connected to the DMM backplane (input and sense respectively).
                """"""
                channels = range(1, 51)
            else:
                log.warning(
                    f""Card type {card} at slot {slot} is not yet implemented.""
                )
                continue

            channels = [100 * slot + ch for ch in channels]

            self.CLIST_VALUES.extend(channels)

    def close_rows_to_columns(self, rows, columns, slot=None):
        """""" Closes (connects) the channels between column(s) and row(s)
        of the 7709 connection matrix.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used
        """"""

        channels = self.channels_from_rows_columns(rows, columns, slot)
        self.closed_channels = channels

    def open_rows_to_columns(self, rows, columns, slot=None):
        """""" Opens (disconnects) the channels between column(s) and row(s)
        of the 7709 connection matrix.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used
        """"""

        channels = self.channels_from_rows_columns(rows, columns, slot)
        self.open_channels = channels

    def channels_from_rows_columns(self, rows, columns, slot=None):
        """""" Determine the channel numbers between column(s) and row(s) of the
        7709 connection matrix. Returns a list of channel numbers.
        Only one of the parameters 'rows' or 'columns' can be ""all""

        :param rows: row number or list of numbers; can also be ""all""
        :param columns: column number or list of numbers; can also be ""all""
        :param slot: slot number (1 or 2) of the 7709 card to be used

        """"""

        if slot is not None and self.cards[slot] != ""7709"":
            raise ValueError(""No 7709 card installed in slot %g"" % slot)

        if isinstance(rows, str) and isinstance(columns, str):
            raise ValueError(""Only one parameter can be 'all'"")
        elif isinstance(rows, str) and rows == ""all"":
            rows = list(range(1, 7))
        elif isinstance(columns, str) and columns == ""all"":
            columns = list(range(1, 9))

        if isinstance(rows, (list, tuple, np.ndarray)) and \
                isinstance(columns, (list, tuple, np.ndarray)):

            if len(rows) != len(columns):
                raise ValueError(""The length of the rows and columns do not match"")

            # Flatten (were necessary) the arrays
            new_rows = []
            new_columns = []
            for row, column in zip(rows, columns):
                if isinstance(row, int) and isinstance(column, int):
                    new_rows.append(row)
                    new_columns.append(column)
                elif isinstance(row, (list, tuple, np.ndarray)) and isinstance(column, int):
                    new_columns.extend(len(row) * [column])
                    new_rows.extend(list(row))
                elif isinstance(column, (list, tuple, np.ndarray)) and isinstance(row, int):
                    new_columns.extend(list(column))
                    new_rows.extend(len(column) * [row])

            rows = new_rows
            columns = new_columns

        # Determine channel number from rows and columns number.
        rows = np.array(rows, ndmin=1)
        columns = np.array(columns, ndmin=1)

        channels = (rows - 1) * 8 + columns

        if slot is not None:
            channels += 100 * slot

        return channels

    # system, some taken from Keithley 2400
    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2700 reported error: %d, %s"" % (code, message))
            print(code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2700 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    options = Instrument.measurement(
        ""*OPT?"",
        """"""Property that lists the installed cards in the Keithley 2700.
        Returns a dict with the integer card numbers on the position."""""",
        cast=False
    )

    ###########
    # DISPLAY #
    ###########

    text_enabled = Instrument.control(
        ""DISP:TEXT:STAT?"", ""DISP:TEXT:STAT %d"",
        """""" A boolean property that controls whether a text message can be
        shown on the display of the Keithley 2700.
        """""",
        values={True: 1, False: 0},
        map_values=True,
    )
    display_text = Instrument.control(
        ""DISP:TEXT:DATA?"", ""DISP:TEXT:DATA '%s'"",
        """""" A string property that controls the text shown on the display of
        the Keithley 2700. Text can be up to 12 ASCII characters and must be
        enabled to show.
        """""",
        validator=text_length_validator,
        values=12,
        cast=str,
        separator=""NO_SEPARATOR"",
        get_process=lambda v: v.strip(""'\""""),
    )

    def display_closed_channels(self):
        """""" Show the presently closed channels on the display of the Keithley
        2700.
        """"""

        # Get the closed channels and make a string of the list
        channels = self.closed_channels
        channel_string = "" "".join([
            str(channel % 100) for channel in channels
        ])

        # Prepend ""Closed: "" or ""C: "" to the string, depending on the length
        str_length = 12
        if len(channel_string) < str_length - 8:
            channel_string = ""Closed: "" + channel_string
        elif len(channel_string) < str_length - 3:
            channel_string = ""C: "" + channel_string

        # enable displaying text-messages
        self.text_enabled = True

        # write the string to the display
        self.display_text = channel_string
"
315,5420.0,USA,"The single output, 1500 W N5767A, provides universal AC input, GPIB, LAN, USB, LXI compliance, and analog/resistance control of output voltage and current. It delivers reliable performance and enhanced capabilities in a compact 1U package.",Keysightn 5767a,318.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Pymeasure,Keysight,"[OrderedDict([('id', 'att0DZYgk9msHCxq0'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/guSbX_sW5Auu_s1LF9Dvnw/Bv8-q7w-Rnp4plrqqRESX7B6ZpiB2dj4GlIY5-mgMRQDcBhXHTAOSUMCgqeN4-8pElnqAh5EGNvPwt3AqTUB_daa8iOgvr7iFh_VgMs8HjQ/duDwTwAStYcEw16xLIb9tgQI4z_Hlih6inEin_4xQ4U'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/v9iqCIZNa1Zxv-WbaWEHeg/11OIBEfjzx4r9QoZ4L64WUebrtyEUIlbmvEbS_Pgdwbw0WTObrOt-dT0Ckuea2y53cTrtsEM8DdU3FaDrDYp8dBHErX_Jo7msptg8BPtFAI/yuN4vCh0mhgx3SrSXbez09LKDsCPOuRQWd4YQUaknV8'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kN4b7UOhjQ5QZPacNCYXyg/jjXg3ZI8Iv3ZyzzUJXMRdK_wFEAf8m2jpTGmYzx1I-KIrNYwHz7fIslPCqHAhe-rmCaUTPuz8B5QIWXUHjpx5QLfsfQdYeMM9Tzs4U147Pc/43h-YGcgp_W3bTU3QVuOzL7Ca03Z-V5c7LFlQ67_OeE'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cIEuAzpNr0pTk74bbP19qQ/zz0CdgA1avOTwqul6m296z597BGTWU-wfVeYQIj3fI5pZdQ2qMaEFTRGmL35bGmwAUa-6Yvb_YmOhAD7YibzyYCPg1XVjy-MZ0UEkjDayWo/KFp5UWocF6WYmkAOU4ZqIpvhtBqhu6zJ-DUn7QH7sTc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT N5767A Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",KEYSIGHT N5767A,https://www.keysight.com/us/en/assets/7018-01235/data-sheets/5989-1330.pdf,"[OrderedDict([('id', 'attRSrjrFB1ceymam'), ('width', 1584), ('height', 1584), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/shK1n525Dh6c0cmEzX52-g/0I1ck9J318EaWZ6VqgPou0f2j1ijGutIqFq0tgV848OIlN8MXJCslzYS-uTq_BXHTMsoeArsJLbOV7UnvJzYbEOMAZqg3z490CUJdItl7jg/76Y1oQotuAgoSSZTVt5UUgmyp5Tammvn3ltPRQiIO8Q'), ('filename', 'KTAN5767A.webp'), ('size', 26910), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/beYIgNd1HRhuAlssiJiaOw/Ig1-dWgPWVilOo38geC9kK5lEozh-_rPrmWiN05-E08bFwRqdKDeocEkl2T1g9c8Zld9ORJkS9_a7EZHzr90CNiikdQE4TSxkYZZp3fxvq0/prwoDk5PAgRUnujMhni0PysiN9R8zS22nXu9eW_SVPA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dP1MMInoeFJo5s2s3sfL6g/8oDBflSp46kTQePAxOorPpZ5PadMIVo6zCrEl8dn03EREuRK-XLG4Lq4YuyutWUxWBYcQtITLQ_-zVanOYWpS8F6YrCrVaqPKS9PbWbtWxE/mLmI6kUNzjX7DOJXs5IFsfP65d21ros4dieYnjluo44'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vK54iSfbQj6yNwo5Fgd3Xg/Vk-yCQvG8CLhIgPzdCOvn8mOdMfxio9Mujma6JwIpOiII-xli1Q6BjeI9pXKITeQTWBBuS3A6WfntE_18qX1tMwkUn1PttCm-YxJvhccy3Q/LeIFDjcW58Iokewlhe-VZNp6dh3-aINR13H8A8rxGhk'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/N5767A/power-supply-60v-25a-1500w.html#:~:text=The%20single%20output%2C%201500%20W%20N5767A%2C%20provides%20universal%20AC%20input,free%20to%20control%20your%20instruments.",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keysight/keysightN5767A.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keysight/keysightN7776C.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range

from pymeasure.adapters import VISAAdapter

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class KeysightN5767A(Instrument):
    """""" Represents the Keysight N5767A Power supply
    interface for interacting with the instrument.
    """"""
    ###############
    # Current (A) #
    ###############
    current_range = Instrument.control(
        "":CURR?"", "":CURR %g"",
        """""" A floating point property that controls the DC current range in
        Amps, which can take values from 0 to 25 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 25],
    )

    current = Instrument.measurement("":MEAS:CURR?"",
                                     """""" Reads a setting current in Amps. """"""
                                     )

    ###############
    # Voltage (V) #
    ###############
    voltage_range = Instrument.control(
        "":VOLT?"", "":VOLT %g V"",
        """""" A floating point property that controls the DC voltage range in
        Volts, which can take values from 0 to 60 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 60]
    )

    voltage = Instrument.measurement(""MEAS:VOLT?"",
                                     """""" Reads a DC voltage measurement in Volts. """"""
                                     )

    #################
    # _status (0/1) #
    #################
    _status = Instrument.measurement("":OUTP?"",
                                     """""" Read power supply current output status. """""",
                                     )

    def enable(self):
        """""" Enables the flow of current.
        """"""
        self.write("":OUTP 1"")

    def disable(self):
        """""" Disables the flow of current.
        """"""
        self.write("":OUTP 0"")

    def is_enabled(self):
        """""" Returns True if the current supply is enabled.
        """"""
        return bool(self._status)

    def __init__(self, adapter, name=""Keysight N5767A power supply"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
        # Set up data transfer format
        if isinstance(self.adapter, VISAAdapter):
            self.adapter.config(
                is_binary=False,
                datatype='float32',
                converter='f',
                separator=','
            )
"
323,110.6,"Cleveland, Ohio, United States","The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",Keithley 2450,217.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 2450 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2450,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zcMA96mtJXYCOkb6kupHvQ/1ps5TsoRXCKsgqMySssYHoFSmhIRx4aO-XnriClXx2hps3be9sz0iHDjxaiFc2bdN99oaalDnhvz83JRJ2LXAg/J1L5e2oVFP6WmjIXtPMyOo7kKZDtigkNccvN0QWJA34'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ESnqh5TwnjrQtEeabYPoKQ/gk-ujrmURPBE0ke1R-mZFeYnploc5mrcLGXwHxpcXfGfOItUvhXTJ1KRqyYJLMLNoSMzDToglmnmEQjpZsdwTg/qTqGV6hlOyYZ6j4G7XL77nIdu-oeP4zuKe9dbycKwEs'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Y0IFHnD1gpxXWlPcN-aBbQ/RlwATNebPwv7UNuAkR02xj2TEzcSh2Ye-f3e9d3lzb121zFJXuYOGNpgR-1F3aCyWbF7GgrgiOPmwozG206Egg/EBNyEc-Z__pKX6YJcEGkA5oqXfg9V0_TPk-5cMCIkb4'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V2pJhiB2HJsrbTpZR7Dp7A/T_kRNu7Kg6c6wkrPBNFQGCjoxUfansX8IVfb2CJkIAHvd4S9I2WVDht-qUlbycmblE2XD4ztWCmchWmJeTZ5QQ/Kx6THN0HbSzRC4X-fUuyOxlQhk-jZ_QK51SSOiIvs40'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2450.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2450.html,9549.3,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set
from .buffer import KeithleyBuffer

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2450(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2450 SourceMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley2450(""GPIB::1"")

        keithley.apply_current()                # Sets up to source current
        keithley.source_current_range = 10e-3   # Sets the source current range to 10 mA
        keithley.compliance_voltage = 10        # Sets the compliance voltage to 10 V
        keithley.source_current = 0             # Sets the source current to 0 mA
        keithley.enable_source()                # Enables the source output

        keithley.measure_voltage()              # Sets up to measure voltage

        keithley.ramp_to_current(5e-3)          # Ramps the current to 5 mA
        print(keithley.voltage)                 # Prints the voltage in Volts

        keithley.shutdown()                     # Ramps the current to 0 mA and disables output

    """"""

    source_mode = Instrument.control(
        "":SOUR:FUNC?"", "":SOUR:FUNC %s"",
        """""" A string property that controls the source mode, which can
        take the values 'current' or 'voltage'. The convenience methods
        :meth:`~.Keithley2450.apply_current` and :meth:`~.Keithley2450.apply_voltage`
        can also be used. """""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        map_values=True
    )

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads the current in Amps, if configured for this reading.
        """"""
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    compliance_current = Instrument.control(
        "":SOUR:VOLT:ILIM?"", "":SOUR:VOLT:ILIM %g"",
        """""" A floating point property that controls the compliance current
        in Amps. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR:LEV %g"",
        """""" A floating point property that controls the source current
        in Amps. """"""
    )

    source_current_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -1.05 and +1.05 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1.05, 1.05]
    )

    source_current_delay = Instrument.control(
        "":SOUR:CURR:DEL?"", "":SOUR:CURR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_current_delay_auto = Instrument.control(
        "":SOUR:CURR:DEL:AUTO?"", "":SOUR:CURR:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """"""
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    compliance_voltage = Instrument.control(
        "":SOUR:CURR:VLIM?"", "":SOUR:CURR:VLIM %g"",
        """""" A floating point property that controls the compliance voltage
        in Volts. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -210 to 210 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-210, 210]
    )

    source_voltage_delay = Instrument.control(
        "":SOUR:VOLT:DEL?"", "":SOUR:VOLT:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 0 [seconds] and 999.9999 [seconds]."""""",
        validator=truncated_range,
        values=[0, 999.9999],
    )

    source_voltage_delay_auto = Instrument.control(
        "":SOUR:VOLT:DEL:AUTO?"", "":SOUR:VOLT:DEL:AUTO %d"",
        """""" A boolean property that enables or disables auto delay. Valid
        values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """"""
    )

    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 210 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 210e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )

    wires = Instrument.control(
        "":SENS:RES:RSENSE?"", "":SENS:RES:RSENSE %d"",
        """""" An integer property that controls the number of wires in
        use for resistance measurements, which can take the value of
        2 or 4.
        """""",
        validator=strict_discrete_set,
        values={4: 1, 2: 0},
        map_values=True
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    means = Instrument.measurement(
        "":TRACe:STATistics:AVERage?"",
        """""" Reads the calculated means (averages) for voltage,
        current, and resistance from the buffer data  as a list. """"""
    )

    maximums = Instrument.measurement(
        "":TRACe:STATistics:MAXimum?"",
        """""" Returns the calculated maximums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    minimums = Instrument.measurement(
        "":TRACe:STATistics:MINimum?"",
        """""" Returns the calculated minimums for voltage, current, and
        resistance from the buffer data as a list. """"""
    )

    standard_devs = Instrument.measurement(
        "":TRACe:STATistics:STDDev?"",
        """""" Returns the calculated standard deviations for voltage,
        current, and resistance from the buffer data as a list. """"""
    )

    ###########
    # Filters #
    ###########

    current_filter_type = Instrument.control(
        "":SENS:CURR:AVER:TCON?"", "":SENS:CURR:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    current_filter_count = Instrument.control(
        "":SENS:CURR:AVER:COUNT?"", "":SENS:CURR:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    current_filter_state = Instrument.control(
        "":SENS:CURR:AVER?"", "":SENS:CURR:AVER %s"",
        """""" A string property that controls if the filter is active."""""",
        validator=strict_discrete_set,
        values=['ON', 'OFF'],
        map_values=False)

    voltage_filter_type = Instrument.control(
        "":SENS:VOLT:AVER:TCON?"", "":SENS:VOLT:AVER:TCON %s"",
        """""" A String property that controls the filter's type for the current.
        REP : Repeating filter
        MOV : Moving filter"""""",
        validator=strict_discrete_set,
        values=['REP', 'MOV'],
        map_values=False)

    voltage_filter_count = Instrument.control(
        "":SENS:VOLT:AVER:COUNT?"", "":SENS:VOLT:AVER:COUNT %d"",
        """""" A integer property that controls the number of readings that are
        acquired and stored in the filter buffer for the averaging"""""",
        validator=truncated_range,
        values=[1, 100],
        cast=int)

    #####################
    # Output subsystem #
    #####################

    current_output_off_state = Instrument.control(
        "":OUTP:CURR:SMOD?"", "":OUTP:CURR:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    voltage_output_off_state = Instrument.control(
        "":OUTP:VOLT:SMOD?"", "":OUTP:VOLT:SMOD %s"",
        """""" Select the output-off state of the SourceMeter.
        HIMP : output relay is open, disconnects external circuitry.
        NORM : V-Source is selected and set to 0V, Compliance is set to 0.5%
        full scale of the present current range.
        ZERO : V-Source is selected and set to 0V, compliance is set to the
        programmed Source I value or to 0.5% full scale of the present current
        range, whichever is greater.
        GUAR : I-Source is selected and set to 0A"""""",
        validator=strict_discrete_set,
        values=['HIMP', 'NORM', 'ZERO', 'GUAR'],
        map_values=False)

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 2450 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms, from -210 MOhms to 210 MOhms
        :param auto_range: Enables auto_range if True, else uses the set resistance
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -210 V to 210 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -1.05 A to 1.05 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write("":SOUR:CURR:RANG:AUTO 1"")
        else:
            self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_current(self, current_range=None,
                      compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.

        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2450.current_range` value or None
        """"""
        log.info(""%s is sourcing current."", self.name)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.

        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2450.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2450.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2450 reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2450 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_current(self, target_current, steps=30, pause=20e-3):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        currents = np.linspace(
            self.source_current,
            target_current,
            steps
        )
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger.
        """"""
        return self.write(""*TRG"")

    @property
    def mean_voltage(self):
        """""" Returns the mean voltage from the buffer """"""
        return self.means[0]

    @property
    def max_voltage(self):
        """""" Returns the maximum voltage from the buffer """"""
        return self.maximums[0]

    @property
    def min_voltage(self):
        """""" Returns the minimum voltage from the buffer """"""
        return self.minimums[0]

    @property
    def std_voltage(self):
        """""" Returns the voltage standard deviation from the buffer """"""
        return self.standard_devs[0]

    @property
    def mean_current(self):
        """""" Returns the mean current from the buffer """"""
        return self.means[1]

    @property
    def max_current(self):
        """""" Returns the maximum current from the buffer """"""
        return self.maximums[1]

    @property
    def min_current(self):
        """""" Returns the minimum current from the buffer """"""
        return self.minimums[1]

    @property
    def std_current(self):
        """""" Returns the current standard deviation from the buffer """"""
        return self.standard_devs[1]

    @property
    def mean_resistance(self):
        """""" Returns the mean resistance from the buffer """"""
        return self.means[2]

    @property
    def max_resistance(self):
        """""" Returns the maximum resistance from the buffer """"""
        return self.maximums[2]

    @property
    def min_resistance(self):
        """""" Returns the minimum resistance from the buffer """"""
        return self.minimums[2]

    @property
    def std_resistance(self):
        """""" Returns the resistance standard deviation from the buffer """"""
        return self.standard_devs[2]

    def use_rear_terminals(self):
        """""" Enables the rear terminals for measurement, and
        disables the front terminals. """"""
        self.write("":ROUT:TERM REAR"")

    def use_front_terminals(self):
        """""" Enables the front terminals for measurement, and
        disables the rear terminals. """"""
        self.write("":ROUT:TERM FRON"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
332,110.6,"Cleveland, Ohio, United States","The 2750 offers a cost-effective, high performance, affordable alternatives to separate digital multimeters and switch systems, dataloggers/recorders, plug-in card data acquisition equipment, and VXI/PXI systems. System builders can create test solutions with a combination of channel count, cost per channel, and system performance unmatched by any other singlebox measurement system. The input modules provide the flexibility to vary the channel count from 20 to 200 (2-pole), apply a stimulus to the device under test, route signals, control system components, and make precision measurements with up to 14 functions. Robust digital I/O capabilities can be used for triggering, handshaking with other automation equipment, and alarm limit outputs. Scan rates of up to 500 channels/second (up to 3500 readings/second on a single channel) will increase test productivity.",Keithley 2750,259.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 2750 Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Keithley 2750,https://www.farnell.com/datasheets/1484285.pdf,"[OrderedDict([('id', 'attWJFDYwrGd2bp0z'), ('width', 320), ('height', 181), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6-4sND0KjR9Pr3l6MV7Ccw/Dxct7y6eJs9i8s3_ShY2i2Z69bkreNbNCSD-RiuEDbSCLl0nxfWoHJw5Mwd2HfJQ7Vcb9qB9Ezo26v6Xm6I9VI1LgZgsw-UsOxuY84JtdCk/QziGHSY5ait_fTwUYybpvhdS7VXWNive6_a5hVN5Xvs'), ('filename', '2750.webp'), ('size', 3144), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FVBykoYtR4jA_V9OgC8P7Q/CgsRkelTHvIU3yn8HS4LV8JjNlAyYO5_A2f_kGyILgJYIgfUnjgQEpwBROy4ju18QUl9MtHuEwN9DttFuC79_kNDd57YGm9Z0F_5gS04710/1kQOttdNFr9F5PMUu8ppqW3xHtWOvn3HUP8LglOhfb0'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oSgzoVbTtKFkKstBasczww/JcA_JdogTBDa1M06X-c8Zv5cPC9cqNrOQ9OejrtqeeMG5ErXSN_ZB3PcG86mGufswkeBtfNjH6HrHG0MSEJkkvYq92e6afCCk1PW9OqhNhc/24VJsGrvVrWtdHzluccz63E5CtdafgzaZQdwPJQyVAU'), ('width', 320), ('height', 181)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WZOkovXKFyuhrqU_4DOaHw/oDXJn6OoiiGTV2BJRbja3FTdm0_7MD6Ovji7WRtsEHQFnfXL66GkTNOMaalV5-oQvB4NiYlFi4Sbz369RJHERIruqJ588PrxXhPSIezuljs/V3ZWvAsgI5BEYR6B135aos2_LcALB8ZVIKnlM2_-9es'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newark.com/keithley/2750/digital-multimeter-dmm-data-acq/dp/11J1599?pf_custSiteRedirect=true,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2750.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2750.html,4220.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


def clean_closed_channels(output):
    """"""Cleans up the list returned by command "":ROUTe:CLOSe?"", such that each entry is an integer
    denoting the channel number.
    """"""
    if isinstance(output, str):
        s = output.replace(""("", """").replace("")"", """").replace(""@"", """")
        if s == """":
            return []
        else:
            return [int(s)]
    elif isinstance(output, list):
        list_final = []
        for i, entry in enumerate(output):
            if isinstance(entry, float) or isinstance(entry, int):
                list_final += [int(entry)]
            elif isinstance(entry, str):
                list_final += [int(entry.replace(""("", """").replace("")"", """").replace(""@"", """"))]
            else:
                raise ValueError(""Every entry must be a string, float, or int"")
            assert isinstance(list_final[i], int)
        return list_final
    else:
        raise ValueError(""`output` must be a string or list."")


class Keithley2750(Instrument):
    """""" Represents the Keithley2750 multimeter/switch system and provides a high-level interface for
    interacting with the instrument.
    """"""

    closed_channels = Instrument.measurement("":ROUTe:CLOSe?"",
                                             ""Reads the list of closed channels"",
                                             get_process=clean_closed_channels)

    def __init__(self, adapter, name=""Keithley 2750 Multimeter/Switch System"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def open(self, channel):
        """""" Opens (disconnects) the specified channel.

        :param int channel: 3-digit number for the channel
        :return: None
        """"""
        self.write(f"":ROUTe:MULTiple:OPEN (@{channel})"")

    def close(self, channel):
        """""" Closes (connects) the specified channel.

        :param int channel: 3-digit number for the channel
        :return: None
        """"""
        # Note: if `MULTiple` is omitted, then the specified channel will close,
        # but all other channels will open.
        self.write(f"":ROUTe:MULTiple:CLOSe (@{channel})"")

    def open_all(self):
        """""" Opens (disconnects) all the channels on the switch matrix.

        :return: None
        """"""
        self.write("":ROUTe:OPEN:ALL"")
"
333,110.6,"Cleveland, Ohio, United States","Source a wide range of voltages and currents with the 360W, 720W, or 1080W Series 2260B Programmable DC Power Supplies. The 360W versions can output current of 36A, 13.5A, 4.5A, or 1.44A; the 720W models can output 72A, 27A, 9A, or 2.88A; and the 1080W instruments can output 108A, 40.5A, 13.5A or 4.32A. This wide range of output voltages and current, combined with multiple interface choices, makes the Series 2260B ideal for use in a wide range of applications, including research and design, quality control, and production test.",Keithley 2260 B,202.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 2260B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2260B,https://download.tek.com/datasheet/1KW-73968-1_2260B_Programmable_DC_Power_Supplies_Datasheet_102122.pdf,"[OrderedDict([('id', 'att1UqqckwapnISx1'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wj6IJbCOvf0MdtR5p8uJxQ/j5IJqJNAPyUTtWkYwBMRa0l15_e8A4aSLUxrCHNaafXDnEbMb0o3Ka87QnQ6bx6KliTxUfPvk8XEvlnGvLEdwbtH_6YpUw73bqIRiHxGy0E/a1iirQP6-eJE9RBeXfirWRproD2IocJF9b27RcKEHAc'), ('filename', '2260b.webp'), ('size', 14758), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rysinjp_mtsrCAJ5EZ2cfw/rOJOdPfulw4JA_A5iNqgnXbxK4heYsF-Rr-U1dqCdda2a_x69msCaDymU5EHHNxFXkIQqUl6Ad10UMaEATCij7Ny7bl31ousuCjUinGzQg4/LeA5Qs3gMpR1On_ZBapMNjPa-z6ju0FyetYAFOWAzLU'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nhw-ZG3FzP9vsh3he1xXtA/zguj4UvFNhl6rpN96W7xpOi4UVKsIyDoEQFOIua86sKpdBFyFV2g5vpBO40iOL4dgZLtPApu14YwPZAm9TbIY8gCCa5Gicmv8OFU0zN4Ots/KE1Dv3OVAB-FzgSY_wgg9HhJ-l55O6JPOQP3udCEx-c'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7FB9QJWTj1B1_3HL5HZp0A/uWX5vd9K6bfHrjuiTM4BH2W4Ndr0bEmvI9fKy6B5LBCteUdVdRmdRtkFO45p2JA49LsrMnnABxFwqJSZzs-jYNhanBxmowxPyTyoRig-H6Y/8WO0QykCprG3EAvI1A3iXN2jwN6YlY5UYAtrZpR918s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/dc-power-supplies/2260b-series,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2260B.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2260B.html,2110.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set

import time
import logging

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2260B(Instrument):
    """""" Represents the Keithley 2260B Power Supply (minimal implementation)
    and provides a high-level interface for interacting with the instrument.

    For a connection through tcpip, the device only accepts
    connections at port 2268, which cannot be configured otherwise.
    example connection string: 'TCPIP::xxx.xxx.xxx.xxx::2268::SOCKET'
    the read termination for this interface is \n

    .. code-block:: python

        source = Keithley2260B(""GPIB::1"")
        source.voltage = 1
        print(source.voltage)
        print(source.current)
        print(source.power)
        print(source.applied)
    """"""

    def __init__(self, adapter, name=""Keithley 2260B DC Power Supply"",
                 read_termination=""\n"", **kwargs):
        super().__init__(
            adapter,
            name,
            read_termination=read_termination,
            **kwargs
        )

    output_enabled = Instrument.control(
        ""OUTPut?"",
        ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True,
    )

    current_limit = Instrument.control(
        "":SOUR:CURR?"",
        "":SOUR:CURR %g"",
        """"""A floating point property that controls the source current
        in amps. This is not checked against the allowed range. Depending on
        whether the instrument is in constant current or constant voltage mode,
        this might differ from the actual current achieved."""""",
    )

    voltage_setpoint = Instrument.control(
        "":SOUR:VOLT?"",
        "":SOUR:VOLT %g"",
        """"""A floating point property that controls the source voltage
        in volts. This is not checked against the allowed range. Depending on
        whether the instrument is in constant current or constant voltage mode,
        this might differ from the actual voltage achieved."""""",
    )

    power = Instrument.measurement(
        "":MEAS:POW?"",
        """"""Reads the power (in Watt) the dc power supply is putting out.
        """""",
    )

    voltage = Instrument.measurement(
        "":MEAS:VOLT?"",
        """"""Reads the voltage (in Volt) the dc power supply is putting out.
        """""",
    )

    current = Instrument.measurement(
        "":MEAS:CURR?"",
        """"""Reads the current (in Ampere) the dc power supply is putting out.
        """""",
    )

    applied = Instrument.control(
        "":APPly?"",
        "":APPly %g,%g"",
        """"""Simultaneous control of voltage (volts) and current (amps).
        Values need to be supplied as tuple of (voltage, current). Depending on
        whether the instrument is in constant current or constant voltage mode,
        the values achieved by the instrument will differ from the ones set.
        """""",
    )

    @property
    def enabled(self):
        log.warning('Deprecated property name ""enabled"", use the identical ""output_enabled"", '
                    'instead.', FutureWarning)
        return self.output_enabled

    @enabled.setter
    def enabled(self, value):
        log.warning('Deprecated property name ""enabled"", use the identical ""output_enabled"", '
                    'instead.', FutureWarning)
        self.output_enabled = value

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', """")
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2260B reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2260B error retrieval."")

    def shutdown(self):
        """""" Disable output, call parent function""""""
        self.output_enabled = False
        super().shutdown()
"
341,2500.0,"Munich, Germany",The Rohde & Schwarz HMP4040 power supply belongs to the HMP series and has 4 channels and a power of 384W. All four channels have an output voltage of 0-32V and an output current of 0-10A.,HMP 4040,469.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Pymeasure,Rohdes And Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,https://www.farnell.com/datasheets/3677014.pdf,"[OrderedDict([('id', 'att0tCSR9EFjatbkU'), ('width', 520), ('height', 380), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oyoCtuyT-JqFCHAGgHCqKg/J--p6nhhIR7F4I2xDQPjR1JB_DQM1rXJxrK4sZe2MTJpedBTy9RuLhpKB7A2-NUqCWEjcyYnvM4saIbaMAmidA/Su9oUJ24HEqDU4u1mqRko5ciiKnH9ycrCG1zoWDNAU4'), ('filename', '4040.jpg'), ('size', 39656), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1jngclwiVWbw_0OQ9lR-TA/9B386uX6jqRD4KKT8upSeiWjnKgyuWP7NyxCO2yL-L_DDuZFLXYjLnu1xmWJmUv8CIz4TmVz5TwFeaQbMVvJNQ/VeFKPgI0BQZu7hm-HuR-hTgEuFKUYDhtQ8tLycvh5nM'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Z4VeFWGi57yxaTU3Bu1aiQ/utyZC0nn48dKTjhJiZElAqG-NU4LL-zbh_nwAqCT_mz-b-HRhkZTxta3KI76zYGoqF60anJ7oiAKezP4i0McvQ/t0wqikoJXf1PhCUw7FgLJzZIeN0BBSAGjjR_2dJWry8'), ('width', 520), ('height', 380)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NmGdNTVd-L05fhRyTLBqCQ/KYERIlADBFfWdsaiwXaUHr-U6T6b1hrhrdumR0Wf5Zqd-FwhRDkWoKEa2O7tdMXJsevXh2N3UQXnM28Y0leyKA/W7ky3kHt5cOiLxOWjDlSopUmEL6jNvLJAjlAFunIUe8'), ('width', 3000), ('height', 3000)]))]))])]","https://eleshop.eu/rohde-schwarz-hmp40.html#:~:text=Details,are%20programmable%20DC%20power%20supplies.",https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/rohdeschwarz/hmp.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/rohdeschwarz/hmp.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (strict_discrete_set,
                                              truncated_range)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


def process_sequence(sequence):
    """"""
    Check and prepare sequence data.

    :param sequence: Sequence data, in the form [voltage1, current1, time1,
        voltage2, current2, time2, ..., voltage128, current128, time128] with
        voltages in V, currents in A, and times in s. Dwell times are between
        0.06 and 10 s.
    :type sequence: list of float
    :return: Sequence data in the form ""Voltage1,Current1,Time1,Voltage2,
        Current2,Time2,...,Voltage128,Current128,Time128""
    :rtype: str
    """"""
    if not len(sequence) % 3 == 0:
        raise ValueError(""Sequence must contain multiple of 3 values."")
    if any(t > 10 or t < 0.06 for t in sequence[2::3]):
        raise ValueError(""Dwell times must be between 0.06 and 10 s."")
    # turn sequence data into a string
    sequence = "","".join(str(s) for s in sequence)
    return sequence


class HMP4040(Instrument):
    """"""Represents a Rohde&Schwarz HMP4040 power supply.""""""

    def __init__(self, adapter, **kwargs):
        kwargs.setdefault(""name"", ""Rohde&Schwarz HMP4040"")
        super().__init__(
            adapter, includeSCPI=True, **kwargs
        )

    # System Setting Commands -------------------------------------------------

    def beep(self):
        """"""Emit a single beep from the instrument.""""""
        self.write(""SYST:BEEP"")

    control_method = Instrument.setting(
        ""SYST:%s"",
        """"""
        Enables manual front panel ('LOC'), remote ('REM') or manual/remote
        control('MIX') control or locks the the front panel control ('RWL').
        """""",
        validator=strict_discrete_set,
        values=[""LOC"", ""REM"", ""MIX"", ""RWL""],
    )

    version = Instrument.measurement(
        ""SYST:VERS?"",
        ""The SCPI version the instrument's command set complies with."",
    )

    # Channel Selection Commands ----------------------------------------------

    selected_channel = Instrument.control(
        ""INST:NSEL?"",
        ""INST:NSEL %s"",
        ""Selected channel."",
        validator=strict_discrete_set,
        values=[1, 2, 3, 4],
        cast=int
    )

    # Voltage Settings --------------------------------------------------------

    voltage = Instrument.control(
        ""VOLT?"", ""VOLT %s"", ""Output voltage in V. Increment 0.001 V.""
    )

    min_voltage = Instrument.measurement(
        ""VOLT? MIN"", ""Minimum voltage in V.""
    )

    max_voltage = Instrument.measurement(
        ""VOLT? MAX"", ""Maximum voltage in V.""
    )

    def voltage_to_min(self):
        """"""Set voltage of the selected channel to its minimum value.""""""
        self.write(""VOLT MIN"")

    def voltage_to_max(self):
        """"""Set voltage of the selected channel to its maximum value.""""""
        self.write(""VOLT MAX"")

    voltage_step = Instrument.control(
        ""VOLT:STEP?"",
        ""VOLT:STEP %s"",
        ""Voltage step in V. Default 1 V."",
        validator=truncated_range,
        values=[0, 32.050],
    )

    def step_voltage_up(self):
        """"""Increase voltage by one step.""""""
        self.write(""VOLT UP"")

    def step_voltage_down(self):
        """"""Decrease voltage by one step.""""""
        self.write(""VOLT DOWN"")

    # Current Settings --------------------------------------------------------

    current = Instrument.control(
        ""CURR?"",
        ""CURR %s"",
        ""Output current in A. Range depends on instrument type."",
    )

    min_current = Instrument.measurement(
        ""CURR? MIN"", ""Minimum current in A.""
    )

    max_current = Instrument.measurement(
        ""CURR? MAX"", ""Maximum current in A.""
    )

    def current_to_min(self):
        """"""Set current of the selected channel to its minimum value.""""""
        self.write(""CURR MIN"")

    def current_to_max(self):
        """"""Set current of the selected channel to its maximum value.""""""
        self.write(""CURR MAX"")

    current_step = Instrument.control(
        ""CURR:STEP?"", ""CURR:STEP %s"", ""Current step in A.""
    )

    def step_current_up(self):
        """"""Increase current by one step.""""""
        self.write(""CURR UP"")

    def step_current_down(self):
        """"""Decreases current by one step.""""""
        self.write(""CURR DOWN"")

    # Combined Voltage And Current Settings -----------------------------------

    voltage_and_current = Instrument.control(
        ""APPL?"",
        ""APPL %s, %s"",
        ""Output voltage (V) and current (A)."",
    )

    # Output Settings ---------------------------------------------------------

    selected_channel_active = Instrument.control(
        ""OUTP:SEL?"",
        ""OUTPUT:SEL %s"",
        ""Set the selected channel to active or inactive or check its status."",
        values={True: 1, False: 0},
        map_values=True,
    )

    output_enabled = Instrument.control(
        ""OUTP:GEN?"",
        ""OUTP:GEN %s"",
        ""Set the output on or off or check the output status."",
        values={True: 1, False: 0},
        map_values=True,
    )

    # The following commands are for making it easier to change the selected
    # channels and activate/deactivate them.

    def set_channel_state(self, channel, state):
        """"""
        Set the state of the channel to active or inactive.

        :param channel: Channel number to set the state of.
        :type channel: int
        :param state: State of the channel, i.e. True for active, False for
            inactive.
        :type state: bool
        """"""
        # Save current selected channel before switching.
        selected_channel = self.selected_channel
        self.selected_channel = channel
        self.selected_channel_active = state
        # Restore previously selected channel.
        self.selected_channel = selected_channel

    # Measurement Commands ----------------------------------------------------

    measured_voltage = Instrument.measurement(
        ""MEAS:VOLT?"", ""Measured voltage in V.""
    )

    measured_current = Instrument.measurement(
        ""MEAS:CURR?"", ""Measured current in A.""
    )

    # Arbitrary Sequence Commands ---------------------------------------------

    def clear_sequence(self, channel):
        """"""Clear the sequence of the selected channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:CLEAR {channel}"")

    sequence = Instrument.setting(
        ""ARB:DATA %s"",
        ""Define sequence of triplets of voltage (V), current (A) and dwell ""
        ""time (s)."",
        set_process=process_sequence,
    )

    repetitions = Instrument.control(
        ""ARB:REP?"",
        ""ARB:REP %s"",
        ""Number of repetitions (0...255). If 0 is entered, the sequence is""
        ""repeated indefinitely."",
        validator=strict_discrete_set,
        values=range(256),
        cast=int,
    )

    def load_sequence(self, slot):
        """"""Load a saved waveform from internal memory (slot 1, 2 or 3).""""""
        slot = strict_discrete_set(slot, [1, 2, 3])
        self.write(f""ARB:REST {slot}"")

    def save_sequence(self, slot):
        """"""
        Save the sequence defined in the sequence property to internal memory
        (slot 1, 2 or 3).
        """"""
        slot = strict_discrete_set(slot, [1, 2, 3])
        self.write(f""ARB:SAVE {slot}"")

    def start_sequence(self, channel):
        """"""Start the sequence of the selected channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:START {channel}"")

    def stop_sequence(self, channel):
        """"""Stop the sequence defined in the sequence property of the selected
        channel.""""""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:STOP {channel}"")

    def transfer_sequence(self, channel):
        """"""
        Transfer the sequence defined in the sequence property to the selected
        channel.
        """"""
        channel = strict_discrete_set(channel, [1, 2, 3, 4])
        self.write(f""ARB:TRAN {channel}"")
"
343,5420.0,USA,"Keysight 33500 Series function/arbitrary waveform generators offer the highest signal fidelity and implement a new breakthrough technology that provides you with the ability to generate more accurate arbitrary waveforms. With 10x better jitter than anything in their class, they offer unparalleled control of signal frequency for your most challenging measurements.",Agilent 33521 A,9.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a KEYSIGHT 33521 A RF Signal Generator,https://www.keysight.com/us/en/products/waveform-and-function-generators.html,['RF Signal Generator'],"Function / Arbitrary Waveform Generator, 30 MHz
",KEYSIGHT 33521 A,https://www.keysight.com/us/en/assets/7018-02567/data-sheets/5990-5914.pdf,"[OrderedDict([('id', 'attOk0hnMqAuS5qCp'), ('width', 1164), ('height', 578), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_QEdnz-NsNbswUHvyOvNpQ/UD1JQe66uSaYZuMvhV08TDr65NZnXLH5jcOrN--welHNm4gvKrsfs0aexut-EImIOKw4BkgzPQXHi1ZgwkvjEpD35_FSK3OmiVYfDIdJYzU/_8DF_8UEbNHCdCySeakgOQ3Ryj3oIuIt4aQQxNZdwAo'), ('filename', 'Agilent 33521.png'), ('size', 415731), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/f7ckRe4F9Go7j5U_cTGWQA/tTqRN9kTpQuyUwMlDUC2yU7Ral2YlmZHIrdQZVQc91MK5AU6CDogNioCcJpMEnj7SwsDseLU8OgkbAbIwAUu-w/LKziZrB8hYD34qaixSxIbpz-aE56uLjUfYCc4PQLF3k'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IJE0DXsDZ8ObJR7elrEegA/l_GKZH84jzt9Om_U4V2dqol3GuN_f5NhrqhG5fmb7vGxsp5Um9csVKp7znL78ynQj2DWxjSayTgSjOfIavKkkQ/RtiGbYRYTQzqt2uAkHcontpt7t9_PdG6HmvddTk_zEw'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VqAhW9iwbPmBE4hI6oO6nQ/RMt41mf_DosXUCJ4WvhM3O1mKS1gMXvof5HsRHNt8OWuKJku3XFtRTjafoCmwiBEtu0FTnHLCKWeLG4_-oRH4g/TYdZHTNU5V4eCXUTAyTVGHSnJ2kgsYt7uRxgmald_WM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/33521A/function--arbitrary-waveform-generator-30-mhz.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent33500.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent33500.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Parts of this code were copied and adapted from the Agilent33220A class.

import logging
from pymeasure.instruments import Instrument, Channel
from pymeasure.instruments.validators import strict_discrete_set, strict_range
from time import time
from pyvisa.errors import VisaIOError

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


# Capitalize string arguments to allow for better conformity with other WFG's
# FIXME: Currently not used since it does not combine well with the strict_discrete_set validator
# def capitalize_string(string: str, *args, **kwargs):
#     return string.upper()


# Combine the capitalize function and validator
# FIXME: This validator is not doing anything other then self.capitalize_string
# FIXME: I removed it from this class for now
# string_validator = joined_validators(capitalize_string, strict_discrete_set)


class Agilent33500Channel(Channel):
    """"""Implementation of a base Agilent 33500 channel""""""

    shape = Instrument.control(
        ""SOUR{ch}:FUNC?"",
        ""SOUR{ch}:FUNC %s"",
        """""" A string property that controls the output waveform. Can be set to:
        SIN<USOID>, SQU<ARE>, TRI<ANGLE>, RAMP, PULS<E>, PRBS,  NOIS<E>, ARB, DC. """""",
        validator=strict_discrete_set,
        values=[""SIN"", ""SQU"", ""TRI"", ""RAMP"", ""PULS"", ""PRBS"", ""NOIS"", ""ARB"", ""DC""],
    )

    frequency = Instrument.control(
        ""SOUR{ch}:FREQ?"",
        ""SOUR{ch}:FREQ %f"",
        """""" A floating point property that controls the frequency of the output
        waveform in Hz, from 1 uHz to 120 MHz (maximum range, can be lower depending
        on your device), depending on the specified function. """""",
        validator=strict_range,
        values=[1e-6, 120e6],
    )

    amplitude = Instrument.control(
        ""SOUR{ch}:VOLT?"",
        ""SOUR{ch}:VOLT %f"",
        """""" A floating point property that controls the voltage amplitude of the
        output waveform in V, from 10e-3 V to 10 V. Depends on the output
        impedance."""""",
        validator=strict_range,
        values=[10e-3, 10],
    )

    amplitude_unit = Instrument.control(
        ""SOUR{ch}:VOLT:UNIT?"",
        ""SOUR{ch}:VOLT:UNIT %s"",
        """""" A string property that controls the units of the amplitude. Valid
        values are VPP (default), VRMS, and DBM."""""",
        validator=strict_discrete_set,
        values=[""VPP"", ""VRMS"", ""DBM""],
    )

    offset = Instrument.control(
        ""SOUR{ch}:VOLT:OFFS?"",
        ""SOUR{ch}:VOLT:OFFS %f"",
        """""" A floating point property that controls the voltage offset of the
        output waveform in V, from 0 V to 4.995 V, depending on the set
        voltage amplitude (maximum offset = (Vmax - voltage) / 2).
        """""",
        validator=strict_range,
        values=[-4.995, +4.995],
    )

    voltage_high = Instrument.control(
        ""SOUR{ch}:VOLT:HIGH?"",
        ""SOUR{ch}:VOLT:HIGH %f"",
        """""" A floating point property that controls the upper voltage of the
        output waveform in V, from -4.999 V to 5 V (must be higher than low
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-4.999, 5],
    )

    voltage_low = Instrument.control(
        ""SOUR{ch}:VOLT:LOW?"",
        ""SOUR{ch}:VOLT:LOW %f"",
        """""" A floating point property that controls the lower voltage of the
        output waveform in V, from -5 V to 4.999 V (must be lower than high
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-5, 4.999],
    )

    phase = Instrument.control(
        ""SOUR{ch}:PHAS?"",
        ""SOUR{ch}:PHAS %f"",
        """""" A floating point property that controls the phase of the output
        waveform in degrees, from -360 degrees to 360 degrees. Not available
        for arbitrary waveforms or noise."""""",
        validator=strict_range,
        values=[-360, 360],
    )

    square_dutycycle = Instrument.control(
        ""SOUR{ch}:FUNC:SQU:DCYC?"",
        ""SOUR{ch}:FUNC:SQU:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a square
        waveform function in percent, from 0.01% to 99.98%.
        The duty cycle is limited by the frequency and the minimal pulse width of
        16 ns. See manual for more details."""""",
        validator=strict_range,
        values=[0.01, 99.98],
    )

    ramp_symmetry = Instrument.control(
        ""SOUR{ch}:FUNC:RAMP:SYMM?"",
        ""SOUR{ch}:FUNC:RAMP:SYMM %f"",
        """""" A floating point property that controls the symmetry percentage
        for the ramp waveform, from 0.0% to 100.0%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_period = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:PER?"",
        ""SOUR{ch}:FUNC:PULS:PER %e"",
        """""" A floating point property that controls the period of a pulse
        waveform function in seconds, ranging from 33 ns to 1 Ms. Can be set
        and overwrites the frequency for *all* waveforms. If the period is
        shorter than the pulse width + the edge time, the edge time and pulse
        width will be adjusted accordingly. """""",
        validator=strict_range,
        values=[33e-9, 1e6],
    )

    pulse_hold = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:HOLD?"",
        ""SOUR{ch}:FUNC:PULS:HOLD %s"",
        """""" A string property that controls if either the pulse width or the
        duty cycle is retained when changing the period or frequency of the
        waveform. Can be set to: WIDT<H> or DCYC<LE>. """""",
        validator=strict_discrete_set,
        values=[""WIDT"", ""WIDTH"", ""DCYC"", ""DCYCLE""],
    )

    pulse_width = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:WIDT?"",
        ""SOUR{ch}:FUNC:PULS:WIDT %e"",
        """""" A floating point property that controls the width of a pulse
        waveform function in seconds, ranging from 16 ns to 1e6 s, within a
        set of restrictions depending on the period."""""",
        validator=strict_range,
        values=[16e-9, 1e6],
    )

    pulse_dutycycle = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:DCYC?"",
        ""SOUR{ch}:FUNC:PULS:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a pulse
        waveform function in percent, from 0% to 100%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_transition = Instrument.control(
        ""SOUR{ch}:FUNC:PULS:TRAN?"",
        ""SOUR{ch}:FUNC:PULS:TRAN:BOTH %e"",
        """""" A floating point property that controls the edge time in
        seconds for both the rising and falling edges. It is defined as the
        time between the 10% and 90% thresholds of the edge.
        Valid values are between 8.4 ns to 1 µs."""""",
        validator=strict_range,
        values=[8.4e-9, 1e-6],
    )

    output = Instrument.control(
        ""OUTP{ch}?"",
        ""OUTP{ch} %d"",
        """""" A boolean property that turns on (True, 'on') or off (False, 'off')
        the output of the function generator."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, ""on"": 1, ""ON"": 1, False: 0, ""off"": 0, ""OFF"": 0},
    )

    output_load = Instrument.control(
        ""OUTP{ch}:LOAD?"",
        ""OUTP{ch}:LOAD %s"",
        """""" Sets the expected load resistance (should be the load impedance connected
        to the output. The output impedance is always 50 Ohm, this setting can be used
        to correct the displayed voltage for loads unmatched to 50 Ohm.
        Valid values are between 1 and 10 kOhm or INF for high impedance.
        No validator is used since both numeric and string inputs are accepted,
        thus a value outside the range will not return an error.
        """""",
    )

    burst_state = Instrument.control(
        ""SOUR{ch}:BURS:STAT?"",
        ""SOUR{ch}:BURS:STAT %d"",
        """""" A boolean property that controls whether the burst mode is on
        (True) or off (False)."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )

    burst_mode = Instrument.control(
        ""SOUR{ch}:BURS:MODE?"",
        ""SOUR{ch}:BURS:MODE %s"",
        """""" A string property that controls the burst mode. Valid values
        are: TRIG<GERED>, GAT<ED>."""""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGERED"", ""GAT"", ""GATED""],
    )

    burst_period = Instrument.control(
        ""SOUR{ch}:BURS:INT:PER?"",
        ""SOUR{ch}:BURS:INT:PER %e"",
        """""" A floating point property that controls the period of subsequent bursts.
        Has to follow the equation burst_period > (burst_ncycles / frequency) + 1 µs.
        Valid values are 1 µs to 8000 s."""""",
        validator=strict_range,
        values=[1e-6, 8000],
    )

    burst_ncycles = Instrument.control(
        ""SOUR{ch}:BURS:NCYC?"",
        ""SOUR{ch}:BURS:NCYC %d"",
        """""" An integer property that sets the number of cycles to be output
        when a burst is triggered. Valid values are 1 to 100000. This can be
        set. """""",
        validator=strict_range,
        values=range(1, 100000),
    )

    arb_file = Instrument.control(
        ""SOUR{ch}:FUNC:ARB?"",
        ""SOUR{ch}:FUNC:ARB %s"",
        """""" A string property that selects the arbitrary signal from the volatile
        memory of the device. String has to match an existing arb signal in volatile
        memory (set by :meth:`data_arb`)."""""",
    )

    arb_advance = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:ADV?"",
        ""SOUR{ch}:FUNC:ARB:ADV %s"",
        """""" A string property that selects how the device advances from data point
        to data point. Can be set to 'TRIG<GER>' or 'SRAT<E>' (default). """""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGER"", ""SRAT"", ""SRATE""],
    )

    arb_filter = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:FILT?"",
        ""SOUR{ch}:FUNC:ARB:FILT %s"",
        """""" A string property that selects the filter setting for arbitrary signals.
        Can be set to 'NORM<AL>', 'STEP' and 'OFF'. """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""NORMAL"", ""STEP"", ""OFF""],
    )

    arb_srate = Instrument.control(
        ""SOUR{ch}:FUNC:ARB:SRAT?"",
        ""SOUR{ch}:FUNC:ARB:SRAT %f"",
        """""" An floating point property that sets the sample rate of the currently selected
        arbitrary signal. Valid values are 1 µSa/s to 250 MSa/s (maximum range, can be lower
        depending on your device)."""""",
        validator=strict_range,
        values=[1e-6, 250e6],
    )

    def data_volatile_clear(self):
        """"""
        Clear all arbitrary signals from volatile memory for a given channel.

        This should be done if the same name is used continuously to load
        different arbitrary signals into the memory, since an error will occur
        if a trace is loaded which already exists in memory.
        """"""
        self.write(""SOUR{ch}:DATA:VOL:CLE"")

    def data_arb(self, arb_name, data_points, data_format=""DAC""):
        """"""
        Uploads an arbitrary trace into the volatile memory of the device for a given channel.

        The data_points can be given as:
        comma separated 16 bit DAC values (ranging from -32767 to +32767),
        as comma separated floating point values (ranging from -1.0 to +1.0),
        or as a binary data stream.
        Check the manual for more information. The storage depends on the device type and ranges
        from 8 Sa to 16 MSa (maximum).

        :param arb_name: The name of the trace in the volatile memory. This is used to access the
                         trace.

        :param data_points: Individual points of the trace. The format depends on the format
                            parameter.

                            format = 'DAC' (default): Accepts list of integer values ranging from
                            -32767 to +32767. Minimum of 8 a maximum of 65536 points.

                            format = 'float': Accepts list of floating point values ranging from
                            -1.0 to +1.0. Minimum of 8 a maximum of 65536 points.

                            format = 'binary': Accepts a binary stream of 8 bit data.
        :param data_format: Defines the format of data_points. Can be 'DAC' (default), 'float' or
                            'binary'. See documentation on parameter data_points above.
        """"""
        if data_format == ""DAC"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""SOUR{{ch}}:DATA:ARB:DAC {arb_name}, {data_string}"")
            return
        elif data_format == ""float"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""SOUR{{ch}}:DATA:ARB {arb_name}, {data_string}"")
            return
        elif data_format == ""binary"":  # TODO: *Binary is not yet implemented*
            raise NotImplementedError(
                'The binary format has not yet been implemented. Use ""DAC"" or ""float"" instead.'
            )
        else:
            raise ValueError(
                'Undefined format keyword was used. Valid entries are ""DAC"", ""float"" and ""binary""'
            )


class Agilent33500(Instrument):
    """"""
    Represents the Agilent 33500 Function/Arbitrary Waveform Generator family.

    Individual devices are represented by subclasses.
    User can specify a channel to control, if no channel specified, a default channel
    is picked based on the device e.g. For Agilent33500B the default channel
    is channel 1. See reference manual for your device

    .. code-block:: python

        generator = Agilent33500(""GPIB::1"")

        generator.shape = 'SIN'                 # Sets default channel output signal shape to sine
        generator.ch_1.shape = 'SIN'           # Sets channel 1 output signal shape to sine
        generator.frequency = 1e3               # Sets default channel output frequency to 1 kHz
        generator.ch_1.frequency = 1e3         # Sets channel 1 output frequency to 1 kHz
        generator.ch_2.amplitude = 5           # Sets channel 2 output amplitude to 5 Vpp
        generator.ch_2.output = 'on'           # Enables channel 2 output

        generator.ch_1.shape = 'ARB'           # Set channel 1 shape to arbitrary
        generator.ch_1.arb_srate = 1e6         # Set channel 1 sample rate to 1MSa/s

        generator.ch_1.data_volatile_clear()   # Clear channel 1 volatile internal memory
        generator.ch_1.data_arb(               # Send data of arbitrary waveform to channel 1
            'test',
            range(-10000, 10000, +20),          # In this case a simple ramp
            data_format='DAC'                   # Data format is set to 'DAC'
         )
        generator.ch_1.arb_file = 'test'       # Select the transmitted waveform 'test'

    """"""

    ch_1 = Instrument.ChannelCreator(Agilent33500Channel, 1)

    ch_2 = Instrument.ChannelCreator(Agilent33500Channel, 2)

    def __init__(self, adapter, name=""Agilent 33500 Function/Arbitrary Waveform generator family"",
                 **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def beep(self):
        """"""Causes a system beep.""""""
        self.write(""SYST:BEEP"")

    shape = Instrument.control(
        ""FUNC?"",
        ""FUNC %s"",
        """""" A string property that controls the output waveform. Can be set to:
        SIN<USOID>, SQU<ARE>, TRI<ANGLE>, RAMP, PULS<E>, PRBS,  NOIS<E>, ARB, DC. """""",
        validator=strict_discrete_set,
        values=[""SIN"", ""SQU"", ""TRI"", ""RAMP"", ""PULS"", ""PRBS"", ""NOIS"", ""ARB"", ""DC""],
    )

    frequency = Instrument.control(
        ""FREQ?"",
        ""FREQ %f"",
        """""" A floating point property that controls the frequency of the output
        waveform in Hz, from 1 uHz to 120 MHz (maximum range, can be lower depending
        on your device), depending on the specified function."""""",
        validator=strict_range,
        values=[1e-6, 120e6],
    )

    amplitude = Instrument.control(
        ""VOLT?"",
        ""VOLT %f"",
        """""" A floating point property that controls the voltage amplitude of the
        output waveform in V, from 10e-3 V to 10 V. Depends on the output
        impedance."""""",
        validator=strict_range,
        values=[10e-3, 10],
    )

    amplitude_unit = Instrument.control(
        ""VOLT:UNIT?"",
        ""VOLT:UNIT %s"",
        """""" A string property that controls the units of the amplitude. Valid
        values are VPP (default), VRMS, and DBM."""""",
        validator=strict_discrete_set,
        values=[""VPP"", ""VRMS"", ""DBM""],
    )

    offset = Instrument.control(
        ""VOLT:OFFS?"",
        ""VOLT:OFFS %f"",
        """""" A floating point property that controls the voltage offset of the
        output waveform in V, from 0 V to 4.995 V, depending on the set
        voltage amplitude (maximum offset = (Vmax - voltage) / 2).
        """""",
        validator=strict_range,
        values=[-4.995, +4.995],
    )

    voltage_high = Instrument.control(
        ""VOLT:HIGH?"",
        ""VOLT:HIGH %f"",
        """""" A floating point property that controls the upper voltage of the
        output waveform in V, from -4.999 V to 5 V (must be higher than low
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-4.999, 5],
    )

    voltage_low = Instrument.control(
        ""VOLT:LOW?"",
        ""VOLT:LOW %f"",
        """""" A floating point property that controls the lower voltage of the
        output waveform in V, from -5 V to 4.999 V (must be lower than high
        voltage by at least 1 mV)."""""",
        validator=strict_range,
        values=[-5, 4.999],
    )

    phase = Instrument.control(
        ""PHAS?"",
        ""PHAS %f"",
        """""" A floating point property that controls the phase of the output
        waveform in degrees, from -360 degrees to 360 degrees. Not available
        for arbitrary waveforms or noise."""""",
        validator=strict_range,
        values=[-360, 360],
    )

    square_dutycycle = Instrument.control(
        ""FUNC:SQU:DCYC?"",
        ""FUNC:SQU:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a square
        waveform function in percent, from 0.01% to 99.98%.
        The duty cycle is limited by the frequency and the minimal pulse width of
        16 ns. See manual for more details."""""",
        validator=strict_range,
        values=[0.01, 99.98],
    )

    ramp_symmetry = Instrument.control(
        ""FUNC:RAMP:SYMM?"",
        ""FUNC:RAMP:SYMM %f"",
        """""" A floating point property that controls the symmetry percentage
        for the ramp waveform, from 0.0% to 100.0%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_period = Instrument.control(
        ""FUNC:PULS:PER?"",
        ""FUNC:PULS:PER %e"",
        """""" A floating point property that controls the period of a pulse
        waveform function in seconds, ranging from 33 ns to 1e6 s. Can be set
        and overwrites the frequency for *all* waveforms. If the period is
        shorter than the pulse width + the edge time, the edge time and pulse
        width will be adjusted accordingly. """""",
        validator=strict_range,
        values=[33e-9, 1e6],
    )

    pulse_hold = Instrument.control(
        ""FUNC:PULS:HOLD?"",
        ""FUNC:PULS:HOLD %s"",
        """""" A string property that controls if either the pulse width or the
        duty cycle is retained when changing the period or frequency of the
        waveform. Can be set to: WIDT<H> or DCYC<LE>. """""",
        validator=strict_discrete_set,
        values=[""WIDT"", ""WIDTH"", ""DCYC"", ""DCYCLE""],
    )

    pulse_width = Instrument.control(
        ""FUNC:PULS:WIDT?"",
        ""FUNC:PULS:WIDT %e"",
        """""" A floating point property that controls the width of a pulse
        waveform function in seconds, ranging from 16 ns to 1 Ms, within a
        set of restrictions depending on the period."""""",
        validator=strict_range,
        values=[16e-9, 1e6],
    )

    pulse_dutycycle = Instrument.control(
        ""FUNC:PULS:DCYC?"",
        ""FUNC:PULS:DCYC %f"",
        """""" A floating point property that controls the duty cycle of a pulse
        waveform function in percent, from 0% to 100%."""""",
        validator=strict_range,
        values=[0, 100],
    )

    pulse_transition = Instrument.control(
        ""FUNC:PULS:TRAN?"",
        ""FUNC:PULS:TRAN:BOTH %e"",
        """""" A floating point property that controls the edge time in
        seconds for both the rising and falling edges. It is defined as the
        time between the 10% and 90% thresholds of the edge.
        Valid values are between 8.4 ns to 1 µs."""""",
        validator=strict_range,
        values=[8.4e-9, 1e-6],
    )

    output = Instrument.control(
        ""OUTP?"",
        ""OUTP %d"",
        """""" A boolean property that turns on (True, 'on') or off (False, 'off')
        the output of the function generator."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, ""on"": 1, ""ON"": 1, False: 0, ""off"": 0, ""OFF"": 0},
    )

    output_load = Instrument.control(
        ""OUTP:LOAD?"",
        ""OUTP:LOAD %s"",
        """""" Sets the expected load resistance (should be the load impedance connected
        to the output. The output impedance is always 50 Ohm, this setting can be used
        to correct the displayed voltage for loads unmatched to 50 Ohm.
        Valid values are between 1 and 10 kOhm or INF for high impedance.
        No validator is used since both numeric and string inputs are accepted,
        thus a value outside the range will not return an error.
        """""",
    )

    burst_state = Instrument.control(
        ""BURS:STAT?"",
        ""BURS:STAT %d"",
        """""" A boolean property that controls whether the burst mode is on
        (True) or off (False)."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )

    burst_mode = Instrument.control(
        ""BURS:MODE?"",
        ""BURS:MODE %s"",
        """""" A string property that controls the burst mode. Valid values
        are: TRIG<GERED>, GAT<ED>."""""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGERED"", ""GAT"", ""GATED""],
    )

    burst_period = Instrument.control(
        ""BURS:INT:PER?"",
        ""BURS:INT:PER %e"",
        """""" A floating point property that controls the period of subsequent bursts.
        Has to follow the equation burst_period > (burst_ncycles / frequency) + 1 µs.
        Valid values are 1 µs to 8000 s."""""",
        validator=strict_range,
        values=[1e-6, 8000],
    )

    burst_ncycles = Instrument.control(
        ""BURS:NCYC?"",
        ""BURS:NCYC %d"",
        """""" An integer property that sets the number of cycles to be output
        when a burst is triggered. Valid values are 1 to 100000. This can be
        set. """""",
        validator=strict_range,
        values=range(1, 100000),
    )

    arb_file = Instrument.control(
        ""FUNC:ARB?"",
        ""FUNC:ARB %s"",
        """""" A string property that selects the arbitrary signal from the volatile
        memory of the device. String has to match an existing arb signal in volatile
        memory (set by :meth:`data_arb`)."""""",
    )

    arb_advance = Instrument.control(
        ""FUNC:ARB:ADV?"",
        ""FUNC:ARB:ADV %s"",
        """""" A string property that selects how the device advances from data point
        to data point. Can be set to 'TRIG<GER>' or 'SRAT<E>' (default). """""",
        validator=strict_discrete_set,
        values=[""TRIG"", ""TRIGGER"", ""SRAT"", ""SRATE""],
    )

    arb_filter = Instrument.control(
        ""FUNC:ARB:FILT?"",
        ""FUNC:ARB:FILT %s"",
        """""" A string property that selects the filter setting for arbitrary signals.
        Can be set to 'NORM<AL>', 'STEP' and 'OFF'. """""",
        validator=strict_discrete_set,
        values=[""NORM"", ""NORMAL"", ""STEP"", ""OFF""],
    )
    # TODO: This implementation is currently not working. Do not know why.
    # arb_period = Instrument.control(
    #     ""FUNC:ARB:PER?"", ""FUNC:ARB:PER %e"",
    #     """""" A floating point property that controls the period of the arbitrary signal.
    #     Limited by number of signal points. Check for instrument errors when setting
    #     this property."""""",
    #     validator=strict_range,
    #     values=[33e-9, 1e6],
    # )
    #
    # arb_frequency = Instrument.control(
    #     ""FUNC:ARB:FREQ?"", ""FUNC:ARB:FREQ %f"",
    #     """""" A floating point property that controls the frequency of the arbitrary signal.
    #     Limited by number of signal points. Check for instrument
    #     errors when setting this property."""""",
    #     validator=strict_range,
    #     values=[1e-6, 30e+6],
    # )
    #
    # arb_npoints = Instrument.measurement(
    #     ""FUNC:ARB:POIN?"",
    #     """""" Returns the number of points in the currently selected arbitrary trace. """"""
    # )
    #
    # arb_voltage = Instrument.control(
    #     ""FUNC:ARB:PTP?"", ""FUNC:ARB:PTP %f"",
    #     """""" An floating point property that sets the peak-to-peak voltage for the
    #     currently selected arbitrary signal. Valid values are 1 mV to 10 V. This can be
    #     set. """""",
    #     validator=strict_range,
    #     values=[0.001, 10],
    # )

    arb_srate = Instrument.control(
        ""FUNC:ARB:SRAT?"",
        ""FUNC:ARB:SRAT %f"",
        """""" An floating point property that sets the sample rate of the currently selected
        arbitrary signal. Valid values are 1 µSa/s to 250 MSa/s (maximum range, can be lower
        depending on your device)."""""",
        validator=strict_range,
        values=[1e-6, 250e6],
    )

    def data_volatile_clear(self):
        """"""
        Clear all arbitrary signals from volatile memory.

        This should be done if the same name is used continuously to load
        different arbitrary signals into the memory, since an error
        will occur if a trace is loaded which already exists in the memory.
        """"""
        self.write(""DATA:VOL:CLE"")

    def phase_sync(self):
        """""" Synchronize the phase of all channels.""""""
        self.write(""PHAS:SYNC"")

    def data_arb(self, arb_name, data_points, data_format=""DAC""):
        """"""
        Uploads an arbitrary trace into the volatile memory of the device.

        The data_points can be given as:
        comma separated 16 bit DAC values (ranging from -32767 to +32767),
        as comma separated floating point values (ranging from -1.0 to +1.0)
        or as a binary data stream.
        Check the manual for more information.
        The storage depends on the device type and ranges
        from 8 Sa to 16 MSa (maximum).

        :param arb_name: The name of the trace in the volatile memory. This is used to access the
                         trace.
        :param data_points: Individual points of the trace. The format depends on the format
                            parameter.
                            format = 'DAC' (default): Accepts list of integer values ranging from
                            -32767 to +32767. Minimum of 8 a maximum of 65536 points.
                            format = 'float': Accepts list of floating point values ranging from
                            -1.0 to +1.0. Minimum of 8 a maximum of 65536 points.
                            format = 'binary': Accepts a binary stream of 8 bit data.
        :param data_format: Defines the format of data_points. Can be 'DAC' (default), 'float' or
                            'binary'. See documentation on parameter data_points above.
        """"""
        if data_format == ""DAC"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""DATA:ARB:DAC {arb_name}, {data_string}"")
            return
        elif data_format == ""float"":
            separator = "", ""
            data_points_str = [str(item) for item in data_points]  # Turn list entries into strings
            data_string = separator.join(data_points_str)  # Join strings with separator
            self.write(f""DATA:ARB {arb_name}, {data_string}"")
            return
        elif data_format == ""binary"":  # TODO: *Binary is not yet implemented*
            raise NotImplementedError(
                'The binary format has not yet been implemented. Use ""DAC"" or ""float"" instead.'
            )
        else:
            raise ValueError(
                'Undefined format keyword was used. Valid entries are ""DAC"", ""float"" and ""binary""'
            )

    display = Instrument.setting(
        ""DISP:TEXT '%s'"",
        """""" A string property which is displayed on the front panel of
        the device."""""",
    )

    def clear_display(self):
        """"""Removes a text message from the display.""""""
        self.write(""DISP:TEXT:CLE"")

    def trigger(self):
        """"""Send a trigger signal to the function generator.""""""
        self.write(""*TRG;*WAI"")

    def wait_for_trigger(self, timeout=3600, should_stop=lambda: False):
        """"""
        Wait until the triggering has finished or timeout is reached.

        :param timeout: The maximum time the waiting is allowed to take. If
                        timeout is exceeded, a TimeoutError is raised. If
                        timeout is set to zero, no timeout will be used.
        :param should_stop: Optional function (returning a bool) to allow the
                            waiting to be stopped before its end.

        """"""
        self.write(""*OPC?"")

        t0 = time()
        while True:
            try:
                ready = bool(self.read())
            except VisaIOError:
                ready = False

            if ready:
                return

            if timeout != 0 and time() - t0 > timeout:
                raise TimeoutError(
                    ""Timeout expired while waiting for the Agilent 33220A""
                    + "" to finish the triggering.""
                )

            if should_stop:
                return

    trigger_source = Instrument.control(
        ""TRIG:SOUR?"",
        ""TRIG:SOUR %s"",
        """""" A string property that controls the trigger source. Valid values
        are: IMM<EDIATE> (internal), EXT<ERNAL> (rear input), BUS (via trigger
        command)."""""",
        validator=strict_discrete_set,
        values=[""IMM"", ""IMMEDIATE"", ""EXT"", ""EXTERNAL"", ""BUS""],
    )

    ext_trig_out = Instrument.control(
        ""OUTP:TRIG?"",
        ""OUTP:TRIG %d"",
        """""" A boolean property that controls whether the trigger out signal is
        active (True) or not (False). This signal is output from the Ext Trig
        connector on the rear panel in Burst and Wobbel mode."""""",
        validator=strict_discrete_set,
        map_values=True,
        values={True: 1, False: 0},
    )
"
346,,UK (Meggit),"Handheld single-axis digital magnetometer gauss / tesla meter for measuring magnets, magnetism of steel, and other manufacturing and scientific applications.",Fwbell 5080,124.0,"Technology leaders in instrumentation. Designing and manufacturing **F.W. Bell** gaussmeters, probes, current sensors and Hall generators for over 60 years
",Pymeasure,F.W. Bell,"[OrderedDict([('id', 'attlye35NOBj3ErJe'), ('width', 373), ('height', 247), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g6NXyNYpbm7SB16MS4ywRA/NhqgrnI8byS3HlpcMlxDJPPadAg49KmNMLlYOQDLXWDxYhNvlozjGRDTDl0w3pbr1yOnL_5zq8ZKwOOKbBgoV9P0ZTnn4_QAFlVHueAbX5A/asHrhjm4O-o1dILuQBn0Xwx0vCU9GXhj_JHfIkPDCHY'), ('filename', 'fw-bell logo.jpg'), ('size', 12846), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TW7FNSEuA_bmMqwRBWGl_g/nMOSlshoh8jZ1PLMLPTzlATu59GyozFCQqRFhtI3Mu9XUjkgPxFL4Kz693Cy88IRF6v2jFiriXtHR-DDsJLK0w/fthskKw2VMWIB0I5B5fOMbF_hooq-XlGYDPBwBIx3Iw'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rT9QCO21IYqpsBMDUAzJ4g/pX4LKolJhy7iHO7qQC_Pz39oXUOGkX-vnat-dBkET2T_OxxIGe5pA_Ebq0PXAyqFHinhurUN_BOzn4F61wejXA/k0fKieezyMQXkQ2g83wplbD7a7NVMSK81CSueiC2jtI'), ('width', 373), ('height', 247)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CM6Moq_QF9mxHl4-Z_Uliw/zEVlSVimSfCsbpgT3mtJLLi7ieqn3V5XDiGwLvvdLFBz6RJMoPbmwmcAryj1uVDKWuvPeV7a8SZk1aEuV9HNmA/otuO24sh8fkjfd_w_c7q8ZUCpt2yfTLK5mkbPQAX98g'), ('width', 3000), ('height', 3000)]))]))])]",https://fwbell.com/,Write a Python script that uses Pymeasure to connect to a F.W. Bell 5280 Multimeters,https://en.wikipedia.org/wiki/Magnetometer,['Multimeters'],A Gaussmeter is a device that measures magnetic field or magnetic dipole moment.,F.W. Bell 5280,https://store-5445uo.mybigcommerce.com/content/5200_Magsci_version_2pg.pdf,"[OrderedDict([('id', 'attci8CRkQ0fU1oHJ'), ('width', 44), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zhRCrjmaZfAQH3_MhPfWBw/QJngKblMrpVYstN82nOGV7Gf_JUygMLKxYPTve2FoYEkGCQYpNF646JrZKjV4xXal245K-m-bk85_rD4iXJ6Tg/VWVcL3Zdewcu9YpAnDo_NDLwaGtFAtJS3_2iAqOEBSg'), ('filename', 'F.W.jpg'), ('size', 1623), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ChaH7hcehCZPICn-9JpMGQ/mPZdZkOuJnnhPPC17M3iFqHo-rSOLboUWrchGBoQvofqPps6FZw6PCl2ze0B1cb11_FCNyKixgIhljjmlGsyeA/61CvO_jrMQmx2UhkX8yTJqybLkHBEx3M5gKIYw1shbA'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pvc97axD7hPAANxIzxGHdw/mrzp_SW1k0xiTIy9ra2t8FguaBwP6HuwhbEvtuVcqamXBXdAR4Ip2Cb92PoykMekED2XBj-tYClgeyjDvMDDBQ/CQOFa3FnDta1OAyXpbFGMP9ud76bhe46HkQOo8w0P0g'), ('width', 44), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kKrIr8ZNnr_o3UtHIJszpQ/dvHSMoKIOlMepDPvxEoDQsyxrp1gFjo_udf0SGaEOsHqYozOAYkpeJAWlxFdJaJAHlbIVyw-fC6gp66cDkfqLg/oZgAF4QHGBmJu4Rdzef6fTCghMa_xMVWnMr0Q8OOcEQ'), ('width', 3000), ('height', 3000)]))]))])]",https://magneticsciences.com/bell-5280-gaussmeter/,https://github.com/pymeasure/pymeasure/blob/master/docs/api/instruments/fwbell/fwbell5080.rst,https://pymeasure.readthedocs.io/en/latest/api/instruments/fwbell/fwbell5080.html,750.0,,,,"##################################
F.W. Bell 5080 Handheld Gaussmeter
##################################

.. autoclass:: pymeasure.instruments.fwbell.FWBell5080
    :members:
    :show-inheritance:
    :inherited-members: CommonBase
"
347,110.6,"Cleveland, Ohio, United States",6517B Electrometer/High Resistance Meter is capable of measuring the largest voltage range—up to 200 V—with an input impedance exceeding 200 TΩ. All this performance is built into an instrument that operates as simply as a digital multimeter.,Keithley 6517 B,257.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 6517B Power Meters,https://en.wikipedia.org/wiki/Electrometer,['Power Meters'],"An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.",Keithley 6517B,https://www.farnell.com/datasheets/1484838.pdf?_ga=2.191326378.1021018580.1687884136-1198138748.1687884136,"[OrderedDict([('id', 'attOW045AtVQ9t71b'), ('width', 320), ('height', 164), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8_HkpCf_gzADL5BW44wrwA/yGJC4_qOxE-9HhrJD9HQhQw25sIZP10e3h0Tjn-C7EzMlUSr5JM5Je-PGAcH5e0EY2yEwCl0TmhpvJ07nE2eeOCpa46CFLQQD2bUnnWMgq4/vJxPI9waGmdlADH3Ti9x6cwe7dmvKCLNWjp2n_fhvhU'), ('filename', '6517b.webp'), ('size', 5212), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IToAzAIs8gVFdubv7bCpdg/Vj2tEWizJem220Nh9ni1AH2SOBb6OfPkqNzhjN4E5oEH-d7Cn9Oiq-NnAoARbAVzwTc-nQrdRFmYG8AnXzy9uRTrqd0K8dlWTcpmEacafq0/XzeMP5-tcFCATxdmWHJgDvUMigk3GOFnriVfGpJOvlo'), ('width', 70), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zadIUvqhPwcJ1MDKhBh5Qg/R2m5ahOurujVfOOT0DXFWPk-dWHTb8GwRsXIZQgJ30Y3eKbzl5RJtTMOGiUEXg2OKm19-XT0Dn-oQStvQuTcR4j1CsxaFK7sbKjWbmvSFNE/UsTVTwrIpACCIuvMWToKbv3It3Vy1OVXJktqTRyjbBs'), ('width', 320), ('height', 164)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lohWhI-dk2s2_q_Dammdiw/8kdhKUNteExbmZx-sX63cdMXn4pPfHvGukB2laFB_tHpBH-75W0zbpH0lGpdE--FuwXeQHKJo79IRAakReHnmU1acO1PbDtARmWBXlMv2x0/ea2hAlZX9bX4n1hGDKFsv34RGtd3hx6ihwK6Z3YvrXo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newark.com/keithley/6517b/electrometer-high-resistance-meter/dp/56P3700,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6517b.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6517b.html,12100.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import re

import numpy as np

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6517B(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6517B ElectroMeter and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6517B(""GPIB::1"")

        keithley.apply_voltage()              # Sets up to source current
        keithley.source_voltage_range = 200   # Sets the source voltage
                                              # range to 200 V
        keithley.source_voltage = 20          # Sets the source voltage to 20 V
        keithley.enable_source()              # Enables the source output

        keithley.measure_resistance()         # Sets up to measure resistance

        keithley.ramp_to_voltage(50)          # Ramps the voltage to 50 V
        print(keithley.resistance)            # Prints the resistance in Ohms

        keithley.shutdown()                   # Ramps the voltage to 0 V
                                              # and disables output

    """"""

    source_enabled = Instrument.measurement(
        ""OUTPUT?"",
        """""" Reads a boolean value that is True if the source is enabled. """""",
        cast=bool
    )

    @staticmethod
    def extract_value(result):
        """""" extracts the physical value from a result object returned
            by the instrument """"""
        m = re.fullmatch(r'([+\-0-9E.]+)[A-Z]{4}', result[0])
        if m:
            return float(m.group(1))
        return None

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":MEAS?"",
        """""" Reads the current in Amps, if configured for this reading.
        """""", get_process=extract_value
    )

    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the measurement current
        range in Amps, which can take values between -20 and +20 mA.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-20e-3, 20e-3]
    )

    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC current measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """""",
        values=[0.01, 10]
    )

    source_current_resistance_limit = Instrument.control(
        "":SOUR:CURR:RLIM?"", "":SOUR:CURR:RLIM %g"",
        """""" Boolean property which enables or disables resistance
        current limit """""",
        cast=bool
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":MEAS:VOLT?"",
        """""" Reads the voltage in Volts, if configured for this reading.
        """""", get_process=extract_value
    )

    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the measurement voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    voltage_nplc = Instrument.control(
        "":SENS:VOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power
        line cycles (NPLC) for the DC voltage measurements, which sets the
        integration period and measurement speed. Takes values from 0.01 to
        10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively. """"""
    )

    source_voltage = Instrument.control(
        "":SOUR:VOLT?"", "":SOUR:VOLT:LEV %g"",
        """""" A floating point property that controls the source voltage
        in Volts. """"""
    )

    source_voltage_range = Instrument.control(
        "":SOUR:VOLT:RANG?"", "":SOUR:VOLT:RANG:AUTO 0;:SOUR:VOLT:RANG %g"",
        """""" A floating point property that controls the source voltage
        range in Volts, which can take values from -1000 to 1000 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-1000, 1000]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads the resistance in Ohms, if configured for this reading.
        """""", get_process=extract_value
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the resistance range
        in Ohms, which can take values from 0 to 100e18 Ohms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 100e18]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the
        integration period and measurement speed. Takes values from 0.01
        to 10, where 0.1, 1, and 10 are Fast, Medium, and Slow respectively.
        """"""
    )

    buffer_points = Instrument.control(
        "":TRAC:POIN?"", "":TRAC:POIN %d"",
        """""" An integer property that controls the number of buffer points. This
        does not represent actual points in the buffer, but the configuration
        value instead. """""",
        validator=truncated_range,
        values=[1, 6875000],
        cast=int
    )

    ####################
    # Methods        #
    ####################

    def __init__(self, adapter, name=""Keithley 6517B Electrometer/High Resistance Meter"", **kwargs):
        super().__init__(
            adapter, name,
            **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def measure_resistance(self, nplc=1, resistance=2.1e5, auto_range=True):
        """""" Configures the measurement of resistance.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param resistance: Upper limit of resistance in Ohms,
                           from -210 POhms to 210 POhms
        :param auto_range: Enables auto_range if True, else uses the
                           resistance_range attribut
        """"""
        log.info(""%s is measuring resistance."", self.name)
        self.write("":SENS:FUNC 'RES';""
                   "":SENS:RES:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:RES:RANG:AUTO 1;"")
        else:
            self.resistance_range = resistance
        self.check_errors()

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param voltage: Upper limit of voltage in Volts, from -1000 V to 1000 V
        :param auto_range: Enables auto_range if True, else uses the
                           voltage_range attribut
        """"""
        log.info(""%s is measuring voltage."", self.name)
        self.write("":SENS:FUNC 'VOLT';""
                   "":SENS:VOLT:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:VOLT:RANG:AUTO 1;"")
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.

        :param nplc: Number of power line cycles (NPLC) from 0.01 to 10
        :param current: Upper limit of current in Amps, from -21 mA to 21 mA
        :param auto_range: Enables auto_range if True, else uses the
                           current_range attribut
        """"""
        log.info(""%s is measuring current."", self.name)
        self.write("":SENS:FUNC 'CURR';""
                   "":SENS:CURR:NPLC %f;"" % nplc)
        if auto_range:
            self.write("":SENS:CURR:RANG:AUTO 1;"")
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        self.write("":SOUR:VOLT:RANG:AUTO 1"")

    def apply_voltage(self, voltage_range=None):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.

        :param voltage_range: A :attr:`~.Keithley6517B.voltage_range` value
                              or None (activates auto range)
        """"""
        log.info(""%s is sourcing voltage."", self.name)
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.check_errors()

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6517B reported error: %d, %s"", code, message)
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6517B error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""*RST;:stat:pres;:*CLS;"")

    def ramp_to_voltage(self, target_voltage, steps=30, pause=20e-3):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.

        :param target_voltage: A voltage in Volts
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps
        """"""
        voltages = np.linspace(
            self.source_voltage,
            target_voltage,
            steps
        )
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":TRIG:SOUR BUS;"")

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down %s."", self.name)
        self.ramp_to_voltage(0.0)
        self.stop_buffer()
        self.disable_source()
        super().shutdown()
"
348,19.0,USA,The ECO-560/660 ThermoStream uses less energy while delivering high-performance temperature control with low noise and low cost.,ECO 560,590.0,"**Temptronic** temperature forcing systems, are designed for testing and characterization of semiconductors, ICs, chips, electronics, and materials

",Pymeasure,Temptronic,"[OrderedDict([('id', 'attMKXEybBAxwHFDR'), ('width', 470), ('height', 572), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/na4BsJwlkqnuz1GWqxCV8g/8wSkZbZICUx-sWQn0mySlDB9smvlFs1-SDNJBCEB7oYSXz0MCl_3jtc9OqrfTGYRk_xBEyzTaulvgg2MYz0jU0QjvIXLed4O7LRuPARqZLTuR1Q78RJg_NYRH2zNoWVf/C3xMCyDJFEaabeVi51UFlWAjoGOacMN2IIZ6m1TzJEo'), ('filename', 'inTEST-Thermal-Solutions.png'), ('size', 18982), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7LM1FMdjsBNqNDVMgxqZ7Q/d1YtGTAB2BOTlYx4v1Et8YBP5WMaRw81P-S_hyaQY0EWcZ4a8Q56MNU55u0X3ftLT9mL-Wi_Lt1jws1RSQu-wA/Y0r4Sg_aR6Q3yBZwwWGN9kqZtgYrXtYUAMCN5Hb7qwM'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6Z_PgK_5CwclJGyIfTUx3A/4oiK1H_smeqwPEb8SfQGnbaoPj05nFJUqDLsmTnIYNm6JP5awVfpqHHL09x0sT862YBMeRbvjdRzNL2DonfSNQ/ARBzmImWLfvEtAjovr3AWxWG3RPMeSnG2vZcJa1XZT0'), ('width', 470), ('height', 572)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QaO1zUTsPkXAzHmYqbUQxg/bOJHt3CC4PShuZ0yDuiTw9c68CGwNAhBzq1_5WE7Iz8_8TR_RPSil1-IcBKGG3_KQctxujlYPCdWQuFruWsPZQ/AdtFsIajUdOnVt0LVkN4IOIlu7AqpNshZTBk_YXgjbo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic,Write a Python script that uses Pymeasure to connect to a {Device name} Temperature Controllers,"https://en.wikipedia.org/wiki/Temperature_control#:~:text=Temperature%20control%20is%20a%20process,to%20achieve%20a%20desired%20temperature.",['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",,https://www.intestthermal.com/temptronic/brochure-request?brochure_title=ECO-560_660_Series_ThermoStream&brand_interest=Temptronic&brand_sub_folder=temptronic&file_name=ECO-560_660_Series_ThermoStream.pdf&product=ECO%20ThermoStream&hsLang=en,"[OrderedDict([('id', 'attZGP0PXEl16LoZ7'), ('width', 366), ('height', 798), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4l1WEF9rhDFIFT6xZ4ZiOg/1sKyWMpPFJ5JqGhVxqF9mVmfTNS5l9OeK-Z5RbmzRKQ1LPfYD6WsafB990sSjGxyRvcVnocrJlYjHK7i0b-cYeQZqKrlB-YV7_AOzGlgSbQ/fHSj2hxWP7dVJ8voeb1pEU4Kg7fDQuCygvSz7eWyg4E'), ('filename', '560 ECO Stream.webp'), ('size', 35380), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UXATsK3MPTrKhJnqS14tNA/75mRaKaZiogvsEwXNxwpOKnwhKZGCfws3CsAAHqFlNxgoQTrdOCbjx4d-WytH9KuYO7qVraCTYBiJgV76P2JRVmf1snQ0BxHSFbL8Xhr3oM/cf_BwEIDlWFbbCRMNjc6NqX4weA4Omo9C0zMFbQKYuo'), ('width', 17), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9PrLCK3K0IOaMu_3nY-S9w/EoQFoHsOmKM1nWqHZn7eFE30z_pz7-1rGWAUH5niORcQd2Zer5BuCU3-siUDi8V6iPXB8WFccSiKmz5Cl1ETucc4CyujwZfbpcP8Yot8mCg/jKQP13TxeCkgpTC1IEts3wK4y3EHJ0yP4bbzcAdAN0g'), ('width', 366), ('height', 798)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q6LsLLUi9NwWbs8qYaQfyw/eCD7jySq7esdOVUR3eHn9WULqgWp4cTcN8onck5hpc1Fr0EUU8Hw-a6vRFgWvdJRGjxxVO_PBcgQ7_1AI780hwovDRkHqqaYubooaxRd9Hk/lc2w8k-ln-OUwUAQWF1_M3Yt1oab9mQDv1nZ7GKkxxA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.intestthermal.com/temptronic/low-cost-thermostream/eco560-660,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/temptronic/temptronic_eco560.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/temptronic/temptronic_eco560.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""""""
Implementation of an interface class for ThermoStream® Systems devices.
Reference Document for implementation:
ECO-560/660 ThermoStream® Systems
Operators Manual
Revision B
September, 2018
""""""

from pymeasure.instruments.temptronic.temptronic_base import ATSBase
from enum import IntFlag


class ECO560ErrorCode(IntFlag):
    """"""Error code enums based on ``IntFlag``.

    Used in conjunction with :attr:`~.error_code`.

        ======  ======
        Value   Enum
        ======  ======
        16384   NO_DUT_SENSOR_SELECTED
        8192    IMPROPER_SOFTWARE_VERSION
        1024    PURGE_HEAT_FAILURE
        512     FLOW_SENSOR_HARDWARE_ERROR
        256     DUT_OPEN_LOOP
        128     INTERNAL_ERROR
        64      OPEN_PURGE_TEMPERATURE_SENSOR
        32      AIR_SENSOR_OPEN
        16      LOW_INPUT_AIR_PRESSURE
        8       LOW_FLOW
        4       SETPOINT_OUT_OF_RANGE
        2       AIR_OPEN_LOOP
        1       OVERHEAT
        0       OK
        ======  ======

    """"""
    # bit 15 - reserved
    NO_DUT_SENSOR_SELECTED = 16384      # bit 14 – no DUT sensor selected
    IMPROPER_SOFTWARE_VERSION = 8192    # bit 13 – software revision error
    # bit 12 – reserved
    # bit 11 – reserved
    PURGE_HEAT_FAILURE = 1024           # bit 10 – purge heat failure
    FLOW_SENSOR_HARDWARE_ERROR = 512    # bit 9  – flow sensor hardware error
    DUT_OPEN_LOOP = 256                 # bit 8  – dut open loop
    INTERNAL_ERROR = 128                # bit 7  – internal error
    OPEN_PURGE_TEMPERATURE_SENSOR = 64  # bit 6  – open purge temperature sensor
    NO_PURGE_FLOW = 32                  # bit 5  – no purge flow
    LOW_INPUT_AIR_PRESSURE = 16         # bit 4  – low input air pressure
    LOW_FLOW = 8                        # bit 3  – low flow
    SETPOINT_OUT_OF_RANGE = 4           # bit 2  – setpoint out of range
    AIR_OPEN_LOOP = 2                   # bit 1  – air open loop
    OVERHEAT = 1                        # bit 0  – overheat
    OK = 0                              # ok state


class ECO560(ATSBase):
    """"""Represent the TemptronicECO560 instruments.
    """"""

    temperature_limit_air_low_values = [-150, 25]

    error_code_get_process = lambda v: ECO560ErrorCode(int(v))  # noqa: E731

    copy_active_setup_file = None
    # Not Implemented in ECO-560

    def __init__(self, adapter, name=""Temptronic ECO-560 Thermostream"", **kwargs):
        kwargs.setdefault('timeout', 3000)
        super().__init__(
            adapter,
            name,
            tcpip={'write_termination': '\n',
                   'read_termination': '\n'},
            **kwargs
        )
"
349,18000.0,USA,"Incorporates all of the powerful features of the Gemini GV digital servo drive
Provides six power ranges for up to 11.8 kW of continuous power
Stand-alone servo controller and drive in one small package
Full ASCII communications capability
Control features such as registration, motion profiles, S-curve velocity profiling and conditional statements
Program storage: Up to 32 programs or 190 lines of program code
Daisy chain up to 99 units
Simplified configuration and tuning
8 programmable inputs and 6 programmable outputs
Wide range of PWM frequencies for linear motor support",Parkergv 6,413.0,"Parker Hannifin Corporation, originally Parker Appliance Company, usually referred to as just Parker, is an American corporation specializing in motion and control technologies.
",Pymeasure,Parker,"[OrderedDict([('id', 'att6lk5W7YnbSjvnS'), ('width', 1024), ('height', 393), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GchXVYHHRKoyTiPZmyeoiA/Z6XALU5DtzbN-m8Z4QHo-LDnO7dc7V6AWwrdKPEri0QYTPx8XiOt90cQAWho6NlDNHbFZU5bUoBw1DC3TBBc8UwZMgriYVRh3stOtnPlyY7figCP43S7oQlZdqtsOakM/A8HFPrpIRPNpF-kzdUt26omxIdUnpq_7mAiVPDX3sqE'), ('filename', '1024px-Parker_Hannifin.svg_.png'), ('size', 12933), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MM09qVLQs90QwdXHYpg-MA/rorlfnoVGCm6Yl3YlUGhi9G54KuT9Rq5i8chBwUSIt82TJkc7FtB76MMCZUVbc6bfnfdhxRsCASHmnLmkipZ3Q/6Wy6-jCYU7gZyaCpFmypGlkQ0Bf_ime6XYTjyWw67v8'), ('width', 94), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MAZvkGxIu9HxqN3xnik73Q/43i6rwPcC1Lp3xd3S2Aa3EnbrPEbsyNntKKF5OPseUZd9eQMebaYy4yir6CuWnaWAbnQE5u54sbP1pVKDub6sw/ffheccaQRX6gZKsatLWE--a6j7anK_UBnqazh-SI6q4'), ('width', 1024), ('height', 393)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TVa66PHhhm7NFLfwtqOx9w/-9QhOFWub__vGoFQE1zNKCRJpQPJSJMshg_h5t00c2dOKe9V1QbcrJzxtqAVTDOP4SLMxwtkioREny5zEmwDkg/7LoYR0J0pynyoYooZjHWK0UGJIEqRVNyv918uHfx9cM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.parker.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a Gemini GV6 ,https://en.wikipedia.org/wiki/Motor_controller,,"A motor controller is a device or group of devices that can coordinate in a predetermined manner the performance of an electric motor. A motor controller might include a manual or automatic means for starting and stopping the motor, selecting forward or reverse rotation, selecting and regulating the speed, regulating or limiting the torque, and protecting against overloads and electrical faults. Motor controllers may use electromechanical switching, or may use power electronics devices to regulate the speed and direction of a motor.",Gemini GV6,https://divapps.parker.com/divapps/emn/prior_version_compumotor/cat/english/pgs95_113_gem_servo.pdf,"[OrderedDict([('id', 'att1GKkDCDEW0jJMO'), ('width', 400), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IRdzZ2BfBBS6g51rHW1Pxg/aEi4OQ7nSaCBbs_Ip9PK3ZdPICChk8lNxkgj9OSpoAx4b4FA5BYtKmjB0wYbSStK0Wdcta951T5SQazgdO8SQMJCw-OGlcur2UXzmKGRPAk/ZwdAm1w8sy1you-hl4DG3aHEC4qqcCHCp6gQB8wGjZc'), ('filename', 'gv6-h20e.jpg'), ('size', 35463), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DVoTzxzLg5PnCUNEzPWQJw/s5Y7lrxuxAwbQR2yzhZv0mTNa3xhzADThjKC12f4_p0YWLOhHDe_aNz3Xn46ZsnGnsfJYZU4YZJXBGWpoRRQkg/3HvTEyq0JxckkZDXEq1g1BCKexGCncEH3_vjjYEN_Dk'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iFHk7NrmuGBs5O7lAln01w/CrvwnTMDo72VSp4nxu3RDSMo6_5Q8wapHFf0m8Tyeh9bicEtLUZecyV4_Ro54zqDdOuLjfmejJP7v99PvEcH0Q/caqJ-CtjFB-Qi0wlinJz-oX3sH61Q0csn0H6iLKIh98'), ('width', 400), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tSY2zzqvEsSMzPHyGfq2_g/p-MtNpIQgchk95tO8oKi7du5LhtNN0aB_kob-kgjvU3D33n4anqDZqmWJjN-DNj0z3SH2q8gM13TvHSlfyKe0Q/mxM9UCY6TdQUJ0v4Rrs52L_G6q24pPAddgFpa_iuS1Q'), ('width', 3000), ('height', 3000)]))]))])]",https://www.parkermotion.com/products/Servo_Drive_Controllers__5336__30_32_80_567_29.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/parker/parkerGV6.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/parker/parkerGV6.html,6208.0,,,Price from here: https://shop.appliedindustrialautomation.com/products/GV6-U12E-NK,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from time import sleep
import re


class ParkerGV6(Instrument):
    """""" Represents the Parker Gemini GV6 Servo Motor Controller
    and provides a high-level interface for interacting with
    the instrument
    """"""

    degrees_per_count = 0.00045  # 90 deg per 200,000 count

    def __init__(self, adapter, name=""Parker GV6 Motor Controller"", **kwargs):
        super().__init__(
            adapter,
            name,
            asrl={'baud_rate': 9600,
                  'timeout': 500,
                  },
            write_termination=""\r"",
            **kwargs
        )
        self.set_defaults()

    def read(self):
        """""" Overwrites the Instrument.read command to provide the correct
        functionality
        """"""
        # TODO seems to be broken as it does not make sense see issue #623
        return re.sub(r'\r\n\n(>|\?)? ', '', ""\n"".join(self.readlines()))

    def set_defaults(self):
        """""" Sets up the default values for the motor, which
        is run upon construction
        """"""
        self.echo = False
        self.set_hardware_limits(False, False)
        self.use_absolute_position()
        self.average_acceleration = 1
        self.acceleration = 1
        self.velocity = 3

    def reset(self):
        """""" Resets the motor controller while blocking and
        (CAUTION) resets the absolute position value of the motor
        """"""
        self.write(""RESET"")
        sleep(5)
        self.setDefault()
        self.enable()

    def enable(self):
        """""" Enables the motor to move """"""
        self.write(""DRIVE1"")

    def disable(self):
        """""" Disables the motor from moving """"""
        self.write(""DRIVE0"")

    @property
    def status(self):
        """""" Returns a list of the motor status in readable format """"""
        return self.ask(""TASF"").split(""\r\n\n"")

    def is_moving(self):
        """""" Returns True if the motor is currently moving """"""
        return self.position is None

    @property
    def angle(self):
        """""" Returns the angle in degrees based on the position
        and whether relative or absolute positioning is enabled,
        returning None on error
        """"""
        position = self.position
        if position is not None:
            return position * self.degrees_per_count
        else:
            return None

    @angle.setter
    def angle(self, angle):
        """""" Gives the motor a setpoint in degrees based on an
        angle from a relative or absolution position
        """"""
        self.position = int(angle * self.degrees_per_count**-1)

    @property
    def angle_error(self):
        """""" Returns the angle error in degrees based on the
        position error, or returns None on error
        """"""
        position_error = self.position_error
        if position_error is not None:
            return position_error * self.degrees_per_count
        else:
            return None

    @property
    def position(self):
        """""" Returns an integer number of counts that correspond to
        the angular position where 1 revolution equals 4000 counts
        """"""
        match = re.search(r'(?<=TPE)-?\d+', self.ask(""TPE""))
        if match is None:
            return None
        else:
            return int(match.group(0))

    @position.setter
    def position(self, counts):  # in counts: 4000 count = 1 rev
        """""" Gives the motor a setpoint in counts where 4000 counts
        equals 1 revolution
        """"""
        self.write(""D"" + str(int(counts)))

    @property
    def position_error(self):
        """""" Returns the error in the number of counts that corresponds
        to the error in the angular position where 1 revolution equals
        4000 counts
        """"""
        match = re.search(r'(?<=TPER)-?\d+', self.ask(""TPER""))
        if match is None:
            return None
        else:
            return int(match.group(0))

    def move(self):
        """""" Initiates the motor to move to the setpoint """"""
        self.write(""GO"")

    def stop(self):
        """""" Stops the motor during movement """"""
        self.write(""S"")

    def kill(self):
        """""" Stops the motor """"""
        self.write(""K"")

    def use_absolute_position(self):
        """""" Sets the motor to accept setpoints from an absolute
        zero position
        """"""
        self.write(""MA1"")
        self.write(""MC0"")

    def use_relative_position(self):
        """""" Sets the motor to accept setpoints that are relative
        to the last position
        """"""
        self.write(""MA0"")
        self.write(""MC0"")

    def set_hardware_limits(self, positive=True, negative=True):
        """""" Enables (True) or disables (False) the hardware
        limits for the motor
        """"""
        if positive and negative:
            self.write(""LH3"")
        elif positive and not negative:
            self.write(""LH2"")
        elif not positive and negative:
            self.write(""LH1"")
        else:
            self.write(""LH0"")

    def set_software_limits(self, positive, negative):
        """""" Sets the software limits for motion based on
        the count unit where 4000 counts is 1 revolution
        """"""
        self.write(""LSPOS%d"" % int(positive))
        self.write(""LSNEG%d"" % int(negative))

    @property
    def echo(self):
        pass

    @echo.setter
    def echo(self, enable=False):
        """""" Enables (True) or disables (False) the echoing
        of all commands that are sent to the instrument
        """"""
        if enable:
            self.write(""ECHO1"")
        else:
            self.write(""ECHO0"")

    @property
    def acceleration(self):
        pass  # TODO: Implement acceleration return value

    @acceleration.setter
    def acceleration(self, acceleration):
        """""" Sets the acceleration setpoint in revolutions per second
        squared
        """"""
        self.write(""A"" + str(float(acceleration)))

    @property
    def average_acceleration(self):
        pass  # TODO: Implement average_acceleration return value

    @average_acceleration.setter
    def average_acceleration(self, acceleration):
        """""" Sets the average acceleration setpoint in revolutions
        per second squared
        """"""
        self.write(""AA"" + str(float(acceleration)))

    @property
    def velocity(self):
        pass  # TODO: Implement velocity return value

    @velocity.setter
    def velocity(self, velocity):  # in revs/s
        """""" Sets the velocity setpoint in revolutions per second """"""
        self.write(""V"" + str(float(velocity)))
"
351,318.0,Japan,"The GS200 is a low voltage/current DC source with high accuracy, high stability, and high resolution. With its excellent traceability, stability, and 5 1/2-digit resolution, the GS200 generates extremely low-noise DC voltage and current signals that are required for many applications. Additionally, the optional monitoring feature turns the GS200 into a voltage and current measuring instrument.",Yokogawags 200,638.0,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",Pymeasure,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UaAsDYNLAOdUQ4cG-gVBw/NTY986xzNYwKbonHbWwWC4LeHEHqycOQeXYwRbRUCHdcuhOKGAvrvBoatXQsD5bpSMp051hQO8G6Z1_BiSG1VC6MM2RwFw-JgfT3HK4pXZo/cdsfM51bauCXQpD2o4jMtv4J_4Pc6fMk_dJlEKX20e0'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0FZ2eqXGORQw7KhD8ggQhA/54nn9VVUA8rLZTUqpQNJJRRABVqmHyYpr39PgVnaWermrd9uQk4oKjA-U_ElbfbtDYyDeyOy0wUoLtc2W5106g/xl6wqD05nzCPSKrDuCKrzZgEG0XSnoQSadmaYKdpFJM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HaEWyRlZBthPGsYttIxnHQ/Dg6dnKGNXLv3Mh6hmw3-ew1Frbuj6oI01Vn3HH6YZCGh51cSS68iCmPrXpZJPdTo-4wfWlWjjSEU4Ca-zmtRlQ/eXk6rUTl5KsnGehm3vQUBE5QCuNLX-D5bbpf0_IxIrM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IbzTBl4xKhTim-kj9IZJWw/jqTaszS54GnOhLIRvMV0S3ODA6kF-CfXSMb2hQnB7aSuYMsMIsRnYenR7US3v50OI9A0DzAtFvhKHusA-qJEaw/o46lbBXBsIcuUNQKSTjhxI0hmLRfL48B90X8oBZ96jI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,Write a Python script that uses Pymeasure to connect to a GS200 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ",GS200,https://cdn.tmi.yokogawa.com/1/7543/files/BUGS200-01EN.pdf,"[OrderedDict([('id', 'attVoxpUxYSQ6kk0I'), ('width', 800), ('height', 366), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hk0VJxBmbRexUhpKO_-l4w/pnchoYJrmCRD1X-YAkeK9hIZy5ACFC8o-BbenCOSXF0rtbp5CcHj7qGXuJYF8LIgdWa7tJj9tqPGab5_wgmnQzJGeUiBj3kJPo6NPkUjxEw/Ry7cxR0UNMV3aw-MqAr3wawDNKoxjNIp0nmWPbf_HQw'), ('filename', 'gs200_4.jpg'), ('size', 54439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aRydi7OJi5TxDJNQ4sNgaw/pGFLlqfTkuqSG89ToWd-9P1vna7mElQ5o-g8s_Rp0aH67f6lUEdlyR-6Lx6PhRyEEQ2a3tZYION2Oa4syijD1A/h5-Imre2PMwCYNOE6feE8Xvy52_nic-9-dHO54nhuWs'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BlZKe0UB2ATqHQoLcLScHw/hiCyQOrNn7tadTBH4RvkYIDUVBBIvHkdBQyYd0KeEpGFYXRNIEGMxSewgN1jBsBFbA5XSrxv0LSzWyid5j98AA/QPW2hzu1Oo6zJ_QlSPILlZJZxbii8VnsjOOdh0DpmcQ'), ('width', 800), ('height', 366)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eH2rP8rLO5MhZClD6I37RA/TyWYIZa7BHf2CkaipW1705XTqJUtzr4vt-azifWxgfDOXbZ6UXngMfHBX9TbTq7mew8byvTfvhxJor36gCotZA/MokrZQZToDfxgVUh8TG3o_6OOawjGHSG_5x4HpboTbI'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/products/generators-sources/source-measure-units/gs200/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/yokogawa/yokogawags200.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/yokogawa/yokogawags200.html,3499.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    strict_discrete_set, truncated_discrete_set, truncated_range
)

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

MIN_RAMP_TIME = 0.1  # seconds


class YokogawaGS200(Instrument):
    """""" Represents the Yokogawa GS200 source and provides a high-level interface for interacting
    with the instrument. """"""

    source_enabled = Instrument.control(
        ""OUTPut:STATe?"",
        ""OUTPut:STATe %d"",
        """"""A boolean property that controls whether the source is enabled, takes values
        True or False. """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_mode = Instrument.control(
        "":SOURce:FUNCtion?"",
        "":SOURce:FUNCtion %s"",
        """"""String property that controls the source mode. Can be either 'current' or 'voltage'."""""",
        validator=strict_discrete_set,
        values={'current': 'CURR', 'voltage': 'VOLT'},
        get_process=lambda s: s.strip()
    )

    source_range = Instrument.control(
        "":SOURce:RANGe?"",
        ""SOURce:RANGe %g"",
        """"""Floating point number that controls the range (either in voltage or current)
        of the output. ""Range"" refers to the maximum source level. """""",
        validator=truncated_discrete_set,
        values=[1e-3, 10e-3, 100e-3, 200e-3, 1, 10, 30]
    )

    voltage_limit = Instrument.control(
        ""SOURce:PROTection:VOLTage?"",
        ""SOURce:PROTection:VOLTage %g"",
        """"""Floating point number that controls the voltage limit. ""Limit"" refers to maximum
        value of the electrical value that is conjugate to the mode (current is conjugate to
        voltage, and vice versa). Thus, voltage limit is only applicable when in 'current' mode"""""",
        validator=truncated_range,
        values=[1, 30]
    )

    current_limit = Instrument.control(
        ""SOURce:PROTection:CURRent?"",
        ""SOURce:PROTection:CURRent %g"",
        """"""Floating point number that controls the current limit. ""Limit"" refers to maximum value
        of the electrical value that is conjugate to the mode (current is conjugate to voltage,
        and vice versa). Thus, current limit is only applicable when in 'voltage' mode"""""",
        validator=truncated_range,
        values=[1e-3, 200e-3]
    )

    def __init__(self, adapter, name=""Yokogawa GS200 Source"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    @property
    def source_level(self):
        """""" Floating point number that controls the output level, either a voltage or a current,
        depending on the source mode.
        """"""
        return float(self.ask("":SOURce:LEVel?""))

    @source_level.setter
    def source_level(self, level):
        if level > self.source_range * 1.2:
            raise ValueError(
                ""Level must be within 1.2 * source_range, otherwise the Yokogawa will produce an ""
                ""error.""
            )
        else:
            self.write(""SOURce:LEVel %g"" % level)

    def trigger_ramp_to_level(self, level, ramp_time):
        """"""
        Ramp the output level from its current value to ""level"" in time ""ramp_time"". This method
        will NOT wait until the ramp is finished (thus, it will not block further code evaluation).

        :param float level: final output level
        :param float ramp_time: time in seconds to ramp
        :return: None
        """"""
        if not self.source_enabled:
            raise ValueError(
                ""YokogawaGS200 source must be enabled in order to ramp to a specified level. ""
                ""Otherwise, the Yokogawa will reject the ramp.""
            )
        if ramp_time < MIN_RAMP_TIME:
            log.warning(
                f""Ramp time of {ramp_time}s is below the minimum ramp time of {MIN_RAMP_TIME}s, ""
                f""so the Yokogawa will instead be instantaneously set to the desired level.""
            )
            self.source_level = level
        else:
            # Use the Yokogawa's ""program"" mode to create the ramp
            ramp_program = (
                f"":program:edit:start;""
                f"":source:level {level};""
                f"":program:edit:end;""
            )
            # set ""interval time"" equal to ""slope time"" to make a continuous ramp
            ramp_program += (
                f"":program:interval {ramp_time};""
                f"":program:slope {ramp_time};""
            )
            # run it once
            ramp_program += (
                "":program:repeat 0;""
                "":program:run""
            )
            self.write(ramp_program)
"
353,1.0,US,"The Andeen-Hagerling AH 2700A offers unparalleled stability, resolution, linearity and accuracy in a multi-frequency capacitance/loss bridge. Its numerous state-of-the-art features make it an exceptionally user-friendly instrument, measuring capacitance and loss in medium and high impedance ranges, and thus allows using three-terminal rather than five-terminal connections to the DUT (Device Under Test).

The new AH 2700A-E offers substantially improved resolution over the entire operating range, bringing a super-sensitivity that enables it to explore applications in calibration, scientific research, and manufacturing with a new precision.

The AH2700A-E is the pinnacle of decades of Andeen-Hagerling experience in bridge design and manufacture, and is complemented by its sister model, the AH2700A-E-C that offers continuous frequency scanning.",AH 2700 A,79.0,"**Andeen**-**Hagerling**, Inc. - manufacturers of the world's most accurate capacitance bridges and standards

",Pymeasure,Andeen Hagerling,"[OrderedDict([('id', 'attHkizub4S6653G8'), ('width', 375), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Wdzc-_rA_DV-LMwtpc8Asg/dEUzTAi0zId1jgPJmnMCPMB2ilXzeTbDYYoygb7QIMj9rgi4uXpOPB_cjFm3vxoiYLQqSkJj-HcHmyu4oH9mEf2M9iogdcrZ0ASpymfcF8U/kvgFqI46CuvGga3xt14YhNGZlzsfKh61CGDbU9omD48'), ('filename', 'AH_Logo-375x200.jpg'), ('size', 5603), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7rscRbu7yWIRUSqm7zzudw/9kODe2p0e4X1Y12DFtmzXSnz-M1Mz3EmZGiOFpTRjiCbNOIYSKM-j5bieBkV1Q1Knpr1hEmD7Q1yUWb7uSpb-w/iXWcnXND4EjzeszSS-HK1jJKLMl0UZ27g9oMpJu1JmA'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yNpFJ0EOm3rvmz4jkIOeQg/MfQoShnsfLD1e8bXB0kd8jkkgVDJtFZLc4FXgBlJq0BJWMiwpWVmbjTEAhf2l9XfH6ZXLOSuV0w51-ILC0zmkg/mQnKJKlhMZ1ZWu0aZwTMhg75L8vlY5nAz5OXuqviNgI'), ('width', 375), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-GeOZn3lpmqeDkkrzngVrw/vXLLlqEAcn3qdgW2jFKFAQU4lxkRR37t7wWmn6W3PrSwKK3hB7aq1-BR0ACGDTFhWmBPMofPFEnnIg2h9v9s2g/Y38kglQ0z7GRMP1NET7LewCdTpJFsI7NmTLIrpN2uik'), ('width', 3000), ('height', 3000)]))]))])]",http://www.andeen-hagerling.com/,Write a Python script that uses Pymeasure to connect to a 2700A Bridge Multimeters,https://electricalacademia.com/instrumentation-and-measurements/capacitance-bridge-circuit/,['Multimeters'],"Capacitance Bridge
A Maxwell Inductance Capacitance Bridge (known as a Maxwell Bridge) is a modified version of a Wheatstone bridge which is used to measure the self-inductance of a circuit.",2700A Bridge,http://www.andeen-hagerling.com/ah2700a.pdf,"[OrderedDict([('id', 'attTIP6EtYa88Q5Do'), ('width', 500), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e6GgxbOyF1U2gvT9VbzmlA/89EQZwAT0CSHrEzzR_zdvIjdFB-3jHCGblmyImE5kqUQa-7IaTvZYO6wZbQmK4gMwS6FS8uALeKJJwvZFNTPm90Uz2XDQuj-WxiEMZ-RpNo/qe06kGnFwWD0BU4OC1fykzVInperOmRKsz31bpk2YdI'), ('filename', 'MODEL2700-500x500w.jpg'), ('size', 28499), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6u9uohB3KrkMUTpbFb7toQ/wHKHVNTberC1wqkVrvVkh919yrSrUuJiELZv2DVOCLyj0BspAdkBpWPN3a0bRWRwLAehHhW5NSnlR1gQ8fdAMQ/m2wJ7Df-IWcFL0-KvEjykwqz5fBTb_RmEkrKHlsoPV8'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tP2EQ1EeaTBmCZiyx5aIRA/feFh6TJMnX34wqfswxZsZeWwXOIflk6SDRt23caVfrSBNeErCQTpoAb3FrO-sB1d-INFYuEttQRRgdYshcNVKw/YSdFRI1ZI7TyYZc2kpwoZ0DjEgP_ZcjajxXIMzU1vC4'), ('width', 500), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0_TzsLZNYvyRMnb4upRf-A/E5rHif53hvUIA9xXh2vU_bBECfXP1JEaAvJDZzgijiuLLW3oQog80zXc9-u01EElRSHizWQN22HXwi8H_kC3gA/_VGLzq_3jERw32Y17_5OG-XuxB51gpSdzJWPq5W-IFw'), ('width', 3000), ('height', 3000)]))]))])]",http://www.andeen-hagerling.com/ah2700a.htm,https://github.com/lupien/pyHegel/blob/master/pyHegel/instruments/others.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/andeenhagerling/ah2700a.html,,"
",,,"# -*- coding: utf-8 -*-

########################## Copyrights and license ############################
#                                                                            #
# Copyright 2011-2015  Christian Lupien <christian.lupien@usherbrooke.ca>    #
#                                                                            #
# This file is part of pyHegel.  http://github.com/lupien/pyHegel            #
#                                                                            #
# pyHegel is free software: you can redistribute it and/or modify it under   #
# the terms of the GNU Lesser General Public License as published by the     #
# Free Software Foundation, either version 3 of the License, or (at your     #
# option) any later version.                                                 #
#                                                                            #
# pyHegel is distributed in the hope that it will be useful, but WITHOUT     #
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      #
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public        #
# License for more details.                                                  #
#                                                                            #
# You should have received a copy of the GNU Lesser General Public License   #
# along with pyHegel.  If not, see <http://www.gnu.org/licenses/>.           #
#                                                                            #
##############################################################################

from __future__ import absolute_import

import numpy as np
import random
import time
from scipy.optimize import brentq as brentq_rootsolver

from ..instruments_base import BaseInstrument, visaInstrument, visaInstrumentAsync,\
                            BaseDevice, scpiDevice, MemoryDevice, Dict_SubDevice, ReadvalDev,\
                            ChoiceBase, ChoiceMultiple, ChoiceMultipleDep, ChoiceSimpleMap,\
                            ChoiceStrings, ChoiceIndex,\
                            make_choice_list, _fromstr_helper,\
                            decode_float64, visa_wrap, locked_calling,\
                            Lock_Extra, Lock_Instruments, _sleep_signal_context_manager, wait,\
                            release_lock_context, mainStatusLine, quoted_string, Choice_bool_OnOff,\
                            resource_info
from ..types import dict_improved
from ..instruments_registry import register_instrument, register_usb_name, register_idn_alias

from .logical import FunctionDevice, ScalingDevice

# for pfeiffer
import threading
import weakref

# for BIAS-DAC
import struct

# for micro_lambda_wireless
import socket

#######################################################
##    Yokogawa source
#######################################################

register_usb_name('Yokogawa Electric Corporation', 0x0B21)

# To implement hardware sweeping:
#  can use program with interval and slope.
#   interval needs to be >= slope
#  They both are time with resolution of .1 s
#  can have 10000 program steps
#  cannot readback ramping state or program
#  can use pause/cont  or hold/hold to pause and restart
#    pause/cont produce errors
#  the program steps consists of level,range,function
#  can define program like:
#     :prog:memory ""0,1,V\n.5,1,V""
#  When the range changes (between prog steps or between current and first step),
#   the slope is not working.
#  Count is incremented will the program is running. Goes back to 1 at the end
#  Can see level/steps/prog completion with :status:event? bits 5,6,7 (32,64,128)
#      level is set when slope is done, steps when interval is done.
#  the :status:event bit 8 (256) is toggled by changing the program (prog:edit:start, prog:edit:end, or frontpanel)
#   but not by prog:memory
# can't run a program if the output is disabled
# OPC does not work for programs

@register_instrument('YOKOGAWA', 'GS210', usb_vendor_product=[0x0B21, 0x0039])
#@register_instrument('YOKOGAWA', 'GS210', '1.05')
#@register_instrument('YOKOGAWA', 'GS210', '1.02')
class yokogawa_gs200(visaInstrument):
    # TODO: implement multipliers, units. The multiplier
    #      should be the same for all instruments, and be stripped
    #      before writing and going to the cache (in BaseDevice)
    #      This is probably not needed. Just use 1e3
    # case insensitive
    multipliers = ['YO', 'ZE', 'EX', 'PE', 'T', 'G', 'MA', 'K', 'M', 'U', 'N', 'P',
                   'F', 'A', 'Z', 'Y']
    multvals    = [1e24, 1e21, 1e18, 1e15, 1e12, 1e9, 1e6, 1e3, 1e-3, 1e-6, 1e-9, 1e-12,
                   1e-15, 1e-18, 1e-21, 1e-24]
    def init(self, full=False):
        # clear event register, extended event register and error queue
        self.clear()
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('function', 'range', 'level', 'output_en', options)
    def _create_devs(self):
        #self.level_2 = wrapDevice(self.levelsetdev, self.levelgetdev, self.levelcheck)
        self.function = scpiDevice(':source:function', choices=ChoiceStrings('VOLT', 'CURRent')) # use 'voltage' or 'current'
        # voltage or current means to add V or A in the string (possibly with multiplier)
        self.range = scpiDevice(':source:range', str_type=float, setget=True) # can be a voltage, current, MAX, MIN, UP or DOWN
        #self.level = scpiDevice(':source:level') # can be a voltage, current, MAX, MIN
        self.voltlim = scpiDevice(':source:protection:voltage', str_type=float, setget=True) #voltage, MIN or MAX
        self.currentlim = scpiDevice(':source:protection:current', str_type=float, setget=True) #current, MIN or MAX
        self.output_en = scpiDevice('OUTPut', str_type=bool)
        self._devwrap('level', setget=True)
        self.alias = self.level
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def _level_checkdev(self, val):
        rnge = 1.2*self.range.getcache()
        if self.function.getcache()=='CURR' and rnge>.2:
            rnge = .2
        if abs(val) > rnge:
            raise ValueError, self.perror('level is invalid')
    def _level_getdev(self):
        return float(self.ask(':source:level?'))
    def _level_setdev(self, val):
        # used %.6e instead of repr
        # repr sometimes sends 0.010999999999999999
        # which the yokogawa understands as 0.010 instead of 0.011
        self.write(':source:level %.6e'%val)


#######################################################
##    Stanford Research SR830 Lock-in Amplifier
#######################################################

#@register_instrument('Stanford_Research_Systems', 'SR830', 'ver1.07 ')
@register_instrument('Stanford_Research_Systems', 'SR830', alias='SR830 LIA')
class sr830_lia(visaInstrument):
    """"""
    Don't forget to set the async_wait to some usefull values.
     might do set(sr1.async_wait, 1.)
    when using 24dB/oct, 100ms filter.

    You can use find_n_time and find_fraction to set the time.
    For example: set(sr1.async_wait, sr1.find_n_time(.99,sec=True))

    To read more than one channel at a time use readval/fetch(snap)
    Otherwise you can use x, y, t, theta
    """"""
    # TODO setup snapsel to use the names instead of the numbers
    _snap_type = {1:'x', 2:'y', 3:'R', 4:'theta', 5:'Aux_in1', 6:'Aux_in2',
                  7:'Aux_in3', 8:'Aux_in4', 9:'Ref_Freq', 10:'Ch1', 11:'Ch2'}
    def init(self, full=False):
        # This empties the instrument buffers
        self._dev_clear()
    def _check_snapsel(self,sel):
        if not (2 <= len(sel) <= 6):
            raise ValueError, 'snap sel needs at least 2 and no more thant 6 elements'
    def _snap_getdev(self, sel=[1,2], norm=False):
        # sel must be a list
        self._check_snapsel(sel)
        sel = map(str, sel)
        data = decode_float64(self.ask('snap? '+','.join(sel)))
        if norm:
            amp = self.srclvl.get()
            data_norm = data/amp
            data = np.concatenate( (data_norm, data) )
        return data
    def _snap_getformat(self, sel=[1,2], norm=False, **kwarg):
        self._check_snapsel(sel)
        headers = [ self._snap_type[i] for i in sel]
        if norm:
            headers = map(lambda x: x+'_norm', headers) + headers
        d = self.snap._format
        d.update(multi=headers, graph=range(len(sel)))
        return BaseDevice.getformat(self.snap, sel=sel, **kwarg)
    def auto_offset(self, ch='x'):
        """"""
           commands the auto offset for channel ch
           which can be 'x', 'y' or 'r'
        """"""
        choices=ChoiceIndex(['x', 'y', 'r'], offset=1)
        ch_i = choices.tostr(ch)
        self.write('aoff '+ch_i)
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        #base = ['async_delay=%r'%self.async_delay]
        return self._conf_helper('async_delay','async_wait', 'freq', 'sens', 'srclvl', 'harm', 'phase', 'timeconstant', 'filter_slope',
                                 'sync_filter', 'reserve_mode',
                                 'offset_expand_x', 'offset_expand_y', 'offset_expand_r',
                                 'input_conf', 'grounded_conf', 'dc_coupled_conf', 'linefilter_conf',
                                 'auxout1', 'auxout2', 'auxout3', 'auxout4', options)
    def _create_devs(self):
        self.freq = scpiDevice('freq', str_type=float, setget=True, min=0.001, max=102e3)
        sens = ChoiceIndex(make_choice_list([2,5,10], -9, -1), normalize=True)
        self.sens = scpiDevice('sens', choices=sens, doc='Set the sensitivity in V (for currents it is in uA)')
        self.oauxi1 = scpiDevice(getstr='oaux? 1', str_type=float)
        self.auxout1 = scpiDevice('AUXV 1,{val}', 'AUXV? 1', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout2 = scpiDevice('AUXV 2,{val}', 'AUXV? 2', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout3 = scpiDevice('AUXV 3,{val}', 'AUXV? 3', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout4 = scpiDevice('AUXV 4,{val}', 'AUXV? 4', str_type=float, setget=True, min=-10.5, max=10.5)
        self.srclvl = scpiDevice('slvl', str_type=float, min=0.004, max=5., setget=True)
        self.harm = scpiDevice('harm', str_type=int, min=1, max=19999)
        self.phase = scpiDevice('phas', str_type=float, min=-360., max=729.90, setget=True)
        timeconstants = ChoiceIndex(make_choice_list([10, 30], -6, 3), normalize=True)
        self.timeconstant = scpiDevice('oflt', choices=timeconstants)
        filter_slopes=ChoiceIndex([6, 12, 18, 24])
        self.filter_slope = scpiDevice('ofsl', choices=filter_slopes, doc='in dB/oct\n')
        self.sync_filter = scpiDevice('sync', str_type=bool)
        self.x = scpiDevice(getstr='outp? 1', str_type=float, trig=True)
        self.y = scpiDevice(getstr='outp? 2', str_type=float, trig=True)
        self.r = scpiDevice(getstr='outp? 3', str_type=float, trig=True)
        off_exp = ChoiceMultiple(['offset_pct', 'expand_factor'], [float, ChoiceIndex([1, 10 ,100])])
        self.offset_expand_x = scpiDevice('oexp 1,{val}', 'oexp? 1', choices=off_exp, setget=True)
        self.offset_expand_y = scpiDevice('oexp 2,{val}', 'oexp? 2', choices=off_exp, setget=True)
        self.offset_expand_r = scpiDevice('oexp 3,{val}', 'oexp? 3', choices=off_exp, setget=True)
        self.theta = scpiDevice(getstr='outp? 4', str_type=float, trig=True)
        input_conf = ChoiceIndex(['A', 'A-B', 'I1', 'I100'])
        self.input_conf = scpiDevice('isrc', choices=input_conf, doc='For currents I1 refers to 1 MOhm, I100 refers to 100 MOhm\n')
        self.grounded_conf = scpiDevice('ignd', str_type=bool)
        self.dc_coupled_conf = scpiDevice('icpl', str_type=bool)
        reserve_mode = ChoiceIndex(['high', 'normal', 'low'])
        self.reserve_mode = scpiDevice('rmod', choices=reserve_mode)
        linefilter = ChoiceIndex(['none', 'line', '2xline', 'both'])
        self.linefilter_conf = scpiDevice('ilin', choices=linefilter, doc='Selects the notch filters')
        # status: b0=Input/Reserver ovld, b1=Filter ovld, b2=output ovld, b3=unlock,
        # b4=range change (accross 200 HZ, hysteresis), b5=indirect time constant change
        # b6=triggered, b7=unused
        self.status_byte = scpiDevice(getstr='LIAS?', str_type=int)
        self._devwrap('snap', trig=True, doc=""""""
            This device can be called snap or fetch (they are both the same)
            This device obtains simultaneous readings from many inputs.
            To select the inputs, use the parameter
             sel
            which is [1,2] by default.
            The numbers are taken from the following dictionnary:
                %r
            The option norm when True return the data divided by the srclvl (and followed by raw data)
                """"""%self._snap_type)
        self.fetch = self.snap
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):   unused
          bit 1 (2):   Backup error
          bit 2 (4):   RAM error
          bit 3 (8):   Unused
          bit 4 (16):  Rom error
          bit 5 (32):  GPIB error
          bit 6 (64):  DSP error
          bit 7 (128): Math Error
        """"""
        return int(self.ask('ERRS?'))
    def find_fraction(self, n_time_constant, n_filter=None, time_constant=None, sec=False):
        """"""
        Calculates the fraction of a step function that is obtained after
        n_time_constant*time_constant time when using n_filter
        n_filter is the order of the filter: 1, 2, 3 ...
        By default time_constant and n_filter are the current ones
        When sec is True the input time is in sec, not in time_constants
        """"""
        if n_filter is None:
            n_filter = self.filter_slope.getcache()
            n_filter = self.filter_slope.choices.index(n_filter)+1
        if time_constant is None:
            time_constant = self.timeconstant.getcache()
        if sec:
            n_time_constant /= time_constant
        t = n_time_constant
        et = np.exp(-t)
        if n_filter == 1:
            return 1.-et
        elif n_filter == 2:
            return 1.-et*(1.+t)
#        elif n_filter == 3:
#            return 1.-et*(1.+t+0.5*t**2)
#        elif n_filter == 4:
#            return 1.-et*(1.+t+0.5*t**2+t**3/6.)
        else:
            # general formula: 1-exp(-t)*( 1+t +t**/2 + ... t**(n-1)/(n-1)!) )
            m = 1.
            tt = 1.
            for i in range(1, n_filter):
                tt *= t/i
                m += tt
            return 1.-et*m
    def find_n_time(self, frac=.99, n_filter=None, time_constant=None, sec=False):
        """"""
        Does the inverse of find_fraction.
        Here, given a fraction, we find the number of time_constants needed to wait.
        When sec is true, it returs the time in sec not in number of time_constants.
        """"""
        if n_filter is None:
            n_filter = self.filter_slope.getcache()
            n_filter = self.filter_slope.choices.index(n_filter)+1
        if time_constant is None:
            time_constant = self.timeconstant.getcache()
        func = lambda x: self.find_fraction(x, n_filter, time_constant)-frac
        n_time = brentq_rootsolver(func, 0, 100)
        if sec:
            return n_time*time_constant
        else:
            return n_time


#######################################################
##    Stanford Research SR384 RF source
#######################################################

#@register_instrument('Stanford Research Systems', 'SG384', 'ver1.02.0E')
@register_instrument('Stanford Research Systems', 'SG384', alias='SG384 RF source')
class sr384_rf(visaInstrument):
    # This instruments needs to be on local state or to pass through local state
    #  after a local_lockout to actually turn off the local key.
    # allowed units: amp: dBm, rms, Vpp; freq: GHz, MHz, kHz, Hz; Time: ns, us, ms, s
    def init(self, full=False):
        # This clears the error state
        self.clear()
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('freq', 'en_lf', 'amp_lf_dbm', 'offset_low',
                                 'en_rf', 'amp_rf_dbm', 'en_hf', 'amp_hf_dbm',
                                 'phase', 'mod_en', options)
    def _create_devs(self):
        self.freq = scpiDevice('freq',str_type=float, min=1e-6, max=8.1e9)
        self.offset_low = scpiDevice('ofsl',str_type=float, min=-1.5, max=+1.5) #volts
        self.amp_lf_dbm = scpiDevice('ampl',str_type=float, min=-47, max=14.96) # all channel output power calibrated to +13 dBm only, manual says 15.5 for low but intruments stops at 14.96
        self.amp_rf_dbm = scpiDevice('ampr',str_type=float, min=-110, max=16.53)
        self.amp_hf_dbm = scpiDevice('amph',str_type=float, min=-10, max=16.53) # doubler
        self.en_lf = scpiDevice('enbl', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.en_rf = scpiDevice('enbr', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.en_hf = scpiDevice('enbh', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.phase = scpiDevice('phas',str_type=float, min=-360, max=360) # deg, only change by 360
        self.mod_en = scpiDevice('modl', str_type=bool) # 0 is off, 1 is on
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        """"""
         Pops last error
          ## Execution Errors
          0: No error
         10: Illegal value
         11: Illegal Mode
         12: Not allowed
         13: Recall Failed
         14: No clock option
         15: No RF doubler option
         16: No IQ option
         17: Failed self test
          ## Query Errors
         30: Lost data
         32: No listener
          ## Device dependent errors
         40: Failed ROM check
         42: Failed EEPROM check
         43: Failed FPGA check
         44: Failed SRAM check
         45: Failed GPIB check
         46: Failed LF DDS check
         47: Failed RF DDS check
         48: Failed 20 MHz PLL
         49: Failed 100 MHz PLL
         50: Failed 19 MHz PLL
         51: Failed 1 GHz PLL
         52: Failed 4 GHz PLL
         53: Failed DAC
          ## Parsing errors
        110: Illegal command
        111: Undefined command
        112: Illegal query
        113: Illegal set
        114: Null parameter
        115: Extra parameters
        116: Missing parameters
        117: Parameter overflow
        118: Invalid floating point number
        120: Invalid Integer
        121: Integer overflow
        122: Invalid Hexadecimal
        126: Syntax error
        127: Illegal units
        128: Missing units
          ## Communication errors
        170: Communication error
        171: Over run
          ## Other errors
        254: Too many errors
        """"""
        return int(self.ask('LERR?'))


#######################################################
##    Stanford Research SR780 2 channel network analyzer
#######################################################

#@register_instrument('Stanford_Research_Systems', 'SR780', 'ver116')
@register_instrument('Stanford_Research_Systems', 'SR780', alias='SR780 network analyser')
class sr780_analyzer(visaInstrumentAsync):
    """"""
    This controls a 2 channel network analyzer
    It currently only handles the FFT measurement group (not octave or swept sine).
    Markers are not handled. Only sine sources are handled.
    Useful devices:
        fetch, readval
        dump
        current_display
        current_channel
        freq_start, freq_stop, freq_center, freq_span
        window_type
        average_en
        average_type
        average_mode
        average_count_requested
        async_wait (needed for exponential average, not for linear)
    Useful methods:
        start
        get_xscale

    Changing a setup should be done in the following order
        meas_grp
        meas
        meas_view
        unit
    """"""
    def __init__(self, *args, **kwargs):
        super(sr780_analyzer, self).__init__(*args, **kwargs)
        # The parant __init__ overrides our selection of 'wait' mode
        # in _async_detect_setup(reset=True) in init. So lets set it back
        self._async_mode = 'wait'
    def init(self, full=False):
        # This empties the instrument buffers
        self._dev_clear()
        # This clears the error state, and status/event flags
        self.clear()
        if full:
            self._async_sre_flag = 2
            self.write('DSPE 0;*sre 2') # Display flags
            self._async_detect_setup(reset=True)
            #self._async_tocheck = 0
            #self._async_use_delay = False
            self.visa.write_termination = '\n'
            #self.visa.term_chars='\n'
            # The above turned on detection of termchar on read. This is not good for
            # raw reads so turn it off.
            # visa.vpp43.set_attribute(self.visa.vi, visa.VI_ATTR_TERMCHAR_EN, visa.VI_FALSE)
            self.write('OUTX 0') # Force interface to be on GPIB, in case it is not anymore (problem with dump function)
    def _async_select(self, devs=[]):
        # This is called during init of async mode.
        self._async_detect_setup(reset=True)
        for dev, kwarg in devs:
            if dev in [self.fetch, self.readval]:
                disp = kwarg.get('disp', None)
                self._async_detect_setup(disp=disp)
    def _async_detect_setup(self, disp=None, reset=False):
        if reset:
            # make the default async_mode is 'wait' so that if
            # _async_tocheck == 0, we just turn on wait.
            # This could happen when using run_and_wait before anything is set
            # Otherwise, getasync and readval both call async_select to setup
            # the mode properly (_async_mode and_async_tocheck).
            self._async_tocheck = 0
            self._async_mode = 'wait'
            return
        self._async_mode = 'srq'
        disp_org = self.current_display.getcache()
        if disp is None:
            disp = disp_org
        self.current_display.set(disp)
        # 0x2=A-linear avg, 0x4=A-settled, 0x200=B-linear, 0x400=B-settled
        if self.average_en.get(disp=disp):
            if self.average_type.get() in ['linear', 'FixedLength']:
                tocheck = 0x2
            else:
                self._async_mode = 'wait+srq'
                tocheck = 0x4
        else:
            tocheck = 0x4
        if disp == 'B':
            tocheck <<= 8
        self._async_tocheck |= tocheck
        self.current_display.set(disp_org)
    def _async_trigger_helper(self):
        # We are setup so that run_and_wait resuses the last config which starts
        # with a simple wait (could be invalid now if averaging is changed on the instrument).
        # Should not be a big deal since that is not a normal use of it.
        self._cum_display_status = 0
        self.write('PAUS') # make sure we are not scanning anymore.
        self.get_display_status() # reset the display status flags
        self.write('DSPE %i'%self._async_tocheck)
        self.write('STRT')
    def _get_esr(self):
        # This disables the get_esr in the async routines.
        return 0
    @locked_calling
    def start(self):
        """"""
        Same as pressing Start/Reset button.
        """"""
        self._async_trigger_helper()
    def _async_detect(self, max_time=.5): # 0.5 s max by default
        ret = super(sr780_analyzer, self)._async_detect(max_time)
        if self._async_mode == 'wait':
            # pure wait
            return ret
        if not ret:
            # Did not receive SRQ or wait long enough
            return False
        # Received SRQ, check if we are done
        disp_st = self.get_display_status()
        self._cum_display_status |= disp_st
        tocheck = self._async_tocheck
        #print 'tocheck %0x %0x %0x'%(tocheck, self._cum_display_status, disp_st)
        if self._cum_display_status&tocheck == tocheck:
            self.write('DSPE 0')
            self._cum_display_status = 0
            return True # We are done!
        return False
    def _fetch_getformat(self, **kwarg):
        xaxis = kwarg.get('xaxis', True)
        if xaxis:
            multi = ('freq', 'data')
        else:
            multi = True
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=[], xaxis=xaxis)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, disp=None, xaxis=True):
        """"""
        Optional parameter: disp and xaxis
         -disp:  To select which display to read.
         -xaxis: when True(default), the first column of data is the xaxis
        For faster transfer, make the view and unit the same type (both linear or both log)
        It is STRONGLY recommended to use linear averaging.
        For exponential averaging you need to specify a wait time with async_wait
         i.e. set(srnet.async_wait,3)  # for 3 seconds
        """"""
        # The instrument has 5 Traces that can be used for memory.
        # There is REFY? d,j to obtain pint j (0..length-1) in ref curve of display d
        #  DSPN? d to obtain lenght of data set
        if disp is not None:
            self.current_display.set(disp)
        disp = self.current_display.getcache()
        disp = self.current_display._tostr(disp)
        # DSPY returns ascii but is slower than DSPB (binary)
        # TODO implement handling of nyquist and nichols plot which return 2 values per datapoint.
        # TODO handle waterfalls: dswb
        data = self.ask('DSPB? %s'%disp, raw=True)
        ret = np.fromstring(data, np.float32)
        if xaxis:
            ret = ret = np.asarray([self.get_xscale(), ret])
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if options.has_key('disp'):
            self.current_display.set(options['disp'])
        want_ch = 1
        meas = self.meas.getcache()
        # This does not handle Coherence, CrossSpectrum F2/F1 ...
        if meas[-1] == '2' and meas[-4:-1] != 'ser':
            want_ch = 2
        orig_ch = self.current_channel.getcache()
        if want_ch != orig_ch:
            self.current_channel.set(want_ch)
        conf = self._conf_helper('current_display', 'current_channel',
                                 'input_source', 'input_mode', 'input_grounding', 'input_coupling',
                                 'input_range_dBV', 'input_autorange_en', 'input_autorange_mode', 'input_antialiasing_en',
                                 'input_aweight_en', 'input_auto_offset_en', 'input_eng_unit_en', 'input_eng_label',
                                 'input_eng_unit_scale', 'input_eng_unit_user',
                                 'freq_start', 'freq_stop', 'freq_resolution', 'freq_baseline', 'window_type',
                                 'meas_group', 'meas', 'meas_view',
                                 'meas_unit', 'dBm_ref', 'disp_PSD_en', 'disp_transducer_unit_mode',
                                 'disp_live_en',
                                 'average_en', 'average_mode', 'average_type', 'average_count_requested',
                                 'average_increment_pct', 'average_overload_reject_en', 'average_preview_type',
                                 'source_en', 'source_type', 'source_freq1', 'source_ampl1_V',
                                 'source_offset_V', 'source_freq2', 'source_ampl2_V', 'async_wait',
                                 options)
        if want_ch != orig_ch:
            self.current_channel.set(orig_ch)
        return conf
    def _create_devs(self):
        display_sel = ChoiceIndex(['A', 'B']) # also both=2
        self.current_display = MemoryDevice('A', choices=display_sel)
        self.current_channel = MemoryDevice(1, choices=[1, 2])
        self.freq_baseline = scpiDevice('FBAS 2,{val}', 'FBAS? 0', choices=ChoiceIndex([100e3, 102.4e3]))
        self.dBm_ref = scpiDevice('DBMR 2,{val}', 'DBMR? 2', str_type=float, min=0)
        self.source_en = scpiDevice('SRCO', str_type=bool)
        self.source_type = scpiDevice('STYP', choices=ChoiceIndex(['Sine', 'Chirp', 'Noise', 'Arbitrary']))
        self.source_freq1 = scpiDevice('S1FR', str_type=float)
        self.source_ampl1_V = scpiDevice('S1AM', str_type=float)
        self.source_offset_V = scpiDevice('SOFF', str_type=float)
        self.source_freq2 = scpiDevice('S2FR', str_type=float)
        self.source_ampl2_V = scpiDevice('S2AM', str_type=float)
        self.input_source = scpiDevice('ISRC', choices=ChoiceIndex(['Analog', 'Capture']))
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.input_mode = devChOption('I{ch}MD', choices=ChoiceIndex(['Analog', 'Capture']))
        self.input_grounding = devChOption('I{ch}GD', choices=ChoiceIndex(['Float', 'Ground']))
        self.input_coupling = devChOption('I{ch}CP', choices=ChoiceIndex(['DC', 'AC', 'ICP']))
        self.input_range_dBV = devChOption('I{ch}RG', str_type=int, choices=range(-50, 36, 2))
        self.input_autorange_en = devChOption('A{ch}RG', str_type=bool)
        self.input_autorange_mode = devChOption('I{ch}AR', choices=ChoiceIndex(['Normal', 'Tracking']))
        self.input_antialiasing_en = devChOption('I{ch}AF', str_type=bool)
        self.input_aweight_en = devChOption('I{ch}AW', str_type=bool)
        self.input_auto_offset_en = scpiDevice('IAOM', str_type=bool)
        self.input_eng_unit_en = devChOption('EU{ch}M', str_type=bool)
        self.input_eng_label = devChOption('EU{ch}L', str_type=ChoiceIndex(['m/s2', 'm/s', 'm', 'in/s2', 'in/s', 'in', 'mil', 'g', 'kg', 'lbs', 'N', 'dyne', 'Pas', 'bar', 'USER']))
        self.input_eng_unit_scale = devChOption('EU{ch}V', str_type=float, doc='number of eng.unit/Volt')
        self.input_eng_unit_user = devChOption('EU{ch}U', str_type=str)
        def devDispOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(disp=self.current_display)
            app = kwarg.pop('options_apply', ['disp'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.freq_span = devDispOption('FSPN {disp},{val}', 'FSPN? {disp}', str_type=float, setget=True)
        self.freq_start = devDispOption('FSTR {disp},{val}', 'FSTR? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        self.freq_stop = devDispOption('FEND {disp},{val}', 'FEND? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        self.freq_center = devDispOption('FCTR {disp},{val}', 'FCTR? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        resol_sel = ChoiceIndex([100, 200, 400, 800])
        self.freq_resolution = devDispOption('FLIN {disp},{val}', 'FLIN? {disp}', choices=resol_sel)
        mgrp_sel = ChoiceIndex(['FFT', 'Octave', 'Swept Sine'])
        self.meas_group = devDispOption('MGRP {disp},{val}', 'MGRP? {disp}', choices=mgrp_sel)
        meas_sel = ChoiceIndex(['FFT1', 'FFT2', 'Time1', 'Time2', 'WindowedTime1', 'WindowedTime2',
                                'Orbit', 'Coherence', 'CrossSpectrum', '<F2/F1>', '<F2>/<F1>',
                                'AutoCorr1', 'AutoCorr2', 'CaptureBuffer1', 'CaptureBuffer2',
                                'FFTuser1', 'FFTuser2', 'FFTuser3', 'FFTuser4', 'FFTuser5',
                                'Octave1', 'Octave2', 'OctaveCapBuff1', 'OctaveCapBuff2',
                                'OctaveUser1', 'OctaveUser2', 'OctaveUser3', 'OctaveUser4', 'OctaveUser5',
                                'SweptSpectrum1', 'SweptSpectrum2', 'SweptCross', 'SweptTransferFunction',
                                'SweptUser1', 'SweptUser2', 'SweptUser3', 'SweptUser4', 'SweptUser5'])
        self.meas = devDispOption('MEAS {disp},{val}', 'MEAS? {disp}', choices=meas_sel)
        view_sel = ChoiceIndex(['LogMag', 'LinMag', 'MagSquared', 'Real', 'Imag', 'Phase', 'UnWrapPhase', 'Nyquist', 'Nichols'])
        self.meas_view = devDispOption('VIEW {disp},{val}', 'VIEW? {disp}', choices=view_sel)
        unit_sel = ChoiceIndex(['Vpk', 'Vrms', 'Vpk2', 'Vrms2', 'dBVpk', 'dBVrms', 'dBm', 'dBspl', 'deg', 'rad', 'Units', 'dB'])
        self.meas_unit = devDispOption('UNIT {disp},{val}', 'UNIT? {disp}', choices=unit_sel)
        self.disp_live_en = devDispOption('DISP {disp},{val}', 'DISP? {disp}', str_type=bool)
        self.disp_log_xscale = devDispOption('XAXS {disp},{val}', 'XAXS? {disp}', str_type=bool)
        self.disp_PSD_en = devDispOption('PSDU {disp},{val}', 'PSDU? {disp}', str_type=bool, doc='Wether PSD (power spectral density) is enabled.')
        self.disp_transducer_unit_mode = devDispOption('TDRC {disp},{val}', 'TDRC? {disp}', choices=ChoiceIndex(['acceleration', 'velocity', 'displacement']))
        self.average_en = devDispOption('FAVG {disp},{val}', 'FAVG? {disp}', str_type=bool)
        self.average_mode = devDispOption('FAVM {disp},{val}', 'FAVM? {disp}', choices=ChoiceIndex(['vector', 'RMS', 'PeakHold']))
        self.average_type = devDispOption('FAVT {disp},{val}', 'FAVT? {disp}', choices=ChoiceIndex(['linear', 'exponential', 'FixedLength', 'continuous']))
        self.average_count_requested = devDispOption('FAVN {disp},{val}', 'FAVN? {disp}', str_type=int, min=2, max=32767)
        self.average_count = devDispOption(getstr='NAVG? {disp}', str_type=int)
        self.average_increment_pct = devDispOption('FOVL {disp},{val}', 'FOVL? {disp}', str_type=float, min=0, max=300)
        self.average_overload_reject_en = scpiDevice('FREJ 2,{val}', 'FREJ? 0', str_type=bool)
        self.average_preview_type = devDispOption('PAVO {disp},{val}', 'PAVO? {disp}', choices=ChoiceIndex(['off', 'manual', 'timed']))
        self.window_type = devDispOption('FWIN {disp},{val}', 'FWIN? {disp}', choices=ChoiceIndex(['uniform', 'flattop', 'hanning', 'BMH', 'kaiser', 'force', 'exponential', 'user', '-T/2..T/2', '0..T/2', '-T/4..T/4',]))
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        self._devwrap('dump', autoinit=False)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    @locked_calling
    def get_xscale(self):
        # only works for fft
        start = self.freq_start.getcache()
        stop = self.freq_stop.getcache()
        npoints = self.freq_resolution.getcache() + 1 # could also use DSPN? d
        return np.linspace(start, stop, npoints)
    def _dump_getformat(self, ps=True, **kwarg):
        fmt = self.dump._format
        if ps:
            binfmt = '.ps'
        else:
            binfmt = '.gif'
        fmt.update(bin=binfmt)
        return BaseDevice.getformat(self.dump, **kwarg)
    def _dump_getdev(self, ps=True, area='all'):
        """"""
        options are ps, area
         -ps: when True (default) returns a postscript object, otherwise returns a GIF file
         -area: used for GIF files, one of 'graph', 'menu', 'status' or 'all'(default)
        """"""
        # Reading data is tricky because the instrument does not send
        # EOI on its last byte so we either need to detect the ending comment
        # of the postscript or wait for the first timeout to occur for
        # the bitmap.
        # Also when the remote output is set to GPIB we do no receive the last byte.
        # So we need to switch the output to RS232 first.
        area_sel = dict(graph=0, menu=1, status=2, all=3)
        # POUT sets hardware print key to bitmap or vector
        # PDST 3 selects GPIB
        # PCIC 0 selects host controller
        # PLTP selects postscript
        # PRTP selects GIF
        r=''
        old_to = self.set_timeout
        self.set_timeout=.5 # useful for bitmap mode since we need to wait for timeout
        self.write('OUTX 1') # Go to RS232 interface
        if ps:
            self.write('POUT 1;PDST 3;PCIC 0;PLTP 1;PLOT')
            while r[-11:] != '%%Trailer\r\n':
                r += self.visa.read_raw_n(1)
        else:
            self.write('POUT 0;PDST 3;PCIC 0;PRTP 4;PSCR %d;PRNT'%area_sel[area])
            try:
                while True:
                    r += self.visa.read_raw_n(1)
            except visa_wrap.VisaIOError:
                pass
        self.write('OUTX 0') # return to gpib interface
        self.set_timeout = old_to
        return r
    # serial poll status word: 0=INSTrument, 1=DISPlay, 2=INPuT, 3=ERRor, 4=output buffer empty
    #                          5=standard status word, 6=SRQ, 7=IFC (no command execution in progress)
    def get_instrument_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):   A measurement has been triggered
          bit 1 (2):   Disk operation complete
          bit 2 (4):   Hardcopy output complete
          bit 3 (8):   unused
          bit 4 (16):  Capture buffer filled
          bit 5 (32):  Measurement has been paused
          bit 6 (64):  Measurement has been started
          bit 7 (128): Single shot capture playback has finished
          bit 8 (256): Measurement stopped to wait for average preview
          bit 9-15: unused
        """"""
        # can access bits with inst? 1
        # can enable in status register with INSE
        return int(self.ask('INST?'))
    def get_display_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):    displayA has new data
          bit 1 (2):    displayA linear average complete
          bit 2 (4):    displayA new settled data available
          bit 3 (8):    displayA failed a limit test
          bit 4 (16):   displayA swept sine has failed
          bit 5 (32):   displayA 1-shot waterfall has finished
          bit 6-7:      unused
          bit 8 (256):  displayB has new data
          bit 9 (512):  displayB linear average complete
          bit 10 (1024):displayB new settled data available
          bit 11 (2048):displayB failed a limit test
          bit 12 (4096):displayB swept sine has failed
          bit 13 (8192):displayB 1-shot waterfall has finished
          bit 14-15:    unused
         except for waterfall always test for new data (bit 0/8) for
         the correct display first.
        """"""
        # can access bits with inst? 1
        # can enable in status register with DSPE
        return int(self.ask('DSPS?'))
    def get_input_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):    input1 has fallend below half of full scale
          bit 1 (2):    input1 has exceeded half of full scale
          bit 2 (4):    input1 has exceeded full scale
          bit 3 (8):    input1 has exceeded 35 dBV, range switched to 34 dBV
          bit 4 (16):   input1 has autoranged
          bit 5-7:      unused
          bit 8 (256):  input2 has fallend below half of full scale
          bit 9 (512):  input2 has exceeded half of full scale
          bit 10 (1024):input2 has exceeded full scale
          bit 11 (2048):input2 has exceeded 35 dBV, range switched to 34 dBV
          bit 12 (4096):input2 has autoranged
          bit 13-15:    unused
        """"""
        # can access bits with inst? 1
        # can enable in status register with INPE
        # also see INPC? 0 (ch1) or INPC? 1 (ch2)
        # which returns instanteneous a value 0-3 where:
        #   0=input under half full scale
        #   1=input over half full scale
        #   2=input overloaded
        #   3=input is HighV
        return int(self.ask('INPS?'))
    @locked_calling
    def get_error(self):
        """"""
         returns two byte of bit flags
         first:
          bit 0-1:     unused
          bit 2 (4):   Too many responses are pending
          bit 3 (8):   too many commands received
          bit 4 (16):  command cannot execute successfully
          bit 5 (32):  command syntax error
          bit 6 (64):  key press or knob rotated
          bit 7 (128): power is turned on
          bit 8-15:    unused
         second:
          bit 0 (1):   An output error as occured (print, plot, dump)
          bit 1 (2):   disk errro
          bit 2 (4):   math error
          bit 3 (8):   RAM memory test fails
          bit 4 (16):  ROM memory test fails
          bit 5 (32):  Video memory test fails
          bit 6 (64):  Help memory test fails
          bit 7 (128): DSP data memory fails
          bit 8 (256): DSP program memory fails
          bit 9 (512): DSP DRAM memory fails
          bit 10 (1024): DSP calibration memory fails
          bit 11 (2048): Ch1 calibration memory fails
          bit 12 (4096): Ch2 calibration memory fails
          bit 13-15: unused
        """"""
        # can access bits with errs? 1
        # can enable in status register with ERRE
        # enable *ese with *ese
        return int(self.ask('*esr?')),int(self.ask('ERRS?'))


#######################################################
##    Lakeshore 325 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL325', '1.7/1.1')
@register_instrument('LSCI', 'MODEL325')
class lakeshore_325(visaInstrument):
    """"""
       Temperature controller
       Useful device:
           sa
           sb
           ta
           tb
           status_a
           status_b
           fetch
       s? and t? return the sensor or kelvin value of a certain channel
       status_? returns the status of the channel
       fetch allows to read all channels
    """"""
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([c+'_T', c+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, ch=None):
        """"""
        reads thermometers temperature and their sensor values.
        option ch: can be a single channel or a list of channels.
                   by default (None), all active channels are used
                   possible channels names are:
                       A, B
        """"""
        ch = self._fetch_helper(ch)
        ret = []
        for c in ch:
            if c == 'A':
                ret.append(self.ta.get())
                ret.append(self.sa.get())
            elif c == 'B':
                ret.append(self.tb.get())
                ret.append(self.sb.get())
            else:
                raise ValueError(""Invalid selection for ch. If it is None, check that enabled_list is a list with 'A' and/or 'B'"")
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('sp', options)
    def _create_devs(self):
        self.crdg = scpiDevice(getstr='CRDG? A', str_type=float)
        self.enabled_list = MemoryDevice(['A', 'B'])
        self.thermocouple = scpiDevice(getstr='TEMP?', str_type=float)
        self.ta = scpiDevice(getstr='KRDG? A', str_type=float) #in Kelvin
        self.tb = scpiDevice(getstr='KRDG? B', str_type=float) #in Kelvin
        self.sa = scpiDevice(getstr='SRDG? A', str_type=float) #in sensor unit: Ohm, V or mV
        self.sb = scpiDevice(getstr='SRDG? B', str_type=float) #in sensor unit
        self.status_a = scpiDevice(getstr='RDGST? A', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.status_b = scpiDevice(getstr='RDGST? b', str_type=int)
        self.htr = scpiDevice(getstr='HTR?', str_type=float) #heater out in %
        self.sp = scpiDevice(setstr='SETP 1,', getstr='SETP? 1', str_type=float)
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Lakeshore 340 Temperature controller
#######################################################

register_idn_alias('Lake Shore Cryotronics', 'LSCI')

#@register_instrument('LSCI', 'MODEL340', '061407')
@register_instrument('LSCI', 'MODEL340')
class lakeshore_340(visaInstrument):
    """"""
       Temperature controller used for He3 system
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
       s and t return the sensor or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_crv = []
            in_type = []
            for c in ch:
                ch_list.append(c)
                in_set.append(self.input_set.get(ch=c))
                in_crv.append(self.input_crv.get())
                in_type.append(self.input_type.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_set=%r'%in_set,
                    'input_crv=%r'%in_crv, 'input_type=%r'%in_type]
        else:
            base = self._conf_helper('current_ch', 'input_set', 'input_crv', 'input_type')
        base += self._conf_helper('current_loop', 'sp', 'pid', options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_set.get(ch=c)
            if d['enabled']:
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([c+'_T', c+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, ch=None):
        """"""
        reads thermometers temperature and their sensor values.
        option ch: can be a single channel or a list of channels.
                   by default (None), all active channels are used
                   possible channels names are:
                       A, B, C, D, C1, C2, C3, C4, D1, D2, D3, D4
                   (depending on installed options)
        """"""
        old_ch = self.current_ch.getcache()
        ch = self._fetch_helper(ch)
        ret = []
        for c in ch:
            ret.append(self.t.get(ch=c))
            ret.append(self.s.get())
        self.current_ch.set(old_ch)
        return ret
    def _create_devs(self):
        rev_str = self.ask('rev?')
        conv = ChoiceMultiple(['master_rev_date', 'master_rev_num', 'master_serial_num', 'sw1', 'input_rev_date',
                         'input_rev_num', 'option_id', 'option_rev_date', 'option_rev_num'], fmts=str)
        rev_dic = conv(rev_str)
        ch_Base = ChoiceStrings('A', 'B')
        ch_3462_3464 = ChoiceStrings('A', 'B', 'C', 'D') # 3462=2 other channels, 3464=2 thermocouple
        ch_3468 = ChoiceStrings('A', 'B', 'C1', 'C2', 'C3', 'C4', 'D1', 'D2','D3','D4') # 2 groups of 4, limited rate, limited current sources (10u or 1m)
        ch_3465 = ChoiceStrings('A', 'B', 'C') # single capacitance
        ch_opt = {'3462':ch_3462_3464, '3464':ch_3462_3464, '3468':ch_3468, '3465':ch_3465}
        ch_opt_sel = ch_opt.get(rev_dic['option_id'], ch_Base)
        self.current_ch = MemoryDevice('A', choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='KRDG? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='SRDG? {ch}', str_type=float, doc='Return the sensor value in Ohm, V(diode), mV (thermocouple), nF (for capacitance)  for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.input_set = devChOption('INSET {ch},{val}', 'INSET? {ch}', choices=ChoiceMultiple(['enabled', 'compens'],[bool, int]))
        self.input_crv = devChOption('INCRV {ch},{val}', 'INCRV? {ch}', str_type=int)
        self.input_type = devChOption('INTYPE {ch},{val}', 'INTYPE? {ch}',
                                      choices=ChoiceMultiple(['type', 'units', 'coeff', 'exc', 'range']))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}',
                                      choices=ChoiceMultiple(['filter_en', 'n_points', 'window'], [bool, int, int]))
        self.current_loop = MemoryDevice(1, choices=[1, 2])
        def devLoopOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(loop=self.current_loop)
            app = kwarg.pop('options_apply', ['loop'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.pid = devLoopOption('PID {loop},{val}', 'PID? {loop}',
                                 choices=ChoiceMultiple(['P', 'I', 'D'], float))
        self.htr = scpiDevice(getstr='HTR?', str_type=float) #heater out in %
        self.sp = devLoopOption(setstr='SETP {loop},{val}', getstr='SETP? {loop}', str_type=float)
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

#######################################################
##    Lakeshore 224 Temperature monitor
#######################################################
class quoted_name(object):
    def __call__(self, read_str):
        # the instruments returns a 15 character string with spaces if unused
        return read_str.rstrip()
    def tostr(self, input_str):
        if '""' in input_str:
            raise ValueError, 'The given string already contains a quote :"":'
        return '""'+input_str[:15]+'""'

#@register_instrument('LSCI', 'MODEL224', '1.0')
@register_instrument('LSCI', 'MODEL224')
class lakeshore_224(lakeshore_340):
    """"""
       Temperature monitor
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
       s and t return the sensor or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels (which is the alias)

       Note: The device USB is actually a serial to USB port. Therfore it
             shows on the computer as a serial connection (once the driver
             is installed, which could happen automatically.)
    """"""
    def init(self, full=False):
        if full:
            if self.visa.is_serial():
                self.visa.baud_rate = 57600
                self.visa.parity = visa_wrap.constants.Parity.odd
                self.visa.data_bits = 7
            if self.visa.is_serial():
                self._write_write_wait = 0.100
            else: # GPIB, LAN: This is unchecked but should be ok. Shorter time might be better...
                self._write_write_wait = 0.050
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_crv = []
            in_type = []
            in_diode = []
            for c in ch:
                ch_list.append(c)
                in_crv.append(self.input_crv.get(ch=c))
                in_type.append(self.input_type.get())
                in_diode.append(self.input_diode_current.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_crv=%r'%in_crv, 'input_type=%r'%in_type, 'input_diode_current=%r'%in_diode]
        else:
            base = self._conf_helper('current_ch', 'input_crv', 'input_type', 'input_diode_current')
        base += self._conf_helper(options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_type.get(ch=c)
            if d['type'] != 'disabled':
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _get_esr(self):
        return int(self.ask('*esr?'))
    def get_error(self):
        esr = self._get_esr()
        ret = ''
        if esr&0x80:
            ret += 'Power on. '
        if esr&0x20:
            ret += 'Command Error. '
        if esr&0x10:
            ret += 'Execution Error. '
        if esr&0x04:
            ret += 'Query Error (output queue full). '
        if esr&0x01:
            ret += 'OPC received.'
        if ret == '':
            ret = 'No Error.'
        return ret
    def _create_devs(self):
        ch_opt_sel = ['A', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'D1', 'D2', 'D3', 'D4', 'D5']
        self.current_ch = MemoryDevice('A', choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='KRDG? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='SRDG? {ch}', str_type=float, doc='Return the sensor value in Ohm, V(diode), mV (thermocouple), nF (for capacitance)  for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.input_crv = devChOption('INCRV {ch},{val}', 'INCRV? {ch}', str_type=int)
        intypes = ChoiceIndex({0:'disabled', 1:'diode', 2:'PTC_RTD', 3:'NTC_RTD'})
        units = ChoiceIndex({1:'Kelvin', 2:'Celsius', 3:'Sensor'})
        ranges_disabled = ChoiceIndex({0:0})
        ranges_diode = ChoiceIndex({0:2.5, 1:10}) # V
        ranges_PTC = ChoiceIndex(make_choice_list([1, 3], 1, 4)[:-1], normalize=True) # Ohm
        ranges_NTC = ChoiceIndex(make_choice_list([1, 3], 1, 5)[:-1], normalize=True) # Ohm
        type_ranges = ChoiceMultipleDep('type', {'disabled':ranges_disabled, 'diode':ranges_diode, 'PTC_RTD':ranges_PTC, 'NTC_RTD':ranges_NTC})
        self.input_type = devChOption('INTYPE {ch},{val}', 'INTYPE? {ch}',
                                      allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['type', 'autorange_en', 'range', 'compensation_en', 'units'], [intypes, bool, type_ranges, bool, units]))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}',
                                      allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['filter_en', 'n_points', 'window'], [bool, int, int]))
        self.input_diode_current = devChOption('DIOCUR {ch},{val}', 'DIOCUR? {ch}', choices=ChoiceIndex({0:10e-6, 1:1e-3}), doc=
                """"""Only valid when input is a diode type. Options are in Amps.
                   Default of instrument is 10 uA (used after every change of sensor type)."""""")
        self.input_name = devChOption('INNAME {ch},{val}', 'INNAME? {ch}', str_type=quoted_name())
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(lakeshore_340, self)._create_devs()
    def disable_ch(self, ch):
        """"""
        This method set a channel to disabled.
        Note that the settings of the channel are lost. To reenable use
          input_type with at least options autorange_en (PTC, NTC), range (allways, any value is allowed if autorange is enabled)
                     compensation_en (PTC, NTC)
          input_crv
          input_diode_current (for diodes if want 1 mA)
        """"""
        self.input_type.set(ch=ch, type='disabled', range=0)

#######################################################
##    Lakeshore 370 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL370', '04102008')
@register_instrument('LSCI', 'MODEL370')
class lakeshore_370(visaInstrument):
    """"""
       Temperature controller used for dilu system
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
           pid
           still
           still_raw
       s and t return the sensor(Ohm) or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels

       Notes about T control:
           - the htr values is either in W (assuming the resistance is correctly
           programmed) or % of current full scale. Therefore we have
           W = ((%/100)*Ifullscale)**2 * Rheater
           - The feedback formula is:
               Iheater = Imax * P * [e + I integral(e dt) + D de/dt]
               with e = 2*log10(Rmeas/Rsetpoint)
                 at least for sensors calibrated as log scale
           - Therefore increasing currrent scale by x3.16 (power by x10)
             would require decreasing P by x3.16
       Notes about timing:
           - takes 10 readings / s, has a 200 ms hardware input filter
           - the digital filter is a linear average
           - Hardware settling time is about 1s, 2-3s for range change
             (scan channel change)
           - Time to a stable reading after channel change:
               max(hardware_settling, pause) + digital_filter
             so if pause it too small, it will take hardware settling time
             to get first reading used for the filter. Otherwise it will be
             the pause time (pause and hardware settling don't add)
           - When under PID control:
               The control channel is measured between all the other channels
               (toggles between control channel and non control channels).
               channel switch time is the same but the dwell times are changed
               about 5s for control and 1s for others (non-control).
               These are fixed (see  Manual 4.11.8.1 Reading Sequence p 4-23)
               There does not seem to be a way to change these dwell times.
    """"""
    def __init__(self, visa_addr, still_res=120., still_full_res=136.4, scanner=True, **kwarg):
        """"""
        still_res is the still heater resistance
        still_full_res is the still heater resistance with the wire resistance
                       included (the 2 wire resistance seen from outside the fridge)
        They are both used fot the still device
        scanner set it to True to force scanner use, False to disable it and 'auto' to
                automatically check for it. 'auto' only works for newer model 372 not 370.
        """"""
        self._still_res = still_res
        self._still_full_res = still_full_res
        self._scanner_present = scanner
        rsrc_info = resource_info(visa_addr)
        if rsrc_info.interface_type == visa_wrap.constants.InterfaceType.asrl:
            kwarg['parity'] = visa_wrap.constants.Parity.odd
            kwarg['data_bits'] = 7
        super(lakeshore_370, self).__init__(visa_addr, **kwarg)
        self._data_valid_last_ch = 0
        self._data_valid_last_t = 0.
        self._data_valid_last_start = 0., [0, False]
    def _get_esr(self):
        return int(self.ask('*esr?'))
    def get_error(self):
        esr = self._get_esr()
        ret = ''
        if esr&0x80:
            ret += 'Power on. '
        if esr&0x20:
            ret += 'Command Error. '
        if esr&0x10:
            ret += 'Execution Error. '
        if esr&0x04:
            ret += 'Query Error (output queue full). '
        if esr&0x01:
            ret += 'OPC received.'
        if ret == '':
            ret = 'No Error.'
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_filter = []
            in_meas = []
            for c in ch:
                ch_list.append(c)
                in_set.append(self.input_set.get(ch=c))
                in_filter.append(self.input_filter.get())
                in_meas.append(self.input_meas.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_set=%r'%in_set,
                    'input_filter=%r'%in_filter, 'input_meas=%r'%in_meas]
        else:
            base = self._conf_helper('current_ch', 'input_set', 'input_filter', 'input_meas')
        base += self._conf_helper('sp', 'pid', 'manual_out_raw', 'still', 'heater_range',
                                  'control_mode', 'control_setup', 'control_ramp', options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_set.get(ch=c)
            if d['enabled']:
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([str(c)+'_T', str(c)+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    @locked_calling
    def _data_valid_start(self):
        """""" returns channel and autoscan_en """"""
        to = time.time()
        if to - self._data_valid_last_start[0] < 0.02:
            # nothing has changed since last call so speedup by reusing result
            return self._data_valid_last_start[1]
        # the only way to clear the status when using serial is with *cls
        # and it is faster to also ask a question (less wait time later)
        result = self.ask('*cls;scan?').split(',')
        ret = int(result[0]), bool(int(result[1]))
        self._data_valid_last_start = time.time(), ret
        return ret
    def _data_valid(self):
        """"""
        waits until we have valid data
        returns the current scan channel when done
        """"""
        with self._lock_instrument: # protect object variables
            to = time.time()
            start_ch, foo = self._data_valid_start()
            if to-self._data_valid_last_t < 1. and self._data_valid_last_ch == start_ch:
                # we should still be having good data, skip the wait
                self._data_valid_last_t = to
                return start_ch
        while not self.read_status_byte()&4:
            wait(.02)
        after_ch, foo = self._data_valid_start()
        tf = time.time()
        if tf-to > 1.: # we waited after a channel change
            ch = after_ch
        else:  # the channel is the same or it got changed just after our wait.
            ch = start_ch
        with self._lock_instrument: # protect object variables
            self._data_valid_last_t = tf
            self._data_valid_last_ch = ch
        return ch
    def _fetch_getdev(self, ch=None, lastval=False, wait_new=False):
        """"""
        Optional parameter:
            ch: To select which channels to read. Default to all the enabled
                ones. Otherwise ch=4 selects only channel 4 and
                ch=[3,5] selects channels 3 and 5.
          lastval: When enabled, and when scanning, waits and picks the last value
                   read from that channel before switching
          wait_new: only returns values the are fresh. If a channel is never scanned
                    it will hang
        lastval and wait_new do something only when scanning is enabled.
        You can enable both at the same time.

        For each channels, two values are returned. The tempereture in Kelvin
        and the sensor value in Ohm.
        """"""
        old_ch = self.current_ch.getcache()
        ch = self._fetch_helper(ch)
        nmeas = len(ch) # the number of measures to do
        ret = [None] * nmeas*2
        ich = list(enumerate(ch)) # this makes a list of (i,c)
        ch2i = {c:i for i,c in ich} # maps channel # to index
        # for lastval only:
        # We assume the scanning is slower than getting all the values
        # so we first get all channel except the active one.
        # This should be ok since the first seconds after a channel change
        # returns the previous value and the sequence order is not too critical
        # since we have seconds to read all other channels
        if lastval or wait_new:
            # use _data_valid_start here because it can save some time over
            # self.scan.get()
            start_scan_ch, autoscan_en = self._data_valid_start()
            current_ch = start_scan_ch
            if not autoscan_en:
                lastval = False
                wait_new = False
        if lastval or wait_new:
            # They both introduce delays so we unlock to allow other threads
            # to use this device. The reset of the code has been checked to
            # be thread safe
            # TODO better unlockin/locking: This way, if the code is interrupted
            #             by KeyboardInterrupt it will produce an unlocking
            #             error in the previous with handler (the re-acquire)
            #             is not performed.
            self._lock_release()
        skip = False
        indx = 0
        while nmeas != 0:
            if wait_new and lastval:
                while True:
                    ch, foo = self._data_valid_start()
                    if ch == current_ch: # we wait until the channel changes
                        wait(.2)
                    else:
                        break
                if current_ch not in ch2i:
                    current_ch = ch
                    continue
                i, c = ch2i[current_ch], current_ch
                current_ch = ch
                # In PID control we will repeat the control channel multiple times
                # So check that. We will return the last one only
                if ret[i*2] is None:
                    nmeas -= 1
            elif wait_new: # only
                while True:
                    current_ch = self._data_valid()
                    if current_ch not in ch2i: # we want valid data for this channel
                        wait(.5)
                    else:
                        i, c = ch2i.pop(current_ch), current_ch
                        nmeas -= 1
                        break
            else: # lastval only or nothing
                i, c = ich[indx]
                indx += 1
                nmeas -= 1
                if lastval and c == start_scan_ch:
                    skip = True
                    continue
            ret[i*2] = self.t.get(ch=c)
            ret[i*2+1] = self.s.get(ch=c) # repeating channels means we don't need the lock
        if skip and lastval:
            while True:
                ch, foo = self._data_valid_start()
                if ch != start_scan_ch:
                    break
                wait(.1)
            i = ch2i[start_scan_ch]
            ret[i*2] = self.t.get(ch=start_scan_ch)
            ret[i*2+1] = self.s.get(ch=start_scan_ch)
        if lastval or wait_new:
            # we need to reacquire the lock before leaving
            self._lock_acquire()
        self.current_ch.set(old_ch)
        return ret
    def _htr_getdev(self):
        """"""Always in W, using control_setup heater_Ohms if necessary.""""""
        csetup = self.control_setup.getcache()
        htr = self.htr_raw.get()
        if csetup.output_display == 'power':
            return htr
        else:
            rng = self.heater_range.get()
            return (htr/100.*rng)**2 * csetup.heater_Ohms
    def _create_devs(self):
        if self.visa.is_serial():
            # we need to set this before any writes.
            self._write_write_wait = 0.100
            #self.visa.term_chars = '\r\n'
            self.write('*ESE 255') # needed for get_error
            self.write('*sre 4') # neede for _data_valid
        else: # GPIB
            self._write_write_wait = 0.050
        if self._scanner_present == 'auto':
            # DOUT always returns 00 when a scanner is present.
            scanner = False
            prev_dout = int(self.ask('DOUT?'))
            if prev_dout == 0:
                self.write('DOUT 01')
                dout = int(self.ask('DOUT?'))
                if dout != 0:
                    # bring it back
                    self.write('DOUT 00')
                else:
                    scanner = True
            self._scanner_present = scanner
        if self._scanner_present:
            ch_opt_sel = range(1, 17)
        else:
            ch_opt_sel = range(1, 2)
        self.current_ch = MemoryDevice(1, choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='RDGK? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='RDGR? {ch}', str_type=float, doc='Return the sensor value in Ohm for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=CS OVL, 2(1)=VCM OVL, 4(2)=VMIX OVL, 8(3)=VDIF OVL
                               #16(4)=R. OVER, 32(5)=R. UNDER, 64(6)=T. OVER, 128(7)=T. UNDER
                               # 000 = valid
        tempco = ChoiceIndex({1:'negative', 2:'positive'})
        self.input_set = devChOption('INSET {ch},{val}', 'INSET? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                     choices=ChoiceMultiple(['enabled', 'dwell', 'pause', 'curvno', 'tempco'],
                                                       [bool, (int, (1, 200)), (int, (3, 200)), (int, (0, 20)), tempco]))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['filter_en', 'settle_time', 'window'], [bool, (int, (1, 200)), (int, (1, 80))]))
        res_ranges = ChoiceIndex(make_choice_list([2, 6.32], -3, 7), offset=1, normalize=True)
        cur_ranges = ChoiceIndex(make_choice_list([1, 3.16], -12, -2), offset=1, normalize=True)
        volt_ranges = ChoiceIndex(make_choice_list([2, 6.32], -6, -1), offset=1, normalize=True)
        curvolt_ranges = ChoiceMultipleDep('exc_mode', {'voltage':volt_ranges, 'current':cur_ranges})
        self.input_meas = devChOption('RDGRNG {ch},{val}', 'RDGRNG? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                     choices=ChoiceMultiple(['exc_mode', 'exc_range', 'range', 'autorange_en', 'excitation_disabled'],
                                                       [ChoiceIndex(['voltage', 'current']), curvolt_ranges, res_ranges, bool, bool]))
        # scan returns the channel currently being read
        #  it is the channel that flashes, not necessarily the one after scan on the
        #  display (they differ when temperature control is enabled, the instrument goes back
        #  to the control channel after all readings. This command follows that.)
        self.scan = scpiDevice('SCAN', allow_kw_as_dict=True, allow_missing_dict=True,
                               choices=ChoiceMultiple(['ch', 'autoscan_en'], [int, bool]))
        #self.current_loop = MemoryDevice(1, choices=[1, 2])
        #def devLoopOption(*arg, **kwarg):
        #    options = kwarg.pop('options', {}).copy()
        #    options.update(loop=self.current_loop)
        #    app = kwarg.pop('options_apply', ['loop'])
        #    kwarg.update(options=options, options_apply=app)
        #    return scpiDevice(*arg, **kwarg)
        #self.pid = scpiDevice('PID', choices=ChoiceMultiple(['P', 'I', 'D'], float))
        pid_ch = ChoiceMultiple(['P', 'I', 'D'], [(float, (0.001, 1000)), (float,(0, 10000)), (float, (0, 2500))])
        self.pid = scpiDevice('PID', allow_kw_as_dict=True, allow_missing_dict=True, choices=pid_ch, multi=pid_ch.field_names, doc=""You can use as set(tc3.pid, P=21)"")
        self.pid_P = Dict_SubDevice(self.pid, 'P', force_default=False)
        self.pid_I = Dict_SubDevice(self.pid, 'I', force_default=False)
        self.pid_D = Dict_SubDevice(self.pid, 'D', force_default=False)
        self.manual_out_raw = scpiDevice('MOUT', str_type=float,
                                  doc='manual heater output in % of Imax or in W depending on control_setup output_display option')
        self.htr_raw = scpiDevice(getstr='HTR?', str_type=float,
                                  doc='heater output in % of Imax or in W depending on control_setup output_display option')
        self._devwrap('htr')
        cmodes = ChoiceIndex({1:'pid', 2:'zone', 3:'open_loop', 4:'off'})
        self.control_mode = scpiDevice('CMODE', choices=cmodes)
        # heater range of 0 means off
        htrrng_dict = {0:0., 1:31.6e-6, 2:100e-6, 3:316e-6,
                       4:1.e-3, 5:3.16e-3, 6:10e-3, 7:31.6e-3, 8:100e-3}
        htrrng = ChoiceIndex(htrrng_dict)
        self.heater_range = scpiDevice('HTRRNG', choices=htrrng)
        csetup_htrrng_dict = htrrng_dict.copy()
        del csetup_htrrng_dict[0]
        csetup_htrrng = ChoiceIndex(csetup_htrrng_dict)
        csetup = ChoiceMultiple(['channel','filter_en', 'units', 'delay', 'output_display',
                           'heater_limit', 'heater_Ohms'],
                          [(int, (1, 16)), bool, ChoiceIndex({1:'kelvin', 2:'ohm'}), (int, (1, 255)),
                           ChoiceIndex({1:'current', 2:'power'}), csetup_htrrng, (float, (1, 1e5))])
        self.control_setup = scpiDevice('CSET', choices=csetup, allow_kw_as_dict=True, allow_missing_dict=True)
        self.control_setup_heater_limit = Dict_SubDevice(self.control_setup, 'heater_limit', force_default=False)
        self.control_ramp = scpiDevice('RAMP', allow_kw_as_dict=True, allow_missing_dict=True,
                                       choices=ChoiceMultiple(['en', 'rate'], [bool, (float,(0.001, 10))]), doc=""Activates the sweep mode. rate is in K/min."", setget=True)
        self.ramp_sweeping = devChOption(getstr='RAMPST?', str_type=bool)
        self.sp = scpiDevice('SETP', str_type=float)
        self.still_raw = scpiDevice('STILL', str_type=float)
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch

        Rfull = self._still_full_res
        Rhtr = self._still_res
        htr_from_raw = lambda x:  (x/10./Rfull)**2 * Rhtr*1e3 # x is % of 10V scale so x/10 is volt
        htr_to_raw = lambda p:    np.sqrt(p*1e-3/Rhtr)*Rfull*10.  # p is in mW
        self.still = FunctionDevice(self.still_raw, htr_from_raw, htr_to_raw, quiet_del=True, doc='still power in mW')

        # This needs to be last to complete creation
        super(lakeshore_370, self)._create_devs()

#######################################################
##    Lakeshore 372 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL372', '1.3')
@register_instrument('LSCI', 'MODEL372')
class lakeshore_372(lakeshore_370):
    def __init__(self, visa_addr, *args, **kwargs):
        rsrc_info = resource_info(visa_addr)
        if rsrc_info.interface_type == visa_wrap.constants.InterfaceType.asrl:
            baud_rate = kwargs.pop('baud_rate', 57600)
            kwargs['baud_rate'] = baud_rate
        scanner = kwargs.pop('scanner', 'auto')
        super(lakeshore_372, self).__init__(visa_addr, *args, scanner=scanner, **kwargs)


#######################################################
##    Colby Instruments Programmable delay line PDL-100A-20NS
#######################################################

#@register_instrument('Colby Instruments', 'PDL-100A-20.00NS', 'V1.70')
@register_instrument('Colby Instruments', 'PDL-100A-20.00NS')
class colby_pdl_100a(visaInstrument):
    """"""
    Colby Instruments delay box: PDL-100A-20NS
    Useful devices:
        delay_ps (default alias): enter delay value in ps
    It can take up to 1.5s to change the delay.
    Make sure visa timeout is not made too short (initialized to 3s).

    Useful methods:
        get_error
        reset
    """"""
    _errors_dict = {0: 'No Error', 1: 'Invalid Command', 2: 'Invalid Argument',
                    3: 'Unit did not pass calibration',
                    4: 'Delay setting requested beyond range of device',
                    5: 'Delay not set', 99: 'Buffer overflow'}
    def init(self, full=False):
        # This clears the error state, and status/event flags
        self.clear()
        if full:
            self.set_timeout = 3
            #self.visa.term_chars='\n'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        #return self._conf_helper('delay_ps', 'mode', 'rate', 'accel', options)
        return self._conf_helper('delay_ps', 'mode', options)
    def _delay_ps_setdev(self, val):
        # TODO could use async instead of using *OPC and visa timeout
        # OPC is to wait for completion, could require up to 1.5s
        self.ask('DEL %f PS;*OPC?'%val)
    def reset(self):
        """"""
        Returns to power on state (goes to 0 ps)
        """"""
        self.write('*rst')
        self.delay_ps.setcache(0.)
    def caltest(self, test=False):
        """"""
        Does either a calibration (only trombone) or an internal self-test
        (longer: trombone and relays)
        The state of the delay after calibration (because of relays) is not
        known.
        """"""
        if test:
            self.ask('*tst?')
        else:
            self.ask('*cal?')
        self.delay_ps.setcache(0.)
    def cal(self):
        self.write('*rst')
    def _delay_ps_getdev(self):
        return float(self.ask('DEL?'))*1e12
    def _create_devs(self):
        # other commands REL? relay query which returns bit flag, total delay ns
        #                REL n ON or REL n OFF to turn relay n (1..5) on or off.
        self.mode = scpiDevice('MODE', choices=ChoiceStrings('SER', 'PAR', '312.5PS', '625PS'))
        #self.rate = scpiDevice('RATE', str_type=int, min=100, max=550)
        #self.accel = scpiDevice('XDD', str_type=int, min=500, max=2000)
        self._devwrap('delay_ps', min=0, max=20e3, setget=True)
        self.alias = self.delay_ps
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        val = int(self.ask('ERR?'))
        err_str = self._errors_dict[val]
        return val, err_str


#######################################################
##    BNC 845 microwave/RF generator
#######################################################

register_usb_name('Berkeley Nucleonics Corporation', 0x03EB)

@register_instrument('Berkeley Nucleonics Corporation', 'MODEL 845', '0.4.35', usb_vendor_product=[0x03EB, 0xAFFF])
class BNC_rf_845(visaInstrument):
    """"""
    This controls a BNC 845 signal generetor
    Most useful devices:
        ampl_dbm
        rf_en
        freq_cw
    The alc devices refer to automatic level (amplitude) control.
    Available methods:
        phase_sync

    According to specs, it takes less than 0.1 ms for settling after
    a frequency change.
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # TODO Get the proper config
        return self._conf_helper('oscillator_source', 'oscillator_ext_freq_MHz', 'oscillator_locked',
                                 'oscillator_out_en', 'oscillator_out_freq',
                                 'rf_en', 'ampl_dbm', 'amp_flatness_corr_en', 'output_blanking_en',
                                 'ampl_mode', 'ampl_start', 'ampl_stop',
                                 'alc_en', 'alc_low_amp_noise_en', 'alc_hold_en',
                                 'attenuation_db', 'attenuation_auto_en', 'amp_flatness_corr_en',
                                 'freq_mode', 'freq_cw', 'freq_start', 'freq_stop',
                                 'sweep_nbpoints', 'sweep_type', 'sweep_dwell_s', 'sweep_delay_s', 'sweep_delay_auto_en',
                                 'sweep_direction',
                                 'lowfout_freq', 'lowfout_amp_V', 'lowfout_shape', 'lowfout_source', 'lowfout_en',
                                 'phase', 'mod_am_en', 'mod_fm_en', 'mod_phase_en', 'mod_pulse_en', options)
    def _create_devs(self):
        self.installed_options = scpiDevice(getstr='*OPT?')
        self.oscillator_source = scpiDevice(':ROSCillator:SOURce', choices=ChoiceStrings('INTernal', 'EXTernal')) # 'SLAVe' not useful for us
        self.oscillator_ext_freq_MHz = scpiDevice(':ROSCillator:EXTernal:FREQuency', str_type=float, min=1, max=250)
        self.oscillator_locked = scpiDevice(getstr=':ROSCillator:LOCKed?', str_type=bool)
        self.oscillator_out_en = scpiDevice(':ROSCillator:OUTPut:STATe', str_type=bool)
        self.oscillator_out_freq = scpiDevice(':ROSCillator:OUTPut:FREQuency', str_type=float, choices=[10e6, 100e6])
        self.rf_en = scpiDevice(':OUTPut', str_type=bool)
        #self.unit_power('UNIT:POWer', choices=ChoiceStrings('W', 'V', 'DBM', 'DB')) # only affects display
        #self.unit_freq('UNIT:FREQuency', choices=ChoiceStrings('HZ', 'MHZ', 'GHZ')) # only affects display
        self.ampl_dbm = scpiDevice(':POWer', str_type=float, setget=True, min=-105, max=20)
        # unit:volt:type affects volt scale like power:alc:search:ref:level, which are not user changeable
        self.ampl_mode = scpiDevice(':POWer:MODE', choices=ChoiceStrings('FIXed', 'LIST', 'SWEep'))
        self.ampl_start = scpiDevice(':POWer:STARt', str_type=float, setget=True)
        self.ampl_stop = scpiDevice(':POWer:STOP', str_type=float, setget=True)
        self.ampl_step = scpiDevice(getstr=':POWer:STEP?', str_type=float)
        self.alc_en = scpiDevice(':POWer:ALC', str_type=bool)
        self.alc_low_amp_noise_en = scpiDevice(':POWer:ALC:LOWN', str_type=bool, doc='When enabled provides up to 0.001 dB output resolution. Works similarly to hold')
        self.alc_hold_en = scpiDevice(':POWer:ALC:HOLD', str_type=bool, doc='Open loops ALC control')
        att_list = list(decode_float64(self.ask('POWer:ATTenuation:LIST?')))
        self.attenuation_db = scpiDevice(':POWer:ATTenuation', str_type=float, choices=att_list)
        self.attenuation_auto_en = scpiDevice(':POWer:ATTenuation:AUTO', str_type=bool)
        self.amp_flatness_corr_en = scpiDevice(':CORRection:FLATness', str_type=bool)
        self.output_blanking_en = scpiDevice(':OUTPut:BLANKing:STATe', str_type=bool, doc='disable RF output when changing frequency')
        self.phase = scpiDevice(':PHASe', str_type=float, min=0, max=2*np.pi, doc='Adjust phase arounf ref. In rad.')
        self.freq_mode = scpiDevice(':FREQuency:MODE', choices=ChoiceStrings('CW', 'FIXed', 'LIST', 'SWEep', 'CHIRp'), doc='CW and FIXed are the same.')
        minfreq=9e3
        maxfreq=20.5e9
        self.freq_cw = scpiDevice(':FREQuency', str_type=float, min=minfreq, max=maxfreq)
        self.freq_start = scpiDevice('FREQuency:STARt', str_type=float, min=minfreq, max=maxfreq)
        self.freq_stop = scpiDevice('FREQuency:STOP', str_type=float, min=minfreq, max=maxfreq)
        self.freq_step = scpiDevice(getstr='FREQuency:STEP?', str_type=float)
        #self.freq_steplog = scpiDevice(getstr='FREQuency:STEP:LOGarithmic?', str_type=float) # This is in the manual but does not seem to work
        self.sweep_nbpoints = scpiDevice('SWEep:POINts', str_type=int, min=2, max=65535)
        self.sweep_progress = scpiDevice(getstr='SWEep:PROGress?', str_type=float) # manual says proggress but is wrong
        self.sweep_type = scpiDevice('SWEep:SPACing', choices=ChoiceStrings('LINear', 'LOGarithmic'))
        self.sweep_dwell_s = scpiDevice('SWEep:DWELl', str_type=float)
        self.sweep_delay_s = scpiDevice('SWEep:DELay', str_type=float)
        self.sweep_delay_auto_en = scpiDevice('SWEep:DELay:AUTO', str_type=bool)
        self.sweep_direction = scpiDevice('SWEep:DIRection', choices=ChoiceStrings('UP', 'DOWN', 'RANDom'))
        self.lowfout_freq = scpiDevice(':LFOutput:FREQuency', str_type=float, min=10, max=5e6)
        self.lowfout_amp_V = scpiDevice(':LFOutput:AMPLitude', str_type=float, min=0, max=2.5, doc=
            """"""Vpp, only for LFGenerator and sine or triangle into 50 Ohm
               (not accurate, and with an offset).
               For Square amp=5V CMOS always."""""")
        self.lowfout_shape = scpiDevice(':LFOutput:SHAPe', choices=ChoiceStrings('SINE', 'TRIangle', 'SQUare'))
        self.lowfout_source = scpiDevice(':LFOutput:SOURce', choices=ChoiceStrings('LFGenerator', 'PULM', 'TRIGger'))
        self.lowfout_en = scpiDevice(':LFOutput:STATe', str_type=bool)
        self.mod_am_en = scpiDevice(':AM:STATe', str_type=bool)
        self.mod_fm_en = scpiDevice(':FM:STATe', str_type=bool)
        self.mod_phase_en = scpiDevice(':PM:STATe', str_type=bool)
        self.mod_pulse_en = scpiDevice(':PULM:STATe', str_type=bool)
        self.alias = self.freq_cw
        # This needs to be last to complete creation
        super(BNC_rf_845, self)._create_devs()
    def phase_sync(self):
        """"""
        Sets the current output phase as a zero reference.
        """"""
        self.write('PHASe:REFerence')


#######################################################
##    Scientific Magnetics Magnet Controller SMC120-10ECS
#######################################################

_parse_magnet_glitches = 0

def _parse_magnet_return(s, conv):
    """"""
    s is the input string
    conv is a list of tuples (start symbol, name, type)
    """"""
    global _parse_magnet_glitches
    names = []
    vals = []
    for symb, name, t in conv[::-1]:
        if symb=='last':
            vals.append(_fromstr_helper(s[-1], t))
            s = s[:-1]
        else:
            sp = s.rsplit(symb, 1)
            # I have notice that sometimes the instrument does not send the first
            # letter of the reply (at least for status update K, it sometimes (1 out of 20000),
            #  skips sending R). So capture that and handle it.
            if len(sp) == 1:
                vals.append(_fromstr_helper(sp[0], t))
                s = """"
                _parse_magnet_glitches += 1
            else:
                vals.append(_fromstr_helper(sp[1], t))
                s = sp[0]
        names.append(name)
    if s != """":
        raise RuntimeError('There is some leftovers (%s) in the string'%s)
    return dict_improved(zip(names[::-1], vals[::-1]))

def _repeat_getdev_dec(func):
    def _repeat_getdev_wrap(self, *arg, **kwarg):
        i = 0
        while True:
            try:
                ret = func(self, *arg, **kwarg)
                break
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    raise
                if i == 2:
                    raise
            i += 1
        _repeat_getdev_wrap._bad_count += i
        return ret
    _repeat_getdev_wrap._bad_count = 0
    return _repeat_getdev_wrap


@register_instrument('Scientific Magnetics', 'SMC120-10', '5.67')
class MagnetController_SMC(visaInstrument):
    """"""
    This controls a Scientific Magnetics Magnet Controller SMC120-10ECS
    Usefull device:
        ramp_T
        ramp_wait_after
        field
        rawIV
    You only control the lower setpoint. The upper setpoint is to control
    maximum value.
    Important, either leave the instrument in Tesla or at least
    do not change the calibration (it is read during init.)
    This only handles serial address connections (like ASRL1)
    Important: To changes values like display Unit, the instrument needs to be
    in remote (press remote button).
    To change the polarity(reverse option of operating_parameters),
    the current needs to be near zero to work (<0.09 A). It fails silently
    when above (reread operating_parameters to confirm the change).
    """"""
    def __init__(self, address):
        cnsts = visa_wrap.constants
        super(MagnetController_SMC, self).__init__(address, parity=cnsts.Parity.none, flow_control=cnsts.VI_ASRL_FLOW_XON_XOFF,
                                            baud_rate=9600, data_bits=8, stop_bits=cnsts.StopBits.two)
    def init(self, full=False):
        super(MagnetController_SMC, self).init(full=full)
        self._magnet_cal_T_per_A = self.operating_parameters.get()['calibTpA']
        maxT = self._magnet_max_T = self.setpoints.get(Tunit=True).upper
        self._magnet_max_I = self.setpoints.get(Tunit=False).upper
        self.ramp_T.min = -maxT
        self.ramp_T.max = maxT
    def idn(self):
        return 'Scientific Magnetics,SMC120-10,000000,5.67'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('field', 'current_status', 'setpoints', 'status', 'operating_parameters', 'ramp_wait_after', options)
    @_repeat_getdev_dec
    def _field_internal(self):
        s=self.ask('N')
        if s[0] == 'F':
            d = _parse_magnet_return(s, [('F', 'field', float), ('V', 'volt', float),
                                         ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                          ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
            field = d.field
        else:
            d = _parse_magnet_return(s, [('I', 'current', float), ('V', 'volt', float),
                                     ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                     ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
            field = d.current * self._magnet_cal_T_per_A
        return field, d
    def _field_getdev(self):
        field, d = self._field_internal()
        return field
    @_repeat_getdev_dec
    def _current_status_getdev(self):
        # Note that G,N returns the live output, while only J returns the persistent current (this is different than
        #  what the manual says.)
        s=self.ask('G')
        d = _parse_magnet_return(s, [('I', 'current', float), ('V', 'volt', float),
                                     ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                     ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
        return d
    def _rawIV_getdev(self):
        d = self._current_status_getdev()
        return d.current, d.volt
    def _operating_parameters_setdev(self, value):
        """"""
        When setting, you need a dictionnary.
        You can only set the following keys, to the corresponding values:
            rate:  sign of value is lost. in A/s.
            Tunit: True or False
            reverse: True or False
        But reverse will only work if field and voltage are 0.
        """"""
        for k,v in value.iteritems():
            if k == 'rate':
                self.write('A%.5f'%abs(v))
            elif k == 'Tunit':
                 self.write('T%i'%v)
            elif k == 'reverse':
                 self.write('D%i'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)
    @_repeat_getdev_dec
    def _operating_parameters_getdev(self):
        s = self.ask('O')
        return _parse_magnet_return(s, [('A', 'rate', float), ('D', 'reverse', bool),
                                        ('T', 'Tunit', bool), ('B', 'lockout', bool),
                                        ('W', 'Htr_current', float), ('C', 'calibTpA', float)])
    def _setpoints_setdev(self, values):
        Tunit = values.pop('Tunit', None)
        if Tunit is not None:
            self.write('T%i'%Tunit)
        for k,v in values.iteritems():
            v = abs(v)
            if k == 'lower':
                self.write('L%f'%v)
            #elif k == 'upper':
            #    self.write('U%f'%v)
            elif k == 'voltLim':
                self.write('Y%f'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)
    @_repeat_getdev_dec
    def _setpoints_getdev(self, Tunit='default'):
        """"""
        When setting, use a dictionnary with keys of 'lower' and/or 'voltLim'
        and with value the setpoint/limit you want (the sign of the value is lost).
        Also use 'Tunit' key with value False/True.
        For upper/lower you should also always set Tunit (if not it will use the current unit of the instrument.)
        For set, any unspecified value is unchanged.
        """"""
        s = self.ask('S')
        d = _parse_magnet_return(s, [ ('T', 'Tunit', bool), ('U', 'upper', float), ('L', 'lower', float),
                                     ('Y', 'voltLim', float)])
        if Tunit != 'default' and Tunit != d['Tunit']:
            if Tunit:
                f = self._magnet_cal_T_per_A
            else:
                f = 1./self._magnet_cal_T_per_A
            d['upper'] *= f
            d['lower'] *= f
            d['Tunit'] = Tunit
        return d
    def persistent_force(self):
        """"""
        This is very dangerous. It is currently disabled.
        """"""
        #self.write('H2')
        pass
    def persistent_forget(self):
        """"""
        This is dangerous. It is currently disabled.
        """"""
        #self.write('H9')
        pass
    def _status_setdev(self, value):
        for k,v in value.iteritems():
            if k == 'target':
                ch=ChoiceIndex(['zero', 'lower','upper'])
                self.write('R%s'%ch.tostr(v))
            elif k == 'pause':
                self.write('P%i'%v)
            elif k == 'persistent':
                # note that persistent could be True(1), False(0), see also persistent_force and forget
                self.write('H%i'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)

    @_repeat_getdev_dec
    def _status_getdev(self):
        """"""
        When setting, you need a dictionnary.
        You can only set the following keys, to the corresponding values:
            target: 'zero', 'lower' or 'upper'
            pause: True or False
            persistent: True or False
        """"""
        s = self.ask('K')
        d= _parse_magnet_return(s, [('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                    ('M', 'rampstate', ChoiceIndex(['ramping', 'unknown', 'at_target'])),
                                    ('P', 'pause', bool), ('X', 'trip', ChoiceIndex(['off', 'on_inactive', 'on_active', 'off_active', 'on_auto_inactive', 'on_auto_active'])),
                                    ('H', 'persistent', bool), ('Z', 'foo', float),
                                    ('E', 'error', int), ('Q', 'trip_point', float)])
        # Note that the value of M is not properly described in manual. At least it does not match
        # what I observe (0=ramping, 2=at target, 1 is not seen)
        # at target is shown when control has reached the value. The actual outputs gets there a little bit later
        d.pop('foo')
        return d

    def get_error(self):
        return 'This instrument does not return the communication error state. Use status error value instead.'

    def _ramping_helper(self, stay_states, end_states=None, extra_wait=None):
        to = time.time()
        if self._last_state == 'ramp':
            # Reaching here, the cache should be ok.
            factor = -1. if self.operating_parameters.getcache().reverse else 1.
            prog_base = 'Magnet Ramping {field:.3f}/%.3f T'%(self.setpoints.getcache().lower*factor)
        else: # zeroing field
            prog_base = 'Magnet Ramping {field:.3f}/0 T'
        if isinstance(stay_states, basestring):
            stay_states = [stay_states]
        with release_lock_context(self):
            with mainStatusLine.new(priority=10, timed=True) as progress:
                check = lambda x: x.rampstate in stay_states and x.error == 0
                while check(self.status.get()):
                    # The instrument is slow. Trying to read too fast is counter productive
                    wait(.5)
                    progress(prog_base.format(field=self.field.get(), time=time.time()-to))
            if self.status.getcache().error != 0:
                error_code = self.status.getcache().error
                errors = []
                if error_code >= 10:
                    errors.append({1:'Changing polarity with I/V != 0.',
                                    2:'Polarity did not switch correctly',
                                    3:'Polarity switch in invalid state'}[error_code//10])
                if error_code%10 != 0:
                    errors.append({1:'Quenched!!',
                                    2:'External trip',
                                    3:'Quenched!! and External trip',
                                    4:'Brick trip',
                                    5:'Heatsink overtemperature trip',
                                    6:'Slave trip',
                                    7:'Heatsink overvoltage trip'}[error_code%10])
                # Polarity switch (I/V) != 0. error is only reset once a proper polarity change is performed
                # i.e. when changing polarity (operating_parameters reverse option)  with I=V=0.
                raise RuntimeError(self.perror('Magnet is in error: %s'%', '.join(errors)))
            if extra_wait:
                wait(extra_wait, progress_base='Magnet wait')
        if end_states is not None:
            if isinstance(end_states, basestring):
                end_states = [end_states]
            if self.status.get().rampstate not in end_states:
                raise RuntimeError(self.perror('The magnet state did not change to %s as expected'%end_states))

    def _do_ramp(self, field_target, wait):
        status = self.status.get()
        # chaning pause or target status takes 0.6 each and it is cumulative.
        # Therefore check if the change is needed before doing it.
        if field_target == 0:
            if status.target != 'zero':
                self.status.set(target='zero')
            if status.pause:
                self.status.set(pause=False)
            self._last_state = 'zero'
        else:
            #self.status.set(pause=True)
            self.setpoints.set(lower=field_target, Tunit=True)
            if status.target != 'lower':
                # This can take 0.6s so only do it when necessary.
                self.status.set(target='lower')
            if status.pause:
                self.status.set(pause=False)
            self._last_state = 'ramp'
        # unknow state seems to be a possible transient between ramping and at_target.
        # I only see it once (when continuously reading status) immediately followed by 'at_target'
        # I don't always see it.
        # Since the end_states check is done after a second reading of status (and a possible wait)
        # we should never have to check for it but to be safe I add it anyway (my observations time was not infinite)
        self._ramping_helper('ramping', ['at_target', 'unknown'], wait)
        # With a ramping rate of 0.00585 A/s  = 0.031 T/min
        # when going to zero, at_target shows up at about 3 mT and it takes about another 5 s to go to 0.
        # going to non-zero field (+0.05), at_target shows up at about 20 mT from target, and it takes another 15-20 s to become stable (0.0505 T)

    def _ramp_T_checkdev(self, val, wait=None, quiet=True):
        BaseDevice._checkdev(self.ramp_T, val)

    def _ramp_T_setdev(self, val, wait=None, quiet=True):
        """""" Goes to the requested setpoint and then waits until it is reached.
            After the instrument says we have reached the setpoint, we wait for the
            duration set by ramp_wait_after (in s).
            wait can be used to set a wait time (in s) after the ramp. It overrides ramp_wait_after.
            When using get, returns the magnet field in T.
        """"""
        def print_if(s):
            if not quiet:
                print s
        if wait is None:
            wait = self.ramp_wait_after.getcache()
        reverse_en = self.operating_parameters.get().reverse
        neg_val = True if val<0 else False
        if val != 0 and reverse_en != neg_val:
            # We need to switch polarity
            print_if('Ramping to zero for polarity change ...')
            # When switching polarity, need to wait. 5s is minium I observed as necessary.
            #  To be safe make it 20.
            self._do_ramp(0, 20.)
            self.operating_parameters.set(reverse = not reverse_en)
        print_if('Ramping...')
        self._do_ramp(val, wait)

    def _ramp_T_getdev(self):
        return self.field.get()

    def _create_devs(self):
        self.ramp_wait_after = MemoryDevice(20., min=0.)
        self._devwrap('field', doc='units are Tesla')
        self._devwrap('operating_parameters', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['rate', 'reverse', 'Tunit'], [float, bool, bool], allow_missing_keys=True))
        self._devwrap('setpoints', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['lower', 'voltLim', 'Tunit'], [float, float, bool], allow_missing_keys=True))
        self._devwrap('status', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['pause', 'target', 'persistent'], [bool, float, bool], allow_missing_keys=True))
        self._devwrap('current_status')
        self._devwrap('rawIV')
        self.rawIV._format['multi'] = ['current', 'volt']
        self._devwrap('ramp_T')
        self.alias = self.field
        # This needs to be last to complete creation
        super(MagnetController_SMC, self)._create_devs()


#######################################################
##    Pfeiffer DCU400 TC400
#######################################################

class pfeiffer_turbo_loop(threading.Thread):
    def __init__(self, master):
        super(pfeiffer_turbo_loop, self).__init__()
        self.master = master
        self._stop = False
    def cancel(self):
        self._stop = True
    def run(self):
        # empty buffer
        self.master.visa.flush(visa_wrap.constants.VI_IO_IN_BUF_DISCARD)
        # trow away first partial data
        self.master.read()
        while True:
            if self._stop:
                return
            string = self.master.read()
            res = self.master.parse(string)
            if res is None:
                continue
            param, data = res
            #self.master._alldata_lock.acquire()
            self.master._alldata[param] = data, time.time()
            #self.master._alldata_lock.release()
    def wait(self, timeout=None):
        # we use a the context manager because join uses sleep.
        with _sleep_signal_context_manager():
            self.join(timeout)
        return not self.is_alive()

class pfeiffer_dev(BaseDevice):
    def __init__(self, param, type, enable_set=False, *args, **kwargs):
        super(pfeiffer_dev, self).__init__(*args, **kwargs)
        self._param = param
        self._param_type = type
        self._getdev_p = 'foo'
        if enable_set:
            self._setdev_p = 'foo'
    def _getdev(self):
        if self.instr._monitor_mode:
            return self.instr.get_param(self._param, self._param_type)
        else:
            request = self.instr._create_req(self._param)
            self.instr.write(request)
            return self.instr.get_param(self._param, self._param_type)
    def _setdev(self, val):
        if self.instr._monitor_mode:
            raise NotImplementedError(self.perror('The set for this device is not available'))
        request = self.instr._create_req(self._param, val, self._param_type)
        self.instr.write(request)
        ret = self.instr.get_param(self._param, self._param_type)
        self.setcache(ret)

@register_instrument('Pfeiffer', 'TC400')
class pfeiffer_turbo_log(visaInstrument):
    """"""
        This reads the information from a Pfeiffer pump
        using a serial to rs-485 converter.
        The pump is connected to a DCU unit that requests and reads
        all the values. We just capture all of them (when monitor_mode == True,
        the default).
    """"""
    # we had trouble with the Visa serial connection that kept frezzing.
    # So we use the serial module instead.
    def __init__(self, address, monitor_mode=True):
        cnsts = visa_wrap.constants
        super(pfeiffer_turbo_log, self).__init__(address, timeout=5, parity=cnsts.Parity.none, baud_rate=9600, data_bits=8,
             stop_bits=cnsts.StopBits.one, write_termination='\r', read_termination='\r', end_input=cnsts.SerialTermination.termination_char)
        self._monitor_mode = monitor_mode
        if monitor_mode:
            # Locking makes the get code go slow so don't do it
            self._lock_extra = Lock_Extra()
            self._lock_instrument = Lock_Extra()
            self._alldata = dict()
            self._alldata_lock = threading.Lock()
            s = weakref.proxy(self)
            self._helper_thread = pfeiffer_turbo_loop(s)
            self._helper_thread.start()
    def __del__(self):
        self._helper_thread.cancel()
        self._helper_thread.wait(.1)
        super(pfeiffer_turbo_log, self).__del__()
    def idn(self):
        return 'Pfeiffer,TC400,no_serial,no_firmare'
    def parse(self, string):
        chksum = string[-3:]
        try:
            chksum = int(chksum)
        except ValueError:
            print 'Invalid Checksum value', string
            return None
        if np.sum(bytearray(string[:-3]))%256 != chksum:
            print 'Invalid Checksum', string
            return None
        addr = string[:3]
        if addr != '001':
            print 'Invalid address', string
            return None
        action = string[3:5]
        if action != '10':
            if action != '00':
                print 'Invalid action', string
            return None
        # action == '00' is for a question
        param = int(string[5:8])
        len = int(string[8:10])
        data = string[10:10+len]
        return param, data
    def _create_req(self, param, data=None, type='string'):
        """""" if data is None, creates a request for a value.
            possible types:
                boolean
                string
                integer
                real
                expo
                vector
                boolean_new
                short_int
                tms_old
                expo_new
                string16
                string8
        """"""
        addr = '001'
        action = '00'
        param_s = '%03i'%param
        if data is None:
            data_str = '=?'
        else:
            data_str = ''
            def check(data, min_val, max_val):
                if data>max_val or data<min_val:
                    raise ValueError(self.perror('Value(%s) outside of valid range(%s,%s)'%(data, min_val, max_val)))
                return data
            if type == 'boolean':
                s = '1' if data else '0'
                s = s*6
            elif type == 'boolean_new':
                s = '1' if data else '0'
            elif type in ['string', 'string16', 'string8']:
                l = dict(string=6, string16=16, string8=8)[type]
                s = '%-*s'%(l, data[:l])
            elif type == 'integer':
                s = '%06i'%check(data, 0, 999999)
            elif type == 'short_int':
                s = '%03i'%check(data,0,999)
            elif type == 'real':
                s = '%06i'%check(data*100, 0, 999999)
            elif type == 'expo_new':
                fexp = int(np.floor(np.log10(check(data, 0, 9.9994e79))))
                fman = int(np.round(data/10.**(fexp-3)))
                if fman>9999:
                    fman = fman//10
                    fexp += 1
                check(fexp, -20, 79)
                check(fman, 0, 9999)
                s = '%04i%02i'%(fman, fexp+20)
            elif type in ['expo', 'tms_old', 'vector']:
                raise NotImplementedError(self.perror('tms_old and vector are not implemented yet'))
            else:
                raise ValueError(self.perror('Invalid type'))
            data_str = s
        data_len = '%02i'%len(data_str)
        req = addr + action + param_s + data_len + data_str
        chksum = np.sum(bytearray(req))%256
        req += '%03i'%chksum
        return req
    def get_param(self, param, type='string'):
        """""" possible type:
                boolean
                string
                integer
                real
                expo
                vector
                boolean_new
                short_int
                tms_old
                expo_new
                string16
                string8
        """"""
        if self._monitor_mode:
            self._alldata_lock.acquire()
            val = self._alldata.get(param)
            self._alldata_lock.release()
            if val is None:
                print 'Data not available yet'
                return None
            val, last = val
        else:
            val_str = self.read()
            param_read, val = self.parse(val_str)
            if param_read != param:
                raise RuntimeError(self.perror('Received unexpected param (%i!=%i)'%(param_read, param)))
        if type in ['boolean',  'boolean_new']:
            return bool(int(val))
        elif type in ['integer', 'short_int']: #integer is 6 digits, short is 3
            return int(val)
        elif type == 'real':
            return int(val)/100.
        elif type == 'expo':
            return float(val)
        elif type == 'expo_new':
            return val[:4]/1000. * 10**(int(val[4:])-20)
        elif type in ['string', 'string16', 'string8']: # string is 6 long
            return val
        elif type in ['tms_old', 'vector']:
            raise NotImplementedError(self.perror('tms_old and vector are not implemented yet'))
        else:
            raise ValueError(self.perror('Invalid type'))
        return val
    def _create_devs(self):
        self.temp_power_stage = pfeiffer_dev(324, 'integer')
        self.temp_elec = pfeiffer_dev(326, 'integer')
        self.temp_pump_bottom = pfeiffer_dev(330, 'integer')
        self.temp_bearing = pfeiffer_dev(342, 'integer')
        self.temp_motor = pfeiffer_dev(346, 'integer')
        self.actual_speed = pfeiffer_dev(309, 'integer')
        self.drive_current = pfeiffer_dev(310, 'real')
        self.drive_power = pfeiffer_dev(316, 'integer')
        #self._devwrap('temp_pump_bottom')
        #self.alias = self.field
        # This needs to be last to complete creation
        super(pfeiffer_turbo_log, self)._create_devs()

#######################################################
##    Delft BIAS-DAC
#######################################################

#@register_instrument('Delft', 'BIAS-DAC', '1.4')
@register_instrument('Delft', 'BIAS-DAC')
class delft_BIAS_DAC(visaInstrument):
    """"""
       This is to set the voltages on a Delft made BIAS-DAC.
       It works with version 1.4 of the fiber control box.
       The box is only connected with a serial port.
       WARNING: the voltages that are read are only what the
         control box remembers it sent to the hardware. If the
         power is lost on the hardware or the control box, the
         values are INVALID until new ones are set.
       For the voltages to be valid, the programs needs to
       know the settings of the 4 dials. You should set them
       up properly before using the device.

       Useful device:
          level
          level_all
          current_ch
       Useful methods:
          set_config
          get_config
    """"""
    def __init__(self, address):
        self._last_error_val = 0
        self._dac_modes_blocks = [None]*4
        self._last_dac_read_time = None
        self._last_dac_read_vals = None
        cnsts = visa_wrap.constants
        super(delft_BIAS_DAC, self).__init__(address, parity=cnsts.Parity.odd, baud_rate=115200, data_bits=8,
             stop_bits=cnsts.StopBits.one, write_termination=None, read_termination=None, end_input=cnsts.SerialTermination.none)
        # Note that end_input default is cnsts.SerialTermination.termination_char
        #  the read code works even in that case. However to be clearer about our intentions we set it properly here
        #  (the difference is that self.visa.read_raw_n will stop at term char (newline). read_raw_n_all will
        #   repeat the read until the full count is received)
    def _base_command(self, command, *args):
        """"""
        This handles commands 'set_dac', 'read_dacs', 'get_version', 'set_interface_bits'
                              and even 'continues_send_data'
        The args for 'set_dac', 'continues_send_data' are
            channel number (1-16)
            dac value (uint16)
        The args for 'set_interface_bits' are
            values: uint32
                     note that value 1<<27 turns the LED on.
                     some bits cannot be toggle (masked with 0xff00a0a0)
        The return value is None except for:
            'get_version': where is is an integer (divide by 10 to get version number)
            'read_dacs': where it is 16 uint16
        """"""
        send_header = '>bbbb' # size, error, out_size, action
        recv_header = '>bb'   # size, error
        if command in ('set_dac','continues_send_data') :
            send_header += 'bH' # channel, dac_value(uint16)
            cmd_val = 1 if command == 'set_dac' else 3
            n_arg = 2
            ch = args[0]
            daq_val = args[1]
            if ch<1 or ch>16:
                raise ValueError('Invalid channel number. Should be 1<=ch<=16')
            if daq_val<0 or daq_val>0xffff:
                raise ValueError('Invalid daq_val. Should be 0<= val <= 0xffff')
        elif command == 'read_dacs':
            cmd_val = 2
            n_arg = 0
            recv_header += '16H'
        elif command == 'get_version':
            cmd_val = 4
            n_arg = 0
            recv_header += 'b'
        elif command == 'set_interface_bits':
            send_header += 'bH4s' # channel, dac_value(uint16), inteface_bits(uint32)
            cmd_val= 5
            n_arg = 3
            ib = struct.pack('<I', args[0]&0xff00a0a0)
            # the inteface bit has the wrong endianness
            args = (0,0)+(ib,)+args[1:]
        else:
            raise ValueError('Invalid Command')
        if len(args) != n_arg:
            raise ValueError('Invalid number of arguments')
        send_len = struct.calcsize(send_header)
        recv_len = struct.calcsize(recv_header)
        send_str = struct.pack(send_header, send_len, 0, recv_len, cmd_val, *args)
        self.write(send_str)
        res = self.read(count=recv_len)
        ret_vals = struct.unpack(recv_header, res)
        n_read, error = ret_vals[:2]
        self._last_error_val = error
        if n_read != recv_len:
            raise RuntimeError('Unexpected return value header length')
        if error != 0:
            if error & 0x20:
                print ""WARNING: The controller was reset (watchdog) (%i)""%error
                #raise RuntimeError('The controller was reset (watchdog) (%i)'%error)
            if error & 0x40:
                raise RuntimeError('Invalid dac channel (%i)'%error)
            if error & 0x80:
                raise RuntimeError('Wrong Action (%i)'%error)
            raise RuntimeError('Unknown error (%i)'%error)
        rest = ret_vals[2:]
        if len(rest):
            return rest
        else:
            return None
    def _get_ch_mode(self, ch):
        block_index = (ch-1)//4
        mode = self._dac_modes_blocks[block_index]
        return mode
    def _set_ch_command(self, val, ch):
        mode = self._get_ch_mode(ch)
        if mode is None:
            raise RuntimeError(self.perror('You did not initialize the mode for ch=%i. See set_config method.'%ch))
        dac_val = self._v2dac_conv(val, mode)
        self._base_command('set_dac', ch, dac_val)
        self._last_dac_read_time = None
    def _get_all_command(self):
        last = self._last_dac_read_time
        now = time.time()
        if last is None or last+0.5 < now:
            # force a read after a set, or after more than 0.5s since last read
            #print 'READING DAC'
            data = self._base_command('read_dacs')
            self._last_dac_read_time = now
            self._last_dac_read_vals = data
            return data
        else:
            return self._last_dac_read_vals
    def _get_ch_command(self, ch, do_exc=True):
        data = self._get_all_command()
        val = data[ch-1]
        mode = self._get_ch_mode(ch)
        if mode is None:
            if do_exc:
                raise RuntimeError(self.perror('You did not initialize the mode for ch=%i. See set_config method.'%ch))
            else:
                return val
        return self._dac2v_conv(val, mode)
    def read(self, raw=False, count=2, chunk_size=None):
        # change the count default.
        return super(delft_BIAS_DAC, self).read(count=count)
    def idn(self):
        firm_version = self._base_command('get_version')[0]/10.
        return 'Delft,BIAS-DAC,serial-unknown,%r'%firm_version
    def get_error(self):
        return self._last_error_val
    _mode_offset = dict(neg=4., bip=2., pos=0.)
    _dac_full_range = 2**16
    def _dac2v_conv(self, dac, mode):
        v = dac*4./self._dac_full_range
        v -= self._mode_offset[mode]
        return v
    def _v2dac_conv(self, v, mode):
        full_range = self._dac_full_range
        v += self._mode_offset[mode]
        dac = v/4. * full_range
        dac = int(round(dac))
        # make sure 0 <= dac < full_range
        dac = min(max(dac, 0), full_range-1)
        return dac
    def set_config(self, dac_mode_1_4=None, dac_mode_5_8=None, dac_mode_9_12=None, dac_mode_13_16=None):
        """"""
        For all the blocks the valid options are None, 'pos', 'neg', 'bip'
        where None means keep the previous value,
        'pos', 'neg', 'bip' mean positive (0 - 4V), negative (-4 - 0V) and bipolar (-2 - 2V)
        """"""
        modes = [dac_mode_1_4, dac_mode_5_8, dac_mode_9_12, dac_mode_13_16]
        for i, m in enumerate(modes):
            if m is None:
                continue
            if m not in ['pos', 'neg', 'bip']:
                raise ValueError(self.perror('invalid mode'))
            self._dac_modes_blocks[i] = m
    def get_config(self, do_return=False):
        blocks = self._dac_modes_blocks
        if do_return:
            return blocks
        print 'Current dac mode is:'
        for i in range(4):
            mode = blocks[i]
            print '   DAC mode %2i - %2i: %s'%(i*4+1, i*4+4, mode)
    def _level_helper(self, ch):
        if ch is None:
            return self.current_ch.get()
        if ch<1 or ch>16:
            raise ValueError(self.perror('channel is outside the 1-16 range.'))
        self.current_ch.set(ch)
        return ch
    def _level_checkdev(self, val, ch=None):
        ch = self._level_helper(ch)
    def _level_setdev(self, val, ch=None):
        ch = self._level_helper(ch)
        self._set_ch_command(val, ch)
    def _level_getdev(self, ch=None):
        ch = self._level_helper(ch)
        return self._get_ch_command(ch)
    def _level_all_setdev(self, all_values):
        if len(all_values) != 16:
            raise ValueError(self.perror('Need to provide a vector of 16 elements'))
        for i, val in enumerate(all_values):
            self._set_ch_command(val, i+1)
    def _level_all_getdev(self):
        return np.array([self._get_ch_command(ch) for ch in range(1,17)])
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        modes = self.get_config(do_return=True)
        values = [self._get_ch_command(ch, do_exc=False) for ch in range(1,17)]
        for i, m in enumerate(modes):
            if m is None:
                for ch in range(i*4, i*4+4):
                    values[ch] = '%#06x'%values[ch]
        base = ['modes=%r'%modes, 'values=%r'%values]
        return base+self._conf_helper('current_ch', options)
    def _create_devs(self):
        self.current_ch = MemoryDevice(1, choices=range(1,17))
        self._devwrap('level', autoinit=False, setget=True, doc='option ch: it is the channel to use (1-16). When not given it reuses the last one.')
        titles = ['dac_%02i'%i for i in range(1, 17)]
        self._devwrap('level_all', setget=True, autoinit=False, multi=titles)
        self.alias = self.level
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

#######################################################
##    Micro Lambda Wireless MLBF filter
#######################################################

#@register_instrument('micro_lambda_wireless', 'MLBFP-78020', '1.2  Aug 29 2016')
@register_instrument('micro_lambda_wireless', 'MLBFP-78020')
class micro_lambda_mlbf(BaseInstrument):
    """"""
    This is the driver for the Micro Lambda Wireless MLBF YIG filter.
    It currently works using the UDP (network) protocol or the USB protocol
    if cython-hipapi isinstalled. To install cython-hipapi on windows can be
    done with: pip install hidapi
    You need to specify either the udp_address (like '192.168.137.10' or 'mlbf0093')
    or the usb value (True or a serial number string like '0093')
    NOTE: the usb driver does hang when communicating a lot. When that happens the whole
    instrument is completely frozen and requires disconnecting the power cable.
    """"""
    def __init__(self, udp_address=None, udp_port=30303, usb=None, **kwargs):
        if usb is not None and usb is not False:
            import hid
            usbdev = hid.device()
            usb_kwargs = {}
            if usb is not True:
                usb_kwargs['serial_number'] = unicode(usb)
            usbdev.open(0x04d8, 0x003f, **usb_kwargs)
            usbdev.set_nonblocking(True) # just to be safe. Probably unecessary since I used read timeouts.
            self._usbdev = usbdev
            self._usb_timeout = None
            self._socket = None
        else:
            self._socket = socket.socket(type=socket.SOCK_DGRAM)
            self._socket.connect((udp_address, udp_port))
            self._usbdev = None
        self.set_timeout = 3
        self._last_write = 0
        # from testing 0.001 seems good enough. So to be safe, make it 0.01
        self._write_delay = 0.01
        super(micro_lambda_mlbf, self).__init__(**kwargs)

    def idn(self):
        conf = self.conf_general()
        return 'micro_lambda_wireless,%s,%s,%s'%(conf['model'], conf['serial'], conf['firmware_date'])

    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        opts = self._conf_helper('freq', 'temperature', 'temperature_highest')
        opts += ['conf_general=%s'%self.conf_general()]
        opts += ['protocol=%s'%('udp' if self._socket is not None else 'usb')]
        opts += self._conf_helper(options)
        return opts

    @locked_calling
    def write(self, val):
        # writing to fast after a write prevents the first one from working
        # (for example a query of the freq immediately after setting it, prevents
        #  the frequency from changing)
        now = time.time()
        delta = now-self._last_write
        delay = self._write_delay
        if delta < delay:
            wait(delay-delta)
        if self._socket is not None:
            self._socket.send(val)
        else:
            data = [0]*65
            for i, s in enumerate(val):
                data[i+1] = ord(s)
            self._usbdev.write(data)
        self._last_write = time.time()

    @locked_calling
    def read(self, raw=None, chunk_size=None):
        if self._socket is not None:
            ret = self._socket.recv(256)
        else:
            ret = self._usbdev.read(65, timeout_ms=int(self._usb_timeout*1e3))
            if len(ret) == 0:
                raise RuntimeError(self.perror('Timeout when reading.'))
            ret = ''.join(map(chr, ret))
        self._last_write = 0
        # all the reads I have seen have been 18 byte long.
        # Theres is padding with \0 and for socket only (not usb) terminates with \r\n
        zero_ind = ret.find('\0')
        if zero_ind >= 0:
            ret = ret[:zero_ind]
        return ret

    @property
    def set_timeout(self):
        """""" The timeout in seconds """"""
        if self._socket is not None:
            return self._socket.gettimeout()
        else:
            return self._usb_timeout
    @set_timeout.setter
    def set_timeout(self, val):
        if self._socket is not None:
            self._socket.settimeout(val)
        else:
            self._usb_timeout = val
    @locked_calling

    def ask(self, val, raw=None, chunk_size=None):
        self.write(val)
        return self.read()

    @locked_calling
    def close(self):
        if self._socket is not None:
            self._socket.shutdown()
            self._socket.close()
        else:
            self._usbdev.close()

    def _freq_setdev(self, val):
        """""" Set/get frequency in Hz """"""
        if self._socket is not None:
            self.write('F%.4f'%(val*1e-6))
        else: # usb returns an empty string, udp returns nothing
            self.ask('F%.4f'%(val*1e-6))
    def _freq_getdev(self):
        s = self.ask('R16')
        return float(s)*1e6

    def set_display(self, display_string=None):
        """""" Sets the instrument 2 line display to the given string.
            if None, set the first line to freq, the second to temperature.
        """"""
        if display_string is None:
            return self.ask('DT')
        if len(display_string) > 32:
            raise ValueError(self.perror('The requested display string is too long. Need length <= 32.'))
        self.write('""%s""'%display_string)

    def conf_general(self):
        clean = lambda x: x.rstrip('\n\r ')
        model = self.ask('R0')
        serial = self.ask('R1')
        product = self.ask('R2')
        freq_min_MHz = float(self.ask('R3'))
        freq_max_MHz = float(self.ask('R4'))
        v3_0 = float(self.ask('V1')[:-1]) # Need to remove terminating V
        v3_3 = float(self.ask('V2')[:-1]) # Need to remove terminating V
        v5_0 = float(self.ask('V3')[:-1]) # Need to remove terminating V
        vp15 = float(self.ask('V4')[:-1]) # Need to remove terminating V
        vn15 = float(self.ask('V5')[:-1]) # Need to remove terminating V
        filter_bandwidth_MHz = float(self.ask('R5'))
        filter_insertion_loss_dB = float(self.ask('R6'))
        filter_limit_power_dBm = float(self.ask('R7'))
        temperature_min = float(self.ask('R8'))
        temperature_max = float(self.ask('R9'))
        non_volatile_state = clean(self.ask('R11'))
        firmware_date = clean(self.ask('R12'))
        unit_health = self.ask('R13')
        unit_calibration_status = self.ask('R14')
        unit_self_test_result = self.ask('R15')
        filter_passband_spurs_ripples_max_dB = float(self.ask('R17'))
        filter_off_resonance_isolation_min_dB = float(self.ask('R18'))
        filter_bandwidth_meas_spec_db = float(self.ask('R23'))
        unit_coarse_calibration_status = self.ask('R26')
        unit_fine_calibration_status = self.ask('R27')
        firmware_tcpip_stack_version = self.ask('R29')
        firmware_build_time = self.ask('R30')
        ret = locals()
        del ret['self']
        del ret['clean']
        return ret

    def conf_network(self):
        clean = lambda x: x.rstrip('\n\r ')
        dhcp_status = clean(self.ask('R100'))
        ip_addr = clean(self.ask('R101'))
        ip_mask = clean(self.ask('R102'))
        ip_gateway = clean(self.ask('R103'))
        ip_dns1 = clean(self.ask('R104'))
        ip_dns2 = clean(self.ask('R105'))
        mac_address = clean(self.ask('R106'))
        hostname = clean(self.ask('R107'))
        udp_port = int(self.ask('R108'))
        ret = locals()
        del ret['self']
        del ret['clean']
        return ret

    def get_status(self):
        status = self.ask('?')
        val = int(status, 2)
        return dict(self_test_pass=bool(val&0x40), novo_locked=bool(val&0x80))

    def _create_devs(self):
        self.temperature = scpiDevice(getstr='T', str_type=lambda x: float(x[:-1])) # Need to remove terminating C
        self.temperature_highest = scpiDevice(getstr='R10', str_type=float)
        fmin = float(self.ask('R3'))-100
        fmax = float(self.ask('R4'))+100
        self._devwrap('freq', min=fmin*1e6, max=fmax*1e6, setget=True)
        self.alias = self.freq
        self.freq_MHz = ScalingDevice(self.freq, 1e-6, quiet_del=True)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

# Above we use the UDP or USB connection protocol.
# You can also connect using telnet.
#  - The windows telnet works ok
#  - The cygwin works if you specify the port (23) because that prevents
#        automatic initiation of TELNET options.
#  - The protocol seem fragile (hence preventing option negotiation)
#      bad entries can easily block it
#  - It allows only one connection at a time.
# You can also use the web server:
#  - connect to http://192.168.137.10 or something to that effect (standard port 80)
#  - in python
#     import httplib
#     ht = httplib.HTTPConnection('192.168.137.10')
#     ht.request('POST', '/diag.htm', 'cmd=r1'); resp = ht.getresponse()
#     resp.status, resp.reason, resp.read()
#   - can replace /diag.htm  by /commands.htm
#   - should also be able to use /index.htm but that does not seem to work

#######################################################
##    Andeen Hagerling AH 2550A  Ultra-Precision 1 kHz capacitance bridge
#######################################################

#@register_instrument('ANDEEN-HAGERLING', 'AH2550A', 'AH2X0217')
@register_instrument('ANDEEN-HAGERLING', 'AH2550A')
class ah_2550a_capacitance_bridge(visaInstrumentAsync):
    """"""
    This is the driver for the Andeen Hagerling AH 2550A  Ultra-Precision 1 kHz capacitance bridge.
    The protect the life of the instrument relays, do not measure continously (or for long periods
    of time) with the averaging at 7 or above.
       Useful device:
           readval
           fetch
           average
           bias
    """"""
    def __init__(self, *args, **kwargs):
        self._async_trig_current_data = None
        super(ah_2550a_capacitance_bridge, self).__init__(*args, **kwargs)

    def idn_split(self):
        idn = self.idn()
        no_labels = False
        if idn.startswith('\n'):
            no_labels = True
        #'MANUFACTURER    ANDEEN-HAGERLING\nMODEL/OPTIONS   AH2550A  --------\nSERIAL NUMBER   00100319\nACTIVE FIRMWARE AH2X0217'
        pp = idn.split('\n')
        def check_skip(s, start_str):
            if not no_labels:
                if not s.startswith(start_str):
                    raise RuntimeError('Unexepected idn string format')
                s = s[len(start_str):].lstrip()
            return s
        vm = check_skip(pp[0], 'MANUFACTURER')
        if vm == '':
            # without labels the current firmware (AH2X0217) returns an empty manufacturer
            vm = 'ANDEEN-HAGERLING'
        model_option = check_skip(pp[1], 'MODEL/OPTIONS')
        if ',' in model_option:
            # using ieee:
            mo = model_option.split(',')
        else:
            mo = model_option.split(' ')
        model = mo[0].rstrip()
        option = mo[-1]
        sn = check_skip(pp[2], 'SERIAL NUMBER')
        fm = check_skip(pp[3], 'ACTIVE FIRMWARE')
        return dict(vendor=vm, model=model, option=option, serial=sn, firmware=fm)

    def _get_esr(self):
        # does not have esr register
        return 0

    def _async_trigger_helper(self):
        self._async_trig_current_data = None
        self.write('*sre 16;SIngle')

    def _async_detect(self, max_time=.5): # 0.5 s max by default
        ret = super(ah_2550a_capacitance_bridge, self)._async_detect(max_time)
        if not ret:
            # This cycle is not finished
            return ret
        # we got a trigger telling data is available. so read it, before we turn off triggering in cleanup
        data = self.read()
        self._async_trig_current_data = data
        return ret

    def _async_cleanup_after(self):
        self._async_trig_current_data = None
        self.write('*sre 0') # disable trigger on data ready to prevent unread status byte from showing up
        super(ah_2550a_capacitance_bridge, self)._async_cleanup_after()


    def get_error(self, no_reset=False):
        """""" when no_reset is True, the error state is read but not reset """"""
        if no_reset:
            flags = self.read_status_byte()
        else:
            # This will also reset the flags
            flags = int(self.ask('*STB?'))
        errors = []
        if flags & 0x01:
            errors.append('Oven temperature invalid')
        if flags & 0x02:
            errors.append('Command error')
        if flags & 0x04:
            errors.append('User request')
        if flags & 0x08:
            errors.append('Powered on')
        # flags & 0x10 is ready for command
        if flags & 0x20:
            errors.append('Execution Erro')
        # flags & 0x40 is Master summary
        # flags & 0x80 is message available
        if len(errors):
            return ', '.join(errors)
        else:
            return 'No errors.'

    def clear(self):
        #some device buffer status byte so clear them
        while self.read_status_byte()&0x40:
            pass

    def init(self, full=False):
        self.write('*sre 0') # disable trigger (we enable it only when needed)
        self.clear()
        if full:
            # These are normally reset during power on.
            #  float (could be sci or eng), labels off, ieee on (commas), variable spacing (as opposed to fix)
            self.write('FORMAT float,OFF,ON,VARIABLE')
            # fields: sample off, frequency off, Cap 9 digits, loss 9 digits, voltage on, message(error) off means a number
            #  The error shows first
            self.write('FIELD OFF,OFF,9,9,ON,OFF')
            # With this configuration, an invalid question returns '32' or '36'
            #  when error are off the corresponding messages are: ILLEGAL WORD, and SYNTAX ERROR
            #  Table B3 says ILLEGAL WORD is 31, SYNTAX ERROR is 35

    def conf_datetime(self, set_to_now=False, passcode='INVALID'):
        """""" The correct passcode(owner or calibrator) is necessary to change the date/time """"""
        if set_to_now:
            if passcode == 'INVALID':
                raise ValueError(self.perror('You need to specify a valid passcode'))
            tm = time.localtime()
            cmd = 'STOre DAte %i,%i,%i\n%s\nSTOre TIme %i,%i,%i\n%s'%(tm.tm_year, tm.tm_mon, tm.tm_mday, passcode,
                                                                    tm.tm_hour, tm.tm_min, tm.tm_sec, passcode)
            self.write(cmd)
        d = self.ask('SHow DAte')
        t = self.ask('SHow TIme')
        d = map(int, d.split(','))
        t = map(int, t.split(','))
        runtime_hours = int(self.ask('SHow STAtus'))
        return dict(date='%04i-%02i-%02i %02i:%02i:%02i'%tuple(d+t), runtime_hours=runtime_hours)

    def conf_firmwares(self):
        firmwares = self.ask('SHow FIRMware')
        return dict(zip(['bank_rom', 'bank_flash1', 'bank_flash2'], firmwares.split('\n')))

    def conf_zero(self, enable=None, cap=None, loss=None, use_last=False):
        """""" This is used to configure zero mode.
            If none of the entries are specified, it returns the current setting.
            If you use use_last (uses last reading as 0 value) you cannont use cap or loss.
            If either cap or loss is specified, the other value is unchanged.
        """"""
        if use_last and (cap is not None or loss is not None):
            raise ValueError(self.perror('You can only specify cap/loss or use_last'))
        if enable is not None and not enable:
            self.write('Zero '+Choice_bool_OnOff.tostr(enable))
        if use_last:
            self.write('Zero FEtch')
        if cap is not None or loss is not None:
            prev = self.conf_zero()
            if cap is None:
                cap = prev.cap
            if loss is None:
                loss = prev.loss
            # Need to always specify both, otherwise it is an error
            self.write('Zero POINT %r,%r'%(cap, loss))
        if enable is not None and enable:
            self.write('Zero '+Choice_bool_OnOff.tostr(enable))
        res = self.ask('SHow Zero')
        # returns: 'OFF\n"" "",0.00000000,"" "",0.00000000'
        en, points_raw = res.split('\n')
        ret = dict_improved(enabled = Choice_bool_OnOff(en))
        zero_fmt = ChoiceMultiple(['cap_lbl', 'cap', 'loss_lbl', 'loss'], [quoted_string(), float, quoted_string(), float])
        ret.update(zero_fmt(points_raw).items())
        return ret

    def conf_reference(self, enable=None, cap=None, loss=None, percent=None, use_last=False):
        """""" This is used to configure reference mode.
            If none of the entries are specified, it returns the current setting.
            enable/use_last/percent can be None, 'cap', 'loss', 'all' (or True), 'none' (or False)
            If you use use_last (uses last reading as 0 value) you cannont use cap or loss.
            If either cap or loss is specified, the other value is unchanged.
        """"""
        def cleanup(x):
            if x is None:
                return x
            if x not in [True, False, 'all', 'none', 'cap', 'loss']:
                raise ValueError(self.perror('Invalid option'))
            if x is True:
                x = 'all'
            elif x is False:
                x = 'none'
            return x
        enable = cleanup(enable)
        percent = cleanup(percent)
        use_last = cleanup(use_last)
        if use_last in ['cap', 'all'] and cap is not None:
            raise ValueError(self.perror('You can only specify cap or use_last'))
        if use_last in ['loss', 'all'] and loss is not None:
            raise ValueError(self.perror('You can only specify cap or use_last'))
        if enable is not None and enable != 'all':
            # These all return the measurement in the new configuration
            # Not reading it sometimes prevents the change to actually happen
            #  so use ask instead of write
            if enable == 'none':
                self.ask('REFerence ALL OFF')
            elif enable == 'cap':
                self.ask('REFerence LOSs OFF')
            elif enable == 'loss':
                self.ask('REFerence Cap OFF')
        if use_last != 'none':
            self.write('REFerence FEtch %s'%use_last)
        if cap is not None:
            self.write('REFerence POINT Cap %r'%cap)
        if loss is not None:
            self.write('REFerence POINT LOSs %r'%loss)
        if percent is not None:
            if percent in ['all', 'cap']:
                self.write('REFerence PERcent Cap ON')
            if percent in ['all', 'loss']:
                self.write('REFerence PERcent LOSs ON')
            if percent in ['none', 'cap']:
                self.write('REFerence PERcent LOSs OFF')
            if percent in ['none', 'loss']:
                self.write('REFerence PERcent Cap OFF')
        if enable is not None and enable != 'none':
            # These all return the measurement in the new configuration
            # Not reading it sometimes prevents the change to actually happen
            #  so use ask instead of write
            if enable == 'all':
                self.ask('REFerence ALL ON')
            elif enable == 'cap':
                self.ask('REFerence Cap ON')
            elif enable == 'loss':
                self.ask('REFerence LOSs ON')
        res = self.ask('SHow REFerence')
        # returns: 'OFF,OFF\n"" "",0.00000000,"" "",0.00000000\nOFF,OFF'
        en, points_raw, percent = res.split('\n')
        ret = dict_improved()
        ret.update(zip(['cap_en', 'loss_en'], map(Choice_bool_OnOff, en.split(','))))
        zero_fmt = ChoiceMultiple(['cap_lbl', 'cap', 'loss_lbl', 'loss'], [quoted_string(), float, quoted_string(), float])
        ret.update(zero_fmt(points_raw).items())
        ret.update(zip(['cap_percent_en', 'loss_percent_en'], map(Choice_bool_OnOff, percent.split(','))))
        return ret

    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        opts = self._conf_helper('average', 'units', 'voltage_max', 'frequency', 'commutate', 'bias', 'cable')
        opts += ['zero=%r'%self.conf_zero()]
        opts += ['reference=%r'%self.conf_reference()]
        opts += self._conf_helper(options)
        return opts

    _data_format = ChoiceMultiple(['error', 'cap_lbl', 'cap', 'loss_lbl', 'loss', 'volt'], [int, quoted_string(), float, quoted_string(), float, float])
    @locked_calling
    def _read_data(self, force_req=True):
        """""" using force_req will send a fetch request (it will show BUSY on the display)
            When in continuous you can use force_req=False to read the latest value (then wait for the next one.)
            It can also be 'async' to read available async data.
        """"""
        data = None
        if force_req == 'async':
            data = self._async_trig_current_data
            self._async_trig_current_data = None
        elif force_req:
            self.write('fetch')
        if data is None:
            data = self.read()
        return self._data_format(data)

    def continous(self, state=None):
        """""" state can be True/False. If none it returns the current state """"""
        if state is not None:
            self.write('COntinuous %s'%Choice_bool_OnOff.tostr(state))
        else:
            data = self.ask('SHow COntinuous').split('\n')
            data = map(lambda x: x[0](x[1]), zip([float, int, int], data))
            return dict(zip(['interval', 'stop_count', 'count'], data))

    def _fetch_getdev(self):
        """""" error contains cap uncertainty flag (>) if 1000 and loss uncertainty flag (>) if 2000.
            errors codes <100 are listed in Appendix B of manual (careful some numbers are off by 1).
        """"""
        if self._async_trig_current_data is not None:
            data  = self._read_data('async')
        else:
            data  = self._read_data(True)
        error = data.error
        if data.cap_lbl != ' ':
            if data.cap_lbl != '>':
                raise RuntimeError(self.perror('Unexpected cap label received'))
            error += 1000
        if data.loss_lbl != ' ':
            if data.loss_lbl != '>':
                raise RuntimeError(self.perror('Unexpected loss label received'))
            error += 2000
        return data.cap, data.loss, data.volt, error

    def _create_devs(self):
        # TODO: commands to program:
        #   calibrate? / store calibarate
        #   continuous interval, reset, total
        #   dev mode
        #   dev auto
        #   dev average
        #   dev bound
        #   dev fetch
        #   dev format
        #   dev margin
        #   dev point
        #   dev position
        #   dev rolloff
        #   dev span
        #   dev stream
        #   gpib  (to read this use: show gpib list)
        #     logger (to turn it off)
        #     scan to disable it.
        #   serial (to read this use: show serial list)
        #   test?
        # Note that deviation mode does not seem to work with AH2550A (probably only for AH2700)
        cold_k = np.array([.28,.29,.30,.33,.37,.44,.58,.82,1.2,1.8,3,5,9,17,34,68])
        cold_f = np.array([80,110,150,200,260,350,520,820,1300,2200,3900,7000,14000,27000,57000,120000])
        warm_k = np.array([.027, .033,.042,.058,.085,.12,.18])
        warm_f = np.array([11,23,42,75,130,230,400])
        cold_time = cold_k+cold_f/1e3 # at 1 kHz
        warm_time = warm_k+warm_f/1e3 # at 1 kHz
        time_doc = '%6s  %10s %10s\n'%('','cold', 'warm')
        for i in range(len(cold_time)):
            if i < len(warm_time):
                time_doc += '%6i: %10.3f %10.3f\n'%(i, cold_time[i], warm_time[i])
            else:
                time_doc += '%6i: %10.3f %10s\n'%(i, cold_time[i], 'n/a')
        # Note that for loss range the table is not clear if that f is in Hz or kHz but
        # comparing with table 4-3 it seems to be kHz for loss formula hence 12 uS.
        self.average = scpiDevice('AVerage', 'SHow AVerage', str_type=int, min=0, max=15,
                                  doc=u""""""
The averaging time is seen in table 4-1 and A-1 of the manual.
Note cold start measurement are longer because they readjust all the relays.
Warm start only adjust the stages that don't use relays.
For cold start by using average >= 7 (but don't use continous because relays will age too quickly.)
There is a frequency dependence but for 1 kHz it is and C<0.165 µF (G<12 µS):
%s
                                  """"""%time_doc)
        self.bias = scpiDevice('BIas', 'SHow BIas', choices=ChoiceStrings('OFF', 'ILow', 'IHigh'),
                               doc=u'ihigh is 1 MΩ, ilow is 100 MΩ')
        self.units = scpiDevice('UNits', 'SHow UNits',
                                    choices=ChoiceStrings('NS', 'DS', 'KO', 'GO', 'JP'),
                                    doc=u""""""
                                    Choices mean:
                                        NS: Nanosiemens (nS)
                                        DS: Dissipation factor or tanδ (dimensionless)
                                        KO: Series resistance in kilohms (kΩ)
                                        GO: Parallel resistance in gigohms (GΩ)
                                        JP: G/ω  (jpF)
                                    Note that series option (KO) means series capacitance is measured.
                                    Otherwise it is the parallel capacitance that is measured.
                                        """""")
        self.voltage_max = scpiDevice('Voltage', 'SH Voltage', str_type=float, min=0.3e-3, max=15, setget=True,
                                      doc=""""""For optimal use select one of the following voltages: 15, 7.5, 3, 1.5, 0.75, 0.25, 0.1, 0.03, 0.01, 0.003, 0.001"""""")
        #self.frequency =  scpiDevice('FRequency', 'SHow FRequency', str_type=float, setget=True)
        self.frequency =  scpiDevice(getstr='SHow FRequency', str_type=float)
        self.commutate = scpiDevice('COMmutate', 'SHow COMmutate', choices=ChoiceStrings('OFF', 'LINERej', 'ASync'))
        self.cable = scpiDevice('CABle', 'SHow CABle',
                                choices=ChoiceMultiple(['length', 'R', 'L', 'C'], [(float, (0, 999.99)), (float, (0, 9999)), (float, (0, 99.99)), (float, (0, 999.9))], reading_sep='\n'),
                                doc=u""""""Units are: length (m), R(mΩ/m), L(µH/m), C(pF/m)"""""")
        self._devwrap('fetch', autoinit=False, trig=True, multi=['cap', 'loss', 'volt', 'error'], graph=[0,1])
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        # This needs to be last to complete creation
        super(ah_2550a_capacitance_bridge, self)._create_devs()


#######################################################
##    Dummy instrument
#######################################################

@register_instrument('pyHegel_Instrument', 'dummy', '1.0')
class dummy(BaseInstrument):
    """""" This is a dummy device (just in memory) to use for testing.
        There are 5 devices: volt, current, incr, rand and other
          incr is a device that is incremented by 1 after every get
          rand returns a random value from a normal distribution
        Both incr and rand wait the time set in the wait attribute
        before returning from get. The wait attribute defaults to 0.1
    """"""
    def init(self, full=False):
        self.incr_val = 0
        self.wait = .1
    def idn(self):
        return 'pyHegel_Instrument,dummy,00000,1.0'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('volt', 'current', 'other', options)
    def _incr_getdev(self):
        ret = self.incr_val
        self.incr_val += 1
        wait(self.wait)
        return ret
    def _incr_setdev(self, val):
        self.incr_val = val
    #incr3 = wrapDevice(_incr_setdev, _incr_getdev)
    #incr2 = wrapDevice(getdev=_incr_getdev)
    def _rand_getdev(self):
        wait(self.wait)
        return random.normalvariate(0,1.)
    def _create_devs(self):
        self.volt = MemoryDevice(0., doc='This is a memory voltage, a float')
        self.current = MemoryDevice(1., doc='This is a memory current, a float')
        self.other = MemoryDevice(autoinit=False, doc='This takes a boolean')
        #self.freq = scpiDevice('freq', str_type=float)
        self._devwrap('rand', doc='This returns a random value. There is not set.', trig=True)
        self._devwrap('incr')
        self.alias = self.current
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Loop instrument
#######################################################

@register_instrument('pyHegel_Instrument', 'loop', '1.0')
class loop(BaseInstrument):
    """"""
        This is a dummy instrument (just in memory) to use for
        looping/repeating (multi_sweep).
        There are 5 devices: loop1 to loop5
    """"""
    def idn(self):
        return 'pyHegel_Instrument,dummy,00000,1.0'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('loop1', 'loop2',  'loop3', 'loop4', 'loop5', options)
    def _create_devs(self):
        self.loop1 = MemoryDevice(0.)
        self.loop2 = MemoryDevice(0.)
        self.loop3 = MemoryDevice(0.)
        self.loop4 = MemoryDevice(0.)
        self.loop5 = MemoryDevice(0.)
        self.alias = self.loop1
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
"
356,110.6,"Cleveland, Ohio, United States","The 6221 AC and DC Current Source combine ease of use with exceptionally low current noise. Low current sourcing is critical to applications in test environments ranging from R&D to production, especially in the semiconductor, nanotechnology, and superconductor industries. High sourcing accuracy and built-in control functions make the 6221 ideal for applications like Hall measurements, resistance measurements using delta mode, pulsed measurements, and differential conductance measurements.",Keithley 6221,213.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 6221 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 6221,https://download.tek.com/datasheet/6220-6221.pdf,"[OrderedDict([('id', 'attAMc0ndlQOH57r9'), ('width', 218), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lIbQ9FKR-8ZLCtsfekBs6w/LHuZDDeyBd_sEiMBmEuCa-Hn6pdw_LueAQPTqShAugYmvd1-unYLxkiaA3jhpEa5idN14AzfFGT8OQU50Xo1Exx6r74sbdvaTmMV3os1WIc/fTmHb1KfG6EN0rdEeE8x4z4xCOK1YgLr35nMxcpwTHk'), ('filename', '6221.webp'), ('size', 4854), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rGt0XDmQ1Xy1fcsoefL0oA/uFU0xoSnndlSZ3prk0i4NN6ioe4QlF5gvIkTUA6G9NcbfZYzKbTopGJroq70rzp_FnUOOEeaKy2Gg89W24dhjhw188Hw8zC40WArwQLVAvU/9jKCNaEO-EoYfn1R3hrRI1j9SzHXgQiPLaS1WJA-8wI'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zmgTmWoO_BP4wli2pLPPJA/ushfERtAvbyrtG_mSQFu2a4i639ZCZrNwfQSRanxqzcnVOR6kLlDf7vapyL0RjUTylIld0Y2ldhRUyj3cVR_A9SZ1wkkK0WR3gXG0CKV4Wc/kv5Mvh-a92fa1MkC2msIaMNxUc4AG5GyLFp3o_iKBHI'), ('width', 218), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M7FVJpp-DtpKMV7S6D0j7Q/Er1gMXNDjF2sI7k0s2ptovwTHK__zq9AlpFuDLvsMbIezFu-wDKvSI6Ckd1YHWzxCQF608fj6Oameuo0_QNpUoSwnoOIBYF1mHwfV5IjWNE/Z-P0P_A4pWN0SmHBexlav_qErqusYdn1Sni_cpOAUTI'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/6221/source-meter-ac-dc-current-11w/dp/54K3077,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley6221.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley6221.html,11620.4,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time

import numpy as np

from pymeasure.instruments import Instrument, RangeException
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley6221(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 6221 AC and DC current source and provides a
    high-level interface for interacting with the instrument.

    .. code-block:: python

        keithley = Keithley6221(""GPIB::1"")
        keithley.clear()

        # Use the keithley as an AC source
        keithley.waveform_function = ""square""   # Set a square waveform
        keithley.waveform_amplitude = 0.05      # Set the amplitude in Amps
        keithley.waveform_offset = 0            # Set zero offset
        keithley.source_compliance = 10         # Set compliance (limit) in V
        keithley.waveform_dutycycle = 50        # Set duty cycle of wave in %
        keithley.waveform_frequency = 347       # Set the frequency in Hz
        keithley.waveform_ranging = ""best""      # Set optimal output ranging
        keithley.waveform_duration_cycles = 100 # Set duration of the waveform

        # Link end of waveform to Service Request status bit
        keithley.operation_event_enabled = 128  # OSB listens to end of wave
        keithley.srq_event_enabled = 128        # SRQ listens to OSB

        keithley.waveform_arm()                 # Arm (load) the waveform

        keithley.waveform_start()               # Start the waveform

        keithley.adapter.wait_for_srq()         # Wait for the pulse to finish

        keithley.waveform_abort()               # Disarm (unload) the waveform

        keithley.shutdown()                     # Disables output

    """"""

    ##########
    # OUTPUT #
    ##########

    source_enabled = Instrument.control(
        ""OUTPut?"", ""OUTPut %d"",
        """"""A boolean property that controls whether the source is enabled, takes
        values True or False. The convenience methods :meth:`~.Keithley6221.enable_source` and
        :meth:`~.Keithley6221.disable_source` can also be used."""""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    source_delay = Instrument.control(
        "":SOUR:DEL?"", "":SOUR:DEL %g"",
        """""" A floating point property that sets a manual delay for the source
        after the output is turned on before a measurement is taken. When this
        property is set, the auto delay is turned off. Valid values are
        between 1e-3 [seconds] and 999999.999 [seconds]."""""",
        validator=truncated_range,
        values=[1e-3, 999999.999],
    )

    output_low_grounded = Instrument.control(
        "":OUTP:LTE?"", ""OUTP:LTE %d"",
        """""" A boolean property that controls whether the low output of the triax
        connection is connected to earth ground (True) or is floating (False). """""",
        validator=strict_discrete_set,
        values={True: 1, False: 0},
        map_values=True
    )

    ##########
    # SOURCE #
    ##########

    source_current = Instrument.control(
        "":SOUR:CURR?"", "":SOUR:CURR %g"",
        """""" A floating point property that controls the source current
        in Amps. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_compliance = Instrument.control(
        "":SOUR:CURR:COMP?"", "":SOUR:CURR:COMP %g"",
        """"""A floating point property that controls the compliance of the current
        source in Volts. valid values are in range 0.1 [V] to 105 [V]."""""",
        validator=truncated_range,
        values=[0.1, 105])
    source_range = Instrument.control(
        "":SOUR:CURR:RANG?"", "":SOUR:CURR:RANG:AUTO 0;:SOUR:CURR:RANG %g"",
        """""" A floating point property that controls the source current
        range in Amps, which can take values between -0.105 A and +0.105 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    source_auto_range = Instrument.control(
        "":SOUR:CURR:RANG:AUTO?"", "":SOUR:CURR:RANG:AUTO %d"",
        """""" A boolean property that controls the auto range of the current source.
        Valid values are True or False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    ##################
    # WAVE FUNCTIONS #
    ##################

    waveform_function = Instrument.control(
        "":SOUR:WAVE:FUNC?"", "":SOUR:WAVE:FUNC %s"",
        """""" A string property that controls the selected wave function. Valid
        values are ""sine"", ""ramp"", ""square"", ""arbitrary1"", ""arbitrary2"",
        ""arbitrary3"" and ""arbitrary4"". """""",
        values={
            ""sine"": ""SIN"",
            ""ramp"": ""RAMP"",
            ""square"": ""SQU"",
            ""arbitrary1"": ""ARB1"",
            ""arbitrary2"": ""ARB2"",
            ""arbitrary3"": ""ARB3"",
            ""arbitrary4"": ""ARB4"",
        },
        map_values=True
    )

    waveform_frequency = Instrument.control(
        "":SOUR:WAVE:FREQ?"", "":SOUR:WAVE:FREQ %g"",
        """"""A floating point property that controls the frequency of the
        waveform in Hertz. Valid values are in range 1e-3 to 1e5. """""",
        validator=truncated_range,
        values=[1e-3, 1e5]
    )
    waveform_amplitude = Instrument.control(
        "":SOUR:WAVE:AMPL?"", "":SOUR:WAVE:AMPL %g"",
        """"""A floating point property that controls the (peak) amplitude of the
        waveform in Amps. Valid values are in range 2e-12 to 0.105. """""",
        validator=truncated_range,
        values=[2e-12, 0.105]
    )
    waveform_offset = Instrument.control(
        "":SOUR:WAVE:OFFS?"", "":SOUR:WAVE:OFFS %g"",
        """"""A floating point property that controls the offset of the waveform
        in Amps. Valid values are in range -0.105 to 0.105. """""",
        validator=truncated_range,
        values=[-0.105, 0.105]
    )
    waveform_dutycycle = Instrument.control(
        "":SOUR:WAVE:DCYC?"", "":SOUR:WAVE:DCYC %g"",
        """"""A floating point property that controls the duty-cycle of the
        waveform in percent for the square and ramp waves. Valid values are in
        range 0 to 100. """""",
        validator=truncated_range,
        values=[0, 100]
    )
    waveform_duration_time = Instrument.control(
        "":SOUR:WAVE:DUR:TIME?"", "":SOUR:WAVE:DUR:TIME %g"",
        """"""A floating point property that controls the duration of the
        waveform in seconds. Valid values are in range 100e-9 to 999999.999.
        """""",
        validator=truncated_range,
        values=[100e-9, 999999.999]
    )
    waveform_duration_cycles = Instrument.control(
        "":SOUR:WAVE:DUR:CYCL?"", "":SOUR:WAVE:DUR:CYCL %g"",
        """"""A floating point property that controls the duration of the
        waveform in cycles. Valid values are in range 1e-3 to 99999999900.
        """""",
        validator=truncated_range,
        values=[1e-3, 99999999900]
    )

    def waveform_duration_set_infinity(self):
        """""" Set the waveform duration to infinity.
        """"""
        self.write("":SOUR:WAVE:DUR:TIME INF"")

    waveform_ranging = Instrument.control(
        "":SOUR:WAVE:RANG?"", "":SOUR:WAVE:RANG %s"",
        """""" A string property that controls the source ranging of the
        waveform. Valid values are ""best"" and ""fixed"". """""",
        values={""best"": ""BEST"", ""fixed"": ""FIX""},
        map_values=True,
    )
    waveform_use_phasemarker = Instrument.control(
        "":SOUR:WAVE:PMAR:STAT?"", "":SOUR:WAVE:PMAR:STAT %s"",
        """""" A boolean property that controls whether the phase marker option
        is turned on or of. Valid values True (on) or False (off). Other
        settings for the phase marker have not yet been implemented."""""",
        values={True: 1, False: 0},
        map_values=True,
    )
    waveform_phasemarker_phase = Instrument.control(
        "":SOUR:WAVE:PMAR?"", "":SOUR:WAVE:PMAR %g"",
        """""" A numerical property that controls the phase of the phase marker."""""",
        validator=truncated_range,
        values=[-180, 180],
    )
    waveform_phasemarker_line = Instrument.control(
        "":SOUR:WAVE:PMAR:OLIN?"", "":SOUR:WAVE:PMAR:OLIN %d"",
        """""" A numerical property that controls the line of the phase marker."""""",
        validator=truncated_range,
        values=[1, 6],
    )

    def waveform_arm(self):
        """""" Arm the current waveform function. """"""
        self.write("":SOUR:WAVE:ARM"")

    def waveform_start(self):
        """""" Start the waveform output. Must already be armed """"""
        self.write("":SOUR:WAVE:INIT"")

    def waveform_abort(self):
        """""" Abort the waveform output and disarm the waveform function. """"""
        self.write("":SOUR:WAVE:ABOR"")

    def define_arbitary_waveform(self, datapoints, location=1):
        """""" Define the data points for the arbitrary waveform and copy the
        defined waveform into the given storage location.

        :param datapoints: a list (or numpy array) of the data points; all
            values have to be between -1 and 1; 100 points maximum.
        :param location: integer storage location to store the waveform in.
            Value must be in range 1 to 4.
        """"""

        # Check validity of parameters
        if not isinstance(datapoints, (list, np.ndarray)):
            raise ValueError(""datapoints must be a list or numpy array"")
        elif len(datapoints) > 100:
            raise ValueError(""datapoints cannot be longer than 100 points"")
        elif not all([x >= -1 and x <= 1 for x in datapoints]):
            raise ValueError(""all data points must be between -1 and 1"")

        if location not in [1, 2, 3, 4]:
            raise ValueError(""location must be in [1, 2, 3, 4]"")

        # Make list of strings
        datapoints = [str(x) for x in datapoints]
        data = "", "".join(datapoints)

        # Write the data points to the Keithley 6221
        self.write("":SOUR:WAVE:ARB:DATA %s"" % data)

        # Copy the written data to the specified location
        self.write("":SOUR:WAVE:ARB:COPY %d"" % location)

        # Select the newly made arbitrary waveform as waveform function
        self.waveform_function = ""arbitrary%d"" % location

    def __init__(self, adapter, name=""Keithley 6221 SourceMeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def enable_source(self):
        """""" Enables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT ON"")

    def disable_source(self):
        """""" Disables the source of current or voltage depending on the
        configuration of the instrument. """"""
        self.write(""OUTPUT OFF"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")

    def triad(self, base_frequency, duration):
        """""" Sounds a musical triad using the system beep.

        :param base_frequency: A frequency in Hz between 65 Hz and 1.3 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.beep(base_frequency, duration)
        time.sleep(duration)
        self.beep(base_frequency * 5.0 / 4.0, duration)
        time.sleep(duration)
        self.beep(base_frequency * 6.0 / 4.0, duration)

    display_enabled = Instrument.control(
        "":DISP:ENAB?"", "":DISP:ENAB %d"",
        """""" A boolean property that controls whether or not the display of the
        sourcemeter is enabled. Valid values are True and False. """""",
        values={True: 1, False: 0},
        map_values=True,
    )

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.values("":system:error?"")
        if len(err) < 2:
            err = self.read()  # Try reading again
        code = err[0]
        message = err[1].replace('""', '')
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 6221 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 6221 error retrieval."")

    def reset(self):
        """""" Resets the instrument and clears the queue.  """"""
        self.write(""status:queue:clear;*RST;:stat:pres;:*CLS;"")

    def trigger(self):
        """""" Executes a bus trigger, which can be used when
        :meth:`~.trigger_on_bus` is configured.
        """"""
        return self.write(""*TRG"")

    def trigger_immediately(self):
        """""" Configures measurements to be taken with the internal
        trigger at the maximum sampling rate.
        """"""
        self.write("":ARM:SOUR IMM;:TRIG:SOUR IMM;"")

    def trigger_on_bus(self):
        """""" Configures the trigger to detect events based on the bus
        trigger, which can be activated by :meth:`~.trigger`.
        """"""
        self.write("":ARM:SOUR BUS;:TRIG:SOUR BUS;"")

    def set_timed_arm(self, interval):
        """""" Sets up the measurement to be taken with the internal
        trigger at a variable sampling rate defined by the interval
        in seconds between sampling points
        """"""
        if interval > 99999.99 or interval < 0.001:
            raise RangeException(""Keithley 6221 can only be time""
                                 "" triggered between 1 mS and 1 Ms"")
        self.write("":ARM:SOUR TIM;:ARM:TIM %.3f"" % interval)

    def trigger_on_external(self, line=1):
        """""" Configures the measurement trigger to be taken from a
        specific line of an external trigger

        :param line: A trigger line from 1 to 4
        """"""
        cmd = "":ARM:SOUR TLIN;:TRIG:SOUR TLIN;""
        cmd += "":ARM:ILIN %d;:TRIG:ILIN %d;"" % (line, line)
        self.write(cmd)

    def output_trigger_on_external(self, line=1, after='DEL'):
        """""" Configures the output trigger on the specified trigger link
        line number, with the option of supplying the part of the
        measurement after which the trigger should be generated
        (default to delay, which is right before the measurement)

        :param line: A trigger line from 1 to 4
        :param after: An event string that determines when to trigger
        """"""
        self.write("":TRIG:OUTP %s;:TRIG:OLIN %d;"" % (after, line))

    def disable_output_trigger(self):
        """""" Disables the output trigger for the Trigger layer
        """"""
        self.write("":TRIG:OUTP NONE"")

    def shutdown(self):
        """""" Disables the output. """"""
        log.info(""Shutting down %s."" % self.name)
        self.disable_source()
        super().shutdown()

    ###############
    # Status bits #
    ###############

    measurement_event_enabled = Instrument.control(
        "":STAT:MEAS:ENAB?"", "":STAT:MEAS:ENAB %d"",
        """""" An integer value that controls which measurement events are
        registered in the Measurement Summary Bit (MSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    operation_event_enabled = Instrument.control(
        "":STAT:OPER:ENAB?"", "":STAT:OPER:ENAB %d"",
        """""" An integer value that controls which operation events are
        registered in the Operation Summary Bit (OSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    questionable_event_enabled = Instrument.control(
        "":STAT:QUES:ENAB?"", "":STAT:QUES:ENAB %d"",
        """""" An integer value that controls which questionable events are
        registered in the Questionable Summary Bit (QSB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    standard_event_enabled = Instrument.control(
        ""ESE?"", ""ESE %d"",
        """""" An integer value that controls which standard events are
        registered in the Event Summary Bit (ESB) status bit. Refer to
        the Model 6220/6221 Reference Manual for more information about
        programming the status bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 65535],
    )

    srq_event_enabled = Instrument.control(
        ""*SRE?"", ""*SRE %d"",
        """""" An integer value that controls which event registers trigger the
        Service Request (SRQ) status bit. Refer to the Model 6220/6221
        Reference Manual for more information about programming the status
        bits.
        """""",
        cast=int,
        validator=truncated_range,
        values=[0, 255],
    )

    measurement_events = Instrument.measurement(
        "":STAT:MEAS?"",
        """""" An integer value that reads which measurement events have been
        registered in the Measurement event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    operation_events = Instrument.measurement(
        "":STAT:OPER?"",
        """""" An integer value that reads which operation events have been
        registered in the Operation event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    questionable_events = Instrument.measurement(
        "":STAT:QUES?"",
        """""" An integer value that reads which questionable events have been
        registered in the Questionable event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )

    standard_events = Instrument.measurement(
        ""*ESR?"",
        """""" An integer value that reads which standard events have been
        registered in the Standard event registers. Refer to the Model
        6220/6221 Reference Manual for more information about programming
        the status bits. Reading this value clears the register.
        """""",
        cast=int,
    )
"
380,110.6,"Cleveland, Ohio, United States","Series 2600A System SourceMeter instruments are Keithley’s latest I-V source measurement unit
(SMU) instruments for use as either bench-top I-V characterization tools or as building block components of multi-channel I-V test systems. For bench-top use, Series 2600A instruments feature an
embedded TSP Express Software Tool that allows users to quickly and easily perform common I-V
tests without programming or installing software. For system level applications, the Series 2600A’s
Test Script Processor (TSP) architecture, along with other new capabilities such as parallel test execution and precision timing, provides the highest throughput in the industry, lowering the cost of test.
To simplify the testing, verification, and analysis of semiconductor components, the optional ACS
Basic Edition software is also available.",Keithley 2600,216.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a Keithley 2600 ,,,,Keithley 2600,,,,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2600.py,,,,,,"# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
import time
import numpy as np
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, strict_discrete_set

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2600(Instrument):
    """"""Represents the Keithley 2600 series (channel A and B) SourceMeter""""""

    def __init__(self, adapter, name=""Keithley 2600 SourceMeter"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
        self.ChA = Channel(self, 'a')
        self.ChB = Channel(self, 'b')

    @property
    def error(self):
        """""" Returns a tuple of an error code and message from a
        single error. """"""
        err = self.ask('print(errorqueue.next())')
        err = err.split('\t')
        # Keithley Instruments Inc. sometimes on startup
        # if tab delimitated message is greater than one, grab first two as code, message
        # otherwise, assign code & message to returned error
        if len(err) > 1:
            err = (int(float(err[0])), err[1])
            code = err[0]
            message = err[1].replace('""', '')
        else:
            code = message = err[0]
        log.info(f""ERROR {str(code)},{str(message)} - len {str(len(err))}"")
        return (code, message)

    def check_errors(self):
        """""" Logs any system errors reported by the instrument.
        """"""
        code, message = self.error
        while code != 0:
            t = time.time()
            log.info(""Keithley 2600 reported error: %d, %s"" % (code, message))
            code, message = self.error
            if (time.time() - t) > 10:
                log.warning(""Timed out for Keithley 2600 error retrieval."")


class Channel:

    def __init__(self, instrument, channel):
        self.instrument = instrument
        self.channel = channel

    def ask(self, cmd):
        return float(self.instrument.ask(f'print(smu{self.channel}.{cmd})'))

    def write(self, cmd):
        self.instrument.write(f'smu{self.channel}.{cmd}')

    def values(self, cmd, **kwargs):
        """""" Reads a set of values from the instrument through the adapter,
        passing on any key-word arguments.
        """"""
        return self.instrument.values(f'print(smu{self.channel}.{cmd})')

    def binary_values(self, cmd, header_bytes=0, dtype=np.float32):
        return self.instrument.binary_values('print(smu%s.%s)' %
                                             (self.channel, cmd,), header_bytes, dtype)

    def check_errors(self):
        return self.instrument.check_errors()

    source_output = Instrument.control(
        'source.output', 'source.output=%d',
        """"""Property controlling the channel output state (ON of OFF)
        """""",
        validator=strict_discrete_set,
        values={'OFF': 0, 'ON': 1},
        map_values=True
    )

    source_mode = Instrument.control(
        'source.func', 'source.func=%d',
        """"""Property controlling the channel soource function (Voltage or Current)
        """""",
        validator=strict_discrete_set,
        values={'voltage': 1, 'current': 0},
        map_values=True
    )

    measure_nplc = Instrument.control(
        'measure.nplc', 'measure.nplc=%f',
        """""" Property controlling the nplc value """""",
        validator=truncated_range,
        values=[0.001, 25],
        map_values=True
    )

    ###############
    # Current (A) #
    ###############
    current = Instrument.measurement(
        'measure.i()',
        """""" Reads the current in Amps """"""
    )

    source_current = Instrument.control(
        'source.leveli', 'source.leveli=%f',
        """""" Property controlling the applied source current """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    compliance_current = Instrument.control(
        'source.limiti', 'source.limiti=%f',
        """""" Property controlling the source compliance current """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    source_current_range = Instrument.control(
        'source.rangei', 'source.rangei=%f',
        """"""Property controlling the source current range """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    current_range = Instrument.control(
        'measure.rangei', 'measure.rangei=%f',
        """"""Property controlling the measurement current range """""",
        validator=truncated_range,
        values=[-1.5, 1.5]
    )

    ###############
    # Voltage (V) #
    ###############
    voltage = Instrument.measurement(
        'measure.v()',
        """""" Reads the voltage in Volts """"""
    )

    source_voltage = Instrument.control(
        'source.levelv', 'source.levelv=%f',
        """""" Property controlling the applied source voltage """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    compliance_voltage = Instrument.control(
        'source.limitv', 'source.limitv=%f',
        """""" Property controlling the source compliance voltage """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    source_voltage_range = Instrument.control(
        'source.rangev', 'source.rangev=%f',
        """"""Property controlling the source current range """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    voltage_range = Instrument.control(
        'measure.rangev', 'measure.rangev=%f',
        """"""Property controlling the measurement voltage range """""",
        validator=truncated_range,
        values=[-200, 200]
    )

    ####################
    # Resistance (Ohm) #
    ####################
    resistance = Instrument.measurement(
        'measure.r()',
        """""" Reads the resistance in Ohms """"""
    )

    wires_mode = Instrument.control(
        'sense', 'sense=%d',
        """"""Property controlling the resistance measurement mode: 4 wires or 2 wires"""""",
        validator=strict_discrete_set,
        values={'4': 1, '2': 0},
        map_values=True
    )

    #######################
    # Measurement Methods #
    #######################

    def measure_voltage(self, nplc=1, voltage=21.0, auto_range=True):
        """""" Configures the measurement of voltage.
        :param nplc: Number of power line cycles (NPLC) from 0.001 to 25
        :param voltage: Upper limit of voltage in Volts, from -200 V to 200 V
        :param auto_range: Enables auto_range if True, else uses the set voltage
        """"""
        log.info(""%s is measuring voltage."" % self.channel)
        self.write('measure.v()')
        self.write('measure.nplc=%f' % nplc)
        if auto_range:
            self.write('measure.autorangev=1')
        else:
            self.voltage_range = voltage
        self.check_errors()

    def measure_current(self, nplc=1, current=1.05e-4, auto_range=True):
        """""" Configures the measurement of current.
        :param nplc: Number of power line cycles (NPLC) from 0.001 to 25
        :param current: Upper limit of current in Amps, from -1.5 A to 1.5 A
        :param auto_range: Enables auto_range if True, else uses the set current
        """"""
        log.info(""%s is measuring current."" % self.channel)
        self.write('measure.i()')
        self.write('measure.nplc=%f' % nplc)
        if auto_range:
            self.write('measure.autorangei=1')
        else:
            self.current_range = current
        self.check_errors()

    def auto_range_source(self):
        """""" Configures the source to use an automatic range.
        """"""
        if self.source_mode == 'current':
            self.write('source.autorangei=1')
        else:
            self.write('source.autorangev=1')

    def apply_current(self, current_range=None, compliance_voltage=0.1):
        """""" Configures the instrument to apply a source current, and
        uses an auto range unless a current range is specified.
        The compliance voltage is also set.
        :param compliance_voltage: A float in the correct range for a
                                   :attr:`~.Keithley2600.compliance_voltage`
        :param current_range: A :attr:`~.Keithley2600.current_range` value or None
        """"""
        log.info(""%s is sourcing current."" % self.channel)
        self.source_mode = 'current'
        if current_range is None:
            self.auto_range_source()
        else:
            self.source_current_range = current_range
        self.compliance_voltage = compliance_voltage
        self.check_errors()

    def apply_voltage(self, voltage_range=None,
                      compliance_current=0.1):
        """""" Configures the instrument to apply a source voltage, and
        uses an auto range unless a voltage range is specified.
        The compliance current is also set.
        :param compliance_current: A float in the correct range for a
                                   :attr:`~.Keithley2600.compliance_current`
        :param voltage_range: A :attr:`~.Keithley2600.voltage_range` value or None
        """"""
        log.info(""%s is sourcing voltage."" % self.channel)
        self.source_mode = 'voltage'
        if voltage_range is None:
            self.auto_range_source()
        else:
            self.source_voltage_range = voltage_range
        self.compliance_current = compliance_current
        self.check_errors()

    def ramp_to_voltage(self, target_voltage, steps=30, pause=0.1):
        """""" Ramps to a target voltage from the set voltage value over
        a certain number of linear steps, each separated by a pause duration.
        :param target_voltage: A voltage in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps """"""
        voltages = np.linspace(self.source_voltage, target_voltage, steps)
        for voltage in voltages:
            self.source_voltage = voltage
            time.sleep(pause)

    def ramp_to_current(self, target_current, steps=30, pause=0.1):
        """""" Ramps to a target current from the set current value over
        a certain number of linear steps, each separated by a pause duration.
        :param target_current: A current in Amps
        :param steps: An integer number of steps
        :param pause: A pause duration in seconds to wait between steps """"""
        currents = np.linspace(self.source_current, target_current, steps)
        for current in currents:
            self.source_current = current
            time.sleep(pause)

    def shutdown(self):
        """""" Ensures that the current or voltage is turned to zero
        and disables the output. """"""
        log.info(""Shutting down channel %s."" % self.channel)
        if self.source_mode == 'current':
            self.ramp_to_current(0.0)
        else:
            self.ramp_to_voltage(0.0)
        self.source_output = 'OFF'
"
394,700.0,US,"Deep-Well Compact Bath, –45 °C to 150 °C",Fluke 7341,129.0,"**Fluke** Corporation is the world leader in professional electronic test tools and software for measuring and condition monitoring.

",Pymeasure,Fluke,"[OrderedDict([('id', 'attC77II6inAac4Sm'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9WWA4UjSWVTpWMMEjsR6vg/jZSq-z9vRcV08YGF397tLMPsv24Hsen54jg7YwdvLY5S1LdNMCG4UT1e1XEJNJah3ez0r4jV1l-U1xsIg_eukzTq7MzdlAFUlWPPQ_AOUUU_YiFBru8S7xamJhfYx_3a/TvX-lQsa7EdTHBKWrW-VFrSIc_8zwOppO_udCzsvYC0'), ('filename', 'fluke-corporation-logo-vector.png'), ('size', 1735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IjPQZO64bHfSRGAqoYNJuw/dq0yUEkV1WvvB7b3iKkTQO45ujT7f14s4AK_RyMyYa0hpFOyxvUS_bT-tri-LqikcGWQ80Nc4QvpDOEtoNOtDQ/XJxuwIbaOtdhS-z-SuImchIlC16auoQAGZCSJqrc51Q'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jGOrb0UaNe5Q_i4uqiPOlA/4nCn6K7uowMN_VYEoMaTi7XMcRg5ifnly8R1yal5VElzER4qXlDT_1p52mE5PVL6P1WSHgKEVUYdl2uIvvoMmw/reFtSzwDWFTjW7Lo7v1maVc8WKhEBAtbWEnz7911crE'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/H6wJOaHQV_41xbu9wufRlw/RXrDmPfI0Svzem4iwAu49OUaxRppwW7MRoT1tZUsw2p44WW9JuoDWaLqT8WF5a0xGIXKy93iqhSpi7HrtQDJmw/K76LWM7xD0Hk99xPqI_Qcq3lCGE6Y3ZpsHx4SWp8UrA'), ('width', 3000), ('height', 3000)]))]))])]",https://us.flukecal.com/,Write a Python script that uses Pymeasure to connect to a Fluke 7341 Temperature Controllers,"https://us.flukecal.com/products/temperature-calibration/calibration-baths#:~:text=What%20is%20a%20temperature%20calibration,are%20different%20shapes%20and%20sizes.",['Temperature Controllers'],A temperature calibration bath is a calibrator having a uniform fluid enclosure that can be adjusted to specific temperatures for test points,Fluke 7341,https://download.flukecal.com/pub/literature/7341__Rebrand__ugeng0000.pdf,"[OrderedDict([('id', 'att8EUiD44cBzIsi1'), ('width', 970), ('height', 1459), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eLiJJSlVc7OqfgQu6ULiDQ/PAJn0Yb7jVQluhT14YoF-IcDdAvVlmJuO3faYuLEFZ7ZwhOPwdCoKwWx8H3X0WaxjuPIan3O0tW3Ef5FVwSK15z1QNFNq0ZKCD6ermR4BGk/0ypum6-pivbhe2z1LwFNNDsNghM6gnPGK2r7Z5XfTWw'), ('filename', 'Fc-6331_04a_c.jpg'), ('size', 62022), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cuxvOTWruFtTrGfm5ZoEew/h-LKJTLWZZ6xh1YozxAGj658N8DmgvW2UyV2ICNIOOLeO2iIpE8z1j-FEs3QU8XvgHfpbEBFUjMxSmI67J60cQ/ud0YlbX9mqpZ3Z9e88GTb6giiSQqPR39eeGc3GDyOhI'), ('width', 24), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/x4FfvvWU0wpKF1F87UdPFg/Nc_PpakcI1KO7xnMbUMWyXf5YdvfiEFYTrwVwV0M4t_2x7wjJo8zsoGQFbuavoc3W8SKigUqrc7y3gkBSI6G0Q/1wXRfH6EfTIxoji5lbDu6iBJTgvC9E_RKo4ohAt0Tvw'), ('width', 512), ('height', 770)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Rgna3vR1TpF7Hl57WOHfxA/F2Ep1f8Tgyr8ikjhJt5Hx1489TyxnOtIBc4DY72RGZm1gLrIlM8NQw8EYS4NB83c413rr7v_Lgo4__P6SIlhHg/UUQIH71VDpTritAm2MRvxMmQnyCoG3EyH3OK8WeYV1M'), ('width', 3000), ('height', 3000)]))]))])]",https://eu.flukecal.com/fr/products/temperature-calibration/calibration-baths/compact-calibration-baths/bains-compacts-%C3%A0-puits-?quicktabs_product_details=3,https://github.com/fordj06/temp-cal-automation,https://pymeasure.readthedocs.io/en/latest/api/instruments/fluke/fluke7341.html,,,,,
397,1.0,US,"The AH 2500A offers unparalleled stability, resolution and accuracy in a capacitance/loss1 bridge (whether manual or automatic)",AH 2500 A,76.0,"**Andeen**-**Hagerling**, Inc. - manufacturers of the world's most accurate capacitance bridges and standards

",Pymeasure,Andeen Hagerling,"[OrderedDict([('id', 'attHkizub4S6653G8'), ('width', 375), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Wdzc-_rA_DV-LMwtpc8Asg/dEUzTAi0zId1jgPJmnMCPMB2ilXzeTbDYYoygb7QIMj9rgi4uXpOPB_cjFm3vxoiYLQqSkJj-HcHmyu4oH9mEf2M9iogdcrZ0ASpymfcF8U/kvgFqI46CuvGga3xt14YhNGZlzsfKh61CGDbU9omD48'), ('filename', 'AH_Logo-375x200.jpg'), ('size', 5603), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7rscRbu7yWIRUSqm7zzudw/9kODe2p0e4X1Y12DFtmzXSnz-M1Mz3EmZGiOFpTRjiCbNOIYSKM-j5bieBkV1Q1Knpr1hEmD7Q1yUWb7uSpb-w/iXWcnXND4EjzeszSS-HK1jJKLMl0UZ27g9oMpJu1JmA'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yNpFJ0EOm3rvmz4jkIOeQg/MfQoShnsfLD1e8bXB0kd8jkkgVDJtFZLc4FXgBlJq0BJWMiwpWVmbjTEAhf2l9XfH6ZXLOSuV0w51-ILC0zmkg/mQnKJKlhMZ1ZWu0aZwTMhg75L8vlY5nAz5OXuqviNgI'), ('width', 375), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-GeOZn3lpmqeDkkrzngVrw/vXLLlqEAcn3qdgW2jFKFAQU4lxkRR37t7wWmn6W3PrSwKK3hB7aq1-BR0ACGDTFhWmBPMofPFEnnIg2h9v9s2g/Y38kglQ0z7GRMP1NET7LewCdTpJFsI7NmTLIrpN2uik'), ('width', 3000), ('height', 3000)]))]))])]",http://www.andeen-hagerling.com/,Write a Python script that uses Pymeasure to connect to a 2500A Bridge Multimeters,https://electricalacademia.com/instrumentation-and-measurements/capacitance-bridge-circuit/,['Multimeters'],A Maxwell Inductance Capacitance Bridge (known as a Maxwell Bridge) is a modified version of a Wheatstone bridge which is used to measure the self-inductance of a circuit.,2500A Bridge,http://manuals.repeater-builder.com/te-files/MISCELLANEOUS/ANDEEN-HAGERLING%202500A%20Operation.pdf,"[OrderedDict([('id', 'attf7SCnvVCz7J0a1'), ('width', 500), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ibg_I6SHEhvOXslnBgGmgQ/F-CztSEUd0lb7XHULfwudS7CEwM8YOEBVl654w8lh_Jylnw9SLhJoe2cPEH9ewE-NAVlKJsgtONSrPKPfHn-r3KgRGxDUIzfezYE6CsBXXg/j24nusa4X7tJOeMUQGtT2pG2emkT3oFeaDdLZ9QTYOQ'), ('filename', 'AH2550A-500x500w.jpg'), ('size', 25126), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AHLKAtaAcFGy8DZmqKetrQ/kLnpihQ-ghBKYteFo70Q1i9Taddp-GV5baxzBCw6taVJBVNcjp8VbPkGbyYZCbqkFDeCEAJYBNCkbFZBp82WFw/gzgMwKWMsjxK6t4qC9jHd15szk0MMh3MWkr_oD-KOC4'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/chJvHYGXfWsYQmUENRFMbw/V74uvDgIErbHWnd9a4vQjGJkWKUgDICeNnIah_4wd4Ghb1u3znwsxTj760IDT18XIqdHC3fM3oLwvaYWIw1NnQ/cqN-DrJ5VPgZUaYAGns41nBUD28fgJ-92S3MQTEBDH8'), ('width', 500), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/akoFvDpxCLDJmuysBUH_FA/cst2uu8NaGaUPXykpDBGIvbYkNjZbXs9TNcWMu6JFPVDY7eUvJXW78Myqd2lu2w5-aXkIm0tRSuPZL53KXjW-w/d1D-3GJSMRQXIvaZpYwqSDA4Z000vXGQpAY_pliM9Qk'), ('width', 3000), ('height', 3000)]))]))])]",http://www.andeen-hagerling.com/ah2500a.htm,https://github.com/lupien/pyHegel/blob/master/pyHegel/instruments/others.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/andeenhagerling/ah2500a.html,,"
",,,"# -*- coding: utf-8 -*-

########################## Copyrights and license ############################
#                                                                            #
# Copyright 2011-2015  Christian Lupien <christian.lupien@usherbrooke.ca>    #
#                                                                            #
# This file is part of pyHegel.  http://github.com/lupien/pyHegel            #
#                                                                            #
# pyHegel is free software: you can redistribute it and/or modify it under   #
# the terms of the GNU Lesser General Public License as published by the     #
# Free Software Foundation, either version 3 of the License, or (at your     #
# option) any later version.                                                 #
#                                                                            #
# pyHegel is distributed in the hope that it will be useful, but WITHOUT     #
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      #
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public        #
# License for more details.                                                  #
#                                                                            #
# You should have received a copy of the GNU Lesser General Public License   #
# along with pyHegel.  If not, see <http://www.gnu.org/licenses/>.           #
#                                                                            #
##############################################################################

from __future__ import absolute_import

import numpy as np
import random
import time
from scipy.optimize import brentq as brentq_rootsolver

from ..instruments_base import BaseInstrument, visaInstrument, visaInstrumentAsync,\
                            BaseDevice, scpiDevice, MemoryDevice, Dict_SubDevice, ReadvalDev,\
                            ChoiceBase, ChoiceMultiple, ChoiceMultipleDep, ChoiceSimpleMap,\
                            ChoiceStrings, ChoiceIndex,\
                            make_choice_list, _fromstr_helper,\
                            decode_float64, visa_wrap, locked_calling,\
                            Lock_Extra, Lock_Instruments, _sleep_signal_context_manager, wait,\
                            release_lock_context, mainStatusLine, quoted_string, Choice_bool_OnOff,\
                            resource_info
from ..types import dict_improved
from ..instruments_registry import register_instrument, register_usb_name, register_idn_alias

from .logical import FunctionDevice, ScalingDevice

# for pfeiffer
import threading
import weakref

# for BIAS-DAC
import struct

# for micro_lambda_wireless
import socket

#######################################################
##    Yokogawa source
#######################################################

register_usb_name('Yokogawa Electric Corporation', 0x0B21)

# To implement hardware sweeping:
#  can use program with interval and slope.
#   interval needs to be >= slope
#  They both are time with resolution of .1 s
#  can have 10000 program steps
#  cannot readback ramping state or program
#  can use pause/cont  or hold/hold to pause and restart
#    pause/cont produce errors
#  the program steps consists of level,range,function
#  can define program like:
#     :prog:memory ""0,1,V\n.5,1,V""
#  When the range changes (between prog steps or between current and first step),
#   the slope is not working.
#  Count is incremented will the program is running. Goes back to 1 at the end
#  Can see level/steps/prog completion with :status:event? bits 5,6,7 (32,64,128)
#      level is set when slope is done, steps when interval is done.
#  the :status:event bit 8 (256) is toggled by changing the program (prog:edit:start, prog:edit:end, or frontpanel)
#   but not by prog:memory
# can't run a program if the output is disabled
# OPC does not work for programs

@register_instrument('YOKOGAWA', 'GS210', usb_vendor_product=[0x0B21, 0x0039])
#@register_instrument('YOKOGAWA', 'GS210', '1.05')
#@register_instrument('YOKOGAWA', 'GS210', '1.02')
class yokogawa_gs200(visaInstrument):
    # TODO: implement multipliers, units. The multiplier
    #      should be the same for all instruments, and be stripped
    #      before writing and going to the cache (in BaseDevice)
    #      This is probably not needed. Just use 1e3
    # case insensitive
    multipliers = ['YO', 'ZE', 'EX', 'PE', 'T', 'G', 'MA', 'K', 'M', 'U', 'N', 'P',
                   'F', 'A', 'Z', 'Y']
    multvals    = [1e24, 1e21, 1e18, 1e15, 1e12, 1e9, 1e6, 1e3, 1e-3, 1e-6, 1e-9, 1e-12,
                   1e-15, 1e-18, 1e-21, 1e-24]
    def init(self, full=False):
        # clear event register, extended event register and error queue
        self.clear()
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('function', 'range', 'level', 'output_en', options)
    def _create_devs(self):
        #self.level_2 = wrapDevice(self.levelsetdev, self.levelgetdev, self.levelcheck)
        self.function = scpiDevice(':source:function', choices=ChoiceStrings('VOLT', 'CURRent')) # use 'voltage' or 'current'
        # voltage or current means to add V or A in the string (possibly with multiplier)
        self.range = scpiDevice(':source:range', str_type=float, setget=True) # can be a voltage, current, MAX, MIN, UP or DOWN
        #self.level = scpiDevice(':source:level') # can be a voltage, current, MAX, MIN
        self.voltlim = scpiDevice(':source:protection:voltage', str_type=float, setget=True) #voltage, MIN or MAX
        self.currentlim = scpiDevice(':source:protection:current', str_type=float, setget=True) #current, MIN or MAX
        self.output_en = scpiDevice('OUTPut', str_type=bool)
        self._devwrap('level', setget=True)
        self.alias = self.level
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def _level_checkdev(self, val):
        rnge = 1.2*self.range.getcache()
        if self.function.getcache()=='CURR' and rnge>.2:
            rnge = .2
        if abs(val) > rnge:
            raise ValueError, self.perror('level is invalid')
    def _level_getdev(self):
        return float(self.ask(':source:level?'))
    def _level_setdev(self, val):
        # used %.6e instead of repr
        # repr sometimes sends 0.010999999999999999
        # which the yokogawa understands as 0.010 instead of 0.011
        self.write(':source:level %.6e'%val)


#######################################################
##    Stanford Research SR830 Lock-in Amplifier
#######################################################

#@register_instrument('Stanford_Research_Systems', 'SR830', 'ver1.07 ')
@register_instrument('Stanford_Research_Systems', 'SR830', alias='SR830 LIA')
class sr830_lia(visaInstrument):
    """"""
    Don't forget to set the async_wait to some usefull values.
     might do set(sr1.async_wait, 1.)
    when using 24dB/oct, 100ms filter.

    You can use find_n_time and find_fraction to set the time.
    For example: set(sr1.async_wait, sr1.find_n_time(.99,sec=True))

    To read more than one channel at a time use readval/fetch(snap)
    Otherwise you can use x, y, t, theta
    """"""
    # TODO setup snapsel to use the names instead of the numbers
    _snap_type = {1:'x', 2:'y', 3:'R', 4:'theta', 5:'Aux_in1', 6:'Aux_in2',
                  7:'Aux_in3', 8:'Aux_in4', 9:'Ref_Freq', 10:'Ch1', 11:'Ch2'}
    def init(self, full=False):
        # This empties the instrument buffers
        self._dev_clear()
    def _check_snapsel(self,sel):
        if not (2 <= len(sel) <= 6):
            raise ValueError, 'snap sel needs at least 2 and no more thant 6 elements'
    def _snap_getdev(self, sel=[1,2], norm=False):
        # sel must be a list
        self._check_snapsel(sel)
        sel = map(str, sel)
        data = decode_float64(self.ask('snap? '+','.join(sel)))
        if norm:
            amp = self.srclvl.get()
            data_norm = data/amp
            data = np.concatenate( (data_norm, data) )
        return data
    def _snap_getformat(self, sel=[1,2], norm=False, **kwarg):
        self._check_snapsel(sel)
        headers = [ self._snap_type[i] for i in sel]
        if norm:
            headers = map(lambda x: x+'_norm', headers) + headers
        d = self.snap._format
        d.update(multi=headers, graph=range(len(sel)))
        return BaseDevice.getformat(self.snap, sel=sel, **kwarg)
    def auto_offset(self, ch='x'):
        """"""
           commands the auto offset for channel ch
           which can be 'x', 'y' or 'r'
        """"""
        choices=ChoiceIndex(['x', 'y', 'r'], offset=1)
        ch_i = choices.tostr(ch)
        self.write('aoff '+ch_i)
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        #base = ['async_delay=%r'%self.async_delay]
        return self._conf_helper('async_delay','async_wait', 'freq', 'sens', 'srclvl', 'harm', 'phase', 'timeconstant', 'filter_slope',
                                 'sync_filter', 'reserve_mode',
                                 'offset_expand_x', 'offset_expand_y', 'offset_expand_r',
                                 'input_conf', 'grounded_conf', 'dc_coupled_conf', 'linefilter_conf',
                                 'auxout1', 'auxout2', 'auxout3', 'auxout4', options)
    def _create_devs(self):
        self.freq = scpiDevice('freq', str_type=float, setget=True, min=0.001, max=102e3)
        sens = ChoiceIndex(make_choice_list([2,5,10], -9, -1), normalize=True)
        self.sens = scpiDevice('sens', choices=sens, doc='Set the sensitivity in V (for currents it is in uA)')
        self.oauxi1 = scpiDevice(getstr='oaux? 1', str_type=float)
        self.auxout1 = scpiDevice('AUXV 1,{val}', 'AUXV? 1', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout2 = scpiDevice('AUXV 2,{val}', 'AUXV? 2', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout3 = scpiDevice('AUXV 3,{val}', 'AUXV? 3', str_type=float, setget=True, min=-10.5, max=10.5)
        self.auxout4 = scpiDevice('AUXV 4,{val}', 'AUXV? 4', str_type=float, setget=True, min=-10.5, max=10.5)
        self.srclvl = scpiDevice('slvl', str_type=float, min=0.004, max=5., setget=True)
        self.harm = scpiDevice('harm', str_type=int, min=1, max=19999)
        self.phase = scpiDevice('phas', str_type=float, min=-360., max=729.90, setget=True)
        timeconstants = ChoiceIndex(make_choice_list([10, 30], -6, 3), normalize=True)
        self.timeconstant = scpiDevice('oflt', choices=timeconstants)
        filter_slopes=ChoiceIndex([6, 12, 18, 24])
        self.filter_slope = scpiDevice('ofsl', choices=filter_slopes, doc='in dB/oct\n')
        self.sync_filter = scpiDevice('sync', str_type=bool)
        self.x = scpiDevice(getstr='outp? 1', str_type=float, trig=True)
        self.y = scpiDevice(getstr='outp? 2', str_type=float, trig=True)
        self.r = scpiDevice(getstr='outp? 3', str_type=float, trig=True)
        off_exp = ChoiceMultiple(['offset_pct', 'expand_factor'], [float, ChoiceIndex([1, 10 ,100])])
        self.offset_expand_x = scpiDevice('oexp 1,{val}', 'oexp? 1', choices=off_exp, setget=True)
        self.offset_expand_y = scpiDevice('oexp 2,{val}', 'oexp? 2', choices=off_exp, setget=True)
        self.offset_expand_r = scpiDevice('oexp 3,{val}', 'oexp? 3', choices=off_exp, setget=True)
        self.theta = scpiDevice(getstr='outp? 4', str_type=float, trig=True)
        input_conf = ChoiceIndex(['A', 'A-B', 'I1', 'I100'])
        self.input_conf = scpiDevice('isrc', choices=input_conf, doc='For currents I1 refers to 1 MOhm, I100 refers to 100 MOhm\n')
        self.grounded_conf = scpiDevice('ignd', str_type=bool)
        self.dc_coupled_conf = scpiDevice('icpl', str_type=bool)
        reserve_mode = ChoiceIndex(['high', 'normal', 'low'])
        self.reserve_mode = scpiDevice('rmod', choices=reserve_mode)
        linefilter = ChoiceIndex(['none', 'line', '2xline', 'both'])
        self.linefilter_conf = scpiDevice('ilin', choices=linefilter, doc='Selects the notch filters')
        # status: b0=Input/Reserver ovld, b1=Filter ovld, b2=output ovld, b3=unlock,
        # b4=range change (accross 200 HZ, hysteresis), b5=indirect time constant change
        # b6=triggered, b7=unused
        self.status_byte = scpiDevice(getstr='LIAS?', str_type=int)
        self._devwrap('snap', trig=True, doc=""""""
            This device can be called snap or fetch (they are both the same)
            This device obtains simultaneous readings from many inputs.
            To select the inputs, use the parameter
             sel
            which is [1,2] by default.
            The numbers are taken from the following dictionnary:
                %r
            The option norm when True return the data divided by the srclvl (and followed by raw data)
                """"""%self._snap_type)
        self.fetch = self.snap
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):   unused
          bit 1 (2):   Backup error
          bit 2 (4):   RAM error
          bit 3 (8):   Unused
          bit 4 (16):  Rom error
          bit 5 (32):  GPIB error
          bit 6 (64):  DSP error
          bit 7 (128): Math Error
        """"""
        return int(self.ask('ERRS?'))
    def find_fraction(self, n_time_constant, n_filter=None, time_constant=None, sec=False):
        """"""
        Calculates the fraction of a step function that is obtained after
        n_time_constant*time_constant time when using n_filter
        n_filter is the order of the filter: 1, 2, 3 ...
        By default time_constant and n_filter are the current ones
        When sec is True the input time is in sec, not in time_constants
        """"""
        if n_filter is None:
            n_filter = self.filter_slope.getcache()
            n_filter = self.filter_slope.choices.index(n_filter)+1
        if time_constant is None:
            time_constant = self.timeconstant.getcache()
        if sec:
            n_time_constant /= time_constant
        t = n_time_constant
        et = np.exp(-t)
        if n_filter == 1:
            return 1.-et
        elif n_filter == 2:
            return 1.-et*(1.+t)
#        elif n_filter == 3:
#            return 1.-et*(1.+t+0.5*t**2)
#        elif n_filter == 4:
#            return 1.-et*(1.+t+0.5*t**2+t**3/6.)
        else:
            # general formula: 1-exp(-t)*( 1+t +t**/2 + ... t**(n-1)/(n-1)!) )
            m = 1.
            tt = 1.
            for i in range(1, n_filter):
                tt *= t/i
                m += tt
            return 1.-et*m
    def find_n_time(self, frac=.99, n_filter=None, time_constant=None, sec=False):
        """"""
        Does the inverse of find_fraction.
        Here, given a fraction, we find the number of time_constants needed to wait.
        When sec is true, it returs the time in sec not in number of time_constants.
        """"""
        if n_filter is None:
            n_filter = self.filter_slope.getcache()
            n_filter = self.filter_slope.choices.index(n_filter)+1
        if time_constant is None:
            time_constant = self.timeconstant.getcache()
        func = lambda x: self.find_fraction(x, n_filter, time_constant)-frac
        n_time = brentq_rootsolver(func, 0, 100)
        if sec:
            return n_time*time_constant
        else:
            return n_time


#######################################################
##    Stanford Research SR384 RF source
#######################################################

#@register_instrument('Stanford Research Systems', 'SG384', 'ver1.02.0E')
@register_instrument('Stanford Research Systems', 'SG384', alias='SG384 RF source')
class sr384_rf(visaInstrument):
    # This instruments needs to be on local state or to pass through local state
    #  after a local_lockout to actually turn off the local key.
    # allowed units: amp: dBm, rms, Vpp; freq: GHz, MHz, kHz, Hz; Time: ns, us, ms, s
    def init(self, full=False):
        # This clears the error state
        self.clear()
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('freq', 'en_lf', 'amp_lf_dbm', 'offset_low',
                                 'en_rf', 'amp_rf_dbm', 'en_hf', 'amp_hf_dbm',
                                 'phase', 'mod_en', options)
    def _create_devs(self):
        self.freq = scpiDevice('freq',str_type=float, min=1e-6, max=8.1e9)
        self.offset_low = scpiDevice('ofsl',str_type=float, min=-1.5, max=+1.5) #volts
        self.amp_lf_dbm = scpiDevice('ampl',str_type=float, min=-47, max=14.96) # all channel output power calibrated to +13 dBm only, manual says 15.5 for low but intruments stops at 14.96
        self.amp_rf_dbm = scpiDevice('ampr',str_type=float, min=-110, max=16.53)
        self.amp_hf_dbm = scpiDevice('amph',str_type=float, min=-10, max=16.53) # doubler
        self.en_lf = scpiDevice('enbl', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.en_rf = scpiDevice('enbr', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.en_hf = scpiDevice('enbh', str_type=bool) # 0 is off, 1 is on, read value depends on freq
        self.phase = scpiDevice('phas',str_type=float, min=-360, max=360) # deg, only change by 360
        self.mod_en = scpiDevice('modl', str_type=bool) # 0 is off, 1 is on
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        """"""
         Pops last error
          ## Execution Errors
          0: No error
         10: Illegal value
         11: Illegal Mode
         12: Not allowed
         13: Recall Failed
         14: No clock option
         15: No RF doubler option
         16: No IQ option
         17: Failed self test
          ## Query Errors
         30: Lost data
         32: No listener
          ## Device dependent errors
         40: Failed ROM check
         42: Failed EEPROM check
         43: Failed FPGA check
         44: Failed SRAM check
         45: Failed GPIB check
         46: Failed LF DDS check
         47: Failed RF DDS check
         48: Failed 20 MHz PLL
         49: Failed 100 MHz PLL
         50: Failed 19 MHz PLL
         51: Failed 1 GHz PLL
         52: Failed 4 GHz PLL
         53: Failed DAC
          ## Parsing errors
        110: Illegal command
        111: Undefined command
        112: Illegal query
        113: Illegal set
        114: Null parameter
        115: Extra parameters
        116: Missing parameters
        117: Parameter overflow
        118: Invalid floating point number
        120: Invalid Integer
        121: Integer overflow
        122: Invalid Hexadecimal
        126: Syntax error
        127: Illegal units
        128: Missing units
          ## Communication errors
        170: Communication error
        171: Over run
          ## Other errors
        254: Too many errors
        """"""
        return int(self.ask('LERR?'))


#######################################################
##    Stanford Research SR780 2 channel network analyzer
#######################################################

#@register_instrument('Stanford_Research_Systems', 'SR780', 'ver116')
@register_instrument('Stanford_Research_Systems', 'SR780', alias='SR780 network analyser')
class sr780_analyzer(visaInstrumentAsync):
    """"""
    This controls a 2 channel network analyzer
    It currently only handles the FFT measurement group (not octave or swept sine).
    Markers are not handled. Only sine sources are handled.
    Useful devices:
        fetch, readval
        dump
        current_display
        current_channel
        freq_start, freq_stop, freq_center, freq_span
        window_type
        average_en
        average_type
        average_mode
        average_count_requested
        async_wait (needed for exponential average, not for linear)
    Useful methods:
        start
        get_xscale

    Changing a setup should be done in the following order
        meas_grp
        meas
        meas_view
        unit
    """"""
    def __init__(self, *args, **kwargs):
        super(sr780_analyzer, self).__init__(*args, **kwargs)
        # The parant __init__ overrides our selection of 'wait' mode
        # in _async_detect_setup(reset=True) in init. So lets set it back
        self._async_mode = 'wait'
    def init(self, full=False):
        # This empties the instrument buffers
        self._dev_clear()
        # This clears the error state, and status/event flags
        self.clear()
        if full:
            self._async_sre_flag = 2
            self.write('DSPE 0;*sre 2') # Display flags
            self._async_detect_setup(reset=True)
            #self._async_tocheck = 0
            #self._async_use_delay = False
            self.visa.write_termination = '\n'
            #self.visa.term_chars='\n'
            # The above turned on detection of termchar on read. This is not good for
            # raw reads so turn it off.
            # visa.vpp43.set_attribute(self.visa.vi, visa.VI_ATTR_TERMCHAR_EN, visa.VI_FALSE)
            self.write('OUTX 0') # Force interface to be on GPIB, in case it is not anymore (problem with dump function)
    def _async_select(self, devs=[]):
        # This is called during init of async mode.
        self._async_detect_setup(reset=True)
        for dev, kwarg in devs:
            if dev in [self.fetch, self.readval]:
                disp = kwarg.get('disp', None)
                self._async_detect_setup(disp=disp)
    def _async_detect_setup(self, disp=None, reset=False):
        if reset:
            # make the default async_mode is 'wait' so that if
            # _async_tocheck == 0, we just turn on wait.
            # This could happen when using run_and_wait before anything is set
            # Otherwise, getasync and readval both call async_select to setup
            # the mode properly (_async_mode and_async_tocheck).
            self._async_tocheck = 0
            self._async_mode = 'wait'
            return
        self._async_mode = 'srq'
        disp_org = self.current_display.getcache()
        if disp is None:
            disp = disp_org
        self.current_display.set(disp)
        # 0x2=A-linear avg, 0x4=A-settled, 0x200=B-linear, 0x400=B-settled
        if self.average_en.get(disp=disp):
            if self.average_type.get() in ['linear', 'FixedLength']:
                tocheck = 0x2
            else:
                self._async_mode = 'wait+srq'
                tocheck = 0x4
        else:
            tocheck = 0x4
        if disp == 'B':
            tocheck <<= 8
        self._async_tocheck |= tocheck
        self.current_display.set(disp_org)
    def _async_trigger_helper(self):
        # We are setup so that run_and_wait resuses the last config which starts
        # with a simple wait (could be invalid now if averaging is changed on the instrument).
        # Should not be a big deal since that is not a normal use of it.
        self._cum_display_status = 0
        self.write('PAUS') # make sure we are not scanning anymore.
        self.get_display_status() # reset the display status flags
        self.write('DSPE %i'%self._async_tocheck)
        self.write('STRT')
    def _get_esr(self):
        # This disables the get_esr in the async routines.
        return 0
    @locked_calling
    def start(self):
        """"""
        Same as pressing Start/Reset button.
        """"""
        self._async_trigger_helper()
    def _async_detect(self, max_time=.5): # 0.5 s max by default
        ret = super(sr780_analyzer, self)._async_detect(max_time)
        if self._async_mode == 'wait':
            # pure wait
            return ret
        if not ret:
            # Did not receive SRQ or wait long enough
            return False
        # Received SRQ, check if we are done
        disp_st = self.get_display_status()
        self._cum_display_status |= disp_st
        tocheck = self._async_tocheck
        #print 'tocheck %0x %0x %0x'%(tocheck, self._cum_display_status, disp_st)
        if self._cum_display_status&tocheck == tocheck:
            self.write('DSPE 0')
            self._cum_display_status = 0
            return True # We are done!
        return False
    def _fetch_getformat(self, **kwarg):
        xaxis = kwarg.get('xaxis', True)
        if xaxis:
            multi = ('freq', 'data')
        else:
            multi = True
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=[], xaxis=xaxis)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, disp=None, xaxis=True):
        """"""
        Optional parameter: disp and xaxis
         -disp:  To select which display to read.
         -xaxis: when True(default), the first column of data is the xaxis
        For faster transfer, make the view and unit the same type (both linear or both log)
        It is STRONGLY recommended to use linear averaging.
        For exponential averaging you need to specify a wait time with async_wait
         i.e. set(srnet.async_wait,3)  # for 3 seconds
        """"""
        # The instrument has 5 Traces that can be used for memory.
        # There is REFY? d,j to obtain pint j (0..length-1) in ref curve of display d
        #  DSPN? d to obtain lenght of data set
        if disp is not None:
            self.current_display.set(disp)
        disp = self.current_display.getcache()
        disp = self.current_display._tostr(disp)
        # DSPY returns ascii but is slower than DSPB (binary)
        # TODO implement handling of nyquist and nichols plot which return 2 values per datapoint.
        # TODO handle waterfalls: dswb
        data = self.ask('DSPB? %s'%disp, raw=True)
        ret = np.fromstring(data, np.float32)
        if xaxis:
            ret = ret = np.asarray([self.get_xscale(), ret])
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if options.has_key('disp'):
            self.current_display.set(options['disp'])
        want_ch = 1
        meas = self.meas.getcache()
        # This does not handle Coherence, CrossSpectrum F2/F1 ...
        if meas[-1] == '2' and meas[-4:-1] != 'ser':
            want_ch = 2
        orig_ch = self.current_channel.getcache()
        if want_ch != orig_ch:
            self.current_channel.set(want_ch)
        conf = self._conf_helper('current_display', 'current_channel',
                                 'input_source', 'input_mode', 'input_grounding', 'input_coupling',
                                 'input_range_dBV', 'input_autorange_en', 'input_autorange_mode', 'input_antialiasing_en',
                                 'input_aweight_en', 'input_auto_offset_en', 'input_eng_unit_en', 'input_eng_label',
                                 'input_eng_unit_scale', 'input_eng_unit_user',
                                 'freq_start', 'freq_stop', 'freq_resolution', 'freq_baseline', 'window_type',
                                 'meas_group', 'meas', 'meas_view',
                                 'meas_unit', 'dBm_ref', 'disp_PSD_en', 'disp_transducer_unit_mode',
                                 'disp_live_en',
                                 'average_en', 'average_mode', 'average_type', 'average_count_requested',
                                 'average_increment_pct', 'average_overload_reject_en', 'average_preview_type',
                                 'source_en', 'source_type', 'source_freq1', 'source_ampl1_V',
                                 'source_offset_V', 'source_freq2', 'source_ampl2_V', 'async_wait',
                                 options)
        if want_ch != orig_ch:
            self.current_channel.set(orig_ch)
        return conf
    def _create_devs(self):
        display_sel = ChoiceIndex(['A', 'B']) # also both=2
        self.current_display = MemoryDevice('A', choices=display_sel)
        self.current_channel = MemoryDevice(1, choices=[1, 2])
        self.freq_baseline = scpiDevice('FBAS 2,{val}', 'FBAS? 0', choices=ChoiceIndex([100e3, 102.4e3]))
        self.dBm_ref = scpiDevice('DBMR 2,{val}', 'DBMR? 2', str_type=float, min=0)
        self.source_en = scpiDevice('SRCO', str_type=bool)
        self.source_type = scpiDevice('STYP', choices=ChoiceIndex(['Sine', 'Chirp', 'Noise', 'Arbitrary']))
        self.source_freq1 = scpiDevice('S1FR', str_type=float)
        self.source_ampl1_V = scpiDevice('S1AM', str_type=float)
        self.source_offset_V = scpiDevice('SOFF', str_type=float)
        self.source_freq2 = scpiDevice('S2FR', str_type=float)
        self.source_ampl2_V = scpiDevice('S2AM', str_type=float)
        self.input_source = scpiDevice('ISRC', choices=ChoiceIndex(['Analog', 'Capture']))
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.input_mode = devChOption('I{ch}MD', choices=ChoiceIndex(['Analog', 'Capture']))
        self.input_grounding = devChOption('I{ch}GD', choices=ChoiceIndex(['Float', 'Ground']))
        self.input_coupling = devChOption('I{ch}CP', choices=ChoiceIndex(['DC', 'AC', 'ICP']))
        self.input_range_dBV = devChOption('I{ch}RG', str_type=int, choices=range(-50, 36, 2))
        self.input_autorange_en = devChOption('A{ch}RG', str_type=bool)
        self.input_autorange_mode = devChOption('I{ch}AR', choices=ChoiceIndex(['Normal', 'Tracking']))
        self.input_antialiasing_en = devChOption('I{ch}AF', str_type=bool)
        self.input_aweight_en = devChOption('I{ch}AW', str_type=bool)
        self.input_auto_offset_en = scpiDevice('IAOM', str_type=bool)
        self.input_eng_unit_en = devChOption('EU{ch}M', str_type=bool)
        self.input_eng_label = devChOption('EU{ch}L', str_type=ChoiceIndex(['m/s2', 'm/s', 'm', 'in/s2', 'in/s', 'in', 'mil', 'g', 'kg', 'lbs', 'N', 'dyne', 'Pas', 'bar', 'USER']))
        self.input_eng_unit_scale = devChOption('EU{ch}V', str_type=float, doc='number of eng.unit/Volt')
        self.input_eng_unit_user = devChOption('EU{ch}U', str_type=str)
        def devDispOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(disp=self.current_display)
            app = kwarg.pop('options_apply', ['disp'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.freq_span = devDispOption('FSPN {disp},{val}', 'FSPN? {disp}', str_type=float, setget=True)
        self.freq_start = devDispOption('FSTR {disp},{val}', 'FSTR? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        self.freq_stop = devDispOption('FEND {disp},{val}', 'FEND? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        self.freq_center = devDispOption('FCTR {disp},{val}', 'FCTR? {disp}', str_type=float, setget=True, min=0, max=102.4e3)
        resol_sel = ChoiceIndex([100, 200, 400, 800])
        self.freq_resolution = devDispOption('FLIN {disp},{val}', 'FLIN? {disp}', choices=resol_sel)
        mgrp_sel = ChoiceIndex(['FFT', 'Octave', 'Swept Sine'])
        self.meas_group = devDispOption('MGRP {disp},{val}', 'MGRP? {disp}', choices=mgrp_sel)
        meas_sel = ChoiceIndex(['FFT1', 'FFT2', 'Time1', 'Time2', 'WindowedTime1', 'WindowedTime2',
                                'Orbit', 'Coherence', 'CrossSpectrum', '<F2/F1>', '<F2>/<F1>',
                                'AutoCorr1', 'AutoCorr2', 'CaptureBuffer1', 'CaptureBuffer2',
                                'FFTuser1', 'FFTuser2', 'FFTuser3', 'FFTuser4', 'FFTuser5',
                                'Octave1', 'Octave2', 'OctaveCapBuff1', 'OctaveCapBuff2',
                                'OctaveUser1', 'OctaveUser2', 'OctaveUser3', 'OctaveUser4', 'OctaveUser5',
                                'SweptSpectrum1', 'SweptSpectrum2', 'SweptCross', 'SweptTransferFunction',
                                'SweptUser1', 'SweptUser2', 'SweptUser3', 'SweptUser4', 'SweptUser5'])
        self.meas = devDispOption('MEAS {disp},{val}', 'MEAS? {disp}', choices=meas_sel)
        view_sel = ChoiceIndex(['LogMag', 'LinMag', 'MagSquared', 'Real', 'Imag', 'Phase', 'UnWrapPhase', 'Nyquist', 'Nichols'])
        self.meas_view = devDispOption('VIEW {disp},{val}', 'VIEW? {disp}', choices=view_sel)
        unit_sel = ChoiceIndex(['Vpk', 'Vrms', 'Vpk2', 'Vrms2', 'dBVpk', 'dBVrms', 'dBm', 'dBspl', 'deg', 'rad', 'Units', 'dB'])
        self.meas_unit = devDispOption('UNIT {disp},{val}', 'UNIT? {disp}', choices=unit_sel)
        self.disp_live_en = devDispOption('DISP {disp},{val}', 'DISP? {disp}', str_type=bool)
        self.disp_log_xscale = devDispOption('XAXS {disp},{val}', 'XAXS? {disp}', str_type=bool)
        self.disp_PSD_en = devDispOption('PSDU {disp},{val}', 'PSDU? {disp}', str_type=bool, doc='Wether PSD (power spectral density) is enabled.')
        self.disp_transducer_unit_mode = devDispOption('TDRC {disp},{val}', 'TDRC? {disp}', choices=ChoiceIndex(['acceleration', 'velocity', 'displacement']))
        self.average_en = devDispOption('FAVG {disp},{val}', 'FAVG? {disp}', str_type=bool)
        self.average_mode = devDispOption('FAVM {disp},{val}', 'FAVM? {disp}', choices=ChoiceIndex(['vector', 'RMS', 'PeakHold']))
        self.average_type = devDispOption('FAVT {disp},{val}', 'FAVT? {disp}', choices=ChoiceIndex(['linear', 'exponential', 'FixedLength', 'continuous']))
        self.average_count_requested = devDispOption('FAVN {disp},{val}', 'FAVN? {disp}', str_type=int, min=2, max=32767)
        self.average_count = devDispOption(getstr='NAVG? {disp}', str_type=int)
        self.average_increment_pct = devDispOption('FOVL {disp},{val}', 'FOVL? {disp}', str_type=float, min=0, max=300)
        self.average_overload_reject_en = scpiDevice('FREJ 2,{val}', 'FREJ? 0', str_type=bool)
        self.average_preview_type = devDispOption('PAVO {disp},{val}', 'PAVO? {disp}', choices=ChoiceIndex(['off', 'manual', 'timed']))
        self.window_type = devDispOption('FWIN {disp},{val}', 'FWIN? {disp}', choices=ChoiceIndex(['uniform', 'flattop', 'hanning', 'BMH', 'kaiser', 'force', 'exponential', 'user', '-T/2..T/2', '0..T/2', '-T/4..T/4',]))
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        self._devwrap('dump', autoinit=False)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    @locked_calling
    def get_xscale(self):
        # only works for fft
        start = self.freq_start.getcache()
        stop = self.freq_stop.getcache()
        npoints = self.freq_resolution.getcache() + 1 # could also use DSPN? d
        return np.linspace(start, stop, npoints)
    def _dump_getformat(self, ps=True, **kwarg):
        fmt = self.dump._format
        if ps:
            binfmt = '.ps'
        else:
            binfmt = '.gif'
        fmt.update(bin=binfmt)
        return BaseDevice.getformat(self.dump, **kwarg)
    def _dump_getdev(self, ps=True, area='all'):
        """"""
        options are ps, area
         -ps: when True (default) returns a postscript object, otherwise returns a GIF file
         -area: used for GIF files, one of 'graph', 'menu', 'status' or 'all'(default)
        """"""
        # Reading data is tricky because the instrument does not send
        # EOI on its last byte so we either need to detect the ending comment
        # of the postscript or wait for the first timeout to occur for
        # the bitmap.
        # Also when the remote output is set to GPIB we do no receive the last byte.
        # So we need to switch the output to RS232 first.
        area_sel = dict(graph=0, menu=1, status=2, all=3)
        # POUT sets hardware print key to bitmap or vector
        # PDST 3 selects GPIB
        # PCIC 0 selects host controller
        # PLTP selects postscript
        # PRTP selects GIF
        r=''
        old_to = self.set_timeout
        self.set_timeout=.5 # useful for bitmap mode since we need to wait for timeout
        self.write('OUTX 1') # Go to RS232 interface
        if ps:
            self.write('POUT 1;PDST 3;PCIC 0;PLTP 1;PLOT')
            while r[-11:] != '%%Trailer\r\n':
                r += self.visa.read_raw_n(1)
        else:
            self.write('POUT 0;PDST 3;PCIC 0;PRTP 4;PSCR %d;PRNT'%area_sel[area])
            try:
                while True:
                    r += self.visa.read_raw_n(1)
            except visa_wrap.VisaIOError:
                pass
        self.write('OUTX 0') # return to gpib interface
        self.set_timeout = old_to
        return r
    # serial poll status word: 0=INSTrument, 1=DISPlay, 2=INPuT, 3=ERRor, 4=output buffer empty
    #                          5=standard status word, 6=SRQ, 7=IFC (no command execution in progress)
    def get_instrument_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):   A measurement has been triggered
          bit 1 (2):   Disk operation complete
          bit 2 (4):   Hardcopy output complete
          bit 3 (8):   unused
          bit 4 (16):  Capture buffer filled
          bit 5 (32):  Measurement has been paused
          bit 6 (64):  Measurement has been started
          bit 7 (128): Single shot capture playback has finished
          bit 8 (256): Measurement stopped to wait for average preview
          bit 9-15: unused
        """"""
        # can access bits with inst? 1
        # can enable in status register with INSE
        return int(self.ask('INST?'))
    def get_display_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):    displayA has new data
          bit 1 (2):    displayA linear average complete
          bit 2 (4):    displayA new settled data available
          bit 3 (8):    displayA failed a limit test
          bit 4 (16):   displayA swept sine has failed
          bit 5 (32):   displayA 1-shot waterfall has finished
          bit 6-7:      unused
          bit 8 (256):  displayB has new data
          bit 9 (512):  displayB linear average complete
          bit 10 (1024):displayB new settled data available
          bit 11 (2048):displayB failed a limit test
          bit 12 (4096):displayB swept sine has failed
          bit 13 (8192):displayB 1-shot waterfall has finished
          bit 14-15:    unused
         except for waterfall always test for new data (bit 0/8) for
         the correct display first.
        """"""
        # can access bits with inst? 1
        # can enable in status register with DSPE
        return int(self.ask('DSPS?'))
    def get_input_status(self):
        """"""
         returns a byte of bit flags
          bit 0 (1):    input1 has fallend below half of full scale
          bit 1 (2):    input1 has exceeded half of full scale
          bit 2 (4):    input1 has exceeded full scale
          bit 3 (8):    input1 has exceeded 35 dBV, range switched to 34 dBV
          bit 4 (16):   input1 has autoranged
          bit 5-7:      unused
          bit 8 (256):  input2 has fallend below half of full scale
          bit 9 (512):  input2 has exceeded half of full scale
          bit 10 (1024):input2 has exceeded full scale
          bit 11 (2048):input2 has exceeded 35 dBV, range switched to 34 dBV
          bit 12 (4096):input2 has autoranged
          bit 13-15:    unused
        """"""
        # can access bits with inst? 1
        # can enable in status register with INPE
        # also see INPC? 0 (ch1) or INPC? 1 (ch2)
        # which returns instanteneous a value 0-3 where:
        #   0=input under half full scale
        #   1=input over half full scale
        #   2=input overloaded
        #   3=input is HighV
        return int(self.ask('INPS?'))
    @locked_calling
    def get_error(self):
        """"""
         returns two byte of bit flags
         first:
          bit 0-1:     unused
          bit 2 (4):   Too many responses are pending
          bit 3 (8):   too many commands received
          bit 4 (16):  command cannot execute successfully
          bit 5 (32):  command syntax error
          bit 6 (64):  key press or knob rotated
          bit 7 (128): power is turned on
          bit 8-15:    unused
         second:
          bit 0 (1):   An output error as occured (print, plot, dump)
          bit 1 (2):   disk errro
          bit 2 (4):   math error
          bit 3 (8):   RAM memory test fails
          bit 4 (16):  ROM memory test fails
          bit 5 (32):  Video memory test fails
          bit 6 (64):  Help memory test fails
          bit 7 (128): DSP data memory fails
          bit 8 (256): DSP program memory fails
          bit 9 (512): DSP DRAM memory fails
          bit 10 (1024): DSP calibration memory fails
          bit 11 (2048): Ch1 calibration memory fails
          bit 12 (4096): Ch2 calibration memory fails
          bit 13-15: unused
        """"""
        # can access bits with errs? 1
        # can enable in status register with ERRE
        # enable *ese with *ese
        return int(self.ask('*esr?')),int(self.ask('ERRS?'))


#######################################################
##    Lakeshore 325 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL325', '1.7/1.1')
@register_instrument('LSCI', 'MODEL325')
class lakeshore_325(visaInstrument):
    """"""
       Temperature controller
       Useful device:
           sa
           sb
           ta
           tb
           status_a
           status_b
           fetch
       s? and t? return the sensor or kelvin value of a certain channel
       status_? returns the status of the channel
       fetch allows to read all channels
    """"""
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([c+'_T', c+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, ch=None):
        """"""
        reads thermometers temperature and their sensor values.
        option ch: can be a single channel or a list of channels.
                   by default (None), all active channels are used
                   possible channels names are:
                       A, B
        """"""
        ch = self._fetch_helper(ch)
        ret = []
        for c in ch:
            if c == 'A':
                ret.append(self.ta.get())
                ret.append(self.sa.get())
            elif c == 'B':
                ret.append(self.tb.get())
                ret.append(self.sb.get())
            else:
                raise ValueError(""Invalid selection for ch. If it is None, check that enabled_list is a list with 'A' and/or 'B'"")
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('sp', options)
    def _create_devs(self):
        self.crdg = scpiDevice(getstr='CRDG? A', str_type=float)
        self.enabled_list = MemoryDevice(['A', 'B'])
        self.thermocouple = scpiDevice(getstr='TEMP?', str_type=float)
        self.ta = scpiDevice(getstr='KRDG? A', str_type=float) #in Kelvin
        self.tb = scpiDevice(getstr='KRDG? B', str_type=float) #in Kelvin
        self.sa = scpiDevice(getstr='SRDG? A', str_type=float) #in sensor unit: Ohm, V or mV
        self.sb = scpiDevice(getstr='SRDG? B', str_type=float) #in sensor unit
        self.status_a = scpiDevice(getstr='RDGST? A', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.status_b = scpiDevice(getstr='RDGST? b', str_type=int)
        self.htr = scpiDevice(getstr='HTR?', str_type=float) #heater out in %
        self.sp = scpiDevice(setstr='SETP 1,', getstr='SETP? 1', str_type=float)
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Lakeshore 340 Temperature controller
#######################################################

register_idn_alias('Lake Shore Cryotronics', 'LSCI')

#@register_instrument('LSCI', 'MODEL340', '061407')
@register_instrument('LSCI', 'MODEL340')
class lakeshore_340(visaInstrument):
    """"""
       Temperature controller used for He3 system
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
       s and t return the sensor or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_crv = []
            in_type = []
            for c in ch:
                ch_list.append(c)
                in_set.append(self.input_set.get(ch=c))
                in_crv.append(self.input_crv.get())
                in_type.append(self.input_type.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_set=%r'%in_set,
                    'input_crv=%r'%in_crv, 'input_type=%r'%in_type]
        else:
            base = self._conf_helper('current_ch', 'input_set', 'input_crv', 'input_type')
        base += self._conf_helper('current_loop', 'sp', 'pid', options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_set.get(ch=c)
            if d['enabled']:
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([c+'_T', c+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, ch=None):
        """"""
        reads thermometers temperature and their sensor values.
        option ch: can be a single channel or a list of channels.
                   by default (None), all active channels are used
                   possible channels names are:
                       A, B, C, D, C1, C2, C3, C4, D1, D2, D3, D4
                   (depending on installed options)
        """"""
        old_ch = self.current_ch.getcache()
        ch = self._fetch_helper(ch)
        ret = []
        for c in ch:
            ret.append(self.t.get(ch=c))
            ret.append(self.s.get())
        self.current_ch.set(old_ch)
        return ret
    def _create_devs(self):
        rev_str = self.ask('rev?')
        conv = ChoiceMultiple(['master_rev_date', 'master_rev_num', 'master_serial_num', 'sw1', 'input_rev_date',
                         'input_rev_num', 'option_id', 'option_rev_date', 'option_rev_num'], fmts=str)
        rev_dic = conv(rev_str)
        ch_Base = ChoiceStrings('A', 'B')
        ch_3462_3464 = ChoiceStrings('A', 'B', 'C', 'D') # 3462=2 other channels, 3464=2 thermocouple
        ch_3468 = ChoiceStrings('A', 'B', 'C1', 'C2', 'C3', 'C4', 'D1', 'D2','D3','D4') # 2 groups of 4, limited rate, limited current sources (10u or 1m)
        ch_3465 = ChoiceStrings('A', 'B', 'C') # single capacitance
        ch_opt = {'3462':ch_3462_3464, '3464':ch_3462_3464, '3468':ch_3468, '3465':ch_3465}
        ch_opt_sel = ch_opt.get(rev_dic['option_id'], ch_Base)
        self.current_ch = MemoryDevice('A', choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='KRDG? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='SRDG? {ch}', str_type=float, doc='Return the sensor value in Ohm, V(diode), mV (thermocouple), nF (for capacitance)  for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.input_set = devChOption('INSET {ch},{val}', 'INSET? {ch}', choices=ChoiceMultiple(['enabled', 'compens'],[bool, int]))
        self.input_crv = devChOption('INCRV {ch},{val}', 'INCRV? {ch}', str_type=int)
        self.input_type = devChOption('INTYPE {ch},{val}', 'INTYPE? {ch}',
                                      choices=ChoiceMultiple(['type', 'units', 'coeff', 'exc', 'range']))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}',
                                      choices=ChoiceMultiple(['filter_en', 'n_points', 'window'], [bool, int, int]))
        self.current_loop = MemoryDevice(1, choices=[1, 2])
        def devLoopOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(loop=self.current_loop)
            app = kwarg.pop('options_apply', ['loop'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.pid = devLoopOption('PID {loop},{val}', 'PID? {loop}',
                                 choices=ChoiceMultiple(['P', 'I', 'D'], float))
        self.htr = scpiDevice(getstr='HTR?', str_type=float) #heater out in %
        self.sp = devLoopOption(setstr='SETP {loop},{val}', getstr='SETP? {loop}', str_type=float)
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

#######################################################
##    Lakeshore 224 Temperature monitor
#######################################################
class quoted_name(object):
    def __call__(self, read_str):
        # the instruments returns a 15 character string with spaces if unused
        return read_str.rstrip()
    def tostr(self, input_str):
        if '""' in input_str:
            raise ValueError, 'The given string already contains a quote :"":'
        return '""'+input_str[:15]+'""'

#@register_instrument('LSCI', 'MODEL224', '1.0')
@register_instrument('LSCI', 'MODEL224')
class lakeshore_224(lakeshore_340):
    """"""
       Temperature monitor
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
       s and t return the sensor or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels (which is the alias)

       Note: The device USB is actually a serial to USB port. Therfore it
             shows on the computer as a serial connection (once the driver
             is installed, which could happen automatically.)
    """"""
    def init(self, full=False):
        if full:
            if self.visa.is_serial():
                self.visa.baud_rate = 57600
                self.visa.parity = visa_wrap.constants.Parity.odd
                self.visa.data_bits = 7
            if self.visa.is_serial():
                self._write_write_wait = 0.100
            else: # GPIB, LAN: This is unchecked but should be ok. Shorter time might be better...
                self._write_write_wait = 0.050
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_crv = []
            in_type = []
            in_diode = []
            for c in ch:
                ch_list.append(c)
                in_crv.append(self.input_crv.get(ch=c))
                in_type.append(self.input_type.get())
                in_diode.append(self.input_diode_current.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_crv=%r'%in_crv, 'input_type=%r'%in_type, 'input_diode_current=%r'%in_diode]
        else:
            base = self._conf_helper('current_ch', 'input_crv', 'input_type', 'input_diode_current')
        base += self._conf_helper(options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_type.get(ch=c)
            if d['type'] != 'disabled':
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _get_esr(self):
        return int(self.ask('*esr?'))
    def get_error(self):
        esr = self._get_esr()
        ret = ''
        if esr&0x80:
            ret += 'Power on. '
        if esr&0x20:
            ret += 'Command Error. '
        if esr&0x10:
            ret += 'Execution Error. '
        if esr&0x04:
            ret += 'Query Error (output queue full). '
        if esr&0x01:
            ret += 'OPC received.'
        if ret == '':
            ret = 'No Error.'
        return ret
    def _create_devs(self):
        ch_opt_sel = ['A', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'D1', 'D2', 'D3', 'D4', 'D5']
        self.current_ch = MemoryDevice('A', choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='KRDG? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='SRDG? {ch}', str_type=float, doc='Return the sensor value in Ohm, V(diode), mV (thermocouple), nF (for capacitance)  for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=invalid, 16(4)=temp underrange,
                               #32(5)=temp overrange, 64(6)=sensor under (<0), 128(7)=sensor overrange
                               # 000 = valid
        self.input_crv = devChOption('INCRV {ch},{val}', 'INCRV? {ch}', str_type=int)
        intypes = ChoiceIndex({0:'disabled', 1:'diode', 2:'PTC_RTD', 3:'NTC_RTD'})
        units = ChoiceIndex({1:'Kelvin', 2:'Celsius', 3:'Sensor'})
        ranges_disabled = ChoiceIndex({0:0})
        ranges_diode = ChoiceIndex({0:2.5, 1:10}) # V
        ranges_PTC = ChoiceIndex(make_choice_list([1, 3], 1, 4)[:-1], normalize=True) # Ohm
        ranges_NTC = ChoiceIndex(make_choice_list([1, 3], 1, 5)[:-1], normalize=True) # Ohm
        type_ranges = ChoiceMultipleDep('type', {'disabled':ranges_disabled, 'diode':ranges_diode, 'PTC_RTD':ranges_PTC, 'NTC_RTD':ranges_NTC})
        self.input_type = devChOption('INTYPE {ch},{val}', 'INTYPE? {ch}',
                                      allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['type', 'autorange_en', 'range', 'compensation_en', 'units'], [intypes, bool, type_ranges, bool, units]))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}',
                                      allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['filter_en', 'n_points', 'window'], [bool, int, int]))
        self.input_diode_current = devChOption('DIOCUR {ch},{val}', 'DIOCUR? {ch}', choices=ChoiceIndex({0:10e-6, 1:1e-3}), doc=
                """"""Only valid when input is a diode type. Options are in Amps.
                   Default of instrument is 10 uA (used after every change of sensor type)."""""")
        self.input_name = devChOption('INNAME {ch},{val}', 'INNAME? {ch}', str_type=quoted_name())
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch
        # This needs to be last to complete creation
        super(lakeshore_340, self)._create_devs()
    def disable_ch(self, ch):
        """"""
        This method set a channel to disabled.
        Note that the settings of the channel are lost. To reenable use
          input_type with at least options autorange_en (PTC, NTC), range (allways, any value is allowed if autorange is enabled)
                     compensation_en (PTC, NTC)
          input_crv
          input_diode_current (for diodes if want 1 mA)
        """"""
        self.input_type.set(ch=ch, type='disabled', range=0)

#######################################################
##    Lakeshore 370 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL370', '04102008')
@register_instrument('LSCI', 'MODEL370')
class lakeshore_370(visaInstrument):
    """"""
       Temperature controller used for dilu system
       Useful device:
           s
           t
           fetch
           status_ch
           current_ch
           pid
           still
           still_raw
       s and t return the sensor(Ohm) or kelvin value of a certain channel
       which defaults to current_ch
       status_ch returns the status of ch
       fetch allows to read all channels

       Notes about T control:
           - the htr values is either in W (assuming the resistance is correctly
           programmed) or % of current full scale. Therefore we have
           W = ((%/100)*Ifullscale)**2 * Rheater
           - The feedback formula is:
               Iheater = Imax * P * [e + I integral(e dt) + D de/dt]
               with e = 2*log10(Rmeas/Rsetpoint)
                 at least for sensors calibrated as log scale
           - Therefore increasing currrent scale by x3.16 (power by x10)
             would require decreasing P by x3.16
       Notes about timing:
           - takes 10 readings / s, has a 200 ms hardware input filter
           - the digital filter is a linear average
           - Hardware settling time is about 1s, 2-3s for range change
             (scan channel change)
           - Time to a stable reading after channel change:
               max(hardware_settling, pause) + digital_filter
             so if pause it too small, it will take hardware settling time
             to get first reading used for the filter. Otherwise it will be
             the pause time (pause and hardware settling don't add)
           - When under PID control:
               The control channel is measured between all the other channels
               (toggles between control channel and non control channels).
               channel switch time is the same but the dwell times are changed
               about 5s for control and 1s for others (non-control).
               These are fixed (see  Manual 4.11.8.1 Reading Sequence p 4-23)
               There does not seem to be a way to change these dwell times.
    """"""
    def __init__(self, visa_addr, still_res=120., still_full_res=136.4, scanner=True, **kwarg):
        """"""
        still_res is the still heater resistance
        still_full_res is the still heater resistance with the wire resistance
                       included (the 2 wire resistance seen from outside the fridge)
        They are both used fot the still device
        scanner set it to True to force scanner use, False to disable it and 'auto' to
                automatically check for it. 'auto' only works for newer model 372 not 370.
        """"""
        self._still_res = still_res
        self._still_full_res = still_full_res
        self._scanner_present = scanner
        rsrc_info = resource_info(visa_addr)
        if rsrc_info.interface_type == visa_wrap.constants.InterfaceType.asrl:
            kwarg['parity'] = visa_wrap.constants.Parity.odd
            kwarg['data_bits'] = 7
        super(lakeshore_370, self).__init__(visa_addr, **kwarg)
        self._data_valid_last_ch = 0
        self._data_valid_last_t = 0.
        self._data_valid_last_start = 0., [0, False]
    def _get_esr(self):
        return int(self.ask('*esr?'))
    def get_error(self):
        esr = self._get_esr()
        ret = ''
        if esr&0x80:
            ret += 'Power on. '
        if esr&0x20:
            ret += 'Command Error. '
        if esr&0x10:
            ret += 'Execution Error. '
        if esr&0x04:
            ret += 'Query Error (output queue full). '
        if esr&0x01:
            ret += 'OPC received.'
        if ret == '':
            ret = 'No Error.'
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        if dev_obj == self.fetch:
            old_ch = self.current_ch.getcache()
            ch = options.get('ch', None)
            ch = self._fetch_helper(ch)
            ch_list = []
            in_set = []
            in_filter = []
            in_meas = []
            for c in ch:
                ch_list.append(c)
                in_set.append(self.input_set.get(ch=c))
                in_filter.append(self.input_filter.get())
                in_meas.append(self.input_meas.get())
            self.current_ch.set(old_ch)
            base = ['current_ch=%r'%ch_list, 'input_set=%r'%in_set,
                    'input_filter=%r'%in_filter, 'input_meas=%r'%in_meas]
        else:
            base = self._conf_helper('current_ch', 'input_set', 'input_filter', 'input_meas')
        base += self._conf_helper('sp', 'pid', 'manual_out_raw', 'still', 'heater_range',
                                  'control_mode', 'control_setup', 'control_ramp', options)
        return base
    def _enabled_list_getdev(self):
        old_ch = self.current_ch.getcache()
        ret = []
        for c in self.current_ch.choices:
            d = self.input_set.get(ch=c)
            if d['enabled']:
                ret.append(c)
        self.current_ch.set(old_ch)
        return ret
    def _fetch_helper(self, ch=None):
        if ch is None:
            ch = self.enabled_list.getcache()
        if not isinstance(ch, (list, ChoiceBase)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        ch = kwarg.get('ch', None)
        ch = self._fetch_helper(ch)
        multi = []
        graph = []
        for i, c in enumerate(ch):
            graph.append(2*i)
            multi.extend([str(c)+'_T', str(c)+'_S'])
        fmt = self.fetch._format
        fmt.update(multi=multi, graph=graph)
        return BaseDevice.getformat(self.fetch, **kwarg)
    @locked_calling
    def _data_valid_start(self):
        """""" returns channel and autoscan_en """"""
        to = time.time()
        if to - self._data_valid_last_start[0] < 0.02:
            # nothing has changed since last call so speedup by reusing result
            return self._data_valid_last_start[1]
        # the only way to clear the status when using serial is with *cls
        # and it is faster to also ask a question (less wait time later)
        result = self.ask('*cls;scan?').split(',')
        ret = int(result[0]), bool(int(result[1]))
        self._data_valid_last_start = time.time(), ret
        return ret
    def _data_valid(self):
        """"""
        waits until we have valid data
        returns the current scan channel when done
        """"""
        with self._lock_instrument: # protect object variables
            to = time.time()
            start_ch, foo = self._data_valid_start()
            if to-self._data_valid_last_t < 1. and self._data_valid_last_ch == start_ch:
                # we should still be having good data, skip the wait
                self._data_valid_last_t = to
                return start_ch
        while not self.read_status_byte()&4:
            wait(.02)
        after_ch, foo = self._data_valid_start()
        tf = time.time()
        if tf-to > 1.: # we waited after a channel change
            ch = after_ch
        else:  # the channel is the same or it got changed just after our wait.
            ch = start_ch
        with self._lock_instrument: # protect object variables
            self._data_valid_last_t = tf
            self._data_valid_last_ch = ch
        return ch
    def _fetch_getdev(self, ch=None, lastval=False, wait_new=False):
        """"""
        Optional parameter:
            ch: To select which channels to read. Default to all the enabled
                ones. Otherwise ch=4 selects only channel 4 and
                ch=[3,5] selects channels 3 and 5.
          lastval: When enabled, and when scanning, waits and picks the last value
                   read from that channel before switching
          wait_new: only returns values the are fresh. If a channel is never scanned
                    it will hang
        lastval and wait_new do something only when scanning is enabled.
        You can enable both at the same time.

        For each channels, two values are returned. The tempereture in Kelvin
        and the sensor value in Ohm.
        """"""
        old_ch = self.current_ch.getcache()
        ch = self._fetch_helper(ch)
        nmeas = len(ch) # the number of measures to do
        ret = [None] * nmeas*2
        ich = list(enumerate(ch)) # this makes a list of (i,c)
        ch2i = {c:i for i,c in ich} # maps channel # to index
        # for lastval only:
        # We assume the scanning is slower than getting all the values
        # so we first get all channel except the active one.
        # This should be ok since the first seconds after a channel change
        # returns the previous value and the sequence order is not too critical
        # since we have seconds to read all other channels
        if lastval or wait_new:
            # use _data_valid_start here because it can save some time over
            # self.scan.get()
            start_scan_ch, autoscan_en = self._data_valid_start()
            current_ch = start_scan_ch
            if not autoscan_en:
                lastval = False
                wait_new = False
        if lastval or wait_new:
            # They both introduce delays so we unlock to allow other threads
            # to use this device. The reset of the code has been checked to
            # be thread safe
            # TODO better unlockin/locking: This way, if the code is interrupted
            #             by KeyboardInterrupt it will produce an unlocking
            #             error in the previous with handler (the re-acquire)
            #             is not performed.
            self._lock_release()
        skip = False
        indx = 0
        while nmeas != 0:
            if wait_new and lastval:
                while True:
                    ch, foo = self._data_valid_start()
                    if ch == current_ch: # we wait until the channel changes
                        wait(.2)
                    else:
                        break
                if current_ch not in ch2i:
                    current_ch = ch
                    continue
                i, c = ch2i[current_ch], current_ch
                current_ch = ch
                # In PID control we will repeat the control channel multiple times
                # So check that. We will return the last one only
                if ret[i*2] is None:
                    nmeas -= 1
            elif wait_new: # only
                while True:
                    current_ch = self._data_valid()
                    if current_ch not in ch2i: # we want valid data for this channel
                        wait(.5)
                    else:
                        i, c = ch2i.pop(current_ch), current_ch
                        nmeas -= 1
                        break
            else: # lastval only or nothing
                i, c = ich[indx]
                indx += 1
                nmeas -= 1
                if lastval and c == start_scan_ch:
                    skip = True
                    continue
            ret[i*2] = self.t.get(ch=c)
            ret[i*2+1] = self.s.get(ch=c) # repeating channels means we don't need the lock
        if skip and lastval:
            while True:
                ch, foo = self._data_valid_start()
                if ch != start_scan_ch:
                    break
                wait(.1)
            i = ch2i[start_scan_ch]
            ret[i*2] = self.t.get(ch=start_scan_ch)
            ret[i*2+1] = self.s.get(ch=start_scan_ch)
        if lastval or wait_new:
            # we need to reacquire the lock before leaving
            self._lock_acquire()
        self.current_ch.set(old_ch)
        return ret
    def _htr_getdev(self):
        """"""Always in W, using control_setup heater_Ohms if necessary.""""""
        csetup = self.control_setup.getcache()
        htr = self.htr_raw.get()
        if csetup.output_display == 'power':
            return htr
        else:
            rng = self.heater_range.get()
            return (htr/100.*rng)**2 * csetup.heater_Ohms
    def _create_devs(self):
        if self.visa.is_serial():
            # we need to set this before any writes.
            self._write_write_wait = 0.100
            #self.visa.term_chars = '\r\n'
            self.write('*ESE 255') # needed for get_error
            self.write('*sre 4') # neede for _data_valid
        else: # GPIB
            self._write_write_wait = 0.050
        if self._scanner_present == 'auto':
            # DOUT always returns 00 when a scanner is present.
            scanner = False
            prev_dout = int(self.ask('DOUT?'))
            if prev_dout == 0:
                self.write('DOUT 01')
                dout = int(self.ask('DOUT?'))
                if dout != 0:
                    # bring it back
                    self.write('DOUT 00')
                else:
                    scanner = True
            self._scanner_present = scanner
        if self._scanner_present:
            ch_opt_sel = range(1, 17)
        else:
            ch_opt_sel = range(1, 2)
        self.current_ch = MemoryDevice(1, choices=ch_opt_sel)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.t = devChOption(getstr='RDGK? {ch}', str_type=float, doc='Return the temperature in Kelvin for the selected sensor(ch)')
        self.s = devChOption(getstr='RDGR? {ch}', str_type=float, doc='Return the sensor value in Ohm for the selected sensor(ch)')
        self.status_ch = devChOption(getstr='RDGST? {ch}', str_type=int) #flags 1(0)=CS OVL, 2(1)=VCM OVL, 4(2)=VMIX OVL, 8(3)=VDIF OVL
                               #16(4)=R. OVER, 32(5)=R. UNDER, 64(6)=T. OVER, 128(7)=T. UNDER
                               # 000 = valid
        tempco = ChoiceIndex({1:'negative', 2:'positive'})
        self.input_set = devChOption('INSET {ch},{val}', 'INSET? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                     choices=ChoiceMultiple(['enabled', 'dwell', 'pause', 'curvno', 'tempco'],
                                                       [bool, (int, (1, 200)), (int, (3, 200)), (int, (0, 20)), tempco]))
        self.input_filter = devChOption('FILTER {ch},{val}', 'FILTER? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                      choices=ChoiceMultiple(['filter_en', 'settle_time', 'window'], [bool, (int, (1, 200)), (int, (1, 80))]))
        res_ranges = ChoiceIndex(make_choice_list([2, 6.32], -3, 7), offset=1, normalize=True)
        cur_ranges = ChoiceIndex(make_choice_list([1, 3.16], -12, -2), offset=1, normalize=True)
        volt_ranges = ChoiceIndex(make_choice_list([2, 6.32], -6, -1), offset=1, normalize=True)
        curvolt_ranges = ChoiceMultipleDep('exc_mode', {'voltage':volt_ranges, 'current':cur_ranges})
        self.input_meas = devChOption('RDGRNG {ch},{val}', 'RDGRNG? {ch}', allow_kw_as_dict=True, allow_missing_dict=True,
                                     choices=ChoiceMultiple(['exc_mode', 'exc_range', 'range', 'autorange_en', 'excitation_disabled'],
                                                       [ChoiceIndex(['voltage', 'current']), curvolt_ranges, res_ranges, bool, bool]))
        # scan returns the channel currently being read
        #  it is the channel that flashes, not necessarily the one after scan on the
        #  display (they differ when temperature control is enabled, the instrument goes back
        #  to the control channel after all readings. This command follows that.)
        self.scan = scpiDevice('SCAN', allow_kw_as_dict=True, allow_missing_dict=True,
                               choices=ChoiceMultiple(['ch', 'autoscan_en'], [int, bool]))
        #self.current_loop = MemoryDevice(1, choices=[1, 2])
        #def devLoopOption(*arg, **kwarg):
        #    options = kwarg.pop('options', {}).copy()
        #    options.update(loop=self.current_loop)
        #    app = kwarg.pop('options_apply', ['loop'])
        #    kwarg.update(options=options, options_apply=app)
        #    return scpiDevice(*arg, **kwarg)
        #self.pid = scpiDevice('PID', choices=ChoiceMultiple(['P', 'I', 'D'], float))
        pid_ch = ChoiceMultiple(['P', 'I', 'D'], [(float, (0.001, 1000)), (float,(0, 10000)), (float, (0, 2500))])
        self.pid = scpiDevice('PID', allow_kw_as_dict=True, allow_missing_dict=True, choices=pid_ch, multi=pid_ch.field_names, doc=""You can use as set(tc3.pid, P=21)"")
        self.pid_P = Dict_SubDevice(self.pid, 'P', force_default=False)
        self.pid_I = Dict_SubDevice(self.pid, 'I', force_default=False)
        self.pid_D = Dict_SubDevice(self.pid, 'D', force_default=False)
        self.manual_out_raw = scpiDevice('MOUT', str_type=float,
                                  doc='manual heater output in % of Imax or in W depending on control_setup output_display option')
        self.htr_raw = scpiDevice(getstr='HTR?', str_type=float,
                                  doc='heater output in % of Imax or in W depending on control_setup output_display option')
        self._devwrap('htr')
        cmodes = ChoiceIndex({1:'pid', 2:'zone', 3:'open_loop', 4:'off'})
        self.control_mode = scpiDevice('CMODE', choices=cmodes)
        # heater range of 0 means off
        htrrng_dict = {0:0., 1:31.6e-6, 2:100e-6, 3:316e-6,
                       4:1.e-3, 5:3.16e-3, 6:10e-3, 7:31.6e-3, 8:100e-3}
        htrrng = ChoiceIndex(htrrng_dict)
        self.heater_range = scpiDevice('HTRRNG', choices=htrrng)
        csetup_htrrng_dict = htrrng_dict.copy()
        del csetup_htrrng_dict[0]
        csetup_htrrng = ChoiceIndex(csetup_htrrng_dict)
        csetup = ChoiceMultiple(['channel','filter_en', 'units', 'delay', 'output_display',
                           'heater_limit', 'heater_Ohms'],
                          [(int, (1, 16)), bool, ChoiceIndex({1:'kelvin', 2:'ohm'}), (int, (1, 255)),
                           ChoiceIndex({1:'current', 2:'power'}), csetup_htrrng, (float, (1, 1e5))])
        self.control_setup = scpiDevice('CSET', choices=csetup, allow_kw_as_dict=True, allow_missing_dict=True)
        self.control_setup_heater_limit = Dict_SubDevice(self.control_setup, 'heater_limit', force_default=False)
        self.control_ramp = scpiDevice('RAMP', allow_kw_as_dict=True, allow_missing_dict=True,
                                       choices=ChoiceMultiple(['en', 'rate'], [bool, (float,(0.001, 10))]), doc=""Activates the sweep mode. rate is in K/min."", setget=True)
        self.ramp_sweeping = devChOption(getstr='RAMPST?', str_type=bool)
        self.sp = scpiDevice('SETP', str_type=float)
        self.still_raw = scpiDevice('STILL', str_type=float)
        self._devwrap('enabled_list')
        self._devwrap('fetch', autoinit=False)
        self.alias = self.fetch

        Rfull = self._still_full_res
        Rhtr = self._still_res
        htr_from_raw = lambda x:  (x/10./Rfull)**2 * Rhtr*1e3 # x is % of 10V scale so x/10 is volt
        htr_to_raw = lambda p:    np.sqrt(p*1e-3/Rhtr)*Rfull*10.  # p is in mW
        self.still = FunctionDevice(self.still_raw, htr_from_raw, htr_to_raw, quiet_del=True, doc='still power in mW')

        # This needs to be last to complete creation
        super(lakeshore_370, self)._create_devs()

#######################################################
##    Lakeshore 372 Temperature controller
#######################################################

#@register_instrument('LSCI', 'MODEL372', '1.3')
@register_instrument('LSCI', 'MODEL372')
class lakeshore_372(lakeshore_370):
    def __init__(self, visa_addr, *args, **kwargs):
        rsrc_info = resource_info(visa_addr)
        if rsrc_info.interface_type == visa_wrap.constants.InterfaceType.asrl:
            baud_rate = kwargs.pop('baud_rate', 57600)
            kwargs['baud_rate'] = baud_rate
        scanner = kwargs.pop('scanner', 'auto')
        super(lakeshore_372, self).__init__(visa_addr, *args, scanner=scanner, **kwargs)


#######################################################
##    Colby Instruments Programmable delay line PDL-100A-20NS
#######################################################

#@register_instrument('Colby Instruments', 'PDL-100A-20.00NS', 'V1.70')
@register_instrument('Colby Instruments', 'PDL-100A-20.00NS')
class colby_pdl_100a(visaInstrument):
    """"""
    Colby Instruments delay box: PDL-100A-20NS
    Useful devices:
        delay_ps (default alias): enter delay value in ps
    It can take up to 1.5s to change the delay.
    Make sure visa timeout is not made too short (initialized to 3s).

    Useful methods:
        get_error
        reset
    """"""
    _errors_dict = {0: 'No Error', 1: 'Invalid Command', 2: 'Invalid Argument',
                    3: 'Unit did not pass calibration',
                    4: 'Delay setting requested beyond range of device',
                    5: 'Delay not set', 99: 'Buffer overflow'}
    def init(self, full=False):
        # This clears the error state, and status/event flags
        self.clear()
        if full:
            self.set_timeout = 3
            #self.visa.term_chars='\n'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        #return self._conf_helper('delay_ps', 'mode', 'rate', 'accel', options)
        return self._conf_helper('delay_ps', 'mode', options)
    def _delay_ps_setdev(self, val):
        # TODO could use async instead of using *OPC and visa timeout
        # OPC is to wait for completion, could require up to 1.5s
        self.ask('DEL %f PS;*OPC?'%val)
    def reset(self):
        """"""
        Returns to power on state (goes to 0 ps)
        """"""
        self.write('*rst')
        self.delay_ps.setcache(0.)
    def caltest(self, test=False):
        """"""
        Does either a calibration (only trombone) or an internal self-test
        (longer: trombone and relays)
        The state of the delay after calibration (because of relays) is not
        known.
        """"""
        if test:
            self.ask('*tst?')
        else:
            self.ask('*cal?')
        self.delay_ps.setcache(0.)
    def cal(self):
        self.write('*rst')
    def _delay_ps_getdev(self):
        return float(self.ask('DEL?'))*1e12
    def _create_devs(self):
        # other commands REL? relay query which returns bit flag, total delay ns
        #                REL n ON or REL n OFF to turn relay n (1..5) on or off.
        self.mode = scpiDevice('MODE', choices=ChoiceStrings('SER', 'PAR', '312.5PS', '625PS'))
        #self.rate = scpiDevice('RATE', str_type=int, min=100, max=550)
        #self.accel = scpiDevice('XDD', str_type=int, min=500, max=2000)
        self._devwrap('delay_ps', min=0, max=20e3, setget=True)
        self.alias = self.delay_ps
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def get_error(self):
        val = int(self.ask('ERR?'))
        err_str = self._errors_dict[val]
        return val, err_str


#######################################################
##    BNC 845 microwave/RF generator
#######################################################

register_usb_name('Berkeley Nucleonics Corporation', 0x03EB)

@register_instrument('Berkeley Nucleonics Corporation', 'MODEL 845', '0.4.35', usb_vendor_product=[0x03EB, 0xAFFF])
class BNC_rf_845(visaInstrument):
    """"""
    This controls a BNC 845 signal generetor
    Most useful devices:
        ampl_dbm
        rf_en
        freq_cw
    The alc devices refer to automatic level (amplitude) control.
    Available methods:
        phase_sync

    According to specs, it takes less than 0.1 ms for settling after
    a frequency change.
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # TODO Get the proper config
        return self._conf_helper('oscillator_source', 'oscillator_ext_freq_MHz', 'oscillator_locked',
                                 'oscillator_out_en', 'oscillator_out_freq',
                                 'rf_en', 'ampl_dbm', 'amp_flatness_corr_en', 'output_blanking_en',
                                 'ampl_mode', 'ampl_start', 'ampl_stop',
                                 'alc_en', 'alc_low_amp_noise_en', 'alc_hold_en',
                                 'attenuation_db', 'attenuation_auto_en', 'amp_flatness_corr_en',
                                 'freq_mode', 'freq_cw', 'freq_start', 'freq_stop',
                                 'sweep_nbpoints', 'sweep_type', 'sweep_dwell_s', 'sweep_delay_s', 'sweep_delay_auto_en',
                                 'sweep_direction',
                                 'lowfout_freq', 'lowfout_amp_V', 'lowfout_shape', 'lowfout_source', 'lowfout_en',
                                 'phase', 'mod_am_en', 'mod_fm_en', 'mod_phase_en', 'mod_pulse_en', options)
    def _create_devs(self):
        self.installed_options = scpiDevice(getstr='*OPT?')
        self.oscillator_source = scpiDevice(':ROSCillator:SOURce', choices=ChoiceStrings('INTernal', 'EXTernal')) # 'SLAVe' not useful for us
        self.oscillator_ext_freq_MHz = scpiDevice(':ROSCillator:EXTernal:FREQuency', str_type=float, min=1, max=250)
        self.oscillator_locked = scpiDevice(getstr=':ROSCillator:LOCKed?', str_type=bool)
        self.oscillator_out_en = scpiDevice(':ROSCillator:OUTPut:STATe', str_type=bool)
        self.oscillator_out_freq = scpiDevice(':ROSCillator:OUTPut:FREQuency', str_type=float, choices=[10e6, 100e6])
        self.rf_en = scpiDevice(':OUTPut', str_type=bool)
        #self.unit_power('UNIT:POWer', choices=ChoiceStrings('W', 'V', 'DBM', 'DB')) # only affects display
        #self.unit_freq('UNIT:FREQuency', choices=ChoiceStrings('HZ', 'MHZ', 'GHZ')) # only affects display
        self.ampl_dbm = scpiDevice(':POWer', str_type=float, setget=True, min=-105, max=20)
        # unit:volt:type affects volt scale like power:alc:search:ref:level, which are not user changeable
        self.ampl_mode = scpiDevice(':POWer:MODE', choices=ChoiceStrings('FIXed', 'LIST', 'SWEep'))
        self.ampl_start = scpiDevice(':POWer:STARt', str_type=float, setget=True)
        self.ampl_stop = scpiDevice(':POWer:STOP', str_type=float, setget=True)
        self.ampl_step = scpiDevice(getstr=':POWer:STEP?', str_type=float)
        self.alc_en = scpiDevice(':POWer:ALC', str_type=bool)
        self.alc_low_amp_noise_en = scpiDevice(':POWer:ALC:LOWN', str_type=bool, doc='When enabled provides up to 0.001 dB output resolution. Works similarly to hold')
        self.alc_hold_en = scpiDevice(':POWer:ALC:HOLD', str_type=bool, doc='Open loops ALC control')
        att_list = list(decode_float64(self.ask('POWer:ATTenuation:LIST?')))
        self.attenuation_db = scpiDevice(':POWer:ATTenuation', str_type=float, choices=att_list)
        self.attenuation_auto_en = scpiDevice(':POWer:ATTenuation:AUTO', str_type=bool)
        self.amp_flatness_corr_en = scpiDevice(':CORRection:FLATness', str_type=bool)
        self.output_blanking_en = scpiDevice(':OUTPut:BLANKing:STATe', str_type=bool, doc='disable RF output when changing frequency')
        self.phase = scpiDevice(':PHASe', str_type=float, min=0, max=2*np.pi, doc='Adjust phase arounf ref. In rad.')
        self.freq_mode = scpiDevice(':FREQuency:MODE', choices=ChoiceStrings('CW', 'FIXed', 'LIST', 'SWEep', 'CHIRp'), doc='CW and FIXed are the same.')
        minfreq=9e3
        maxfreq=20.5e9
        self.freq_cw = scpiDevice(':FREQuency', str_type=float, min=minfreq, max=maxfreq)
        self.freq_start = scpiDevice('FREQuency:STARt', str_type=float, min=minfreq, max=maxfreq)
        self.freq_stop = scpiDevice('FREQuency:STOP', str_type=float, min=minfreq, max=maxfreq)
        self.freq_step = scpiDevice(getstr='FREQuency:STEP?', str_type=float)
        #self.freq_steplog = scpiDevice(getstr='FREQuency:STEP:LOGarithmic?', str_type=float) # This is in the manual but does not seem to work
        self.sweep_nbpoints = scpiDevice('SWEep:POINts', str_type=int, min=2, max=65535)
        self.sweep_progress = scpiDevice(getstr='SWEep:PROGress?', str_type=float) # manual says proggress but is wrong
        self.sweep_type = scpiDevice('SWEep:SPACing', choices=ChoiceStrings('LINear', 'LOGarithmic'))
        self.sweep_dwell_s = scpiDevice('SWEep:DWELl', str_type=float)
        self.sweep_delay_s = scpiDevice('SWEep:DELay', str_type=float)
        self.sweep_delay_auto_en = scpiDevice('SWEep:DELay:AUTO', str_type=bool)
        self.sweep_direction = scpiDevice('SWEep:DIRection', choices=ChoiceStrings('UP', 'DOWN', 'RANDom'))
        self.lowfout_freq = scpiDevice(':LFOutput:FREQuency', str_type=float, min=10, max=5e6)
        self.lowfout_amp_V = scpiDevice(':LFOutput:AMPLitude', str_type=float, min=0, max=2.5, doc=
            """"""Vpp, only for LFGenerator and sine or triangle into 50 Ohm
               (not accurate, and with an offset).
               For Square amp=5V CMOS always."""""")
        self.lowfout_shape = scpiDevice(':LFOutput:SHAPe', choices=ChoiceStrings('SINE', 'TRIangle', 'SQUare'))
        self.lowfout_source = scpiDevice(':LFOutput:SOURce', choices=ChoiceStrings('LFGenerator', 'PULM', 'TRIGger'))
        self.lowfout_en = scpiDevice(':LFOutput:STATe', str_type=bool)
        self.mod_am_en = scpiDevice(':AM:STATe', str_type=bool)
        self.mod_fm_en = scpiDevice(':FM:STATe', str_type=bool)
        self.mod_phase_en = scpiDevice(':PM:STATe', str_type=bool)
        self.mod_pulse_en = scpiDevice(':PULM:STATe', str_type=bool)
        self.alias = self.freq_cw
        # This needs to be last to complete creation
        super(BNC_rf_845, self)._create_devs()
    def phase_sync(self):
        """"""
        Sets the current output phase as a zero reference.
        """"""
        self.write('PHASe:REFerence')


#######################################################
##    Scientific Magnetics Magnet Controller SMC120-10ECS
#######################################################

_parse_magnet_glitches = 0

def _parse_magnet_return(s, conv):
    """"""
    s is the input string
    conv is a list of tuples (start symbol, name, type)
    """"""
    global _parse_magnet_glitches
    names = []
    vals = []
    for symb, name, t in conv[::-1]:
        if symb=='last':
            vals.append(_fromstr_helper(s[-1], t))
            s = s[:-1]
        else:
            sp = s.rsplit(symb, 1)
            # I have notice that sometimes the instrument does not send the first
            # letter of the reply (at least for status update K, it sometimes (1 out of 20000),
            #  skips sending R). So capture that and handle it.
            if len(sp) == 1:
                vals.append(_fromstr_helper(sp[0], t))
                s = """"
                _parse_magnet_glitches += 1
            else:
                vals.append(_fromstr_helper(sp[1], t))
                s = sp[0]
        names.append(name)
    if s != """":
        raise RuntimeError('There is some leftovers (%s) in the string'%s)
    return dict_improved(zip(names[::-1], vals[::-1]))

def _repeat_getdev_dec(func):
    def _repeat_getdev_wrap(self, *arg, **kwarg):
        i = 0
        while True:
            try:
                ret = func(self, *arg, **kwarg)
                break
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    raise
                if i == 2:
                    raise
            i += 1
        _repeat_getdev_wrap._bad_count += i
        return ret
    _repeat_getdev_wrap._bad_count = 0
    return _repeat_getdev_wrap


@register_instrument('Scientific Magnetics', 'SMC120-10', '5.67')
class MagnetController_SMC(visaInstrument):
    """"""
    This controls a Scientific Magnetics Magnet Controller SMC120-10ECS
    Usefull device:
        ramp_T
        ramp_wait_after
        field
        rawIV
    You only control the lower setpoint. The upper setpoint is to control
    maximum value.
    Important, either leave the instrument in Tesla or at least
    do not change the calibration (it is read during init.)
    This only handles serial address connections (like ASRL1)
    Important: To changes values like display Unit, the instrument needs to be
    in remote (press remote button).
    To change the polarity(reverse option of operating_parameters),
    the current needs to be near zero to work (<0.09 A). It fails silently
    when above (reread operating_parameters to confirm the change).
    """"""
    def __init__(self, address):
        cnsts = visa_wrap.constants
        super(MagnetController_SMC, self).__init__(address, parity=cnsts.Parity.none, flow_control=cnsts.VI_ASRL_FLOW_XON_XOFF,
                                            baud_rate=9600, data_bits=8, stop_bits=cnsts.StopBits.two)
    def init(self, full=False):
        super(MagnetController_SMC, self).init(full=full)
        self._magnet_cal_T_per_A = self.operating_parameters.get()['calibTpA']
        maxT = self._magnet_max_T = self.setpoints.get(Tunit=True).upper
        self._magnet_max_I = self.setpoints.get(Tunit=False).upper
        self.ramp_T.min = -maxT
        self.ramp_T.max = maxT
    def idn(self):
        return 'Scientific Magnetics,SMC120-10,000000,5.67'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('field', 'current_status', 'setpoints', 'status', 'operating_parameters', 'ramp_wait_after', options)
    @_repeat_getdev_dec
    def _field_internal(self):
        s=self.ask('N')
        if s[0] == 'F':
            d = _parse_magnet_return(s, [('F', 'field', float), ('V', 'volt', float),
                                         ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                          ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
            field = d.field
        else:
            d = _parse_magnet_return(s, [('I', 'current', float), ('V', 'volt', float),
                                     ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                     ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
            field = d.current * self._magnet_cal_T_per_A
        return field, d
    def _field_getdev(self):
        field, d = self._field_internal()
        return field
    @_repeat_getdev_dec
    def _current_status_getdev(self):
        # Note that G,N returns the live output, while only J returns the persistent current (this is different than
        #  what the manual says.)
        s=self.ask('G')
        d = _parse_magnet_return(s, [('I', 'current', float), ('V', 'volt', float),
                                     ('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                     ('last', 'ramptype', ChoiceSimpleMap(dict(A='current_limit', V='volt_limit')))])
        return d
    def _rawIV_getdev(self):
        d = self._current_status_getdev()
        return d.current, d.volt
    def _operating_parameters_setdev(self, value):
        """"""
        When setting, you need a dictionnary.
        You can only set the following keys, to the corresponding values:
            rate:  sign of value is lost. in A/s.
            Tunit: True or False
            reverse: True or False
        But reverse will only work if field and voltage are 0.
        """"""
        for k,v in value.iteritems():
            if k == 'rate':
                self.write('A%.5f'%abs(v))
            elif k == 'Tunit':
                 self.write('T%i'%v)
            elif k == 'reverse':
                 self.write('D%i'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)
    @_repeat_getdev_dec
    def _operating_parameters_getdev(self):
        s = self.ask('O')
        return _parse_magnet_return(s, [('A', 'rate', float), ('D', 'reverse', bool),
                                        ('T', 'Tunit', bool), ('B', 'lockout', bool),
                                        ('W', 'Htr_current', float), ('C', 'calibTpA', float)])
    def _setpoints_setdev(self, values):
        Tunit = values.pop('Tunit', None)
        if Tunit is not None:
            self.write('T%i'%Tunit)
        for k,v in values.iteritems():
            v = abs(v)
            if k == 'lower':
                self.write('L%f'%v)
            #elif k == 'upper':
            #    self.write('U%f'%v)
            elif k == 'voltLim':
                self.write('Y%f'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)
    @_repeat_getdev_dec
    def _setpoints_getdev(self, Tunit='default'):
        """"""
        When setting, use a dictionnary with keys of 'lower' and/or 'voltLim'
        and with value the setpoint/limit you want (the sign of the value is lost).
        Also use 'Tunit' key with value False/True.
        For upper/lower you should also always set Tunit (if not it will use the current unit of the instrument.)
        For set, any unspecified value is unchanged.
        """"""
        s = self.ask('S')
        d = _parse_magnet_return(s, [ ('T', 'Tunit', bool), ('U', 'upper', float), ('L', 'lower', float),
                                     ('Y', 'voltLim', float)])
        if Tunit != 'default' and Tunit != d['Tunit']:
            if Tunit:
                f = self._magnet_cal_T_per_A
            else:
                f = 1./self._magnet_cal_T_per_A
            d['upper'] *= f
            d['lower'] *= f
            d['Tunit'] = Tunit
        return d
    def persistent_force(self):
        """"""
        This is very dangerous. It is currently disabled.
        """"""
        #self.write('H2')
        pass
    def persistent_forget(self):
        """"""
        This is dangerous. It is currently disabled.
        """"""
        #self.write('H9')
        pass
    def _status_setdev(self, value):
        for k,v in value.iteritems():
            if k == 'target':
                ch=ChoiceIndex(['zero', 'lower','upper'])
                self.write('R%s'%ch.tostr(v))
            elif k == 'pause':
                self.write('P%i'%v)
            elif k == 'persistent':
                # note that persistent could be True(1), False(0), see also persistent_force and forget
                self.write('H%i'%v)
            else:
                raise NotImplementedError('Changing %s is not implememented'%k)

    @_repeat_getdev_dec
    def _status_getdev(self):
        """"""
        When setting, you need a dictionnary.
        You can only set the following keys, to the corresponding values:
            target: 'zero', 'lower' or 'upper'
            pause: True or False
            persistent: True or False
        """"""
        s = self.ask('K')
        d= _parse_magnet_return(s, [('R', 'target', ChoiceIndex(['zero', 'lower','upper'])),
                                    ('M', 'rampstate', ChoiceIndex(['ramping', 'unknown', 'at_target'])),
                                    ('P', 'pause', bool), ('X', 'trip', ChoiceIndex(['off', 'on_inactive', 'on_active', 'off_active', 'on_auto_inactive', 'on_auto_active'])),
                                    ('H', 'persistent', bool), ('Z', 'foo', float),
                                    ('E', 'error', int), ('Q', 'trip_point', float)])
        # Note that the value of M is not properly described in manual. At least it does not match
        # what I observe (0=ramping, 2=at target, 1 is not seen)
        # at target is shown when control has reached the value. The actual outputs gets there a little bit later
        d.pop('foo')
        return d

    def get_error(self):
        return 'This instrument does not return the communication error state. Use status error value instead.'

    def _ramping_helper(self, stay_states, end_states=None, extra_wait=None):
        to = time.time()
        if self._last_state == 'ramp':
            # Reaching here, the cache should be ok.
            factor = -1. if self.operating_parameters.getcache().reverse else 1.
            prog_base = 'Magnet Ramping {field:.3f}/%.3f T'%(self.setpoints.getcache().lower*factor)
        else: # zeroing field
            prog_base = 'Magnet Ramping {field:.3f}/0 T'
        if isinstance(stay_states, basestring):
            stay_states = [stay_states]
        with release_lock_context(self):
            with mainStatusLine.new(priority=10, timed=True) as progress:
                check = lambda x: x.rampstate in stay_states and x.error == 0
                while check(self.status.get()):
                    # The instrument is slow. Trying to read too fast is counter productive
                    wait(.5)
                    progress(prog_base.format(field=self.field.get(), time=time.time()-to))
            if self.status.getcache().error != 0:
                error_code = self.status.getcache().error
                errors = []
                if error_code >= 10:
                    errors.append({1:'Changing polarity with I/V != 0.',
                                    2:'Polarity did not switch correctly',
                                    3:'Polarity switch in invalid state'}[error_code//10])
                if error_code%10 != 0:
                    errors.append({1:'Quenched!!',
                                    2:'External trip',
                                    3:'Quenched!! and External trip',
                                    4:'Brick trip',
                                    5:'Heatsink overtemperature trip',
                                    6:'Slave trip',
                                    7:'Heatsink overvoltage trip'}[error_code%10])
                # Polarity switch (I/V) != 0. error is only reset once a proper polarity change is performed
                # i.e. when changing polarity (operating_parameters reverse option)  with I=V=0.
                raise RuntimeError(self.perror('Magnet is in error: %s'%', '.join(errors)))
            if extra_wait:
                wait(extra_wait, progress_base='Magnet wait')
        if end_states is not None:
            if isinstance(end_states, basestring):
                end_states = [end_states]
            if self.status.get().rampstate not in end_states:
                raise RuntimeError(self.perror('The magnet state did not change to %s as expected'%end_states))

    def _do_ramp(self, field_target, wait):
        status = self.status.get()
        # chaning pause or target status takes 0.6 each and it is cumulative.
        # Therefore check if the change is needed before doing it.
        if field_target == 0:
            if status.target != 'zero':
                self.status.set(target='zero')
            if status.pause:
                self.status.set(pause=False)
            self._last_state = 'zero'
        else:
            #self.status.set(pause=True)
            self.setpoints.set(lower=field_target, Tunit=True)
            if status.target != 'lower':
                # This can take 0.6s so only do it when necessary.
                self.status.set(target='lower')
            if status.pause:
                self.status.set(pause=False)
            self._last_state = 'ramp'
        # unknow state seems to be a possible transient between ramping and at_target.
        # I only see it once (when continuously reading status) immediately followed by 'at_target'
        # I don't always see it.
        # Since the end_states check is done after a second reading of status (and a possible wait)
        # we should never have to check for it but to be safe I add it anyway (my observations time was not infinite)
        self._ramping_helper('ramping', ['at_target', 'unknown'], wait)
        # With a ramping rate of 0.00585 A/s  = 0.031 T/min
        # when going to zero, at_target shows up at about 3 mT and it takes about another 5 s to go to 0.
        # going to non-zero field (+0.05), at_target shows up at about 20 mT from target, and it takes another 15-20 s to become stable (0.0505 T)

    def _ramp_T_checkdev(self, val, wait=None, quiet=True):
        BaseDevice._checkdev(self.ramp_T, val)

    def _ramp_T_setdev(self, val, wait=None, quiet=True):
        """""" Goes to the requested setpoint and then waits until it is reached.
            After the instrument says we have reached the setpoint, we wait for the
            duration set by ramp_wait_after (in s).
            wait can be used to set a wait time (in s) after the ramp. It overrides ramp_wait_after.
            When using get, returns the magnet field in T.
        """"""
        def print_if(s):
            if not quiet:
                print s
        if wait is None:
            wait = self.ramp_wait_after.getcache()
        reverse_en = self.operating_parameters.get().reverse
        neg_val = True if val<0 else False
        if val != 0 and reverse_en != neg_val:
            # We need to switch polarity
            print_if('Ramping to zero for polarity change ...')
            # When switching polarity, need to wait. 5s is minium I observed as necessary.
            #  To be safe make it 20.
            self._do_ramp(0, 20.)
            self.operating_parameters.set(reverse = not reverse_en)
        print_if('Ramping...')
        self._do_ramp(val, wait)

    def _ramp_T_getdev(self):
        return self.field.get()

    def _create_devs(self):
        self.ramp_wait_after = MemoryDevice(20., min=0.)
        self._devwrap('field', doc='units are Tesla')
        self._devwrap('operating_parameters', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['rate', 'reverse', 'Tunit'], [float, bool, bool], allow_missing_keys=True))
        self._devwrap('setpoints', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['lower', 'voltLim', 'Tunit'], [float, float, bool], allow_missing_keys=True))
        self._devwrap('status', setget=True, allow_kw_as_dict=True,
                      choices=ChoiceMultiple(['pause', 'target', 'persistent'], [bool, float, bool], allow_missing_keys=True))
        self._devwrap('current_status')
        self._devwrap('rawIV')
        self.rawIV._format['multi'] = ['current', 'volt']
        self._devwrap('ramp_T')
        self.alias = self.field
        # This needs to be last to complete creation
        super(MagnetController_SMC, self)._create_devs()


#######################################################
##    Pfeiffer DCU400 TC400
#######################################################

class pfeiffer_turbo_loop(threading.Thread):
    def __init__(self, master):
        super(pfeiffer_turbo_loop, self).__init__()
        self.master = master
        self._stop = False
    def cancel(self):
        self._stop = True
    def run(self):
        # empty buffer
        self.master.visa.flush(visa_wrap.constants.VI_IO_IN_BUF_DISCARD)
        # trow away first partial data
        self.master.read()
        while True:
            if self._stop:
                return
            string = self.master.read()
            res = self.master.parse(string)
            if res is None:
                continue
            param, data = res
            #self.master._alldata_lock.acquire()
            self.master._alldata[param] = data, time.time()
            #self.master._alldata_lock.release()
    def wait(self, timeout=None):
        # we use a the context manager because join uses sleep.
        with _sleep_signal_context_manager():
            self.join(timeout)
        return not self.is_alive()

class pfeiffer_dev(BaseDevice):
    def __init__(self, param, type, enable_set=False, *args, **kwargs):
        super(pfeiffer_dev, self).__init__(*args, **kwargs)
        self._param = param
        self._param_type = type
        self._getdev_p = 'foo'
        if enable_set:
            self._setdev_p = 'foo'
    def _getdev(self):
        if self.instr._monitor_mode:
            return self.instr.get_param(self._param, self._param_type)
        else:
            request = self.instr._create_req(self._param)
            self.instr.write(request)
            return self.instr.get_param(self._param, self._param_type)
    def _setdev(self, val):
        if self.instr._monitor_mode:
            raise NotImplementedError(self.perror('The set for this device is not available'))
        request = self.instr._create_req(self._param, val, self._param_type)
        self.instr.write(request)
        ret = self.instr.get_param(self._param, self._param_type)
        self.setcache(ret)

@register_instrument('Pfeiffer', 'TC400')
class pfeiffer_turbo_log(visaInstrument):
    """"""
        This reads the information from a Pfeiffer pump
        using a serial to rs-485 converter.
        The pump is connected to a DCU unit that requests and reads
        all the values. We just capture all of them (when monitor_mode == True,
        the default).
    """"""
    # we had trouble with the Visa serial connection that kept frezzing.
    # So we use the serial module instead.
    def __init__(self, address, monitor_mode=True):
        cnsts = visa_wrap.constants
        super(pfeiffer_turbo_log, self).__init__(address, timeout=5, parity=cnsts.Parity.none, baud_rate=9600, data_bits=8,
             stop_bits=cnsts.StopBits.one, write_termination='\r', read_termination='\r', end_input=cnsts.SerialTermination.termination_char)
        self._monitor_mode = monitor_mode
        if monitor_mode:
            # Locking makes the get code go slow so don't do it
            self._lock_extra = Lock_Extra()
            self._lock_instrument = Lock_Extra()
            self._alldata = dict()
            self._alldata_lock = threading.Lock()
            s = weakref.proxy(self)
            self._helper_thread = pfeiffer_turbo_loop(s)
            self._helper_thread.start()
    def __del__(self):
        self._helper_thread.cancel()
        self._helper_thread.wait(.1)
        super(pfeiffer_turbo_log, self).__del__()
    def idn(self):
        return 'Pfeiffer,TC400,no_serial,no_firmare'
    def parse(self, string):
        chksum = string[-3:]
        try:
            chksum = int(chksum)
        except ValueError:
            print 'Invalid Checksum value', string
            return None
        if np.sum(bytearray(string[:-3]))%256 != chksum:
            print 'Invalid Checksum', string
            return None
        addr = string[:3]
        if addr != '001':
            print 'Invalid address', string
            return None
        action = string[3:5]
        if action != '10':
            if action != '00':
                print 'Invalid action', string
            return None
        # action == '00' is for a question
        param = int(string[5:8])
        len = int(string[8:10])
        data = string[10:10+len]
        return param, data
    def _create_req(self, param, data=None, type='string'):
        """""" if data is None, creates a request for a value.
            possible types:
                boolean
                string
                integer
                real
                expo
                vector
                boolean_new
                short_int
                tms_old
                expo_new
                string16
                string8
        """"""
        addr = '001'
        action = '00'
        param_s = '%03i'%param
        if data is None:
            data_str = '=?'
        else:
            data_str = ''
            def check(data, min_val, max_val):
                if data>max_val or data<min_val:
                    raise ValueError(self.perror('Value(%s) outside of valid range(%s,%s)'%(data, min_val, max_val)))
                return data
            if type == 'boolean':
                s = '1' if data else '0'
                s = s*6
            elif type == 'boolean_new':
                s = '1' if data else '0'
            elif type in ['string', 'string16', 'string8']:
                l = dict(string=6, string16=16, string8=8)[type]
                s = '%-*s'%(l, data[:l])
            elif type == 'integer':
                s = '%06i'%check(data, 0, 999999)
            elif type == 'short_int':
                s = '%03i'%check(data,0,999)
            elif type == 'real':
                s = '%06i'%check(data*100, 0, 999999)
            elif type == 'expo_new':
                fexp = int(np.floor(np.log10(check(data, 0, 9.9994e79))))
                fman = int(np.round(data/10.**(fexp-3)))
                if fman>9999:
                    fman = fman//10
                    fexp += 1
                check(fexp, -20, 79)
                check(fman, 0, 9999)
                s = '%04i%02i'%(fman, fexp+20)
            elif type in ['expo', 'tms_old', 'vector']:
                raise NotImplementedError(self.perror('tms_old and vector are not implemented yet'))
            else:
                raise ValueError(self.perror('Invalid type'))
            data_str = s
        data_len = '%02i'%len(data_str)
        req = addr + action + param_s + data_len + data_str
        chksum = np.sum(bytearray(req))%256
        req += '%03i'%chksum
        return req
    def get_param(self, param, type='string'):
        """""" possible type:
                boolean
                string
                integer
                real
                expo
                vector
                boolean_new
                short_int
                tms_old
                expo_new
                string16
                string8
        """"""
        if self._monitor_mode:
            self._alldata_lock.acquire()
            val = self._alldata.get(param)
            self._alldata_lock.release()
            if val is None:
                print 'Data not available yet'
                return None
            val, last = val
        else:
            val_str = self.read()
            param_read, val = self.parse(val_str)
            if param_read != param:
                raise RuntimeError(self.perror('Received unexpected param (%i!=%i)'%(param_read, param)))
        if type in ['boolean',  'boolean_new']:
            return bool(int(val))
        elif type in ['integer', 'short_int']: #integer is 6 digits, short is 3
            return int(val)
        elif type == 'real':
            return int(val)/100.
        elif type == 'expo':
            return float(val)
        elif type == 'expo_new':
            return val[:4]/1000. * 10**(int(val[4:])-20)
        elif type in ['string', 'string16', 'string8']: # string is 6 long
            return val
        elif type in ['tms_old', 'vector']:
            raise NotImplementedError(self.perror('tms_old and vector are not implemented yet'))
        else:
            raise ValueError(self.perror('Invalid type'))
        return val
    def _create_devs(self):
        self.temp_power_stage = pfeiffer_dev(324, 'integer')
        self.temp_elec = pfeiffer_dev(326, 'integer')
        self.temp_pump_bottom = pfeiffer_dev(330, 'integer')
        self.temp_bearing = pfeiffer_dev(342, 'integer')
        self.temp_motor = pfeiffer_dev(346, 'integer')
        self.actual_speed = pfeiffer_dev(309, 'integer')
        self.drive_current = pfeiffer_dev(310, 'real')
        self.drive_power = pfeiffer_dev(316, 'integer')
        #self._devwrap('temp_pump_bottom')
        #self.alias = self.field
        # This needs to be last to complete creation
        super(pfeiffer_turbo_log, self)._create_devs()

#######################################################
##    Delft BIAS-DAC
#######################################################

#@register_instrument('Delft', 'BIAS-DAC', '1.4')
@register_instrument('Delft', 'BIAS-DAC')
class delft_BIAS_DAC(visaInstrument):
    """"""
       This is to set the voltages on a Delft made BIAS-DAC.
       It works with version 1.4 of the fiber control box.
       The box is only connected with a serial port.
       WARNING: the voltages that are read are only what the
         control box remembers it sent to the hardware. If the
         power is lost on the hardware or the control box, the
         values are INVALID until new ones are set.
       For the voltages to be valid, the programs needs to
       know the settings of the 4 dials. You should set them
       up properly before using the device.

       Useful device:
          level
          level_all
          current_ch
       Useful methods:
          set_config
          get_config
    """"""
    def __init__(self, address):
        self._last_error_val = 0
        self._dac_modes_blocks = [None]*4
        self._last_dac_read_time = None
        self._last_dac_read_vals = None
        cnsts = visa_wrap.constants
        super(delft_BIAS_DAC, self).__init__(address, parity=cnsts.Parity.odd, baud_rate=115200, data_bits=8,
             stop_bits=cnsts.StopBits.one, write_termination=None, read_termination=None, end_input=cnsts.SerialTermination.none)
        # Note that end_input default is cnsts.SerialTermination.termination_char
        #  the read code works even in that case. However to be clearer about our intentions we set it properly here
        #  (the difference is that self.visa.read_raw_n will stop at term char (newline). read_raw_n_all will
        #   repeat the read until the full count is received)
    def _base_command(self, command, *args):
        """"""
        This handles commands 'set_dac', 'read_dacs', 'get_version', 'set_interface_bits'
                              and even 'continues_send_data'
        The args for 'set_dac', 'continues_send_data' are
            channel number (1-16)
            dac value (uint16)
        The args for 'set_interface_bits' are
            values: uint32
                     note that value 1<<27 turns the LED on.
                     some bits cannot be toggle (masked with 0xff00a0a0)
        The return value is None except for:
            'get_version': where is is an integer (divide by 10 to get version number)
            'read_dacs': where it is 16 uint16
        """"""
        send_header = '>bbbb' # size, error, out_size, action
        recv_header = '>bb'   # size, error
        if command in ('set_dac','continues_send_data') :
            send_header += 'bH' # channel, dac_value(uint16)
            cmd_val = 1 if command == 'set_dac' else 3
            n_arg = 2
            ch = args[0]
            daq_val = args[1]
            if ch<1 or ch>16:
                raise ValueError('Invalid channel number. Should be 1<=ch<=16')
            if daq_val<0 or daq_val>0xffff:
                raise ValueError('Invalid daq_val. Should be 0<= val <= 0xffff')
        elif command == 'read_dacs':
            cmd_val = 2
            n_arg = 0
            recv_header += '16H'
        elif command == 'get_version':
            cmd_val = 4
            n_arg = 0
            recv_header += 'b'
        elif command == 'set_interface_bits':
            send_header += 'bH4s' # channel, dac_value(uint16), inteface_bits(uint32)
            cmd_val= 5
            n_arg = 3
            ib = struct.pack('<I', args[0]&0xff00a0a0)
            # the inteface bit has the wrong endianness
            args = (0,0)+(ib,)+args[1:]
        else:
            raise ValueError('Invalid Command')
        if len(args) != n_arg:
            raise ValueError('Invalid number of arguments')
        send_len = struct.calcsize(send_header)
        recv_len = struct.calcsize(recv_header)
        send_str = struct.pack(send_header, send_len, 0, recv_len, cmd_val, *args)
        self.write(send_str)
        res = self.read(count=recv_len)
        ret_vals = struct.unpack(recv_header, res)
        n_read, error = ret_vals[:2]
        self._last_error_val = error
        if n_read != recv_len:
            raise RuntimeError('Unexpected return value header length')
        if error != 0:
            if error & 0x20:
                print ""WARNING: The controller was reset (watchdog) (%i)""%error
                #raise RuntimeError('The controller was reset (watchdog) (%i)'%error)
            if error & 0x40:
                raise RuntimeError('Invalid dac channel (%i)'%error)
            if error & 0x80:
                raise RuntimeError('Wrong Action (%i)'%error)
            raise RuntimeError('Unknown error (%i)'%error)
        rest = ret_vals[2:]
        if len(rest):
            return rest
        else:
            return None
    def _get_ch_mode(self, ch):
        block_index = (ch-1)//4
        mode = self._dac_modes_blocks[block_index]
        return mode
    def _set_ch_command(self, val, ch):
        mode = self._get_ch_mode(ch)
        if mode is None:
            raise RuntimeError(self.perror('You did not initialize the mode for ch=%i. See set_config method.'%ch))
        dac_val = self._v2dac_conv(val, mode)
        self._base_command('set_dac', ch, dac_val)
        self._last_dac_read_time = None
    def _get_all_command(self):
        last = self._last_dac_read_time
        now = time.time()
        if last is None or last+0.5 < now:
            # force a read after a set, or after more than 0.5s since last read
            #print 'READING DAC'
            data = self._base_command('read_dacs')
            self._last_dac_read_time = now
            self._last_dac_read_vals = data
            return data
        else:
            return self._last_dac_read_vals
    def _get_ch_command(self, ch, do_exc=True):
        data = self._get_all_command()
        val = data[ch-1]
        mode = self._get_ch_mode(ch)
        if mode is None:
            if do_exc:
                raise RuntimeError(self.perror('You did not initialize the mode for ch=%i. See set_config method.'%ch))
            else:
                return val
        return self._dac2v_conv(val, mode)
    def read(self, raw=False, count=2, chunk_size=None):
        # change the count default.
        return super(delft_BIAS_DAC, self).read(count=count)
    def idn(self):
        firm_version = self._base_command('get_version')[0]/10.
        return 'Delft,BIAS-DAC,serial-unknown,%r'%firm_version
    def get_error(self):
        return self._last_error_val
    _mode_offset = dict(neg=4., bip=2., pos=0.)
    _dac_full_range = 2**16
    def _dac2v_conv(self, dac, mode):
        v = dac*4./self._dac_full_range
        v -= self._mode_offset[mode]
        return v
    def _v2dac_conv(self, v, mode):
        full_range = self._dac_full_range
        v += self._mode_offset[mode]
        dac = v/4. * full_range
        dac = int(round(dac))
        # make sure 0 <= dac < full_range
        dac = min(max(dac, 0), full_range-1)
        return dac
    def set_config(self, dac_mode_1_4=None, dac_mode_5_8=None, dac_mode_9_12=None, dac_mode_13_16=None):
        """"""
        For all the blocks the valid options are None, 'pos', 'neg', 'bip'
        where None means keep the previous value,
        'pos', 'neg', 'bip' mean positive (0 - 4V), negative (-4 - 0V) and bipolar (-2 - 2V)
        """"""
        modes = [dac_mode_1_4, dac_mode_5_8, dac_mode_9_12, dac_mode_13_16]
        for i, m in enumerate(modes):
            if m is None:
                continue
            if m not in ['pos', 'neg', 'bip']:
                raise ValueError(self.perror('invalid mode'))
            self._dac_modes_blocks[i] = m
    def get_config(self, do_return=False):
        blocks = self._dac_modes_blocks
        if do_return:
            return blocks
        print 'Current dac mode is:'
        for i in range(4):
            mode = blocks[i]
            print '   DAC mode %2i - %2i: %s'%(i*4+1, i*4+4, mode)
    def _level_helper(self, ch):
        if ch is None:
            return self.current_ch.get()
        if ch<1 or ch>16:
            raise ValueError(self.perror('channel is outside the 1-16 range.'))
        self.current_ch.set(ch)
        return ch
    def _level_checkdev(self, val, ch=None):
        ch = self._level_helper(ch)
    def _level_setdev(self, val, ch=None):
        ch = self._level_helper(ch)
        self._set_ch_command(val, ch)
    def _level_getdev(self, ch=None):
        ch = self._level_helper(ch)
        return self._get_ch_command(ch)
    def _level_all_setdev(self, all_values):
        if len(all_values) != 16:
            raise ValueError(self.perror('Need to provide a vector of 16 elements'))
        for i, val in enumerate(all_values):
            self._set_ch_command(val, i+1)
    def _level_all_getdev(self):
        return np.array([self._get_ch_command(ch) for ch in range(1,17)])
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        modes = self.get_config(do_return=True)
        values = [self._get_ch_command(ch, do_exc=False) for ch in range(1,17)]
        for i, m in enumerate(modes):
            if m is None:
                for ch in range(i*4, i*4+4):
                    values[ch] = '%#06x'%values[ch]
        base = ['modes=%r'%modes, 'values=%r'%values]
        return base+self._conf_helper('current_ch', options)
    def _create_devs(self):
        self.current_ch = MemoryDevice(1, choices=range(1,17))
        self._devwrap('level', autoinit=False, setget=True, doc='option ch: it is the channel to use (1-16). When not given it reuses the last one.')
        titles = ['dac_%02i'%i for i in range(1, 17)]
        self._devwrap('level_all', setget=True, autoinit=False, multi=titles)
        self.alias = self.level
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

#######################################################
##    Micro Lambda Wireless MLBF filter
#######################################################

#@register_instrument('micro_lambda_wireless', 'MLBFP-78020', '1.2  Aug 29 2016')
@register_instrument('micro_lambda_wireless', 'MLBFP-78020')
class micro_lambda_mlbf(BaseInstrument):
    """"""
    This is the driver for the Micro Lambda Wireless MLBF YIG filter.
    It currently works using the UDP (network) protocol or the USB protocol
    if cython-hipapi isinstalled. To install cython-hipapi on windows can be
    done with: pip install hidapi
    You need to specify either the udp_address (like '192.168.137.10' or 'mlbf0093')
    or the usb value (True or a serial number string like '0093')
    NOTE: the usb driver does hang when communicating a lot. When that happens the whole
    instrument is completely frozen and requires disconnecting the power cable.
    """"""
    def __init__(self, udp_address=None, udp_port=30303, usb=None, **kwargs):
        if usb is not None and usb is not False:
            import hid
            usbdev = hid.device()
            usb_kwargs = {}
            if usb is not True:
                usb_kwargs['serial_number'] = unicode(usb)
            usbdev.open(0x04d8, 0x003f, **usb_kwargs)
            usbdev.set_nonblocking(True) # just to be safe. Probably unecessary since I used read timeouts.
            self._usbdev = usbdev
            self._usb_timeout = None
            self._socket = None
        else:
            self._socket = socket.socket(type=socket.SOCK_DGRAM)
            self._socket.connect((udp_address, udp_port))
            self._usbdev = None
        self.set_timeout = 3
        self._last_write = 0
        # from testing 0.001 seems good enough. So to be safe, make it 0.01
        self._write_delay = 0.01
        super(micro_lambda_mlbf, self).__init__(**kwargs)

    def idn(self):
        conf = self.conf_general()
        return 'micro_lambda_wireless,%s,%s,%s'%(conf['model'], conf['serial'], conf['firmware_date'])

    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        opts = self._conf_helper('freq', 'temperature', 'temperature_highest')
        opts += ['conf_general=%s'%self.conf_general()]
        opts += ['protocol=%s'%('udp' if self._socket is not None else 'usb')]
        opts += self._conf_helper(options)
        return opts

    @locked_calling
    def write(self, val):
        # writing to fast after a write prevents the first one from working
        # (for example a query of the freq immediately after setting it, prevents
        #  the frequency from changing)
        now = time.time()
        delta = now-self._last_write
        delay = self._write_delay
        if delta < delay:
            wait(delay-delta)
        if self._socket is not None:
            self._socket.send(val)
        else:
            data = [0]*65
            for i, s in enumerate(val):
                data[i+1] = ord(s)
            self._usbdev.write(data)
        self._last_write = time.time()

    @locked_calling
    def read(self, raw=None, chunk_size=None):
        if self._socket is not None:
            ret = self._socket.recv(256)
        else:
            ret = self._usbdev.read(65, timeout_ms=int(self._usb_timeout*1e3))
            if len(ret) == 0:
                raise RuntimeError(self.perror('Timeout when reading.'))
            ret = ''.join(map(chr, ret))
        self._last_write = 0
        # all the reads I have seen have been 18 byte long.
        # Theres is padding with \0 and for socket only (not usb) terminates with \r\n
        zero_ind = ret.find('\0')
        if zero_ind >= 0:
            ret = ret[:zero_ind]
        return ret

    @property
    def set_timeout(self):
        """""" The timeout in seconds """"""
        if self._socket is not None:
            return self._socket.gettimeout()
        else:
            return self._usb_timeout
    @set_timeout.setter
    def set_timeout(self, val):
        if self._socket is not None:
            self._socket.settimeout(val)
        else:
            self._usb_timeout = val
    @locked_calling

    def ask(self, val, raw=None, chunk_size=None):
        self.write(val)
        return self.read()

    @locked_calling
    def close(self):
        if self._socket is not None:
            self._socket.shutdown()
            self._socket.close()
        else:
            self._usbdev.close()

    def _freq_setdev(self, val):
        """""" Set/get frequency in Hz """"""
        if self._socket is not None:
            self.write('F%.4f'%(val*1e-6))
        else: # usb returns an empty string, udp returns nothing
            self.ask('F%.4f'%(val*1e-6))
    def _freq_getdev(self):
        s = self.ask('R16')
        return float(s)*1e6

    def set_display(self, display_string=None):
        """""" Sets the instrument 2 line display to the given string.
            if None, set the first line to freq, the second to temperature.
        """"""
        if display_string is None:
            return self.ask('DT')
        if len(display_string) > 32:
            raise ValueError(self.perror('The requested display string is too long. Need length <= 32.'))
        self.write('""%s""'%display_string)

    def conf_general(self):
        clean = lambda x: x.rstrip('\n\r ')
        model = self.ask('R0')
        serial = self.ask('R1')
        product = self.ask('R2')
        freq_min_MHz = float(self.ask('R3'))
        freq_max_MHz = float(self.ask('R4'))
        v3_0 = float(self.ask('V1')[:-1]) # Need to remove terminating V
        v3_3 = float(self.ask('V2')[:-1]) # Need to remove terminating V
        v5_0 = float(self.ask('V3')[:-1]) # Need to remove terminating V
        vp15 = float(self.ask('V4')[:-1]) # Need to remove terminating V
        vn15 = float(self.ask('V5')[:-1]) # Need to remove terminating V
        filter_bandwidth_MHz = float(self.ask('R5'))
        filter_insertion_loss_dB = float(self.ask('R6'))
        filter_limit_power_dBm = float(self.ask('R7'))
        temperature_min = float(self.ask('R8'))
        temperature_max = float(self.ask('R9'))
        non_volatile_state = clean(self.ask('R11'))
        firmware_date = clean(self.ask('R12'))
        unit_health = self.ask('R13')
        unit_calibration_status = self.ask('R14')
        unit_self_test_result = self.ask('R15')
        filter_passband_spurs_ripples_max_dB = float(self.ask('R17'))
        filter_off_resonance_isolation_min_dB = float(self.ask('R18'))
        filter_bandwidth_meas_spec_db = float(self.ask('R23'))
        unit_coarse_calibration_status = self.ask('R26')
        unit_fine_calibration_status = self.ask('R27')
        firmware_tcpip_stack_version = self.ask('R29')
        firmware_build_time = self.ask('R30')
        ret = locals()
        del ret['self']
        del ret['clean']
        return ret

    def conf_network(self):
        clean = lambda x: x.rstrip('\n\r ')
        dhcp_status = clean(self.ask('R100'))
        ip_addr = clean(self.ask('R101'))
        ip_mask = clean(self.ask('R102'))
        ip_gateway = clean(self.ask('R103'))
        ip_dns1 = clean(self.ask('R104'))
        ip_dns2 = clean(self.ask('R105'))
        mac_address = clean(self.ask('R106'))
        hostname = clean(self.ask('R107'))
        udp_port = int(self.ask('R108'))
        ret = locals()
        del ret['self']
        del ret['clean']
        return ret

    def get_status(self):
        status = self.ask('?')
        val = int(status, 2)
        return dict(self_test_pass=bool(val&0x40), novo_locked=bool(val&0x80))

    def _create_devs(self):
        self.temperature = scpiDevice(getstr='T', str_type=lambda x: float(x[:-1])) # Need to remove terminating C
        self.temperature_highest = scpiDevice(getstr='R10', str_type=float)
        fmin = float(self.ask('R3'))-100
        fmax = float(self.ask('R4'))+100
        self._devwrap('freq', min=fmin*1e6, max=fmax*1e6, setget=True)
        self.alias = self.freq
        self.freq_MHz = ScalingDevice(self.freq, 1e-6, quiet_del=True)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

# Above we use the UDP or USB connection protocol.
# You can also connect using telnet.
#  - The windows telnet works ok
#  - The cygwin works if you specify the port (23) because that prevents
#        automatic initiation of TELNET options.
#  - The protocol seem fragile (hence preventing option negotiation)
#      bad entries can easily block it
#  - It allows only one connection at a time.
# You can also use the web server:
#  - connect to http://192.168.137.10 or something to that effect (standard port 80)
#  - in python
#     import httplib
#     ht = httplib.HTTPConnection('192.168.137.10')
#     ht.request('POST', '/diag.htm', 'cmd=r1'); resp = ht.getresponse()
#     resp.status, resp.reason, resp.read()
#   - can replace /diag.htm  by /commands.htm
#   - should also be able to use /index.htm but that does not seem to work

#######################################################
##    Andeen Hagerling AH 2550A  Ultra-Precision 1 kHz capacitance bridge
#######################################################

#@register_instrument('ANDEEN-HAGERLING', 'AH2550A', 'AH2X0217')
@register_instrument('ANDEEN-HAGERLING', 'AH2550A')
class ah_2550a_capacitance_bridge(visaInstrumentAsync):
    """"""
    This is the driver for the Andeen Hagerling AH 2550A  Ultra-Precision 1 kHz capacitance bridge.
    The protect the life of the instrument relays, do not measure continously (or for long periods
    of time) with the averaging at 7 or above.
       Useful device:
           readval
           fetch
           average
           bias
    """"""
    def __init__(self, *args, **kwargs):
        self._async_trig_current_data = None
        super(ah_2550a_capacitance_bridge, self).__init__(*args, **kwargs)

    def idn_split(self):
        idn = self.idn()
        no_labels = False
        if idn.startswith('\n'):
            no_labels = True
        #'MANUFACTURER    ANDEEN-HAGERLING\nMODEL/OPTIONS   AH2550A  --------\nSERIAL NUMBER   00100319\nACTIVE FIRMWARE AH2X0217'
        pp = idn.split('\n')
        def check_skip(s, start_str):
            if not no_labels:
                if not s.startswith(start_str):
                    raise RuntimeError('Unexepected idn string format')
                s = s[len(start_str):].lstrip()
            return s
        vm = check_skip(pp[0], 'MANUFACTURER')
        if vm == '':
            # without labels the current firmware (AH2X0217) returns an empty manufacturer
            vm = 'ANDEEN-HAGERLING'
        model_option = check_skip(pp[1], 'MODEL/OPTIONS')
        if ',' in model_option:
            # using ieee:
            mo = model_option.split(',')
        else:
            mo = model_option.split(' ')
        model = mo[0].rstrip()
        option = mo[-1]
        sn = check_skip(pp[2], 'SERIAL NUMBER')
        fm = check_skip(pp[3], 'ACTIVE FIRMWARE')
        return dict(vendor=vm, model=model, option=option, serial=sn, firmware=fm)

    def _get_esr(self):
        # does not have esr register
        return 0

    def _async_trigger_helper(self):
        self._async_trig_current_data = None
        self.write('*sre 16;SIngle')

    def _async_detect(self, max_time=.5): # 0.5 s max by default
        ret = super(ah_2550a_capacitance_bridge, self)._async_detect(max_time)
        if not ret:
            # This cycle is not finished
            return ret
        # we got a trigger telling data is available. so read it, before we turn off triggering in cleanup
        data = self.read()
        self._async_trig_current_data = data
        return ret

    def _async_cleanup_after(self):
        self._async_trig_current_data = None
        self.write('*sre 0') # disable trigger on data ready to prevent unread status byte from showing up
        super(ah_2550a_capacitance_bridge, self)._async_cleanup_after()


    def get_error(self, no_reset=False):
        """""" when no_reset is True, the error state is read but not reset """"""
        if no_reset:
            flags = self.read_status_byte()
        else:
            # This will also reset the flags
            flags = int(self.ask('*STB?'))
        errors = []
        if flags & 0x01:
            errors.append('Oven temperature invalid')
        if flags & 0x02:
            errors.append('Command error')
        if flags & 0x04:
            errors.append('User request')
        if flags & 0x08:
            errors.append('Powered on')
        # flags & 0x10 is ready for command
        if flags & 0x20:
            errors.append('Execution Erro')
        # flags & 0x40 is Master summary
        # flags & 0x80 is message available
        if len(errors):
            return ', '.join(errors)
        else:
            return 'No errors.'

    def clear(self):
        #some device buffer status byte so clear them
        while self.read_status_byte()&0x40:
            pass

    def init(self, full=False):
        self.write('*sre 0') # disable trigger (we enable it only when needed)
        self.clear()
        if full:
            # These are normally reset during power on.
            #  float (could be sci or eng), labels off, ieee on (commas), variable spacing (as opposed to fix)
            self.write('FORMAT float,OFF,ON,VARIABLE')
            # fields: sample off, frequency off, Cap 9 digits, loss 9 digits, voltage on, message(error) off means a number
            #  The error shows first
            self.write('FIELD OFF,OFF,9,9,ON,OFF')
            # With this configuration, an invalid question returns '32' or '36'
            #  when error are off the corresponding messages are: ILLEGAL WORD, and SYNTAX ERROR
            #  Table B3 says ILLEGAL WORD is 31, SYNTAX ERROR is 35

    def conf_datetime(self, set_to_now=False, passcode='INVALID'):
        """""" The correct passcode(owner or calibrator) is necessary to change the date/time """"""
        if set_to_now:
            if passcode == 'INVALID':
                raise ValueError(self.perror('You need to specify a valid passcode'))
            tm = time.localtime()
            cmd = 'STOre DAte %i,%i,%i\n%s\nSTOre TIme %i,%i,%i\n%s'%(tm.tm_year, tm.tm_mon, tm.tm_mday, passcode,
                                                                    tm.tm_hour, tm.tm_min, tm.tm_sec, passcode)
            self.write(cmd)
        d = self.ask('SHow DAte')
        t = self.ask('SHow TIme')
        d = map(int, d.split(','))
        t = map(int, t.split(','))
        runtime_hours = int(self.ask('SHow STAtus'))
        return dict(date='%04i-%02i-%02i %02i:%02i:%02i'%tuple(d+t), runtime_hours=runtime_hours)

    def conf_firmwares(self):
        firmwares = self.ask('SHow FIRMware')
        return dict(zip(['bank_rom', 'bank_flash1', 'bank_flash2'], firmwares.split('\n')))

    def conf_zero(self, enable=None, cap=None, loss=None, use_last=False):
        """""" This is used to configure zero mode.
            If none of the entries are specified, it returns the current setting.
            If you use use_last (uses last reading as 0 value) you cannont use cap or loss.
            If either cap or loss is specified, the other value is unchanged.
        """"""
        if use_last and (cap is not None or loss is not None):
            raise ValueError(self.perror('You can only specify cap/loss or use_last'))
        if enable is not None and not enable:
            self.write('Zero '+Choice_bool_OnOff.tostr(enable))
        if use_last:
            self.write('Zero FEtch')
        if cap is not None or loss is not None:
            prev = self.conf_zero()
            if cap is None:
                cap = prev.cap
            if loss is None:
                loss = prev.loss
            # Need to always specify both, otherwise it is an error
            self.write('Zero POINT %r,%r'%(cap, loss))
        if enable is not None and enable:
            self.write('Zero '+Choice_bool_OnOff.tostr(enable))
        res = self.ask('SHow Zero')
        # returns: 'OFF\n"" "",0.00000000,"" "",0.00000000'
        en, points_raw = res.split('\n')
        ret = dict_improved(enabled = Choice_bool_OnOff(en))
        zero_fmt = ChoiceMultiple(['cap_lbl', 'cap', 'loss_lbl', 'loss'], [quoted_string(), float, quoted_string(), float])
        ret.update(zero_fmt(points_raw).items())
        return ret

    def conf_reference(self, enable=None, cap=None, loss=None, percent=None, use_last=False):
        """""" This is used to configure reference mode.
            If none of the entries are specified, it returns the current setting.
            enable/use_last/percent can be None, 'cap', 'loss', 'all' (or True), 'none' (or False)
            If you use use_last (uses last reading as 0 value) you cannont use cap or loss.
            If either cap or loss is specified, the other value is unchanged.
        """"""
        def cleanup(x):
            if x is None:
                return x
            if x not in [True, False, 'all', 'none', 'cap', 'loss']:
                raise ValueError(self.perror('Invalid option'))
            if x is True:
                x = 'all'
            elif x is False:
                x = 'none'
            return x
        enable = cleanup(enable)
        percent = cleanup(percent)
        use_last = cleanup(use_last)
        if use_last in ['cap', 'all'] and cap is not None:
            raise ValueError(self.perror('You can only specify cap or use_last'))
        if use_last in ['loss', 'all'] and loss is not None:
            raise ValueError(self.perror('You can only specify cap or use_last'))
        if enable is not None and enable != 'all':
            # These all return the measurement in the new configuration
            # Not reading it sometimes prevents the change to actually happen
            #  so use ask instead of write
            if enable == 'none':
                self.ask('REFerence ALL OFF')
            elif enable == 'cap':
                self.ask('REFerence LOSs OFF')
            elif enable == 'loss':
                self.ask('REFerence Cap OFF')
        if use_last != 'none':
            self.write('REFerence FEtch %s'%use_last)
        if cap is not None:
            self.write('REFerence POINT Cap %r'%cap)
        if loss is not None:
            self.write('REFerence POINT LOSs %r'%loss)
        if percent is not None:
            if percent in ['all', 'cap']:
                self.write('REFerence PERcent Cap ON')
            if percent in ['all', 'loss']:
                self.write('REFerence PERcent LOSs ON')
            if percent in ['none', 'cap']:
                self.write('REFerence PERcent LOSs OFF')
            if percent in ['none', 'loss']:
                self.write('REFerence PERcent Cap OFF')
        if enable is not None and enable != 'none':
            # These all return the measurement in the new configuration
            # Not reading it sometimes prevents the change to actually happen
            #  so use ask instead of write
            if enable == 'all':
                self.ask('REFerence ALL ON')
            elif enable == 'cap':
                self.ask('REFerence Cap ON')
            elif enable == 'loss':
                self.ask('REFerence LOSs ON')
        res = self.ask('SHow REFerence')
        # returns: 'OFF,OFF\n"" "",0.00000000,"" "",0.00000000\nOFF,OFF'
        en, points_raw, percent = res.split('\n')
        ret = dict_improved()
        ret.update(zip(['cap_en', 'loss_en'], map(Choice_bool_OnOff, en.split(','))))
        zero_fmt = ChoiceMultiple(['cap_lbl', 'cap', 'loss_lbl', 'loss'], [quoted_string(), float, quoted_string(), float])
        ret.update(zero_fmt(points_raw).items())
        ret.update(zip(['cap_percent_en', 'loss_percent_en'], map(Choice_bool_OnOff, percent.split(','))))
        return ret

    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        opts = self._conf_helper('average', 'units', 'voltage_max', 'frequency', 'commutate', 'bias', 'cable')
        opts += ['zero=%r'%self.conf_zero()]
        opts += ['reference=%r'%self.conf_reference()]
        opts += self._conf_helper(options)
        return opts

    _data_format = ChoiceMultiple(['error', 'cap_lbl', 'cap', 'loss_lbl', 'loss', 'volt'], [int, quoted_string(), float, quoted_string(), float, float])
    @locked_calling
    def _read_data(self, force_req=True):
        """""" using force_req will send a fetch request (it will show BUSY on the display)
            When in continuous you can use force_req=False to read the latest value (then wait for the next one.)
            It can also be 'async' to read available async data.
        """"""
        data = None
        if force_req == 'async':
            data = self._async_trig_current_data
            self._async_trig_current_data = None
        elif force_req:
            self.write('fetch')
        if data is None:
            data = self.read()
        return self._data_format(data)

    def continous(self, state=None):
        """""" state can be True/False. If none it returns the current state """"""
        if state is not None:
            self.write('COntinuous %s'%Choice_bool_OnOff.tostr(state))
        else:
            data = self.ask('SHow COntinuous').split('\n')
            data = map(lambda x: x[0](x[1]), zip([float, int, int], data))
            return dict(zip(['interval', 'stop_count', 'count'], data))

    def _fetch_getdev(self):
        """""" error contains cap uncertainty flag (>) if 1000 and loss uncertainty flag (>) if 2000.
            errors codes <100 are listed in Appendix B of manual (careful some numbers are off by 1).
        """"""
        if self._async_trig_current_data is not None:
            data  = self._read_data('async')
        else:
            data  = self._read_data(True)
        error = data.error
        if data.cap_lbl != ' ':
            if data.cap_lbl != '>':
                raise RuntimeError(self.perror('Unexpected cap label received'))
            error += 1000
        if data.loss_lbl != ' ':
            if data.loss_lbl != '>':
                raise RuntimeError(self.perror('Unexpected loss label received'))
            error += 2000
        return data.cap, data.loss, data.volt, error

    def _create_devs(self):
        # TODO: commands to program:
        #   calibrate? / store calibarate
        #   continuous interval, reset, total
        #   dev mode
        #   dev auto
        #   dev average
        #   dev bound
        #   dev fetch
        #   dev format
        #   dev margin
        #   dev point
        #   dev position
        #   dev rolloff
        #   dev span
        #   dev stream
        #   gpib  (to read this use: show gpib list)
        #     logger (to turn it off)
        #     scan to disable it.
        #   serial (to read this use: show serial list)
        #   test?
        # Note that deviation mode does not seem to work with AH2550A (probably only for AH2700)
        cold_k = np.array([.28,.29,.30,.33,.37,.44,.58,.82,1.2,1.8,3,5,9,17,34,68])
        cold_f = np.array([80,110,150,200,260,350,520,820,1300,2200,3900,7000,14000,27000,57000,120000])
        warm_k = np.array([.027, .033,.042,.058,.085,.12,.18])
        warm_f = np.array([11,23,42,75,130,230,400])
        cold_time = cold_k+cold_f/1e3 # at 1 kHz
        warm_time = warm_k+warm_f/1e3 # at 1 kHz
        time_doc = '%6s  %10s %10s\n'%('','cold', 'warm')
        for i in range(len(cold_time)):
            if i < len(warm_time):
                time_doc += '%6i: %10.3f %10.3f\n'%(i, cold_time[i], warm_time[i])
            else:
                time_doc += '%6i: %10.3f %10s\n'%(i, cold_time[i], 'n/a')
        # Note that for loss range the table is not clear if that f is in Hz or kHz but
        # comparing with table 4-3 it seems to be kHz for loss formula hence 12 uS.
        self.average = scpiDevice('AVerage', 'SHow AVerage', str_type=int, min=0, max=15,
                                  doc=u""""""
The averaging time is seen in table 4-1 and A-1 of the manual.
Note cold start measurement are longer because they readjust all the relays.
Warm start only adjust the stages that don't use relays.
For cold start by using average >= 7 (but don't use continous because relays will age too quickly.)
There is a frequency dependence but for 1 kHz it is and C<0.165 µF (G<12 µS):
%s
                                  """"""%time_doc)
        self.bias = scpiDevice('BIas', 'SHow BIas', choices=ChoiceStrings('OFF', 'ILow', 'IHigh'),
                               doc=u'ihigh is 1 MΩ, ilow is 100 MΩ')
        self.units = scpiDevice('UNits', 'SHow UNits',
                                    choices=ChoiceStrings('NS', 'DS', 'KO', 'GO', 'JP'),
                                    doc=u""""""
                                    Choices mean:
                                        NS: Nanosiemens (nS)
                                        DS: Dissipation factor or tanδ (dimensionless)
                                        KO: Series resistance in kilohms (kΩ)
                                        GO: Parallel resistance in gigohms (GΩ)
                                        JP: G/ω  (jpF)
                                    Note that series option (KO) means series capacitance is measured.
                                    Otherwise it is the parallel capacitance that is measured.
                                        """""")
        self.voltage_max = scpiDevice('Voltage', 'SH Voltage', str_type=float, min=0.3e-3, max=15, setget=True,
                                      doc=""""""For optimal use select one of the following voltages: 15, 7.5, 3, 1.5, 0.75, 0.25, 0.1, 0.03, 0.01, 0.003, 0.001"""""")
        #self.frequency =  scpiDevice('FRequency', 'SHow FRequency', str_type=float, setget=True)
        self.frequency =  scpiDevice(getstr='SHow FRequency', str_type=float)
        self.commutate = scpiDevice('COMmutate', 'SHow COMmutate', choices=ChoiceStrings('OFF', 'LINERej', 'ASync'))
        self.cable = scpiDevice('CABle', 'SHow CABle',
                                choices=ChoiceMultiple(['length', 'R', 'L', 'C'], [(float, (0, 999.99)), (float, (0, 9999)), (float, (0, 99.99)), (float, (0, 999.9))], reading_sep='\n'),
                                doc=u""""""Units are: length (m), R(mΩ/m), L(µH/m), C(pF/m)"""""")
        self._devwrap('fetch', autoinit=False, trig=True, multi=['cap', 'loss', 'volt', 'error'], graph=[0,1])
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        # This needs to be last to complete creation
        super(ah_2550a_capacitance_bridge, self)._create_devs()


#######################################################
##    Dummy instrument
#######################################################

@register_instrument('pyHegel_Instrument', 'dummy', '1.0')
class dummy(BaseInstrument):
    """""" This is a dummy device (just in memory) to use for testing.
        There are 5 devices: volt, current, incr, rand and other
          incr is a device that is incremented by 1 after every get
          rand returns a random value from a normal distribution
        Both incr and rand wait the time set in the wait attribute
        before returning from get. The wait attribute defaults to 0.1
    """"""
    def init(self, full=False):
        self.incr_val = 0
        self.wait = .1
    def idn(self):
        return 'pyHegel_Instrument,dummy,00000,1.0'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('volt', 'current', 'other', options)
    def _incr_getdev(self):
        ret = self.incr_val
        self.incr_val += 1
        wait(self.wait)
        return ret
    def _incr_setdev(self, val):
        self.incr_val = val
    #incr3 = wrapDevice(_incr_setdev, _incr_getdev)
    #incr2 = wrapDevice(getdev=_incr_getdev)
    def _rand_getdev(self):
        wait(self.wait)
        return random.normalvariate(0,1.)
    def _create_devs(self):
        self.volt = MemoryDevice(0., doc='This is a memory voltage, a float')
        self.current = MemoryDevice(1., doc='This is a memory current, a float')
        self.other = MemoryDevice(autoinit=False, doc='This takes a boolean')
        #self.freq = scpiDevice('freq', str_type=float)
        self._devwrap('rand', doc='This returns a random value. There is not set.', trig=True)
        self._devwrap('incr')
        self.alias = self.current
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Loop instrument
#######################################################

@register_instrument('pyHegel_Instrument', 'loop', '1.0')
class loop(BaseInstrument):
    """"""
        This is a dummy instrument (just in memory) to use for
        looping/repeating (multi_sweep).
        There are 5 devices: loop1 to loop5
    """"""
    def idn(self):
        return 'pyHegel_Instrument,dummy,00000,1.0'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('loop1', 'loop2',  'loop3', 'loop4', 'loop5', options)
    def _create_devs(self):
        self.loop1 = MemoryDevice(0.)
        self.loop2 = MemoryDevice(0.)
        self.loop3 = MemoryDevice(0.)
        self.loop4 = MemoryDevice(0.)
        self.loop5 = MemoryDevice(0.)
        self.alias = self.loop1
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
"
403,5420.0,USA,"The Agilent Technologies 8657A and 8657B signal generators are designed to test AM, FM, and pulsed receivers as well as components.
",HP 8657 B,181.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Pymeasure,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Pymeasure to connect to a Keysight 8657B RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape",Keysight 8657B,https://www.testequipmenthq.com/datasheets/Agilent-8657B-Datasheet.pdf,"[OrderedDict([('id', 'attJm86J8SkTFF9aT'), ('width', 550), ('height', 191), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QphzhJLmZjH4wIR46q-GOw/Gamf-YvCJ8tnG8kB6_vypVjYtWb9whtnpXodh-FK7NLPTqoync9eVffbxaAGPPljcaAma2VQhx_IQX8WwVKepA/zgR2WVL3Zv0Nsi9PGorcgW2UUwljXVAstJCDznYzzQA'), ('filename', 'HP_.jpeg'), ('size', 97806), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/by2nIeBYqJtElyJEP1qdBw/xigwEgD3vAXHyP3bxQ8fyIQmrGMrv33U_MOg9iQw6eeCdBuZ5VVrcboQvsIemOlDgEzYoPAOUW95ulpDTeFz8Q/fyr14LFvQqCK1KBg1LURXrAXBmDn6OeOkyBnts5rTm0'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_d9HeTX3QiPYz2nyo-bBLA/n09aVYE7KT1PLoP0rGjLX8ngb1RekyVJNBlrcwX5R3uuF2GddOO8snPb90jbXLJ5YIIxmNro8AR3AaTV_V55jw/LrBw9_2Af6LMg7eXEslcdgh9tJJ1OMzYk6JLE43E-wc'), ('width', 550), ('height', 191)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l0kOnWH1mecMeBmTJ-Bnrw/iYRJOi2dsfEQJpU3YIBQhubZzKbRCLc58sxx3Cwx2va060p4PDwq63qasa_-_sWONcg34LM720-kFfkpGeoP7Q/qfpZQdIlLpOmHNlGCKn3RE6MPK9nXzjVB6NQFa14Jdg'), ('width', 3000), ('height', 3000)]))]))])]",https://accusrc.com/product-HP-Agilent-8657B-9453,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/hp/hp8657b.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp8657B.html,900.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging
from enum import IntEnum
from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set, strict_range

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class HP8657B(Instrument):
    """""" Represents the Hewlett Packard 8657B signal generator
    and provides a high-level interface for interacting
    with the instrument.
    """"""

    def __init__(self, adapter, name=""Hewlett-Packard HP8657B"", **kwargs):
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            send_end=True,
            **kwargs,
        )

    class Modulation(IntEnum):
        """"""
        IntEnum for the different modulation sources
        """"""
        EXTERNAL = 1
        INT_400HZ = 2
        INT_1000HZ = 3
        OFF = 4
        DC_FM = 5

    def check_errors(self):
        """"""
        Method to read the error status register
        as the 8657B does not support any readout of values, this will return 0 and log a warning

        """"""
        log.warning(""HP8657B Does not support error status readout"")

    def clear(self):
        """"""
        Reset the instrument to power-on default settings

        """"""
        self.adapter.connection.clear()

    id = ""HP,8657B,N/A,N/A""  #: Manual ID entry

    am_depth = Instrument.setting(
        ""AM %2.1f PC"",
        """"""
        Set the modulation depth for AM,
        usable range 0-99.9%
        """""",
        validator=strict_range,
        values=[0, 99.9],
        )

    am_source = Instrument.setting(
        ""AM S%i"",
        """"""
        Set the source for the AM function with :attr:`Modulation` enumeration.

        ==========  =======
        Value       Meaning
        ==========  =======
        OFF         no modulation active
        INT_400HZ   internal 400 Hz modulation source
        INT_1000HZ  internal 1000 Hz modulation source
        EXTERNAL    External source, AC coupling
        ==========  =======

        *Note:*
            * AM & FM can be active at the same time
            * only one internal source can be active at the time
            * use ""OFF"" to deactivate AM

        usage example:

        .. code-block:: python

            sig_gen = HP8657B(""GPIB::7"")
            ...
            sig_gen.am_source = sig_gen.Modulation.INT_400HZ    #  Enable int. 400 Hz source for AM
            sig_gen.am_depth = 50                               #  Set AM modulation depth to 50%
            ...
            sig_gen.am_source = sig_gen.Modulation.OFF          #  Turn AM off

        """""",
        validator=strict_discrete_set,
        values=Modulation,
        )

    fm_deviation = Instrument.setting(
        ""FM %3.1fKZ"",
        """"""
        Set the peak deviation in kHz for the FM function,
        useable range 0.1 - 400 kHz

        *NOTE*:
            the maximum usable deviation is depending on the output frequency, refer to the
            instrument documentation for further detail.

        """""",
        validator=strict_range,
        values=[0.1, 400],
        )

    fm_source = Instrument.setting(
        ""FM S%i"",
        """"""
        Set the source for the FM function with :attr:`Modulation` enumeration.

        ==========  =======
        Value       Meaning
        ==========  =======
        OFF         no modulation active
        INT_400HZ   internal 400 Hz modulation source
        INT_1000HZ  internal 1000 Hz modulation source
        EXTERNAL    External source, AC coupling
        DC_FM       External source, DC coupling (FM only)
        ==========  =======

        *Note:*
            * AM & FM can be active at the same time
            * only one internal source can be active at the time
            * use ""OFF"" to deactivate FM
            * refer to the documentation rearding details on use of DC FM mode

        usage example:

        .. code-block:: python

            sig_gen = HP8657B(""GPIB::7"")
            ...
            sig_gen.fm_source = sig_gen.Modulation.EXTERNAL     #  Enable external source for FM
            sig_gen.fm_deviation = 15                           #  Set FM peak deviation to 15 kHz
            ...
            sig_gen.fm_source = sig_gen.Modulation.OFF          #  Turn FM off

        """""",
        validator=strict_discrete_set,
        values=Modulation,
        )

    frequency = Instrument.setting(
        ""FR %10.0f HZ"",
        """"""
        Set the output frequency of the instrument in Hz.

        For the 8567B the valid range is 100 kHz to 2060 MHz.
        """""",
        validator=strict_range,
        values=[1.0E5, 2.060E9],
        )

    level = Instrument.setting(
        ""AP %g DM"",
        """"""
        Set the output level in dBm.

        For the 8657B the range is -143.5 to +17 dBm/

        """""",
        validator=strict_range,
        values=[-143.5, 17.0],
        )

    level_offset = Instrument.setting(
        ""AO %g DB"",
        """"""
        Set the output offset in dB, usable range -199 to +199 dB.

        """""",
        validator=strict_range,
        values=[-199.0, 199.0],
        )

    output_enabled = Instrument.setting(
        ""R%d"",
        """"""
        Control whether the output is enabled.
        """""",
        validator=strict_discrete_set,
        values={False: 2, True: 3},
        map_values=True
       )

    def reset(self):
        self.adapter.connection.clear()

    def shutdown(self):
        self.adapter.connection.clear()
        self.output_enabled = False
        self.adapter.connection.close()
        super().shutdown()
"
407,110.6,"Cleveland, Ohio, United States","The Model 2000 6_-Digit Multimeter is part of Keithleys family of high performance DMMs. Based on the same high speed, low noise A/D converter technology as the Model 2001 and 2002, the 2000 is a fast, accurate, and highly stable instrument thats as easy to operate as it is to afford. It combines broad measurement ranges with superior accuracy specifications DC voltage from 100nV to 1kV (with 0.002% 90-day basic accuracy) and DC resistance from 100 to 100M (with 0.008% 90-day basic accuracy). Optional switch cards enable multiplexing up to 20 different input signals for multipoint measurement applications.",Keithley 2000,219.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Pymeasure,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Pymeasure to connect to a {Device name} Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-2000-Datasheet.pdf,"[OrderedDict([('id', 'attDkhYLQ6zcJU0mz'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g8NVRWRCYxFeNnCVE8rBkA/SXZEaj-FkmAbR9wEBqi2qdq9C9bfVztotbsqqti2aNMyC6b0jlxareooxrYkRFZ2wFjES6K0Qq5GNnWf4ZE-w-vPFRGuZlEDM05o92qbV98/W3RG-j7BKmbIom8t9FvC6oyAmVnqp1N9VexEW-5ZNSc'), ('filename', '2000.webp'), ('size', 6118), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QAvV5B847YFg3uI3iHlU5Q/9T3KQzGdCJ5Z0-v1R9zyg9qhsLRe4eBLGi0fffyKyXfVyxmNV8AiiN8sFnzyWIM8Eiy1AGFd7KmUc_YHgIL1pLZB9zhGturDKK6tvDgfMq0/otaYwWB8QK6dHmvuFBQYKkPDJMwuVvL-p4UmSJfyyyE'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fS0cJWXGPpyOHx57eTFU4w/46PP77zdFZBNuKeUYatFm3TIO9Q77H5WPU5S3Ft8lD3l6_ED3Yn08CsvlE3_QujhAxgeSj8FNYN0VfdwGqbPhhXC9gYUj5QQovn8Ka3Hlak/3mP_hDhCnMShVqg89WP7-aL1n-exNIyXqQhjayiwABA'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5_JJVg4EYXiGUbmAcsGuyg/tAc66MXu4_eKSFhQm8SIm-FoD1RcT3PsvN-9Q8mAzrX4Ukfp2r77XFUxvOSRAM7Gmxq0xK3bGTJcUw08dX9SNXIznjDWkOZptw90G-YKt0M/hU1saAYHMpCoLK306-Y7Zzwq45DDGvlTvn6Zuo6Y6rY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.allaboutcircuits.com/test-measurement/multimeters/keithley-2000/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/keithley/keithley2000.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/keithley/keithley2000.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import (
    truncated_range, truncated_discrete_set,
    strict_discrete_set
)
from .buffer import KeithleyBuffer

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class Keithley2000(KeithleyBuffer, Instrument):
    """""" Represents the Keithley 2000 Multimeter and provides a high-level
    interface for interacting with the instrument.

    .. code-block:: python

        meter = Keithley2000(""GPIB::1"")
        meter.measure_voltage()
        print(meter.voltage)

    """"""
    MODES = {
        'current': 'CURR:DC', 'current ac': 'CURR:AC',
        'voltage': 'VOLT:DC', 'voltage ac': 'VOLT:AC',
        'resistance': 'RES', 'resistance 4W': 'FRES',
        'period': 'PER', 'frequency': 'FREQ',
        'temperature': 'TEMP', 'diode': 'DIOD',
        'continuity': 'CONT'
    }

    mode = Instrument.control(
        "":CONF?"", "":CONF:%s"",
        """""" A string property that controls the configuration mode for measurements,
        which can take the values: ``current`` (DC), ``current ac``,
        ``voltage`` (DC),  ``voltage ac``, ``resistance`` (2-wire),
        ``resistance 4W`` (4-wire), ``period``,
        ``temperature``, ``diode``, and ``frequency``."""""",
        validator=strict_discrete_set,
        values=MODES,
        map_values=True,
        get_process=lambda v: v.replace('""', '')
    )

    beep_state = Instrument.control(
        "":SYST:BEEP:STAT?"",
        "":SYST:BEEP:STAT %g"",
        """""" A string property that enables or disables the system status beeper,
        which can take the values: ``enabled`` and ``disabled``. """""",
        validator=strict_discrete_set,
        values={'enabled': 1, 'disabled': 0},
        map_values=True
    )

    ###############
    # Current (A) #
    ###############

    current = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC current measurement in Amps, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    current_range = Instrument.control(
        "":SENS:CURR:RANG?"", "":SENS:CURR:RANG:AUTO 0;:SENS:CURR:RANG %g"",
        """""" A floating point property that controls the DC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_reference = Instrument.control(
        "":SENS:CURR:REF?"", "":SENS:CURR:REF %g"",
        """""" A floating point property that controls the DC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_nplc = Instrument.control(
        "":SENS:CURR:NPLC?"", "":SENS:CURR:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_digits = Instrument.control(
        "":SENS:CURR:DIG?"", "":SENS:CURR:DIG %d"",
        """""" An integer property that controls the number of digits in the DC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int,
    )
    current_ac_range = Instrument.control(
        "":SENS:CURR:AC:RANG?"", "":SENS:CURR:AC:RANG:AUTO 0;:SENS:CURR:AC:RANG %g"",
        """""" A floating point property that controls the AC current range in
        Amps, which can take values from 0 to 3.1 A.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 3.1]
    )
    current_ac_reference = Instrument.control(
        "":SENS:CURR:AC:REF?"", "":SENS:CURR:AC:REF %g"",
        """""" A floating point property that controls the AC current reference
        value in Amps, which can take values from -3.1 to 3.1 A. """""",
        validator=truncated_range,
        values=[-3.1, 3.1]
    )
    current_ac_nplc = Instrument.control(
        "":SENS:CURR:AC:NPLC?"", "":SENS:CURR:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC current measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    current_ac_digits = Instrument.control(
        "":SENS:CURR:AC:DIG?"", "":SENS:CURR:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC current
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    current_ac_bandwidth = Instrument.control(
        "":SENS:CURR:AC:DET:BAND?"", "":SENS:CURR:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC current detector
        bandwidth in Hz, which can take the values 3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ###############
    # Voltage (V) #
    ###############

    voltage = Instrument.measurement(
        "":READ?"",
        """""" Reads a DC or AC voltage measurement in Volts, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    voltage_range = Instrument.control(
        "":SENS:VOLT:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:RANG %g"",
        """""" A floating point property that controls the DC voltage range in
        Volts, which can take values from 0 to 1010 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    voltage_reference = Instrument.control(
        "":SENS:VOLT:REF?"", "":SENS:VOLT:REF %g"",
        """""" A floating point property that controls the DC voltage reference
        value in Volts, which can take values from -1010 to 1010 V. """""",
        validator=truncated_range,
        values=[-1010, 1010]
    )
    voltage_nplc = Instrument.control(
        "":SENS:CURRVOLT:NPLC?"", "":SENS:VOLT:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the DC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_digits = Instrument.control(
        "":SENS:VOLT:DIG?"", "":SENS:VOLT:DIG %d"",
        """""" An integer property that controls the number of digits in the DC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_range = Instrument.control(
        "":SENS:VOLT:AC:RANG?"", "":SENS:VOLT:RANG:AUTO 0;:SENS:VOLT:AC:RANG %g"",
        """""" A floating point property that controls the AC voltage range in
        Volts, which can take values from 0 to 757.5 V.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 757.5]
    )
    voltage_ac_reference = Instrument.control(
        "":SENS:VOLT:AC:REF?"", "":SENS:VOLT:AC:REF %g"",
        """""" A floating point property that controls the AC voltage reference
        value in Volts, which can take values from -757.5 to 757.5 Volts. """""",
        validator=truncated_range,
        values=[-757.5, 757.5]
    )
    voltage_ac_nplc = Instrument.control(
        "":SENS:VOLT:AC:NPLC?"", "":SENS:VOLT:AC:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the AC voltage measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    voltage_ac_digits = Instrument.control(
        "":SENS:VOLT:AC:DIG?"", "":SENS:VOLT:AC:DIG %d"",
        """""" An integer property that controls the number of digits in the AC voltage
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    voltage_ac_bandwidth = Instrument.control(
        "":SENS:VOLT:AC:DET:BAND?"", "":SENS:VOLT:AC:DET:BAND %g"",
        """""" A floating point property that sets the AC voltage detector
        bandwidth in Hz, which can take the values  3, 30, and 300 Hz. """""",
        validator=truncated_discrete_set,
        values=[3, 30, 300]
    )

    ####################
    # Resistance (Ohm) #
    ####################

    resistance = Instrument.measurement(
        "":READ?"",
        """""" Reads a resistance measurement in Ohms for both 2-wire and 4-wire
        configurations, based on the active :attr:`~.Keithley2000.mode`. """"""
    )
    resistance_range = Instrument.control(
        "":SENS:RES:RANG?"", "":SENS:RES:RANG:AUTO 0;:SENS:RES:RANG %g"",
        """""" A floating point property that controls the 2-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_reference = Instrument.control(
        "":SENS:RES:REF?"", "":SENS:RES:REF %g"",
        """""" A floating point property that controls the 2-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_nplc = Instrument.control(
        "":SENS:RES:NPLC?"", "":SENS:RES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 2-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_digits = Instrument.control(
        "":SENS:RES:DIG?"", "":SENS:RES:DIG %d"",
        """""" An integer property that controls the number of digits in the 2-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    resistance_4W_range = Instrument.control(
        "":SENS:FRES:RANG?"", "":SENS:FRES:RANG:AUTO 0;:SENS:FRES:RANG %g"",
        """""" A floating point property that controls the 4-wire resistance range
        in Ohms, which can take values from 0 to 120 MOhms.
        Auto-range is disabled when this property is set. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_reference = Instrument.control(
        "":SENS:FRES:REF?"", "":SENS:FRES:REF %g"",
        """""" A floating point property that controls the 4-wire resistance
        reference value in Ohms, which can take values from 0 to 120 MOhms. """""",
        validator=truncated_range,
        values=[0, 120e6]
    )
    resistance_4W_nplc = Instrument.control(
        "":SENS:FRES:NPLC?"", "":SENS:FRES:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the 4-wire resistance measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    resistance_4W_digits = Instrument.control(
        "":SENS:FRES:DIG?"", "":SENS:FRES:DIG %d"",
        """""" An integer property that controls the number of digits in the 4-wire
        resistance readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ##################
    # Frequency (Hz) #
    ##################

    frequency = Instrument.measurement(
        "":READ?"",
        """""" Reads a frequency measurement in Hz, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    frequency_reference = Instrument.control(
        "":SENS:FREQ:REF?"", "":SENS:FREQ:REF %g"",
        """""" A floating point property that controls the frequency reference
        value in Hz, which can take values from 0 to 15 MHz. """""",
        validator=truncated_range,
        values=[0, 15e6]
    )
    frequency_digits = Instrument.control(
        "":SENS:FREQ:DIG?"", "":SENS:FREQ:DIG %d"",
        """""" An integer property that controls the number of digits in the frequency
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    frequency_threshold = Instrument.control(
        "":SENS:FREQ:THR:VOLT:RANG?"", "":SENS:FREQ:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the frequency measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    frequency_aperature = Instrument.control(
        "":SENS:FREQ:APER?"", "":SENS:FREQ:APER %g"",
        """""" A floating point property that controls the frequency aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ##############
    # Period (s) #
    ##############

    period = Instrument.measurement(
        "":READ?"",
        """""" Reads a period measurement in seconds, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    period_reference = Instrument.control(
        "":SENS:PER:REF?"", "":SENS:PER:REF %g"",
        """""" A floating point property that controls the period reference value
        in seconds, which can take values from 0 to 1 s. """""",
        validator=truncated_range,
        values=[0, 1]
    )
    period_digits = Instrument.control(
        "":SENS:PER:DIG?"", "":SENS:PER:DIG %d"",
        """""" An integer property that controls the number of digits in the period
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )
    period_threshold = Instrument.control(
        "":SENS:PER:THR:VOLT:RANG?"", "":SENS:PRE:THR:VOLT:RANG %g"",
        """""" A floating point property that controls the voltage signal threshold
        level in Volts for the period measurement, which can take values
        from 0 to 1010 V. """""",
        validator=truncated_range,
        values=[0, 1010]
    )
    period_aperature = Instrument.control(
        "":SENS:PER:APER?"", "":SENS:PER:APER %g"",
        """""" A floating point property that controls the period aperature in seconds,
        which sets the integration period and measurement speed. Takes values
        from 0.01 to 1.0 s. """""",
        validator=truncated_range,
        values=[0.01, 1.0]
    )

    ###################
    # Temperature (C) #
    ###################

    temperature = Instrument.measurement(
        "":READ?"",
        """""" Reads a temperature measurement in Celsius, based on the
        active :attr:`~.Keithley2000.mode`. """"""
    )
    temperature_reference = Instrument.control(
        "":SENS:TEMP:REF?"", "":SENS:TEMP:REF %g"",
        """""" A floating point property that controls the temperature reference value
        in Celsius, which can take values from -200 to 1372 C. """""",
        validator=truncated_range,
        values=[-200, 1372]
    )
    temperature_nplc = Instrument.control(
        "":SENS:TEMP:NPLC?"", "":SENS:TEMP:NPLC %g"",
        """""" A floating point property that controls the number of power line cycles
        (NPLC) for the temperature measurements, which sets the integration period
        and measurement speed. Takes values from 0.01 to 10, where 0.1, 1, and 10 are
        Fast, Medium, and Slow respectively. """"""
    )
    temperature_digits = Instrument.control(
        "":SENS:TEMP:DIG?"", "":SENS:TEMP:DIG %d"",
        """""" An integer property that controls the number of digits in the temperature
        readings, which can take values from 4 to 7. """""",
        validator=truncated_discrete_set,
        values=[4, 5, 6, 7],
        cast=int
    )

    ###########
    # Trigger #
    ###########

    trigger_count = Instrument.control(
        "":TRIG:COUN?"", "":TRIG:COUN %d"",
        """""" An integer property that controls the trigger count,
        which can take values from 1 to 9,999. """""",
        validator=truncated_range,
        values=[1, 9999],
        cast=int
    )
    trigger_delay = Instrument.control(
        "":TRIG:SEQ:DEL?"", "":TRIG:SEQ:DEL %g"",
        """""" A floating point property that controls the trigger delay
        in seconds, which can take values from 1 to 9,999,999.999 s. """""",
        validator=truncated_range,
        values=[0, 999999.999]
    )

    def __init__(self, adapter, name=""Keithley 2000 Multimeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )

    def measure_voltage(self, max_voltage=1, ac=False):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if ac:
            self.mode = 'voltage ac'
            self.voltage_ac_range = max_voltage
        else:
            self.mode = 'voltage'
            self.voltage_range = max_voltage

    def measure_current(self, max_current=10e-3, ac=False):
        """""" Configures the instrument to measure current,
        based on a maximum current to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_current: A current in Volts to set the current range
        :param ac: False for DC current, and True for AC current
        """"""
        if ac:
            self.mode = 'current ac'
            self.current_ac_range = max_current
        else:
            self.mode = 'current'
            self.current_range = max_current

    def measure_resistance(self, max_resistance=10e6, wires=2):
        """""" Configures the instrument to measure voltage,
        based on a maximum voltage to set the range, and
        a boolean flag to determine if DC or AC is required.

        :param max_voltage: A voltage in Volts to set the voltage range
        :param ac: False for DC voltage, and True for AC voltage
        """"""
        if wires == 2:
            self.mode = 'resistance'
            self.resistance_range = max_resistance
        elif wires == 4:
            self.mode = 'resistance 4W'
            self.resistance_4W_range = max_resistance
        else:
            raise ValueError(""Keithley 2000 only supports 2 or 4 wire""
                             ""resistance meaurements."")

    def measure_period(self):
        """""" Configures the instrument to measure the period. """"""
        self.mode = 'period'

    def measure_frequency(self):
        """""" Configures the instrument to measure the frequency. """"""
        self.mode = 'frequency'

    def measure_temperature(self):
        """""" Configures the instrument to measure the temperature. """"""
        self.mode = 'temperature'

    def measure_diode(self):
        """""" Configures the instrument to perform diode testing.  """"""
        self.mode = 'diode'

    def measure_continuity(self):
        """""" Configures the instrument to perform continuity testing. """"""
        self.mode = 'continuity'

    def _mode_command(self, mode=None):
        if mode is None:
            mode = self.mode
        return self.MODES[mode]

    def auto_range(self, mode=None):
        """""" Sets the active mode to use auto-range,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:RANG:AUTO 1"" % self._mode_command(mode))

    def enable_reference(self, mode=None):
        """""" Enables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 1"" % self._mode_command(mode))

    def disable_reference(self, mode=None):
        """""" Disables the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:STAT 0"" % self._mode_command(mode))

    def acquire_reference(self, mode=None):
        """""" Sets the active value as the reference for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:REF:ACQ"" % self._mode_command(mode))

    def enable_filter(self, mode=None, type='repeat', count=1):
        """""" Enables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        :param type: The type of averaging filter, either 'repeat' or 'moving'.
        :param count: A number of averages, which can take take values from 1 to 100
        """"""
        self.write("":SENS:%s:AVER:STAT 1"")
        self.write("":SENS:%s:AVER:TCON %s"")
        self.write("":SENS:%s:AVER:COUN %d"")

    def disable_filter(self, mode=None):
        """""" Disables the averaging filter for the active mode,
        or can set another mode by its name.

        :param mode: A valid :attr:`~.Keithley2000.mode` name, or None for the active mode
        """"""
        self.write("":SENS:%s:AVER:STAT 0"" % self._mode_command(mode))

    def local(self):
        """""" Returns control to the instrument panel, and enables
        the panel if disabled. """"""
        self.write("":SYST:LOC"")

    def remote(self):
        """""" Places the instrument in the remote state, which is
        does not need to be explicity called in general. """"""
        self.write("":SYST:REM"")

    def remote_lock(self):
        """""" Disables and locks the front panel controls to prevent
        changes during remote operations. This is disabled by
        calling :meth:`~.Keithley2000.local`.  """"""
        self.write("":SYST:RWL"")

    def reset(self):
        """""" Resets the instrument state. """"""
        self.write("":STAT:QUEUE:CLEAR;*RST;:STAT:PRES;:*CLS;"")

    def beep(self, frequency, duration):
        """""" Sounds a system beep.

        :param frequency: A frequency in Hz between 65 Hz and 2 MHz
        :param duration: A time in seconds between 0 and 7.9 seconds
        """"""
        self.write(f"":SYST:BEEP {frequency:g}, {duration:g}"")
"
414,57.0,"Shenzhen, China","Siglent’s SPD1168X Series Programmable Linear DC Power Supply has a 2.8 inch TFT-LCD (240 * 320) color display. The SPD1168X outputs up to 128 Watts of power and has a Voltage range of 0-16 V and Current range of 0-8 A. The Voltage resolution is 1 uV while the Current resolution is 1 mA.

Because higher currents supplied through smaller gauge wire or longer distances can cause a drop in voltage to the supplied load, the SPD1168X incorporates Remote Sensing in order to measure the actual supplied voltage at the load. The remote sensed voltage is fed back to the power supply and output voltage is adjusted almost instantaneously.",Siglent SPD 1168 X,504.0,"**iglent** is a China-based manufacturer specializing in electronic test & measurement instruments. Siglent founders began a preliminary study of digital oscilloscopes in 2002. It founded in 2007, and now Siglent has extended its product line to include digital oscilloscopes, function / arbitrary waveform generators, RF generators，digital multi-meters, DC power supplies, spectrum analyzers, spectrum & vector network analyzers, isolated handheld oscilloscopes, DC electronic loads and other general test instruments.Siglent also manufactured entry-level products for Lecroy.
",Pymeasure,Siglent Technologies,"[OrderedDict([('id', 'attzuZfmx06hyyd2m'), ('width', 500), ('height', 304), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6rfr-yNAPASVtUBWM90kTQ/NZEbagRadUjDIXKkFPP6J0eUX3aZWS3mG4UG_fCIHrmB18GydvusPRiPLPxsCbc1tMXe_gB4ivrpEL-6nyN65ZnVGKZbuhhRSEqJAdsyCck/e-TgR98p0y_1AdLljtY2nYSH3ctZ3okQJKO6uVjeaW8'), ('filename', 'New-Siglent-Logo.png'), ('size', 3479), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MWGbuhdnHluts1tr83KI2w/a7sRXTtX_SYigN6qqluRky0JPXzkxIvO8YPTbG9TJaOzsGq7HsSyTPc4V6nq03uYC7dg6gzd6QLj1jgt77Hbiw/O1aftFG75gQzakU4-TPAsSGuDi_xFnItguj2F_MkzQA'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r9C8oauPliGmoHScjFJXDA/wwJfM99TFDZmxySU-KxnRy9kFsRPkuWsAfTAqBkbPt6Zgt7FZzic8X60Yk9_D9qR92SC6-8evU8yYLMoPw43qA/ddzibM1DYi_YhddyclXr2si35RYFwOqWcGCbEc2fhS4'), ('width', 500), ('height', 304)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YALrWvjtXtlLW6y-xgPsmg/--hyRe3jfSaj_tPBt2HugZGe0J-n3npGfyE4v2FS50nuF51lPCaRnzBT5ogr5FD1yAorYiRHmUFbHQvrUk_kkw/OBqrPoila1EFvLVk-xbCpZryV0PQudHTHxIpXApS17o'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/,Write a Python script that uses Pymeasure to connect to a SPD1168X Power Supply Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",SPD1168X Power Supply,https://www.electrokit.com/uploads/productfile/41016/SPD1168X_DataSheet_DS0501X-E01A.pdf,"[OrderedDict([('id', 'attbpVCbnAzAHgkQv'), ('width', 799), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/34HUfbNQFbmXmuzSOBBLZA/JaIEh0fxeu6_9ViQzxssPuvvGubEnGB7FOOedLPsMlhBtMwHh9iuCBItBVSjofGYZMQJE7frVSr6b1yuePbP4fx7TMmMUy1GS5K1qWcCTcvUCVHxK0ECKp9YLvODmCQq/NMKXfDlVrxPXgqZvaI4s2MRPmm3ioB-Uxvk8lwoy9Y4'), ('filename', '81Ls3Y2LgBL._AC_UF894,1000_QL80_.jpg'), ('size', 85769), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4RSuljKjIEibFU_k7EwPZQ/hFBBorl5OGMjwtBjDc2_jj3tKD2xSJKGldbxqXLim2FZyPMzMXdD9wXA_NqX2r5Z7Z1XLgFPSwg-IFNSBFjxYg/VLRIMN1xfdJ4WkVLTeEpsRucqu-1v3Wwi3THDsWJtHU'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bWAGmfVt60Nu3KxXyKKgXg/UWM_YO23oQrtC27RCqlbEaj2hhTiXibFL9zYYhO20LdEtlvCiM7G-YGdb8VdOuDKJikNArXKvAwZlb37iIGlUw/96PerV5l6lHyW0gnRmWohBVFZUCDWPBAyGpHiMhuwjE'), ('width', 512), ('height', 641)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oacdD6ACvByMN38Q8DcMxw/2yhDf8d6NvLOY0Ui06e4bIQgob9MJDMWlUW_OJGlYC5yyrOD6ECle3YC3UWHq3QaOIubnfa9NN1O7QTnQBjpeA/VdjWTg6evcECafzUZNjav3f4p_n4G2nHzVrM1Z90--U'), ('width', 3000), ('height', 3000)]))]))])]",https://siglentna.com/product/spd1168x/,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/siglenttechnologies/siglent_spd1168x.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/siglenttechnologies/siglent_spd1168x.html,265.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
from pymeasure.instruments.instrument import Instrument
from pymeasure.instruments.siglenttechnologies.siglent_spdbase import (SPDSingleChannelBase,
                                                                       SPDChannel)


class SPD1168X(SPDSingleChannelBase):
    """"""Represent the Siglent SPD1168X Power Supply.
    """"""

    ch_1 = Instrument.ChannelCreator(SPDChannel, 1)

    def __init__(self, adapter, name=""Siglent Technologies SPD1168X Power Supply"", **kwargs):
        super().__init__(
            adapter,
            name,
            **kwargs
        )
"
426,367.3,"Abingdon, United Kingdom",MERC-IPS-120 MercuryIPS 120 A 10 V superconducting magnet power supply. The Mercury iPS is configurable and is made up of two units: The Mercury main unit E1-060 and Mercury secondary slave unit E1-061.,IPS 120  10,406.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Pymeasure,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Pymeasure to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/39370/IPS120-10.pdf,"[OrderedDict([('id', 'attmQ7Nb3HgLUBAiu'), ('width', 700), ('height', 700), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YlVX0yOi-N4XqQupowlBnA/o2DiGqEVds-hnkMK8aeHPHlDBznv0tRViuyDQQ7kuiCGWarePLCjjPbPNNYhtj70N5q1Z2oYba9T233LCKmkE5wpUOJLBj8e-q60b7LEgMw/1plFAxwuFcl9cGxJula250cJisiqVDLDlYpcThp_rL0'), ('filename', 'Mercury_IPS_E1-120.jpg'), ('size', 22336), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB6b6VbRWM3ictmwIRO57w/7WsEOUYCHSx4n-v_SSVfm8rJIp5vAsUzNAyl8h8EwxxdmUossmCsqyPqB6aPxoT6p4SKFwr7oMPSJqevGQz5rw/E8L9IhCVs5eTeMhuq2TGjxGfQAHz9aAIbQUwvcJ_G4o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l_lGrrvPtz-Hb6ZHQl1Wtg/e1qzCdR4uOUBq0qy-WzVakKRZAXCa4Oo1tdZdf4TNkdMPw3qqidANgH8DQ1toYrROU6wkBsb6rKLeo3ZpU4sFg/mYLeDMbeO6SPDaTi9b0RxC5NjSsavCxiItKaOqMOwd8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WPB0rBrdy_Q4acn_4MlPIg/Hs2PW0K1fyiuqcV8vb_-VRa3qsvkyj_ANwN0dlI37ELgopYyj2u9vMY014w-xibyzL49LqAeXanu1rordt7m2g/991DxuQzLzuKuQre9iDP37xeHpwNvYvtNmpuZ6fQmBE'), ('width', 3000), ('height', 3000)]))]))])]",https://estore.oxinst.com/eu/products/system-spares/magnet-systems/mercury-electronics-and-cables/zidE1-120,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/oxfordinstruments/ips120_10.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/oxfordinstruments/IPS120_10.html,,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


import logging
from time import sleep, time

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import strict_discrete_set
from pymeasure.instruments.validators import truncated_range

from .base import OxfordInstrumentsBase

# Setup logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class MagnetError(ValueError):
    """""" Exception that is raised for issues regarding the state of the magnet or power supply. """"""
    pass


class SwitchHeaterError(ValueError):
    """""" Exception that is raised for issues regarding the state of the superconducting switch. """"""
    pass


class IPS120_10(OxfordInstrumentsBase):
    """"""Represents the Oxford Superconducting Magnet Power Supply IPS 120-10.

    .. code-block:: python

        ips = IPS120_10(""GPIB::25"")  # Default channel for the IPS

        ips.enable_control()         # Enables the power supply and remote control

        ips.train_magnet([           # Train the magnet after it has been cooled-down
            (11.8, 1.0),
            (13.9, 0.4),
            (14.9, 0.2),
            (16.0, 0.1),
        ])

        ips.set_field(12)           # Bring the magnet to 12 T. The switch heater will
                                    # be turned off when the field is reached and the
                                    # current is ramped back to 0 (i.e. persistent mode).

        print(self.field)           # Print the current field (whether in persistent or
                                    # non-persistent mode)

        ips.set_field(0)            # Bring the magnet to 0 T. The persistent mode will be
                                    # turned off first (i.e. current back to set-point and
                                    # switch-heater on); afterwards the switch-heater will
                                    # again be turned off.

        ips.disable_control()       # Disables the control of the supply, turns off the
                                    # switch-heater and clamps the output.

    :param clear_buffer: A boolean property that controls whether the instrument
        buffer is clear upon initialisation.
    :param switch_heater_heating_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned on before the heater is expected to be heated.
    :param switch_heater_cooling_delay: The time in seconds (default is 20s) to wait after
        the switch-heater is turned off before the heater is expected to be cooled down.
    :param field_range: A numeric value or a tuple of two values to indicate the
        lowest and highest allowed magnetic fields. If a numeric value is provided
        the range is expected to be from :code:`-field_range` to :code:`+field_range`.
        The default range is -7 to +7 Tesla.

    """"""

    _SWITCH_HEATER_HEATING_DELAY = 20  # Seconds
    _SWITCH_HEATER_COOLING_DELAY = 20  # Seconds

    _SWITCH_HEATER_SET_VALUES = {
        False: 0,  # Heater off
        True: 1,  # Heater on, with safety checks
        ""Force"": 2,  # Heater on, without safety checks
    }
    _SWITCH_HEATER_GET_VALUES = {
        0: False,  # Heater off, Switch closed, Magnet at zero
        1: True,  # Heater on, Switch open
        2: False,  # Heater off, Switch closed, Magnet at field
        5: ""Heater fault, low heater current"",  # Heater on but current is low
        8: ""No switch fitted"",  # No switch fitted
    }

    def __init__(self,
                 adapter,
                 name=""Oxford IPS"",
                 clear_buffer=True,
                 switch_heater_heating_delay=None,
                 switch_heater_cooling_delay=None,
                 field_range=None,
                 **kwargs):

        super().__init__(
            adapter=adapter,
            name=name,
            **kwargs
        )

        if switch_heater_heating_delay is not None:
            self._SWITCH_HEATER_HEATING_DELAY = switch_heater_heating_delay
        if switch_heater_cooling_delay is not None:
            self._SWITCH_HEATER_COOLING_DELAY = switch_heater_cooling_delay

        if field_range is not None:
            if isinstance(field_range, (float, int)):
                self.field_setpoint_values = [-field_range, +field_range]
            elif isinstance(field_range, (list, tuple)):
                self.field_setpoint_values = field_range

        # Clear the buffer in order to prevent communication problems
        if clear_buffer:
            self.adapter.connection.clear()

    version = Instrument.measurement(
        ""V"",
        """""" A string property that returns the version of the IPS. """""",
    )

    control_mode = Instrument.control(
        ""X"", ""C%d"",
        """""" A string property that sets the IPS in `local` or `remote` and `locked`
        or `unlocked`, locking the LOC/REM button. Allowed values are:

        =====   =================
        value   state
        =====   =================
        LL      local & locked
        RL      remote & locked
        LU      local & unlocked
        RU      remote & unlocked
        =====   =================
        """""",
        preprocess_reply=lambda v: v[6],
        cast=int,
        validator=strict_discrete_set,
        values={""LL"": 0, ""RL"": 1, ""LU"": 2, ""RU"": 3},
        map_values=True,
    )

    current_measured = Instrument.measurement(
        ""R1"",
        """""" A floating point property that returns the measured magnet current of
        the IPS in amps. """""",
        dynamic=True,
    )

    demand_current = Instrument.measurement(
        ""R0"",
        """""" A floating point property that returns the demand magnet current of
        the IPS in amps. """""",
        dynamic=True,
    )

    demand_field = Instrument.measurement(
        ""R7"",
        """""" A floating point property that returns the demand magnetic field of
        the IPS in Tesla. """""",
        dynamic=True,
    )

    persistent_field = Instrument.measurement(
        ""R18"",
        """""" A floating point property that returns the persistent magnetic field of
        the IPS in Tesla. """""",
        dynamic=True,
    )

    switch_heater_status = Instrument.control(
        ""X"", ""H%d"",
        """""" An integer property that returns the switch heater status of
        the IPS. Use the :py:attr:`~switch_heater_enabled` property for controlling
        and reading the switch heater. When using this property, the user
        is referred to the IPS120-10 manual for the meaning of the integer
        values. """""",
        preprocess_reply=lambda v: v[8],
        cast=int,
    )

    @property
    def switch_heater_enabled(self):
        """""" A boolean property that controls whether the switch heater
        is enabled or not. When the switch heater is enabled (:code:`True`), the
        switch is closed and the switch is open and the current in the
        magnet can be controlled; when the switch heater is disabled
        (:code:`False`) the switch is closed and the current in the magnet cannot
        be controlled.

        When turning on the switch heater with :code:`True`, the switch heater is
        only activated if the current of the power supply matches the last
        recorded current in the magnet.

        .. warning::
            These checks can be omitted by using :code:`""Force""` in stead of
            :code:`True`. Caution: Not performing these checks can cause serious
            damage to both the power supply and the magnet.

        After turning on the switch heater it is necessary to wait several
        seconds for the switch the respond.

        Raises a :class:`.SwitchHeaterError` if the system reports a 'heater fault'
        or if no switch is fitted on the system upon getting the status.
        """"""
        status_value = self.switch_heater_status
        status = self._SWITCH_HEATER_GET_VALUES[status_value]

        if isinstance(status, str):
            raise SwitchHeaterError(
                ""IPS 120-10: switch heater status reported issue with ""
                ""switch heater: %s"" % status)

        return status

    @switch_heater_enabled.setter
    def switch_heater_enabled(self, value):

        status_value = self._SWITCH_HEATER_SET_VALUES[value]

        if status_value == 2:
            log.info(""IPS 120-10: Turning on the switch heater without any safety checks."")

        self.switch_heater_status = status_value

    current_setpoint = Instrument.control(
        ""R0"", ""I%f"",
        """""" A floating point property that controls the magnet current set-point of
        the IPS in ampere. """""",
        validator=truncated_range,
        values=[0, 120],  # Ampere
        dynamic=True,
    )

    field_setpoint = Instrument.control(
        ""R8"", ""J%f"",
        """""" A floating point property that controls the magnetic field set-point of
        the IPS in Tesla. """""",
        validator=truncated_range,
        values=[-7, 7],  # Tesla
        dynamic=True,
    )

    sweep_rate = Instrument.control(
        ""R9"", ""T%f"",
        """""" A floating point property that controls the sweep-rate of
        the IPS in Tesla/minute. """""",
        dynamic=True,
    )

    activity = Instrument.control(
        ""X"", ""A%d"",
        """""" A string property that controls the activity of the IPS. Valid values
        are ""hold"", ""to setpoint"", ""to zero"" and ""clamp"" """""",
        preprocess_reply=lambda v: v[4],
        cast=int,
        values={""hold"": 0, ""to setpoint"": 1, ""to zero"": 2, ""clamp"": 4},
        map_values=True,
    )

    sweep_status = Instrument.measurement(
        ""X"",
        """""" A string property that returns the current sweeping mode of the IPS. """""",
        preprocess_reply=lambda v: v[11],
        cast=int,
        values={""at rest"": 0, ""sweeping"": 1, ""sweep limiting"": 2, ""sweeping & sweep limiting"": 3},
        map_values=True,
    )

    @property
    def field(self):
        """""" Property that returns the current magnetic field value in Tesla.
        """"""

        try:
            heater_on = self.switch_heater_enabled
        except SwitchHeaterError as e:
            log.error(""IPS 120-10: Switch heater status reported issue: %s"" % e)
            field = self.demand_field
        else:
            if heater_on:
                field = self.demand_field
            else:
                field = self.persistent_field

        return field

    def enable_control(self):
        """""" Enable active control of the IPS by setting control to remote and
        turning off the clamp.
        """"""
        log.debug(""start enabling control"")
        self.control_mode = ""RU""

        # Turn off clamping if still clamping
        if self.activity == ""clamp"":
            self.activity = ""hold""

        # Turn on switch-heater if field at zero
        if self.field == 0:
            log.debug(""enabling switch heater"")
            self.switch_heater_enabled = True

    def disable_control(self):
        """""" Disable active control of the IPS (if at 0T) by turning off the switch heater,
        clamping the output and setting control to local.
        Raise a :class:`.MagnetError` if field not at 0T. """"""
        log.debug(""start disabling control"")
        if not self.field == 0:
            raise MagnetError(""IPS 120-10: field not at 0T; cannot disable the supply. "")

        log.debug(""disabling switch heater"")
        self.switch_heater_enabled = False
        self.activity = ""clamp""
        self.control_mode = ""LU""

    def enable_persistent_mode(self):
        """""" Enable the persistent magnetic field mode.
         Raise a :class:`.MagnetError` if the magnet is not at rest. """"""
        # Check if system idle
        log.debug(""enabling persistent mode"")
        if not self.sweep_status == ""at rest"":
            raise MagnetError(""IPS 120-10: magnet not at rest; cannot enable persistent mode"")

        if not self.switch_heater_enabled:
            log.debug(""magnet already in persistent mode"")
            return  # Magnet already in persistent mode
        else:
            self.activity = ""hold""
            self.switch_heater_enabled = False
            log.info(""IPS 120-10: Wait for for switch heater delay"")
            sleep(self._SWITCH_HEATER_COOLING_DELAY)
            self.activity = ""to zero""
            self.wait_for_idle()

    def disable_persistent_mode(self):
        """""" Disable the persistent magnetic field mode.
         Raise a :class:`.MagnetError` if the magnet is not at rest. """"""
        # Check if system idle
        log.debug(""disabling persistent mode"")
        if not self.sweep_status == ""at rest"":
            raise MagnetError(""IPS 120-10: magnet not at rest; cannot disable persistent mode"")

        # Check if the setpoint equals the persistent field
        if not self.field == self.field_setpoint:
            log.warning(""IPS 120-10: field setpoint and persistent field not identical; ""
                        ""setting the setpoint to the persistent field."")
            self.field_setpoint = self.field

        if self.switch_heater_enabled:
            log.debug(""magnet already in demand mode or at 0 field"")
            return  # Magnet already in demand mode or at 0 field
        else:
            log.debug(""set activity to 'to setpoint'"")
            self.activity = ""to setpoint""
            self.wait_for_idle()
            log.debug(""set activity to 'hold'"")
            self.activity = ""hold""
            log.debug(""enable switch heater"")
            self.switch_heater_enabled = True
            log.info(""IPS 120-10: Wait for for switch heater delay"")
            sleep(self._SWITCH_HEATER_HEATING_DELAY)

    def wait_for_idle(self, delay=1, max_wait_time=None, should_stop=lambda: False):
        """""" Wait until the system is at rest (i.e. current of field not ramping).

        :param delay: Time in seconds between each query into the state of the instrument.
        :param max_wait_time: Maximum time in seconds to wait before is at rest. If the system is
            not at rest within this time a :class:`TimeoutError` is raised. :code:`None` is
            interpreted as no maximum time.
        :param should_stop: A function that returns :code:`True` when this function should return
            early.
        """"""
        log.debug(""waiting for magnet to be idle"")
        start_time = time()

        while True:
            log.debug(""sleeping for %d s"", delay)
            sleep(delay)

            log.debug(""checking the status of the sweep"")
            status = self.sweep_status

            if status == ""at rest"":
                log.debug(""status is 'at rest', waiting is done"")
                break
            if should_stop():
                log.debug(""external function signals to stop waiting"")
                break

            if max_wait_time is not None and time() - start_time > max_wait_time:
                raise TimeoutError(""IPS 120-10: Magnet not idle within max wait time."")

    def set_field(self, field, sweep_rate=None, persistent_mode_control=True):
        """""" Change the applied magnetic field to a new specified magnitude.
        If allowed (via `persistent_mode_control`) the persistent mode will be turned off
        if needed and turned on when the magnetic field is reached.
        When the new field set-point is 0, the set-point of the instrument will not be changed
        but rather the `to zero` functionality will be used. Also, the persistent mode will not
        turned on upon reaching the 0T field in this case.

        :param field: The new set-point for the magnetic field in Tesla.
        :param sweep_rate: A numeric value that controls the rate with which to change
            the magnetic field in Tesla/minute.
        :param persistent_mode_control: A boolean that controls whether the persistent mode
            may be turned off (if needed before sweeping) and on (when the field is reached);
            if set to :code:`False` but the system is in persistent mode, a :class:`.MagnetError`
            will be raised and the magnetic field will not be changed.

        """"""

        # Check if field needs changing
        if self.field == field:
            return

        if self.switch_heater_enabled:
            pass  # Magnet in demand mode
            log.debug(""Magnet in demand mode, continuing"")
        else:
            # Magnet in persistent mode
            log.debug(""Magnet in persistent mode"")
            if persistent_mode_control:
                log.debug(""trying to disable persistent mode"")
                self.disable_persistent_mode()
            else:
                raise MagnetError(
                    ""IPS 120-10: magnet is in persistent mode but cannot turn off ""
                    ""persistent mode because persistent_mode_control == False. ""
                )

        if sweep_rate is not None:
            log.debug(""setting the sweep rate to %s"", sweep_rate)
            self.sweep_rate = sweep_rate

        if field == 0:
            log.debug(""setting activity to 'to zero' - running down the field"")
            self.activity = ""to zero""
        else:
            log.debug(""setting activity to 'to setpoint'"")
            self.activity = ""to setpoint""
            log.debug(""setting the field_setpoint to %d"", field)
            self.field_setpoint = field

        log.debug(""waiting for magnet to be finished"")
        self.wait_for_idle()
        log.debug(""sleeping for additional 10s (whatever the reason)"")
        sleep(10)

        if persistent_mode_control and field != 0:
            log.debug(
                ""persistent mode control is on, and setpoint_field !=0 - enabling persistent mode""
            )
            self.enable_persistent_mode()

    def train_magnet(self, training_scheme):
        """""" Train the magnet after cooling down. Afterwards, set the field
        back to 0 tesla (at last-used ramp-rate).

        :param training_scheme: The training scheme as a list of tuples; each
            tuple should consist of a (field [T], ramp-rate [T/min]) pair.
        """"""

        for (field, rate) in training_scheme:
            self.set_field(field, rate, persistent_mode_control=False)

        self.set_field(0)
"
429,24.9,"Sunnyvale, California",The SR510 is analog lock-in amplifiers which can measure AC signals as small as nanovolts in the presence of much larger noise levels.,SR 510,524.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",Pymeasure,SRS,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DX08usGjvnJBkvdHHhYk9A/Ae77gRakGMHNfTqleg_gK2RmfhmZ8TnU6CkFTq-QhV04pYYt3CIA1-M0G5j91V3CxvPLy-7iqKz9m9CaWmEnEnSDzPYD1BwYM-OMHf77iKw/mkND8FmArWFnxcicFTTUdCpwpJlIvs3XrBVGa87BIXY'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yD1ca115gu_SQ83dKE0emw/5XQdYHjDR2rN0zH6LKhJNyg_AEUnKQuYqjZFO6UfZqpZh3J0FIJiRuWgys4qUrcB-CsZDdapTRMem1vNFJ2l6w/QT7uPhb9kiI3fhKXBZKEsl29w5pe5akLQRiZ6YFuQM0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4Z3F4fMBHh13CjRUCwbcqw/yjovR8hh-b27dj3kTuO5eo_wkLicYPXlJ1YkHeDIUjQmf9QFtQtEdkIvcaCjrAqINx0aWWljOaEazgyqHVSCKA/YhAzqwCookM3Y1vcYlZexFNoWT_fe88vI8YAzybT1n4'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AggdRBatTfbcAgOj8TSG6g/w3adorfbdopR7_emfj-CqYgQo1iPqnK0RuD8bxuK8ka6uyaHcbX_tyXcHtgYjlVSRJx3EzLFkMcbtC3lUp0mOg/S55lqAqdhkgfzerGs1wQr_e9B_ktutyR26SoH0vXsm0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,Write a Python script that uses Pymeasure to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://www.thinksrs.com/downloads/pdfs/catalog/SR510530c.pdf,"[OrderedDict([('id', 'attTfE5nBuJLi6efo'), ('width', 3969), ('height', 1716), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-x3t4qD41PQ6ovGrMEOcDw/udzBFhMjXOIVIhh4NdXqEF68cDT096C9pQpdjaKizNV3CRHyCC0dAtphmDjXk1FS51Nc2mMNmLfkDfzHOuH_CgVCFZ34XEwXATiMRyDA0Is/dXoFYnzPeq2FPdsbRDC4ZppaGmNwTPLyAsuV2SRhPTo'), ('filename', 'SR530 Main Pic.jpg'), ('size', 1598439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mXue0I3ho8cW2IMUQalNqQ/V1nJKBN9bwbVUpImvaF-_J7iXj3X2UTgDvCERbiNoMEyoXWpMChDDOjCwECArENcVv-7E7ZCaG2RFNnQxlCeFA/XzDCZ8us9AmCbVuspAcbSVeOm0tLbvsSWo_jVLr5Izg'), ('width', 83), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YypQpbUPnD1FzPMh2TnOZg/xapJ8qShUxRYgukX95iv-oWWW8c4LCnKvZDHEKlCLbmcGbIYKujz03whI1UyziQEq4MavA5ox4mCw496Oa_3NQ/7uBSRpPKmoqG-Qlza7W3pgJpnWSNrXAOiD9ABGsSKqA'), ('width', 1184), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cvgFNLdHZTZcYfRTjpdTEA/NATTpIbCNKapQp-Yf-7og5AtOxik1dJCr8bKTGgDpQDjDMVlcAyhpovqQQPmlfgI7P2QRxUkKLWVrAAh624zrQ/yfkkQ2UfcMkIrkH7eAd3k9wkC4uvOYRKpmoF5RZzAMo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr510530.htm,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/srs/sr510.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/srs/sr510.html,2495.0,,,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from pymeasure.instruments.validators import truncated_range, truncated_discrete_set


class SR510(Instrument):
    TIME_CONSTANTS = {1e-3: 1, 3e-3: 2, 10e-3: 3, 30e-3: 4, 100e-3: 5,
                      300e-3: 6, 1: 7, 3: 8, 10: 9, 30: 10, 100: 11, }

    SENSITIVITIES = {10e-9: 1, 20e-9: 2, 50e-9: 3, 100e-9: 4, 200e-9: 5, 500e-9: 6,
                     1e-6: 7, 2e-6: 8, 5e-6: 9, 10e-6: 10, 20e-6: 11, 50e-6: 12, 100e-6: 13,
                     200e-6: 14, 500e-6: 15, 1e-3: 16, 2e-3: 17, 5e-3: 18, 10e-3: 19, 20e-3: 20,
                     50e-3: 21, 100e-3: 22, 200e-3: 23, 500e-3: 24, }

    phase = Instrument.control(
        ""P"", ""P %g"",
        """"""A float property that represents the SR510 reference to input
        phase offset in degrees. Queries return values between -180 and
        180 degrees. This property can be set with a range of values
        between -999 to 999 degrees. Set values are mapped internal in the
        lockin to -180 and 180 degrees."""""",
        validator=truncated_range,
        values=[-999, 999],
    )

    time_constant = Instrument.control(
        ""T1"", ""T1,%d"",
        """"""A float property that represents the SR510 PRE filter time constant.
        This property can be set."""""",
        validator=truncated_discrete_set,
        values=TIME_CONSTANTS,
        map_values=True,
    )

    sensitivity = Instrument.control(
        ""G"", ""G%d"",
        """"""A float property that represents the SR510 sensitivity value.
           This property can be set."""""",
        validator=truncated_discrete_set,
        values=SENSITIVITIES,
        map_values=True,
    )

    frequency = Instrument.measurement(
        ""F"",
        """"""A float property representing the SR510 input reference frequency"""""",
    )

    status = Instrument.measurement(
        ""Y"",
        """"""A string property representing the bits set within the SR510 status byte"""""",
        get_process=lambda s: bin(int(s))[2:],
    )

    output = Instrument.measurement(
        ""Q"",
        """"""A float property that represents the SR510 output voltage in Volts."""""",
    )

    def __init__(self, adapter, name=""Stanford Research Systems SR510 Lock-in amplifier"",
                 **kwargs):
        kwargs.setdefault('write_termination', '\r')
        super().__init__(
            adapter,
            name,
            includeSCPI=False,
            **kwargs,
        )
"
