,Device datasheet (PDF),Category description link,Device picture,"Yearly revenue (millions, USD)",Vendor headquarters,Device Description,Device Description Link,Device,Field 1,Device Category,Category Description,Vendor wikipedia or cruncbase description,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Library,Python docs link,Vendor,Vendor logo,Vendor website,Corrected device name,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,Notes,docstring
0,could not find,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attN3qKogpCndO3Cx'), ('width', 250), ('height', 1011), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RRwFlVSpZHk-ird2rmULhA/ch8WrUALmzHfFf4RtARlnDVa2Rqz82B0daNUVuHfiWdFCucHEGTMxHbt-DlP95pPEQPKw_IO8PyzgF4vG7P3QmUjSXhjJ0cCnYawbHOuWZU/DEDrSTsxAatHLOHFeUgUIll9SFXgWcX7jIf-01AgdZg'), ('filename', 'FrontD5a.png'), ('size', 297423), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/62txvenm89uQ0YzPlNRtbg/WenulH9EHlQYq9k9Uecn3Fyz0WaQcBZVNhqFh8Msf4SRuVkim6bumlMZwAjhwETREncrqyvfvjlUq0s1V4HlEA/2q2-jALFmKLCO0Hp7wgvNC4Bja5nhHATzu5J4IDPALY'), ('width', 9), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iBxtc8Ztr44utzpnyn8nWg/oO2NkAVNxIccbmH9AJZb28yvPeAvUUp7hD7dwxvecJavPgRSkQKarWSHESdbUNKRWUISoB6-dVDHEVFyacqERw/jCNFIxKROdY3rkX8c-XCR-HRDwwPcuq55TV7tDN4lQQ'), ('width', 250), ('height', 1011)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XNFSkuBUOmzFg__syLQc6Q/pLKpaG2J2uxezbw9BBA0L9NdS6gtKX4aP1XW3aBt0FPR-kULtaGpzUGwnsznZEOAL960XqfZFqY9lc1HEBl0jA/FQtaKvAJ_b8kQ0PnldagririQDsifziTtx-soOFjuv0'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands","The D5a module contains 16 18-bit DACs (Digital to Analog Converters), initially created for setting gate-voltages on samples. In contrast to most commercial units, there are no processor or clock circuits present in this module. This to prevent interference. The only time any digital signals are present is when the DAC values are being changed. Afterwards the module goes back to being static. The DAC values are set via the controller module. As this module is generally used for gate voltage control, the use of an isolated controller module (C1b/C2 combination) is recommended.

",https://qtwork.tudelft.nl/~mtiggelman/modules/v-source/d5a.html,D5A,436.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/D5a.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.D5a,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,D5a,Write a Python script that uses Qcodes Community to connect to a D5a Power Supplies,,,,,"from qcodes.instrument.base import Instrument
from qcodes.utils.validators import Enum, Numbers

try:
    from spirack import D5a_module
except ImportError:
    raise ImportError(('The D5a_module class could not be found. '
                       'Try installing it using pip install spirack'))

from functools import partial


class D5a(Instrument):
    """"""
    Qcodes driver for the D5a DAC SPI-rack module.

    functions:
    -   set_dacs_zero   set all DACs to zero voltage

    parameters:
    -   dacN:       get and set DAC voltage
    -   stepsizeN   get the minimum step size corresponding to the span
    -   spanN       get and set the DAC span: '4v uni', '4v bi', or '2.5v bi'

    where N is the DAC number from 1 up to 16

    """"""

    def __init__(self, name, spi_rack, module, inter_delay=0.1, dac_step=10e-3,
                 reset_voltages=False, mV=False, number_dacs=16, **kwargs):
        """""" Create instrument for the D5a module.

        The D5a module works with volts as units. For backward compatibility
        there is the option to allow mV for the dacX parameters.

        The output span of the DAC module can be changed with the spanX
        command. Be carefull when executing this command with a sample
        connected as voltage jumps can occur.

        Args:
            name (str): name of the instrument.

            spi_rack (SPI_rack): instance of the SPI_rack class as defined in
                the spirack package. This class manages communication with the
                individual modules.

            module (int): module number as set on the hardware.
            inter_delay (float): time in seconds, passed to dac parameters of the object
            dac_step (float): max step size (V or mV), passed to dac parameters of the object
            reset_voltages (bool): passed to D5a_module constructor
            mV (bool): if True, then use mV as units in the dac parameters
            number_dacs (int): number of DACs available. This is 8 for the D5mux
        """"""
        super().__init__(name, **kwargs)

        self.d5a = D5a_module(spi_rack, module, reset_voltages=reset_voltages)
        self._number_dacs = number_dacs

        self._span_set_map = {
            '4v uni': 0,
            '4v bi': 2,
            '2v bi': 4,
        }

        self._span_get_map = {v: k for k, v in self._span_set_map.items()}

        self.add_function('set_dacs_zero', call_cmd=self._set_dacs_zero,
                          docstring='Reset all dacs to zero voltage. No ramping is performed.')

        if mV:
            self._gain = 1e3
            unit = 'mV'
        else:
            self._gain = 1
            unit = 'V'

        for i in range(self._number_dacs):
            validator = self._get_validator(i)

            self.add_parameter('dac{}'.format(i + 1),
                               label='DAC {}'.format(i + 1),
                               get_cmd=partial(self._get_dac, i),
                               set_cmd=partial(self._set_dac, i),
                               unit=unit,
                               vals=validator,
                               step=dac_step,
                               inter_delay=inter_delay)

            self.add_parameter('stepsize{}'.format(i + 1),
                               get_cmd=partial(self.d5a.get_stepsize, i),
                               unit='V',
                               docstring='Returns the smallest voltage step of the DAC.')

            self.add_parameter('span{}'.format(i + 1),
                               get_cmd=partial(self._get_span, i),
                               set_cmd=partial(self._set_span, i),
                               vals=Enum(*self._span_set_map.keys()),
                               docstring='Change the output span of the DAC. This command also updates the validator.')

    def set_dac_unit(self, unit: str) -> None:
        """"""Set the unit of dac parameters""""""
        allowed_values = Enum('mV', 'V')
        allowed_values.validate(unit)
        self._gain = {'V': 1, 'mV': 1e3}[unit]
        for i in range(1, self._number_dacs + 1):
            setattr(self.parameters[f'dac{i}'], 'unit', unit)
            setattr(self.parameters[f'dac{i}'], 'vals', self._get_validator(i - 1))

    def _set_dacs_zero(self):
        for i in range(self._number_dacs):
            self._set_dac(i, 0.0)

    def _set_dac(self, dac, value):
        return self.d5a.set_voltage(dac, value / self._gain)

    def _get_dac(self, dac):
        return self._gain * self.d5a.voltages[dac]

    def _get_span(self, dac):
        return self._span_get_map[self.d5a.span[dac]]

    def _set_span(self, dac, span_str):
        self.d5a.change_span_update(dac, self._span_set_map[span_str])
        self.parameters['dac{}'.format(
            dac + 1)].vals = self._get_validator(dac)

    def _get_validator(self, dac):
        span = self.d5a.span[dac]
        if span == D5a_module.range_2V_bi:
            validator = Numbers(-2 * self._gain, 2 * self._gain)
        elif span == D5a_module.range_4V_bi:
            validator = Numbers(-4 * self._gain, 4 * self._gain)
        elif span == D5a_module.range_4V_uni:
            validator = Numbers(0, 4 * self._gain)
        else:
            msg = 'The found DAC span of {} does not correspond to a known one'
            raise Exception(msg.format(span))

        return validator
"
1,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'att3LDHenICPFoo4H'), ('width', 336), ('height', 336), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Squ_iFYkBWWGTa81ZAoqwA/P2BhGIRjzIoY_t4W8yUx2MndvCVRNca0zpqXY32ttR7uVoTHFpgzA5Xj8iIZkh7GTMvILGBkAKx1HWuW222MwFdPE0AcyyESKXzu4yRigwM/G_LATf7OTfRy7pxS-RL1Q8ah_X7lOd28vvL-yoHWSec'), ('filename', 'vaunix-lda802-q.png'), ('size', 137129), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DOV2LLvSM5eAytrAXxnBQA/E3ZHF0psTJjze-yWlJeYcebr96IWUNv1jhSJZTYSH6HCE8NL1gB5s2o7N_hPMK7KD6T4chTw3q6ZZ9K-Hn24FQ/H3aDdXgOMIrYIaAQmYQIv7SsI-DlLlCkpfkCEu2nzEw'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/U0zTHK-HJbvm1cZvfByzzQ/RsZpQszbvjOMzAtKbsoKtjOjg4xmfWyjtBHlaln9McCG6hgIED9_VHWaGTiwFt_VGmkJs8eRNiUN9EzMuncgPA/i2yMNvi35tRpDPPBd0YSeh_Zj3MQ5OjjW5yqG44n970'), ('width', 336), ('height', 336)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Z2zWYpDUr-m-IINj1S4beg/oEjfYVEiirSPHEJbXzIzrQnt-LBeLOcqTOkJITft4XVMG9VsXlLh21Zxru-5dXo3zSV4OpeIP0s3kpg-M15roA/wckH6SdfPdWQHBPUaeyhsi8di3iNBaA7oMF6N1C1LOs'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802Q Digital Attenuator is a 4-channel high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802Q provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802q-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802Q,Write a Python script that uses Qcodes Community to connect to a LDA-802Q ,2995.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
12,https://www.batronix.com/pdf/Rohde-Schwarz/HMC804X/HMC804X_Datasheet_DE.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attfUxU1WRSQ3qyCD'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/INF_P_MyzyqQVSDl-XkA1Q/P36d-mesR87EDkvTQh9ARSodLKTw-3dtThwaVWkFZqsQ54D-76PC7hyJgq-7GuA_0yHkvqIx_rQNIZ2onP_Ly-EytWqba7BoVlXs7JuXtWzuFWiBypsgfLH_tJQBiglx_dP9G0z4pHjo7p4d0txUXFPK7s5q-xvEd88kEQIbxDk/Yv-PZmSadpgzKyjsHl-ZWRLFk0qnR3lc1coKao9u-YE'), ('filename', 'hmc804x-dc-power-supply-front-view-rohde-schwarz_200_979_640_360_1.jpg'), ('size', 39364), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/tUmoWaxyU1mjd21pSHNvag/KCw_fGYAxx8bXMcjczwxuj478Dgs79zLD8FLT9XjtBivAZq2q3SMxy16K9E-GTek5Z2VAW2gm1dgtb5KoVw30A/ZuUIp0D9dcczZ_EitxMRtt-Ox1eSJVnLqP5dfw7JTtg'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/k0DpQVBoOOcR7a7gNOfYwg/cyIt7zdakTe4ezjk45z2C4UUDh6PVZml3FtTO3XOiuLc85alSk1VGdzO35ruvFCmVtaZur9OVEHhet6DH8P7uA/nRVRM8rpE2heT7HptuHNL_ZViC68ckmPFUPzz_3kQW0'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/-pwDk_odte8bsAD07cGqUQ/-VUHrlzBh7S7QcKkfMLDn3wbnfXMhwYauuRN_MQCmg-sQ9I9QDFntTDtykTHGJUTJ_EVt4nRQhUmkXxkVef9Iw/rLyJEeWZRw1GWxeJg4bfTahMJYpfap2xnWINt1bNzAM'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","The R&S® HMC8041 offers a wide range of logging functions, an integrated energy meter and electronic fuses that can be individually combined for each channel, making it ideal for hardware developers, labs and industrial environments. Linear switching power supplies ensure high efficiency, for minimum heat dissipation even at full load.",https://www.batronix.com/shop/power-supplies/Rohde-Schwarz-HMC8041.html,HMC 8041,485.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMC8041.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMC8041,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMC 8041,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,,,,,"from .private.HMC804x import _RohdeSchwarzHMC804x

class RohdeSchwarzHMC8041(_RohdeSchwarzHMC804x):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMC8041 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, num_channels=1, **kwargs)
"
14,https://www.thinksrs.com/downloads/pdfs/catalog/DG645c.pdf,https://en.wikipedia.org/wiki/Pulse_generator,"[OrderedDict([('id', 'attQqnPuoAadlGes3'), ('width', 2000), ('height', 1435), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Q6aJzaTcQPEqDbgAOGkMTA/4OVimD1JpzfQQFktRvXInr5-xJIO22J0WPJsZlqzQb8As08MqHOZcjBXvaQG5z2vU3ZpaMMICwBEqdCvaEbJd238M9nXsyM7D_b1BSI_d6M/6hXPMsmDEAVv0XvuTJImukNxEQGy0hja4yAMwqCEnzk'), ('filename', 'DG645_Wide_Reflect.jpg'), ('size', 472623), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/V4ku1PDicrv_PiySf2ni5A/nfzagMIS43esVR9kT64dR2UlZASQF4_VOCgg96nN_pNBUOtbqOj8-Zuv4bdBtTSg4qR_-Suw8KFHyyB-h32p0g/fGRNGkhJzxJ-iRA5Kez9tCYgKfL91xFFpGUuQOFVLrA'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/yGdB39x0KX7HpXwMX8FYvQ/HzXoc03yhM6J8TAkFT5GA8cuM1NjC7VwnKebedjtoy0rj6fYPe6WBTipnduZxeSEHyo8EeQ_a5nF6s_2YvUnoA/YhG9u-bC20C0Cs5ni4A2jJUC2nNQAZU6uLeo17TLkus'), ('width', 714), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/A_oVwMEslrqxgnAg8FL1fA/dbpZi3Y6kEuLlvxxkiBtvQTbAqm9mjMcPRqrVcJ1mC7QTpcOtfDixvZDAzoYKuF6wEp2RkRWP4o0X-iqBL9gxA/Eq7Xk9pihaA7ZfSpF__krZqovOSly7wuWifnEPbxJiQ'), ('width', 3000), ('height', 3000)]))]))])]",24.9,"Sunnyvale, California","The DG645 is a versatile digital delay/pulse generator that provides precisely defined pulses at repetition rates up to 10 MHz. The instrument offers several improvements over older designs—lower jitter, higher accuracy, faster trigger rates, and more outputs. The DG645 also has Ethernet, GPIB and RS-232 interfaces for computer or network control of the instrument.",https://www.thinksrs.com/products/dg645.html,DG 645,537.0,['Pulse Generator'],A pulse generator is either an electronic circuit or a piece of electronic test equipment used to generate rectangular pulses. Pulse generators are used primarily for working with digital circuits; related function generators are used primarily for analog circuits.,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University. Stanford Research Systems manufactures all of their products at their Sunnyvale, California facility.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/StanfordResearchSystems/DG645.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.StanfordResearchSystems.html#module-qcodes_contrib_drivers.drivers.StanfordResearchSystems.DG645,Stanford Research,"[OrderedDict([('id', 'attv3bD8piC1qOU7u'), ('width', 119), ('height', 79), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wSwoS_UaYiTp9OEQtlPpkQ/rr8h1l5EzkJaYclqX-6953jsGIwiQE8Ofr4Tk8gRTc9PE1vWOa4X-1LCVu8SjKBzwhH0uClDohhJOtTw0x1Pe01Ya_-f_C233M_RI9Zqxvk/4JEMnf2XVRvxJufflL__81-8ulFA5_fa7t6_NK-B01M'), ('filename', 'download (6).png'), ('size', 1359), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/LrJYphDUKjdlqt6jHxMSIw/DIkHfPq6uoA8F2IkixPDRUoSDQ-tQLTtrBU6Cv7ESnPZBy-PU9GPJJGSQqxZZEOvMNhv_HZ2wBDMDSjQ2NYWvQ/Cwix1tcUvqavD6ZcSaehV9CY3i8ZP4vrg2O1gton49k'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NgbnjVcWoVTbPEQnfSZptw/dSfBDVyQH1mqy1OOx5XrCt2J9JvBGRh2YSIHPthdivuLgs7xOtVxPNT0v-gc6fEL_gndf33are7MKkAmKSiWdQ/xwfzJuALkW4pHD47kRT2PShy7JG8ZM9evxw71cnswtk'), ('width', 119), ('height', 79)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MO9FQ4xHx6hDfHuZ7RoR-Q/5YoyvPdz6oLPR0-GSZ_skE5FEYbF_Ebnx2OrR_DMqzjRVupj8gIKpfXnG84Ez8iDSprW625ZTQTLdGMEVif5Mw/QonH75jd3rhfnEXyXkPZ27M4wPN2FBm5A5EyXj0FPAM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/index.html,DG 645,Write a Python script that uses Qcodes Community to connect to a {Device name} Pulse Generator,4695.0,,,,"import logging
log = logging.getLogger(__name__)

from qcodes import VisaInstrument
import qcodes.utils.validators as vals

class DG645(VisaInstrument):
    """"""Qcodes driver for SRS DG645 digital delay generator.
    """"""
    CHANNEL_MAPPING = {
        'T0': 0, 'T1': 1, 'A': 2, 'B': 3, 'C': 4,
        'D': 5, 'E': 6, 'F': 7, 'G': 8, 'H': 9
    }
    OUTPUT_MAPPING = {'T0': 0, 'AB': 1, 'CD': 2, 'EF': 3, 'GH': 4}
    PRESCALE_MAPPING = {'trig': 0, 'AB': 1, 'CD': 2, 'EF': 3, 'GH': 4}
    TRIGGER_MAPPING = {
        'internal': 0,
        'ext_rising': 1,
        'ext_falling': 2,
        'single_ext_rising': 3,
        'single_ext_falling': 4,
        'single': 5,
        'line': 6,
    }
    POLARITY_MAPPING = {'-': 0, '+': 1}
    DISPLAY_MAPPING = {
        'trig_rate': 0,
        'trig_thresh': 1,
        'trig_single_shot': 2,
        'trig_line': 3,
        'advanced_trig_enable': 4,
        'trig_holdoff': 5,
        'prescale_config': 6,
        'burst_mode': 7,
        'burst_delay': 8,
        'burst_count': 9,
        'burst_period': 10,
        'channel_delay': 11,
        'channel_output_levels': 12,
        'channel_output_polarity': 13,
        'burst_T0_config': 14
    }
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, terminator='\r\n', timeout=10, **kwargs)
        self.add_parameter('trig_holdoff',
            label='Trigger holdoff',
            unit='s',
            get_cmd='HOLD?',
            get_parser=float,
            set_cmd='HOLD {}'
        )

        # Prescale parameters
        for channel, idx in self.PRESCALE_MAPPING.items():
            if idx > 0:
                self.add_parameter(
                    f'phase_{channel}',
                    label=f'{channel} prescale phase factor {k}',
                    get_cmd=f'PHAS?{idx}',
                    get_parser=int,
                    set_cmd=f'PHAS {idx},{{}}',
                    vals=vals.Ints(min_value=0),
                    docstring=""""""\
                    The prescale phase factor determines the phase at which the associated output is
                    enabled. The output is enabled when the prescaler counter equals the phase
                    factor. 
                    """"""
                )

            self.add_parameter(
                f'prescale_{channel}',
                label=f'{channel} prescale factor',
                get_cmd=f'PRES?{idx}',
                get_parser=int,
                set_cmd=f'PRES {idx},{{}}',
                vals=vals.Ints(min_value=0),
                docstring=""""""\
                A prescaler on the trigger input enables one to generate
                delay cycles at a sub-multiple of the trigger input frequency.
                """"""
            )

        # Trigger parameters
        self.add_parameter(
            'trigger_level',
            label='Trigger level',
            unit='V',
            get_cmd='TLVL?',
            get_parser=float,
            set_cmd='TLVL {}',
            vals=vals.Numbers()
        )
        self.add_parameter(
            'trigger_rate',
            label='Trigger rate',
            unit='Hz',
            get_cmd='TRAT?',
            get_parser=float,
            set_cmd='TRAT {}',
            vals=vals.Numbers(min_value=0)
        ) 
        self.add_parameter(
            'trigger_source',
            label='Trigger source',
            get_cmd=self._get_trigger_source,
            get_parser=str,
            set_cmd=self._set_trigger_source,
            vals=vals.Enum(*tuple(self.TRIGGER_MAPPING))
        )

        # Burst parameters
        self.add_parameter(
            'burst_count',
            label='Burst count',
            get_cmd='BURC?',
            get_parser=int,
            set_cmd='BURC {}',
            vals=vals.Ints(min_value=0)
        )
        self.add_parameter(
            'burst_delay',
            label='Burst delay',
            unit='s',
            get_cmd='BURD?',
            get_parser=float,
            set_cmd='BURD {}',
            vals=vals.Numbers(min_value=0)
        )
        self.add_parameter(
            'burst_period',
            label='Burst period',
            unit='s',
            get_cmd='BURP?',
            get_parser=float,
            set_cmd='BURC {}',
            vals=vals.Numbers(min_value=100e-9, max_value=2000-10e-9)
        )
        self.add_parameter(
            'burst_T0_config',
            label='Burst T0 configuration',
            get_cmd='BURT?',
            get_parser=int,
            set_cmd='BURT {}',
            vals=vals.Enum(0,1)
        )

        # Channel parameters
        for ch, idx in self.CHANNEL_MAPPING.items():
            if idx > 1:
                self.add_parameter(
                    f'delay_{ch}',
                    label=f'{ch} delay',
                    unit='s',
                    get_cmd=f'DLAY?{idx}',
                    get_parser=str,
                    set_cmd=lambda src_delay, channel=ch: self._set_delay(src_delay, channel),
                    vals=vals.Strings(),
                    docstring=""""""\
                    Set/query they delay of this channel relative to another.
                    Arguments/returned values strings of the form
                    '{index_of_other_channel},{delay_in_seconds}'. For example, '2,+0.001'
                    indicates that this channel is delayed from channel A by 1 ms, since
                    self.CHANNEL_MAPPING['A'] == 2.
                    """"""
                )
                self.add_parameter(
                    f'channel_link_{ch}',
                    label=f'Channel linked to {ch}',
                    get_cmd=f'LINK?{idx}',
                    get_parser=int,
                    set_cmd=lambda target, source=ch: self._set_link(target, source),
                    vals=vals.Enum(*tuple(k for k in self.CHANNEL_MAPPING if k != 'T1'))
                )

        # Output parameters
        for out, idx in self.OUTPUT_MAPPING.items():
            self.add_parameter(
                f'amp_out_{out}',
                label=f'Output {out} amplitude',
                unit='V',
                get_cmd=f'LAMP?{idx}',
                get_parser=float,
                set_cmd=f'LAMP {idx},{{}}',
                vals=vals.Numbers()
            )
            self.add_parameter(
                f'offset_out_{out}',
                label=f'Output {out} offset',
                unit='V',
                get_cmd=f'LOFF?{idx}',
                get_parser=float,
                set_cmd=f'LOFF {idx},{{}}',
                vals=vals.Numbers()
            )
            self.add_parameter(
                f'polarity_out_{out}',
                label=f'Output {out} polarity',
                get_cmd=f'LPOL?{idx}',
                get_parser=int,
                set_cmd=f'LPOL {idx},{{}}',
                vals=vals.Enum(0,1),
                docstring='0 -> negative polarity, 1 -> positive polarity.'
            )

        self.snapshot(update=True)
        self.connect_message()

    def self_calibrate(self) -> None:
        """"""Run auto-calibration routine.
        """"""
        self.write('*CAL?')
        self.wait()

    def self_test(self) -> None:
        """"""Run self-test routine.
        """"""
        self.write('*TST?')
        self.wait()

    def reset(self) -> None:
        """"""Reset instrument.
        """"""
        log.info(f'Resetting {self.name}.')
        self.write('*RST')

    def save_settings(self, location: int) -> None:
        """"""Save instrument settings to given location.

        Args:
            location: Location to which to save the settings (in [1..9]).
        """"""
        log.info(f'Saving instrument settings to location {location}.')
        self.write(f'*SAV {location}')

    def trigger(self) -> None:
        """"""Initiates a single trigger if instrument is in single shot mode.
        """"""
        self.write('*TRG')

    def wait(self) -> None:
        """"""Wait for all prior commands to execute before continuing.
        """"""
        self.write('*WAI')

    def local(self) -> None:
        """"""Go to local.
        """"""
        self.write('LCAL')

    def remote(self) -> None:
        """"""Go to remote.
        """"""
        self.write('REMT')

    def _set_trigger_source(self, src: str) -> None:  
        self.write(f'TSRC {self.TRIGGER_MAPPING[src]}')

    def _get_trigger_source(self) -> str:
        response = self.ask('TSRC?')
        keys = self.TRIGGER_MAPPING.keys()
        values = self.TRIGGER_MAPPING.values()
        return list(keys)[list(values).index(int(response))]

    def _set_delay(self, src_delay: str, target: str) -> None:
        source, delay = [s.strip() for s in src_delay.split(',')]
        self.write('DLAY {},{},{}'.format(self.CHANNEL_MAPPING[target],
                                          self.CHANNEL_MAPPING[source],
                                          delay))

    def _set_link(self, target: str, source: str) -> None:
        self.write('LINK {},{}'.format(self.CHANNEL_MAPPING[target],
                                       self.CHANNEL_MAPPING[source]))
"
34,https://download.tek.com/datasheet/6430.pdf,https://en.wikipedia.org/wiki/Source_measure_unit,"[OrderedDict([('id', 'attpPpm7qoCPF1kNA'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XRZ1Q7m4syCXqbLOnCDzaQ/FviRcg08ZCIEFWcXRJLgpHbg89CLNN7Vh6haniR51x0rnIAu4PItDBDWa6OgBfWMzFIiTx3UcC5wQ4Ow9fFCq52K-UM4b6C771k72M8-yCcFdn7mw3gbscfFsnOZNA8f/H8Y6JDE5v24qD1DwMao6YKEQETP_wWwdtNgvyJcsNiU'), ('filename', 'keithely-electrometers-3.webp'), ('size', 20878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/621L4qB43aGonz0-1DhEgw/XMfyESWwRvphV0sqp3CkInriJ9rXWCtTZbXlA8rPzozvEG5KB2NLztssVIR3_9NL34z4WW23PD3GWGlquCMclDTJC9uwTfyTSve1UfGUa1Q/SQReNjB6VDg8-6rG9GT33fi_DiL_r7rrGzHTOF4py_M'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/bJUZ4E2PRlRTsvatO0K2RA/i0SpDtvVI91nbMkOCtDWHYdDh7ktzKesD9O0TPnyYMz6TQ9v2FhoU5JOZbeACP_FY86qFHyYcgodx9pQDoRLGrYg9anblh-zU6fFUaqhmdg/JFAaUF0khPKx36u2fX5E_Y9S0Nh9ks_O32C2DOC6wYM'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rSGBXfxd1VAB2F_nIRbL8A/fPC8kcwEnfwT1PMEytEAVkO0pqRTeqhYqsiz-bdg6FRObVG3PlmC0sWhOtCyBndfmaQEhLCqIXhTNpsW0Bx10p4vR85QxYPZUt4w_Fq-OyE/g8_kpH1UxSCxX7UCNdC-ISaJ-6PZyKQpGsIusi2AOOM'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States","he 6½-digit Model 6430 Sub-Femtoamp Remote SourceMeter SMU Instrument can measure current with 1aA sensitivity. Its low noise and drift performance make it ideal for research on single electron devices, highly resistive nanowires and nanotubes, polymers, and electrochemical applications.",https://www.tek.com/en/products/keithley/low-level-sensitive-and-specialty-instruments/electrometers,Keithley 6430,576.0,"['Multimeters', 'Power Supplies']","A source measure unit (SMU) is a type of electronic test equipment which, as the name indicates, is capable of both sourcing and measuring at the same time.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Tektronix/Keithley_6430.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Tektronix.html#module-qcodes_contrib_drivers.drivers.Tektronix.Keithley_6430,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/QPVtzM5SYPyX4cyx9RS99Q/Iele002qHLjDBLXxSIQySb-An3CQgHG6NbMRzBzDOlkoP62OcmSl7KWSxLswDnCWQDkdyI8QLmrpI5-y7WxPwYdXl5mCuPNxwMAqKj-NdG8N8XhYYMpwXdrPswqWlcBTCanZVyPPN4Shkh8Daf06yg/O1EN122cWlhh78b8E3YExiiMnyOhBvP6JnudpA8ZrmA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/LXY5STSOy2Npxsiuhk-xBg/si_E4nA6QkcCdXIZi5Px9y3dW8Cb-SjqxeJgmUodL1_71wJHbMUwn3el6GMCKx16SKkN4eG2DwhdrrJYtsy4pA/8z5wIYmnlMh7BKMm3KvtBO92LqDlzbH8gaWhSCkgWvM'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/apmzFxlLL9nIzXQ0l4JyXw/Ve9T8HOmycIG_AHTx9YaEhezJKA3ZYjyyizLyjH2c-nu6fxheXT35IHiUEP7EXA_dl1xkQ1W6Nvu7Wkh6HqxfA/2IjZUiexy8-1qJZwuoHBltrIG1e5TUKuevSnB3tT5KA'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cH97XHVZwLscM2rr0YltQQ/hpCwJ0CnTaUR87FRosIXMlvNLJAWCoIUv264hfQnVsYiVQUibv2HIFXz8ELjR8uqD9qAJQCBHXh7FQlr8MKqTQ/NyPHa7Q9k0s3l8teuL24swVPEeYh4Wi0IkQncPSW-hM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Keithley 6430,"Write a Python script that uses Qcodes Community to connect to a {Device name} Multimeters, Power Supplies",23000.0,,,,"# Qcodes driver Keithley 6430 SMU
# Based on QtLab legacy driver
# https://github.com/qdev-dk/qtlab/blob/master/instrument_plugins/Keithley_6430.py
from typing import List, Tuple

from qcodes.instrument.visa import VisaInstrument
from qcodes.utils.validators import Ints, Numbers, Bool, Strings, Enum
from qcodes.utils.helpers import create_on_off_val_mapping
import logging
import warnings
from functools import partial

log = logging.getLogger(__name__)

on_off_vals = create_on_off_val_mapping(on_val=1, off_val=0)


class Keithley_6430(VisaInstrument):

    r""""""
    This is the Qcodes driver for the Keithley 6430 SMU.

    Args:
        name: The name used internally by QCoDeS
        address: Network address or alias of the instrument
        terminator: Termination character in VISA communication
        reset: resets to default values
    """"""
    def __init__(self, name: str,
                 address: str,
                 terminator=""\n"",
                 reset: bool = False,
                 **kwargs):

        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter('source_current_compliance',
                           unit='A',
                           get_parser=float,
                           set_cmd='SENS:CURR:PROT {}',
                           get_cmd='SENS:CURR:PROT?',
                           vals=Numbers(1e-9, 105e-3)
                           )
        self.add_parameter('source_voltage_compliance',
                           unit='V',
                           get_parser=float,
                           set_cmd='SENS:VOLT:PROT {}',
                           get_cmd='SENS:VOLT:PROT?',
                           vals=Numbers(1e-12, 210)
                           )
        self.add_parameter('source_current_compliance_tripped',
                           get_cmd='SENS:CURR:PROT:TRIP?',
                           val_mapping=on_off_vals,
                           docstring='True if current has reached specified '
                                     'compliance.',
                           )
        self.add_parameter('source_voltage_compliance_tripped',
                           get_cmd='SENS:VOLT:PROT:TRIP?',
                           val_mapping=on_off_vals,
                           docstring='True if voltage has reached specified '
                                     'compliance.',
                           )
        self.add_parameter('source_current',
                           unit='A',
                           get_parser=float,
                           label='Source current',
                           set_cmd='SOUR:CURR:LEV {}',
                           get_cmd='SOUR:CURR:LEV?',
                           vals=Numbers(-105e-3, 105e-3),
                           docstring='When in current sourcing mode, tries to '
                                     'set current to this level.',
                           )
        self.add_parameter('sense_current',
                           unit='A',
                           get_parser=float,
                           label='Measured current',
                           get_cmd=partial(self._read_value, 'CURR:DC'),
                           snapshot_get=False,
                           docstring='Value of measured current, when in '
                                     'current sensing mode.',
                           )
        self.add_parameter('sense_voltage',
                           unit='V',
                           get_parser=float,
                           label='Measured voltage',
                           get_cmd=partial(self._read_value, 'VOLT:DC'),
                           snapshot_get=False,
                           docstring='Value of measured voltage, when in '
                                     'voltage sensing mode.',
                           )
        self.add_parameter('sense_resistance',
                           unit='Ohm',
                           get_parser=float,
                           label='Measured resistance',
                           get_cmd=partial(self._read_value, 'RES'),
                           snapshot_get=False,
                           docstring='Value of measured resistance, when in '
                                     'resistance sensing mode.',
                           )
        self.add_parameter('source_current_range',
                           unit='A',
                           get_parser=float,
                           set_cmd='SOUR:CURR:RANG {}',
                           get_cmd='SOUR:CURR:RANG?',
                           vals=Numbers(1e-12, 105e-3)
                           )
        self.add_parameter('source_voltage',
                           unit='V',
                           get_parser=float,
                           label='Source voltage',
                           set_cmd='SOUR:VOLT:LEV {}',
                           get_cmd='SOUR:VOLT:LEV?',
                           vals=Numbers(-210, 210),
                           docstring='When in voltage sourcing mode, tries to '
                                     'set voltage to this level.',
                           )
        self.add_parameter('source_voltage_range',
                           unit='V',
                           get_parser=float,
                           set_cmd='SOUR:VOLT:RANG {}',
                           get_cmd='SOUR:VOLT:RANG?',
                           vals=Numbers(200e-3, 200)
                           )
        self.add_parameter('source_delay_auto',
                           set_cmd=':SOUR:DEL:AUTO {}',
                           get_cmd=':SOUR:DEL:AUTO?',
                           val_mapping=on_off_vals,
                           docstring=""Automatically set a delay period that ""
                                     ""is appropriate for the present ""
                                     ""source/measure setup configuration."",
                           )
        self.add_parameter('source_delay',
                           unit='s',
                           get_parser=float,
                           set_cmd=':SOUR:DEL {}',
                           get_cmd=':SOUR:DEL?',
                           vals=Numbers(0, 9999.998),
                           docstring=""Settling time after setting source ""
                                     ""value."",
                           )
        self.add_parameter('output_enabled',
                           set_cmd='OUTP {}',
                           get_cmd='OUTP?',
                           val_mapping=on_off_vals,
                           docstring='Turns the source on or off.',
                           )
        self.add_parameter('output_auto_off_enabled',
                           set_cmd=':SOUR:CLE:AUTO {}',
                           get_cmd='OUTP?',
                           val_mapping=on_off_vals,
                           )
        self.add_parameter('source_mode',
                           set_cmd='SOUR:FUNC {}',
                           get_cmd=self._get_source_mode,
                           vals=Enum('VOLT', 'CURR'),
                           docstring=""Either 'VOLT' to source voltage, ""
                                     ""or 'CURR' for current."",
                           )
        self.add_parameter('sense_mode',
                           set_cmd=self._set_sense_mode,
                           get_cmd=self._get_sense_mode,
                           vals=Strings(),
                           docstring=""Sensing mode.""
                                     ""Set to 'VOLT:DC', ""
                                     ""'CURR:DC', or 'RES', or a combination ""
                                     ""thereof by using comma."",
                           )
        self.add_parameter('sense_autorange',
                           set_cmd=self._set_sense_autorange,
                           get_cmd=self._get_sense_autorange,
                           vals=Bool(),
                           docstring=""If True, all ranges in all modes are""
                                     "" chosen automatically"",
                           )
        self.add_parameter('sense_current_range',
                           unit='A',
                           get_parser=float,
                           set_cmd=':SENS:CURR:RANG {}',
                           get_cmd=':SENS:CURR:RANG?',
                           vals=Numbers(1e-12, 1e-1),
                           )
        self.add_parameter('sense_voltage_range',
                           unit='V',
                           get_parser=float,
                           set_cmd=':SENS:VOLT:RANG {}',
                           get_cmd=':SENS:VOLT:RANG?',
                           vals=Enum(200, 20, 2, 0.2),
                           )
        self.add_parameter('sense_resistance_range',
                           unit='Ohm',
                           get_parser=float,
                           set_cmd=':SENS:RES:RANG {}',
                           get_cmd=':SENS:RES:RANG?',
                           vals=Numbers(2, 2e13),
                           )
        self.add_parameter('sense_resistance_offset_comp_enabled',
                           set_cmd=':SENS:RES:OCOM {}',
                           get_cmd=':SENS:RES:OCOM?',
                           val_mapping=on_off_vals,
                           docstring=""Set offset compensation on/off for ""
                                     ""resistance measurements."",
                           )
        self.add_parameter('trigger_source',
                           set_cmd=':TRIG:SOUR {}',
                           get_cmd=':TRIG:SOUR?',
                           vals=Enum('IMM', 'TLIN'),
                           docstring=""Specify trigger control source.""
                                     ""IMMediate or TLINk."",
                           )
        self.add_parameter('arm_source',
                           set_cmd=':ARM:SOUR {}',
                           get_cmd=':ARM:SOUR?',
                           vals=Enum('IMM', 'TLIN', ""TIM"", ""MAN"", ""BUS"",
                                     ""NST"", ""PST"", ""BST""),
                           docstring=""Specify arm control source.""
                                     ""IMMediate, or TLINk, TIMer, MANual,""
                                     "" BUS, NSTest, PSTest, or BSTest."",
                           )
        self.add_parameter('trigger_count',
                           set_cmd=':TRIG:COUN {}',
                           get_cmd=':TRIG:COUN?',
                           vals=Ints(),
                           docstring=""How many times to trigger."",
                           )
        self.add_parameter('arm_count',
                           set_cmd=':ARM:COUN {}',
                           get_cmd=':ARM:COUN?',
                           vals=Ints(),
                           docstring=""How many times to arm."",
                           )
        self.add_parameter('nplc',
                           get_parser=float,
                           set_cmd=':NPLC {}',
                           get_cmd=':NPLC?',
                           vals=Numbers(0.01, 10),
                           docstring=""Set integration time to the specified""
                                     ""value in Number of Powerline Cycles."",
                           )
        self.add_parameter('digits',
                           get_parser=int,
                           set_cmd='DISP:DIG  {}',
                           get_cmd='DISP:DIG?',
                           vals=Ints(4, 7),
                           docstring=""Display resolution."",
                           )
        self.add_parameter('autozero',
                           set_cmd='SYST:AZER:STAT {}',
                           get_cmd='SYST:AZER:STAT?',
                           val_mapping=on_off_vals,
                           docstring=""Enable autozero.""
                                     ""Enabling maximizes accuracy, ""
                                     ""disabling increases speed."",
                           )
        self.add_parameter('filter_auto',
                           set_cmd='AVER:AUTO {}',
                           get_cmd='AVER:AUTO?',
                           val_mapping=on_off_vals,
                           docstring=""Automatically choose filtering."",
                           )
        self.add_parameter('filter_repeat_enabled',
                           set_cmd=':AVER:REP:STAT {}',
                           get_cmd='AVER:AUTO?',
                           val_mapping=on_off_vals,
                           docstring=""Enable repeat filter."",
                           )
        self.add_parameter('filter_median_enabled',
                           set_cmd=':MED:STAT {}',
                           get_cmd=':MED:STAT?',
                           val_mapping=on_off_vals,
                           docstring=""Enable median filter."",
                           )
        self.add_parameter('filter_moving_enabled',
                           set_cmd=':AVER:STAT {}',
                           get_cmd=':AVER:STAT?',
                           val_mapping=on_off_vals,
                           docstring=""Enable moving average."",
                           )
        self.add_parameter('filter_repeat',
                           get_parser=int,
                           set_cmd=':AVER:REP:COUN {}',
                           get_cmd=':AVER:REP:COUN?',
                           vals=Ints(),
                           docstring=""Number of readings that are acquired""
                                     ""and stored in the filter buffer."",
                           )
        self.add_parameter('filter_median',
                           get_parser=int,
                           set_cmd=':MED:RANK {}',
                           get_cmd=':MED:RANK?',
                           vals=Ints(),
                           docstring=""Number of reading samples""
                                     "" for the median filter process."",
                           )
        self.add_parameter('filter_moving',
                           get_parser=int,
                           set_cmd=':AVER:COUN {}',
                           get_cmd=':AVER:COUN?',
                           vals=Ints(),
                           docstring=""Number of reading samples""
                                     "" in the moving average filter."",
                           )

        self.connect_message()

        if reset:
            self.reset()

    def reset(self) -> None:
        r""""""
        Resets instrument to default values
        """"""
        self.write('*RST')

    def read(self) -> Tuple[float, float, float]:
        """"""
        Arm, trigger, and readout. Note that the values may not be valid if
        sense mode doesn't include them.
        Returns:
            tuple of (voltage (V), current (A), resistance (Ohm))
        """"""
        if not (self.output_enabled() or self.output_auto_off_enabled()):
            raise Exception(
                    ""Either source must be turned on manually or ""
                    ""``output_auto_off_enabled`` has to be enabled before ""
                    ""measuring a sense parameter.""
                    )
        s = self.ask(':READ?')
        logging.debug(f'Read: {s}')

        v, i, r = [float(n) for n in s.split(',')][:3]
        return v, i, r

    def _read_value(self, quantity: str) -> float:
        """"""
        Read voltage, current or resistance through the sensing module.
        Issues a warning if reading a value that does not correspond to the
        sensing mode.
        Args:
            quantity: either ""VOLT:DC"", ""CURR:DC"" or ""RES""
        Returns:
            Measured value of the requested quantity.
        """"""
        mode_now = self.sense_mode()
        if quantity not in mode_now:
            warnings.warn(f""{self.short_name} tried reading {quantity}, but ""
                          f""mode is set to {mode_now}. Value might be out of ""
                          f""date."")
        mapping = {""VOLT:DC"": 0, ""CURR:DC"": 1, ""RES"": 2}
        return self.read()[mapping[quantity]]

    def init(self) -> None:
        """"""
        Go into the arm/trigger layers from the idle mode.
        """"""
        self.write(':INIT')

    def set_trigger_immediate(self) -> None:
        """"""
        Set trigger and arm modes to immediate.
        """"""
        self.trigger_source('IMM')
        self.arm_source('IMM')

    def _set_sense_mode(self, mode: str) -> None:
        """"""
        Set the sense_mode to the specified value
        Input:
            mode: mode(s) to be set. Choose from self._sense_modes.
            Use comma to separate multiple modes.
        """"""

        modes = [m.strip(' ') for m in mode.split(',')]

        if not all([m in [""RES"", ""CURR:DC"", ""VOLT:DC""] for m in modes]):
            raise ValueError(f'invalid sense_mode {modes}')

        modes_str = '""' + '"",""'.join(modes) + '""'

        string = f':SENS:FUNC {modes_str}'

        self.write(':SENS:FUNC:OFF:ALL')
        self.write(string)

    def _get_sense_mode(self) -> str:
        """"""
        Read the sense_mode from the device
        """"""
        string = 'SENS:FUNC?'
        ans = self.ask(string).replace('""', '')
        return ans

    def _get_source_mode(self) -> str:
        """"""
        Read the source_mode from the device
        """"""
        string = 'SOUR:FUNC?'
        ans = self.ask(string).strip('""')
        return ans

    def _set_sense_autorange(self, val: bool) -> None:
        """"""
        Switch sense_autorange on or off for all modes.
        """"""
        n = int(val)
        self.write(f'SENS:CURR:RANG:AUTO {n}')
        self.write(f'SENS:VOLT:RANG:AUTO {n}')
        self.write(f'SENS:RES:RANG:AUTO {n}')

    def _get_sense_autorange(self) -> bool:
        """"""
        Get status of sense_autorange. Returns true iff true for all modes
        """"""
        reply0 = bool(int(self.ask('SENS:CURR:RANG:AUTO?')))
        reply1 = bool(int(self.ask('SENS:VOLT:RANG:AUTO?')))
        reply2 = bool(int(self.ask('SENS:RES:RANG:AUTO?')))
        return reply0 and reply1 and reply2
"
36,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attEHHnQFKIW24UvA'), ('width', 394), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/no9xBP5On8uccGQGAI5PmA/Xmlzi-CkU9q1XJSxqB9fdjUq9A0BUhjMd1Jt5ZvXGAmbRk9_yBvL2j0sWge4HAhKcSSZXgZJyWN-XvF0CtruuSuMygQ0f43sEGQGQ0NTjHI/revBRokkkguKCUAcWHw08FFQ1binv1B0AS6E5se7dws'), ('filename', 'vaunix-lda-133.png'), ('size', 87729), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8xL8KAC_MJVTDL0_Tab7YQ/pc8EBvJwnRFGhvzn3WpiHC4drfuwhgCkivNaFoOotj_0jUglEaASHUYr7EO-COIaBCzPR0j38GclaPYJ20fqEw/mR0Nyvc5QXTfMoKcS2sh9R8L8I4a9uAmLYAoI-k9o-k'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FWFB94KLjTI7nXadznEjpQ/2lmzapCKmXEtnNVXTIeOuqXHODarbOAHTzA-Dqs8hWqoIsJu9dc4Hkn9Fo4FwO4K4Ny-l-5lzTNpuqqbfcXf-w/hNoZdVlQRFuuL-xmyD_W4D17PVeqa_jz0ZDVpXpDdmM'), ('width', 394), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5FA_HtrPjQVNASMeFX4JzQ/F9mais3CbTB3N-SWjsqQpEBw6XK7W4vWb_ebXaux9oVpBVMGvhtcxwyPL5OsZ-6kTtVaLBVoQCfFT_JR_GxiVg/4-iu7KQREp8fS7srZmnmmHuHLVjowEsPNY_p61o-C-g'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-5018V Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator. The LDA-5018V provides calibrated attenuation from 50 to 18000 MHz with an amazing step size of 0.1 dB and typical accuracy <1.0 dB over 50 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-5018v-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-5018V,Write a Python script that uses Qcodes Community to connect to a LDA-5018V ,899.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
40,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attONwl5TPTEPYUD9'), ('width', 359), ('height', 423), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/I6BtS6c4swfqM64MBj363Q/8BD4l9911CZGD-CFsYESzdgnhoN5fmHRPJ2qblyI-Npiikch2zrq_NsIwwmziFEiwzp5GTPmkOZ_ipgrAhBCC36MNkjg9lKYkSNW4aq8eEY/vDcZ0y1HP9El8fuuFWKyR-TUd9SK1NvluyDC3LJKmxc'), ('filename', 'vaunix-lda908v-4.png'), ('size', 77681), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XYP1RB5d1uVgde5uJTOeCQ/P5SOejQIrkhKrZ94RuHU9Ys-dREqssBfkegQXKTstU7pRQy8QJW3LJbrE9uayD2niTSNFwBsHz6Ucg3G16RnoQ/dmYG85WdZazKuudH9mWYebUCk8RZ0z5aPu9imgB3cq4'), ('width', 31), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/AqUiUm6DJRNn83akvmsCVQ/K9gfSHkphYYcYvkNz06mYg2jBh3SUMxjyVgPFz3PpfQkjvBWy7JFOTW3Ys1WhZA0Gva1GpiK2CpUIwx6a8Q7oQ/eWdAi2d_5mkCMAz5gZkaz3yGPlum5OpXOGFa-L_GsLY'), ('width', 359), ('height', 423)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vhxpgW92AwkWYX0ANAmZIg/jb5k4MZKvYOGetdtE2DNpUenQBnyNTJOR_Dj_frKu-tAlQ5WxiALNgXsUJTayX2ClFfTR0DMWmG5jkfY_c7q5A/pQlRDJPmjs3nnAvJ7U85RyqnqKGX_GDLebem0kZofnk'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-908V-4 Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator. The LDA-908V-4 provides calibrated attenuation from 1 to 8000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 90 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-908v-4-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-908V-4,Write a Python script that uses Qcodes Community to connect to a LDA-908V-4 ,2400.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
41,https://www.newport.com/mam/celum/celum_assets/np/resources/Agilis_Piezo_Motor_Driven_Components_User_Manual.pdf?1,https://en.wikipedia.org/wiki/Motion_control,"[OrderedDict([('id', 'att1f7U3syYdx6rGU'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/-NlGP-KpjyrUJ7J4sYcVvA/8TzynPGxjQsMChZYpwAdEhXEmJMhdblyn0gxUV-wYZvJrI-_SU9813BLdFXcr_PkinuyBMu8OJ_d9D8dtrfldAsZ8AmYyXb83VzgjigtTYo/aDRU4WC3IgactxacVDoX24MViTWzQvKL9Fcf0jXnfX4'), ('filename', 'AG-UC8_400w.jpg'), ('size', 15942), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/QuP8nH9ZM8V6JCCmn2M8xQ/ft1tZYmil85Vx8UXU85HTt7-ayt6z14-FGfvqgh5PiYKFiFRifFlctFV3VUqitLLBcGc8pZ1FHkotXMHhtF2Eg/vo_l5eGANQ7aw9TF5Xv9ug7SS4KsIK0RzDhvlopNFxc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6pmVw5Tvz7SM84Tfe8zh-w/7GDMH5JCAN-ynr7wnWPGN6t3mZv-CB1aRxr6_bSLDWT_oPi2etb4Uh-5ZXvHDFhZRBaYlBs9XJNj2mpTNI8wbA/zPYB4EL2nJtVAu4kfOZGiW2vENf97YAv-HsZhI16eoY'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1XEBT7OytaI-tqogCLjq-Q/o7x4Die8f3BjP002F7uh3GHIT20j3XzzGouZAzj_tehHbqx_hA52FyLkz92Z3A8abJlme8IDkUi-2oSrNzuuzQ/DYQirEcieMq8DpjLroDhPykUjMchviMuQ5ROk7F8h0g'), ('width', 3000), ('height', 3000)]))]))])]",3500.0,"Irvine, California, United States","The AG-UC8 Agilis™ Controller provides USB computer control of up to eight Agilis axes. Power is supplied through the same USB port used for communication. USB hubs may also be used for powering and communication, but must provide the required 5 V supply, e.g. must feature an external power supply. Two holes in the controller allow stacking of several controllers and attachment to optical tables.",https://www.newport.com/p/AG-UC8,AG UC 8,385.0,['Positional Controller'],"Motion control is a sub-field of automation, encompassing the systems or sub-systems involved in moving parts of machines in a controlled manner. Motion control systems are extensively used in a variety of fields for automation purposes, including precision engineering, micromanufacturing, biotechnology, and nanotechnology.[1] The main components involved typically include a motion controller, an energy amplifier, and one or more prime movers or actuators. Motion control may be open loop or closed loop. In open loop systems, the controller sends a command through the amplifier to the prime mover or actuator, and does not know if the desired motion was actually achieved. Typical systems include stepper motor or fan control. For tighter control with more precision, a measuring device may be added to the system (usually near the end motion). When the measurement is converted to a signal that is sent back to the controller, and the controller compensates for any error, it becomes a Closed loop System.","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Newport/AG_UC8.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/Newport_AG-UC8.html,Newport,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zfiB0FELBci0xen8fI0UJA/iMRyNfuMzSo_BNTFuAk4jV_hmEPgCZ2EyHX8tYJynCFxJxheqiQQ_hzOU1RaPsFONjPqsKYo56IpfQshd-bq8AESZ60BMIrnUl6oQ-GArPE/e58T5ZbHrzDg4kzl29dTH0wLCLsaqRG1aPn-09qCCC4'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/WjoQyTdBnqVqkuGYQYgHYA/22dptd1TbnXcF8HWG1ezvPRUDXHVBPLj11oXGufzR0LCuYHmaiR_Ro8enhAHB5xrarc4BtXUDEdHYJIaRg3ReQ/QxYiBhSu6Ii-idTRLBb2qcohnRqEUBUNlk1oEOc1EpQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DHU0uRjrT_JOkrjzOXe2HA/pK-vneWLLeDt5M8M6a9FZycUExIp79Rr8dGQweE6lid2KBE2Wo2ktCTSmoW2OdgRwZvs__LexOTtmjwllRZZNg/PsLLw3RHyc7oAJfGxEUm_5kw0tQnFHN8TCfLRhb0n8M'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4NL40gB_axyRkEBojV78cw/7GRpUjvMxgcv6MB2b6q5_EBtxdzJaHYJ_rOwC9GBg0w3-_Hzpe49fUSihtRvT4Y3HzjAAEi8BJKcUf3BuD-DZw/OrsiIRO7IfdpECyqETSN81rJZbt6bTJyTzuslKc9Zyo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newport.com/,AG UC 8,Write a Python script that uses Qcodes Community to connect to a {Device name} Positional Controller,1022.0,,,,"""""""
QCoDeS driver for Newport AGILIS AG-UC8 Piezo Stepper Controller.
""""""

import logging
import time
from typing import Optional, Dict, Callable

from pyvisa.resources.serial import SerialInstrument

from qcodes import VisaInstrument, InstrumentChannel, ChannelList
from qcodes.utils.validators import Ints

log = logging.getLogger(__name__)


# Meaning of error codes returned by the device.
ERROR_CODES = {
    0: ""No error"",
    -1: ""Unknown command"",
    -2: ""Axis out of range"",
    -3: ""Wrong format for parameter"",
    -4: ""Parameter out of range"",
    -5: ""Not allowed in local mode"",
    -6: ""Not allowed in current state"",
}


def _make_get_parser(cmd: str) -> Callable[[str], int]:
    """"""Return a parser function which expects a line
    starting with <cmd> followed by an integer, and returns
    only the integer.
    """"""

    def get_parser(resp: str) -> int:
        if resp.startswith(cmd):
            try:
                return int(resp[len(cmd):].strip())
            except ValueError:
                # Parsing return value failed.
                # Ignore the error here, we will report it below.
                pass
        log.warning(""Unexpected response from %s: %r"" % (cmd, resp))
        raise Newport_AG_UC8_Exception(""Unexpected response from %s: %r""
                                       % (cmd, resp))

    return get_parser


class Newport_AG_UC8_Exception(Exception):
    pass


class Newport_AG_UC8_ErrorCode(Newport_AG_UC8_Exception):
    def __init__(self, cmd: str, err: int) -> None:
        self.failed_command = cmd
        self.error_code = err
        error_string = ERROR_CODES.get(err, ""unknown error"")
        super().__init__(""Command %s failed with error code %d (%s)""
                         % (cmd, err, error_string))


class Newport_AG_UC8_Axis(InstrumentChannel):
    """"""Represents one of the 2 axes of one channel of an AG-UC8 controller.""""""

    SPEED_TABLE = {
        1: ""5 steps/second at defined step amplitude"",
        2: ""100 steps/second at maximum step amplitude"",
        3: ""1700 steps/second at maximum step amplitude"",
        4: ""666 steps/second at defined step amplitude"",
    }

    def __init__(self, parent: 'Newport_AG_UC8_Channel', axis: int) -> None:
        assert axis in (1, 2)
        super().__init__(parent, ""axis_%d"" % axis)

        self.axis = axis

        self.add_parameter(""step_delay"",
                           label=""Step delay in units of 10 us"",
                           get_cmd=""%dDL?"" % axis,
                           set_cmd=""%dDL{}"" % axis,
                           get_parser=_make_get_parser(""%dDL"" % axis),
                           vals=Ints(0, 200000))
        self.add_parameter(""step_amplitude_pos"",
                           label=""Step amplitude in positive direction"",
                           get_cmd=""%dSU+?"" % axis,
                           set_cmd=""%dSU+{}"" % axis,
                           get_parser=_make_get_parser(""%dSU+"" % axis),
                           vals=Ints(1, 50))
        self.add_parameter(""step_amplitude_neg"",
                           label=""Step amplitude in negative direction"",
                           get_cmd=""%dSU-?"" % axis,
                           set_cmd=""%dSU-{}"" % axis,
                           get_parser=_make_get_parser(""%dSU-"" % axis),
                           vals=Ints(1, 50))
        self.add_parameter(""steps"",
                           label=""Accumulated number of steps since last ""
                                 + ""reset of the step counter"",
                           get_cmd=""%dTP"" % axis,
                           get_parser=_make_get_parser(""%dTP"" % axis))
        self.add_parameter(""status"",
                           label=""Status of the axis"",
                           get_cmd=""%dTS"" % axis,
                           get_parser=_make_get_parser(""%dTS"" % axis),
                           val_mapping={""ready"": 0,
                                        ""stepping"": 1,
                                        ""jogging"": 2,
                                        ""moving_to_limit"": 3})

    def jog(self, speed: int) -> None:
        """"""Start moving in positive (speed > 0) or negative (speed < 0)
        direction.

        Args:
            speed (int): speed and direction of movement.
                Negative values (-1 .. -4) start moving in negative direction.
                Positive values (1 .. 4) start moving in positive direction.
                Magnitude determines speed according to
                Newport_AG_UC8_Axis.SPEED_TABLE.
        """"""
        assert speed >= -4 and speed <= 4
        self.write(""%dJA%d"" % (self.axis, speed))

    def move_limit(self, speed: int) -> None:
        """"""Start moving to positive (speed > 0) or negative (speed < 0) limit.

        Args:
            speed (int): speed and direction of movement.
                Negative values (-1 .. -4) start moving in negative direction.
                Positive values (1 .. 4) start moving in positive direction.
                Magnitude determines speed according to
                Newport_AG_UC8_Axis.SPEED_TABLE.
        """"""
        assert speed >= -4 and speed <= 4
        self.write(""%dMV%d"" % (self.axis, speed))

    def measure_position(self) -> int:
        """"""Measure current position.

        This is a slow command which may take up to 2 minutes to finish.

        Returns:
            int: Current position in range 0 .. 1000 representing
            steps of 1/1000 of total travel.
        """"""
        return self._slow_command(""%dMA"" % self.axis, """")

    def move_abs(self, position: int) -> int:
        """"""Move to absolute position.

        This is a slow command which may take up to 2 minutes to finish.

        Args:
            position (int): Target position in range 0 .. 1000 representing
                steps of 1/1000 of total travel.
        """"""
        assert position >= 0 and position <= 1000
        return self._slow_command(""%dPA"" % self.axis, ""%d"" % position)

    def move_rel(self, steps: int) -> None:
        """"""Start a relative move to current position.

        Args:
            steps (int): Number of steps to move relative to current position.
        """"""
        assert steps >= -(2**31) and steps < 2**31
        self.write(""%dPR%d"" % (self.axis, steps))

    def stop(self):
        """"""Stop current movement.""""""
        self.write(""%dST"" % self.axis)

    def zero_position(self):
        """"""Reset the step counter to zero.""""""
        self.write(""%dZP"" % self.axis)

    def _slow_command(self, cmd: str, arg: str) -> int:
        """"""Execute a slow command with longer timeout and parse
        return value.""""""

        # Temporarily set long timeout to support slow command.
        tmo = self.root_instrument.slow_command_timeout
        self.root_instrument.timeout(tmo)

        try:
            # Execute command.
            resp = self.ask(cmd + arg)
        finally:
            # Restore normal timeout.
            tmo = self.root_instrument.default_timeout
            self.root_instrument.timeout(tmo)

        # Parse response.
        if resp.startswith(cmd):
            try:
                return int(resp[len(cmd):].strip())
            except ValueError:
                # Parsing return value failed.
                # Ignore the error here, we will report it below.
                pass
        log.warning(""Unexpected response from %s: %r"" % (cmd, resp))
        raise Newport_AG_UC8_Exception(""Unexpected response from %s: %r""
                                       % (cmd, resp))


class Newport_AG_UC8_Channel(InstrumentChannel):
    """"""Represents one of the 4 channels of an AG-UC8 controller.

    Each channel drives 2 axes of an optical mount.
    """"""

    def __init__(self, parent: 'Newport_AG_UC8', channel_number: int) -> None:
        assert channel_number in (1, 2, 3, 4)
        super().__init__(parent, ""channel_%d"" % channel_number)

        self._channel_number = channel_number

        self.add_submodule(""axis1"", Newport_AG_UC8_Axis(self, 1))
        self.add_submodule(""axis2"", Newport_AG_UC8_Axis(self, 2))

        self.add_parameter(""limit_status"",
                           label=""Limit switch status"",
                           get_cmd=""PH"",
                           get_parser=_make_get_parser('PH'),
                           val_mapping={""not_active"": 0,
                                        ""active_on_axis_1"": 1,
                                        ""active_on_axis_2"": 2,
                                        ""active_on_both_axes"": 3})

    def write(self, cmd: str) -> None:
        return self.parent.write_channel(self._channel_number, cmd)

    def ask(self, cmd: str) -> str:
        return self.parent.ask_channel(self._channel_number, cmd)


class Newport_AG_UC8(VisaInstrument):
    """"""
    QCoDeS driver for the Newport AGILIS AG-UC8 Piezo Stepper Controller.

    Args:
        name (str): name of the instrument.

        address (str): VISA string describing the serial port,
            for example ""ASRL3"" for COM3.
    """"""

    # By default, expect response to command within 1 second.
    default_timeout = 1.0

    # Some commands (position measurement and absolute move) can take
    # up to 2 minutes to complete.
    slow_command_timeout = 120.0

    # After a command which does not generate a response, a short
    # delay is needed before we can send the following command.
    command_delay = 0.002

    # After a reset command, a longer delay is needed before
    # we can send the following command.
    reset_delay = 0.05

    def __init__(self, name: str, address: str) -> None:
        log.debug(""Opening Newport_AG_UC8 at %s"" % address)

        super().__init__(name,
                         address,
                         timeout=self.default_timeout,
                         terminator=""\r\n"")
        assert isinstance(self.visa_handle, SerialInstrument)
        self.visa_handle.baud_rate = 912600

        self._current_channel: Optional[int] = None

        channels = [Newport_AG_UC8_Channel(self, channel_number)
                    for channel_number in range(1, 4+1)]

        channel_list = ChannelList(self,
                                   ""channels"",
                                   Newport_AG_UC8_Channel,
                                   channels)

        self.add_submodule(""channels"", channel_list)

        self.add_function(""reset"",
                          call_cmd=self.reset,
                          args=())

        # Set controller in remote mode (otherwise many commands don't work).
        self.write(""MR"")

    def get_last_error(self) -> int:
        """"""Send a TE command (get error of previous command) and return
        a numerical error code.

        Returns:
            int: Error code for previous command.
            Value 0 means no error (success).
            See global table ERROR_CODES for the meaning of the codes.

        This function is called automatically after each command sent
        to the device. When a command results in error, exception
        Newport_AG_UC8_ErrorCode is raised.
        """"""
        resp = self.ask('TE')
        if resp.startswith(""TE""):
            try:
                return int(resp.strip()[2:])
            except ValueError:
                # Parsing error code failed.
                # Ignore the error here, we will report it below.
                pass
        log.warning(""Unexpected response to TE command: %r"" % resp)
        raise Newport_AG_UC8_Exception(""Unexpected response to TE command: %r""
                                       % resp)

    def reset(self) -> None:
        """"""Reset the motor controller.""""""
        self._current_channel = None
        # Send reset command.
        super().write(""RS"")
        # Sleep until reset completed.
        time.sleep(self.reset_delay)
        # Switch controller to remote mode (many commands require remote mode).
        self.write(""MR"")

    def get_idn(self) -> Dict[str, Optional[str]]:
        resp = self.ask(""VE"")
        words = resp.strip().split()
        if len(words) == 2:
            model = words[0]
            version = words[1]
        else:
            log.warning(""Unexpected response to VE command: %r"" % resp)
            raise Newport_AG_UC8_Exception(
                ""Unexpected response to VE command: %r"" % resp)
        return {""vendor"": ""Newport"",
                ""model"": model,
                ""firmware"": version}

    def write(self, cmd: str) -> None:
        # Send command.
        super().write(cmd)
        # Sleep until command completed.
        time.sleep(self.command_delay)
        # Check if command produced an error.
        err = self.get_last_error()
        if err != 0:
            log.warning(""Command %s failed with error %d"" % (cmd, err))
            raise Newport_AG_UC8_ErrorCode(cmd, err)

    def _select_channel(self, channel_number: int) -> None:
        """"""Make sure the specified channel is selected.""""""
        if self._current_channel != channel_number:
            # Switch to channel.
            super().write(""CC%d"" % channel_number)
            # Sleep until change channel command completed.
            time.sleep(self.command_delay)
            self._current_channel = channel_number

    def write_channel(self, channel_number: int, cmd: str) -> None:
        """"""Select specified channel, then apply specified command.""""""
        self._select_channel(channel_number)
        self.write(cmd)

    def ask_channel(self, channel_number: int, cmd: str) -> str:
        """"""Select specified channel, then apply specified query
        and return response.""""""
        self._select_channel(channel_number)
        return self.ask(cmd)
"
46,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attquOEHC31yDwYV2'), ('width', 735), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/s3Ejtf1gPUmjQyg4EKEkdA/KPzaY8ND3BlB8KmqRqLm3wnetpGlJfApyn8jG5XR056LGMsDD_ABSLehvk6NsQpjtuSPCIzs1sxyCY6TA5SH_Uj98eg5emPpfJSo7LL21pQ/jR1Lr3vs7Mzfui4tcsFR_lLCnbYAu8z10KNPtHb_jYQ'), ('filename', 'lda-802-16-product.png'), ('size', 134941), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ezNfsl6y73p8LMLCMfuDvQ/0bBnHc47rmW4x_88PVUjfUdXp620Pg6kljABJ0lBuM_mcUj-yAVFmDnmD8UUSyzP1ir6LxkI5umFotSTbPa8nA/Bts-7ZtckueLWunSiar-4Yuo_bsJ4ww-JEoq1_eL7vY'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/R2S_eajYeUngTVp3T7QWjA/EADRiu7OD65BLljPJrTBrbVFHRuq-KpR7V6Sfr2UATNyBjVeVc8MjxlByabTX0CsEyCrq07_aE97GFe3W4onBg/qMYl-YPdElypYK4y8tKMR19t5iI9i0ffl2S9fL-qag8'), ('width', 735), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/OBnzpbTwdd5AxUgJNBruqg/C95xx-80jklI82ioidFt1Oc9HMzoCEnbx-mMpcFtmhCQ-IuHGYXE_aaVACHKwpj04fM-j3ldZ9cWkaGSVH3j1Q/joYnkYaAajvXGsIC8Jv3ikZThWrhKW2qBCOg32kI4eM'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802-32 Digital Attenuator is a rack mounted 32-channel high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802-32 provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and user defined fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802-32-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802-32,Write a Python script that uses Qcodes Community to connect to a LDA-802-32 ,19000.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
49,https://www.batronix.com/pdf/Rohde-Schwarz/HMC804X/HMC804X_Datasheet_EN.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attLHKOo6MIuMbC2o'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/l23ssFDrPFP7gyCItXanCg/AY1fJmHjwGEGhKpfFcvZaXCNSx05RBE9gkFsRF_BeuJsLNUnMpECq0m2Yw557ScwMYo_LA7YsqjAlHTRxhx1XS1kEp1dqhCB253ViuPdrnSjXnxj5iMg0sjU0TIDquQJOcjAJollv7swpvnI8hsox-5lwnEqctbrDYeWJqkNUq8/X8bOa8vd0Y4ryl5eEefmSdjp88sXQGdPcitt05ABH-M'), ('filename', 'hmc804x-dc-power-supply-front-view-rohde-schwarz_200_979_640_360_1.jpg'), ('size', 39364), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/HugsUcpARoXmuMaiqzbHRQ/w2j4lAmjZt69wPFm7URSumSfJniy7U5D0ZZ5XlFGp4o70mvCl_Tn1IYvVjRzqMInBf3fyvkxdm8TTY81GBH_qw/n8gLeFmF4AD0Drn4CpubemxBwDYp_ut06n5SG_RJ_hc'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UxLHCzeUQqYwVIJx8qN0eA/0KMC3YzYD9JJeUUCyEU6KE_LW4iZWMmRlDUl8wRh1WcYwOrZSS-xcLqtByKoELwPHHunZpJurGasY_lhnr94WQ/t9cgECScdhqK5jqDmiTBifSqrxzdh-1zZSbMlcmJXxE'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PVvKanqTq8o7kikIdxX91g/mquqFYKCa3Weud-YJmjHLZiqDEaUrDfKbT2bFRhd9CSc7D5_ZlgX87MTEMhRNYEuCWhJfKqcfj9XMc6OkRYpZQ/W4SL1fHK6ZE6-V3HDW8-HZ47Ig3wdPRfqCn0Eb9VkyU'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","The R&S® HMC8043 offers a wide range of logging functions, an integrated energy meter and electronic fuses that can be individually combined for each channel, making it ideal for hardware developers, labs and industrial environments. Linear switching power supplies ensure high efficiency, for minimum heat dissipation even at full load.",https://www.batronix.com/shop/power-supplies/Rohde-Schwarz-HMC8043.html,HMC 8043,482.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMC8043.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMC8043,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMC 8043,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,,,,,"from .private.HMC804x import _RohdeSchwarzHMC804x

class RohdeSchwarzHMC8043(_RohdeSchwarzHMC804x):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMC8043 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, num_channels=3, **kwargs)
"
53,https://www.farnell.com/datasheets/3677014.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attXwLf1bJmAbrGBg'), ('width', 520), ('height', 380), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/a6saxHbkVjT2ETvKcKKBfg/dMAgSglzIIeiuV6_lddOvC-_tbsvCveGe0H5SqkNsCeDNEcVlt6QsXVDcpYKN2FI6XoJ5x0EK7U2IB69s-0TMQ/uWS0T3yKKzh1-AHawhzpTZ0H98GTn24Ifdzs5uQGGNw'), ('filename', '44.jpg'), ('size', 39284), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZawHxgNwAhxEHnFEH49NAQ/a-84CkDkriFa-gPAoO6Pr-hQeTuK5Ij6euH7niVc6Cd6D_FhGKmbjFw1e1YuYpfXwei55QaD3RhuAkUWgsHa1A/d87J0bfZj9V8wnO9c555DCO5qOmbLant3Zqd9zzqsCw'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CaCSckWIyj-w-Mg6YK1QSg/uhK0JII9zRtwfpUU1aqvNtI4__kz_eDb5n15--AQ3O9N5SdOZKg7KetvWkHiU2zepreJKzEAUvqMkZaSzUdO8w/4syFic73XB9iSRFUFITsBXVj6TwKj3qdN5K7YwDdPDo'), ('width', 520), ('height', 380)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RorVYbONWQJaEnJ-QhugOg/papT2qXSC8EYRZ7VF0pq6MmV_tVeROGsC2uOi-rPPkBNHfW96LYzdgkFY0tfTauLD-6DFO2xMYjmXAn4yP4b4A/1hQubakPnlSVCukr0jnQVFGVP9Ej1FQubqdbbmM8B9Q'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",The Rohde & Schwarz HMP4040 power supply belongs to the HMP series and has 4 channels and a power of 384W. All four channels have an output voltage of 0-32V and an output current of 0-10A.,"https://eleshop.eu/rohde-schwarz-hmp40.html#:~:text=Details,are%20programmable%20DC%20power%20supplies.",HMP 4040,479.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMP4040.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMP4040,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMP 4040,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,,,,,"from .private.HMP import _RohdeSchwarzHMP


class RohdeSchwarzHMP4040(_RohdeSchwarzHMP):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMP4040 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, model_no=4040, **kwargs)"
54,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attDYQn0vronvW6VC'), ('width', 700), ('height', 644), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/EwRJ-A-xPmMliVU0kFMfDw/wz_n-Rrn9UxcYWhgBt6M2WkP407_PhygQN-CR4S4wqkUuGEsyhuQijdF8N3_Q-OaktMRepOgbZcn_CUrH5jjFe9bTvNz_-LTuO1_BplpZNI/3L58xa4r3O9eZFvbGSXRTiEysltevEiFIoLlhRJdHFE'), ('filename', 'nai-783126-01.jpg'), ('size', 29885), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/15iHPs4wCUqFPJIxBsllJA/N2sMEjjvohlf2eqpO3FKjKL1ogqY-CBF47hWl0bm5sOm8aVvyo4hv_3Fexa-QYa9_IcKZ6OWk60GxikEUxse-Q/o9YxJfeJVzhiyCpERff7IBxYQxqzl4CqNRPlBVc0ZNs'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Uwvz8iB6OZzWAGBIXKO6tQ/e-yFW7RgAn7LZZ7PhhNc-UnbyfeALN_9fgRKNwxnmYMR7zUiskAwms_REywOCVV46uqgZtGE2_EFglNJtgTAaA/aTPzG9vqVn-JPtASPlC7IQ0B5Xl4ZEqhY6BoVYK7JN8'), ('width', 557), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xcM_z2Jc5eN3SpLrg6s4aQ/OHSw5UljKqHVYkmpcKkgver65H-g-eCci9jMwwG4F54aGixe2XT_ye6os0A9WwYrziRxLp1kRZSrf0aFx94sRg/_QupLP7ecEOqQbneFXWuSWSHTokfU8HQ_lcVuJtvzOg'), ('width', 3000), ('height', 3000)]))]))])]",1657.0,"Austin, Texas, USA","PXIe, 250 kHz to 20 GHz, PXI RF Analog Signal Generator—The PXIe-5654 features a combination of exceptional phase noise and frequency tuning time. These features address applications such as blocker test/receiver desensitization, high-performance intermodulation distortion measurements, and various electronic warfare applications. The PXIe-5654 is designed to meet the challenging requirements of RFIC characterization, satellite test, and radar applications. Some PXIe-5654 options include a PXIe-5696 Amplitude Extender Module. The PXIe-5696 supports a frequency range of 250 kHz to 20 GHz and an extended amplitude range up to 27 dBm.",https://www.ni.com/en-ca/support/model.pxie-5654.html,Pxie 5654,378.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","A producer of automated test equipment and virtual instrumentation software. Common applications include data acquisition, instrument control and machine vision. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/NationalInstruments/PXIe_5654.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/NationalInstruments_RFSG.html,National Instruments,"[OrderedDict([('id', 'attXAVi8mGWUwkEk7'), ('width', 960), ('height', 541), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/j_Cmz4uga8rm7Jk-W_hKJA/OFEsr4zAjNbG-yC55hU0noMqYtoPe9vQD-Gl-SI0_1-hw4p7TC8Qdz0fFEtGOyg7Gp-hqmHtvDJ5Uc0FHOeTZg/VpMBAVW2a1O5TmWcxSYkEtHm4BcyD8QObKnNg5JfgT0'), ('filename', '0x0.webp'), ('size', 3600), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4ZfSfzm3FWUK3mOB22JVow/iKinLC2EHIADrqenQyQb4vXtxsXSU3vw7pErcZG_x94ZnV7BNdl1ATxfilb4AcI9AzC_jsIekTtgJ4AgWnIY-b1Hh0id6SKbfLgxWmnsBXo/fH59fAbtvfp-o76XqOSe5kcylQsoXwwwMGdcmXpo_nU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Rc_oPk909VeMPUIitsLj0w/FGlkfJlj5eu6r1O9HbQw96t_v9q8ABFOEQoC6d-bOa2Qdc1ops_fMtexXqE0QP7SXa02gEfs2oNFOOrrKS_LXbc2EJwN2G-Q5nDLPE18cCU/8v_OfysCX2mh7OF_Gi8ehcKkabwz3aT5QxGDtwHH5Co'), ('width', 909), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VrmEJSvE-wFyX58WI74X5w/21j--KVJrXwHWTW9l2FxBDTcxAsHk77Bi_xQtjImpzHfA--vqGMI_jVdQr3fG77lJzEyZHS6dUQe__YLb2i04-hmeB9UHAvi4AiVzzQBF1Q/NpnfS_vHNbJaSo4ZYcewJF_7ZX-hLmRd65vYunzSeig'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ni.com/en-ca.html,NI PXIe-5654,Write a Python script that uses Qcodes Community to connect to a NI PXIe-5654 RF Signal Generator,27815.61,,,https://www.apexwaves.com/pdf/manuals/PXIe-5654/ni-pxie-5654-getting-started-guide.pdf,"from typing import Optional
from .RFSG import NI_RFSG
from qcodes.utils.validators import Numbers


class NationalInstruments_PXIe_5654(NI_RFSG):
    r""""""
    Device-specific driver for the PXIe-5654 signal generator. See the NI_RFSG
    class for further details.

    Args:
        name: Name for this instrument
        resource: Identifier for this instrument in NI MAX.
        dll_path: path to the NI-RFSG library DLL. If not provided, use the
            default location,
            ``C:\Program Files\IVI Foundation\IVI\bin\NiRFSG_64.dll``.
        id_query: whether to perform an ID query on initialization
        reset_device: whether to reset the device on initialization
    """"""
    def __init__(self, name: str, resource: str,
                 dll_path: Optional[str] = None,
                 id_query: bool = False,
                 reset_device: bool = False,
                 **kwargs):

        super().__init__(name=name, resource=resource, dll_path=dll_path,
                         id_query=id_query, reset_device=reset_device,
                         **kwargs)

        # device-specific parameter limits
        self.frequency.vals = Numbers(250e3, 20e9)
        self.power_level.vals = Numbers(-7, 15)

        # check for amplitude extender and update power limits accordingly
        model = self.IDN()[""model""]
        if ""PXIe-5696"" in model:
            self.power_level.vals = Numbers(-110, 24)


NI_PXIe_5654 = NationalInstruments_PXIe_5654
"
56,https://download.tek.com/datasheet/76W_11846_5_1.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attxWYvLE8okBv36J'), ('width', 800), ('height', 435), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GghLkID_CUdxbx_wyg1Yxg/Fz0HUqsrmUEEORUil46F9V10SU5_TYws3Er9gHG2Ylwqi2cDjGrsuKpjZihRDHV8ie7mSUwn5fMZTpfOHy71XxBoYROLkZglpWEqvaRvF1g/QKFyu0hJGhb13nQtIq9gpBSy5F4MF_Bu8nA2voSejVM'), ('filename', 'Tektronix_AWG520.jpg'), ('size', 100741), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/b9dEYkWZC6O-aLs2ZueW1w/ee3tDucAZ_1PySsWgVbxRd-s_igTZcdup0JOlmQSr8q6ywVD9isrT0U5tk3O7MrNlofWuCi6uo3_3QI8US5yzA/l3FEnYQOS5wfLuRw6qiH1pr1V-P1BKBt2sl2egOZDi0'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SwBOln1HRtEIQN4k4uW5sQ/tLBD6nwpiVG3kpIjA6KYsJ-tJKYAlW-4RYWhNGBGrWA7KMS0Y8I3FocegXxOdNkNRoTKLxBHF2YbqieDVea0CA/7ItkHjTqWuTm6HEqa-k_xcJ7VLDdXJfNx7axA9n8mgw'), ('width', 800), ('height', 435)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5Izt7cWkFWlFU9gV7JwjfQ/z9JYJZf-iF2f8LH8UKQ1lmTVVMyaQYX06JA1Jk01GOthJnbsQp3DG5WDRwpgNCQe3evbuwsBouqBwvItXLOgQA/mlvGRP3rX1qyN64utx3jrNaKnufjcAP3V-2L4olFjvo'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,"The AWG520's unique design combines a graphical editing display with powerful output capabilities to simplify the creation of arbitrary and complex waveforms and enable easy on-screen waveform editing. With the AWG520's many built-in intuitive and powerful features, you can easily develop and edit custom waveforms. Option 03 adds an independent 10–bit-wide digital data port that can be used in conjunction with marker outputs for data generation up to 14–bits wide at up to 1 GHz (14–bits, AWG520). Direct waveform transfer capability makes the AWG520 the perfect complement to selected Tektronix oscilloscopes.",https://www.tek.com/en/datasheet/awg520,AWG 520,580.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Tektronix/AWG520.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Tektronix/AWG520.py,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/t9x5w9mixNN1vX3Lcnk4ig/U_1pMs3_ygzDCnX71pbdHfcaKdp2vkRUI--wQkW2FVlaPwf5o-dR5TyQbAnNX1xDOepj5PX9bax2Q8-pfFusJg/w15ap4s4nBtHZQtX6RSEmCtmPpjoW_ZVIeB4BXdLqJI'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XloCyiOlywNa6txqtyw0IA/h3_a4-JvRiikrMaHbp2g9HWROsI5h8KoDEDEnpaoPmcdgA_Ohfylo4N3qBnBIWxDCC7ErYMaPQ7drXE1JshFug/HndoVMRnuWm752IlWSIyQqTAs8ysFvjn6aiNeKsMxAc'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mJgOPZVY10D66DbfwNJREQ/C6trfbs3rBZ1sN_CF3zgdc97w96WU26TnFdcBioC3d7HtulvxtfJdj2DyvOGyTcUV90FSAunpKbDaHGmlM0NUg/4ljeWTMHT2fz_3FzcZnh_fxRNdP-A7nZtO9m2riHjbo'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/jNvKuDBu35rSaGiSNL7PBw/xcthBJoaHTUOXvL6-_vVwE3qPOdZn7gBdnVPJeG3PGLeDf-JrewfSx4wLjXDlweD3lKZsSTEM_mvKOCI2hhkag/0L-9ZxtzmarHg4fRdh9EVNGcSaSmDHNhD_s5594IJUg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,AWG520,Write a Python script that uses Qcodes Community to connect to a AWG520 RF Signal Generator,,,True,,"# Tektronix_AWG520.py class, to perform the communication between the Wrapper and the device
# Pieter de Groot <pieterdegroot@gmail.com>, 2008
# Martijn Schaafsma <qtlab@mcschaafsma.nl>, 2008
# Vishal Ranjan, 2012
# Ron schutjens, 2012
# Adriaan Rol, 2016 Ported to QCodes
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


import time
import logging
import numpy as np
import struct
from qcodes import VisaInstrument, validators as vals


class Tektronix_AWG520(VisaInstrument):
    """"""
    This is the python driver for the Tektronix AWG520
    Arbitrary Waveform Generator

    Work pending:

        1) Get All
        2) Remove test_send??
        3) Add docstrings

    Work pending:

        use inheritance for common use with 520, currently contains
        a lot of repetition
    """"""

    def __init__(self, name, address, reset=False, clock=1e9, numpoints=1000,
                 **kw):
        """"""
        Initializes the AWG520.

        Args:
            name (str)    : name of the instrument
            address (str) : GPIB address (Note: 520 cannot be controlled
                               via ethernet)
            reset (bool)     : resets to default values, default=false
            numpoints (int)  : sets the number of datapoints

        Output:
            None
        """"""
        super().__init__(name, address, **kw)

        self._address = address
        self._values = {}
        self._values['files'] = {}
        self._clock = clock
        self._numpoints = numpoints
        self._fname = ''

        self.add_function('reset', call_cmd='*RST')
        self.add_parameter('state',
                           get_cmd=self.get_state)

        # Add parameters
        self.add_parameter('trigger_mode',
                           get_cmd='AWGC:RMOD?',
                           set_cmd='AWGC:RMOD ' + '{}',
                           vals=vals.Enum('CONT', 'TRIG', 'ENH', 'GAT'))
        self.add_parameter('trigger_impedance',
                           unit='Ohm',
                           label='Trigger impedance (Ohm)',
                           get_cmd='TRIG:IMP?',
                           set_cmd='TRIG:IMP '+'{}',
                           vals=vals.Enum(50, 1000),
                           get_parser=float)
        self.add_parameter('trigger_level',
                           unit='V',
                           label='Trigger level (V)',
                           get_cmd='TRIG:LEV?',
                           set_cmd='TRIG:LEV '+'{:.3f}',
                           vals=vals.Numbers(-5, 5),
                           get_parser=float)

        self.add_parameter('clock_freq',
                           label='Clock frequency (Hz)',
                           get_cmd='SOUR:FREQ?',
                           set_cmd='SOUR:FREQ '+'{}',
                           vals=vals.Numbers(1e6, 1e9),
                           get_parser=float)
        # Todo check if max freq is 1.2 GHz for the AWG 520 aswell
        self.add_parameter('numpoints',
                           label='Number of datapoints per wave',
                           get_cmd=self._do_get_numpoints,
                           set_cmd=self._do_set_numpoints,
                           vals=vals.Ints(100, int(1e9)))

        for ch in [1, 2]:
            amp_cmd = 'SOUR{}:VOLT:LEV:IMM:AMPL'.format(ch)
            offset_cmd = 'SOUR{}:VOLT:LEV:IMM:OFFS'.format(ch)

            self.add_parameter(
                'ch{}_filename'.format(ch), set_cmd=self._gen_ch_set_func(
                    self._do_set_filename, ch), vals=vals.Anything())
            self.add_parameter('ch{}_amp'.format(ch),
                               label='Amplitude channel {} (V)'.format(ch),
                               unit='V',
                               get_cmd=amp_cmd + '?',
                               set_cmd=amp_cmd + ' {:.6f}',
                               vals=vals.Numbers(0.02, 2.0),
                               get_parser=float)

            self.add_parameter('ch{}_offset'.format(ch),
                               label='Offset channel {} (V)'.format(ch),
                               unit='V',
                               get_cmd=offset_cmd + '?',
                               set_cmd=offset_cmd + ' {:.3f}',
                               vals=vals.Numbers(-1.0, 1.0),
                               get_parser=float)
            self.add_parameter('ch{}_status'.format(ch),
                               get_cmd='OUTP{}?'.format(ch),
                               set_cmd='OUTP{}'.format(ch) + ' {}',
                               vals=vals.Enum('ON', 'OFF'),
                               get_parser=float)

            for j in [1, 2]:
                # TODO: check that 520 does not have marker delay feature
                # m_del_cmd = 'SOUR{}:MARK{}:DEL'.format(ch, j)
                m_high_cmd = 'SOUR{}:MARK{}:VOLT:LEV:IMM:HIGH'.format(ch, j)
                m_low_cmd = 'SOUR{}:MARK{}:VOLT:LEV:IMM:LOW'.format(ch, j)

                self.add_parameter(
                    'ch{}_m{}_high'.format(ch, j),
                    label='Channel {} Marker {} high level (V)'.format(ch, j),
                    get_cmd=m_high_cmd + '?',
                    set_cmd=m_high_cmd + ' {:.3f}',
                    vals=vals.Numbers(-2., 2.),
                    get_parser=float)
                self.add_parameter(
                    'ch{}_m{}_low'.format(ch, j),
                    label='Channel {} Marker {} low level (V)'.format(ch, j),
                    get_cmd=m_low_cmd + '?',
                    set_cmd=m_low_cmd + ' {:.3f}',
                    vals=vals.Numbers(-2., 2.),
                    get_parser=float)

        # Add functions
        if reset:
            self.reset()
        else:
            self.get_all()
        self.connect_message()

    # Functions
    def _gen_ch_set_func(self, fun, ch):
        def set_func(val):
            return fun(ch, val)
        return set_func

    def _gen_ch_get_func(self, fun, ch):
        def get_func():
            return fun(ch)
        return get_func

    # get state AWG
    def get_state(self):
        state = self.visa_handle.ask('AWGC:RSTATE?')
        if state.startswith('0'):
            return 'Idle'
        elif state.startswith('1'):
            return 'Waiting for trigger'
        elif state.startswith('2'):
            return 'Running'
        else:
            logging.error(__name__ + ' : AWG in undefined state')
            return 'error'

    def start(self):
        self.visa_handle.write('AWGC:RUN')
        return

    def stop(self):
        self.visa_handle.write('AWGC:STOP')

    def get_folder_contents(self):
        return self.visa_handle.ask('mmem:cat?')

    def get_current_folder_name(self):
        return self.visa_handle.ask('mmem:cdir?')

    def set_current_folder_name(self, file_path):
        self.visa_handle.write('mmem:cdir ""%s""' % file_path)

    def change_folder(self, dir):
        self.visa_handle.write('mmem:cdir ""%s""' % dir)

    def goto_root(self):
        self.visa_handle.write('mmem:cdir')

    def make_directory(self, dir, root):
        """"""
        makes a directory
        if root = True, new dir in main folder
        """"""
        if root:
            self.goto_root()
            self.visa_handle.write('MMEMory:MDIRectory ""{}""'.format(dir))
        else:
            self.visa_handle.write('MMEMory:MDIRectory ""{}""'.format(dir))

    def get_all(self, update=True):
        # TODO: fix bug in snapshot where it tries to get setable only param
        # return self.snapshot(update=update)

        return self.snapshot(update=False)

    def clear_waveforms(self):
        """"""
        Clears the waveform on both channels.

        Input:
            None

        Output:
            None
        """"""
        logging.debug(__name__ + ' : Clear waveforms from channels')
        self.visa_handle.write('SOUR1:FUNC:USER """"')
        self.visa_handle.write('SOUR2:FUNC:USER """"')

    def force_trigger(self):
        """"""
        forces a trigger event (used for wait_trigger option in sequences)

        Ron
        """"""
        return self.visa_handle.write('TRIG:SEQ:IMM')

    def force_logicjump(self):
        """"""
        forces a jumplogic event (used as a conditional event during waveform
        executions)

        note: jump_logic events&mode have to be set properly!

        Ron
        """"""
        return self.visa_handle.write('AWGC:EVEN:SEQ:IMM')

    def set_jumpmode(self, mode):
        """"""
        sets the jump mode for jump logic events, possibilities:
        LOGic,TABle,SOFTware
        give mode as string

        note: jump_logic events&mode have to be set properly!

        Ron
        """"""
        return self.visa_handle.write('AWGC:ENH:SEQ:JMOD %s' % mode)

    def get_jumpmode(self, mode):
        """"""
        get the jump mode for jump logic events

        Ron
        """"""
        return self.visa_handle.ask('AWGC:ENH:SEQ:JMOD?')

    def _do_get_numpoints(self):
        """"""
        Returns the number of datapoints in each wave

        Input:
            None

        Output:
            numpoints (int) : Number of datapoints in each wave
        """"""
        return self._numpoints

    def _do_set_numpoints(self, numpts):
        """"""
        Sets the number of datapoints in each wave.
        This acts on both channels.

        Input:
            numpts (int) : The number of datapoints in each wave

        Output:
            None
        """"""
        logging.debug(__name__ + ' : Trying to set numpoints to %s' % numpts)
        if numpts != self._numpoints:
            logging.warning(__name__ + ' : changing numpoints. This will clear all waveforms!')

        response = 'yes'  # raw_input('type ""yes"" to continue')
        if response == 'yes':
            logging.debug(__name__ + ' : Setting numpoints to %s' % numpts)
            self._numpoints = numpts
            self.clear_waveforms()
        else:
            print('aborted')



    def set_setup_filename(self, fname, force_reload=False):
        if self._fname == fname and not force_reload:
            print('File %s already loaded in AWG520' % fname)
            return
        else:
            self._fname = fname
            filename = ""\%s/%s.seq"" % (fname, fname)
            self.set_sequence(filename=filename)
            print('Waiting for AWG to load file ""%s""' % fname)
            sleeptime = 0.5
            # while state idle is not possible due to timeout error while loading
            t0 = time.time()
            while(time.time()-t0 < 360):
                try:
                    if self.get_state() == 'Idle':
                        break
                except:
                    time.sleep(sleeptime)
                    print('.')
            self.get_state()
            print('Loading file took %.2fs' % (time.time()-t0))
            return

    def _do_set_filename(self, name, channel):
        """"""
        Specifies which file has to be set on which channel
        Make sure the file exists, and the numpoints and clock of the file
        matches the instrument settings.

        If file doesn't exist an error is raised, if the numpoints doesn't match
        the command is neglected

        Input:
            name (str) : filename of uploaded file
            channel (int) : 1 or 2, the number of the designated channel

        Output:
            None
        """"""
        logging.debug(__name__ + ' : Try to set {} on channel {}'.format(
                      name, channel))
        exists = False
        if name in self._values['files']:
            exists = True
            logging.debug(__name__ + ' : File exists in loacal memory')
            self._values['recent_channel_%s' % channel] = self._values[
                'files'][name]
            self._values['recent_channel_%s' % channel]['filename'] = name
        else:
            logging.debug(__name__ + ' : File does not exist in memory, \
            reading from instrument')
            lijst = self.visa_handle.ask('MMEM:CAT? ""MAIN""')
            bool = False
            bestand = """"
            for i in range(len(lijst)):
                if (lijst[i] =='""'):
                    bool = True
                elif (lijst[i] == ','):
                    bool = False
                    if (bestand == name):
                        exists = True
                    bestand = """"
                elif bool:
                    bestand = bestand + lijst[i]
        if exists:
            data = self.visa_handle.ask('MMEM:DATA? ""%s""' %name)
            logging.debug(__name__  + ' : File exists on instrument, loading \
            into local memory')
            # string alsvolgt opgebouwd: '#' <lenlen1> <len> 'MAGIC 1000\r\n' '#' <len waveform> 'CLOCK ' <clockvalue>
            len1 = int(data[1])
            len2 = int(data[2:2+len1])
            i = len1
            tekst = """"
            while (tekst !='#'):
                tekst = data[i]
                i = i+1
            len3 = int(data[i])
            len4 = int(data[i+1:i+1+len3])

            w = []
            m1 = []
            m2 = []

            for q in range(i+1+len3, i+1+len3+len4, 5):
                j = int(q)
                c, d = struct.unpack('<fB', data[j:5+j])
                w.append(c)
                m2.append(int(d/2))
                m1.append(d-2*int(d/2))

            clock = float(data[i+1+len3+len4+5:len(data)])

            self._values['files'][name] = {}
            self._values['files'][name]['w'] = w
            self._values['files'][name]['m1'] = m1
            self._values['files'][name]['m2'] = m2
            self._values['files'][name]['clock'] = clock
            self._values['files'][name]['numpoints'] = len(w)

            self._values['recent_channel_%s' %channel] = self._values['files'][name]
            self._values['recent_channel_%s' %channel]['filename'] = name
        else:
            logging.error(__name__ + ' : Invalid filename specified %s' %name)

        if (self._numpoints==self._values['files'][name]['numpoints']):
            logging.debug(__name__  + ' : Set file %s on channel %s' % (name, channel))
            self.visa_handle.write('SOUR%s:FUNC:USER ""%s"",""MAIN""' % (channel, name))
        else:
            self.visa_handle.write('SOUR%s:FUNC:USER ""%s"",""MAIN""' % (channel, name))
            logging.warning(__name__  + ' : Verkeerde lengte %s ipv %s'
                %(self._values['files'][name]['numpoints'], self._numpoints))


    #  Ask for string with filenames
    def get_filenames(self):
        logging.debug(__name__ + ' : Read filenames from instrument')
        return self.visa_handle.ask('MMEM:CAT? ""MAIN""')

    def return_self(self):
        return self
    # Send waveform to the device

    def send_waveform(self, w, m1, m2, filename, clock):
        """"""
        Sends a complete waveform. All parameters need to be specified.
        choose a file extension 'wfm' (must end with .pat)
        See also: resend_waveform()

        Input:
            w (float[numpoints]) : waveform
            m1 (int[numpoints])  : marker1
            m2 (int[numpoints])  : marker2
            filename (str)    : filename
            clock (int)          : frequency (Hz)

        Output:
            None
        """"""
        logging.debug(__name__ + ' : Sending waveform %s to instrument' % filename)

        # Check for errors
        dim = len(w)

        if (not((len(w) == len(m1)) and ((len(m1) == len(m2))))):
            return 'error'
        self._values['files'][filename] = {}
        self._values['files'][filename]['w'] = w
        self._values['files'][filename]['m1'] = m1
        self._values['files'][filename]['m2'] = m2
        self._values['files'][filename]['clock'] = clock
        self._values['files'][filename]['numpoints'] = len(w)

        m = m1 + np.multiply(m2, 2)
        ws = ''
        for i in range(0, len(w)):
            ws = ws + struct.pack('<fB', w[i], int(m[i]))
        s1 = 'MMEM:DATA ""%s"",' % filename
        s3 = 'MAGIC 1000\n'
        s5 = ws
        s6 = 'CLOCK %.10e\n' % clock

        s4 = '#' + str(len(str(len(s5)))) + str(len(s5))
        lenlen = str(len(str(len(s6) + len(s5) + len(s4) + len(s3))))
        s2 = '#' + lenlen + str(len(s6) + len(s5) + len(s4) + len(s3))

        mes = s1 + s2 + s3 + s4 + s5 + s6
        self.visa_handle.write(mes)

    def send_pattern(self, w, m1, m2, filename, clock):
        """"""
        Sends a pattern file.
        similar to waveform except diff file extension
        number of poitns different. diff byte conversion
        See also: resend_waveform()

        Input:
            w (float[numpoints]) : waveform
            m1 (int[numpoints])  : marker1
            m2 (int[numpoints])  : marker2
            filename (str)    : filename
            clock (int)          : frequency (Hz)

        Output:
            None
        """"""
        logging.debug(__name__ + ' : Sending pattern %s to instrument' % filename)

        # Check for errors
        dim = len(w)
        if (not((len(w)==len(m1)) and ((len(m1)==len(m2))))):
            return 'error'
        self._values['files'][filename]={}
        self._values['files'][filename]['w']=w
        self._values['files'][filename]['m1']=m1
        self._values['files'][filename]['m2']=m2
        self._values['files'][filename]['clock']=clock
        self._values['files'][filename]['numpoints']=len(w)

        m = m1 + np.multiply(m2, 2)
        ws = ''
        for i in range(0, len(w)):
            ws = ws + struct.pack('<fB', w[i], int(m[i]))

        s1 = 'MMEM:DATA ""%s"",' % filename
        s3 = 'MAGIC 2000\n'
        s5 = ws
        s6 = 'CLOCK %.10e\n' % clock

        s4 = '#' + str(len(str(len(s5)))) + str(len(s5))
        lenlen=str(len(str(len(s6) + len(s5) + len(s4) + len(s3))))
        s2 = '#' + lenlen + str(len(s6) + len(s5) + len(s4) + len(s3))

        mes = s1 + s2 + s3 + s4 + s5 + s6
        self.visa_handle.write(mes)


    def resend_waveform(self, channel, w=[], m1=[], m2=[], clock=[]):
        """"""
        Resends the last sent waveform for the designated channel
        Overwrites only the parameters specifiedta

        Input: (mandatory)
            channel (int) : 1 or 2, the number of the designated channel

        Input: (optional)
            w (float[numpoints]) : waveform
            m1 (int[numpoints])  : marker1
            m2 (int[numpoints])  : marker2
            clock (int) : frequency

        Output:
            None
        """"""
        filename = self._values['recent_channel_%s' %channel]['filename']
        logging.debug(__name__ + ' : Resending %s to channel %s' % (filename, channel))


        if (w==[]):
            w = self._values['recent_channel_%s' %channel]['w']
        if (m1==[]):
            m1 = self._values['recent_channel_%s' %channel]['m1']
        if (m2==[]):
            m2 = self._values['recent_channel_%s' %channel]['m2']
        if (clock==[]):
            clock = self._values['recent_channel_%s' %channel]['clock']

        if not ( (len(w) == self._numpoints) and (len(m1) == self._numpoints) and (len(m2) == self._numpoints)):
            logging.error(__name__ + ' : one (or more) lengths of waveforms do not match with numpoints')

        self.send_waveform(w, m1, m2, filename, clock)
        self.do_set_filename(filename, channel)

    def delete_all_waveforms_from_list(self):
        """"""
        for compatibillity with awg, is not relevant for AWG520 since it
        has no waveform list
        """"""
        pass

    def send_sequence(self, wfs, rep, wait, goto, logic_jump, filename):
        """"""
        Sends a sequence file (for the moment only for ch1)

        Args:

           wfs:  list of filenames

        Returs:

            None
        """"""
        logging.debug(__name__ + ' : Sending sequence %s to instrument' % filename)
        N = str(len(rep))
        try:
            wfs.remove(N*[None])
        except ValueError:
            pass
        s1 = 'MMEM:DATA ""%s"",' % filename

        if len(np.shape(wfs)) ==1:
            s3 = 'MAGIC 3001\n'
            s5 = ''
            for k in range(len(rep)):
                s5 = s5+ '""%s"",%s,%s,%s,%s\n'%(wfs[k],rep[k],wait[k],goto[k],logic_jump[k])

        else:
            s3 = 'MAGIC 3002\n'
            s5 = ''
            for k in range(len(rep)):
                s5 = s5+ '""%s"",""%s"",%s,%s,%s,%s\n'%(wfs[0][k],wfs[1][k],rep[k],wait[k],goto[k],logic_jump[k])

        s4 = 'LINES %s\n'%N
        lenlen=str(len(str(len(s5) + len(s4) + len(s3))))
        s2 = '#' + lenlen + str(len(s5) + len(s4) + len(s3))


        mes = s1 + s2 + s3 + s4 + s5
        self.visa_handle.write(mes)

    def send_sequence2(self,wfs1,wfs2,rep,wait,goto,logic_jump,filename):
        """"""
        Sends a sequence file

        Args:
            wfs1:  list of filenames for ch1 (all must end with .pat)
            wfs2: list of filenames for ch2 (all must end with .pat)
            rep: list
            wait: list
            goto: list
            logic_jump: list
            filename: name of output file (must end with .seq)

        Returns:
            None
        """"""
        logging.debug(__name__ + ' : Sending sequence %s to instrument' % filename)


        N = str(len(rep))
        s1 = 'MMEM:DATA ""%s"",' % filename
        s3 = 'MAGIC 3002\n'
        s4 = 'LINES %s\n'%N
        s5 = ''


        for k in range(len(rep)):
            s5 = s5+ '""%s"",""%s"",%s,%s,%s,%s\n'%(wfs1[k],wfs2[k],rep[k],wait[k],goto[k],logic_jump[k])

        lenlen=str(len(str(len(s5) + len(s4) + len(s3))))
        s2 = '#' + lenlen + str(len(s5) + len(s4) + len(s3))


        mes = s1 + s2 + s3 + s4 + s5
        self.visa_handle.write(mes)

    def set_sequence(self,filename):
        """"""
        loads a sequence file on all channels.
        Waveforms/patterns to be executed on respective channel
        must be defined inside the sequence file itself
        make sure to send all waveforms before setting a seq
        """"""
        self.visa_handle.write('SOUR%s:FUNC:USER ""%s"",""MAIN""' % (1, filename))

    def load_and_set_sequence(self,wfs,rep,wait,goto,logic_jump,filename):
        """"""
        Loads and sets the awg sequecne
        """"""
        self.send_sequence(wfs,rep,wait,goto,logic_jump,filename)
        self.set_sequence(filename)
"
58,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attEHHnQFKIW24UvA'), ('width', 394), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/no9xBP5On8uccGQGAI5PmA/Xmlzi-CkU9q1XJSxqB9fdjUq9A0BUhjMd1Jt5ZvXGAmbRk9_yBvL2j0sWge4HAhKcSSZXgZJyWN-XvF0CtruuSuMygQ0f43sEGQGQ0NTjHI/revBRokkkguKCUAcWHw08FFQ1binv1B0AS6E5se7dws'), ('filename', 'vaunix-lda-133.png'), ('size', 87729), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8xL8KAC_MJVTDL0_Tab7YQ/pc8EBvJwnRFGhvzn3WpiHC4drfuwhgCkivNaFoOotj_0jUglEaASHUYr7EO-COIaBCzPR0j38GclaPYJ20fqEw/mR0Nyvc5QXTfMoKcS2sh9R8L8I4a9uAmLYAoI-k9o-k'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FWFB94KLjTI7nXadznEjpQ/2lmzapCKmXEtnNVXTIeOuqXHODarbOAHTzA-Dqs8hWqoIsJu9dc4Hkn9Fo4FwO4K4Ny-l-5lzTNpuqqbfcXf-w/hNoZdVlQRFuuL-xmyD_W4D17PVeqa_jz0ZDVpXpDdmM'), ('width', 394), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5FA_HtrPjQVNASMeFX4JzQ/F9mais3CbTB3N-SWjsqQpEBw6XK7W4vWb_ebXaux9oVpBVMGvhtcxwyPL5OsZ-6kTtVaLBVoQCfFT_JR_GxiVg/4-iu7KQREp8fS7srZmnmmHuHLVjowEsPNY_p61o-C-g'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-906V Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator. The LDA-906V provides calibrated attenuation from 200 to 6000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 90 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-906v-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-906V,Write a Python script that uses Qcodes Community to connect to a LDA-906V ,559.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
66,https://www.farnell.com/datasheets/2607096.pdf?_ga=2.134065926.922366921.1579493884-611634051.1579231713,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attptYwWAOrQzTAZz'), ('width', 320), ('height', 169), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/nIoB8LH9URrFTXMHVmybpA/Sr-erurROPIfIcC057rqMQXz1JeTGz615DrvmT0u1Gb_3ZEvKPEXxlIu8fY6CM7daIBy1EP2hJuUxz8qPpSQa-N-AzdhEyryPMt07tNULFI/pakDCwyGRDakNw5ZoyX9XP827vRFpbDaSkxnJ_20fEw'), ('filename', '6500.webp'), ('size', 7262), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FFZXfIM_rTvsyj3N3mSifA/5O0mgb9YNn20ivm4FSvuHH1pR2M1QEvIMK2mLogw0NWj30jq8OI1X974jpFIwBSzr8IokrTzE3J9QZUBu2x0GSgFG-KhxKm5edHxCfg4ft0/PCVo_aAryLFblEyKrq4oZ9Q7tGcAJDO37G0Qyexp6KU'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rDDOU2X77g5LkBlr5kkU2g/OZJxo3ESx5y5ZUGP3On8gmhUZIa_MOeJsYDWRyF_ad_P4wRxHLO9exE03VJ9BAUrKuglDBr_k6YypcFoWvlXIhRbiCHaBOEuVzQx41lTtEI/73IcFR6Ght3xkBf0RmGrmMY9FCV4mDTzptYcs5v4ca0'), ('width', 320), ('height', 169)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/En--Bbnji1ChEgzbPqXhsQ/6nbRmPmahiktE8Gg9UUuwQdHgaVgLhGqNavP5GnpnfuHwIXAYtOKNNqXuZs5mNiD53Bh8b-gBDa4hdgsqR_yx_ZTGs11kP8y_OQmcSMveqg/ssaVBp1QCK59IXk34_GUEEz3jFzpF1Pz0MXfhPJeC-w'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States","6½ digit bench/system digital multimeter with large 5"" (12.7cm) multi touch capacitive touchscreen and graphical display. It supports SCPI, TSP® scripting, Keithley 2000 SCPI emulation and Keysight 34401A SCPI emulation language modes.",https://www.tek.com/en/products/keithley/digital-multimeter/dmm6500,Keithley 6500,575.0,,"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Tektronix/Keithley_6500.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Tektronix.html#module-qcodes_contrib_drivers.drivers.Tektronix.Keithley_6500,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/QPVtzM5SYPyX4cyx9RS99Q/Iele002qHLjDBLXxSIQySb-An3CQgHG6NbMRzBzDOlkoP62OcmSl7KWSxLswDnCWQDkdyI8QLmrpI5-y7WxPwYdXl5mCuPNxwMAqKj-NdG8N8XhYYMpwXdrPswqWlcBTCanZVyPPN4Shkh8Daf06yg/O1EN122cWlhh78b8E3YExiiMnyOhBvP6JnudpA8ZrmA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/LXY5STSOy2Npxsiuhk-xBg/si_E4nA6QkcCdXIZi5Px9y3dW8Cb-SjqxeJgmUodL1_71wJHbMUwn3el6GMCKx16SKkN4eG2DwhdrrJYtsy4pA/8z5wIYmnlMh7BKMm3KvtBO92LqDlzbH8gaWhSCkgWvM'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/apmzFxlLL9nIzXQ0l4JyXw/Ve9T8HOmycIG_AHTx9YaEhezJKA3ZYjyyizLyjH2c-nu6fxheXT35IHiUEP7EXA_dl1xkQ1W6Nvu7Wkh6HqxfA/2IjZUiexy8-1qJZwuoHBltrIG1e5TUKuevSnB3tT5KA'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cH97XHVZwLscM2rr0YltQQ/hpCwJ0CnTaUR87FRosIXMlvNLJAWCoIUv264hfQnVsYiVQUibv2HIFXz8ELjR8uqD9qAJQCBHXh7FQlr8MKqTQ/NyPHa7Q9k0s3l8teuL24swVPEeYh4Wi0IkQncPSW-hM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,DMM6500,Write a Python script that uses Qcodes Community to connect to a DMM6500 ,1670.0,,,,"from qcodes.instrument.visa import VisaInstrument
from qcodes.instrument import InstrumentChannel
from qcodes.utils.validators import Numbers
from functools import partial
from .Keithley_2000_Scan import Keithley_2000_Scan_Channel


class Keithley_Sense(InstrumentChannel):
    """"""
    This is the class for a measurement channel, i.e. the quantity to be measured (e.g. resistance, voltage).
    """"""
    def __init__(self, parent: VisaInstrument, name: str, channel: str) -> None:
        """"""

        Args:
            parent: VisaInstrument instance of the Keithley Digital Multimeter
            name: Channel name (e.g. 'CH1')
            channel: Name of the quantity to measure (e.g. 'VOLT' for DC voltage measurement)
        """"""
        valid_channels = ['VOLT', 'CURR', 'RES', 'FRES', 'TEMP']
        if channel.upper() not in valid_channels:
            raise ValueError(f""Channel must be one of the following: {', '.join(valid_channels)}"")
        super().__init__(parent, name)

        self.add_parameter('measure',
                           unit=self._get_unit(channel),
                           label=self._get_label(channel),
                           get_parser=float,
                           get_cmd=partial(self.parent._measure, channel),
                           docstring=""Measure value of chosen quantity (Current/Voltage/Resistance/Temperature).""
                           )

        self.add_parameter('nplc',
                           label='NPLC',
                           get_parser=float,
                           get_cmd=f""SENS:{channel}:NPLC?"",
                           set_cmd=f""SENS:{channel}:NPLC {{:.4f}}"",
                           vals=Numbers(0.0005, 12),
                           docstring=""Integration rate (Number of Power Line Cycles)""
                           )

    @staticmethod
    def _get_unit(quantity: str) -> str:
        """"""

        Args:
            quantity: Quantity to be measured

        Returns: Corresponding unit string

        """"""
        channel_units = {'VOLT': 'V', 'CURR': 'A', 'RES': 'Ohm', 'FRES': 'Ohm', 'TEMP': 'C'}
        return channel_units[quantity]

    @staticmethod
    def _get_label(quantity: str) -> str:
        """"""

        Args:
            quantity: Quantity to be measured

        Returns: Corresponding parameter label

        """"""
        channel_labels = {'VOLT': 'Measured voltage.',
                          'CURR': 'Measured current.',
                          'RES': 'Measured resistance',
                          'FRES': 'Measured resistance (4w)',
                          'TEMP': 'Measured temperature'}
        return channel_labels[quantity]


class Keithley_6500(VisaInstrument):
    """"""
    This is the qcodes driver for a Keithley DMM6500 digital multimeter.
    """"""
    def __init__(self, name: str,
                 address: str,
                 terminator=""\n"",
                 **kwargs):
        """"""
        Initialize instance of digital multimeter Keithley6500. Check if scanner card is inserted.
        Args:
            name: Name of instrument
            address: Address of instrument
            terminator: Termination character for SCPI commands
            **kwargs: Keyword arguments to pass to __init__ function of VisaInstrument class
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)
        for quantity in ['VOLT', 'CURR', 'RES', 'FRES', 'TEMP']:
            channel = Keithley_Sense(self, quantity.lower(), quantity)
            self.add_submodule(quantity.lower(), channel)

        self.add_parameter('active_terminal',
                           label='active terminal',
                           get_cmd=""ROUTe:TERMinals?"",
                           docstring=""Active terminal of instrument. Can only be switched via knob on front panel."")

        self.add_parameter('resistance',
                           unit='Ohm',
                           label='Measured resistance',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'RES'),
                           )

        self.add_parameter('resistance_4w',
                           unit='Ohm',
                           label='Measured resistance',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'FRES')
                           )

        self.add_parameter('voltage_dc',
                           unit='V',
                           label='Measured DC voltage',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'VOLT')
                           )

        self.add_parameter('current_dc',
                           unit='A',
                           label='Measured DC current',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'CURR')
                           )

        self.add_parameter('temperature',
                           unit='C',
                           label='Measured temperature',
                           get_parser=float,
                           get_cmd=partial(self._measure, 'TEMP')
                           )

        self.connect_message()

        # check if scanner card is connected
        # If no scanner card is connected, the query below returns ""Empty Slot"".
        # For the Scanner Card 2000-SCAN used for development of this driver the output was
        # ""2000,10-Chan Mux,0.0.0a,00000000"".
        scan_idn_msg = self.ask("":SYSTem:CARD1:IDN?"")
        if scan_idn_msg != ""Empty Slot"":
            msg_parts = scan_idn_msg.split("","")
            print(f""Scanner card {msg_parts[0]}-SCAN detected."")
            for ch_number in range(1, 11):
                scan_channel = Keithley_2000_Scan_Channel(self, ch_number)
                self.add_submodule(f""ch{ch_number:d}"", scan_channel)

    # only measure if front terminal is active
    def _measure(self, quantity: str) -> str:
        """"""
        Measure given quantity at front terminal of the instrument. Only perform measurement if front terminal is
        active. Send SCPI command to measure and read out given quantity.
        Args:
            quantity: Quantity to be measured

        Returns: Measurement result

        """"""
        if self.active_terminal.get() == 'FRON':
            return self.ask(f""MEAS:{quantity}?"")
        else:
            raise RuntimeError(""Rear terminal is active instead of front terminal."")
"
79,,https://en.wikipedia.org/wiki/Electric_generator,"[OrderedDict([('id', 'att3KT0VioIKKqGNv'), ('width', 300), ('height', 189), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6sKc9csqf_8MUAtjXYF-cg/sC1NYo94HAYsc2Jh42Z1g9hbYWnIS4Xnjz2kYKTKyOVUDBjFiQ31RT3vfeYChse-Adv-sO2S2BxkdCFCeXz6xs_e5Jab_amyrUU3VFWMeko/PibehRdsWe3OAbutt1qa2R5yRMroNQKj8Xwza8uBrKE'), ('filename', 'QDAC-II_01-300x189.jpg'), ('size', 5690), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/dMqEyopnvJ16X7T7u0ef3A/s5Xu4Fth66WTKDIHsgOHnYp5YjZx3RZ9ibd6BxoDfDsVk5ZMrQGgUGPaiQtjzbW0qYPvICCIlC90LL8H5TYorQ/K8N5cOQFRKS94j_F348OYQVLmp9t38Jsnaa0oWs1koc'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/c4mcCwHJ19-OJ2vmyttv6w/Ki_gEiafAsxJky-84AtyU5xtUejyowltrIbQFxAIpKuMOsawYSIH9UgXJvfshx1Ly1qNUJW0Zz4Qkb0cK18crw/0yYBwWxzFAaSX5yRa01uU6-RHsHR-U_cOivBu1JOCI0'), ('width', 300), ('height', 189)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qWhjE54yuyQjLSqrsRd52A/lw36qSO9iExvPRjHSfnQYb2GgBcMxpckOtjf3igKKCOLLtu87Lw12aUl3KXrE-QscQgoFP5hJaCoZxUkx9BT1A/o0X1SMXJF6HJTbI9cLqbMl-X5aCNsi-V0zrlQ5CJKEE'), ('width', 3000), ('height', 3000)]))]))])]",2.0,"COPENHAGEN, DENMARK","QDAC-II is the next generation of the successful QDAC from QDevil. It has all the outstanding features from its predecessor but is even more versatile and with superior performance. QDAC-II is a high-precision ultra-low-noise computer controlled DAC with 24 voltage generators, operating at a sample rate of 1MS/s – a thousand times faster than its predecessor. It is designed for DC and intermediate-frequency control of quantum devices, including, for example, gate electrodes and flux bias coils in qubits, but is a very versatile instrument that can be used for many other purposes. Each of the 24 channels has five voltage generators working in parallel: One for DC, a sine generator, a triangle generator, a square wave generator, and an arbitrary waveform generator (1 million points/second). Additionally, each channel is equipped with a DC current sensor with a resolution down to a few tens of pA, typically used for gate leakage detection and with sample rates up to 3 kHz.",https://qdevil.com/qdac-ii/,Qdac 2,424.0,"['Power Supplies', 'Digital-Analog Converter']","In electricity generation, a generator[1] is a device that converts motive power (mechanical energy) or fuel-based power (chemical energy) into electric power for use in an external circuit. Sources of mechanical energy include steam turbines, gas turbines, water turbines, internal combustion engines, wind turbines and even hand cranks. The first electromagnetic generator, the Faraday disk, was invented in 1831 by British scientist Michael Faraday. Generators provide nearly all of the power for electric power grids.","Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QDevil/QDAC2.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QDevil.html#module-qcodes_contrib_drivers.drivers.QDevil.QDAC2,Qdevil,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rt0ijk1tEeP19zdHVfttFg/7Ob5OL-aQOWHgJLTZlkxZkOheJC0cN05vXsNpZRsU4OHbtOmqBBAZlhmqBSOIWRZUvxG3tQKTXSQ-e54ZcKM4efr6Y_SsndOQXo4lN8vFmQ/I-pT2nu1se1zoP4Grs6M0aBZp6dNS5Hmy5wXPGCI3Vs'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/0EsL2PmoGiY38ganNXLIXA/6F3XRVRPwQG2h6M4Bzu3VIPyNK-686d5qDAzOEx2xCYQnhk8Vg07pNzWuBAXC2npzgWJXgkt6dViRWY8eZ3sVU8teqS8qPGyDsuTtzMWrPc/h8g-OEnf98sLQylcJtEMTjg0rbA7rnR_a4oTo-cTcLc'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/d6gt9ShC3wZMYSwCexAZnw/mZGS-M4xi-162d2C-IrVxIkwYbHnSu_oTyFSt63Y62UPZq_U0ZVVx0m3AIq4mw0JARmzx6D39IdlQ8eKbTwMDvKLUpoWkfuKXTiXoZFJZRM/sl6WH15UvsVy7nXyFYu3VwMHFJSsjBQr3yfODvcLbDQ'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qAV45QZXEAt3b7YfrCuZCQ/-_qwuyLIus2jW_R-Ivn54iGTzh4GJ0KYI11dJ8E6to-VWm4y7BzEtwY0eNjwiEC6jDFfyYzUOj4dbMd223m2Jfzz1gbcZCKF_BFv7jfyTfQ/je3Fsh2bnUiJYjz4JBzgEeN5qpp57TDjds1gIjtuek4'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,Qdac 2,"Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies, Digital-Analog Converter",,,,,"import numpy as np
import itertools
import uuid
from time import sleep as sleep_s
from qcodes.instrument.channel import InstrumentChannel, ChannelList
from qcodes.instrument.visa import VisaInstrument
from pyvisa.errors import VisaIOError
from qcodes.utils import validators
from typing import NewType, Tuple, Sequence, List, Dict, Optional
from packaging.version import Version, parse
import abc

# Version 1.2.0
#
# Guiding principles for this driver for QDevil QDAC-II
# -----------------------------------------------------
#
# 1. Each command should be self-contained, so
#
#        qdac.ch02.dc_constant_V(0.1)
#
#    should make sure that channel 2 is in the right mode for outputting
#    a constant voltage.
#
# 2. Numeric values should be in ISO units and/or their unit should be an
#    explicitly part of the function name, like above.  If the numeric is
#    a unit-less number, then prefixed by n_ like
#
#        qdac.n_channels()
#
# 3. Allocation of resources should be automated as much as possible, preferably
#    by python context managers that automatically clean up on exit.  Such
#    context managers have a name with a '_Context' suffix.
#
# 4. Any generator should by default be set to start on the BUS trigger
#    (*TRG) so that it is possible to synchronise several generators without
#    further setup; which also eliminates the need for special cases for the
#    BUS trigger.


#
# Future improvements
# -------------------
#
# - Detect and handle mixing of internal and external triggers (_trigger).
#

error_ambiguous_wave = 'Only one of frequency_Hz or period_s can be ' \
                       'specified for a wave form'


def ints_to_comma_separated_list(array: Sequence[int]) -> str:
    return ','.join([str(x) for x in array])


def floats_to_comma_separated_list(array: Sequence[float]) -> str:
    rounded = [format(x, 'g') for x in array]
    return ','.join(rounded)


def comma_sequence_to_list(sequence: str) -> Sequence[str]:
    if not sequence:
        return []
    return [x.strip() for x in sequence.split(',')]


def comma_sequence_to_list_of_floats(sequence: str) -> Sequence[float]:
    if not sequence:
        return []
    return [float(x.strip()) for x in sequence.split(',')]


def diff_matrix(initial: Sequence[float],
                measurements: Sequence[Sequence[float]]) -> np.ndarray:
    """"""Subtract an array of measurements by an initial measurement
    """"""
    matrix = np.asarray(measurements)
    return matrix - np.asarray(list(itertools.repeat(initial, matrix.shape[1])))


def split_version_string_into_components(version: str) -> List[str]:
    return version.split('-')


""""""External input trigger

There are four 3V3 non-isolated triggers on the back (1, 2, 3, 4).
""""""
ExternalInput = NewType('ExternalInput', int)


class QDac2Trigger_Context:
    """"""Internal Triggers with automatic deallocation

    This context manager wraps an already-allocated internal trigger number so
    that the trigger can be automatically reclaimed when the context exits.
    """"""

    def __init__(self, parent: 'QDac2', value: int):
        self._parent = parent
        self._value = value

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._parent.free_trigger(self)
        # Propagate exceptions
        return False

    @property
    def value(self) -> int:
        """"""internal SCPI trigger number""""""
        return self._value


def _trigger_context_to_value(trigger: QDac2Trigger_Context) -> int:
    return trigger.value


class QDac2ExternalTrigger(InstrumentChannel):
    """"""External output trigger

    There are three 5V isolated triggers on the front (1, 2, 3) and two
    non-isolated 3V3 on the back (4, 5).
    """"""

    def __init__(self, parent: 'QDac2', name: str, external: int):
        super().__init__(parent, name)
        self.add_function(
            name='source_from_bus',
            call_cmd=f'outp:trig{external}:sour bus'
        )
        self.add_parameter(
            name='source_from_input',
            # Route external input to external output
            set_cmd='outp:trig{0}:sour ext{1}'.format(external, '{}'),
            get_parser=int
        )
        self.add_parameter(
            name='source_from_trigger',
            # Route internal trigger to external output
            set_parser=_trigger_context_to_value,
            set_cmd='outp:trig{0}:sour int{1}'.format(external, '{}'),
            get_parser=int
        )
        self.add_parameter(
            name='width_s',
            label='width',
            unit='s',
            set_cmd='outp:trig{0}:widt {1}'.format(external, '{}'),
            get_cmd=f'outp:trig{external}:widt?',
            get_parser=float
        )
        self.add_parameter(
            name='polarity',
            label='polarity',
            set_cmd='outp:trig{0}:pol {1}'.format(external, '{}'),
            get_cmd=f'outp:trig{external}:pol?',
            get_parser=str,
            vals=validators.Enum('inv', 'norm')
        )
        self.add_parameter(
            name='delay_s',
            label='delay',
            unit='s',
            set_cmd='outp:trig{0}:del {1}'.format(external, '{}'),
            get_cmd=f'outp:trig{external}:del?',
            get_parser=float
        )
        self.add_function(
            name='signal',
            call_cmd=f'outp:trig{external}:sign'
        )


class _Channel_Context(metaclass=abc.ABCMeta):

    def __init__(self, channel: 'QDac2Channel'):
        self._channel = channel

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Propagate exceptions
        return False

    def allocate_trigger(self) -> QDac2Trigger_Context:
        """"""Allocate internal trigger

        Returns:
            QDac2Trigger_Context: Context that wraps the trigger
        """"""
        return self._channel._parent.allocate_trigger()

    @abc.abstractmethod
    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        pass

    @abc.abstractmethod
    def start_on_external(self, trigger: ExternalInput) -> None:
        pass

    @abc.abstractmethod
    def abort(self) -> None:
        pass

    def _write_channel(self, cmd: str) -> None:
        self._channel.write_channel(cmd)

    def _write_channel_floats(self, cmd: str, values: Sequence[float]) -> None:
        self._channel.write_channel_floats(cmd, values)

    def _ask_channel(self, cmd: str) -> str:
        return self._channel.ask_channel(cmd)

    def _channel_message(self, template: str) -> None:
        return self._channel._channel_message(template)


class _Dc_Context(_Channel_Context):

    def __init__(self, channel: 'QDac2Channel'):
        super().__init__(channel)
        self._write_channel('sour{0}:dc:trig:sour hold')
        self._trigger: Optional[QDac2Trigger_Context] = None
        self._marker_start: Optional[QDac2Trigger_Context] = None
        self._marker_end: Optional[QDac2Trigger_Context] = None
        self._marker_step_start: Optional[QDac2Trigger_Context] = None
        self._marker_step_end: Optional[QDac2Trigger_Context] = None

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to DC generator

        Args:
            trigger (QDac2Trigger_Context): trigger that will start DC
        """"""
        self._trigger = trigger
        internal = _trigger_context_to_value(trigger)
        self._write_channel(f'sour{""{0}""}:dc:trig:sour int{internal}')
        self._make_ready_to_start()

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to DC generator

        Args:
            trigger (ExternalInput): trigger that will start DC generator
        """"""
        self._trigger = None
        self._write_channel(f'sour{""{0}""}:dc:trig:sour ext{trigger}')
        self._make_ready_to_start()

    def abort(self) -> None:
        """"""Abort any DC running generator on the channel
        """"""
        self._write_channel('sour{0}:dc:abor')

    def end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of the DC generator

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end
        """"""
        if not self._marker_end:
            self._marker_end = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:dc:mark:end {self._marker_end.value}')
        return self._marker_end

    def start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of the DC generator

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning
        """"""
        if not self._marker_start:
            self._marker_start = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:dc:mark:star {self._marker_start.value}')
        return self._marker_start

    def step_end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of each step

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each step
        """"""
        if not self._marker_step_end:
            self._marker_step_end = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:dc:mark:send {self._marker_step_end.value}')
        return self._marker_step_end

    def step_start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of each step

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each step
        """"""
        if not self._marker_step_start:
            self._marker_step_start = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:dc:mark:sst {self._marker_step_start.value}')
        return self._marker_step_start

    def _set_delay(self, delay_s: float) -> None:
        self._write_channel(f'sour{""{0}""}:dc:del {delay_s}')

    def _set_triggering(self) -> None:
        self._write_channel('sour{0}:dc:trig:sour bus')
        self._make_ready_to_start()

    def _start(self, description: str) -> None:
        if self._trigger:
            self._make_ready_to_start()
            return self._write_channel(f'tint {self._trigger.value}')
        self._switch_to_immediate_trigger()
        self._write_channel('sour{0}:dc:init')

    def _make_ready_to_start(self) -> None:
        self._write_channel('sour{0}:dc:init:cont on')
        self._write_channel('sour{0}:dc:init')

    def _switch_to_immediate_trigger(self) -> None:
        self._write_channel('sour{0}:dc:init:cont off')
        self._write_channel('sour{0}:dc:trig:sour imm')


class Sweep_Context(_Dc_Context):

    def __init__(self, channel: 'QDac2Channel', start_V: float, stop_V: float,
                 points: int, repetitions: int, dwell_s: float, delay_s: float,
                 backwards: bool, stepped: bool):
        self._repetitions = repetitions
        super().__init__(channel)
        channel.write_channel('sour{0}:volt:mode swe')
        self._set_voltages(start_V, stop_V)
        channel.write_channel(f'sour{""{0}""}:swe:poin {points}')
        self._set_trigger_mode(stepped)
        channel.write_channel(f'sour{""{0}""}:swe:dwel {dwell_s}')
        super()._set_delay(delay_s)
        self._set_direction(backwards)
        self._set_repetitions()
        self._set_triggering()

    def _set_voltages(self, start_V: float, stop_V: float):
        self._write_channel(f'sour{""{0}""}:swe:star {start_V}')
        self._write_channel(f'sour{""{0}""}:swe:stop {stop_V}')

    def _set_trigger_mode(self, stepped: bool) -> None:
        if stepped:
            return self._write_channel('sour{0}:swe:gen step')
        self._write_channel('sour{0}:swe:gen auto')

    def _set_direction(self, backwards: bool) -> None:
        if backwards:
            return self._write_channel('sour{0}:swe:dir down')
        self._write_channel('sour{0}:swe:dir up')

    def _set_repetitions(self) -> None:
        self._write_channel(f'sour{""{0}""}:swe:coun {self._repetitions}')

    def _perpetual(self) -> bool:
        return self._repetitions < 0

    def start(self) -> None:
        """"""Start the DC sweep
        """"""
        self._start('DC sweep')

    def points(self) -> int:
        """"""
        Returns:
            int: Number of steps in the DC sweep
        """"""
        return int(self._ask_channel('sour{0}:swe:poin?'))

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the DC sweep
        """"""
        return int(self._ask_channel('sour{0}:swe:ncl?'))

    def time_s(self) -> float:
        """"""
        Returns:
            float: Seconds that it will take to do the sweep
        """"""
        return float(self._ask_channel('sour{0}:swe:time?'))

    def start_V(self) -> float:
        """"""
        Returns:
            float: Starting voltage
        """"""
        return float(self._ask_channel('sour{0}:swe:star?'))

    def stop_V(self) -> float:
        """"""
        Returns:
            float: Ending voltage
        """"""
        return float(self._ask_channel('sour{0}:swe:stop?'))

    def values_V(self) -> Sequence[float]:
        """"""
        Returns:
            Sequence[float]: List of voltages
        """"""
        return list(np.linspace(self.start_V(), self.stop_V(), self.points()))


class List_Context(_Dc_Context):

    def __init__(self, channel: 'QDac2Channel', voltages: Sequence[float],
                 repetitions: int, dwell_s: float, delay_s: float,
                 backwards: bool, stepped: bool):
        super().__init__(channel)
        self._repetitions = repetitions
        self._write_channel('sour{0}:volt:mode list')
        self._set_voltages(voltages)
        self._set_trigger_mode(stepped)
        self._write_channel(f'sour{""{0}""}:list:dwel {dwell_s}')
        super()._set_delay(delay_s)
        self._set_direction(backwards)
        self._set_repetitions()
        self._set_triggering()

    def _set_voltages(self, voltages: Sequence[float]) -> None:
        self._write_channel_floats('sour{0}:list:volt ', voltages)

    def _set_trigger_mode(self, stepped: bool) -> None:
        if stepped:
            return self._write_channel('sour{0}:list:tmod step')
        self._write_channel('sour{0}:list:tmod auto')

    def _set_direction(self, backwards: bool) -> None:
        if backwards:
            return self._write_channel('sour{0}:list:dir down')
        self._write_channel('sour{0}:list:dir up')

    def _set_repetitions(self) -> None:
        self._write_channel(f'sour{""{0}""}:list:coun {self._repetitions}')

    def _perpetual(self) -> bool:
        return self._repetitions < 0

    def start(self) -> None:
        """"""Start the DC list generator
        """"""
        self._start('DC list')

    def append(self, voltages: Sequence[float]) -> None:
        """"""Append voltages to the existing list

        Arguments:
            voltages (Sequence[float]): Sequence of voltages
        """"""
        self._write_channel_floats('sour{0}:list:volt:app ', voltages)
        self._make_ready_to_start()

    def points(self) -> int:
        """"""
        Returns:
            int: Number of steps in the DC list
        """"""
        return int(self._ask_channel('sour{0}:list:poin?'))

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the DC list
        """"""
        return int(self._ask_channel('sour{0}:list:ncl?'))

    def values_V(self) -> Sequence[float]:
        """"""
        Returns:
            Sequence[float]: List of voltages
        """"""
        # return comma_sequence_to_list_of_floats(
        #     self._ask_channel('sour{0}:list:volt?'))
        return comma_sequence_to_list_of_floats(
            self._ask_channel('sour{0}:list:volt?'))


class _Waveform_Context(_Channel_Context):

    def __init__(self, channel: 'QDac2Channel'):
        super().__init__(channel)
        self._trigger: Optional[QDac2Trigger_Context] = None
        self._marker_start: Optional[QDac2Trigger_Context] = None
        self._marker_end: Optional[QDac2Trigger_Context] = None
        self._marker_period_start: Optional[QDac2Trigger_Context] = None
        self._marker_period_end: Optional[QDac2Trigger_Context] = None

    def _start(self, wave_kind: str, description: str) -> None:
        if self._trigger:
            self._make_ready_to_start(wave_kind)
            return self._write_channel(f'tint {self._trigger.value}')
        self._switch_to_immediate_trigger(wave_kind)
        self._write_channel(f'sour{""{0}""}:{wave_kind}:init')

    def _start_on(self, trigger: QDac2Trigger_Context, wave_kind: str) -> None:
        self._trigger = trigger
        internal = _trigger_context_to_value(trigger)
        self._write_channel(f'sour{""{0}""}:{wave_kind}:trig:sour int{internal}')
        self._make_ready_to_start(wave_kind)

    def _start_on_external(self, trigger: ExternalInput, wave_kind: str) -> None:
        self._trigger = None
        self._write_channel(f'sour{""{0}""}:{wave_kind}:trig:sour ext{trigger}')
        self._make_ready_to_start(wave_kind)

    def _end_marker(self, wave_kind: str) -> QDac2Trigger_Context:
        if not self._marker_end:
            self._marker_end = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:{wave_kind}:mark:end {self._marker_end.value}')
        return self._marker_end

    def _start_marker(self, wave_kind: str) -> QDac2Trigger_Context:
        if not self._marker_start:
            self._marker_start = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:{wave_kind}:mark:star {self._marker_start.value}')
        return self._marker_start

    def _period_end_marker(self, wave_kind: str) -> QDac2Trigger_Context:
        if not self._marker_period_end:
            self._marker_period_end = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:{wave_kind}:mark:pend {self._marker_period_end.value}')
        return self._marker_period_end

    def _period_start_marker(self, wave_kind: str) -> QDac2Trigger_Context:
        if not self._marker_period_start:
            self._marker_period_start = self.allocate_trigger()
        self._write_channel(f'sour{""{0}""}:{wave_kind}:mark:pstart {self._marker_period_start.value}')
        return self._marker_period_start

    def _make_ready_to_start(self, wave_kind: str) -> None:
        self._write_channel(f'sour{""{0}""}:{wave_kind}:init:cont on')
        self._write_channel(f'sour{""{0}""}:{wave_kind}:init')

    def _switch_to_immediate_trigger(self, wave_kind: str):
        self._write_channel(f'sour{""{0}""}:{wave_kind}:init:cont off')
        self._write_channel(f'sour{""{0}""}:{wave_kind}:trig:sour imm')

    def _set_delay(self, wave_kind: str, delay_s) -> None:
        self._write_channel(f'sour{""{0}""}:{wave_kind}:del {delay_s}')

    def _set_slew(self, wave_kind: str, slew_V_s: Optional[float]) -> None:
        if slew_V_s:
            # Bug, see https://trello.com/c/SeeUrRNY
            self._write_channel(f'sour{""{0}""}:{wave_kind}:slew {slew_V_s}')
        else:
            self._write_channel(f'sour{""{0}""}:{wave_kind}:slew inf')


class Square_Context(_Waveform_Context):

    def __init__(self, channel: 'QDac2Channel', frequency_Hz: Optional[float],
                 repetitions: int, period_s: Optional[float],
                 duty_cycle_percent: float, kind: str, inverted: bool,
                 span_V: float, offset_V: float, delay_s: float,
                 slew_V_s: Optional[float]):
        super().__init__(channel)
        self._repetitions = repetitions
        self._write_channel('sour{0}:squ:trig:sour hold')
        self._set_frequency(frequency_Hz, period_s)
        self._write_channel(f'sour{""{0}""}:squ:dcyc {duty_cycle_percent}')
        self._set_type(kind)
        self._set_polarity(inverted)
        self._write_channel(f'sour{""{0}""}:squ:span {span_V}')
        self._write_channel(f'sour{""{0}""}:squ:offs {offset_V}')
        self._set_slew('squ', slew_V_s)
        super()._set_delay('squ', delay_s)
        self._write_channel(f'sour{""{0}""}:squ:coun {repetitions}')
        self._set_triggering()

    def start(self) -> None:
        """"""Start the square wave generator
        """"""
        self._start('squ', 'square wave')

    def abort(self) -> None:
        """"""Abort any running square wave generator
        """"""
        self._write_channel('sour{0}:squ:abor')

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the square wave
        """"""
        return int(self._ask_channel('sour{0}:squ:ncl?'))

    def _set_frequency(self, frequency_Hz: Optional[float],
                       period_s: Optional[float]) -> None:
        if frequency_Hz:
            return self._write_channel(f'sour{""{0}""}:squ:freq {frequency_Hz}')
        if period_s:
            self._write_channel(f'sour{""{0}""}:squ:per {period_s}')

    def _set_type(self, kind: str) -> None:
        if kind == 'positive':
            self._write_channel('sour{0}:squ:typ pos')
        elif kind == 'negative':
            self._write_channel('sour{0}:squ:typ neg')
        else:
            self._write_channel('sour{0}:squ:typ symm')

    def _set_polarity(self, inverted: bool) -> None:
        if inverted:
            self._write_channel('sour{0}:squ:pol inv')
        else:
            self._write_channel('sour{0}:squ:pol norm')

    def _set_triggering(self) -> None:
        self._write_channel('sour{0}:squ:trig:sour bus')
        self._make_ready_to_start('squ')

    def end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of the square wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end
        """"""
        return super()._end_marker('squ')

    def start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of the square wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning
        """"""
        return super()._start_marker('squ')

    def period_end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each period
        """"""
        return super()._period_end_marker('squ')

    def period_start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning of each period
        """"""
        return super()._period_start_marker('squ')

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to start the square wave generator

        Args:
            trigger (QDac2Trigger_Context): trigger that will start square wave
        """"""
        return super()._start_on(trigger, 'squ')

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to start the square wave generator

        Args:
            trigger (ExternalInput): external trigger that will start square wave
        """"""
        return super()._start_on_external(trigger, 'squ')


class Sine_Context(_Waveform_Context):

    def __init__(self, channel: 'QDac2Channel', frequency_Hz: Optional[float],
                 repetitions: int, period_s: Optional[float], inverted: bool,
                 span_V: float, offset_V: float, delay_s: float,
                 slew_V_s: Optional[float]):
        super().__init__(channel)
        self._repetitions = repetitions
        self._write_channel('sour{0}:sine:trig:sour hold')
        self._set_frequency(frequency_Hz, period_s)
        self._set_polarity(inverted)
        self._write_channel(f'sour{""{0}""}:sine:span {span_V}')
        self._write_channel(f'sour{""{0}""}:sine:offs {offset_V}')
        self._set_slew('sine', slew_V_s)
        super()._set_delay('sine', delay_s)
        self._write_channel(f'sour{""{0}""}:sine:coun {repetitions}')
        self._set_triggering()

    def start(self) -> None:
        """"""Start the sine wave generator
        """"""
        self._start('sine', 'sine wave')

    def abort(self) -> None:
        """"""Abort any running sine wave generator
        """"""
        self._write_channel('sour{0}:sine:abor')

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the sine wave
        """"""
        return int(self._ask_channel('sour{0}:sine:ncl?'))

    def _set_frequency(self, frequency_Hz: Optional[float],
                       period_s: Optional[float]) -> None:
        if frequency_Hz:
            return self._write_channel(f'sour{""{0}""}:sine:freq {frequency_Hz}')
        if period_s:
            self._write_channel(f'sour{""{0}""}:sine:per {period_s}')

    def _set_polarity(self, inverted: bool) -> None:
        if inverted:
            self._write_channel('sour{0}:sine:pol inv')
        else:
            self._write_channel('sour{0}:sine:pol norm')

    def _set_triggering(self) -> None:
        self._write_channel('sour{0}:sine:trig:sour bus')
        self._make_ready_to_start('sine')

    def end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of the sine wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end
        """"""
        return super()._end_marker('sine')

    def start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of the sine wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning
        """"""
        return super()._start_marker('sine')

    def period_end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each period
        """"""
        return super()._period_end_marker('sine')

    def period_start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning of each period
        """"""
        return super()._period_start_marker('sine')

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to start the sine wave generator

        Args:
            trigger (QDac2Trigger_Context): trigger that will start sine wave
        """"""
        return super()._start_on(trigger, 'sine')

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to start the sine wave generator

        Args:
            trigger (ExternalInput): external trigger that will start sine wave
        """"""
        return super()._start_on_external(trigger, 'sine')


class Triangle_Context(_Waveform_Context):

    def __init__(self, channel: 'QDac2Channel', frequency_Hz: Optional[float],
                 repetitions: int, period_s: Optional[float],
                 duty_cycle_percent: float, inverted: bool, span_V: float,
                 offset_V: float, delay_s: float, slew_V_s: Optional[float]):
        super().__init__(channel)
        self._repetitions = repetitions
        self._write_channel('sour{0}:tri:trig:sour hold')
        self._set_frequency(frequency_Hz, period_s)
        self._write_channel(f'sour{""{0}""}:tri:dcyc {duty_cycle_percent}')
        self._set_polarity(inverted)
        self._write_channel(f'sour{""{0}""}:tri:span {span_V}')
        self._write_channel(f'sour{""{0}""}:tri:offs {offset_V}')
        self._set_slew('tri', slew_V_s)
        super()._set_delay('tri', delay_s)
        self._write_channel(f'sour{""{0}""}:tri:coun {repetitions}')
        self._set_triggering()

    def start(self) -> None:
        """"""Start the triangle wave generator
        """"""
        self._start('tri', 'triangle wave')

    def abort(self) -> None:
        """"""Abort any running triangle wave generator
        """"""
        self._write_channel('sour{0}:tri:abor')

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the triangle wave
        """"""
        return int(self._ask_channel('sour{0}:tri:ncl?'))

    def _set_frequency(self, frequency_Hz: Optional[float],
                       period_s: Optional[float]) -> None:
        if frequency_Hz:
            return self._write_channel(f'sour{""{0}""}:tri:freq {frequency_Hz}')
        if period_s:
            self._write_channel(f'sour{""{0}""}:tri:per {period_s}')

    def _set_type(self, kind: bool) -> None:
        if kind == 'positive':
            self._write_channel('sour{0}:tri:typ pos')
        elif kind == 'negative':
            self._write_channel('sour{0}:tri:typ neg')
        else:
            self._write_channel('sour{0}:tri:typ symm')

    def _set_polarity(self, inverted: bool) -> None:
        if inverted:
            self._write_channel('sour{0}:tri:pol inv')
        else:
            self._write_channel('sour{0}:tri:pol norm')

    def _set_triggering(self) -> None:
        self._write_channel('sour{0}:tri:trig:sour bus')
        self._make_ready_to_start('tri')

    def end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of the triangle wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end
        """"""
        return super()._end_marker('tri')

    def start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of the triangle wave

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning
        """"""
        return super()._start_marker('tri')

    def period_end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each period
        """"""
        return super()._period_end_marker('tri')

    def period_start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning of each period
        """"""
        return super()._period_start_marker('tri')

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to start the triangle wave generator

        Args:
            trigger (QDac2Trigger_Context): trigger that will start triangle
        """"""
        return super()._start_on(trigger, 'tri')

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to start the triangle wave generator

        Args:
            trigger (ExternalInput): external trigger that will start triangle
        """"""
        return super()._start_on_external(trigger, 'tri')


class Awg_Context(_Waveform_Context):

    def __init__(self, channel: 'QDac2Channel', trace_name: str,
                 repetitions: int, scale: float, offset_V: float,
                 slew_V_s: Optional[float]):
        super().__init__(channel)
        self._repetitions = repetitions
        self._write_channel('sour{0}:awg:trig:sour hold')
        self._write_channel(f'sour{""{0}""}:awg:def ""{trace_name}""')
        self._write_channel(f'sour{""{0}""}:awg:scal {scale}')
        self._write_channel(f'sour{""{0}""}:awg:offs {offset_V}')
        self._set_slew('awg', slew_V_s)
        self._write_channel(f'sour{""{0}""}:awg:coun {repetitions}')
        self._set_triggering()

    def start(self) -> None:
        """"""Start the AWG
        """"""
        self._start('awg', 'AWG')

    def abort(self) -> None:
        """"""Abort any running AWG
        """"""
        self._write_channel('sour{0}:awg:abor')

    def cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of cycles remaining in the AWG
        """"""
        return int(self._ask_channel('sour{0}:awg:ncl?'))

    def _set_triggering(self) -> None:
        self._write_channel('sour{0}:awg:trig:sour bus')
        self._make_ready_to_start('awg')

    def end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of the AWG

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end
        """"""
        return super()._end_marker('awg')

    def start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of the AWG

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning
        """"""
        return super()._start_marker('awg')

    def period_end_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the end of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the end of each period
        """"""
        return super()._period_end_marker('awg')

    def period_start_marker(self) -> QDac2Trigger_Context:
        """"""Internal trigger that will mark the beginning of each period

        A new internal trigger is allocated if necessary.

        Returns:
            QDac2Trigger_Context: trigger that will mark the beginning of each period
        """"""
        return super()._period_start_marker('awg')

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to start the AWG

        Args:
            trigger (QDac2Trigger_Context): trigger that will start AWG
        """"""
        return super()._start_on(trigger, 'awg')

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to start the AWG

        Args:
            trigger (ExternalInput): external trigger that will start AWG
        """"""
        return super()._start_on_external(trigger, 'awg')


class Measurement_Context(_Channel_Context):

    def __init__(self, channel: 'QDac2Channel', delay_s: float,
                 repetitions: int, current_range: str,
                 aperture_s: Optional[float], nplc: Optional[int]):
        super().__init__(channel)
        self._trigger: Optional[QDac2Trigger_Context] = None
        self._write_channel(f'sens{""{0}""}:del {delay_s}')
        self._write_channel(f'sens{""{0}""}:rang {current_range}')
        self._set_aperture(aperture_s, nplc)
        self._write_channel(f'sens{""{0}""}:coun {repetitions}')
        self._set_triggering()

    def start(self) -> None:
        """"""Start a current measurement
        """"""
        if self._trigger:
            return self._write_channel(f'tint {self._trigger.value}')
        self._switch_to_immediate_trigger()
        self._write_channel('sens{0}:init')

    def _switch_to_immediate_trigger(self) -> None:
        self._write_channel('sens{0}:init:cont off')
        self._write_channel('sens{0}:trig:sour imm')

    def start_on(self, trigger: QDac2Trigger_Context) -> None:
        """"""Attach internal trigger to start the current measurement

        Args:
            trigger (QDac2Trigger_Context): trigger that will start measurement
        """"""
        self._trigger = trigger
        internal = _trigger_context_to_value(trigger)
        self._write_channel(f'sens{""{0}""}:trig:sour int{internal}')
        self._write_channel(f'sens{""{0}""}:init:cont on')
        self._write_channel(f'sens{""{0}""}:init')

    def start_on_external(self, trigger: ExternalInput) -> None:
        """"""Attach external trigger to start the current measurement

        Args:
            trigger (ExternalInput): trigger that will start measurement
        """"""
        self._write_channel(f'sens{""{0}""}:trig:sour ext{trigger}')
        self._write_channel(f'sens{""{0}""}:init:cont on')
        self._write_channel(f'sens{""{0}""}:init')

    def abort(self) -> None:
        """"""Abort current measurement
        """"""
        self._write_channel('sens{0}:abor')

    def n_cycles_remaining(self) -> int:
        """"""
        Returns:
            int: Number of measurements remaining
        """"""
        return int(self._ask_channel('sens{0}:ncl?'))

    def n_available(self) -> int:
        """"""
        Returns:
            int: Number of measurements available
        """"""
        return int(self._ask_channel('sens{0}:data:poin?'))

    def available_A(self) -> Sequence[float]:
        """"""Retrieve current measurements

        The available measurements will be removed from measurement queue.

        Returns:
            Sequence[float]: list of available current measurements
        """"""
        # Bug circumvention
        if self.n_available() == 0:
            return list()
        return comma_sequence_to_list_of_floats(
            self._ask_channel('sens{0}:data:rem?'))

    def peek_A(self) -> float:
        """"""Peek at the first available current measurement

        Returns:
            float: current in Amperes
        """"""
        return float(self._ask_channel('sens{0}:data:last?'))

    def _set_aperture(self, aperture_s: Optional[float], nplc: Optional[int]
                      ) -> None:
        if aperture_s:
            return self._write_channel(f'sens{""{0}""}:aper {aperture_s}')
        self._write_channel(f'sens{""{0}""}:nplc {nplc}')

    def _set_triggering(self) -> None:
        self._write_channel('sens{0}:trig:sour bus')
        self._write_channel('sens{0}:init')


class QDac2Channel(InstrumentChannel):

    def __init__(self, parent: 'QDac2', name: str, channum: int):
        super().__init__(parent, name)
        self._channum = channum
        self.add_parameter(
            name='measurement_range',
            label='range',
            set_cmd='sens{1}:rang {0}'.format('{}', channum),
            get_cmd=f'sens{channum}:rang?',
            vals=validators.Enum('low', 'high')
        )
        self.add_parameter(
            name='measurement_aperture_s',
            label='aperture',
            unit='s',
            set_cmd='sens{1}:aper {0}'.format('{}', channum),
            get_cmd=f'sens{channum}:aper?',
            get_parser=float
        )
        self.add_parameter(
            name='measurement_nplc',
            label='PLC',
            set_cmd='sens{1}:nplc {0}'.format('{}', channum),
            get_cmd=f'sens{channum}:nplc?',
            get_parser=int
        )
        self.add_parameter(
            name='measurement_delay_s',
            label=f'delay',
            unit='s',
            set_cmd='sens{1}:del {0}'.format('{}', channum),
            get_cmd=f'sens{channum}:del?',
            get_parser=float
        )
        self.add_function(
            name='measurement_abort',
            call_cmd=f'sens{channum}:abor'
        )
        self.add_parameter(
            name='measurement_count',
            label='count',
            set_cmd='sens{1}:coun {0}'.format('{}', channum),
            get_cmd=f'sens{channum}:coun?',
            get_parser=int
        )
        self.add_parameter(
            name='n_masurements_remaining',
            label='remaning',
            get_cmd=f'sens{channum}:ncl?',
            get_parser=int
        )
        self.add_parameter(
            name='current_last_A',
            label='last',
            unit='A',
            get_cmd=f'sens{channum}:data:last?',
            get_parser=float
        )
        self.add_parameter(
            name='n_measurements_available',
            label='available',
            get_cmd=f'sens{channum}:data:poin?',
            get_parser=int
        )
        self.add_parameter(
            name='current_start_on',
            # Channel {channum} current measurement on internal trigger
            set_parser=_trigger_context_to_value,
            set_cmd='sens{1}:trig:sour int{0}'.format('{}', channum),
        )
        self.add_parameter(
            name='measurement_start_on_external',
            # Channel {channum} current measurement on external input
            set_cmd='sens{1}:trig:sour ext{0}'.format('{}', channum),
        )
        self.add_parameter(
            name='output_range',
            label='range',
            set_cmd='sour{1}:rang {0}'.format('{}', channum),
            get_cmd=f'sour{channum}:rang?',
            vals=validators.Enum('low', 'high')
        )
        self.add_parameter(
            name='output_low_range_minimum_V',
            label='low range min',
            unit='V',
            get_cmd=f'sour{channum}:rang:low:min?',
            get_parser=float
        )
        self.add_parameter(
            name='output_low_range_maximum_V',
            label='low voltage max',
            unit='V',
            get_cmd=f'sour{channum}:rang:low:max?',
            get_parser=float
        )
        self.add_parameter(
            name='output_high_range_minimum_V',
            label='high voltage min',
            unit='V',
            get_cmd=f'sour{channum}:rang:high:min?',
            get_parser=float
        )
        self.add_parameter(
            name='output_high_range_maximum_V',
            label='high voltage max',
            unit='V',
            get_cmd=f'sour{channum}:rang:high:max?',
            get_parser=float
        )
        self.add_parameter(
            name='output_filter',
            label=f'low-pass cut-off',
            unit='Hz',
            set_cmd='sour{1}:filt {0}'.format('{}', channum),
            get_cmd=f'sour{channum}:filt?',
            get_parser=str,
            vals=validators.Enum('dc', 'med', 'high')
        )
        self.add_parameter(
            name='dc_constant_V',
            label=f'ch{channum}',
            unit='V',
            set_cmd=self._set_fixed_voltage_immediately,
            get_cmd=f'sour{channum}:volt?',
            get_parser=float,
            vals=validators.Numbers(-10.0, 10.0)
        )
        self.add_parameter(
            name='dc_last_V',
            label=f'ch{channum}',
            unit='V',
            get_cmd=f'sour{channum}:volt:last?',
            get_parser=float
        )
        self.add_parameter(
            name='dc_next_V',
            label=f'ch{channum}',
            unit='V',
            set_cmd='sour{1}:volt:trig {0}'.format('{}', channum),
            get_cmd=f'sour{channum}:volt:trig?',
            get_parser=float
        )
        self.add_parameter(
            name='dc_slew_rate_V_per_s',
            label=f'ch{channum}',
            unit='V/s',
            set_cmd='sour{1}:volt:slew {0}'.format('{}', channum),
            get_cmd=f'sour{channum}:volt:slew?',
            get_parser=float
        )
        self.add_parameter(
            name='read_current_A',
            # Perform immediate current measurement on channel
            label=f'ch{channum}',
            unit='A',
            get_cmd=f'read{channum}?',
            get_parser=comma_sequence_to_list_of_floats
        )
        self.add_parameter(
            name='fetch_current_A',
            # Retrieve all available current measurements on channel
            label=f'ch{channum}',
            unit='A',
            get_cmd=f'fetc{channum}?',
            get_parser=comma_sequence_to_list_of_floats
        )
        self.add_parameter(
            name='dc_mode',
            label=f'DC mode',
            set_cmd='sour{1}:volt:mode {0}'.format('{}', channum),
            get_cmd=f'sour{channum}:volt:mode?',
            vals=validators.Enum('fixed', 'list', 'sweep')
        )
        self.add_function(
            name='dc_initiate',
            call_cmd=f'sour{channum}:dc:init'
        )
        self.add_function(
            name='dc_abort',
            call_cmd=f'sour{channum}:dc:abor'
        )
        self.add_function(
            name='abort',
            call_cmd=f'sour{channum}:all:abor'
        )

    @property
    def number(self) -> int:
        """"""Channel number""""""
        return self._channum

    def clear_measurements(self) -> Sequence[float]:
        """"""Retrieve current measurements

        The available measurements will be removed from measurement queue.

        Returns:
            Sequence[float]: list of available current measurements
        """"""
        # Bug circumvention
        if int(self.ask_channel('sens{0}:data:poin?')) == 0:
            return list()
        return comma_sequence_to_list_of_floats(
            self.ask_channel('sens{0}:data:rem?'))

    def measurement(self, delay_s: float = 0.0, repetitions: int = 1,
                    current_range: str = 'high',
                    aperture_s: Optional[float] = None,
                    nplc: Optional[int] = None
                    ) -> Measurement_Context:
        """"""Set up a sequence of current measurements

        Args:
            delay_s (float, optional): Seconds to delay the actual measurement after trigger (default 0)
            repetitions (int, optional): Number of consecutive measurements (default 1)
            current_range (str, optional): high (10mA, default) or low (200nA)
            nplc (None, optional): Integration time in power-line cycles (default 1)
            aperture_s (None, optional): Seconds of integration time instead of NPLC

        Returns:
            Measurement_Context: context manager

        Raises:
            ValueError: configuration error
        """"""
        if aperture_s and nplc:
            raise ValueError('Only one of nplc or aperture_s can be '
                             'specified for a current measurement')
        if not aperture_s and not nplc:
            nplc = 1
        return Measurement_Context(self, delay_s, repetitions, current_range,
                                   aperture_s, nplc)

    def output_mode(self, range: str = 'high', filter: str = 'high') -> None:
        """"""Set the output voltage

        Args:
            range (str, optional): Low or high (default) current range
            filter (str, optional): DC (10Hz), medium (10kHz) or high (300kHz, default) voltage filter
        """"""
        self.output_range(range)
        self.output_filter(filter)

    def dc_list(self, voltages: Sequence[float], repetitions: int = 1,
                dwell_s: float = 1e-03, delay_s: float = 0,
                backwards: bool = False, stepped: bool = False
                ) -> List_Context:
        """"""Set up a DC-list generator

        Args:
            voltages (Sequence[float]): Voltages in list
            repetitions (int, optional): Number of repetitions of the list (default 1)
            dwell_s (float, optional): Seconds between each voltage (default 1ms)
            delay_s (float, optional): Seconds of delay after receiving a trigger (default 0)
            backwards (bool, optional): Use list in reverse (default is forward)
            stepped (bool, optional): True means that each step needs to be triggered (default False)

        Returns:
            List_Context: context manager
        """"""
        return List_Context(self, voltages, repetitions, dwell_s, delay_s,
                            backwards, stepped)

    def dc_sweep(self, start_V: float, stop_V: float, points: int,
                 repetitions: int = 1, dwell_s: float = 1e-03,
                 delay_s: float = 0, backwards=False, stepped=True
                 ) -> Sweep_Context:
        """"""Set up a DC sweep

        Args:
            start_V (float): Start voltage
            stop_V (float): Send voltage
            points (int): Number of steps
            repetitions (int, optional): Number of repetition (default 1)
            dwell_s (float, optional): Seconds between each voltage (default 1ms)
            delay_s (float, optional): Seconds of delay after receiving a trigger (default 0)
            backwards (bool, optional): Sweep in reverse (default is forward)
            stepped (bool, optional): True means that each step needs to be triggered (default False)

        Returns:
            Sweep_Context: context manager
        """"""
        return Sweep_Context(self, start_V, stop_V, points, repetitions,
                             dwell_s, delay_s, backwards, stepped)

    def square_wave(self, frequency_Hz: Optional[float] = None,
                    period_s: Optional[float] = None, repetitions: int = -1,
                    duty_cycle_percent: float = 50.0, kind: str = 'symmetric',
                    inverted: bool = False, span_V: float = 0.2,
                    offset_V: float = 0.0, delay_s: float = 0,
                    slew_V_s: Optional[float] = None
                    ) -> Square_Context:
        """"""Set up a square-wave generator

        Args:
            frequency_Hz (float, optional): Frequency
            period_s (float, optional): Period length (instead of frequency)
            repetitions (int, optional): Number of repetition (default infinite)
            duty_cycle_percent (float, optional): Percentage on-time (default 50%)
            kind (str, optional): Positive, negative or symmetric (default) around the offset
            inverted (bool, optional): True means flipped (default False)
            span_V (float, optional): Voltage span (default 200mV)
            offset_V (float, optional): Offset (default 0V)
            delay_s (float, optional): Seconds of delay after receiving a trigger (default 0)
            slew_V_s (float, optional): Max slew rate in V/s (default None)

        Returns:
            Square_Context: context manager

        Raises:
            ValueError: configuration error
        """"""
        if frequency_Hz and period_s:
            raise ValueError(error_ambiguous_wave)
        if not frequency_Hz and not period_s:
            frequency_Hz = 1000
        return Square_Context(self, frequency_Hz, repetitions, period_s,
                              duty_cycle_percent, kind, inverted, span_V,
                              offset_V, delay_s, slew_V_s)

    def sine_wave(self, frequency_Hz: Optional[float] = None,
                  period_s: Optional[float] = None, repetitions: int = -1,
                  inverted: bool = False, span_V: float = 0.2,
                  offset_V: float = 0.0, delay_s: float = 0,
                  slew_V_s: Optional[float] = None
                  ) -> Sine_Context:
        """"""Set up a sine-wave generator

        Args:
            frequency_Hz (float, optional): Frequency
            period_s (float, optional): Period length (instead of frequency)
            repetitions (int, optional): Number of repetition (default infinite)
            inverted (bool, optional): True means flipped (default False)
            span_V (float, optional): Voltage span (default 200mV)
            offset_V (float, optional): Offset (default 0V)
            delay_s (float, optional): Seconds of delay after receiving a trigger (default 0)
            slew_V_s (None, optional): Max slew rate in V/s (default None)

        Returns:
            Sine_Context: context manager

        Raises:
            ValueError: configuration error
        """"""
        if frequency_Hz and period_s:
            raise ValueError(error_ambiguous_wave)
        if not frequency_Hz and not period_s:
            frequency_Hz = 1000
        return Sine_Context(self, frequency_Hz, repetitions, period_s,
                            inverted, span_V, offset_V, delay_s, slew_V_s)

    def triangle_wave(self, frequency_Hz: Optional[float] = None,
                      period_s: Optional[float] = None, repetitions: int = -1,
                      duty_cycle_percent: float = 50.0, inverted: bool = False,
                      span_V: float = 0.2, offset_V: float = 0.0,
                      delay_s: float = 0, slew_V_s: Optional[float] = None
                      ) -> Triangle_Context:
        """"""Set up a triangle-wave generator

        Args:
            frequency_Hz (float, optional): Frequency
            period_s (float, optional): Period length (instead of frequency)
            repetitions (int, optional): Number of repetition (default infinite)
            duty_cycle_percent (float, optional): Percentage on-time (default 50%)
            inverted (bool, optional): True means flipped (default False)
            span_V (float, optional): Voltage span (default 200mV)
            offset_V (float, optional): Offset (default 0V)
            delay_s (float, optional): Seconds of delay after receiving a trigger (default 0)
            slew_V_s (float, optional): Max slew rate in V/s (default None)

        Returns:
            Triangle_Context: context manager

        Raises:
            ValueError: configuration error
        """"""
        if frequency_Hz and period_s:
            raise ValueError(error_ambiguous_wave)
        if not frequency_Hz and not period_s:
            frequency_Hz = 1000
        return Triangle_Context(self, frequency_Hz, repetitions, period_s,
                                duty_cycle_percent, inverted, span_V,
                                offset_V, delay_s, slew_V_s)

    def arbitrary_wave(self, trace_name: str, repetitions: int = 1,
                       scale: float = 1.0, offset_V: float = 0.0,
                       slew_V_s: Optional[float] = None
                       ) -> Awg_Context:
        """"""Set up an arbitrary-wave generator

        Args:
            trace_name (str): Use data from this named trace
            repetitions (int, optional): Number of repetition (default 1)
            scale (float, optional): Scaling factor of voltages (default 1)
            offset_V (float, optional): Offset (default 0V)
            slew_V_s (None, optional): Max slew rate in V/s (default None)

        Returns:
            Awg_Context: context manager
        """"""
        return Awg_Context(self, trace_name, repetitions, scale, offset_V,
                           slew_V_s)

    def _set_fixed_voltage_immediately(self, v) -> None:
        self.write(f'sour{self._channum}:volt:mode fix')
        self.write(f'sour{self._channum}:volt {v}')

    def ask_channel(self, cmd: str) -> str:
        """"""Inject channel number into SCPI query

        Arguments:
            cmd (str): Must contain a '{0}' placeholder for the channel number

        Returns:
            str: SCPI answer
        """"""
        return self.ask(self._channel_message(cmd))

    def write_channel(self, cmd: str) -> None:
        """"""Inject channel number into SCPI command

        Arguments:
            cmd (str): Must contain a '{0}' placeholder for the channel number
        """"""
        self.write(self._channel_message(cmd))

    def write_channel_floats(self, cmd: str, values: Sequence[float]) -> None:
        """"""Inject channel number and a list of values into SCPI command

        The values are appended to the end of the command.

        Arguments:
            cmd (str): Must contain a '{0}' placeholder for channel number
            values (Sequence[float]): Sequence of numbers
        """"""
        self._parent.write_floats(self._channel_message(cmd), values)

    def write(self, cmd: str) -> None:
        """"""Send a SCPI command

        Args:
            cmd (str): SCPI command
        """"""
        self._parent.write(cmd)

    def _channel_message(self, template: str):
        return template.format(self._channum)


class Trace_Context:

    def __init__(self, parent, name: str, size: int):
        self._parent = parent
        self._size = size
        self._name = name
        self._parent.write(f'trac:def ""{name}"",{size}')

    def __len__(self):
        return self.size

    @property
    def size(self) -> int:
        """"""Number of values in trace""""""
        return self._size

    @property
    def name(self) -> str:
        """"""Name of trace""""""
        return self._name

    def waveform(self, values: Sequence[float]) -> None:
        """"""Fill values into trace

        Args:
            values (Sequence[float]): Sequence of values

        Raises:
            ValueError: size mismatch
        """"""
        if len(values) != self.size:
            raise ValueError(f'trace length {len(values)} does not match '
                             f'allocated length {self.size}')
        self._parent.write_floats(f'trac:data ""{self.name}"",', values)


class Virtual_Sweep_Context:

    def __init__(self, arrangement: 'Arrangement_Context', sweep: np.ndarray,
                 start_trigger: Optional[str], step_time_s: float,
                 step_trigger: Optional[str], repetitions: Optional[int]):
        self._arrangement = arrangement
        self._sweep = sweep
        self._step_trigger = step_trigger
        self._step_time_s = step_time_s
        self._repetitions = repetitions
        self._allocate_triggers(start_trigger)
        self._qdac_ready = False

    def __enter__(self):
        self._ensure_qdac_setup()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Let Arrangement take care of freeing triggers
        return False

    def actual_values_V(self, contact: str) -> np.ndarray:
        """"""The corrected values that would actually be sent to the contact

        Args:
            contact (str): Name of contact

        Returns:
            np.ndarray: Corrected voltages
        """"""
        index = self._arrangement._contact_index(contact)
        return self._sweep[:, index]

    def start(self) -> None:
        """"""Start the 2D sweep
        """"""
        self._ensure_qdac_setup()
        trigger = self._arrangement.get_trigger_by_name(self._start_trigger_name)
        self._arrangement._qdac.trigger(trigger)

    def _allocate_triggers(self, start_sweep: Optional[str]) -> None:
        if not start_sweep:
            # Use a random, unique name
            start_sweep = uuid.uuid4().hex
        self._arrangement._allocate_internal_triggers([start_sweep])
        self._start_trigger_name = start_sweep

    def _ensure_qdac_setup(self) -> None:
        if self._qdac_ready:
            return self._make_ready_to_start()
        self._route_inner_trigger()
        self._send_lists_to_qdac()
        self._qdac_ready = True

    def _route_inner_trigger(self) -> None:
        if not self._step_trigger:
            return
        trigger = self._arrangement.get_trigger_by_name(self._step_trigger)
        # All channels change in sync, so just use the first channel to make the
        # external trigger.
        channel = self._get_channel(0)
        channel.write_channel(f'sour{""{0}""}:dc:mark:sst '
                              f'{_trigger_context_to_value(trigger)}')

    def _get_channel(self, contact_index: int) -> 'QDac2Channel':
        channel_number = self._arrangement._channels[contact_index]
        qdac = self._arrangement._qdac
        return qdac.channel(channel_number)

    def _send_lists_to_qdac(self) -> None:
        for contact_index in range(self._arrangement.shape):
            self._send_list_to_qdac(contact_index, self._sweep[:, contact_index])

    def _send_list_to_qdac(self, contact_index, voltages):
        channel = self._get_channel(contact_index)
        dc_list = channel.dc_list(voltages=voltages, dwell_s=self._step_time_s,
                                  repetitions=self._repetitions)
        trigger = self._arrangement.get_trigger_by_name(self._start_trigger_name)
        dc_list.start_on(trigger)

    def _make_ready_to_start(self):  # Bug circumvention
        for contact_index in range(self._arrangement.shape):
            channel = self._get_channel(contact_index)
            channel.write_channel('sour{0}:dc:init')


class Arrangement_Context:
    def __init__(self, qdac: 'QDac2', contacts: Dict[str, int],
                 output_triggers: Optional[Dict[str, int]],
                 internal_triggers: Optional[Sequence[str]]):
        self._qdac = qdac
        self._fix_contact_order(contacts)
        self._allocate_triggers(internal_triggers, output_triggers)
        self._correction = np.identity(self.shape)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._free_triggers()
        return False

    @property
    def shape(self) -> int:
        """"""Number of contacts in the arrangement""""""
        return len(self._contacts)

    @property
    def correction_matrix(self) -> np.ndarray:
        """"""Correction matrix""""""
        return self._correction

    @property
    def contact_names(self) -> Sequence[str]:
        """"""
        Returns:
            Sequence[str]: Contact names in the same order as channel_numbers
        """"""
        return self._contact_names

    def _allocate_internal_triggers(self,
                                    internal_triggers: Optional[Sequence[str]]
                                    ) -> None:
        if not internal_triggers:
            return
        for name in internal_triggers:
            self._internal_triggers[name] = self._qdac.allocate_trigger()

    def initiate_correction(self, contact: str, factors: Sequence[float]) -> None:
        """"""Override how much a particular contact influences the other contacts

        Args:
            contact (str): Name of contact
            factors (Sequence[float]): factors between -1.0 and 1.0
        """"""
        index = self._contact_index(contact)
        self._correction[index] = factors

    def set_virtual_voltage(self, contact: str, voltage: float) -> None:
        """"""Set virtual voltage on specific contact

        The actual voltage that the contact will receive depends on the
        correction matrix.

        Args:
            contact (str): Name of contact
            voltage (float): Voltage corresponding to no correction
        """"""
        try:
            index = self._contact_index(contact)
        except KeyError:
            raise ValueError(f'No contact named ""{contact}""')
        self._effectuate_virtual_voltage(index, voltage)

    def set_virtual_voltages(self, contacts_to_voltages: Dict[str, float]) -> None:
        """"""Set virtual voltages on specific contacts in one go

        The actual voltage that each contact will receive depends on the
        correction matrix.

        Args:
            contact_to_voltages (Dict[str,float]): contact to voltage map
        """"""
        for contact, voltage in contacts_to_voltages.items():
            try:
                index = self._contact_index(contact)
            except KeyError:
                raise ValueError(f'No contact named ""{contact}""')
            self._virtual_voltages[index] = voltage
        self._effectuate_virtual_voltages()

    def _effectuate_virtual_voltage(self, index: int, voltage: float) -> None:
        self._virtual_voltages[index] = voltage
        self._effectuate_virtual_voltages()

    def _effectuate_virtual_voltages(self) -> None:
        for index, channel_number in enumerate(self._channels):
            actual_V = self.actual_voltages()[index]
            self._qdac.channel(channel_number).dc_constant_V(actual_V)

    def add_correction(self, contact: str, factors: Sequence[float]) -> None:
        """"""Update how much a particular contact influences the other contacts

        This is mostly useful in arrangements where each contact has significant
        effect only on nearby contacts, and thus can be added incrementally.

        The factors are extended by the identity matrix and multiplied to the
        correction matrix.

        Args:
            contact (str): Name of contact
            factors (Sequence[float]): factors usually between -1.0 and 1.0
        """"""
        index = self._contact_index(contact)
        multiplier = np.identity(self.shape)
        multiplier[index] = factors
        self._correction = np.matmul(multiplier, self._correction)

    def _fix_contact_order(self, contacts: Dict[str, int]) -> None:
        self._contact_names = list()
        self._contacts = dict()
        self._channels = list()
        index = 0
        for contact, channel in contacts.items():
            self._contact_names.append(contact)
            self._contacts[contact] = index
            index += 1
            self._channels.append(channel)
        self._virtual_voltages = np.zeros(self.shape)

    @property
    def channel_numbers(self) -> Sequence[int]:
        """"""
        Returns:
            Sequence[int]: Channels numbers in the same order as contact_names
        """"""
        return self._channels

    def channel(self, name: str) -> QDac2Channel:
        return self._qdac.channel(self._channels[self._contacts[name]])

    def virtual_voltage(self, contact: str) -> float:
        """"""
        Args:
            contact (str): Name of contact

        Returns:
            float: Voltage before correction
        """"""
        index = self._contact_index(contact)
        return self._virtual_voltages[index]

    def actual_voltages(self) -> Sequence[float]:
        """"""
        Returns:
            Sequence[float]: Corrected voltages for all contacts
        """"""
        vs = np.matmul(self._correction, self._virtual_voltages)
        if self._qdac._round_off:
            vs = np.round(vs, self._qdac._round_off)
        return list(vs)

    def get_trigger_by_name(self, name: str) -> QDac2Trigger_Context:
        """"""
        Args:
            name (str): Name of trigger

        Returns:
            QDac2Trigger_Context: Trigger context manager
        """"""
        try:
            return self._internal_triggers[name]
        except KeyError:
            print(f'Internal triggers: {list(self._internal_triggers.keys())}')
            raise

    def _all_channels_as_suffix(self) -> str:
        channels_str = ints_to_comma_separated_list(self.channel_numbers)
        return f'(@{channels_str})'

    def currents_A(self, nplc: int = 1, current_range: str = ""low"") -> Sequence[float]:
        """"""Measure currents on all contacts

        Args:
            nplc (int, optional): Number of powerline cycles to average over
            current_range (str, optional): Current range (default low)
        """"""
        channels_suffix = self._all_channels_as_suffix()
        self._qdac.write(f'sens:rang {current_range},{channels_suffix}')
        self._qdac.write(f'sens:nplc {nplc},{channels_suffix}')
        # Discard first reading because of possible output-capacitor effects, etc
        slowest_line_freq_Hz = 50
        sleep_s(1 / slowest_line_freq_Hz)
        self._qdac.ask(f'read? {channels_suffix}')
        # Then make a proper reading
        sleep_s((nplc + 1) / slowest_line_freq_Hz)
        currents = self._qdac.ask(f'read? {channels_suffix}')
        return comma_sequence_to_list_of_floats(currents)

    def virtual_sweep(self, contact: str, voltages: Sequence[float],
                      start_sweep_trigger: Optional[str] = None,
                      step_time_s: float = 1e-5,
                      step_trigger: Optional[str] = None,
                      repetitions: int = 1) -> Virtual_Sweep_Context:
        """"""Sweep a contact to create a 1D sweep

        Args:
            contact (str): Name of sweeping contact
            voltages (Sequence[float]): Virtual sweep voltages
            outer_contact (str): Name of slow-changing (outer) contact
            start_sweep_trigger (None, optional): Trigger that starts sweep
            step_time_s (float, optional): Delay between voltage changes
            step_trigger (None, optional): Trigger that marks each step
            repetitions (int, Optional): Number of back-and-forth sweeps, or -1 for infinite

        Returns:
            Virtual_Sweep_Context: context manager
        """"""
        sweep = self._calculate_1d_values(contact, voltages)
        return Virtual_Sweep_Context(self, sweep, start_sweep_trigger,
                                     step_time_s, step_trigger, repetitions)

    def _calculate_1d_values(self, contact: str, voltages: Sequence[float]
                             ) -> np.ndarray:
        original_voltage = self.virtual_voltage(contact)
        index = self._contact_index(contact)
        sweep = list()
        for v in voltages:
            self._virtual_voltages[index] = v
            sweep.append(self.actual_voltages())
        self._virtual_voltages[index] = original_voltage
        return np.array(sweep)

    def virtual_sweep2d(self, inner_contact: str, inner_voltages: Sequence[float],
                        outer_contact: str, outer_voltages: Sequence[float],
                        start_sweep_trigger: Optional[str] = None,
                        inner_step_time_s: float = 1e-5,
                        inner_step_trigger: Optional[str] = None,
                        repetitions: int = 1) -> Virtual_Sweep_Context:
        """"""Sweep two contacts to create a 2D sweep

        Args:
            inner_contact (str): Name of fast-changing (inner) contact
            inner_voltages (Sequence[float]): Inner contact virtual voltages
            outer_contact (str): Name of slow-changing (outer) contact
            outer_voltages (Sequence[float]): Outer contact virtual voltages
            start_sweep_trigger (None, optional): Trigger that starts sweep
            inner_step_time_s (float, optional): Delay between voltage changes
            inner_step_trigger (None, optional): Trigger that marks each step
            repetitions (int, Optional): Number of back-and-forth sweeps, or -1 for infinite

        Returns:
            Virtual_Sweep_Context: context manager
        """"""
        sweep = self._calculate_2d_values(inner_contact, inner_voltages,
                                          outer_contact, outer_voltages)
        return Virtual_Sweep_Context(self, sweep, start_sweep_trigger,
                                     inner_step_time_s, inner_step_trigger, repetitions)

    def _calculate_2d_values(self, inner_contact: str,
                             inner_voltages: Sequence[float],
                             outer_contact: str,
                             outer_voltages: Sequence[float]) -> np.ndarray:
        original_fast_voltage = self.virtual_voltage(inner_contact)
        original_slow_voltage = self.virtual_voltage(outer_contact)
        outer_index = self._contact_index(outer_contact)
        inner_index = self._contact_index(inner_contact)
        sweep = list()
        for slow_V in outer_voltages:
            self._virtual_voltages[outer_index] = slow_V
            for fast_V in inner_voltages:
                self._virtual_voltages[inner_index] = fast_V
                sweep.append(self.actual_voltages())
        self._virtual_voltages[inner_index] = original_fast_voltage
        self._virtual_voltages[outer_index] = original_slow_voltage
        return np.array(sweep)

    def virtual_detune(self, contacts: Sequence[str], start_V: Sequence[float],
                       end_V: Sequence[float], steps: int,
                       start_trigger: Optional[str] = None,
                       step_time_s: float = 1e-5,
                       step_trigger: Optional[str] = None,
                       repetitions: int = 1) -> Virtual_Sweep_Context:
        """"""Sweep any number of contacts linearly from one set of values to another set of values

        Args:
            contacts (Sequence[str]): contacts involved in sweep
            start_V (Sequence[float]): First-extreme values
            end_V (Sequence[float]): Second-extreme values
            steps (int): Number of steps between extremes
            start_trigger (None, optional): Trigger that starts sweep
            step_time_s (float, Optional): Seconds between each step
            step_trigger (None, optional): Trigger that marks each step
            repetitions (int, Optional): Number of back-and-forth sweeps, or -1 for infinite
        """"""
        self._check_same_lengths(contacts, start_V, end_V)
        sweep = self._calculate_detune_values(contacts, start_V, end_V, steps)
        return Virtual_Sweep_Context(self, sweep, start_trigger, step_time_s,
                                     step_trigger, repetitions)

    @staticmethod
    def _check_same_lengths(contacts, start_V, end_V) -> None:
        n_contacts = len(contacts)
        if n_contacts != len(start_V):
            raise ValueError(f'There must be exactly one voltage per contact: {start_V}')
        if n_contacts != len(end_V):
            raise ValueError(f'There must be exactly one voltage per contact: {end_V}')

    def _calculate_detune_values(self, contacts: Sequence[str], start_V: Sequence[float],
                                 end_V: Sequence[float], steps: int):
        original_voltages = [self.virtual_voltage(contact) for contact in contacts]
        indices = [self._contact_index(contact) for contact in contacts]
        sweep = list()
        forward_V = [forward_and_back(start_V[i], end_V[i], steps) for i in range(len(contacts))]
        for voltages in zip(*forward_V):
            for index, voltage in zip(indices, voltages):
                self._virtual_voltages[index] = voltage
            sweep.append(self.actual_voltages())
        for index, voltage in zip(indices, original_voltages):
            self._virtual_voltages[index] = voltage
        return np.array(sweep)

    def leakage(self, modulation_V: float, nplc: int = 2) -> np.ndarray:
        """"""Run a simple leakage test between the contacts

        Each contact is changed in turn and the resulting change in current from
        steady-state is recorded.  The resulting resistance matrix is calculated
        as modulation_voltage divided by current_change.

        Args:
            modulation_V (float): Virtual voltage added to each contact
            nplc (int, Optional): Powerline cycles to wait for each measurement

        Returns:
            ndarray: contact-to-contact resistance in Ohms
        """"""
        steady_state_A, currents_matrix = self._leakage_currents(modulation_V, nplc, 'low')
        with np.errstate(divide='ignore'):
            return np.abs(modulation_V / diff_matrix(steady_state_A, currents_matrix))

    def _leakage_currents(self, modulation_V: float, nplc: int,
                          current_range: str
                          ) -> Tuple[Sequence[float], Sequence[Sequence[float]]]:
        steady_state_A = self.currents_A(nplc, 'low')
        currents_matrix = list()
        for index, channel_nr in enumerate(self.channel_numbers):
            original_V = self._virtual_voltages[index]
            self._effectuate_virtual_voltage(index, original_V + modulation_V)
            currents = self.currents_A(nplc, current_range)
            self._effectuate_virtual_voltage(index, original_V)
            currents_matrix.append(currents)
        return steady_state_A, currents_matrix

    def _contact_index(self, contact: str) -> int:
        return self._contacts[contact]

    def _allocate_triggers(self, internal_triggers: Optional[Sequence[str]],
                           output_triggers: Optional[Dict[str, int]]
                           ) -> None:
        self._internal_triggers: Dict[str, QDac2Trigger_Context] = dict()
        self._allocate_internal_triggers(internal_triggers)
        self._allocate_external_triggers(output_triggers)

    def _allocate_external_triggers(self, output_triggers:
                                    Optional[Dict[str, int]]
                                    ) -> None:
        self._external_triggers = dict()
        if not output_triggers:
            return
        for name, port in output_triggers.items():
            self._external_triggers[name] = port
            trigger = self._qdac.allocate_trigger()
            self._qdac.connect_external_trigger(port, trigger)
            self._internal_triggers[name] = trigger

    def _free_triggers(self) -> None:
        for trigger in self._internal_triggers.values():
            self._qdac.free_trigger(trigger)


def forward_and_back(start: float, end: float, steps: int):
    forward = np.linspace(start, end, steps)
    backward = np.flip(forward)[1:][:-1]
    back_and_forth = itertools.chain(forward, backward)
    return back_and_forth


class QDac2(VisaInstrument):

    def __init__(self, name: str, address: str, **kwargs) -> None:
        """"""Connect to a QDAC-II

        Args:
            name (str): Name for instrument
            address (str): Visa identification string
            **kwargs: additional argument to the Visa driver
        """"""
        self._check_instrument_name(name)
        super().__init__(name, address, terminator='\n', **kwargs)
        self._set_up_serial()
        self._set_up_debug_settings()
        self._set_up_channels()
        self._set_up_external_triggers()
        self._set_up_internal_triggers()
        self._set_up_simple_functions()
        self.connect_message()
        self._check_for_wrong_model()
        self._check_for_incompatiable_firmware()
        self._set_up_manual_triggers()

    def n_channels(self) -> int:
        """"""
        Returns:
            int: Number of channels
        """"""
        return len(self.submodules['channels'])

    def channel(self, ch: int) -> QDac2Channel:
        """"""
        Args:
            ch (int): Channel number

        Returns:
            QDac2Channel: Visa representation of the channel
        """"""
        return getattr(self, f'ch{ch:02}')

    @staticmethod
    def n_triggers() -> int:
        """"""
        Returns:
            int: Number of internal triggers
        """"""
        return 14

    @staticmethod
    def n_external_inputs() -> int:
        """"""
        Returns:
            int: Number of external input triggers
        """"""
        return 4

    def n_external_outputs(self) -> int:
        """"""
        Returns:
            int: Number of external output triggers
        """"""
        return len(self.submodules['external_triggers'])

    def allocate_trigger(self) -> QDac2Trigger_Context:
        """"""Allocate an internal trigger

        Does not have any effect on the instrument, only the driver.

        Returns:
            QDac2Trigger_Context: Context manager

        Raises:
            ValueError: no free triggers
        """"""
        try:
            number = self._internal_triggers.pop()
        except KeyError:
            raise ValueError('no free internal triggers')
        return QDac2Trigger_Context(self, number)

    def free_trigger(self, trigger: QDac2Trigger_Context) -> None:
        """"""Free an internal trigger

        Does not have any effect on the instrument, only the driver.

        Args:
            trigger (QDac2Trigger_Context): trigger to free
        """"""
        internal = _trigger_context_to_value(trigger)
        self._internal_triggers.add(internal)

    def free_all_triggers(self) -> None:
        """"""Free all an internal triggers

        Does not have any effect on the instrument, only the driver.
        """"""
        self._set_up_internal_triggers()

    def connect_external_trigger(self, port: int, trigger: QDac2Trigger_Context,
                                 width_s: float = 1e-6
                                 ) -> None:
        """"""Route internal trigger to external trigger

        Args:
            port (int): External output trigger number
            trigger (QDac2Trigger_Context): Internal trigger
            width_s (float, optional): Output trigger width in seconds (default 1ms)
        """"""
        internal = _trigger_context_to_value(trigger)
        self.write(f'outp:trig{port}:sour int{internal}')
        self.write(f'outp:trig{port}:widt {width_s}')

    def reset(self) -> None:
        self.write('*rst')
        sleep_s(5)

    def errors(self) -> str:
        """"""Retrieve and clear all previous errors

        Returns:
            str: Comma separated list of errors or '0, ""No error""'
        """"""
        return self.ask('syst:err:all?')

    def error(self) -> str:
        """"""Retrieve next error

        Returns:
            str: The next error or '0, ""No error""'
        """"""
        return self.ask('syst:err?')

    def n_errors(self) -> int:
        """"""Peek at number of previous errors

        Returns:
            int: Number of errors
        """"""
        return int(self.ask('syst:err:coun?'))

    def start_all(self) -> None:
        """"""Trigger the global SCPI bus (``*TRG``)

        All generators, that have not been explicitly set to trigger on an
        internal or external trigger, will be started.
        """"""
        self.write('*trg')

    def remove_traces(self) -> None:
        """"""Delete all trace definitions from the instrument

        This means that all AWGs loose their data.
        """"""
        self.write('trac:rem:all')

    def traces(self) -> Sequence[str]:
        """"""List all defined traces

        Returns:
            Sequence[str]: trace names
        """"""
        return comma_sequence_to_list(self.ask('trac:cat?'))

    def allocate_trace(self, name: str, size: int) -> Trace_Context:
        """"""Reserve memory for a new trace

        Args:
            name (str): Name of new trace
            size (int): Number of voltage values in the trace

        Returns:
            Trace_Context: context manager
        """"""
        return Trace_Context(self, name, size)

    def mac(self) -> str:
        """"""
        Returns:
            str: Media Access Control (MAC) address of the instrument
        """"""
        mac = self.ask('syst:comm:lan:mac?')
        return f'{mac[1:3]}-{mac[3:5]}-{mac[5:7]}-{mac[7:9]}-{mac[9:11]}' \
               f'-{mac[11:13]}'

    def arrange(self, contacts: Dict[str, int],
                output_triggers: Optional[Dict[str, int]] = None,
                internal_triggers: Optional[Sequence[str]] = None
                ) -> Arrangement_Context:
        """"""An arrangement of contacts and triggers for virtual gates

        Each contact corresponds to a particular output channel.  Each
        output_trigger corresponds to a particular external output trigger.
        Each internal_trigger will be allocated from the pool of internal
        triggers, and can later be used for synchronisation.  After
        initialisation of the arrangement, contacts and triggers can only be
        referred to by name.

        The voltages that will appear on each contact depends not only on the
        specified virtual voltage, but also on a correction matrix.  Initially,
        the contacts are assumed to not influence each other, which means that
        the correction matrix is the identity matrix, ie. the row for
        each contact has a value of [0, ..., 0, 1, 0, ..., 0].

        Args:
            contacts (Dict[str, int]): Name/channel pairs
            output_triggers (Sequence[Tuple[str,int]], optional): Name/number pairs of output triggers
            internal_triggers (Sequence[str], optional): List of names of internal triggers to allocate

        Returns:
            Arrangement_Context: context manager
        """"""
        return Arrangement_Context(self, contacts, output_triggers,
                                   internal_triggers)

    # -----------------------------------------------------------------------
    # Instrument-wide functions
    # -----------------------------------------------------------------------

    # -----------------------------------------------------------------------
    # Debugging and testing

    def start_recording_scpi(self) -> None:
        """"""Record all SCPI commands sent to the instrument

        Any previous recordings are removed.  To inspect the SCPI commands sent
        to the instrument, call get_recorded_scpi_commands().
        """"""
        self._scpi_sent: List[str] = list()
        self._record_commands = True

    def get_recorded_scpi_commands(self) -> List[str]:
        """"""
        Returns:
            Sequence[str]: SCPI commands sent to the instrument
        """"""
        commands = self._scpi_sent
        self._scpi_sent = list()
        return commands

    def clear(self) -> None:
        """"""Reset the VISA message queue of the instrument
        """"""
        self.visa_handle.clear()

    def clear_read_queue(self) -> Sequence[str]:
        """"""Flush the VISA message queue of the instrument

        Takes at least _message_flush_timeout_ms to carry out.

        Returns:
            Sequence[str]: Messages lingering in queue
        """"""
        lingering = list()
        original_timeout = self.visa_handle.timeout
        self.visa_handle.timeout = self._message_flush_timeout_ms
        while True:
            try:
                message = self.visa_handle.read()
            except VisaIOError:
                break
            else:
                lingering.append(message)
        self.visa_handle.timeout = original_timeout
        return lingering

    # -----------------------------------------------------------------------
    # Override communication methods to make it possible to record the
    # communication with the instrument.

    def write(self, cmd: str) -> None:
        """"""Send SCPI command to instrument

        Args:
            cmd (str): SCPI command
        """"""
        if self._record_commands:
            self._scpi_sent.append(cmd)
        super().write(cmd)

    def ask(self, cmd: str) -> str:
        """"""Send SCPI query to instrument

        Args:
            cmd (str): SCPI query

        Returns:
            str: SCPI answer
        """"""
        if self._record_commands:
            self._scpi_sent.append(cmd)
        answer = super().ask(cmd)
        return answer

    def write_floats(self, cmd: str, values: Sequence[float]) -> None:
        """"""Append a list of values to a SCPI command

        By default, the values are IEEE binary encoded.

        Remember to include separating space in command if needed.
        """"""
        if self._no_binary_values:
            compiled = f'{cmd}{floats_to_comma_separated_list(values)}'
            if self._record_commands:
                self._scpi_sent.append(compiled)
            return super().write(compiled)
        if self._record_commands:
            self._scpi_sent.append(f'{cmd}{floats_to_comma_separated_list(values)}')
        self.visa_handle.write_binary_values(cmd, values)

    # -----------------------------------------------------------------------

    def _set_up_debug_settings(self) -> None:
        self._record_commands = False
        self._scpi_sent = list()
        self._message_flush_timeout_ms = 1
        self._round_off = None
        self._no_binary_values = False

    def _set_up_serial(self) -> None:
        # No harm in setting the speed even if the connection is not serial.
        self.visa_handle.baud_rate = 921600  # type: ignore

    def _check_for_wrong_model(self) -> None:
        model = self.IDN()['model']
        if model != 'QDAC-II':
            raise ValueError(f'Unknown model {model}. Are you using the right'
                             ' driver for your instrument?')

    def _check_for_incompatiable_firmware(self) -> None:
        # Only compare the firmware, not the FPGA version
        firmware = split_version_string_into_components(self.IDN()['firmware'])[1]
        least_compatible_fw = '0.17.5'
        if parse(firmware) < parse(least_compatible_fw):
            raise ValueError(f'Incompatible firmware {firmware}. You need at '
                             f'least {least_compatible_fw}')

    def _set_up_channels(self) -> None:
        channels = ChannelList(self, 'Channels', QDac2Channel,
                               snapshotable=False)
        for i in range(1, 24 + 1):
            name = f'ch{i:02}'
            channel = QDac2Channel(self, name, i)
            self.add_submodule(name, channel)
            channels.append(channel)
        channels.lock()
        self.add_submodule('channels', channels)

    def _set_up_external_triggers(self) -> None:
        triggers = ChannelList(self, 'Channels', QDac2ExternalTrigger,
                               snapshotable=False)
        for i in range(1, 5 + 1):
            name = f'ext{i}'
            trigger = QDac2ExternalTrigger(self, name, i)
            self.add_submodule(name, trigger)
            triggers.append(trigger)
        triggers.lock()
        self.add_submodule('external_triggers', triggers)

    def _set_up_internal_triggers(self) -> None:
        # A set of the available internal triggers
        self._internal_triggers = set(range(1, self.n_triggers() + 1))

    def _set_up_manual_triggers(self) -> None:
        self.add_parameter(
            name='trigger',
            # Manually trigger event
            set_parser=_trigger_context_to_value,
            set_cmd='tint {}',
        )

    def _set_up_simple_functions(self) -> None:
        self.add_function('abort', call_cmd='abor')

    def _check_instrument_name(self, name: str) -> None:
        if name.isidentifier():
            return
        raise ValueError(
            f'Instrument name ""{name}"" is incompatible with QCoDeS parameter '
            'generation (no spaces, punctuation, prepended numbers, etc)')
"
81,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attjFawHPuZIhCIvm'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Tcao1N7OjTvm_2bwlC4Mwg/aP_f6S0BamNesjU-q2zhpCiS9upeMJsEQxZa-lX-TMeX71Mn8n2gKW1YawqiLrLJeo6MDp0Ago5xU6LIFoeFl6VTXh1kAFB246S_Hky5p0Vwrs0j-78IGUGPjtB67KZO/HmUcO-eyZGv5AC1U4DPugwty6vnSr155Gn7ITTNfyEo'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1NRe1eslamsBwGo5bYw-3w/KIclcvgjqHOkBu-lPO3LKD0vcMBZTFXpxe_yztwHQB3i6YbTxRk1pOjziHHsIPcc4-xJbfsMSvPWNIryXJ-H-w/aLrNaWpAV5bb4JC8Sj8B2bSe8oIW-_1c4Lq_25p84a8'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y4VtEMjAX8RN4wNi43Rv0g/I3WMLg0vmihz1eV3ZvbeGQb1yzQnv-AIDccgh3PMgSICbwPk0UglR0Aa6juUm6EEiRJju8eoRlYKw8s6Ec0eGA/lcU21GVvJ7Bkw-HEqH_WExtJvhjsccUvT-4v5OSqk3k'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sUUfTZ7JxfttdhubXl2_Jw/1CDC8kJyuNM7f2GiyqAAZE4-btZwBvNj_RVfRMC2KyT11RIBr7paLAQIAqHrQgK3jF1CwLCxqzxD941qe_rEaA/dOmd6KSbbHew9ePHQtH-MtkoRnQD0BmYwk7O-MB-Ka0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-1N Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 63 dB and a step size of 1.0 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-302p-1n-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-1N,Write a Python script that uses Qcodes Community to connect to a LDA-302P-1N ,615.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
83,https://www.thorlabs.com/_sd.cfm?fileName=ETN012604-D02.pdf&partNumber=MFF102,,"[OrderedDict([('id', 'attf8Uyrio0EVO37O'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rw04_HyTdQYbnMrW1f4_3Q/-vV1AP_B6VxYcS6bDhJtN_GN14KUQ1X2Wkce1CH5zfTkzCPTNI9854rR1KTA67J6PFVjVFKC60_zLk1DRx21eIPvruUX_vmqihnRBhRF3Rle-D844nrqh5Iw-wuuN450/MR7lVcvo9h9e86BTO5z9l8fuJ1E2e1m0Vv0v-x-CiTs'), ('filename', 'Optical_Filter_Mount_A3-780.jpg'), ('size', 83323), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/o3eoGbbmCyOlE96s7xhtcw/wwB9kmDYno4n15PlrUER8zPuvjPxuKGgsCIfPMxF5Mrzaf78KuSUDKBQ_bfsN5Q9bdgDD2G6EZi91QTnARBIYA/WXSTE-XKhNaPN1yJKB5AbY7ctWYNpmFsaZDMRf1KULU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1GNcMJ8PRs4OnIKzt1dPiw/sThpvJaepLoCRUDBhqTp09ItIRDmlZ2br-LHISLgUTg4Ao3NgNCVznbaj3NvVJGtKQbfkj5pXqBbwoqT9fplHg/DPbQB6W_HaL3YqhLoSWucj1FW_cwZ8xpVZpU6Yhr4iw'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rzX8YaWmxY6rwJPm46AeDg/PVbbH5-fLfMxNy6jZHCeKSD3Fmq1cP41AnpGTHMUuNkYQWFeRizcmQ7VJIE-NUumrj3umCKFtuQNou_E17h87w/cXJHIrGRj6r0wGWOc0CXLY-O_fP518VB5o-0CKHqSCQ'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,"These Two-Position, High-Speed Flip Mounts flip lenses, filters, and other optical components into and out of a free-space beam. As shown by the image below, up to two optic mounts can be attached to the same flipper unit, allowing the user to alternate between optics. The flip action can be controlled in four ways: by the button on the top of the unit, via the included remote handset, via the external SMA connectors, or via a PC running the included software (see the Motion Control Software, Kinesis Tutorials, and APT Tutorials tabs for more information). The flipper position rotates 90° clockwise or counterclockwise when it is toggled and may be toggled either by an absolute signal level (i.e., low and high control voltages correspond to specific flipper positions) or by an edge (i.e., a change in the control voltage level causes the flipper to rotate). The unit has magnetic limit switches at both positions to identify which position the flipper is in.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=3962,MFF 10 X,621.0,['Motion'],,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Thorlabs/MFF10x.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Thorlabs_MFF10x.ipynb,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CvgXbArkB27mn-PsYJbdKA/jsnVknsEqxjTF3CFPCLxHvs66QnCiYZlrKfOcYSKT0xlShMdVypaziFjxP-GbYNg2o2nq76d9Ht5yM4bP9o2TDL67EuBfoXyvODtMPd3CPc/E_KBqkl6cDSDcDXfLtNSq5XkXPqT9aqGVwHXLIwRZek'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Jfn9nSRvZW7vWKd0MIGCvw/-b0s1tsK7Jr-okNRoo-YO9QnD1OhX3my9LS0kawwb4B0pjtBcsNrUw35bHRIN8hLpo5Oj2XnkkGAgG3_47sDwA/fJoXn-ks6nJSad3lfq8kIYH241PfMgw8cN7nzjpqa7E'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/V12sgCHA4vKGEDSNnRvERg/BbUh5Ie3dcStXKs6vv_18n-FHe_g8pF8MVKEv_0qvX6r48VA9MCJpV8Rh5euFmU9Bgh7IEU3avXmcSj1WE-bBg/mw8N06nvz-TE83u6CHhkKd3g7QenZawZ2_mNg2PxIfU'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wu3UZ6gHLFH9ebCWIFbGUA/zfw97WSqJfvW-RxyEC9uihliGkYCpT-Ow3ZyWL5IDD6kLAlqBxTb2UoOQxP_cWhF6-yYkE5W0iI53rUuOkwd6A/8gmlAC3gkDu2TyIIbcFvdDygRU8DhgE2_mEfIzF3OaY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,MMF101/MMF102,Write a Python script that uses Qcodes Community to connect to a MMF101/MMF102 Motion,758.17,,,,"from qcodes import Instrument
from .APT import Thorlabs_APT, ThorlabsHWType


class Thorlabs_MFF10x(Instrument):
    """"""
    Instrument driver for the Thorlabs MFF10x mirror flipper.

    Args:
        name: Instrument name.
        device_id: ID for the desired mirror flipper.
        apt: Thorlabs APT server.

    Attributes:
        apt: Thorlabs APT server.
        serial_number: Serial number of the mirror flipper.
        model: Model description.
        version: Firmware version.
    """"""

    def __init__(self, name: str, device_id: int, apt: Thorlabs_APT, **kwargs):

        super().__init__(name, **kwargs)

        # save APT server link
        self.apt = apt

        # initialization
        self.serial_number: int = self.apt.get_hw_serial_num_ex(ThorlabsHWType.MFF10x, device_id)
        self.apt.init_hw_device(self.serial_number)
        self.model, self.version, _ = self.apt.get_hw_info(self.serial_number)

        # add parameters
        self.add_parameter('position',
                           get_cmd=self._get_position,
                           set_cmd=self._set_position,
                           get_parser=int,
                           label='Position')

        # print connect message
        self.connect_message()

    # get methods
    def get_idn(self):
        return {'vendor': 'Thorlabs', 'model': self.model,
                'firmware': self.version, 'serial': self.serial_number}

    def _get_position(self):
        status_bits = bin(self.apt.mot_get_status_bits(self.serial_number) & 0xffffffff)
        return status_bits[-1]

    # set methods
    def _set_position(self, position):
        self.apt.mot_move_jog(self.serial_number, position+1, False)
"
88,https://www.testequipmenthq.com/datasheets/Rohde-Schwarz-SMW200A-Datasheet.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attJFHviIVbFosQoO'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/TdoX9emLvd9knX6jnRTPdQ/uH-H1O3NOfZoNke9mDr1TmmGKZgpvLmrQ6PWOROIjDqk0cZZc_wFdnF8oiXHjs2J8FWJy2sXyC_aVZ13xG6TdMdNYzI8Xexsh42tiVMKq_kRYcFf99siubNE0RksX157Lxneckvg9CUnLjcvptbN_7WoVV4jQiKtWh-jaQpbbXOX6gBQ1YzHEi5QFX0ChfUj/B3nThCtwYH8JWaEHwtqKkEJUN1ZqLMZdmL3QAbFeKhE'), ('filename', 'smw200a-vector-signal-generator-front-view-rohde-schwarz_200_909_640_360_2.jpg'), ('size', 40147), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cHBSIUFYfqZnzhxurXbxVw/Kg3C1yf0kPYIzQ3PHhxDUCbrEibLxT2QaBoUTpPRbq-nLHRRsETXihnjVvTgmqA3sQQWPayfOQpGsaW_WgHejg/uMVew_ZYamU2QBljZLUNknlC6itrIK5_0yTpKDSUa_c'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/jn4x76hg0RFKGytyZ9XfLA/epvOAHutFqqxAEDrvjsfMyRz5JWs2drEPYoU-Z73p_wbRVwqWrTTqq1h2yp7cIxWiB0sgJgDElTeZ56PMCrRMw/7kdb2tU_HUH4l75lk48FDjGBiuAjN-ZrlJ0QAXqkn8M'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wBesmLZvhbp-9py5DJ8F0g/Qow0H4b66t4W3gPzHE5OPZIRFApdrhr_WlJSykc67jKds70qSUmPOzW6V4MbV2KeS9eC5OvRdBLLGZS2R94WWA/7ADLTYPGlGlWl_d6EkJpeiwLybmY-7dfRbnu9kYhcm0'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","The R&S®SMW200A offers integrated channel emulation for up to 800 MHz of fading bandwidth. Fading profiles for all major standards are available as presets. With up to 64 fading channels, all key MIMO fading scenarios such as 2x2, 3x3, 4x4, 8x4, 4x8 and 8x8 can be configured in a single instrument.","https://www.rohde-schwarz.com/us/products/test-and-measurement/vector-signal-generators/rs-smw200a-vector-signal-generator_63493-38656.html#:~:text=The%20R%26S%C2%AESMW200A%20offers,configured%20in%20a%20single%20instrument.",SMW 200 A,477.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/SMW200A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.SMW200A,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,SMW 200 A,Write a Python script that uses Qcodes Community to connect to a {Device name} RF Signal Generator,,,,,"# -*- coding: utf-8 -*-
""""""QCoDeS-Driver for Rohde&Schwarz Vector Signal Generator RS_SMW200A.

This driver can be used with a simulation class (SMW200Asim.py) to generate
reasonable answers to all requests. The only thing is to change two times
the comments as shown below (real mode/simulation mode).

Note:
    To use RohdeSchwarz_SMW200A with a dummy/simulator, replace its base class `VisaInstrument` with
    `MockVisa` from file SMW200Asim.py.

Authors:
    Michael Wagener, ZEA-2, m.wagener@fz-juelich.de
    Sarah Fleitmann, ZEA-2, s.fleitmann@fz-juelich.de
    Lukas Lankes, ZEA-2, l.lankes@fz-juelich.de
""""""


import logging
from functools import partial
import time
from typing import Union

from qcodes import VisaInstrument
from qcodes.instrument.channel import InstrumentChannel, ChannelList
from qcodes import validators as vals

log = logging.getLogger(__name__)

_MODULATION_SIGNAL_DOC_POOL = {
    ""INT"": ""internally generated LF signal = 'LF1'"",
    ""EXT"": ""externally supplied LF signal  = 'EXT1'"",
    ""LF1"": ""first internally generated signal"",
    ""LF2"": ""second internally gererated signal"",
    ""NOIS"": ""internally generated noise signal"",
    ""EXT1"": ""first externally supplied signal"",
    ""EXT2"": ""second externally supplied signal"",
    ""INTB"": ""internal baseband signal""
}


class IQChannel(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""The I/Q channels are the analog output channels of the device.

        Arguments:
            parent: the parent instrument of this channel
            name:   the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            state: Actives/deactives the I/Q output. Values are 'ON' and 'OFF'.
            type: Sets the type of the analog signal. Values are 'SING' (single) and 'DIFF'
                (differential, only available with option SMW-K16)
            mode: Determines the mode for setting the output parameters. Values are
                'FIX': Locks the I/Q output settings
                'VAR': Unlocks the settings (only available with option SMW-K16)
            level: Sets the off-load voltage Vp of the analog I/Q signal output.
                Values are in range 0.04V to 4V for option SMW-B10 and in range 0.04V
                to 2V for option SMW-B9. The value range is adjusted so that the maximum
                overall output voltage does not exceed 4V. Only settable when mode has
                the value 'VAR'.
            coupling: Couples the bias setting of the I and Q signal components.
                Values are 'ON and 'OFF'.
            i_bias: Specifies the amplifier bias of the I component. The value range
                is adjusted so that the maximum overall output voltage does not
                exceed 4V. Is only settable, if the mode parameter has the value 'VAR'.
            q_bias: Specifies the amplifier bias of the Q component. The value range
                is adjusted so that the maximum overall output voltage does not
                exceed 4V. Is only settable, if the mode parameter has the value 'VAR'.
            i_offset: Sets an offset between the inverting and non-inverting input
                of the differential analog I/Q output signal for the I component.
                The value range is adjusted so that the maximum overall output voltage
                does not exceed 4V. Is only settable, if parameter mode has the value 'VAR'.
            q_offset: Sets an offset between the inverting and non-inverting input
                of the differential analog I/Q output signal for the Q component.
                The value range is adjusted so that the maximum overall output voltage
                does not exceed 4V. Is only settable, if parameter mode has the value 'VAR'.
        """"""
        self.hwchan = hwchan
        super().__init__(parent, name)

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Actives/deactives the I/Q output. Values are 'ON' and 'OFF'."")

        if 'SMW-K16' in self._parent.options:
            type_validator = vals.Enum('SING', 'DIFF')
            mode_validator = vals.Enum('FIX', 'VAR')
        else:
            type_validator = vals.Enum('SING')
            mode_validator = vals.Enum('FIX')
        self.add_parameter('type',
                           label='Type',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:TYPE {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:TYPE?',
                           vals=type_validator,
                           docstring=""Sets the type of the analog signal. Values are""
                                     "" 'SING' (single) and 'DIFF' (differential, only""
                                     "" available with option SMW-K16)"")

        self.add_parameter('mode',
                           label='Mode',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:MODE?',
                           vals=mode_validator,
                           docstring=""""""
                           Determines the mode for setting the output parameters. Values are:
                               'FIX': Locks the I/Q output settings
                               'VAR': Unlocks the settings (only available with option SMW-K16)
                           """""")

        if 'SMW-B10' in self._parent.options:
            level_validator = vals.Numbers(0.04, 4)
        else: #option SMW-B9
            level_validator = vals.Numbers(0.04, 2)

        level_set_cmd: Union[str, bool] = False
        if self.mode() == 'VAR':
            level_set_cmd = f'SOUR{self.hwchan}:'+'IQ:OUTP:LEV {}'

        self.add_parameter('level',
                           label='Level',
                           set_cmd=level_set_cmd,
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:LEV?',
                           get_parser=float,
                           vals=level_validator,
                           unit='V',
                           docstring=""Sets the off-load voltage Vp of the analog I/Q signal""
                                     "" output. Values are in range 0.04V to 4V for option""
                                     "" SMW-B10 and in range 0.04V to 2V for option SMW-B9.""
                                     "" The value range is adjusted so that the maximum""
                                     "" overall output voltage does not exceed 4V. Only""
                                     "" settable when mode has the value 'VAR'."")

        self.add_parameter('coupling',
                           label='Coupling',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:BIAS:COUP:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:BIAS:COUP:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Couples the bias setting of the I and Q signal""
                                     "" components. Values are 'ON and 'OFF'."")

        if 'SMW-B10' in self._parent.options:
            lower = -4+self.level()/2+self.i_offset()/2
            upper = 4-self.level()/2-self.i_offset()/2
            bias_validator = vals.Numbers(lower, upper)
        else: #option SMW-B9
            bias_validator = vals.Numbers(-0.2, 2.5)

        i_bias_set_cmd: Union[str, bool] = False
        if self.mode() == 'VAR':
            i_bias_set_cmd = f'SOUR{self.hwchan}:' + 'IQ:OUTP:ANAL:BIAS:I {}'

        self.add_parameter('i_bias',
                           label='I bias',
                           set_cmd=i_bias_set_cmd,
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:BIAS:I?',
                           get_parser=float,
                           vals=bias_validator,
                           unit='V',
                           docstring=""Specifies the amplifier bias of the I component.""
                                     "" The value range is adjusted so that the maximum""
                                     "" overall output voltage does not exceed 4V. Is only""
                                     "" settable, if the mode parameter has the value 'VAR'."")

        if 'SMW-B10' in self._parent.options:
            lower = -4+self.level()/2+self.q_offset()/2
            upper = 4-self.level()/2-self.q_offset()/2
            bias_validator = vals.Numbers(lower, upper)
        else: #option SMW-B9
            bias_validator = vals.Numbers(-0.2, 2.5)

        q_bias_set_cmd: Union[str, bool] = False
        if self.mode() == 'VAR':
            q_bias_set_cmd = f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:BIAS:Q {}'

        self.add_parameter('q_bias',
                           label='Q bias',
                           set_cmd=q_bias_set_cmd,
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:BIAS:Q?',
                           get_parser=float,
                           vals=bias_validator,
                           unit='V',
                           docstring=""Specifies the amplifier bias of the Q component.""
                                     "" The value range is adjusted so that the maximum""
                                     "" overall output voltage does not exceed 4V. Is only""
                                     "" settable, if the mode parameter has the value 'VAR'."")

        if 'SMW-B10' in self._parent.options:
            lower = -4+self.level()/2+self.i_bias()/2
            upper = 4-self.level()/2-self.i_bias()/2
            offset_validator = vals.Numbers(lower, upper)
        else: #option SMW-B9
            lower = -2+self.level()
            upper = 2-self.level()
            offset_validator = vals.Numbers(lower, upper)

        i_offset_set_cmd: Union[str, bool] = False
        if self.mode() == 'VAR':
            i_offset_set_cmd = f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:OFFS:I {}'

        self.add_parameter('i_offset',
                           label='I offset',
                           set_cmd=i_offset_set_cmd,
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:OFFS:I?',
                           get_parser=float,
                           vals=offset_validator,
                           unit='V',
                           docstring=""Sets an offset between the inverting and non-inverting""
                                     "" input of the differential analog I/Q output signal""
                                     "" for the I component.""
                                     "" The value range is adjusted so that the maximum""
                                     "" overall output voltage does not exceed 4V. Is only""
                                     "" settable, if the mode parameter has the value 'VAR'."")

        if 'SMW-B10' in self._parent.options:
            lower = -4+self.level()/2+self.q_bias()/2
            upper = 4-self.level()/2-self.q_bias()/2
            offset_validator = vals.Numbers(lower, upper)
        else: #option SMW-B9
            lower = -2+self.level()
            upper = 2-self.level()
            offset_validator = vals.Numbers(lower, upper)

        q_offset_set_cmd: Union[str, bool] = False
        if self.mode() == 'VAR':
            q_offset_set_cmd = f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:OFFS:Q {}'

        self.add_parameter('q_offset',
                           label='Q offset',
                           set_cmd=q_offset_set_cmd,
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:OUTP:ANAL:OFFS:Q?',
                           get_parser=float,
                           vals=offset_validator,
                           unit='V',
                           docstring=""Sets an offset between the inverting and non-inverting""
                                     "" input of the differential analog I/Q output signal""
                                     "" for the Q component.""
                                     "" The value range is adjusted so that the maximum""
                                     "" overall output voltage does not exceed 4V. Is only""
                                     "" settable, if the mode parameter has the value 'VAR'."")
        # TODO: setter methods for the last 4 parameters, they have dynamic validators



class IQModulation(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning the IQ modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            state: Activates/deactivates the I/Q modulation. Values are 'ON', and 'OFF'.
            source: Selects/reads the input signal source for the I/Q modulator.
                'BAS': internal baseband signal
                'ANAL': external analog signal
                'DIFF': differential analog signal (only with option SMW-K739)
            gain: Optimizes the modulation of the I/Q modulator for a subset of
                measurement requirements.
                'DB0': Activates the gain of  0 dB
                'DB2': Activates the gain of +2 dB
                'DB3': same as 'DB2', for backward compatibility
                'DB4': Activates the gain of +4 dB
                'DB6': Activates the gain of +6 dB
                'DB8': Activates the gain of +8 dB
                'DBM2': Activates the gain of -2 dB
                'DBM3': same as 'DBM2', for backward compatibility
                'DBM4': Activates the gain of -4 dB
                'AUTO': The gain value is retrieved form the connected R&S SZU. The I/Q modulator
                is configured automatically.
            swap: Activates/Deactives the swapping of the I and Q channel. Values are 'ON' / 'OFF'.
            crest_factor: If source set to 'ANAL' (Analog Wideband I/Q Input), sets the crest factor
                of the externally supplied analog signal. The crest factor gives the difference in
                level between the peak envelope power (PEP) and the average power value (RMS) in dB.
                The R&S SMW uses this value for the calculation of the RF output power. The allowed
                range is from 0 dB to 35 dB.
            wideband: Activates/deactivates optimization for wideband modulation signals
                (higher I/Q modulation bandwidth). Values are 'ON' and 'OFF'.
        """"""
        self.hwchan = hwchan
        super().__init__(parent, name)

        if 'SMW-K739' in self._parent.options:
            source_validator = vals.Enum('BAS', 'ANAL', 'DIFF')
        else:
            source_validator = vals.Enum('BAS', 'ANAL')
        self.add_parameter('source',
                           label='Source',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:SOUR {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:SOUR?',
                           vals=source_validator,
                           docstring=""""""
                           Selects/reads the input signal source for the I/Q modulator.
                           Values are:
                               'BAS': internal baseband signal
                               'ANAL': external analog signal
                               'DIFF': differential analog signal (only with option SMW-K739)
                           """""")

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates/deactivates the I/Q modulation. Values""
                                     "" are 'ON', and 'OFF'"")

        self.add_parameter('gain',
                           label='Gain',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:GAIN {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:GAIN?',
                           vals=vals.Enum('DBM4', 'DBM2', 'DB0', 'DB2', 'DB4', \
                                          'DB8', 'DB6', 'DBM3', 'DB3', 'AUTO'),
                           docstring=""""""
                           Optimizes the modulation of the I/Q modulator for a subset
                           of measurement requirements. Possible values are:
                               'DB0'=0dB, 'DB2'=+2dB, 'DB4'=+4dB, 'DB6'=+6dB, 'DB8'=+8dB
                               'DBM2'=-2dB, 'DBM4'=-4dB
                               'DB3' and 'DBM3' provided for backward compatibility (+/-2dB)
                               'AUTO': The gain value is retrieved form the connected R&S SZU.
                               The I/Q modulator is configured automatically.
                           """""")

        self.add_parameter('crest_factor',
                           label='Crest factor',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:CRES {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:CRES?',
                           get_parser=float,
                           vals=vals.Numbers(0, 35),
                           unit='dB',
                           docstring=""If source set to `ANAL' (Analog Wideband I/Q Input),""
                                     "" sets the crest factor of the externally supplied""
                                     "" analog signal. The crest factor gives the difference""
                                     "" in level between the peak envelope power (PEP) and""
                                     "" the average power value (RMS) in dB. The R&S SMW uses""
                                     "" this value for the calculation of the RF output power.""
                                     "" The allowed range is from 0 dB to 35 dB."")

        self.add_parameter('swap',
                           label='Swap',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:SWAP:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:SWAP:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates/Deactives the swapping of the I""
                                     "" and Q channel. Values are 'ON' and 'OFF'."")

        self.add_parameter('wideband',
                           label='Wideband',
                           set_cmd=f'SOUR{self.hwchan}:'+'IQ:WBST {}',
                           get_cmd=f'SOUR{self.hwchan}:'+'IQ:WBST?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates/deactivates optimization for wideband""
                                     "" modulation signals (higher I/Q modulation""
                                     "" bandwidth). Values are 'ON' and 'OFF'."")



class FrequencyModulation(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int, chnum: int):
        """"""Combines all the parameters concerning the frequency modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication
            chnum : the internal number of the channel used for the communication
    
        Attributes:
            state: actives/deactivates the frequency modulation. Values are 'ON' and 'OFF'.
            deviation: Sets the modulation deviation of the frequency modulation in Hz.
            source: Selects the modulation source. Values are:
                'INT': internally generated LF signal = 'LF1' (channel 2 only with option SMW-K24)
                'EXT': externally supplied LF signal  = 'EXT1' (channel 2 only with option SMW-K24)
                'LF1': first internally generated signal
                'LF2': second internally gererated signal (only available with option SMW-K24)
                'NOIS': internally generated noise signal (only available with option SMW-K24)
                'EXT1': first externally supplied signal
                'EXT2': second externally supplied signal
                'INTB': internal baseband signal (only available with option SMW-B9)
            coupling_mode: Selects the coupling mode. The coupling mode parameter also
                determines the mode for fixing the total deviation. Values are:
                'UNC': Does not couple the LF signals. The deviation values of both paths are
                independent.
                'TOT': Couples the deviation of both paths.
                'RAT': Couples the deviation ratio of both paths
            total_deviation: Sets the total deviation of the LF signal when using combined
                signal sources in frequency modulation.
            deviation_ratio: Sets the deviation ratio (path2 to path1) in percent.
            mode: Selects the mode for the frequency modulation. Values are:
                'NOR': normal mode
                'LNO': low noise mode
            sensitivity: (ReadOnly) Queries the sensitivity of the externally supplied signal for
                frequency modulation. The sensitivity depends on the set modulation deviation.
        """"""
        self.hwchan = hwchan
        self.chnum = chnum
        super().__init__(parent, name)

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:' + 'STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""actives/deactivates the frequency modulation.""
                                     "" Values are 'ON' and 'OFF'."")

        self.add_parameter('deviation',
                           label='Deviation',
                           set_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:' + 'DEV {}',
                           get_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:DEV?',
                           get_parser=float,
                           vals=vals.Numbers(0, 1.6e8),
                           unit='Hz',
                           docstring=""Sets the modulation deviation of the frequency""
                                     "" modulation in Hz."")

        # Select the set of available values from the installed options
        if 'SMW-B9' in self._parent.options and not 'SMW-K24' in self._parent.options:
            sv = ['INT', 'LF1', 'EXT', 'EXT1', 'EXT2', 'INTB'] \
            if self.chnum == 1 else ['LF1', 'EXT1', 'EXT2', 'INTB']
        elif not 'SMW-B9' in self._parent.options and 'SMW-K24' in self._parent.options:
            sv = ['INT', 'LF1', 'LF2', 'NOIS', 'EXT', 'EXT1', 'EXT2']
        elif 'SMW-B9' in self._parent.options and 'SMW-K24' in self._aprent.options:
            sv = ['INT', 'LF1', 'LF2', 'NOIS', 'EXT', 'EXT1', 'EXT2', 'INTB']
        else:
            sv = ['INT', 'LF1', 'EXT', 'EXT1', 'EXT2'] \
            if self.chnum == 1 else ['LF1', 'EXT1', 'EXT2']
        # Generate part of the docstring value according to the validator strings
        ds = """"
        for key, value in _MODULATION_SIGNAL_DOC_POOL.items():
            if key in sv:
                ds += f""\n'{key}': {value}""
        self.add_parameter('source',
                           label='Source',
                           set_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:' + 'SOUR {}',
                           get_cmd=f'SOUR{self.hwchan}:FM{self.chnum}:SOUR?',
                           vals=vals.Enum(*sv),
                           docstring=""Selects the modulation source. Values are:""+ds)

        if 'SMW-XXX' in self._parent.options: #TODO: welche Option wird hierfür benötigt?
            self.add_parameter('coupling_mode',
                               label='Coupling mode',
                               set_cmd=f'SOUR{self.hwchan}:' + 'FM:DEV:MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'FM:DEV:MODE?',
                               vals=vals.Enum('UNC', 'TOT', 'RAT'))

        if 'SMW-XXX' in self._parent.options: #TODO: welche Option wird hierfür benötigt?
            self.add_parameter('total_deviation',
                               label='Total deviation',
                               set_cmd=f'SOUR{self.hwchan}:' + 'FM:DEV:SUM {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'FM:DEV:SUM?',
                               get_parser=float,
                               vals=vals.Numbers(0, 40e6))

        self.add_parameter('deviation_ratio',
                           label='Deviation ratio',
                           set_cmd=f'SOUR{self.hwchan}:' + 'FM:RAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'FM:RAT?',
                           get_parser=float,
                           vals=vals.Numbers(0, 100),
                           unit='%',
                           docstring=""Sets the deviation ratio (path2 to path1) in percent."")

        self.add_parameter('mode',
                           label='Mode',
                           set_cmd=f'SOUR{self.hwchan}:' + 'FM:MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'FM:MODE?',
                           vals=vals.Enum('NORM', 'LNO'),
                           docstring=""Selects the mode for the frequency modulation.""
                                     "" 'NOR'=normal mode, 'LNO'=low noise mode"")

        self.add_parameter('sensitivity',
                           label='Sensitivity',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:' + 'FM:SENS?',
                           get_parser=float,
                           unit='Hz/V',
                           docstring=""(ReadOnly) Queries the sensitivity of the externally""
                                     "" supplied signal for frequency modulation. The""
                                     "" sensitivity depends on the set modulation deviation."")


class AmplitudeModulation(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int, chnum: int):
        """"""Combines all the parameters concerning the amplitude modulation. Activation
        of amplitude modulation deactivates ARB, I/Q modulation, digital modulation
        and all digital standards.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication
            chnum : the internal number of the channel used in the communication

        Attributes:
            state: actives/deactivates the amplitude modulation. Values are 'ON' and 'OFF'.
            source: Selects the modulation source. Values are:
                'INT': internally generated LF signal = 'LF1' (channel 2 only with option SMW-K24)
                'EXT': externally supplied LF signal  = 'EXT1' (channel 2 only with option SMW-K24)
                'LF1': first internally generated signal
                'LF2': second internally gererated signal (only available with option SMW-K24)
                'NOIS': internally generated noise signal (only available with option SMW-K24)
                'EXT1': first externally supplied signal
                'EXT2': second externally supplied signal
            depth: Sets the depth of the amplitude modulation in percent.
            total_depth: Sets the total depth of the LF signal when using combined
                signal sources in amplitude modulation.
            coupling_mode: Selects the coupling mode. The coupling mode parameter also
                determines the modefor fixing the total depth. Values are:
                'UNC': Does not couple the LF signals. The deviation depth values of
                both paths are independent.
                'TOT': Couples the deviation depth of both paths.
                'RAT': Couples the deviation depth ratio of both paths.
            deviation_ratio: Sets the deviation ratio (path2 to path1) in percent.
            sensitivity: (ReadOnly) Queries the sensitivity of the externally applied signal.
                The sensitivity depends on the set modulation depth. The returned value
                reports the sensitivity in %/V. It is assigned to the voltage value for
                full modulation of the input.
        """"""
        self.hwchan = hwchan
        self.chnum = chnum
        super().__init__(parent, name)

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:' + 'STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""""""
                           Actives/deactivates the amplitude modulation. Values are 'ON' and 'OFF'.
                           Activation of amplitude modulation deactivates ARB, I/Q modulation,
                           digital modulation and all digital standards.
                           """""")

        # Select the set of available values from the installed options
        if 'SMW-K24' in self._parent.options:
            sv = ['LF1', 'LF2', 'EXT1', 'EXT2', 'NOIS', 'INT', 'EXT']
        else:
            sv = ['LF1', 'EXT1', 'EXT2', 'INT', 'EXT'] if chnum == 1 \
            else ['LF1', 'EXT1', 'EXT2']
        # Generate part of the docstring value according to the validator strings
        ds = """"
        for key, value in _MODULATION_SIGNAL_DOC_POOL.items():
            if key in sv:
                ds += f""\n'{key}': {value}""
        self.add_parameter('source',
                           label='Source',
                           set_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:' + 'SOUR {}',
                           get_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:SOUR?',
                           vals=vals.Enum(*sv),
                           docstring=""Selects the modulation source. Values are:""+ds)

        self.add_parameter('depth',
                           label='Depth',
                           set_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:' + 'DEPT {}',
                           get_cmd=f'SOUR{self.hwchan}:AM{self.chnum}:DEPT?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           docstring=""Sets the depth of the amplitude modulation in percent."")

        if 'SMW-XXX' in self._parent.options:
            # this function was disabled in the device but the needed option not documented in manual
            self.add_parameter('total_depth',
                               label='Total depth',
                               set_cmd=f'SOUR{self.hwchan}:' + 'AM:DEPT:SUM {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'AM:DEPT:SUM?',
                               get_parser=float,
                               vals=vals.Numbers(0, 100))

        if 'SMW-XXX' in self._parent.options:
            # this function was disabled in the device but the needed option not documented in manual
            self.add_parameter('coupling_mode',
                               label='Coupling mode',
                               set_cmd=f'SOUR{self.hwchan}:' + 'AM:DEV:MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'AM:DEV:MODE?',
                               vals=vals.Enum('UNC', 'TOT', 'RAT'))

        self.add_parameter('deviation_ratio',
                           label='Deviation ratio',
                           set_cmd=f'SOUR{self.hwchan}:' + 'AM:RAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'AM:RAT?',
                           get_parser=float,
                           vals=vals.Numbers(0, 100),
                           unit='%',
                           docstring=""Sets the deviation ratio (path2 to path1) in percent."")

        self.add_parameter('sensitivity',
                           label='Sensitifity',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:' + 'AM:SENS?',
                           get_parser=float,
                           unit='%/V',
                           docstring=""(ReadOnly) Queries the sensitivity of the externally""
                                     "" applied signal. The sensitivity depends on the set""
                                     "" modulation depth. The returned value reports the""
                                     "" sensitivity in %/V. It is assigned to the voltage""
                                     "" value for full modulation of the input."")



class PulseModulation(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning the pulse modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication


        Attributes:
            state: Activates/deactivates the pulse modulation. Values are 'ON' and 'OFF'.
            source: Selects the modulation source. Values are:

                - 'INT': internally generated signal is used (only available with option SMW-K23)
                - 'EXT': externally supplied signal is used

            transition_type: sets the transition mode for the pulse signal. Values are:

                - 'SMO': flattens the slew , resulting in longer rise/fall times (SMOothed)
                - 'FAST': enables fast transition with shortest rise and fall times

            video_polarity: Sets the polarity of the pulse video (modulating) signal,
                related to the RF (modulated) signal. Values are:

                - 'NORM': the video signal follows the RF signal, that means it is high
                  when RF signal is high and vice versa
                - 'INV': the video signal follows in inverted mode

            polarity: sets the polarity of the externally applied modulation signal

                - 'NORM': Suppresses the RF signal during the pulse pause
                - 'INV': Suppresses the RF signal during the pulse

            impedance: Sets the impedance for the external pulse modulation input.
                Values are 'G50' and 'G1K'
            trigger_impedance: Sets the impedance for the external pulse trigger.
                Values are 'G50' and 'G10K'

            mode: (Only SMW-K23) Selects the mode for the pulse modulation. Values can be:

                - 'SING': generates a single pulse
                - 'DOUB': generates two pulses within one pulse period

            double_delay: (Only SMW-K23) Sets the delay from the start of the first pulse to the
                start of the second pulse.
            double_width: (Only SMW-K23) Sets the width of the second pulse.
            trigger_mode: (Only SMW-K23) Selects a trigger mode for generating the modulation
                signal. Values are 'AUTO' (AUTOmatic), 'EXT' (EXTernal), 'EGAT' (External
                GATed), 'ESIN' (External single).
            period: (Only SMW-K23) Sets the period of the generated pulse, that means the repetition
                frequency of the internally generated modulation signal.
            width: (Only SMW-K23) Sets the width of the generated pulse, that means the pulse
                length. It must be at least 20ns less than the set pulse period.
            delay: (Only SMW-K23) Sets the pulse delay.
        """"""
        self.hwchan = hwchan
        super().__init__(parent, name)

        if 'SMW-K23' in self._parent.options:
            self.add_parameter('mode',
                               label='Mode',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:MODE?',
                               vals=vals.Enum('SING', 'DOUB'),
                               docstring=""""""
                               Selects the mode for the pulse modulation.
                               'SING': generates a single pulse
                               'DOUB': generates two pulses within one pulse period.
                               """""")

            self.add_parameter('double_delay',
                               label='Double delay',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:DOUB:DEL {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:DOUB:DEL?',
                               get_parser=float,
                               docstring=""Sets the delay from the start of the first""
                                         "" pulse to the start of the second pulse."")

            self.add_parameter('double_width',
                               label='Double width',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:DOUB:WID {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:DOUB:WID?',
                               get_parser=float,
                               docstring=""Sets the width of the second pulse."")

            self.add_parameter('trigger_mode',
                               label='Trigger mode',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:TRIG:MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:TRIG:MODE?',
                               vals=vals.Enum('AUTO', 'EXT', 'EGAT', 'ESIN'),
                               docstring=""Selects a trigger mode for generating the modulation""
                                         "" signal. Values are 'AUTO' (AUTOmatic), 'EXT'""
                                         "" (EXTernal), 'EGAT' (External GATed), 'ESIN'""
                                         "" (External single)."")

            self.add_parameter('period',
                               label='Period',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:PER {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:PER?',
                               get_parser=float,
                               vals=vals.Numbers(20e-9, 100),
                               unit='s',
                               docstring=""Sets the period of the generated pulse, that""
                                         "" means the repetition frequency of the internally""
                                         "" generated modulation signal."")

            self.add_parameter('width',
                               label='Width',
                               set_cmd=partial(self._setwidth),
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:WIDT?',
                               get_parser=float,
                               vals=vals.Numbers(20e-9, 100),
                               unit='s',
                               docstring=""Sets the width of the generated pulse, that""
                                         "" means the pulse length. It must be at least""
                                         "" 20ns less than the set pulse period."")

            self.add_parameter('delay',
                               label='Delay',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PULM:DEL {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PULM:DEL?',
                               get_parser=float,
                               vals=vals.Numbers(),
                               unit='s',
                               docstring=""Sets the pulse delay."")

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates/deactivates the pulse modulation.""
                                     "" Values are 'ON' and 'OFF'."")

        sv = ['INT', 'EXT'] if 'SMW-K23' in self._parent.options else ['EXT']
        ds = """"
        if 'INT' in sv:
            ds += ""\n'INT': internally generated signal""
        if 'EXT' in sv:
            ds += ""\n'EXT': externally supplied signal""
        self.add_parameter('source',
                           label='Source',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:SOUR {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:SOUR?',
                           vals=vals.Enum(*sv),
                           docstring=""Selects the modulation source. Values are:""+ds)

        self.add_parameter('transition_type',
                           label='Transition type',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:TTYP {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:TTYP?',
                           vals=vals.Enum('SMO', 'FAST'),
                           docstring=""""""
                           Sets the transition mode for the pulse signal.
                           'SMO': flattens the slew, resulting in longer rise/fall times (SMOothed),
                           'FAST': enables fast transition with shortest rise and fall times
                           """""")

        self.add_parameter('video_polarity',
                           label='Video polaraity',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:OUTP:VID:POL {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:OUTP:VID:POL?',
                           vals=vals.Enum('NORM', 'INV'),
                           docstring=""""""
                           Sets the polarity of the pulse video (modulating) signal, related to
                           the RF (modulated) signal.
                           'NORM': the video signal follows the RF signal, that means it is high
                            when RF signal is high and vice versa
                           'INV': the video signal follows in inverted mode
                           """""")

        self.add_parameter('polarity',
                           label='Polarity',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:POL {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:POL?',
                           vals=vals.Enum('NORM', 'INV'),
                           docstring=""""""
                           sets the polarity of the externally applied modulation signal
                           'NORM': Suppresses the RF signal during the pulse pause
                           'INV': Suppresses the RF signal during the pulse
                           """""")

        self.add_parameter('impedance',
                           label='Impedance',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:IMP {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:IMP?',
                           vals=vals.Enum('G50', 'G1K'),
                           docstring=""Sets the impedance for the external pulse modulation""
                                     "" input. Values are 'G50' and 'G1K'"")

        self.add_parameter('trigger_impedance',
                           label='Trigger impedance',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PULM:TRIG:EXT:IMP {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PULM:TRIG:EXT:IMP?',
                           vals=vals.Enum('G50', 'G10K'),
                           docstring=""Sets the impedance for the external pulse trigger.""
                                     "" Values are 'G50' and 'G10K'"")

    def _setwidth(self, val):
        """"""
        Helper function to check the maximum allowed value for the step
        """"""
        maxwidth = self.period()-20e-9
        if val > maxwidth:
            raise ValueError(f'{repr(val)} is invalid: must be between 20e-9 and {maxwidth} '
                             f'inclusive.')
        self.write(f'SOUR{self.hwchan}:PULM:WIDT {val}')



class PulseGenerator(InstrumentChannel):
    """"""
    Configurations for the Pulse Generator set with another subclasses:
        Pulse Mode         -> PulseModulation.mode()
        Trigger Mode       -> PulseModulation.trigger_mode()
        Pulse Period       -> PulseModulation.period()
        Pulse Width        -> PulseModulation.width()
        Double Pulse Width -> PulseModulation.double_width()
        Pulse Delay        -> PulseModulation.delay()
        Double Pulse Delay -> PulseModulation.double_delay()
    """"""
    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning the pulse generator for setting output
        of the pulse modulation signal. Available only with option SMW-K23 installed.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            polarity: Sets the polarity of the pulse output signal. Values are:
                'NORM': Outputs the pulse signal during the pulse width, that means during
                the high state.
                'INV': Inverts the pulse output signal polarity. The pulse output signal
                is suppressed during the pulse width, but provided during the low state.
            output: Activates the output of the pulse modulation signal. Values are: 'OFF' or 'ON'.
            state: Enables the output of the video/sync signal. If the pulse generator is the
                current modulation source, activating the pulse modulation automatically
                activates the signal output and the pulse generator.
        """"""
        self.hwchan = hwchan
        super().__init__(parent, name)
        if not 'SMW-K23' in self._parent.options:
            raise RuntimeError(""Invalid usage of class without installed option K23"")

        self.add_parameter('polarity',
                           label='Polarity',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PGEN:OUTP:POL {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PGEN:OUTP:POL?',
                           vals=vals.Enum('NORM', 'INV'),
                           docstring=""""""
                           Sets the polarity of the pulse output signal.
                           'NORM': Outputs the pulse signal during the pulse width,
                           that means during the high state.
                           'INV': Inverts the pulse output signal polarity. The
                           pulse output signal is suppressed during the pulse width,
                           but provided during the low state.
                           """""")

        self.add_parameter('output',
                           label='Output',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PGEN:OUTP:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PGEN:OUTP:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""""""
                           Activates the output of the pulse modulation signal.
                           Possible values: OFF or ON.
                           """""")

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""""""
                           Enables the output of the video/sync signal.
                           If the pulse generator is the current modulation source,
                           activating the pulse modulation automatically activates
                           the signal output and the pulse generator.
                           Possible values: OFF or ON.
                           """""")

        self.add_parameter('mode',
                           label='',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""""""
                           """""")

        self.add_parameter('test',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PGEN:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""""""
                           """""")


class PhaseModulation(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int, chnum: int):
        """"""Combines all the parameters concerning the phase modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication
            chnum : the internal number of the channel used in the communication

        Attributes:
            state: Activates or deactivates phase modulation. Activation of phase modulation
                deactivates frequency modulation. Possible values are 'ON' and 'OFF'.
            deviation: Sets the modulation deviation of the phase modulation in RAD.
            source: Selects the modulation source. Values are:
                'INT': internally generated LF signal = 'LF1' (channel 2 only with option SMW-K24)
                'EXT': externally supplied LF signal  = 'EXT1' (channel 2 only with option SMW-K24)
                'LF1': first internally generated signal
                'LF2': second internally gererated signal (only available with option SMW-K24)
                'NOIS': internally generated noise signal (only available with option SMW-K24)
                'EXT1': first externally supplied signal
                'EXT2': second externally supplied signal
                'INTB': internal baseband signal (only available with option SMW-B9)
            mode: Selects the mode for the phase modulation. Possible values are:
                'HBAN': sets the maximum available bandwidth (High BANdwidth)
                'HDEV': sets the maximum range for deviation (High DEViation)
                'LNO': selects a phase modulation mode with phase noise and spurious
                characteristics close to CW mode. (Low NOise)
            coupling_mode: Selects the coupling mode. Possible values are:
                'UNC': Does not couple the LF signals. The deviation of both paths are independent.
                'TOT': Couples the deviation of both paths.
                'RAT': Couples the deviation ratio of both paths.
            total_deviation: Sets the total deviation of the LF signal when using
                combined signal sources. Possible values range from 0 to 20.
            ratio: Sets the deviation ratio (path2 to path1) in percent.
            sensitivity: Queries the sensitivity of the externally applied signal for phase
                modulation. The returned value reports the sensitivity in RAD/V. It is assigned
                to the voltage value for full modulation of the input.
        """"""
        self.hwchan = hwchan
        self.chnum = chnum
        super().__init__(parent, name)

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'SOUR{self.hwchan}:PM{self.chnum}:' + 'STAT {}',
                           get_cmd=f'SOUR{self.hwchan}:PM{self.chnum}:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates or deactivates phase modulation. Values are""
                                     "" 'ON' and 'OFF'. Activation of phase modulation""
                                     "" deactivates frequency modulation."")

        self.add_parameter('deviation',
                           label='Deviation',
                           set_cmd=f'SOUR:PM{self.chnum}:' + 'DEV {}',
                           get_cmd=f'SOUR:PM{self.chnum}:DEV?',
                           vals=vals.Numbers(0, 16),
                           unit='RAD',
                           docstring=""Sets the modulation deviation of the phase""
                                     ""modulation in RAD."")

        # Select the set of available values from the installed options
        if 'SMW-B9' in self._parent.options and not 'SMW-K24' in self._parent.options:
            sv = ['INT', 'LF1', 'EXT', 'EXT1', 'EXT2', 'INTB'] \
            if self.chnum == 1 else ['LF1', 'EXT1', 'EXT2', 'INTB']
        elif not 'SMW-B9' in self._parent.options and 'SMW-K24' in self._parent.options:
            sv = ['INT', 'LF1', 'LF2', 'NOIS', 'EXT', 'EXT1', 'EXT2']
        elif 'SMW-B9' in self._parent.options and 'SMW-K24' in self._aprent.options:
            sv = ['INT', 'LF1', 'LF2', 'NOIS', 'EXT', 'EXT1', 'EXT2', 'INTB']
        else:
            sv = ['INT', 'LF1', 'EXT', 'EXT1', 'EXT2'] \
            if self.chnum == 1 else ['LF1', 'EXT1', 'EXT2']
        # Generate part of the docstring value according to the validator strings
        ds = """"
        for key, value in _MODULATION_SIGNAL_DOC_POOL.items():
            if key in sv:
                ds += f""\n'{key}': {value}""
        self.add_parameter('source',
                           label='Source',
                           set_cmd=f'SOUR{self.hwchan}:PM{self.chnum}:' + 'SOUR {}',
                           get_cmd=f'SOUR{self.hwchan}:PM{self.chnum}:SOUR?',
                           vals=vals.Enum(*sv),
                           docstring=""Selects the modulations source. Values are:""+ds)

        self.add_parameter('mode',
                           label='Mode',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PM:MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PM:MODE?',
                           vals=vals.Enum('HBAN', 'HDEV', 'LNO'),
                           docstring=""""""
                           Selects the mode for the phase modulation. Possible values are:
                           'HBAN': sets the maximum available bandwidth (High BANdwidth)
                           'HDEV': sets the maximum range for deviation (High DEViation)
                           'LNO': selects a phase modulation mode with phase noise and spurious
                               characteristics close to CW mode. (Low NOise)
                           """""")

        if 'SMW-XXX' in self._parent.options: #TODO: welche Option wird hierfür benötigt?
            self.add_parameter('coupling_mode',
                               label='Coupling mode',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PM:DEV:MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PM:DEV:MODE?',
                               vals=vals.Enum('UNC', 'TOT', 'RAT'))

        if 'SMW-XXX' in self._parent.options: #TODO: welche Option wird hierfür benötigt?
            self.add_parameter('total_deviation',
                               label='Total deviation',
                               set_cmd=f'SOUR{self.hwchan}:' + 'PM:DEV:SUM {}',
                               get_cmd=f'SOUR{self.hwchan}:' + 'PM:DEV:SUM?',
                               vals=vals.Numbers(0, 20))

        self.add_parameter('ratio',
                           label='Ratio',
                           set_cmd=f'SOUR{self.hwchan}:' + 'PM:RAT {}',
                           get_cmd=f'SOUR{self.hwchan}:' + 'PM:RAT?',
                           vals=vals.Numbers(0, 100),
                           unit='%',
                           docstring=""Sets the deviation ratio (path2 to path1) in percent."")

        self.add_parameter('sensitivity',
                           label='Sensitivity',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:' + 'PM:SENS?',
                           unit='RAD/V',
                           docstring=""(ReadOnly) Queries the sensitivity of the externally""
                                     "" applied signal for phase modulation. The returned""
                                     "" value reports the sensitivity in RAD/V. It is assigned""
                                     "" to the voltage value for full modulation of the input."")



class LFOutputSweep(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning one LF output Sweeping. The LF output
        is used as modulation signal for the analog modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            dwell: Dwell time in seconds from 0.5 ms to 100 s.
            mode: Cycle mode for level sweep.
                'AUTO': Each trigger triggers exactly one complete sweep.
                'MAN':  You can trigger every step individually with a command.
                'STEP': Each trigger triggers one sweep step only.
            points: Steps within level sweep range
            shape: Waveform shape for sweep. Allowed values are 'SAWTOOTH' and 'TRIANGLE'
            execute: Executes one RF level sweep. Use this without any ( )
            retrace: Activates that the signal changes to the start frequency value while it is
                waiting for the next trigger event. Values are 'ON' and 'OFF'. You can enable this
                feature, when you are working with sawtooth shapes in sweep mode 'MAN' or 'STEP'.
            running: (ReadOnly) Reports the current sweep state. Returnvalues are 'ON' or 'OFF'.
            spacing: calculationmode of frequency intervals. Values are 'LIN' or 'LOG'
            log_step: Sets the step width factor for logarithmic sweeps to calculate
                the frequencies of the steps. The value can be from 0.01% upto 100%.
            lin_step: Set the step size for linear sweep. The value can be from 0.01
                up to the value of <OutputChannel::sweep_span>
        """"""
        self.hwchan = hwchan

        super().__init__(parent, name)

        self.add_parameter('dwell',
                           label='Dwell time',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'DWEL {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:DWEL?',
                           get_parser=float,
                           vals=vals.Numbers(0.0005, 100),
                           unit='s',
                           docstring=""Dwell time in seconds from 0.5 ms to 100 s."")

        sweepmode = vals.Enum('AUTO', 'MAN', 'STEP')
        self.add_parameter('mode',
                           label='Cycle mode for level sweep',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:MODE?',
                           vals=sweepmode,
                           docstring=""""""
                           Cycle mode for level sweep. Values are:
                           'AUTO': Each trigger triggers exactly one complete sweep.
                           'MAN': You can trigger every step individually with a command.
                           'STEP': Each trigger triggers one sweep step only.
                           """""")

        self.add_parameter('points',
                           label='Steps within level sweep range',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'POIN {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:POIN?',
                           get_parser=int,
                           vals=vals.Numbers(2),  # Upperlimit=MAXINT
                           docstring=""Steps within level sweep range"")

        self.add_parameter('shape',
                           label='Waveform shape for sweep',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'SHAP {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:SHAP?',
                           vals=vals.Enum('SAWTOOTH', 'TRIANGLE'),
                           docstring=""Waveform shape for sweep. Allowed values""
                                     "" are 'SAWTOOTH' and 'TRIANGLE'"")

        self.add_function('execute',
                           call_cmd=f'SOUR{self.hwchan}:LFO:SWE:EXEC',
                           docstring=""Executes one RF level sweep. Use this without any ( )"")

        self.add_parameter('retrace',
                           label='Set to start frequency while waiting for trigger  ',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'RETR {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:RETR?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates that the signal changes to the start frequency""
                                     "" value while it is waiting for the next trigger event.""
                                     "" Values are 'ON' and 'OFF'. You can enable this feature,""
                                     "" when you are working with sawtooth shapes in sweep mode""
                                     "" 'MAN' or 'STEP'."")

        self.add_parameter('running',
                           label='Current sweep state',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:RUNN?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""(ReadOnly) Reports the current sweep state.""
                                     "" Returnvalues are 'ON' or 'OFF'."")

        self.add_parameter('spacing',
                           label='calculationmode of frequency intervals',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:' + 'SPAC {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:SPAC?',
                           vals=vals.Enum('LIN', 'LOG'),
                           docstring=""Calculationmode of frequency intervals.""
                                     "" Values are 'LIN' or 'LOG'."")

        self.add_parameter('log_step',
                           label='logarithmically determined step size for the RF freq sweep',
                           set_cmd=f'SOUR{self.hwchan}:LFO:SWE:STEP:' + 'LOG {}',
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:STEP:LOG?',
                           get_parser=float,
                           vals=vals.Numbers(0.01, 100),
                           unit='%',
                           docstring=""Sets the step width factor for logarithmic sweeps""
                                     "" to calculate the frequencies of the steps. The""
                                     "" value can be from 0.01% upto 100%."")

        self.add_parameter('lin_step',
                           label='step size for linear RF freq sweep',
                           set_cmd=partial(self._setlinstep),
                           get_cmd=f'SOUR{self.hwchan}:LFO:SWE:STEP?',
                           get_parser=float,
                           vals=vals.Numbers(0.01),
                           unit='Hz',
                           docstring=""""""
                           Set the step size for linear sweep.
                           The maximum is the sweep_span of the output channel
                           and will be read during the set lin_step command.
                           """""")

    def _setlinstep(self, val):
        """"""
        Helper function to check the maximum allowed value for the step
        """"""
        maxfreq = float(self.ask(f'SOUR{self.hwchan}:FREQ:SPAN?'))
        if val > maxfreq:
            raise ValueError(f'{repr(val)} is invalid: must be between 0.01 and {maxfreq} '
                             f'inclusive.')
        self.write(f'SOUR{self.hwchan}:LFO:SWE:STEP {val}')


class LFOutputChannel(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int, lfchan: int):
        """"""Combines all the parameters concerning one LF output. The LF output is used
        as modulation signal for the analog modulation.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication
            lfchan: the internal number of the LF output channel used

        Attributes:
            bandwidth: (ReadOnly) Requests the current bandwidth.
    
            state: (hwchan=1) The state of the output. Values are 'ON' or 'OFF'.
            offset: (hwchan=1) DC offset voltage in the range from -3.6V to +3.6V.
            source: (hwchan=1) Determines the LF signal to be synchronized if monitoring is enabled.
    
                - 'LF1', 'LF2', 'LF1A', 'LF2A', 'LF1B', 'LF2B': Selects an internally generated
                  LF signal.
                - 'NOISE', 'NOISA', 'NOISB': Selects an internally generated noise signal.
                - 'EXT1', 'EXT2': Selects an externally supplied LF signal.
                - 'AM', 'AMA', 'AMB': Selects the AM signal.
                - 'FMPM', 'FMPMA', 'FMPMB': Selects the signal also used by the frequency or phase
                  modulations.
    
            source_path: (hwchan=1) Path of the LF output source. Values are 'A' or 'B'.
            voltage: (hwchan=1) Output voltage of the LF output. The valid range will be dynamic
            as shown in the datasheet.
    
            period: (lfchan=1, ReadOnly). Queries the repetition frequency of the sine signal.
            frequency: (lfchan=1) The Frequency of the LF signal when the mode() is 'FIX'. Valid range is from 0.1Hz and ends
            depending on the installed options.
            freq_manual: (lfchan=1) Manual frequency set only valid in the range given by the parameters freq_min and freq_max.
            freq_min: (lfchan=1) Set minimum for manual frequency from 0.1Hz to 1MHz.
            freq_max: (lfchan=1) Set maximum for manual frequency from 0.1Hz to 1MHz.
            mode: (lfchan=1) Set the used mode:
    
                - 'FIX': fixed frequency mode (CW is a synonym)
                - 'SWE': set sweep mode (use LFOutputSweep class)
    
            shape: (SMW-K24) Define the shape of the signal.
            Valid values: 'SINE','SQUARE','TRIANGLE','TRAPEZE'.
            shape_duty_cycle: (SMW-K24) Duty cycle for shape pulse (range 1e-6 to 100)
            shape_period: (SMW-K24) Period for shape pulse (range 1e-6 to 100)
            shape_width: (SMW-K24) Width for shape pulse (range 1e-6 to 100)
            trapez_fall: (SMW-K24) Fall time for the trapezoid shape (range 1e-6 to 100)
            trapez_height: (SMW-K24) High time for the trapezoid signal (range 1e-6 to 100)
            trapez_period: (SMW-K24) Period of the generated trapezoid shape (range 1e-6 to 100)
            trapez_rise: (SMW-K24) Rise time for the trapezoid shape (range 1e-6 to 100)
            triangle_period: (SMW-K24) Period of the generated pulse (range 1e-6 to 100)
            triangle_rise: (SMW-K24) Rise time for the triangle shape (range 1e-6 to 100)
        """"""
        self.hwchan = hwchan
        self.lfchan = lfchan

        super().__init__(parent, name)

        # aks the limits for ""freq_manual""
        self.freqmin = float(self.ask(f'SOUR{self.hwchan}:LFO:FREQ:STAR?'))
        self.freqmax = float(self.ask(f'SOUR{self.hwchan}:LFO:FREQ:STOP?'))

        self.add_parameter('bandwidth',
                           label='Bandwidth',
                           set_cmd=False,
                           get_cmd=f'SOUR:LFO{self.lfchan}:BAND?',
                           docstring=""(ReadOnly) Requests the current bandwidth."")

        if 'SMW-K24' in self._parent.options:
            shape_ids = vals.Enum('SINE', 'SQUARE', 'TRIANGLE', 'TRAPEZE')
            self.add_parameter('shape',
                               label='Shape',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}' + ':SHAP {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP?',
                               vals=shape_ids)

            self.add_parameter('shape_duty_cycle',
                               label='Duty cycle for shape pulse',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS' + ':DCYC {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS:DCYC?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100),
                               unit='%')

            self.add_parameter('shape_period',
                               label='Period for shape pulse',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS' + ':PER {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS:PER?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('shape_width',
                               label='Width for shape pulse',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS' + ':WIDT {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:PULS:WIDT?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('trapez_fall',
                               label='Fall time for the trapezoid shape',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP' + ':FALL {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP:FALL?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('trapez_height',
                               label='High time for the trapezoid signal',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP' + ':HIGH {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP:HIGH?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('trapez_period',
                               label='Period of the generated trapezoid shape',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP' + ':PER {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP:PER?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('trapez_rise',
                               label='Rise time for the trapezoid shape',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP' + ':RISE {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRAP:RISE?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('triangle_period',
                               label='period of the generated pulse',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRI' + ':PER {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRI:PER?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))

            self.add_parameter('triangle_rise',
                               label='Rise time for the triangle shape',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRI' + ':RISE {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:SHAP:TRI:RISE?',
                               get_parser=float,
                               vals=vals.Numbers(1e-6, 100))


        if self.hwchan == 1:
            # The following parameters are only available for the SOURCE1

            self.add_parameter('state',
                               label='State',
                               set_cmd=f'SOUR:LFO{self.lfchan}' + ':STAT {}',
                               get_cmd=f'SOUR:LFO{self.lfchan}:STAT?',
                               val_mapping={'ON': 1, 'OFF': 0},
                               vals=vals.Enum('ON', 'OFF'),
                               docstring=""The state of the output. Values are 'ON' or 'OFF'."")

            self.add_parameter('offset',
                               label='DC offset voltage',
                               set_cmd=f'SOUR:LFO{self.lfchan}' + ':OFFS {}',
                               get_cmd=f'SOUR:LFO{self.lfchan}:OFFS?',
                               get_parser=float,
                               vals=vals.Numbers(-3.6, +3.6),
                               unit='V',
                               docstring=""DC offset voltage in the range from -3.6V to +3.6V."")

            source_val = vals.Enum('LF1', 'LF2', 'NOISE', 'AM', 'FMPM', 'EXT1',
                                   'EXT2', 'LF1B', 'LF2B', 'AMB', 'NOISB', 'FMPMB',
                                   'LF1A', 'LF2A', 'NOISA', 'FMPMA', 'AMA')
            self.add_parameter('source',
                               label='Source',
                               set_cmd=f'SOUR:LFO{self.lfchan}' + ':SOUR {}',
                               get_cmd=f'SOUR:LFO{self.lfchan}:SOUR?',
                               vals=source_val,
                               docstring=""""""
                               Determines the LF signal to be synchronized, when monitoring is
                               enabled. Values are:
                               'LF1', 'LF2', 'LF1A', 'LF2A', 'LF1B', 'LF2B'
                               --> Selects an internally generated LF signal.
                               'NOISE', 'NOISA', 'NOISB'
                               --> Selects an internally generated noise signal.
                               'EXT1', 'EXT2'
                               --> Selects an externally supplied LF signal.
                               'AM', 'AMA', 'AMB'
                               --> Selects the AM signal.
                               'FMPM', 'FMPMA', 'FMPMB'
                               --> Selects the signal also used by the frequency or phase modulations.
                               """""")

            if 'SMW-XXX' in self._parent.options: #TODO: welche Option wird hierfür benötigt?
                self.add_parameter('source_path',
                                   label='Path of the LF output source',
                                   set_cmd=f'SOUR:LFO{self.lfchan}:SOUR' + ':PATH {}',
                                   get_cmd=f'SOUR:LFO{self.lfchan}:SOUR:PATH?',
                                   vals=vals.Enum('A', 'B'))

            self.add_parameter('voltage',
                               label='Output voltage of the LF output',
                               set_cmd=f'SOUR:LFO{self.lfchan}' + ':VOLT {}',
                               get_cmd=f'SOUR:LFO{self.lfchan}:VOLT?',
                               get_parser=float,
                               unit='V',
                               docstring=""Output voltage of the LF output. The valid""
                                         "" range will be dynamic as shown in the datasheet."")

        if self.lfchan == 1:
            # With other channel numbers the device said: no hardware

            self.add_parameter('period',
                               label='Period',
                               set_cmd=False,
                               get_cmd=f'SOUR:LFO{self.lfchan}:PER?',
                               get_parser=float,
                               unit='s',
                               docstring=""(ReadOnly) Queries the repetition frequency of the""
                                         "" sine signal."")

            if 'SMW-K24' in self._parent.options:
                maxfreq = 20e9 # TODO: this value will not fit, but I could not find a better one
            else:
                maxfreq = 1e9 # Information of the device
            self.add_parameter('frequency',
                               label='Frequency',
                               set_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}' + ':FREQ {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO{self.lfchan}:FREQ?',
                               get_parser=float,
                               vals=vals.Numbers(0.1, maxfreq),
                               unit='Hz',
                               docstring=""The Frequency of the LF signal when the mode() is `FIX'.""
                                         "" Valid range is from 0.1Hz and ends depending on the""
                                         "" installed options."")
            # The frequency parameter is only readable for lfchan==1 even if the channel
            # number is given in the communication string.

            self.add_parameter('freq_manual',
                               label='Manual frequency set',
                               set_cmd=partial(self._setfreqvalue),
                               get_cmd=f'SOUR{self.hwchan}:LFO:FREQ:MAN?',
                               get_parser=float,
                               unit='Hz',
                               docstring=""Manual frequency set only valid in the range given""
                                         "" by the parameters freq_min and freq_max."")
            self.add_parameter('freq_min',
                               label='Set minimum for manual frequency',
                               set_cmd=partial(self._setfreqmin),
                               get_cmd=f'SOUR{self.hwchan}:LFO:FREQ:STAR?',
                               get_parser=float,
                               vals=vals.Numbers(0.1, 1e6),
                               unit='Hz',
                               docstring=""Set minimum for manual frequency from 0.1Hz to 1MHz."")
            self.add_parameter('freq_max',
                               label='Set maximum for manual frequency',
                               set_cmd=partial(self._setfreqmax),
                               get_cmd=f'SOUR{self.hwchan}:LFO:FREQ:STOP?',
                               get_parser=float,
                               vals=vals.Numbers(0.1, 1e6),
                               unit='Hz',
                               docstring=""Set maximum for manual frequency from 0.1Hz to 1MHz."")

            lfmode = vals.Enum('CW', 'FIX', 'SWE')
            self.add_parameter('mode',
                               label='Mode',
                               set_cmd=f'SOUR{self.hwchan}:LFO:FREQ:' + 'MODE {}',
                               get_cmd=f'SOUR{self.hwchan}:LFO:FREQ:MODE?',
                               vals=lfmode,
                               docstring=""""""
                               Set the used mode:
                               'FIX' = fixed frequency mode ('CW' is a synonym)
                               'SWE' = set sweep mode (use LFOutputSweep class)
                               """""")

    def _setfreqmin(self, val):
        """"""
        Helper function to set the minimum frequency and store it in a local variable
        """"""
        self.freqmin = val
        self.write(f'SOUR{self.hwchan}:LFO:FREQ:STAR {val}')

    def _setfreqmax(self, val):
        """"""
        Helper function to set the maximum frequency and store it in a local variable
        """"""
        self.freqmax = val
        self.write(f'SOUR{self.hwchan}:LFO:FREQ:STOP {val}')

    def _setfreqvalue(self, val):
        """"""
        Helper function to set the manual frequency and checks it against the
        local variables before
        """"""
        if val < self.freqmin or self.freqmax < val:
            raise ValueError(f'{repr(val)} is invalid: must be between {self.freqmin} and '
                             f'{self.freqmax}.')
        self.write(f'SOUR{self.hwchan}:LFO:FREQ:MAN {val}')


class OutputLevelSweep(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning one RF output level (power) sweeping.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            attenuator: Power attenuator mode for level sweep. Values are:
                'NORM': Performs the level settings in the range of the built-in attenuator.
                'HPOW': Performs the level settings in the high level range.
            dwell: Dwell time for level sweep, valid range is from 0.001s to 100s.
            mode: Cycle mode for level sweep. Values are:
                'AUTO': Each trigger triggers exactly one complete sweep.
                'MAN':  You can trigger every step individually with a command.
                'STEP': Each trigger triggers one sweep step only.
            points: Steps within level sweep range, minimum is 2.
            log_step: Logarithmically determined step size for the RF level sweep,
                valid range is 0.01dB to 139dB.
            shape: Waveform shape for sweep. Valid are 'SAWTOOTH' and 'TRIANGLE'.
            execute: Executes one RF level sweep. Use no braces () here!
            retrace: Activates that the signal changes to the start frequency value while it is
                waiting for the next trigger event. Values are 'ON' and 'OFF'. You can enable this
                feature, when you are working with sawtooth shapes in sweep mode 'MAN' or 'STEP'.
            running: (ReadOnly) Get the current sweep state. Return values are 'ON' or 'OFF'.
            reset: Resets all active sweeps to the starting point. Use no braces () here!
        """"""
        self.hwchan = hwchan
        super().__init__(parent, name)

        self.add_parameter('attenuator',
                           label='Power attenuator mode for level sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'AMOD {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:AMOD?',
                           vals=vals.Enum('NORM', 'HPOW'),
                           docstring=""""""
                           Power attenuator mode for level sweep. Values are:
                           'NORM' = Performs the level settings in the range of the built-in
                                    attenuator.
                           'HPOW' = Performs the level settings in the high level range.
                           """""")

        self.add_parameter('dwell',
                           label='Dwell time for level sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'DWEL {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:DWEL?',
                           get_parser=float,
                           vals=vals.Numbers(0.001, 100),
                           unit='s',
                           docstring=""Dwell time for level sweep, valid range is from 0.001s""
                                     "" to 100s."")

        sweepmode = vals.Enum('AUTO', 'MAN', 'STEP')
        self.add_parameter('mode',
                           label='Cycle mode for level sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:MODE?',
                           vals=sweepmode,
                           docstring=""""""
                           Cycle mode for level sweep. Values are:
                           'AUTO' = Each trigger triggers exactly one complete sweep.
                           'MAN'  = You can trigger every step individually with a command.
                           'STEP' = Each trigger triggers one sweep step only.
                           """""")

        self.add_parameter('points',
                           label='Steps within level sweep range',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'POIN {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:POIN?',
                           get_parser=int,
                           vals=vals.Numbers(2),  # Upperlimit=MAXINT
                           docstring=""Steps within level sweep range, minimum is 2."")

        self.add_parameter('log_step',
                           label='logarithmically determined step size for the RF level sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'STEP {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:STEP?',
                           get_parser=float,
                           vals=vals.Numbers(0.01, 139),
                           unit='dB',
                           docstring=""Logarithmically determined step size for the RF level""
                                     "" sweep, valid range is 0.01dB to 139dB."")

        self.add_parameter('shape',
                           label='Waveform shape for sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'SHAP {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:SHAP?',
                           vals=vals.Enum('SAWTOOTH', 'TRIANGLE'),
                           docstring=""Waveform shape for sweep. Valid are 'SAWTOOTH' and""
                                     "" 'TRIANGLE'."")

        self.add_function('execute',
                           call_cmd=f'SOUR{self.hwchan}:SWE:POW:EXEC',
                           docstring=""Executes one RF level sweep. Use no braces () here!"")

        self.add_parameter('retrace',
                           label='Set to start frequency while waiting for trigger  ',
                           set_cmd=f'SOUR{self.hwchan}:SWE:POW:' + 'RETR {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:RETR?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates that the signal changes to the start frequency""
                                     "" value while it is waiting for the next trigger event.""
                                     "" Values are 'ON' and 'OFF'. You can enable this feature,""
                                     "" when you are working with sawtooth shapes in sweep mode""
                                     "" 'MAN' or 'STEP'."")

        self.add_parameter('running',
                           label='Current sweep state',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:SWE:POW:RUNN?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""(ReadOnly) Get the current sweep state. Return""
                                     "" values are 'ON' or 'OFF'."")

        self.add_function('reset',
                           call_cmd=f'SOUR{self.hwchan}:SWE:RES',
                           docstring=""Resets all active sweeps to the starting point.""
                                     "" Use no braces () here!"")


class OutputFrequencySweep(InstrumentChannel):

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, hwchan: int):
        """"""Combines all the parameters concerning one RF output frequency sweeping.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            hwchan: the internal number of the hardware channel used in the communication

        Attributes:
            dwell: Dwell time for frequency sweep. Valid range from 0.001s to 100s.
            mode: Cycle mode for frequency sweep. Values are:
                'AUTO': Each trigger triggers exactly one complete sweep.
                'MAN':  You can trigger every step individually with a command.
                'STEP': Each trigger triggers one sweep step only.
            points: Steps within frequency sweep range, minimum is 2.
            spacing: Calculationmode of frequency intervals. Values are 'LIN' or 'LOG'.
            shape: Waveform shape for sweep. Valid values are 'SAWTOOTH' or 'TRIANGLE'.
            execute: Executes one RF frequency sweep. Use no braces () here!
            retrace: Activates that the signal changes to the start frequency value while it is
                waiting for the next trigger event. Values are 'ON' and 'OFF'. You can enable this
                feature, when you are working with sawtooth shapes in sweep mode 'MAN' or 'STEP'.
            running: (ReadOnly) Get the current sweep state. Return values are 'ON' or 'OFF'.
            log_step: Logarithmically determined step size for the RF frequency sweep.
                Valid range is 0.01 to 100.
            lin_step: Step size for linear RF frequency sweep. The minimum is 0.01
                and the maximum is the sweep_span of the output channel and will
                be read during the set lin_step command.
            reset: Resets all active sweeps to the starting point. Use no braces () here!
        """"""
        self.hwchan = hwchan

        super().__init__(parent, name)

        self.add_parameter('dwell',
                           label='Dwell time for frequency sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'DWEL {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:DWEL?',
                           get_parser=float,
                           vals=vals.Numbers(0.001, 100),
                           unit='s',
                           docstring=""Dwell time for frequency sweep. Valid range from 0.001s""
                                     "" to 100s."")

        sweepmode = vals.Enum('AUTO', 'MAN', 'STEP')
        self.add_parameter('mode',
                           label='Cycle mode for frequency sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'MODE {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:MODE?',
                           vals=sweepmode,
                           docstring=""""""
                           Cycle mode for frequency sweep. Values are:
                           'AUTO' = Each trigger triggers exactly one complete sweep.
                           'MAN'  = You can trigger every step individually with a command.
                           'STEP' = Each trigger triggers one sweep step only.
                           """""")

        self.add_parameter('points',
                           label='Steps within frequency sweep range',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'POIN {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:POIN?',
                           get_parser=int,
                           vals=vals.Numbers(2),  # Upperlimit=MAXINT
                           docstring=""Steps within frequency sweep range, minimum is 2."")

        self.add_parameter('spacing',
                           label='calculationmode of frequency intervals',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'SPAC {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:SPAC?',
                           vals=vals.Enum('LIN', 'LOG'),
                           docstring=""Calculationmode of frequency intervals. Values are 'LIN'""
                                     "" or 'LOG'."")

        self.add_parameter('shape',
                           label='Waveform shape for sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'SHAP {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:SHAP?',
                           vals=vals.Enum('SAWTOOTH', 'TRIANGLE'),
                           docstring=""Waveform shape for sweep. Valid values are 'SAWTOOTH' or""
                                     "" 'TRIANGLE'."")

        self.add_function('execute',
                           call_cmd=f'SOUR{self.hwchan}:SWE:EXEC',
                           docstring=""Executes one RF frequency sweep. Use no braces () here!"")

        self.add_parameter('retrace',
                           label='Set to start frequency while waiting for trigger  ',
                           set_cmd=f'SOUR{self.hwchan}:SWE:' + 'RETR {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:RETR?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Activates that the signal changes to the start frequency""
                                     "" value while it is waiting for the next trigger event.""
                                     "" when you are working Values are 'ON' and 'OFF'. You can""
                                     "" enable this feature, with sawtooth shapes in sweep mode""
                                     "" 'MAN' or 'STEP'."")

        self.add_parameter('running',
                           label='Current sweep state',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.hwchan}:SWE:RUNN?',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""(ReadOnly) Get the current sweep state. Return""
                                     "" values are 'ON' or 'OFF'."")

        self.add_parameter('log_step',
                           label='logarithmically determined step size for the RF freq sweep',
                           set_cmd=f'SOUR{self.hwchan}:SWE:STEP:' + 'LOG {}',
                           get_cmd=f'SOUR{self.hwchan}:SWE:STEP:LOG?',
                           get_parser=float,
                           vals=vals.Numbers(0.01, 100),
                           unit='%',
                           docstring=""Logarithmically determined step size for the RF""
                                     "" frequency sweep. Valid range is 0.01 to 100."")

        self.add_parameter('lin_step',
                           label='step size for linear RF freq sweep',
                           set_cmd=partial(self._setlinstep),
                           get_cmd=f'SOUR{self.hwchan}:SWE:STEP?',
                           get_parser=float,
                           vals=vals.Numbers(0.01),
                           unit='Hz',
                           docstring=""Step size for linear RF frequency sweep. The""
                                     "" minimum is 0.01 and the maximum is the sweep_span""
                                     "" of the output channel and will be read during the""
                                     "" set lin_step command."")

        self.add_function('reset',
                           call_cmd=f'SOUR{self.hwchan}:SWE:RES',
                           docstring=""Resets all active sweeps to the starting point.""
                                     "" Use no braces () here!"")

    def _setlinstep(self, val):
        """"""
        Helper function to check the maximum allowed value for the step
        """"""
        maxfreq = float(self.ask(f'SOUR{self.hwchan}:FREQ:SPAN?'))
        if val > maxfreq:
            raise ValueError(f'{repr(val)} is invalid: must be between 0.01 and {maxfreq} '
                             f'inclusive.')
        self.write(f'SOUR{self.hwchan}:SWE:STEP {val}')


class OutputChannel(InstrumentChannel):
    _MAXFREQ_POOL = {
        1: {
            'SMW-B120': 20e9,
            'SMW-B103': 3e9,
            'SMW-B106': 6e9,
            'SMW-B112': 12.75e9,
            'SMW-B131': 31.8e9,
            'SMW-B140': 40e9
        },
        2: {
            'SMW-B203': 3e9,
            'SMW-B206': 6e9,
            'SMW-B207': 7.5e9,
            'SMW-B212': 12.75e9,
            'SMW-220': 20e9
        }
    }

    def __init__(self, parent: 'RohdeSchwarz_SMW200A', name: str, chnum: int):
        """"""Combines all the parameters concerning one RF output.

        Args:
            parent: the parent instrument of this channel
            name  : the internal QCoDeS name of this channel
            chnum : the internal number of the channel used in the communication

        Attributes:
            state: actives/deactivates the RF output. Values are 'ON' and 'OFF'.
            frequency: set/read the main frequency of the oscillator.
            level: set/read the output power level.
            mode: selects the mode of the oscillator. Valid values are:
                'FIX': fixed frequency mode (CW is a synonym)
                'SWE': set sweep mode (use sweep_start/sweep_stop/sweep_center/sweep_span)
                'LIST': use a special loadable list of frequencies - the list functions
                are not yet implemented here.
            sweep_center: set/read the center frequency of the sweep.
            sweep_span: set/read the span of frequency sweep range.
            sweep_start: set/read the start frequency of the sweep.
            sweep_stop: set/read the stop frequency of the sweep.
            losc_input: read the LOscillator input frequency (ReadOnly).
            losc_mode: set/read the LOscillator mode. Valid values are:

                - 'INT': A&B Internal / Internal (one path instrument). Uses the internal oscillator
                  signal in both paths.
                - 'EXT': A External & B Internal (one path instrument). Uses an external signal in
                  path A. B uses its internal signal.
                - 'COUP': A Internal & A->B Coupled. Assigns the internal oscillator signal of path A
                  also to path B.
                - 'ECO': A External & A->B Coupled. Assigns an externally supplied signal to both
                  paths.
                - 'BOFF': A Internal & B RF Off. Uses the internal local oscillator signal of path A,
                  if the selected frequency exceeds the maximum frequency of path B.
                - 'EBOF': A External & B RF Off. Uses the LO IN signal for path A, if the selected
                  RF frequency exceeds the maximum frequency of path B.
                - 'AOFF': A RF Off & B External. Uses the LO IN signal for path B, if the selected
                  RF frequency exceeds the maximum frequency of path A.

            losc_output: read the LOscillator output frequency (ReadOnly).
            losc_state: set/read the LOscillator state. Valid values are 'ON' and 'OFF'.
        """"""

        self.chnum = chnum
        super().__init__(parent, name)
        if self.chnum in self._MAXFREQ_POOL:
            for opt, freq in self._MAXFREQ_POOL[self.chnum].items():
                if opt in self._parent.options:
                    maxfreq = freq
                    break
            else:
                raise RuntimeError(f""Missing frequency option for RF path {self.chnum}"")

        self.add_parameter('frequency',
                           label='Frequency',
                           set_cmd=f'SOUR{self.chnum}' + ':FREQ {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ?',
                           get_parser=float,
                           vals=vals.Numbers(100e3, maxfreq),
                           unit='Hz',
                           docstring=""The main frequency of the oscillator.""
                                     "" The minimum is 100kHz and the maximum""
                                     "" depends on the installed option."")

        # TODO: are these parameter meaningfull?
        # 'offset' This value represents the frequency shift of a downstream
        #          instrument, like for example a mixer.
        # 'multiplier': This value represents the multiplication factor of a
        #          downstream instrument, like for example a multiplier.

        self.add_parameter('level',
                           label='Level',
                           set_cmd=f'SOUR{self.chnum}:' + 'POW:POW {}',
                           get_cmd=f'SOUR{self.chnum}:POW:POW?',
                           get_parser=float,
                           vals=vals.Numbers(-145, 30),
                           unit='dBm',
                           docstring=""The output power level. Valid values are""
                                     "" from -145dBm up to 30dBm."")

        self.add_parameter('state',
                           label='State',
                           set_cmd=f'OUTP{self.chnum}:' + 'STAT {}',
                           get_cmd=f'OUTP{self.chnum}:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""actives/deactivates the RF output. Values are 'ON' and 'OFF'"")

        rfmode = vals.Enum('CW', 'FIX', 'SWE', 'LIST')
        self.add_parameter('mode',
                           label='Mode',
                           set_cmd=f'SOUR{self.chnum}:FREQ:' + 'MODE {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:MODE?',
                           vals=rfmode,
                           docstring=""""""
                           Selects the mode of the oscillator. Valid values are:
                           'FIX'  = fixed frequency mode (CW is a synonym)
                           'SWE'  = set sweep mode (use start/stop/center/span)
                           'LIST' = use a special loadable list of frequencies (nyi here)
                           """""")

        # Parameter for the sweep mode
        self.add_parameter('sweep_center',
                           label='Center frequency of the sweep',
                           set_cmd=f'SOUR{self.chnum}:FREQ:' + 'CENT {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:CENT?',
                           get_parser=float,
                           vals=vals.Numbers(300e3, maxfreq),
                           unit='Hz',
                           docstring=""""""
                           The center frequency of the sweep.
                           Use sweep_center and sweep_span or
                           use sweep_start and sweep_stop
                           to define the sweep range.
                           """""")

        self.add_parameter('sweep_span',
                           label='Span of frequency sweep range',
                           set_cmd=f'SOUR{self.chnum}:FREQ:' + 'SPAN {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:SPAN?',
                           get_parser=float,
                           vals=vals.Numbers(0, maxfreq),
                           unit='Hz',
                           docstring=""""""
                           The span of frequency sweep range.
                           Use sweep_center and sweep_span or
                           use sweep_start and sweep_stop
                           to define the sweep range.
                           """""")

        self.add_parameter('sweep_start',
                           label='Start frequency of the sweep',
                           set_cmd=f'SOUR{self.chnum}:FREQ:' + 'STAR {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:STAR?',
                           get_parser=float,
                           vals=vals.Numbers(300e3, maxfreq),
                           unit='Hz',
                           docstring=""""""
                           The start frequency of the sweep.
                           Use sweep_start and sweep_stop or
                           use sweep_center and sweep_span
                           to define the sweep range.
                           """""")

        self.add_parameter('sweep_stop',
                           label='Stop frequency of the sweep',
                           set_cmd=f'SOUR{self.chnum}:FREQ:' + 'STOP {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:STOP?',
                           get_parser=float,
                           vals=vals.Numbers(300e3, maxfreq),
                           unit='Hz',
                           docstring=""""""
                           The stop frequency of the sweep.
                           Use sweep_start and sweep_stop or
                           use sweep_center and sweep_span
                           to define the sweep range.
                           """""")

        # Parameter for the LOSCILLATOR
        self.add_parameter('losc_input',
                           label='LOscillator input frequency',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.chnum}:FREQ:LOSC:INP:FREQ?',
                           get_parser=float,
                           unit='Hz',
                           docstring=""(ReadOnly) Read the LOscillator input frequency."")

        lomode = vals.Enum('INT', 'EXT', 'COUP', 'ECO', 'BOFF', 'EBOF', 'AOFF')
        self.add_parameter('losc_mode',
                           label='LOscillator mode',
                           set_cmd=f'SOUR{self.chnum}:FREQ:LOSC:' + 'MODE {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:LOSC:MODE?',
                           vals=lomode,
                           docstring=""""""
                           The LOscillator mode. Valid options:
                               'INT':  A&B Internal / Internal (one path instrument) - Uses the
                                       internal oscillator signal in both paths.
                               'EXT':  A External & B Internal (one path instrument) - Uses an
                                       external signal in path A. B uses its internal signal.
                               'COUP': A Internal & A->B Coupled - Assigns the internal oscillator
                                       signal of path A also to path B.
                               'ECO':  A External & A->B Coupled - Assigns an externally supplied
                                       signal to both paths.
                               'BOFF': A Internal & B RF Off - Uses the internal local oscillator
                                       signal of path A, if the selected frequency exceeds the
                                       maximum frequency of path B.
                               'EBOF': A External & B RF Off - Uses the LO IN signal for path A, if
                                       the selected RF frequency exceeds the maximum frequency of
                                       path B.
                               'AOFF': A RF Off & B External - Uses the LO IN signal for path B, if
                                       the selected RF frequency exceeds the maximum frequency of
                                       path A.
                           """""")

        self.add_parameter('losc_output',
                           label='LOscillator output frequency',
                           set_cmd=False,
                           get_cmd=f'SOUR{self.chnum}:FREQ:LOSC:OUTP:FREQ?',
                           get_parser=float,
                           unit='Hz',
                           docstring=""(ReadOnly) Read the LOscillator output frequency."")

        self.add_parameter('losc_state',
                           label='LOscillator state',
                           set_cmd=f'SOUR{self.chnum}:FREQ:LOSC:OUTP:' + 'STAT {}',
                           get_cmd=f'SOUR{self.chnum}:FREQ:LOSC:OUTP:STAT?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=""Set the LOscillator state. Valid values are 'ON' and 'OFF'."")



class RohdeSchwarz_SMW200A(VisaInstrument):
#class RohdeSchwarz_SMW200A(MockVisa):
    """"""This is the qcodes driver for the Rohde & Schwarz SMW200A vector signal
    generator.
    
    Do not forget to change the class for real / simulation mode.

    Status:
        coding: almost finished
        communication tests: done
        usage in experiment: outstanding
    """"""

    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, **kwargs)

        # for security check the ID from the device
        self.idn = self.ask(""*IDN?"").strip()
        if not self.idn.startswith(""Rohde&Schwarz,SMW200A,""):
            raise RuntimeError(""Invalid device ID found: ""+self.idn)

        log.debug(__name__ + ' : Initializing instrument ' + self.idn)

        # save the option flags as a string array for later usage
        self.options = self.ask(""*OPT?"").strip().split("","")
        self.add_parameter('options',
                           label='Options',
                           set_cmd=False,
                           get_cmd=self.get_options,
                           docstring=""(ReadOnly) List of installed options."")

        # RF output submodules
        rfchannels = ChannelList(self, ""OutputChannels"", OutputChannel,
                                 snapshotable=False)
        if 'SMW-B203' in self.options or 'SMW-B206' in self.options \
                or 'SMW-B207' in self.options or 'SMW-B212' in self.options \
                or 'SMW-B220' in self.options:
            self.rfoutput_no = 2
        else:
            self.rfoutput_no = 1
        for chnum in range(1, self.rfoutput_no+1):
            name = f'rfoutput{chnum}'
            rfchannel = OutputChannel(self, name, chnum)
            rfchannels.append(rfchannel)
            self.add_submodule(name, rfchannel)
        rfchannels.lock()
        self.add_submodule('output_channels', rfchannels)

        # RF output sweep submodules (for Level and Frequency)
        rflevelsweeps = ChannelList(self, ""OutputLevelSweep"", OutputLevelSweep,
                                    snapshotable=False)
        for rfnum in range(1, self.rfoutput_no+1):
            name = f'level_sweep{rfnum}'
            rfsweep = OutputLevelSweep(self, name, rfnum)
            rflevelsweeps.append(rfsweep)
            self.add_submodule(name, rfsweep)
        rflevelsweeps.lock()
        self.add_submodule('rflevelsweep_channels', rflevelsweeps)

        rffreqsweeps = ChannelList(self, ""OutputFrequencySweep"", OutputFrequencySweep,
                                   snapshotable=False)
        for rfnum in range(1, self.rfoutput_no+1):
            name = f'freq_sweep{rfnum}'
            rfsweep = OutputFrequencySweep(self, name, rfnum)
            rffreqsweeps.append(rfsweep)
            self.add_submodule(name, rfsweep)
        rffreqsweeps.lock()
        self.add_submodule('rffreqsweep_channels', rffreqsweeps)

        # LF output submodules
        lfchannels = ChannelList(self, ""LFOutputChannels"", LFOutputChannel,
                                 snapshotable=False)
        self.lfoutput_no = 2 # TODO: wie fragen wir das ab?
        for rfnum in range(1, self.rfoutput_no+1):
            for lfnum in range(1, self.lfoutput_no+1):
                name = f'lf{rfnum}output{lfnum}'
                lfchannel = LFOutputChannel(self, name, rfnum, lfnum)
                lfchannels.append(lfchannel)
                self.add_submodule(name, lfchannel)
        lfchannels.lock()
        self.add_submodule('lfoutput_channels', lfchannels)

        # LF output sweep submodules
        lfsweeps = ChannelList(self, ""LFOutputSweep"", LFOutputSweep,
                               snapshotable=False)
        for rfnum in range(1, self.rfoutput_no+1):
            name = f'lf{rfnum}sweep'
            lfsweep = LFOutputSweep(self, name, rfnum)
            lfsweeps.append(lfsweep)
            self.add_submodule(name, lfsweep)
        lfsweeps.lock()
        self.add_submodule('lfsweep_channels', lfsweeps)

        #Amplitude Modulation submodules
        amchannels = ChannelList(self, ""AMChannels"", AmplitudeModulation,
                                 snapshotable=False)
        self.am_no = 2
        for rfnum in range(1, self.rfoutput_no+1):
            for chnum in range(1, self.am_no+1):
                name = f'am{rfnum}_{chnum}'
                amchannel = AmplitudeModulation(self, name, rfnum, chnum)
                amchannels.append(amchannel)
                self.add_submodule(name, amchannel)
        amchannels.lock()
        self.add_submodule('am_channels', amchannels)

        if 'SMW-B22' or 'SMW-B20' in self.options:
            #Frequency Modulation submodules
            fmchannels = ChannelList(self, ""FMChannels"", FrequencyModulation,
                                     snapshotable=False)
            self.fm_no = 2
            for rfnum in range(1, self.rfoutput_no+1):
                for chnum in range(1, self.fm_no+1):
                    name = f'fm{rfnum}_{chnum}'
                    fmchannel = FrequencyModulation(self, name, rfnum, chnum)
                    fmchannels.append(fmchannel)
                    self.add_submodule(name, fmchannel)
            fmchannels.lock()
            self.add_submodule('fm_channels', fmchannels)

            #Phase Modulation submodules
            pmchannels = ChannelList(self, ""PMChannels"", PhaseModulation,
                                     snapshotable=False)
            self.pm_no = 2
            for rfnum in range(1, self.rfoutput_no+1):
                for chnum in range(1, self.pm_no+1):
                    name = f'pm{rfnum}_{chnum}'
                    pmchannel = PhaseModulation(self, name, rfnum, chnum)
                    pmchannels.append(pmchannel)
                    self.add_submodule(name, pmchannel)
            pmchannels.lock()
            self.add_submodule('pm_channels', pmchannels)

        #Pulse modulation submodule
        if 'SMW-K22' in self.options:
            for rfnum in range(1, self.rfoutput_no+1):
                name = f'pulsemod{rfnum}'
                pulsemchannel = PulseModulation(self, name, rfnum)
                self.add_submodule(name, pulsemchannel)

            if 'SMW-K23' in self.options:
                #Pulse generator
                pgenchannels = ChannelList(self, ""PGenChannels"", PulseGenerator,
                                           snapshotable=False)
                self.pgen_no = 1
                for chnum in range(1, self.pgen_no+1):
                    name = f'pulsegen{chnum}'
                    pgenchannel = PulseGenerator(self, name, chnum)
                    pgenchannels.append(pgenchannel)
                    self.add_submodule(name, pgenchannel)
                pgenchannels.lock()
                self.add_submodule('pgen_channels', pgenchannels)
                self.add_parameter('genTriggerPulse',
                                   label='Trigger Pulse',
                                   set_cmd=self.genTriggerPulse,
                                   get_cmd=False,
                                   docstring=""(WriteOnly) Generates on trigger pulse."")

        #IQ modulation submodule
        for rfnum in range(1, self.rfoutput_no+1):
            name = f'iqmod{rfnum}'
            IQmodchannel = IQModulation(self, name, rfnum)
            self.add_submodule(name, IQmodchannel)

        #analog IQ outputs submodule
        iqchannels = ChannelList(self, ""IQChannels"", IQChannel, snapshotable=False)
        self.iqoutput_no = 2
        for iq_num in range(1, self.iqoutput_no+1):
            name = f'iqoutput{iq_num}'
            iqchannel = IQChannel(self, name, iq_num)
            iqchannels.append(iqchannel)
            self.add_submodule(name, iqchannel)
        iqchannels.lock()
        self.add_submodule('iqoutput_channels', iqchannels)


    def get_id(self):
        """"""
        Get the device identification.

        Args:
            None

        Returns:
            Strings from the IDN command from the startup.
        """"""
        return self.idn


    def get_options(self):
        """"""
        Get the device option flags.

        Args:
            None

        Returns:
            Stringarray with the options installed in the device
        """"""
        return self.options


    def close(self):
        """"""
        Close the connection.

        Args:
            None

        Returns:
            None
        """"""
        log.info(__name__ + ': close connection')
        super().close()


    def reset(self):
        """"""
        Resets the instrument to default values.

        Args:
            None

        Returns:
            None
        """"""
        log.info(__name__ + ': Resetting instrument')
        self.write('*RST')


    def get_error(self):
        """"""
        Reads the errors from the device.

        Args:
            None

        Returns:
            List of strings containing error number and string representation
        """"""
        retval = self.ask('SYST:ERR:ALL?').strip().split(""\n"")
        return retval


    def gen_trigger_pulse(self, val):
        """"""
        Function to generate a trigger pulse. The port for this is always defined
        by the user. And the Options SMW-K22 and SMW-K23 must be installed.

        Args:
            val: the time value in seconds (tested with 0.0001)
        """"""
        if not 'SMW-K22' in self.options or not 'SMW-K23' in self.options:
            raise RuntimeError('Invalid options installed (SMW-K22 and SMW-K23 needed)')
        # get the required submodules
        pgen = self.submodules['pulsegen1']
        pmod = self.submodules['pulsemod1']
        # configure the submodules
        pgen.polarity('NORM')
        pmod.delay(0)
        pmod.mode('SING')
        pmod.trigger_mode('AUTO')
        # calculate the period to the third of the requested width
        if val < 0.1:
            # if the requested width is too short, make it longer
            pmod.period(val + 0.3)
        else:
            pmod.period(val * 3.0)
        pmod.width(val)
        # active the pulse
        pgen.output('ON')
        # wait some time longer than the pulse but shorter than the period
        if val < 0.1:
            time.sleep(val + 0.1)
        else:
            time.sleep(val * 1.4)
        # deactivate the output to prevent the second pulse
        pgen.output('OFF')



    def getall(self, submod=""*""):
        """"""
        Read all parameters and retun them to the caller. This will scan all
        submodules with all parameters, so in this function no changes are
        necessary for new modules or parameters.

        Args:
            submod: (optional) returns only the parameters for this submodule.

        Returns:
            dict with all parameters, the key is the modulename and the parametername
        """"""
        retval = {}
        if submod == ""*"":
            # ID and options only if all modules are returned
            retval.update({""ID"": self.idn})
            retval.update({""Options"": self.options})

        for m in self.submodules:
            mod = self.submodules[m]
            if not isinstance(mod, ChannelList) and submod in (""*"", m):
                for p in mod.parameters:
                    par = mod.parameters[p]
                    try:
                        if par.unit.isEmpty():
                            val = str(par()).strip()
                        else:
                            val = str(par()).strip() + "" "" + par.unit
                    except:
                        val = ""** not readable **""
                    retval.update({m + ""."" + p: val})

        return retval
"
91,could not find,https://www.everythingrf.com/search/microwave-rf-amplifiers,"[OrderedDict([('id', 'attYjeFgtcYBZEORx'), ('width', 250), ('height', 945), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vOX9eUcQFOvopyiQdpSkWQ/nO2-RN3ykepGj7qGFzFIocB6Ashk2rZvI4fiQgfTgSAxkr-knSdxBbsP25Dp8pIJH7n2AXjs9737fkCJ5YZeN5VwOrsbm8PYcERj-E-lgew/45fU4E2xRicdDUdB9R8Ic-pP4r4IWdDQSLgv2znhNgg'), ('filename', 'FrontM2j.png'), ('size', 270260), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZK8I-L6oWQvI7UTKQP7kxQ/8rby0UqvB2cJoXD2p_Oy3xlbw4PIxEzq9Pa1-T07TPFT0rdT9tZzi33MJQhzOGJgoRJ3JuKGwygkROotvSqiEA/FWLnsz7Hb7M06wpRA-rF0M1sVpTgjElfbMkvEzwzoV8'), ('width', 10), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/HtfWzoS5zuaDQ24kweZi5A/J-VZw4RoTPg_3FtDXiFBNsUf2tlsJnyhVVHvvc6URhEGz0ymE-soQ5up28InES-dgITosYUWy8zBocXgol4MvQ/ly1W_4DKjerHFCdQJhUB9JV5wpjHOtJZUvI9QexDokk'), ('width', 250), ('height', 945)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/r3sAIstSEzSYAqWQ1jQ2WQ/rLvCkNpuVAUAeuHBP53C_S9bs3UtQutTIIgJS7aPjsgg5F1Pl-UU4JtWoiPmUSv-yyXeOgIEMtrr33Nq_3Txqw/XE1xgnl-uClcgimb3sD5gQOf5-Q2YXASF5Z6wkpaang'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands",The M2j module is a low noise amplifier initially designed for use in reflectometry. It has been optimised for use with the F1d IQ Demodulator with a 40 MHz to 1.5 GHz frequency range. This is reflected in the gain flatness of M2j: within 3dB from 40 MHz to 1.4 GHz.,https://qtwork.tudelft.nl/~mtiggelman/modules/rf/m2j.html,M2J,440.0,['Lockin Amplifiers'],A Microwave RF Amplifier is an electronic device that amplifies a low power radio frequency signal to one with larger amplitude within a wireless system. RF Amplifiers from the leading manufacturers are listed below. Use the filters to narrow down on products based on your requirement. Download datasheets and request quotes for products that you find interesting. Your inquiry will be directed to the manufacturer and their distributors in your region.,"At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/M2j.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.M2j,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,M2j,Write a Python script that uses Qcodes Community to connect to a M2j Lockin Amplifiers,,,,,"from qcodes.instrument.base import Instrument
from qcodes.utils.validators import Numbers
import numpy as np

try:
    from spirack import M2j_module, SPI_rack
except ImportError:
    raise ImportError(('The M2j_module class could not be found. '
                       'Try installing it using pip install spirack'))


class M2j(Instrument):

    def __init__(self, name: str, spi_rack: SPI_rack, module: int, **kwargs):
        """"""
        Qcodes driver for the M2j RF amplifier SPI-rack module.

        Args:
            name: name of the instrument.

            spi_rack: instance of the SPI_rack class as defined in
                the spirack package. This class manages communication with the
                individual modules.

            module: module number as set on the hardware.

        The gain can only be set on the device, but not read from the device.
        """"""
        super().__init__(name, **kwargs)

        self.m2j = M2j_module(spi_rack, module)
        self._max_gain_value = 4095
        self._min_gain_value = 0
        self._gain_parameters = {'slope': -1024.45, 'offset': 4450.63,
                                 'db_offset': 32}

        self.add_parameter('gain',
                           label='gain',
                           set_cmd=self._set_gain,
                           unit='dB',
                           vals=Numbers(min_value=33, max_value=110),
                           docstring='Amplifier gain in dB, range 33 to 110 dB')

        self.add_parameter('RF_level',
                           label='RF level',
                           get_cmd=self._meas_rf_level,
                           unit='dBm',
                           docstring='Measured RF power after amplification '
                                     '(not calibrated)')

        self.add_function('clear_rf_clip',
                          call_cmd=self.m2j.clear_rf_clip)
        self.add_function('is_rf_clipped',
                          call_cmd=self.m2j.rf_clipped)

    def _set_gain(self, gain):
        ref_scale = int(self._gain_parameters['slope'] * np.log(
            gain - self._gain_parameters['db_offset']) + self._gain_parameters[
                            'offset'])
        if ref_scale < self._min_gain_value:
            ref_scale = self._min_gain_value
        if ref_scale > self._max_gain_value:
            ref_scale = self._max_gain_value

        self.m2j.set_gain(ref_scale)

    def _meas_rf_level(self):
        """"""
        Measure the power in dBm. Calibrated using an R&S SMA100 source.
        Linear relation between set power and measured data.
        Measurement range -80 to -40 dBm.
        """"""
        return self.m2j.get_level()
"
93,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'att6gOYzZvJ5DwDip'), ('width', 1280), ('height', 720), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7lILp9UpxtR6TdoCYGE2Aw/5CRIhJyrX6fA15AnEVTCl_ovq7dM6NGHOPd1j6d-GUjj-l51YbLMnEmXyjABn7Ux-pYOLtVkFnXo6daB6HLnFXjn8dnZAmv-CpVO4eM-4dxixxl61YGq2nCUbXC51tK7/dhSKcmM8bV9nTj7wKFql_fV8EoYJfpzmgHij7mfnQiE'), ('filename', 'erasynth-splash_jpg_md-xl.jpg'), ('size', 42614), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SU4BdCUcWYS5ZX2xLDLxCA/r-VbHnsRN1a2FtPNWpau6n6U7uwF5W5_l14oCUuy-ksrBq_BInXeUyMRa4-yENQVTQPcb4WckYEmfdqaaCyuEw/TZij4aYkKWmZvMK09t2rX76SMyexSxOSMoCWGMmJsgo'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/L7zbkak6bWaexwpgSXVlfg/7kPgKoTPxKqGigNp5EoUlHN1lOj8sDvdy0ECDiaO9Ju698mX8_hmcklnrqFe3dx96H1dCcjjEsi9VbE2rjHHNg/XfAaAdEFwnxS2GlY7Wdp6R5iNjgqsU2mlfVMxZJQ0Gk'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4uqZdqaPDImrpdN9VSh6hw/qatbQkwTd7EkSe1s46-J6ktM3LKbg7YxW-QtOwb-pbdUt2RBNj74_aP070yE9Pvjma1PszPiVC8cl4YyfiN-Vw/B1rInCky_aXgbi2pEaIe_pKqkPCEKCXX4sjhBqjf7b4'), ('width', 3000), ('height', 3000)]))]))])]",5.0,Turkey,"ERASynth removes the cost barriers and makes quality RF signal synthesis accessible to everyone, especially budget-conscious makers.",https://erainstruments.com/,"ERASYNTH
",121.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape","**ERA Instruments** is a startup technology company based in Istanbul, Turkey. With its young and dynamic engineering team, ERA specializes in: RF Signal Generators
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/ERAInstruments/erasynth.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.ERAInstruments.html#module-qcodes_contrib_drivers.drivers.ERAInstruments.erasynth,Erainstruments,"[OrderedDict([('id', 'attqjNKC4K1tN3MTz'), ('width', 1833), ('height', 839), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SxvqYhg-Tol0WxzdGERVBQ/C3xEco5l9-EYaMRckEP5RwMZjFHrRcOJ9_CYzEVGa7OK5hZ3XoFdSUVqOBB0Ex1tzWZgiBlV0aDdS1Ars0KL19YvFuybDRmwJaUmTlok-FnqdJBksx3V5jsOLdOxlCUj/JiRhTGMq-8TNJdZ_mDU_MR6pn2_TpjTMy3Al1Ft_iA0'), ('filename', 'era-instruments-logo-4.svg'), ('size', 5220), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZQ0ICV3M7hN5KncrJRzZ2w/CDai81TI6Uv0llZRbegjgLI0-lKa_n28Tczs3tlCOgOPUoYkvlebirGIyZs4Dx_GKAyf0NkVOyCeXuNIfDfUO4gAphtmt2GaZhXlAY9Fbb4/Hmukp3EITLuCbi-16WtErVY10VcEN2cQ9FkTlk6yh9s'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/D4YlEc6qg5e2dWhb-d_5dw/64LWx7VOcMkc5liox1L7d6sbaiuZE7XVZw4F4iZrf7j5ppgRl612CXupOrO0_U4DblILrJTYb12gv-_nfcjw5N390oYobt45ln-fXdwg4Xs/MfShsNOS-lkp86hiRaLwyarDIVGuRxSD1hcgzwy_kkk'), ('width', 1119), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xlrVz929ekdClOW5Q9mpGQ/F6RKk8HCqC6E8YPLk8CzY38_i4ASlkaCsnFhlE2e_yV8dcLuxMQ2MMythZL0juRfya0UhSJkAqZTPkSv0w68tie2Uooccm5NqytiuOdMXm8/ZFafnQSekkEgAsmE3i-QLBemgYg-pn7eS0o5JqW1UeI'), ('width', 3000), ('height', 3000)]))]))])]",https://erainstruments.com/#home,"ERASYNTH
","Write a Python script that uses Qcodes Community to connect to a ERASYNTH
 RF Signal Generator",500.0,,,ERASYNTH Firmware is coded in C++,"""""""Driver for the ERASynth/ERASynth+/ERASynth++ signal generators.

Author: Victor Negîrneac, vnegirneac@qblox.com

For official instrument support visit:

- https://erainstruments.com
- https://github.com/erainstruments/

This module provides the following drivers:

- :class:`qcodes_contrib_drivers.drivers.ERAInstruments.ERASynth <qcodes_contrib_drivers.drivers.ERAInstruments.erasynth.ERASynth>`,
- :class:`qcodes_contrib_drivers.drivers.ERAInstruments.ERASynthPlus <qcodes_contrib_drivers.drivers.ERAInstruments.erasynth.ERASynthPlus>`, and
- :class:`qcodes_contrib_drivers.drivers.ERAInstruments.ERASynthPlusPlus <qcodes_contrib_drivers.drivers.ERAInstruments.erasynth.ERASynthPlusPlus>`.
""""""
from __future__ import annotations

from typing import Dict, List, Union, Tuple, Optional
import time
import json
import logging

from qcodes import VisaInstrument, Parameter, validators

try:
    import pyvisa
except ModuleNotFoundError as e:
    raise ModuleNotFoundError(
        ""ERAInstrument drivers require the `pyvisa` package to be installed.\n""
        ""Install it with `pip install pyvisa` and try again.""
    ) from e

logger = logging.getLogger(__name__)

BAUDRATE = 115200

_CMD_TO_JSON_MAPPING: Dict[str, str] = {
    # We will treat these differently when confirming the value
    # because the instrument replies with a sentence containing the value.
    # which is much faster than reading the full JSON
    # as fast as possible
    # ""P0"": ""rfoutput"",
    # ""A"": ""amplitude"",
    # ""F"": ""frequency"",
    ""P1"": ""reference_int_ext"",
    ""P5"": ""reference_tcxo_ocxo"",
    ""MS"": ""modulation_on_off"",
    ""M2"": ""modulation_signal_waveform"",
    ""M1"": ""modulation_source"",
    ""M0"": ""modulation_type"",
    ""M3"": ""modulation_freq"",
    ""M5"": ""modulation_am_depth"",
    ""M4"": ""modulation_fm_deviation"",
    ""M6"": ""modulation_pulse_period"",
    ""M7"": ""modulation_pulse_width"",
    ""SS"": ""sweep_start_stop"",
    ""S0"": ""sweep_trigger"",
    ""S1"": ""sweep_start"",
    ""S2"": ""sweep_stop"",
    ""S3"": ""sweep_step"",
    ""S4"": ""sweep_dwell"",
    ""P9"": ""phase_noise_mode"",
    ""PEW"": ""wifi_mode"",
    ""PES0"": ""wifi_sta_ssid"",
    ""PEP0"": ""wifi_sta_password"",
    ""PES1"": ""wifi_ap_ssid"",
    ""PEP1"": ""wifi_ap_password"",
    ""PEI"": ""wifi_ip_address"",
    ""PEN"": ""wifi_subnet_address"",
    ""PEG"": ""wifi_gateway_address"",
}
""""""
A mapping used to read back certain commands to ensure they have been set.
This is necessary due to non-deterministic communication times.
""""""

class ERASynthBase(VisaInstrument):
    r""""""
    A Base class for the ERASynth/ERASynth+/ERASynth++ instruments.

    Example:

    .. code-block::

        from qcodes import Instrument
        from qcodes_contrib_drivers.drivers.ERAInstruments import ERASynthPlus

        # list communication ports
        ERASynthPlus.print_pyvisa_resources()

        # Instantiate the instrument
        lo = ERASynthPlus(""ERASynthPlus"", 'ASRL/dev/cu.usbmodem14101::INSTR')

        lo.off()  # Turn off the output

        # print updated snapshot once to make sure the snapshot will be up-to-date
        # takes a few seconds
        lo.print_readable_snapshot(update=True)

        # Configure the local oscillator
        lo.ref_osc_source(""int"")  # Use internal reference
        lo.frequency(4.7e9)
        lo.power(10)  # Set the amplitude to 10 dBm
        lo.on()  # Turn on the output


    .. seealso::

        The raw serial commands can be found here:
        https://github.com/erainstruments/erasynth-docs/blob/master/erasynth-command-list.pdf

        ``self.visa_handle`` can be used to interact directly with the serial pyvisa
        communication.
    """"""

    @staticmethod
    def print_pyvisa_resources() -> None:
        """"""Utility to list all.""""""
        resource_manager = pyvisa.ResourceManager()
        print(resource_manager.list_resources())

    def _prep_communication(self):
        """"""Makes sure the instrument config is compatible with this driver.""""""
        self.debug_messages_en(False)  # Print less messages to improve communication
        self.wifi_off()  # print less messages to improve communication

    def __init__(self, name: str, address: str, **kwargs):
        """"""
        Create an instance of the instrument.

        Args:
            name: Instrument name.
            address: Used to connect to the instrument.
                Run :meth:`.ERASynthBase.print_pyvisa_resources` to list available list.
        """"""
        super().__init__(name=name, address=address, terminator=""\r\n"", **kwargs)

        # ##############################################################################
        # Standard LO parameters
        # ##############################################################################

        # NB `initial_value` is not used because that would make the initialization slow

        self.status = Parameter(
            name=""status"",
            instrument=self,
            val_mapping={False: ""0"", True: ""1""},
            get_cmd=""RA:rfoutput"",
            set_cmd=self._set_status,
        )
        """"""Sets the output state (`True`/`False`).""""""

        self.power = Parameter(
            name=""power"",
            instrument=self,
            label=""Power"",
            unit=""dBm"",
            vals=validators.Numbers(min_value=-60.0, max_value=20.0),
            get_cmd=""RA:amplitude"",
            get_parser=float,
            set_parser=lambda power: f""{power:.2f}"",
            set_cmd=self._set_power,
        )
        """"""Signal power in dBm of the ERASynth signal, 'amplitude' in EraSynth docs.""""""

        self.ref_osc_source = Parameter(
            name=""ref_osc_source"",
            instrument=self,
            val_mapping={""int"": ""0"", ""ext"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['P1']}"",
            set_cmd=""P1{}"",
        )
        """"""
        Set to external if a 10 MHz reference is connected to the REF input connector.
        """"""

        # ##############################################################################
        # ERASynth specific parameters
        # ##############################################################################

        self.temperature = Parameter(
            name=""temperature"",
            instrument=self,
            label=""Temperature"",
            unit=""\u00B0C"",
            get_cmd=""RD:temperature"",
        )
        """"""Temperature of the device.""""""

        self.voltage = Parameter(
            name=""voltage"",
            instrument=self,
            label=""Voltage"",
            unit=""V"",
            get_cmd=""RD:voltage"",
        )
        """"""The input voltage value from power input of the ERASynth.""""""

        self.current = Parameter(
            name=""current"",
            instrument=self,
            label=""Current"",
            unit=""V"",
            get_cmd=""RD:current"",
        )
        """"""The current value drawn by the ERASynth.""""""

        self.embedded_version = Parameter(
            name=""embedded_version"",
            instrument=self,
            label=""Embedded version"",
            get_cmd=""RD:em"",
        )
        """"""The firmware version of the ERASynth.""""""

        self.wifi_rssi = Parameter(
            name=""wifi_rssi"",
            instrument=self,
            label=""WiFi RSSI"",
            get_cmd=""RD:rssi"",
        )
        """"""The Wifi received signal power.""""""

        self.pll_lmx1_status = Parameter(
            name=""pll_lmx1_status"",
            instrument=self,
            label=""PLL LMX1 status"",
            val_mapping={""locked"": ""1"", ""unlocked"": ""0""},
            get_cmd=""RD:lock_lmx1"",
        )
        """"""PLL lock status of LMX1.""""""

        self.pll_lmx2_status = Parameter(
            name=""pll_lmx2_status"",
            instrument=self,
            label=""PLL LMX2 status"",
            val_mapping={""locked"": ""1"", ""unlocked"": ""0""},
            get_cmd=""RD:lock_lmx2"",
        )
        """"""PLL lock status of LMX2.""""""

        self.pll_xtal_status = Parameter(
            name=""pll_xtal_status"",
            instrument=self,
            label=""PLL XTAL status"",
            val_mapping={""locked"": ""1"", ""unlocked"": ""0""},
            get_cmd=""RD:lock_xtal"",
        )
        """"""PLL lock status of XTAL.""""""

        self.modulation_en = Parameter(
            name=""modulation_en"",
            instrument=self,
            val_mapping={False: ""0"", True: ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['MS']}"",
            set_cmd=""MS{}"",
        )
        """"""Modulation on/off.""""""

        self.modulation_signal_waveform = Parameter(
            name=""modulation_signal_waveform"",
            instrument=self,
            val_mapping={""sine"": ""0"", ""triangle"": ""1"", ""ramp"": ""2"", ""square"": ""3""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M2']}"",
            set_cmd=""M2{}"",
        )
        """"""Internal modulation waveform.""""""

        self.modulation_source = Parameter(
            name=""modulation_source"",
            instrument=self,
            val_mapping={""internal"": ""0"", ""external"": ""1"", ""microphone"": ""2""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M1']}"",
            set_cmd=""M1{}"",
        )
        """"""Modulation source.""""""

        self.modulation_type = Parameter(
            name=""modulation_type"",
            instrument=self,
            val_mapping={
                ""narrowband_fm"": ""0"",
                ""wideband_fm"": ""1"",
                ""am"": ""2"",
                ""pulse"": ""3"",
            },
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M0']}"",
            set_cmd=""M0{}"",
        )
        """"""Modulation type.""""""

        self.modulation_freq = Parameter(
            name=""modulation_freq"",
            instrument=self,
            label=""Modulation frequency"",
            unit=""Hz"",
            vals=validators.Numbers(min_value=0, max_value=20e9),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M3']}"",
            get_parser=int,
            set_cmd=""M3{}"",
            set_parser=lambda freq: str(int(freq)),
        )
        """"""Internal modulation frequency in Hz.""""""

        self.modulation_am_depth = Parameter(
            name=""modulation_am_depth"",
            instrument=self,
            label=""AM depth"",
            unit=""%"",
            vals=validators.Numbers(min_value=0, max_value=100),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M5']}"",
            get_parser=int,
            set_cmd=""M5{}"",
            set_parser=lambda depth: str(int(depth)),
        )
        """"""AM modulation depth.""""""

        self.modulation_fm_deviation = Parameter(
            name=""modulation_fm_deviation"",
            instrument=self,
            label=""FM deviation"",
            unit=""Hz"",
            vals=validators.Numbers(min_value=0, max_value=20e9),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M4']}"",
            get_parser=int,
            set_cmd=""M4{}"",
            set_parser=lambda freq: str(int(freq)),
        )
        """"""FM modulation deviation.""""""

        self.modulation_pulse_period = Parameter(
            name=""modulation_pulse_period"",
            instrument=self,
            label=""Pulse period"",
            unit=""s"",
            vals=validators.Numbers(min_value=1e-6, max_value=10),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M6']}"",
            get_parser=lambda val: int(val) * 1e-6,
            set_cmd=""M6{}"",
            set_parser=lambda period: str(int(period * 1e6)),
        )
        """"""Pulse period in seconds.""""""

        self.modulation_pulse_width = Parameter(
            name=""modulation_pulse_width"",
            instrument=self,
            label=""Pulse width"",
            unit=""s"",
            vals=validators.Numbers(min_value=1e-6, max_value=10),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['M7']}"",
            get_parser=lambda val: int(val) * 1e-6,
            set_cmd=""M7{}"",
            set_parser=lambda period: str(int(period * 1e6)),
        )
        """"""Pulse width in s.""""""

        self.sweep_en = Parameter(
            name=""sweep_en"",
            instrument=self,
            val_mapping={False: ""0"", True: ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['SS']}"",
            set_cmd=""SS{}"",
        )
        """"""Sweep on/off.""""""

        self.sweep_trigger = Parameter(
            name=""sweep_trigger"",
            instrument=self,
            val_mapping={""freerun"": ""0"", ""external"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['S0']}"",
            set_cmd=""S0{}"",
        )
        """"""Sweep trigger freerun/external.""""""

        self.sweep_dwell = Parameter(
            name=""sweep_dwell"",
            instrument=self,
            label=""Sweep dwell"",
            unit=""s"",
            vals=validators.Numbers(min_value=1e-3, max_value=10),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['S4']}"",
            get_parser=lambda val: int(val) * 1e-3,
            set_cmd=""S4{}"",
            set_parser=lambda period: str(int(period * 1e3)),
        )
        """"""Sweep dwell time in s. Requires sweep_trigger('freerun').""""""

        self.synthesizer_mode = Parameter(
            name=""synthesizer_mode"",
            instrument=self,
            val_mapping={""low_spurious"": ""0"", ""low_phase_noise"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['P9']}"",
            set_cmd=""P9{}"",
        )
        """"""Synthesizer mode, low spurious/low phase noise.""""""

        # WiFi control, NB initial_cache_value is used to avoid overriding these values

        self.wifi_mode = Parameter(
            name=""wifi_mode"",
            instrument=self,
            val_mapping={""station"": ""0"", ""hotspot"": ""1"", """": """"},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEW']}"",
            set_cmd=""PEW{}"",
        )
        """"""WiFi Mode, station/hotspot.""""""

        self.wifi_station_ssid = Parameter(
            name=""wifi_station_ssid"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PES0']}"",
            set_cmd=""PES0{}"",
        )
        """"""Sets network SSID for WiFi module.""""""

        self.wifi_station_password = Parameter(
            name=""wifi_station_password"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEP0']}"",
            set_cmd=""PEP0{}"",
        )
        """"""Sets network password for WiFi module.""""""

        self.wifi_hotspot_ssid = Parameter(
            name=""wifi_hotspot_ssid"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PES1']}"",
            set_cmd=""PES1{}"",
        )
        """"""Sets hotspot SSID for WiFi module.""""""

        self.wifi_hotspot_password = Parameter(
            name=""wifi_hotspot_password"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEP1']}"",
            set_cmd=""PEP1{}"",
        )
        """"""Sets hotspot password for WiFi module.""""""

        self.wifi_ip_address = Parameter(
            name=""wifi_ip_address"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEI']}"",
            set_cmd=""PEI{}"",
        )
        """"""Sets IP address for WiFi module.""""""

        self.wifi_subnet_address = Parameter(
            name=""wifi_subnet_address"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEN']}"",
            set_cmd=""PEN{}"",
        )
        """"""Sets Subnet mask for WiFi module.""""""

        self.wifi_gateway_address = Parameter(
            name=""wifi_gateway_address"",
            instrument=self,
            vals=validators.Strings(),
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['PEG']}"",
            set_cmd=""PEG{}"",
        )
        """"""Sets default gateway for WiFi module.""""""

        self.debug_messages_en = Parameter(
            name=""debug_messages_en"",
            instrument=self,
            vals=validators.Strings(),
            initial_cache_value=None,
            val_mapping={True: ""1"", False: ""0""},
            set_cmd=""PD{}"",
        )
        """"""Enables/disables debug printing on the serial port.""""""

        setattr(self.visa_handle, ""baud_rate"", BAUDRATE)
        self.timeout(10)  # generous timeout to avoid disrupting measurements
        self.connect_message()
        self._prep_communication()

    # ##################################################################################
    # Public methods
    # ##################################################################################

    # Standard LO methods

    def on(self) -> None:
        """"""
        Turns ON the RF output.
        """"""
        self.status(True)

    def off(self) -> None:
        """"""
        Turns OFF the RF output.
        """"""
        self.status(False)

    # Custom communication

    def get_idn(self) -> Dict[str, Optional[str]]:
        models = {""0"": ""ERASynth"", ""1"": ""ERASynth+"", ""2"": ""ERASynth++""}
        d_status = self.get_diagnostic_status()
        assert isinstance(d_status, Dict)
        return {
            ""vendor"": ""ERA Instruments"",
            ""model"": models[d_status[""model""]],
            ""serial"": d_status[""serial_number""],
            ""firmware"": d_status[""em""],
        }

    def clear_read_buffer(self) -> None:
        """"""
        Clears the read buffer. The instrument often sends information we do not care
        about in this driver. This function discards the entire read buffer by reading
        it.
        """"""
        bytes_in_buffer = lambda: getattr(self.visa_handle, ""bytes_in_buffer"")
        while bytes_in_buffer():
            self.visa_handle.read_bytes(bytes_in_buffer())

    def ask(self, cmd: str) -> str:
        """"""Writes a command to the communication channel of the instrument and return
        the response.

        Commands are prefixed with `"">""` as required by the ERASynth.

        NB the read buffer is discarded before and after reading one line.
        """"""
        self.clear_read_buffer()
        response = super().ask(f"">{cmd}"")
        self.clear_read_buffer()

        return response

    def ask_raw(self, cmd: str) -> str:
        """"""
        Detects special commands for which the `get_configuration` will be used.

        This makes it convenient to not implement individual getters for most commands.
        """"""
        if cmd[1:].startswith(""RA:""):
            response = self.get_configuration(cmd[1 + len(""RA:"") :])
        elif cmd[1:].startswith(""RD:""):
            response = self.get_diagnostic_status(cmd[1 + len(""RD:"") :])
        else:
            response = super().ask_raw(cmd)
        assert isinstance(response, str)
        return response

    def write(self, cmd: str) -> None:
        """"""Writes a command to the communication channel of the instrument.

        Commands are prefixed with `"">""` as required by the ERASynth.

        NB the read buffer is discarded before and after reading one line.
        """"""
        self.clear_read_buffer()
        super().write(f"">{cmd}"")
        self.clear_read_buffer()

    def write_raw(self, cmd: str) -> None:
        """"""
        For some commands we confirm that the value has been set correctly.

        This is only possible for configurations that can be retrieved from the
        instrument.
        """"""
        is_readable_cmd = False
        for command in _CMD_TO_JSON_MAPPING:
            if cmd[1:].startswith(command):
                is_readable_cmd = True
                break

        if is_readable_cmd:
            json_key = _CMD_TO_JSON_MAPPING[command]
            cmd_arg = cmd[1 + len(command) :]
            while True:
                super().write_raw(cmd)
                self.clear_read_buffer()
                if self.get_configuration(json_key) == cmd_arg:
                    break
        else:
            super().write_raw(cmd)

    def _get_json(self, cmd: str, first_key: str) -> str:
        """"""
        Sends command and reads result until the result looks like a JSON.
        """"""
        timeout = 10
        t_start = time.time()
        first_key = '{""' + first_key + '""'
        while True:
            read_line = self.ask(cmd)
            # Ensure the line contains the json
            if first_key in read_line and read_line[-1] == ""}"":
                break
            if time.time() > t_start + timeout:
                raise TimeoutError(
                    f""Failed to query JSON within {timeout} s. ""
                    f""Command {cmd!r} failed.""
                )

        return """".join([""{"", *read_line.split(""{"")[1:]])

    # ERASynth specific methods

    def get_configuration(self, par_name: Optional[str] = None) -> Union[Dict[str, str], str]:
        """"""
        Returns the configuration JSON that contains all parameters.
        """"""
        config_json = json.loads(self._get_json(""RA"", ""rfoutput""))

        return config_json if par_name is None else config_json[par_name]

    def get_diagnostic_status(self, par_name: Optional[str] = None) -> Union[Dict[str, str], str]:
        """"""
        Returns the diagnostic JSON.
        """"""
        config_json = json.loads(self._get_json(""RD"", ""temperature""))
        return config_json if par_name is None else config_json[par_name]

    def preset(self) -> None:
        """"""
        Presets the device to known values.

        .. warning::

            After the reset the output is set to power 0.0 dBm @ 1GHz!
        """"""
        self.write(""PP"")
        self._prep_communication()

    def factory_reset(self) -> None:
        """"""
        Does factory reset on the device.
        """"""
        self.write(""PR"")
        self._prep_communication()

    def esp8266_upload_mode(self) -> None:
        """"""Sets the ESP8266 module in upload mode.""""""
        self.write(""U"")

    def wifi_on(self) -> None:
        """"""Turn ESP8266 WiFi module on.""""""
        self.write(""PE01"")

    def wifi_off(self) -> None:
        """"""Turn ESP8266 WiFi module off.""""""
        self.write(""PE00"")

    def run_self_test(self) -> None:
        """"""
        Sets all settable parameters to different values.

        NB serves as self test of the instrument because setting readable parameters
        is done by setting and confirming the value.
        """"""
        par_values = list(_SELF_TEST_LIST)

        if isinstance(self, (ERASynthPlus, ERASynthPlusPlus)):
            # Only ERASynth+ and ERASynth++ have this functionality
            par_values += [
                (""reference_tcxo_ocxo"", ""tcxo""),
                (""reference_tcxo_ocxo"", ""ocxo""),
            ]

        num_tests = len(par_values)
        for i, (name, val) in enumerate(par_values):
            print(f""\r[{i+1:2d}/{num_tests}] Running..."", end="""")
            self.set(name, val)

        print(""\nDone!"")

    # ##################################################################################
    # set commands
    # ##################################################################################

    def _set_and_confirm(self, cmd: str, cmd_arg: str, str_back: Optional[str] = None) -> None:
        """"""
        Because for this command the instrument replies with a text containing the
        value, we make use of it to ensure we waited enough time for the changes to
        take effect.
        """"""
        str_back = cmd_arg if str_back is None else str_back
        while True:
            read_line = self.ask(f""{cmd}{cmd_arg}"")
            if str_back in read_line:
                break

    def _set_frequency(self, value: str) -> None:
        self._set_and_confirm(cmd=""F"", cmd_arg=value)

    def _set_power(self, value: str) -> None:
        self._set_and_confirm(cmd=""A"", cmd_arg=value)

    def _set_status(self, value: str) -> None:
        str_back = {""0"": ""OFF"", ""1"": ""ON""}[value]
        self._set_and_confirm(cmd=""P0"", cmd_arg=value, str_back=str_back)


def _mk_frequency(self, max_frequency: float) -> Parameter:
    frequency = Parameter(
        name=""frequency"",
        instrument=self,
        label=""Frequency"",
        unit=""Hz"",
        vals=validators.Numbers(min_value=250e3, max_value=max_frequency),
        get_cmd=""RA:frequency"",
        get_parser=int,
        set_cmd=self._set_frequency,
        set_parser=lambda freq: str(int(freq)),
    )
    frequency.__doc__ = ""The RF Frequency in Hz.""
    return frequency


def _mk_sweep_start_frequency(self, max_frequency: float) -> Parameter:
    sweep_start_frequency = Parameter(
        name=""sweep_start_frequency"",
        instrument=self,
        label=""Sweep start"",
        unit=""Hz"",
        vals=validators.Numbers(min_value=250e3, max_value=max_frequency),
        get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['S1']}"",
        get_parser=int,
        set_cmd=""S1{}"",
        set_parser=lambda freq: str(int(freq)),
    )
    sweep_start_frequency.__doc__ = ""Sweep start frequency in Hz.""
    return sweep_start_frequency


def _mk_sweep_stop_frequency(self, max_frequency: float) -> Parameter:
    sweep_stop_frequency = Parameter(
        name=""sweep_stop_frequency"",
        instrument=self,
        label=""Sweep stop"",
        unit=""Hz"",
        vals=validators.Numbers(min_value=250e3, max_value=max_frequency),
        get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['S2']}"",
        get_parser=int,
        set_cmd=""S2{}"",
        set_parser=lambda freq: str(int(freq)),
    )
    sweep_stop_frequency.__doc__ = ""Sweep stop frequency in Hz.""
    return sweep_stop_frequency


def _mk_sweep_step_frequency(self, max_frequency: float) -> Parameter:
    sweep_step_frequency = Parameter(
        name=""sweep_step_frequency"",
        instrument=self,
        label=""Sweep step"",
        unit=""Hz"",
        vals=validators.Numbers(min_value=0, max_value=max_frequency),
        get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['S3']}"",
        get_parser=int,
        set_cmd=""S3{}"",
        set_parser=lambda freq: str(int(freq)),
    )
    sweep_step_frequency.__doc__ = ""Sweep step frequency in Hz.""
    return sweep_step_frequency


class ERASynth(ERASynthBase):
    """"""
    Driver for the ERASynth model instrument.

    For ERASynth+/ERASynth++ see :class:`.EraSynthPlus`/:class:`.EraSynthPlusPlus`
    classes.
    """"""

    def __init__(self, name: str, address: str, **kwargs):
        super().__init__(name=name, address=address, **kwargs)

        self.frequency = _mk_frequency(self, max_frequency=6e9)
        self.sweep_start_frequency = _mk_sweep_start_frequency(self, max_frequency=6e9)
        self.sweep_stop_frequency = _mk_sweep_stop_frequency(self, max_frequency=6e9)
        self.sweep_step_frequency = _mk_sweep_step_frequency(
            self, max_frequency=6e9 - 250e3
        )

        self.reference_tcxo_ocxo = Parameter(
            name=""reference_tcxo_ocxo"",
            instrument=self,
            val_mapping={""tcxo"": ""0"", ""ocxo"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['P5']}"",
        )
        """"""
        NB not tested if this parameter is available for the ERASynth model (<6GHz)!
        """"""


class ERASynthPlus(ERASynthBase):
    """"""
    Driver for the ERASynth+ model instrument.

    For ERASynth/ERASynth++ see :class:`.EraSynth`/:class:`.EraSynthPlusPlus` classes.
    """"""

    def __init__(self, name: str, address: str, **kwargs):
        super().__init__(name=name, address=address, **kwargs)

        self.frequency = _mk_frequency(self, max_frequency=15e9)
        self.sweep_start_frequency = _mk_sweep_start_frequency(self, max_frequency=15e9)
        self.sweep_stop_frequency = _mk_sweep_stop_frequency(self, max_frequency=15e9)
        self.sweep_step_frequency = _mk_sweep_step_frequency(
            self, max_frequency=15e9 - 250e3
        )

        self.reference_tcxo_ocxo = Parameter(
            name=""reference_tcxo_ocxo"",
            instrument=self,
            val_mapping={""tcxo"": ""0"", ""ocxo"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['P5']}"",
            set_cmd=""P5{}"",
        )
        """"""Chooses reference type.""""""


class ERASynthPlusPlus(ERASynthBase):
    """"""
    Driver for the ERASynth++ model instrument.

    For ERASynth/ERASynth+ see :class:`.EraSynth`/:class:`.EraSynthPlus` classes.
    """"""

    def __init__(self, name: str, address: str, **kwargs):
        super().__init__(name=name, address=address, **kwargs)

        self.frequency = _mk_frequency(self, max_frequency=20e9)
        self.sweep_start_frequency = _mk_sweep_start_frequency(self, max_frequency=20e9)
        self.sweep_stop_frequency = _mk_sweep_stop_frequency(self, max_frequency=20e9)
        self.sweep_step_frequency = _mk_sweep_step_frequency(
            self, max_frequency=20e9 - 250e3
        )

        self.reference_tcxo_ocxo = Parameter(
            name=""reference_tcxo_ocxo"",
            instrument=self,
            val_mapping={""tcxo"": ""0"", ""ocxo"": ""1""},
            get_cmd=f""RA:{_CMD_TO_JSON_MAPPING['P5']}"",
            set_cmd=""P5{}"",
        )
        """"""Chooses reference type.""""""


_SELF_TEST_LIST: List[Tuple[str, Union[bool, float, int, str]]] = [
    (""frequency"", 3.3e9),
    (""modulation_am_depth"", 30),
    (""modulation_fm_deviation"", 1e3),
    (""modulation_freq"", 2e3),
    (""modulation_pulse_period"", 0.003),
    (""modulation_pulse_width"", 0.002),
    (""power"", 0.01),
    (""power"", -0.01),
    (""sweep_dwell"", 0.001),
    (""sweep_start_frequency"", 2e9),
    (""sweep_step_frequency"", 0.5e9),
    (""sweep_stop_frequency"", 6e9),
    (""status"", True),
    (""status"", False),
    (""modulation_en"", True),
    (""modulation_en"", False),
    (""modulation_signal_waveform"", ""triangle""),
    (""modulation_signal_waveform"", ""ramp""),
    (""modulation_signal_waveform"", ""square""),
    (""modulation_signal_waveform"", ""sine""),
    (""modulation_source"", ""internal""),
    (""modulation_source"", ""external""),
    (""modulation_source"", ""microphone""),
    (""modulation_type"", ""narrowband_fm""),
    (""modulation_type"", ""am""),
    (""modulation_type"", ""pulse""),
    (""modulation_type"", ""wideband_fm""),
    (""ref_osc_source"", ""ext""),
    (""ref_osc_source"", ""int""),
    (""synthesizer_mode"", ""low_phase_noise""),
    (""synthesizer_mode"", ""low_spurious""),
    (""sweep_en"", True),
    (""sweep_en"", False),
    (""sweep_trigger"", ""freerun""),
    (""sweep_trigger"", ""external""),
    (""wifi_mode"", ""hotspot""),
    (""wifi_mode"", ""station""),
    (""wifi_station_ssid"", ""ERA_123""),
    (""wifi_station_ssid"", ""ERA""),
    (""wifi_station_password"", ""era1234""),
    (""wifi_station_password"", ""era19050""),
    (""wifi_hotspot_ssid"", ""ERA""),
    (""wifi_hotspot_ssid"", ""ERASynth""),
    (""wifi_hotspot_password"", ""erainstruments+""),
    (""wifi_hotspot_password"", ""erainstruments""),
    (""wifi_ip_address"", ""192.168.001.151""),
    (""wifi_ip_address"", ""192.168.001.150""),
    (""wifi_gateway_address"", ""192.168.001.002""),
    (""wifi_gateway_address"", ""192.168.001.001""),
    (""wifi_subnet_address"", ""255.255.255.001""),
    (""wifi_subnet_address"", ""255.255.255.000""),
]
""""""
A list of `Tuple[<parameter_name, value>]` used for a self-test of the instrument.
It is intended to check that read/write parameters are set correctly.
""""""
"
98,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attt8HEDjvIpzSWow'), ('width', 500), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sQIAK8eGo0dd-t500BexSA/Vf3bhxgJOBhLPT1FUq7HSMyLNbt2BvhmBHCxot-CJL1IkwrGhbKtB5igmzQPprx8htsz_2AGpi6qBRadWq94fdkLZdCiUGVXEBh6Icb53Rc/nkdobelu03piJNb8QuMlxQTWvWOYGK9aN3hVgL3Of5Q'), ('filename', 'SC_5121A.png'), ('size', 92169), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/c4gu7lfoiF85nL2W1vS-JA/cyx5teoYn-j3bLJGZxgyrjLId9cmoUO4ZOhbGMUO29vXgaZ1Hz6kceqU8RpDAAJj2oOUfZaqtLfOuIKg-OHZrA/QTU-KPdnnVGJsZvQ1uw9iiN2PSBO6iKIgPugWl9SqE0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/G1ezpAj7RNTtpRnDImVpCQ/59wvtixZTy0UO0fiB8vzZc9mHq-jKUtK1dscPBQbGOnHLTwvumCFVgpEtc4plBZQ2_kFRqxpS1CupYAWTjIGPg/szshhbBehniA70XXu1YIfIvrGRZNqy9AfBd_kOXPk9k'), ('width', 500), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9Zz2l4w8bCmkLIi8VqbWnw/JQ_EiQlQ43U3opSYqD5YotQHvnJOlVMqcgG-hpBmp36P7x1UOXb_8CsT7fbkDx20gllNCSXBjjV95ChYbwpuPQ/d0x-ixRmdXe95kqU9_9NewRrhDDbLYSjMPihOhC57n0'), ('width', 3000), ('height', 3000)]))]))])]",2.4,"Georgetown, Texas","The SC5520A and SC5521A are part of the ultra-high frequency synthesizer series (UHFS) of signal generators
",https://www.signalcore.com/40ghz_signal-source.html,"Signalcore - 5521A
",507.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Founded in 2009, SignalCore, Inc. is a privately held company based in Georgetown, Texas. SignalCore designs and manufactures high quality, instrument grade RF and microwave subsystems. We serve customers worldwide in the industries of measurement, communications, aerospace, defense, academia, and electronics manufacturing. Our extensive engineering knowledge and experience in the design and manufacturing of high performance RF and microwave solutions ensures that our products are of the highest quality and reliability in the industry.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/SignalCore/SignalCore.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.SignalCore.html#module-qcodes_contrib_drivers.drivers.SignalCore.SignalCore,Signalcore,"[OrderedDict([('id', 'att2GziCud68FfO8C'), ('width', 518), ('height', 161), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kEXtsxCTEPo0POuHaggEPQ/LbMQnPK_3wxXsr_rfUcYi0jCHcL2tNqFB6EVGvppV_K1FwG2Ex4rc_92LkWO2uitd4K4ntYxRqjPq2VryujM2A/JFCoHnykeANMPq1TYsAodLX6RgYLQLLnA7C3gA810fw'), ('filename', 'logo.png'), ('size', 11072), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/klhjh1-wtvZXCuALWoqAQw/syRuwKDawoF8ZmfBhWFZwEi7-q7qgMzCNOZKAxeWZdNlzws_ZFj0jsmRJ87xvsk5R1MUXfqLW29FzCMLl826vg/4YKZ3AzmrdiS37T2beHdtOliFxjXfx-kGVCaarqDoBg'), ('width', 116), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/bKjoF6GXSxDnicigvxMRXg/5T__d3yJPTS3km7XTXV11wfC4UWBv3_epLLnEoLXErkApy-dwqZwZsui6WzPIyLYHj1a8Afi7pfGCTCxK2Wxzw/Gq1943JJBj5O_FvpisapPlWfplNl5sZZT_oPF32qsCU'), ('width', 518), ('height', 161)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/lYUiP_OWxjrUCcpf9oj-Vw/Pcl2t3B5_5s8DrDkuAIiSVipiT1n_o8oamf3ZmBuWddLLaBZalChDVlhEV19ykZTSGOQ8z5I3PEz0rJUqjD5QQ/aWvXh-rrzd4AW3Y-sg3hZ63vWDglJHU0ap3isGPvll0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.signalcore.com/,5521A,Write a Python script that uses Qcodes Community to connect to a 5521A RF Signal Generator,,,,,"import ctypes
import ctypes.wintypes
import os
import sys
from typing import Dict, Optional
from qcodes import Instrument
from qcodes.utils.validators import Enum


MAXDEVICES = 50
MAXDESCRIPTORSIZE = 9
COMMINTERFACE = ctypes.c_uint8(1)

class ManDate(ctypes.Structure):
    _fields_ = [('year', ctypes.c_uint8),
                ('month', ctypes.c_uint8),
                ('day', ctypes.c_uint8),
                ('hour', ctypes.c_uint8)]


class DeviceInfoT(ctypes.Structure):
    _fields_ = [('product_serial_number', ctypes.c_uint32),
                ('hardware_revision', ctypes.c_float),
                ('firmware_revision', ctypes.c_float),
                ('device_interfaces', ctypes.c_uint8),
                ('man_date', ManDate)]
device_info_t = DeviceInfoT()


class ListModeT(ctypes.Structure):
    _fields_ = [('sweep_mode', ctypes.c_uint8),
                ('sweep_dir', ctypes.c_uint8),
                ('tri_waveform', ctypes.c_uint8),
                ('hw_trigger', ctypes.c_uint8),
                ('step_on_hw_trig', ctypes.c_uint8),
                ('return_to_start', ctypes.c_uint8),
                ('trig_out_enable', ctypes.c_uint8),
                ('trig_out_on_cycle', ctypes.c_uint8)]


class PLLStatusT(ctypes.Structure):
    _fields_ = [('sum_pll_ld', ctypes.c_uint8),
                ('crs_pll_ld', ctypes.c_uint8),
                ('fine_pll_ld', ctypes.c_uint8),
                ('crs_ref_pll_ld', ctypes.c_uint8),
                ('crs_aux_pll_ld', ctypes.c_uint8),
                ('ref_100_pll_ld', ctypes.c_uint8),
                ('ref_10_pll_ld', ctypes.c_uint8)]


class OperateStatusT(ctypes.Structure):
    _fields_ = [('rf1_lock_mode', ctypes.c_uint8),
                ('rf1_loop_gain', ctypes.c_uint8),
                ('device_access', ctypes.c_uint8),
                ('device_standby', ctypes.c_uint8),
                ('auto_pwr_disable', ctypes.c_uint8),
                ('output_enable', ctypes.c_uint8),
                ('ext_ref_lock_enable', ctypes.c_uint8),
                ('ext_ref_detect', ctypes.c_uint8),
                ('ref_out_select', ctypes.c_uint8),
                ('list_mode_running', ctypes.c_uint8),
                ('rf_mode', ctypes.c_uint8),
                ('over_temp', ctypes.c_uint8),
                ('harmonic_ss', ctypes.c_uint8),
                ('pci_clk_enable', ctypes.c_uint8)]


class DeviceStatusT(ctypes.Structure):
    _fields_ = [('list_mode_t', ListModeT),
                ('operate_status_t', OperateStatusT),
                ('pll_status_t', PLLStatusT)]
device_status_t = DeviceStatusT()


class HWTriggerT(ctypes.Structure):
    _fields_ = [('edge', ctypes.c_uint8),
                ('pxi_enable', ctypes.c_uint8),
                ('pxi_line', ctypes.c_uint8)]
hw_trigger_t = HWTriggerT()


class DeviceRFParamsT(ctypes.Structure):
    _fields_ = [('frequency', ctypes.c_double),
                ('sweep_start_freq', ctypes.c_double),
                ('sweep_stop_freq', ctypes.c_double),
                ('sweep_step_freq', ctypes.c_double),
                ('sweep_dwell_time', ctypes.c_uint32),
                ('sweep_cycles', ctypes.c_uint32),
                ('buffer_points', ctypes.c_uint32),
                ('rf_phase_offset', ctypes.c_float),
                ('power_level', ctypes.c_float),
                ('atten_value', ctypes.c_float),
                ('level_dac_value', ctypes.c_uint16)]
device_rf_params_t = DeviceRFParamsT()


error_dict = {'0':'SCI_SUCCESS',
              '0':'SCI_ERROR_NONE',
              '-1':'SCI_ERROR_INVALID_DEVICE_HANDLE',
              '-2':'SCI_ERROR_NO_DEVICE',
              '-3':'SCI_ERROR_INVALID_DEVICE',
              '-4':'SCI_ERROR_MEM_UNALLOCATE',
              '-5':'SCI_ERROR_MEM_EXCEEDED',
              '-6':'SCI_ERROR_INVALID_REG',
              '-7':'SCI_ERROR_INVALID_ARGUMENT',
              '-8':'SCI_ERROR_COMM_FAIL',
              '-9':'SCI_ERROR_OUT_OF_RANGE',
              '-10':'SCI_ERROR_PLL_LOCK',
              '-11':'SCI_ERROR_TIMED_OUT',
              '-12':'SCI_ERROR_COMM_INIT',
              '-13':'SCI_ERROR_TIMED_OUT_READ',
              '-14':'SCI_ERROR_INVALID_INTERFACE'}



class SC5521A(Instrument):
    __doc__ = 'QCoDeS python driver for the Signal Core SC5521A.'

    def __init__(self, name: str,
                       dll_path: str='SignalCore\\SC5520A\\api\\c\\scipci\\x64\\sc5520a_uhfs.dll',
                       **kwargs):
        """"""
        QCoDeS driver for the Signal Core SC5521A.
        This driver has been tested when only one SignalCore is connected to the
        computer.

        Args:
        name (str): Name of the instrument.
        dll_path (str): Path towards the instrument DLL.
        """"""

        (super().__init__)(name, **kwargs)

        self._devices_number = ctypes.c_uint()
        self._pxi10Enable = 0
        self._lock_external = 0
        self._clock_frequency = 10
        buffers = [ctypes.create_string_buffer(MAXDESCRIPTORSIZE + 1) for bid in range(MAXDEVICES)]
        self.buffer_pointer_array = (ctypes.c_char_p * MAXDEVICES)()
        for device in range(MAXDEVICES):
            self.buffer_pointer_array[device] = ctypes.cast(buffers[device], ctypes.c_char_p)

        self._buffer_pointer_array_p = ctypes.cast(self.buffer_pointer_array, ctypes.POINTER(ctypes.c_char_p))

        # Adapt the path to the computer language
        if sys.platform == 'win32':
            dll_path = os.path.join(os.environ['PROGRAMFILES'], dll_path)
            self._dll = ctypes.WinDLL(dll_path)
        else:
            raise EnvironmentError(f""{self.__class__.__name__} is supported only on Windows platform"")

        found = self._dll.sc5520a_uhfsSearchDevices(COMMINTERFACE, self._buffer_pointer_array_p, ctypes.byref(self._devices_number))
        if found:
            raise RuntimeError('Failed to find any device')
        self._open()

        self.add_parameter(name='temperature',
                           docstring='Return the microwave source internal temperature.',
                           label='Device temperature',
                           unit='celsius',
                           get_cmd=self._get_temperature)

        self.add_parameter(name='status',
                           docstring='.',
                           vals=Enum('on', 'off'),
                           set_cmd=self._set_status,
                           get_cmd=self._get_status)

        self.add_parameter(name='power',
                           docstring='.',
                           label='Power',
                           unit='dbm',
                           set_cmd=self._set_power,
                           get_cmd=self._get_power)

        self.add_parameter(name='frequency',
                           docstring='.',
                           label='Frequency',
                           unit='Hz',
                           set_cmd=self._set_frequency,
                           get_cmd=self._get_frequency)

        self.add_parameter(name='rf_mode',
                           docstring='.',
                           vals=Enum('single_tone', 'sweep'),
                           initial_value='single_tone',
                           set_cmd=self._set_rf_mode,
                           get_cmd=self._get_rf_mode)

        self.add_parameter(name='clock_frequency',
                           docstring='Select the internal clock frequency, 10 or 100MHz.',
                           unit='MHz',
                           vals=Enum(10, 100),
                           initial_value=100,
                           set_cmd=self._set_clock_frequency,
                           get_cmd=self._get_clock_frequency)

        self.add_parameter(name='clock_reference',
                           docstring='Select the clock reference, internal or external.',
                           vals=Enum('internal', 'external'),
                           initial_value='internal',
                           set_cmd=self._set_clock_reference,
                           get_cmd=self._get_clock_reference)
        self.connect_message()

    def _open(self) -> None:
        if sys.platform == ""win32"":
            self._handle = ctypes.wintypes.HANDLE()
        else:
            raise EnvironmentError(f""{self.__class__.__name__} is supported only on Windows platform"")

        self._dll.sc5520a_uhfsOpenDevice(COMMINTERFACE, self.buffer_pointer_array[0], ctypes.c_uint8(1), ctypes.byref(self._handle))

    def _close(self) -> None:
        self._dll.sc5520a_uhfsCloseDevice(self._handle)

    def _error_handler(self, msg: int) -> None:
        """"""Display error when setting the device fail.

        Args:
            msg (int): error key, see error_dict dict.

        Raises:
            BaseException
        """"""

        if msg!=0:
            raise BaseException(""Couldn't set the devise due to {}."".format(error_dict[str(msg)]))
        else:
            pass

    def _get_temperature(self) -> float:
        temperature = ctypes.c_float()
        self._dll.sc5520a_uhfsFetchTemperature(self._handle, ctypes.byref(temperature))
        return temperature.value

    def _set_status(self, status: str) -> None:
        if status.lower() == 'on':
            status_ = 1
        else:
            status_ = 0
        msg = self._dll.sc5520a_uhfsSetOutputEnable(self._handle, ctypes.c_int(status_))
        self._error_handler(msg)

    def _get_status(self) -> str:
        self._dll.sc5520a_uhfsFetchDeviceStatus(self._handle, ctypes.byref(device_status_t))
        if device_status_t.operate_status_t.output_enable:
            return 'on'
        else:
            return 'off'

    def _set_power(self, power: float) -> None:
        msg = self._dll.sc5520a_uhfsSetPowerLevel(self._handle, ctypes.c_float(power))
        self._error_handler(msg)

    def _get_power(self) -> float:
        self._dll.sc5520a_uhfsFetchRfParameters(self._handle, ctypes.byref(device_rf_params_t))
        return device_rf_params_t.power_level

    def _set_frequency(self, frequency: float) -> None:
        msg = self._dll.sc5520a_uhfsSetFrequency(self._handle, ctypes.c_double(frequency))
        self._error_handler(msg)

    def _get_frequency(self) -> float:
        device_rf_params_t = DeviceRFParamsT()
        self._dll.sc5520a_uhfsFetchRfParameters(self._handle, ctypes.byref(device_rf_params_t))
        return float(device_rf_params_t.frequency)

    def _set_clock_frequency(self, clock_frequency: float) -> None:
        if clock_frequency == 10:
            self._select_high = 0
        else:
            self._select_high = 1
        msg = self._dll.sc5520a_uhfsSetReferenceMode(self._handle, ctypes.c_int(self._pxi10Enable), ctypes.c_int(self._select_high), ctypes.c_int(self._lock_external))
        self._error_handler(msg)

    def _get_clock_frequency(self) -> float:
        self._dll.sc5520a_uhfsFetchDeviceStatus(self._handle, ctypes.byref(device_status_t))
        ref_out_select = device_status_t.operate_status_t.ref_out_select
        if ref_out_select == 1:
            return 100
        return 10

    def _set_clock_reference(self, clock_reference: str) -> None:
        if clock_reference.lower() == 'internal':
            self._lock_external = 0
        else:
            self._lock_external = 1
        msg = self._dll.sc5520a_uhfsSetReferenceMode(self._handle, ctypes.c_int(self._pxi10Enable), ctypes.c_int(self._select_high), ctypes.c_int(self._lock_external))
        self._error_handler(msg)

    def _get_clock_reference(self) -> str:
        self._dll.sc5520a_uhfsFetchDeviceStatus(self._handle, ctypes.byref(device_status_t))
        ext_ref_detect = device_status_t.operate_status_t.ext_ref_detect
        if ext_ref_detect == 1:
            return 'external'
        return 'internal'

    def _set_rf_mode(self, rf_mode: str) -> None:
        if rf_mode.lower() == 'single_tone':
            self.rf_mode_ = 0
        else:
            self.rf_mode_ = 1
        msg = self._dll.sc5520a_uhfsSetRfMode(self._handle, ctypes.c_int(self.rf_mode_))
        self._error_handler(msg)

    def _get_rf_mode(self) -> str:
        self._dll.sc5520a_uhfsFetchDeviceStatus(self._handle, ctypes.byref(device_status_t))
        rf_mode = device_status_t.operate_status_t.rf_mode
        if rf_mode == 0:
            return 'single_tone'
        return 'sweep'

    def get_idn(self) -> Dict[str, Optional[str]]:
        self._dll.sc5520a_uhfsFetchDeviceInfo(self._handle, ctypes.byref(device_info_t))

        return {'vendor':'SignalCore',
                'model':'SC5521A',
                'serial':device_info_t.product_serial_number,
                'firmware':device_info_t.firmware_revision,
                'hardware':device_info_t.hardware_revision,
                'manufacture_date':'20{}-{}-{} at {}h'.format(device_info_t.man_date.year, device_info_t.man_date.month, device_info_t.man_date.day, device_info_t.man_date.hour)}
"
102,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attAXR8c8ki57a3nQ'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/fNKOGo3rNtuaDJXhKDrRCg/QT8PP7mBZkVCHei3Vhtw_BzkCUzdf0DwqgqV4SJ9ZYP0cps70vcxEnvCR6Axq433idpbXB897BnfR4mF8zDd8x--dDMnnzGzsyj66HB3MYdDCroVPhNR8NeOqsJUzRS0/-4t2VVRfcRVvxbFVYk2YKYysquo27ml75jJJxVLZi_Y'), ('filename', 'vaunix-digital-attenuator-102.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PCvmt_rJHdeCSvD54j0tQw/WCNwcuWOvj9TfU_yUY8SrQ2_ePQKWG9kfpnZ9Qspu1cY08Uc6Lsubpzi_7X4evFHv0Np0BNaOhbs_wmS8LauEw/vckUDrXlfOgyG1Seh5d5v6OJBnfyZRsXXQED1DLpODE'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6dDhPwHovo8D2HwtIP84Jg/EP0Nd8-3ws_Sc2S8u6REAB1_YSnC1FWYv9ReDOtAEKs2y9afMRXqqFiaSneIYHnrFbNuvbfQ_YZNgcsMp_Fyfw/d0brUO5beK7v9EEfd4ANj3uxTmbezFnFVUasr8fZHAU'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vi9A8bv4Rv2AxlWhRbZcKA/p1FP_8ORI2q4-to4KC0BzMPFME5VvpnG_i4RHi4om2Keb7Z3_1SHqcKLOYywTxzkVs58riYJ9YzjI6TFPh0U-Q/fCDE2yydX8EGsucrpDEljKHIU0rwN_hDSQJd8P82Jng'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-102 Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +22 dBm, and offers frequency coverage of 10 to 1,000 MHz. It has an attenuation range of 63 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-102-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-102,Write a Python script that uses Qcodes Community to connect to a LDA-102 ,375.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
110,,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attBVqJPaw2ypiHZh'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cvBtInw-jEi2N54E9jizdw/5YVvco2DPE9xeyYkOTOmdwvrDfWK_uh0GRRZXJN5CtmzUgpSQa6l-AIFZumcgMLJK76VcrB1NsX7G_M6Ck5R2RLBGac9bgXHc_1ayUSAZ1o/Mbh-LzINo_eofjlkk1Zjdf4jJ0z4SA4jeEMPVCsZ7q0'), ('filename', '790-large_default.jpg'), ('size', 501113), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/u_KKhGimuizqyhx7ywhm2g/_WZD11mYVSBCM-0LAydt9ALfILf0GZlWhJ_HMzmKQw-oq54Zfss54iyWLK5fJ5FJzKXaWkAj_In_l-odjQXTWQ/EI5XMG4MPYf4WJbidFbc6Z-KjegryapXt1lFPHBXamM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/HPNtlwC1FMvU-TbR6hL2Fg/vZ1Zy_YSzRiB6tv3zyBV9MfMDMJWvlolarbWSgqE8dgo5B95m_QDJsDy3AIGMEZVjEfw8fAnkg5pjPH7A8sUVQ/203H5u72tSliiykJHrJtWO-y-c3id0-pGSGOpeOFAhc'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SleoejOnkg1t6iAM6INEkA/M6aElsQcq9a47LNPw8x9TldzfApBRqsPFSE7yIx4un4pWNWgzLCb4deDqwSAYLHcEIpUcHADdEF6VZYiub1q3Q/zvfcH3cy-bEJGO_De0PYMZA0zS4YnpblvM6kZeI23Kw'), ('width', 3000), ('height', 3000)]))]))])]",5.0,"Grosshandorf, Germany","The M4i.66xx-x8 series arbitrary waveform generators (AWG) deliver the highest performance in both speed and resolution. The series includes PCIe cards with either one, two or four synchronous channels. The large onboard memory can be segmented to replay different waveform sequences. The AWG features a PCI Express x8 Gen 2 interface that offers outstanding data streaming performance. The interface and Spectrum’s optimized drivers enable data transfer rates in excess of 2.8 GB/s so that signals can continuously replayed at a high output rate. While the cards have been designed using the latest technology they are still software compatible with the drivers from earlier Spectrum waveform generators. So, existing customers can use the same software they developed for a 10 year old 20 MS/s AWG card and for an M4i series 625 MS/s AWG.",https://spectrum-instrumentation.com/products/details/M4i6631-x8.php,M4I,516.0,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs."," Spectrum Instrumentation manufactures high-speed, high-resolution PC measurement equipment for the most demanding applications. 200+ products are available for your Perfect Fit Solution, combined with intuitive measurement software, support directly from the engineers and five years warranty. Spectrum products and solutions are used by leading companies and research institutes worldwide.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Spectrum/M4i.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/_modules/qcodes_contrib_drivers/drivers/Spectrum/M4i.html,Spectrum,"[OrderedDict([('id', 'attdNYSKAjAzfakev'), ('width', 480), ('height', 240), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xx-ZJ0ZCL2pgXIY-bq4ePA/bt59kvYCQAKf5_-K0OJrcHv8gZTeP25QvvKSmw2KRzeN8FPkFTQVPBIFjp_M40XhMUj_nO3GTWSrPbeyORk27FoSnufBuQA9wq6r9cjt_sGcBzkEKgnfPDkSKr1QKn38/cNH5xry1xixoJs4EfGDUk4dlMA9CN8SIpk5r3HoK4q0'), ('filename', '5aad02dc7610fb897c8df05d-480x480.png'), ('size', 11200), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XCc3Gw-fG_YMVkWsZO6yBQ/h6fEnmUhw2WCmp8uNLw88_q7rx1Wl95_ixLkEEI6AlF43X6lsvcCjqA5R2Jp6kgxbmpLjGVUrv-rLMnEE6Av0A/dzCzC2_xs4skjg2_O2A7XsBdt7mXLSVH-4NtunNPu6o'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BuA_RP5bO2_LfJQ0pi8kXg/KEGuaPLpgKn_q3AId1bpl1T-aUaf5qtJFtBCVTfG3Xwo0-M65fNJIWZgIf0ahftHdQU4ZIlfsR6PgKuSzmDZhA/B5-F3Nq_n8msMBBM4-PaduUaUXKOCdjE2ErokNxp4BY'), ('width', 480), ('height', 240)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sp0C84EPk6DHru_hYg-sEg/xmrTZBea54gDm59IDyQMPiaRP2dvRBFRgmz4lMOiwIzAidzymTIbNAP8YuOAwJ72H8Yqz20drqIny3muFRZ-wQ/-VRdqBA0t2MvkaZzmYZHaMszxnCjqKc73TsJduy9n_c'), ('width', 3000), ('height', 3000)]))]))])]",https://spectrum-instrumentation.com/,M4i.6631-x8,Write a Python script that uses Qcodes Community to connect to a M4i.6631-x8 Function Generators,,,,,"# **************************************************************************
#
# Driver file for M4i.44x-x8
#
# **************************************************************************
#
# QuTech
#
# Written by: Luka Bavdaz, Marco Tagliaferri, Pieter Eendebak
# Also see: http://spectrum-instrumentation.com/en/m4i-platform-overview
#

# %%
import os
import sys
import logging
import numpy as np
import ctypes as ct
from functools import partial
from typing import Union, Type

from qcodes.utils.validators import Enum, Numbers, Anything, Ints
from qcodes.instrument.base import Instrument

log = logging.getLogger(__name__)

try:
    # add the location of the pyspcm header file manually
    header_dir = os.path.split(__file__)[0]

    if not header_dir in sys.path:
        log.info('M4i: adding header_dir %s to sys.path' % header_dir)
        sys.path.append(header_dir)
    import pyspcm
    import py_header.spcerr
except (ImportError, OSError):
    info_str = 'to use the M4i driver install the pyspcm module and the M4i libs'
    log.exception(info_str)
    raise ImportError(info_str)

# %% Helper functions


def szTypeToName(lCardType):
    """""" Convert card type to string

    This function is taken from an example provided by Spectrum GmbH
    """"""
    sName = ''
    lVersion = (lCardType & pyspcm.TYP_VERSIONMASK)
    if (lCardType & pyspcm.TYP_SERIESMASK) == pyspcm.TYP_M2ISERIES:
        sName = 'M2i.%04x' % lVersion
    elif (lCardType & pyspcm.TYP_SERIESMASK) == pyspcm.TYP_M2IEXPSERIES:
        sName = 'M2i.%04x-Exp' % lVersion
    elif (lCardType & pyspcm.TYP_SERIESMASK) == pyspcm.TYP_M3ISERIES:
        sName = 'M3i.%04x' % lVersion
    elif (lCardType & pyspcm.TYP_SERIESMASK) == pyspcm.TYP_M3IEXPSERIES:
        sName = 'M3i.%04x-Exp' % lVersion
    elif (lCardType & pyspcm.TYP_SERIESMASK) == pyspcm.TYP_M4IEXPSERIES:
        sName = 'M4i.%04x-x8' % lVersion
    else:
        sName = 'unknown type'
    return sName

_errormsg_dict = {
        getattr(py_header.spcerr, name): name
        for name in dir(py_header.spcerr) if name.startswith('ERR_')
        }

# %% Main driver class


class M4i(Instrument):

    _NO_HF_MODE = -1

    def __init__(self, name, cardid='spcm0', **kwargs):
        """""" Driver for the Spectrum M4i.44xx-x8 cards.

        For more information see: http://spectrum-instrumentation.com/en/m4i-platform-overview

        Example:

            Example usage for acquisition with channel 2 using an external trigger
            that triggers multiple times with trigger mode HIGH::

                m4 = M4i(name='M4i', server_name=None)
                m4.enable_channels(pyspcm.CHANNEL2)
                m4.set_channel_settings(2,mV_range, input_path, termination, coupling, compensation)
                m4.set_ext0_OR_trigger_settings(pyspcm.SPC_TM_HIGH,termination,coupling,level0)
                calc = m4.multiple_trigger_acquisition(mV_range,memsize,seg_size,posttrigger_size)

        Note:
          Error generated by the card can be retrieved with the method :func:`get_error_info32bit`. The card can be
          reset with :func:`reset`.
          Sometimes when an error occurs (including validation errors) the python console needs to be restarted


        """"""
        super().__init__(name, **kwargs)

        self.hCard = pyspcm.spcm_hOpen(cardid)
        if self.hCard is None:
            logging.warning(""M4i: no card found\n"")

        self._last_set_result = 0

        # add parameters for getting
        self.add_parameter('card_id',
                           label='card id',
                           get_cmd=None, set_cmd=None,
                           initial_value=cardid,
                           vals=Anything(),
                           docstring='The card ID')
        self.add_parameter('max_sample_rate',
                           label='max sample rate',
                           unit='Hz',
                           get_cmd=self.get_max_sample_rate,
                           docstring='The maximumum sample rate')
        self.add_parameter('memory',
                           label='memory',
                           unit='bytes',
                           get_cmd=self.get_card_memory,
                           docstring='Amount of memory on card')
        self.add_parameter('resolution',
                           label='resolution',
                           unit='bits',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_MIINST_BITSPERSAMPLE),
                           docstring='Resolution of the card')
        self.add_parameter('pcidate',
                           label='pcidate',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_PCIDATE),
                           docstring='The PCI date')
        self.add_parameter('serial_number',
                           label='serial number',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_PCISERIALNO),
                           docstring='The serial number of the board')
        self.add_parameter('hardware_version',
                           label='hardware version',
                           get_cmd=self.get_hardware_version,
                           docstring='The hardware version of the board')
        self.add_parameter('firmware_version',
                           label='firmware version',
                           get_cmd=self.get_firmware_version,
                           docstring='The firmware version of the board')
        self.add_parameter('features',
                           label='features',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_PCIEXTFEATURES),
                           docstring='Installed options and features')
        self.add_parameter('channel_count',
                           label='channel count',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_CHCOUNT),
                           docstring='Return number of enabled channels')
        self.add_parameter('input_path_count',
                           label='input path count',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_READAIPATHCOUNT),
                           docstring='Return number of analog input paths')
        self.add_parameter('input_ranges_count',
                           label='input ranges count',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_READIRCOUNT),
                           docstring='Return number of input ranges for the current input path')
        self.add_parameter('input_path_features',
                           label='input path features',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_READAIFEATURES),
                           docstring='Return a bitmap of features for current input path')
        self.add_parameter('available_card_modes',
                           label='available card modes',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_AVAILCARDMODES),
                           docstring='Return a bitmap of available card modes')
        self.add_parameter('card_status',
                           label='card status',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_M2STATUS),
                           docstring='Return a bitmap for the status information')
        self.add_parameter('read_range_min_0',
                           label='read range min 0', unit='mV',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_READRANGEMIN0),
                           docstring='Return the lower border of input range 0')

        # buffer handling
        self.add_parameter('user_available_length',
                           label='user available length',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_DATA_AVAIL_USER_LEN),
                           docstring='returns the number of currently to the user available bytes inside a sample data transfer')
        self.add_parameter('user_available_position',
                           label='user available position',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_DATA_AVAIL_USER_POS),
                           docstring='returns the position as byte index where the currently available data samles start')
        self.add_parameter('buffer_fill_size',
                           label='buffer fill size',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_FILLSIZEPROMILLE),
                           docstring='returns the current fill size of the on-board memory (FIFO buffer) in promille (1/1000)')

        # triggering
        self.add_parameter('available_trigger_or_mask',
                           label='available trigger or mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_AVAILORMASK),
                           docstring='bitmask, in which all bits of sources for the OR mask are set, if available')
        self.add_parameter('available_channel_or_mask',
                           label='available channel or mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_CH_AVAILORMASK0),
                           docstring='bitmask, in which all bits of sources/channels (0-31) for the OR mask are set, if available')
        self.add_parameter('available_trigger_and_mask',
                           label='available trigger and mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_AVAILANDMASK),
                           docstring='bitmask, in which all bits of sources for the AND mask are set, if available')
        self.add_parameter('available_channel_and_mask',
                           label='available channel and mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_CH_AVAILANDMASK0),
                           docstring='bitmask, in which all bits of sources/channels (0-31) for the AND mask are set, if available')
        self.add_parameter('available_trigger_delay',
                           label='available trigger delay',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_AVAILDELAY),
                           docstring='contains the maximum available delay as decimal integer value')
        self.add_parameter('available_external_trigger_modes',
                           label='available external trigger modes',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT0_AVAILMODES),
                           docstring='bitmask showing all available trigger modes for external 0 (main analog trigger input)')
        self.add_parameter('external_trigger_min_level',
                           label='external trigger min level',
                           unit='mV',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT_AVAIL0_MIN),
                           docstring='returns the minimum trigger level')
        self.add_parameter('external_trigger_max_level',
                           label='external trigger max level',
                           unit='mV',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT_AVAIL0_MAX),
                           docstring='returns the maximum trigger level')
        self.add_parameter('external_trigger_level_step_size',
                           label='external trigger level step size',
                           unit='mV',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT_AVAIL0_STEP),
                           docstring='returns the step size of the trigger level')
        self.add_parameter('available_channel_trigger_modes',
                           label='available channel trigger modes',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_CH_AVAILMODES),
                           docstring='bitmask, in which all bits of the modes for the channel trigger are set')
        self.add_parameter('trigger_counter',
                           label='trigger counter',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIGGERCOUNTER),
                           docstring='returns the number of triger events since acquisition start')
        # data per sample
        self.add_parameter('bytes_per_sample',
                           label='bytes per sample',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_MIINST_BYTESPERSAMPLE),
                           docstring='returns the number of bytes per sample')
        self.add_parameter('bits_per_sample',
                           label='bits per sample',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_MIINST_BITSPERSAMPLE),
                           docstring='returns the number of bits per sample')

        # available clock modes
        self.add_parameter('available_clock_modes',
                           label='available clock modes',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_AVAILCLOCKMODES),
                           docstring='returns a bitmask in which the bits of the clock modes are set, if available')

        # converting ADC samples to voltage values
        self.add_parameter('ADC_to_voltage',
                           label='ADC to voltage',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_MIINST_MAXADCVALUE),
                           docstring='contains the decimal code (in LSB) of the ADC full scale value')

        self.add_parameter('box_averages',
                           label='number samples in box averaging',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_BOX_AVERAGES),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_BOX_AVERAGES),
                           vals=Enum(2, 4, 8, 16, 32, 64, 128, 256),
                           docstring='Defines the number of successive samples per channel that are summed together')

        self.add_parameter('oversampling_factor',
                           label='oversampling factor',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_OVERSAMPLINGFACTOR),
                           docstring='Reads the oversampling factor')

        # add parameters for setting and getting (read/write direction
        # registers)

        self.add_parameter('enable_channels',
                           label='Channels enabled',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_CHENABLE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_CHENABLE),
                           vals=Enum(1, 2, 4, 8, 3, 5, 9, 6, 10, 12, 15),
                           docstring='Set and get enabled channels')

        # analog input path functions
        # TODO: change Enum validator to set_parser for the numbered functions
        # if we want string inputs

        self.add_parameter('read_input_path',
                           label='read input path',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_READAIPATH),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_READAIPATH),
                           vals=Enum(0, 1, 2, 3),
                           docstring='Select the input path which is used to read out the features')

        for i in [0, 1, 2, 3]:
            self.add_parameter(f'input_path_{i}',
                               label=f'input path {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_PATH{i}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_PATH{i}')),
                               vals=Enum(0, 1),
                               docstring=f'Set and get analog input path for channel {i}')

            # channel range functions
            # TODO: check the input path to set the right validator (either by
            # directly calling input_path_x() or by storing a variable)
            self.add_parameter(f'range_channel_{i}',
                               label=f'range channel {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_AMP{i}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_AMP{i}')),
                               vals=Enum(200, 500, 1000, 2000,
                                         2500, 5000, 10000),
                               unit='mV',
                               docstring=f'Set and get input range of channel {i} (in mV)')

            # input termination functions
            self.add_parameter(f'termination_{i}',
                               label=f'termination {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_50OHM{i}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_50OHM{i}')),
                               vals=Enum(0, 1),
                               docstring=f'if 1 sets termination to 50 Ohm, otherwise 1 MOhm for channel {i}')

            # input coupling
            ACDC_coupling_docstring = f'if 1 sets the AC coupling, otherwise sets the DC coupling for channel {i}'
            ACDC_coupling_docstring += '\nThe AC coupling only works if the card is in HF mode.'
            self.add_parameter(f'ACDC_coupling_{i}',
                               label=f'ACDC coupling {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_ACDC{i}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_ACDC{i}')),
                               vals=Enum(0, 1),
                               docstring=ACDC_coupling_docstring)

            # AC/DC offset compensation
            self.add_parameter(f'ACDC_offs_compensation_{i}',
                               label=f'ACDC offs compensation {i}',
                               get_cmd=partial(self._get_compensation, i),
                               set_cmd=partial(self._set_compensation, i),
                               vals=Enum(0, 1, M4i._NO_HF_MODE),
                               docstring=(f'if 1 enables compensation, if 0 disables compensation for channel {i}. '
                                          'Value {M4i._NO_HF_MODE} means the card is not in HF mode'))

            # anti aliasing filter (Bandwidth limit)
            self.add_parameter(f'anti_aliasing_filter_{i}',
                               label=f'anti aliasing filter {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_FILTER{i}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_FILTER{i}')),
                               vals=Enum(0, 1),
                               docstring=f'if 1 selects bandwidth limit, if 0 sets to full bandwidth for channel {i}')

            self.add_parameter(f'channel_{i}',
                               label=f'channel {i}',
                               unit='a.u.',
                               get_cmd=partial(self._read_channel, i))

        # acquisition modes
        # TODO: If required, the other acquisition modes can be added to the
        # validator
        self.add_parameter('card_mode',
                           label='card mode',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_CARDMODE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_CARDMODE),
                           vals=Enum(pyspcm.SPC_REC_STD_SINGLE, pyspcm.SPC_REC_STD_MULTI,
                                     pyspcm.SPC_REC_STD_GATE, pyspcm.SPC_REC_STD_ABA,
                                     pyspcm.SPC_REC_FIFO_SINGLE, pyspcm.SPC_REC_FIFO_MULTI,
                                     pyspcm.SPC_REC_FIFO_GATE, pyspcm.SPC_REC_FIFO_ABA,
                                     pyspcm.SPC_REC_STD_AVERAGE, pyspcm.SPC_REC_STD_BOXCAR),
                           docstring='defines the used operating mode')

        # wait command
        self.add_parameter('timeout',
                           label='timeout',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TIMEOUT),
                           unit='ms',
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TIMEOUT),
                           docstring='defines the timeout for wait commands (in ms)')

        # Single acquisition mode memory, pre- and posttrigger (pretrigger = memory size - posttrigger)
        # TODO: improve the validators to make them take into account the
        # current state of the instrument
        self.add_parameter('data_memory_size',
                           label='data memory size',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_MEMSIZE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_MEMSIZE),
                           vals=Numbers(min_value=16),
                           docstring='sets the memory size in samples per channel')
        self.add_parameter('posttrigger_memory_size',
                           label='posttrigger memory size',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_POSTTRIGGER),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_POSTTRIGGER),
                           docstring='sets the number of samples to be recorded after trigger event')

        # FIFO single acquisition length and pretrigger
        self.add_parameter('pretrigger_memory_size',
                           label='pretrigger memory size',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_PRETRIGGER),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_PRETRIGGER),
                           docstring='sets the number of samples to be recorded before trigger event')
        self.add_parameter('segment_size',
                           label='segment size',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_SEGMENTSIZE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_SEGMENTSIZE),
                           docstring='length of segments to acquire')
        self.add_parameter('total_segments',
                           label='total segments',
                           get_cmd=partial(self._param32bit, pyspcm.SPC_LOOPS),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_LOOPS),
                           docstring='number of segments to acquire in total. Setting 0 makes it run until stopped by user')

        # clock generation
        self.add_parameter('clock_mode',
                           label='clock mode',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_CLOCKMODE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_CLOCKMODE),
                           vals=Enum(pyspcm.SPC_CM_INTPLL, pyspcm.SPC_CM_QUARTZ2,
                                     pyspcm.SPC_CM_EXTREFCLOCK, pyspcm.SPC_CM_PXIREFCLOCK),
                           docstring='defines the used clock mode or reads out the actual selected one')
        self.add_parameter('reference_clock',
                           label='frequency of external reference clock', unit='Hz',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_REFERENCECLOCK),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_REFERENCECLOCK),
                           vals=Ints(),
                           docstring='defines the frequency of the external reference clock')

        self.add_parameter('sample_rate',
                           label='sample rate',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_SAMPLERATE),
                           unit='Hz',
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_SAMPLERATE),
                           docstring='write the sample rate for internal sample generation or read rate nearest to desired. This sample rate is rounded to an integer number.')

        self.add_parameter('exact_sample_rate',
                           label='sample rate',
                           get_cmd=self._exact_sample_rate,
                           unit='Hz',
                           docstring='return the exact sampling rate in Hz. This is an integer divisor of the maximum sample rate')

        self.add_parameter('special_clock',
                           label='special clock',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_SPECIALCLOCK),
                           unit='Hz',
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_SPECIALCLOCK),
                           docstring='Activate/Deactivate the special clock mode (lower and more sampling clock rates)')

        # triggering
        self.add_parameter('trigger_or_mask',
                           label='trigger or mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_ORMASK),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_ORMASK),
                           vals=Enum(pyspcm.SPC_TMASK_NONE, pyspcm.SPC_TMASK_SOFTWARE,
                                     pyspcm.SPC_TMASK_EXT0, pyspcm.SPC_TMASK_EXT1),
                           docstring='defines the events included within the  trigger OR mask card')
        self.add_parameter('channel_or_mask',
                           label='channel or mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_CH_ORMASK0),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_CH_ORMASK0),
                           docstring='includes the channels (0-31) within the channel trigger OR mask of the card')
        self.add_parameter('trigger_and_mask',
                           label='trigger and mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_ANDMASK),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_ANDMASK),
                           vals=Enum(pyspcm.SPC_TMASK_NONE,
                                     pyspcm.SPC_TMASK_EXT0, pyspcm.SPC_TMASK_EXT1),
                           docstring='defines the events included within the  trigger AND mask card')
        self.add_parameter('channel_and_mask',
                           label='channel and mask',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_CH_ANDMASK0),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_CH_ANDMASK0),
                           docstring='includes the channels (0-31) within the channel trigger AND mask of the card')
        self.add_parameter('trigger_delay',
                           label='trigger delay',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_DELAY),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_DELAY),
                           docstring='defines the delay for the detected trigger events')
        self.add_parameter('external_trigger_mode',
                           label='external trigger mode',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT0_MODE),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_EXT0_MODE),
                           docstring='defines the external trigger mode for the external SMA connector trigger input')
        self.add_parameter('external_trigger_termination',
                           label='external trigger termination',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_TERM),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_TERM),
                           vals=Enum(0, 1),
                           docstring='A 1 sets the 50 Ohm termination, a 0 sets high impedance termination')
        self.add_parameter('external_trigger_input_coupling',
                           label='external trigger input coupling',
                           get_cmd=partial(self._param32bit,
                                           pyspcm.SPC_TRIG_EXT0_ACDC),
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_TRIG_EXT0_ACDC),
                           vals=Enum(0, 1),
                           docstring='A 1 sets the AC coupling for the external trigger, a 0 sets DC')

        for l in [0, 1]:
            self.add_parameter(f'external_trigger_level_{l}',
                               label=f'external trigger level {l}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_TRIG_EXT0_LEVEL{l}')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_TRIG_EXT0_LEVEL{l}')),
                               unit='mV',
                               docstring=f'trigger level {l} for external trigger')

        for i in [0, 1, 2, 3]:
            self.add_parameter(f'trigger_mode_channel_{i}',
                               label=f'trigger mode channel {i}',
                               get_cmd=partial(self._param32bit,
                                               getattr(pyspcm, f'SPC_TRIG_CH{i}_MODE')),
                               set_cmd=partial(self._set_param32bit,
                                               getattr(pyspcm, f'SPC_TRIG_CH{i}_MODE')),
                               docstring=f'sets the trigger mode for channel {i}')
            for l in [0, 1]:
                self.add_parameter(f'trigger_channel_{i}_level_{l}',
                                   label=f'trigger channel {i} level {l}',
                                   get_cmd=partial(self._param32bit,
                                                   getattr(pyspcm, f'SPC_TRIG_CH{i}_LEVEL{l}')),
                                   set_cmd=partial(self._set_param32bit,
                                                   getattr(pyspcm, f'SPC_TRIG_CH{i}_LEVEL{l}')),
                                   docstring=f'trigger level {l} channel {i}')

        # add parameters for setting (write only registers)

        # Buffer handling
        self.add_parameter('card_available_length',
                           label='card available length',
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_DATA_AVAIL_CARD_LEN),
                           docstring='writes the number of bytes that the card can now use for sample data transfer again')

        # General
        self.add_parameter('general_command',
                           label='general command',
                           set_cmd=partial(self._set_param32bit,
                                           pyspcm.SPC_M2CMD),
                           docstring='executes a command for the card or data transfer')

        # memsize used for simple channel read-out
        self._channel_memsize = 2**12

    # checks if requirements for the compensation get and set functions are met
    def _get_compensation(self, i):
        # if HF enabled
        if self.get(f'input_path_{i}') == 1:
            return self._param32bit(getattr(pyspcm, f'SPC_ACDC_OFFS_COMPENSATION{i}'))
        else:
            logging.info(""M4i: HF path not set, ACDC offset compensation parameter will be ignored by the M4i card\n"")
            return M4i._NO_HF_MODE

    def _set_compensation(self, i, value):
        # if HF enabled
        if self.get(f'input_path_{i}') == 1:
            self._set_param32bit(
                getattr(pyspcm, f'SPC_ACDC_OFFS_COMPENSATION{i}'), value)
        else:
            logging.warning(""M4i: HF path not set, ignoring ACDC offset compensation set\n"")

    def get_hardware_version(self):
        version_info = self._param32bit(pyspcm.SPC_PCIVERSION)
        return version_info >> 16

    def get_firmware_version(self):
        version_info = self._param32bit(pyspcm.SPC_PCIVERSION)
        return version_info & 0xFFFF

    def active_channels(self):
        """""" Return a list with the indices of the active channels """"""
        x = bin(self.enable_channels.cache())[2:][::-1]
        return [i for i in range(len(x)) if int(x[i])]

    def get_idn(self):
        return {
                'vendor': 'Spectrum_GMBH',
                'model': szTypeToName(self.get_card_type()),
                'serial': self.serial_number(),
                'firmware': self.firmware_version()
                }

    def reset(self):
        """""" Reset the card

        The pyspcm.M2CMD_CARD_RESET command is executed.
        """"""
        self.general_command(pyspcm.M2CMD_CARD_RESET)

    def convert_to_voltage(self, data, input_range):
        """"""convert an array of numbers to an array of voltages.""""""
        resolution = self.ADC_to_voltage.cache()
        return data * (input_range / resolution)

    def initialize_channels(self, channels=None, mV_range=1000, input_path=0,
                            termination=0, coupling=0, compensation=None,
                            memsize=2**12, pretrigger_memsize=16,
                            lp_filter=None):
        """""" Setup channels of the digitizer for simple readout using Parameters

        The channels can be read out using the Parameters `channel_0`,
        `channel_1`, ...

        Args:
            channels (list): list of channels to setup. mV_range, input_path,
                termination, coupling, compensation. Passed to the
                set_channel_settings function
            memsize (int): memory size to use for simple channel readout
            pretrigger_memsize (int): Pretrigger memory size to use.
                The default value used is 16, which is the smallest value
                possible.
        """"""
        allchannels = 0
        self._channel_memsize = memsize
        self._channel_pretrigger_memsize = pretrigger_memsize
        self.data_memory_size(memsize)
        if channels is None:
            channels = range(4)
        for ch in channels:
            self.set_channel_settings(ch, mV_range, input_path=input_path,
                                      termination=termination, coupling=coupling,
                                      compensation=compensation, lp_filter=lp_filter)
            allchannels = allchannels + getattr(pyspcm, 'CHANNEL%d' % ch)

        self.enable_channels(allchannels)

    def _channel_mask(self, channels=range(4)):
        """""" Return mask for specified channels

        Args:
            channels (list): list of channel indices
        Returns:
            cx (int): channel mask
        """"""
        cx = 0
        for c in channels:
            cx += getattr(pyspcm, f'CHANNEL{c}')
        return cx

    def _read_channel(self, channel, memsize=None):
        """""" Helper function to read out a channel

        Before a channel is measured all channels are enabled to ensure we can
        read out channels without the overhead of changing channels.
        """"""
        if memsize is None:
            memsize = self._channel_memsize
        posttrigger_size = memsize - self._channel_pretrigger_memsize
        mV_range = self.get(f'range_channel_{channel}')
        cx = self._channel_mask()
        self.enable_channels(cx)
        data = self.single_software_trigger_acquisition(
            mV_range, memsize, posttrigger_size)
        active = self.active_channels()
        data = data.reshape((-1, len(active)))
        value = np.mean(data[:, channel])
        return value

    def set_channel_settings(self, channel_index, mV_range, input_path,
                             termination, coupling, compensation=None,
                             lp_filter=None):
        """""" Update settings of the specified channel

        Args:
            channel_index (int): channel to update
            mV_range (float): measurement range for the channel
                (buffered path: 200, 500, 1000, 2000, 5000, or 10000)
                (HF path: 500, 1000, 2500, or 5000)
            input_path (int): input path (0: default/buffered; 1: HF/50 Ohm)
            termination (None or int): If None, then do not update the
                termination (0: 1 MOhm; 1: 50 Ohm)
            coupling (None or int): Set the ACDC_coupling.If None, then do not
                update the coupling (0: DC; 1 AC)
            compensation (None or int): If None, then do not update the
                compensation (0: off, 1: off)
            lp_filter (Optional[int]): enable (1) or disable (0) the 20 MHz low pass filter
        """"""
        # initialize
        self.set(f'input_path_{channel_index}', input_path)
        if termination is not None:
            self.set(f'termination_{channel_index}', termination)
        if coupling is not None:
            self.set(f'ACDC_coupling_{channel_index}', coupling)
        if lp_filter is not None:
            self.set(f'anti_aliasing_filter_{channel_index}', lp_filter)
        self.set(f'range_channel_{channel_index}', mV_range)  # note: set after voltage range
        # can only be used with DC coupling and 50 Ohm path (hf)
        if compensation is not None:
            self.set(f'ACDC_offs_compensation_{channel_index}', compensation)

    def set_ext0_OR_trigger_settings(self, trig_mode, termination, coupling, level0, level1=None):
        """""" Configures ext0 trigger

        Args:
            trig_mode: 0: None, 1: Positive edge, 2: Negative edge, 4: Both, 8: High, 16: Low,
                32: Enter window, 64: Leave window, 128: Inside window, 256: Outside window,
                0x01000001: Positive + re-arm, 0x01000002: Negative + re-arm
            termination: input termination 0: 1 MOhm, 1: 50 Ohm
            coupling: DC/AC input coupling (0: DC, 1: AC)
            level0: trigger level [mV]
            level1: 2nd level for re-arm and windowed modes. [mV]
        """"""
        self.channel_or_mask(0)
        self.external_trigger_mode(trig_mode)
        self.trigger_or_mask(pyspcm.SPC_TMASK_EXT0)
        self.external_trigger_termination(termination)
        self.external_trigger_input_coupling(coupling)
        self.external_trigger_level_0(level0)
        if(level1 != None):
            self.external_trigger_level_1(level1)

    # Note: the levels need to be set in bits, not voltages! (between -8191 to
    # 8191 for 14 bits)
    def set_channel_OR_trigger_settings(self, i, trig_mode, bitlevel0, bitlevel1=None):
        """"""When a channel is used for triggering it must be enabled during the
        acquisition.""""""
        self.trigger_or_mask(0)
        self.channel_or_mask(getattr(pyspcm, f'SPC_TMASK0_CH{i}'))
        self.set(f'trigger_channel_{i}_level_0', bitlevel0)
        if(bitlevel1 != None):
            self.set(f'trigger_channel_{i}_level_1', bitlevel1)
        self.set(f'trigger_mode_channel_{i}', trig_mode)  # trigger mode

    def setup_multi_recording(self, posttrigger_size, n_triggers=1,
                              pretrigger_size=None, boxcar_average=False):
        """""" Setup multi recording.

        Triggering must have been configured separately.
        Data acquisition must started with start_triggered().
        The collected data can be acquired with the function get_data().

        Args:
            posttrigger_size (int): size of data trace after triggering
            n_triggers (int): total number of triggers
            pretrigger_size (int): size of data trace before triggering
            boxcar_average (bool): use mode 'boxcar average'

        Example:
            digitizer.setup_multi_recording(size, n_triggers)
            digitizer.start_triggered()
            data = digitizer.get_data()
            # do another measurement with same settings
            digitizer.start_triggered()
            data = digitizer.get_data()

        """"""
        if boxcar_average:
            if self.oversampling_factor() != 1:
                raise Exception('Averaging with BOXCAR can only be used with '
                                'maximum sample rate')
            self.card_mode(pyspcm.SPC_REC_STD_BOXCAR)
        else:
            self.card_mode(pyspcm.SPC_REC_STD_MULTI)

        if not pretrigger_size:
            pretrigger_size = self.pretrigger_memory_size()
        posttrigger_size = self._hw_memsize(posttrigger_size)
        seg_size = self._hw_memsize(posttrigger_size+pretrigger_size)
        memsize = self._hw_memsize(n_triggers * seg_size)
        self.data_memory_size(memsize)
        self.segment_size(seg_size)
        self.posttrigger_memory_size(posttrigger_size)

    def start_triggered(self):
        """""" Starts triggered acquisition
        """"""
        self.general_command(pyspcm.M2CMD_CARD_START
                             | pyspcm.M2CMD_CARD_ENABLETRIGGER)

    def get_data(self):
        """""" Reads measurement data from the digitizer.

        The data acquisition must have been started by start_acquisition() or
        start_triggered().

        Returns:
            2D array with voltages per channel in V.
        """"""
        active_channels = self.active_channels()
        memsize = self.data_memory_size.cache()
        numch = len(active_channels)

        res = self.wait_ready()
        if res == pyspcm.ERR_TIMEOUT:
            logging.error(f'Timeout waiting for data (timeout: {self.timeout()} ms)')
        elif res != pyspcm.ERR_OK:
            raise Exception(f'Error waiting for data: (0x{res:04x})')

        try:
            if self.card_mode() == pyspcm.SPC_REC_STD_BOXCAR:
                box_averages = self.box_averages()
                raw_data = self._transfer_buffer_numpy(memsize, numch, bytes_per_sample=4)
            else:
                box_averages = 1
                raw_data = self._transfer_buffer_numpy(memsize, numch)
        finally:
            self._stop_acquisition()

        resolution = self.ADC_to_voltage.cache()
        voltages = np.zeros((numch, len(raw_data)//numch))
        for i,ch in enumerate(active_channels):
            mV_range = self.get(f'range_channel_{ch}')
            voltages[i,:] = raw_data[i::numch] * (mV_range / 1000 / resolution / box_averages)
        return voltages


    def _stop_acquisition(self):

        # close acquisition
        self.general_command(pyspcm.M2CMD_DATA_STOPDMA)

        # invalidate buffer
        self._invalidate_buf(pyspcm.SPCM_BUF_DATA)

        self.general_command(pyspcm.M2CMD_CARD_STOP)

    # TODO: if multiple channels are used at the same time, the voltage conversion needs to be updated
    # TODO: the data also needs to be organized nicely (currently it
    # interleaves the data)
    def multiple_trigger_acquisition(self, mV_range, memsize, seg_size, posttrigger_size):
        """""" Acquire traces with the SPC_REC_STD_MULTI mode

        This method does not update the triggering properties.

        Args:
            mV_range (float): Input range used for coversion to voltage
            memsize (int): Size of total buffer to acquire
            seg_size (int): Size of segments to record
            posttrigger_size (int): Size of the if post trigger buffer
        Returns:
            Array with measured voltages

        """"""
        self.card_mode(pyspcm.SPC_REC_STD_MULTI)  # multi

        self.data_memory_size(memsize)
        self.segment_size(seg_size)
        self.posttrigger_memory_size(posttrigger_size)
        numch = self._num_channels()

        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER)
        self.wait_ready()

        # convert transfer data to numpy array
        try:
            output = self._transfer_buffer_numpy(memsize, numch, bytes_per_sample=2)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def start_acquisition(self, mV_range, memsize, posttrigger_size=None, verbose=0):
        """""" Start data acquisition of a single data trace

        The resulting data can be acquired with the function retrieve_data.

        Args:
            mV_range (float): range in mV
            memsize (int): size of data trace
            posttrigger_size (int or None): size of data trace after triggering
        Returns:
            trace as a dict. Data concerning the trace
        """"""
        self.card_mode(pyspcm.SPC_REC_STD_SINGLE)  # single

        self.data_memory_size(memsize)
        if posttrigger_size is None:
            posttrigger_size = memsize - 16
        self.posttrigger_memory_size(posttrigger_size)
        numch = self._num_channels()

        # start/enable trigger/wait ready
        self.trigger_or_mask(pyspcm.SPC_TMASK_SOFTWARE)  # software trigger
        self.general_command(pyspcm.M2CMD_CARD_START |
                             pyspcm.M2CMD_CARD_ENABLETRIGGER)

        return {'memsize': memsize, 'numch': numch, 'mV_range': mV_range}

    def _transfer_buffer_numpy(self, memsize: int, numch: int, bytes_per_sample=2) -> np.ndarray:
        """""" Transfer buffer to numpy array

        Args:
            memsize (int): number of samples to transfer
            numch (int): number of channels
            bytes_per_sample (int): specifies the datatype. 2 for int16, 4 for int32
        Returns:
            array: transfered data

        """"""
        # setup software buffer
        sample_ctype: Union[Type[ct.c_int16], Type[ct.c_int32]]
        if bytes_per_sample == 2:
            sample_ctype = ct.c_int16
        elif bytes_per_sample == 4:
            sample_ctype = ct.c_int32
        else:
            raise ValueError('bytes_per_sample should be 2 or 4')

        ctype_buffer_type = sample_ctype * memsize * numch
        data_buffer = (ctype_buffer_type)()
        data_pointer = ct.cast(data_buffer, ct.c_void_p)

        # data acquisition
        self._def_transfer64bit(
            pyspcm.SPCM_BUF_DATA, pyspcm.SPCM_DIR_CARDTOPC, 0, data_pointer, 0, bytes_per_sample * memsize * numch)
        self.general_command(pyspcm.M2CMD_DATA_STARTDMA | pyspcm.M2CMD_DATA_WAITDMA)
        if self._last_set_result != pyspcm.ERR_OK:
            res = self._last_set_result
            raise Exception(f'Error transferring data: {_errormsg_dict[res]} (0x{res:04x})')

        # convert buffer to numpy array
        # this does not typecheck with numpy 1.22 should be updated
        # by someone with access to test on the real data.
        output = np.frombuffer(data_buffer, dtype=sample_ctype) # type: ignore[call-overload]

        return output

    def retrieve_data(self, trace):
        """""" Retrieve data from the digitizer

        The data acquisition must have been started by start_acquisition.

        Args:
            trace (dict): dictionary with acquisition settings.

        Returns:
            voltages (array)
        """"""
        memsize = trace['memsize']
        numch = trace['numch']
        mV_range = trace['mV_range']

        self.wait_ready()
        try:
            output = self._transfer_buffer_numpy(memsize, numch)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def single_trigger_acquisition(self, mV_range, memsize, posttrigger_size):
        """""" Acquire traces with the SPC_REC_STD_SINGLE mode

        This method does not update the triggering properties.

        Args:
            mV_range (float): Input range used for coversion to voltage
            memsize (int): Size of total buffer to acquire
            posttrigger_size (int): Size of the if post trigger buffer
        Returns:
            Array with measured voltages
        """"""
        self.card_mode(pyspcm.SPC_REC_STD_SINGLE)

        # set memsize and posttrigger
        self.data_memory_size(memsize)
        self.posttrigger_memory_size(posttrigger_size)
        numch = self._num_channels()

        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER)
        self.wait_ready()

        try:
            output = self._transfer_buffer_numpy(memsize, numch)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def gated_trigger_acquisition(self, mV_range, memsize, pretrigger_size, posttrigger_size):
        """"""doesn't work completely as expected, it triggers even when the
        trigger level is set outside of the signal range it also seems to
        additionally acquire some wrong parts of the wave, but this also exists
        in SBench6, so it is not a problem caused by this code.""""""

        self.card_mode(pyspcm.SPC_REC_STD_GATE)  # gated

        # set memsize and posttrigger
        self.data_memory_size(memsize)
        self.pretrigger_memory_size(pretrigger_size)
        self.posttrigger_memory_size(posttrigger_size)
        numch = self._num_channels()

        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER )
        self.wait_ready()

        try:
            output = self._transfer_buffer_numpy(memsize, numch)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def single_software_trigger_acquisition_boxcar(self, mV_range, memsize, posttrigger_size):
        """""" Acquire a single data trace with boxcar averaging

        Args:
            mV_range (float): range in mV
            memsize (int): size of data trace
            posttrigger_size (int): size of data trace after triggering
        Returns:
            voltages (array)
        """"""
        self.card_mode(pyspcm.SPC_REC_STD_BOXCAR)  # single

        self.segment_size(memsize)
        self.posttrigger_memory_size(posttrigger_size)
        self.data_memory_size(memsize * self.box_averages())
        numch = self._num_channels()

        self.trigger_or_mask(pyspcm.SPC_TMASK_SOFTWARE)
        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER)
        self.wait_ready()

        try:
            output = self._transfer_buffer_numpy(memsize, numch, bytes_per_sample=4)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(
            output, mV_range / 1000) / self.box_averages()

        return voltages

    def single_software_trigger_acquisition(self, mV_range, memsize, posttrigger_size):
        """""" Acquire a single data trace

        Args:
            mV_range (float): range in mV
            memsize (int): size of data trace
            posttrigger_size (int): size of data trace after triggering
        Returns:
            voltages (array)
        """"""
        self.card_mode(pyspcm.SPC_REC_STD_SINGLE)  # single

        self.data_memory_size(memsize)
        self.posttrigger_memory_size(posttrigger_size)
        numch = self._num_channels()

        # start/enable trigger/wait ready
        self.trigger_or_mask(pyspcm.SPC_TMASK_SOFTWARE)  # software trigger
        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER)
        self.wait_ready()

        try:
            output = self._transfer_buffer_numpy(memsize, numch)
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def _check_buffers(self):
        """""" Check validity of buffers

        See: manual section ""Limits of pre trigger, post trigger, memory size""
        """"""

        pretrigger = self.data_memory_size() - self.posttrigger_memory_size()
        if pretrigger > 2**13:
            raise Exception('value of SPC_PRETRIGGER is invalid')

    def _num_channels(self):
        """""" Return number of channels that is enabled """"""
        return bin(self.enable_channels()).count(""1"")

    def wait_ready(self) -> int:
        """"""  Wait for the M4i card to be ready using M2CMD_CARD_WAITREADY
        Returns:
               Return code of the M4i general command used to wait for the card to be ready
        """"""
        command_result = pyspcm.spcm_dwSetParam_i32(self.hCard, pyspcm.SPC_M2CMD, int(pyspcm.M2CMD_CARD_WAITREADY))
        return command_result

    def blockavg_hardware_trigger_acquisition(self, mV_range, nr_averages=10,
                                              verbose=0, post_trigger=None):
        """""" Acquire data using block averaging and hardware triggering

        To read out multiple channels, use `initialize_channels`. This methods updates
        the external_trigger_mode and trigger_or_mask parameters.

        Args:
            mV_range (float)
            nr_averages (int): number of averages to take
            verbose (int): output level
            post_trigger (None or int): optional size of post_trigger buffer
        Returns:
            An array of voltages. If multiple channels are read,
            then the data is interleaved
        """"""
        # self.available_card_modes()
        memsize = self.data_memory_size()
        self.segment_size(memsize)

        if post_trigger is None:
            pre_trigger = min(2**13, 16 * int((memsize / 2) // 16))
            post_trigger = memsize - pre_trigger
        else:
            pre_trigger = memsize - post_trigger
        self.posttrigger_memory_size(post_trigger)
        self.pretrigger_memory_size(pre_trigger)

        self._check_buffers()

        if verbose:
            print('blockavg_hardware_trigger_acquisition: errors %s' %
                  (self.get_error_info32bit(), ))
            print('blockavg_hardware_trigger_acquisition: card_status %s' %
                  (self.card_status(), ))

        if nr_averages == 1:
            # special case since SPC_AVERAGES cannot handle 1
            if verbose:
                print(
                    'blockavg_hardware_trigger_acquisition: pass to single_trigger_acquisition')
            return self.single_trigger_acquisition(mV_range=mV_range, memsize=memsize, posttrigger_size=post_trigger)

        self.card_mode(pyspcm.SPC_REC_STD_AVERAGE)
        self._set_param32bit(pyspcm.SPC_AVERAGES, nr_averages)
        numch = self._num_channels()

        self.external_trigger_mode(pyspcm.SPC_TM_POS)
        self.trigger_or_mask(pyspcm.SPC_TMASK_EXT0)
        self.general_command(pyspcm.M2CMD_CARD_START | pyspcm.M2CMD_CARD_ENABLETRIGGER)
        self.wait_ready()

        try:
            output = self._transfer_buffer_numpy(memsize, numch, bytes_per_sample=4) / nr_averages
        finally:
            self._stop_acquisition()

        voltages = self.convert_to_voltage(output, mV_range / 1000)

        return voltages

    def close(self):
        """"""Close handle to the card.""""""
        if self.hCard is not None:
            pyspcm.spcm_vClose(self.hCard)
            self.hCard = None
        super().close()

    def get_card_type(self, verbose=0):
        """"""Read card type.""""""
        # read type, function and sn and check for D/A card
        lCardType = pyspcm.int32(0)
        pyspcm.spcm_dwGetParam_i32(
            self.hCard, pyspcm.SPC_PCITYP, pyspcm.byref(lCardType))
        if verbose:
            print('card_type: %s' % szTypeToName(lCardType.value))
        return (lCardType.value)

    # only works if the error was not caused by running the entire program
    # (and therefore making a new M4i object)
    def get_error_info32bit(self, verbose=False):
        """"""Read an error from the error register.

        Args:
            verbose (bool): If True then print the error message to stdout
        Returns:
            errorreg (int)
            errorvalue (int)
        """"""
        dwErrorReg = pyspcm.uint32(0)
        lErrorValue = pyspcm.int32(0)

        if verbose:
            buffer = (ct.c_uint8 * pyspcm.ERRORTEXTLEN)()
            pyspcm.spcm_dwGetErrorInfo_i32(self.hCard, pyspcm.byref(
                dwErrorReg), pyspcm.byref(lErrorValue), buffer)
            bb = (bytearray(buffer)).decode().strip('\x00')
            print('get_error_info32bit: %d %d: %s' %
                  (dwErrorReg.value, lErrorValue.value, bb))
        else:
            pyspcm.spcm_dwGetErrorInfo_i32(self.hCard, pyspcm.byref(
                dwErrorReg), pyspcm.byref(lErrorValue), None)
        return (dwErrorReg.value, lErrorValue.value)

    def _param64bit(self, param):
        """"""Read a 64-bit parameter from the device.""""""
        data = pyspcm.int64(0)
        pyspcm.spcm_dwGetParam_i64(self.hCard, param, pyspcm.byref(data))
        return (data.value)

    def _param32bit(self, param):
        """"""Read a 32-bit parameter from the device.""""""
        data = pyspcm.int32(0)
        pyspcm.spcm_dwGetParam_i32(self.hCard, param, pyspcm.byref(data))
        return (data.value)

    def _set_param32bit(self, param, value):
        """""" Set a 32-bit parameter on the device.""""""
        value = int(value)  # convert floating point to int if necessary
        res = pyspcm.spcm_dwSetParam_i32(self.hCard, param, value)
        self._last_set_result = res
        if res == pyspcm.ERR_TIMEOUT:
            logging.warning('SetParam timeout')
        elif res != pyspcm.ERR_OK:
            raise Exception(f'SetParam failed. param:0x{param:08X} value:0x{value:08X}: '
                            f'result: {_errormsg_dict[res]} (0x{res:08X})')

    def _invalidate_buf(self, buf_type):
        """"""Invalidate device buffer.""""""
        pyspcm.spcm_dwInvalidateBuf(self.hCard, buf_type)

    def _def_transfer64bit(self, buffer_type, direction, bytes_till_event, data_pointer, offset, buffer_length):
        """"""Define a 64-bit transer between the device and the computer.""""""
        pyspcm.spcm_dwDefTransfer_i64(
            self.hCard, buffer_type, direction, bytes_till_event, data_pointer, offset, buffer_length)

    def _exact_sample_rate(self):
        """""" Return exact sampling rate as a floating point number """"""
        sample_rate_hz = self.sample_rate()
        max_sample_rate = self.get_max_sample_rate()
        factor = int(np.round(max_sample_rate/sample_rate_hz))
        return max_sample_rate/factor

    def get_max_sample_rate(self, verbose=0):
        """"""Return max sample rate.""""""
        # read type, function and sn and check for D/A card
        value = self._param32bit(pyspcm.SPC_PCISAMPLERATE)
        if verbose:
            print('max_sample_rate: %s' % (value))
        return value

    def get_card_memory(self, verbose=0):
        data = pyspcm.int64(0)
        pyspcm.spcm_dwGetParam_i64(
            self.hCard, pyspcm.SPC_PCIMEMSIZE, pyspcm.byref(data))
        if verbose:
            print('card_memory: %s' % (data.value))
        return (data.value)

    def _hw_memsize(self, size):
        return (size + 15) // 16 * 16
"
112,https://coppermountaintech.com/m-series-data-sheet/,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attegotigtZ5pNULK'), ('width', 450), ('height', 350), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qNUeFcty7mXW95EIGNuf3A/GMa84j3YqBA5bhJFDWMViCQ5KXOUzTQSQPJBWIwQAgQAZf6E_TpS2Rwv1QXxMatWPcl3aBU_Nf70LQn2hslbcpioBRPxQk9v6sQOYUxBHXM/4W5doWjHYcPDYWZIIosCxF4ucQmx7ybg1f6n--ycEtU'), ('filename', 'M5180-left-450x350.png'), ('size', 86498), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/nVww3XrXVTEhe2dlCKuUXA/jv7YVDHCtDExrvFDxvQ_lcn0j4q30JCv9UtNNp4tCO2nI0R0GO1RNNw2FxpiqwVRiVnqtXVqJTZ12VjOqnQXNA/llt6v6L5x6pM_AYsVTHwUpRuuER__V972QIpfaPb-FM'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1R6Ez9TyOLsl0Z_IX_5a8A/qJ3rWCvnh76OrUVjhxh0vEVBV6QSuf9-PrFZNF_lj4-tTj6eyGfbwF4cJPCw5FEgbj7Ugv4sNJH8vb7298oQcg/hqHC8ualk-XkNOz4ca_HUd-ztKgqQ_8iWKdJobFCtMU'), ('width', 450), ('height', 350)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KHQYyNNkp6pSxwn9DNhiKA/5dIWpDNXGawyOnlJCjp5_Q_70yg_51boaAnFmSkUHBnmzAcP_hUwwLNJhc7UCVUf1PnLAv-GtvKH5UdnjXGlSA/ZQdGqtpTLV_i_qlh_DNsZrsoCdhHUpKDuZE116mXNoo'), ('width', 3000), ('height', 3000)]))]))])]",301.0,US,"
The M5180 is a 2-port, 18 GHz Vector Network Analyzer that delivers metrology-grade performance in a more economical package that excludes a number of advanced features",https://coppermountaintech.com/vna/m5180-2-port-18-ghz-analyzer/,M 5180,112.0,['Network Analyzer'],"A vector network analyzer achieves highly accurate measurements by correcting for the systematic errors in the instrument, the characteristics of cables, adapters and test fixtures","**Copper Mountain Technologies** develops innovative RF test and measurement solutions for engineers worldwide that enable engineers to extend their reach.

",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/CopperMountain/M5180.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.CopperMountain.html#module-qcodes_contrib_drivers.drivers.CopperMountain.M5180,Coppermountain,"[OrderedDict([('id', 'atthotVCDq0T4DOTa'), ('width', 1637), ('height', 1279), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Kqn3QsYiwkmYnTP1w6P2ew/dBXIvxdluKvssYIqH2UYKTzzt0O62xjKV752z531FBXL2v5fkbC1hVa5p-F0w78VZEmDtjAs8fYlMFqH5MePt1fg_pqTNFNs3KmJt-ZEtZE/BxNvPMh17ZyQATFobz2Y5SYWhz5ZitD9xyTlBeUxdBo'), ('filename', 'LOGO.webp'), ('size', 59418), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NV5TMyN3ZPi4Im7fC33VsQ/WSiAsBTLn2XM2MgYVvGSV1KfTwN6IomsWA8zjvFykOCdTBwc9TVprUhFI-KNbmFqOaXqO0DxnLuR6iv5NQalVEAEjjlB-s46Afh-anLXNqU/7yzwIZ8MwvkauYyXrAbG0B8lCeZvtXWL60kMoTdsis4'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hBvx_AHugUIWmK4JqSmIYA/tuCbiuumzr7GAVhFtDe8kWbPL1Hc2FEHCRXYJZEC2SP0RBvYfFpSU8ZlDqKKaUaK_uJetZ177eyC2JTd_wpmvw-aiAPf3k5uaFbIN6HSg_M/ic-7RCjjC9lN63WmPQY4pl9mRxJT-bxQXFcU2xNxQ4E'), ('width', 655), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6wojSJxiEGgMgc5YsRX94g/lnkaCG9rutL5VDazeGOzFrZ_yidEVZRdElaKnM6tsqEI3cIDErRMrE3pWu5ydkEkcee2N1clOdsEyxEE8KfVr6mxz01G0QlHxA_NFVlKQGg/PDCc-UCqVubEBxTrZixWYtMaj12wWwKBRBRr0N9Voeg'), ('width', 3000), ('height', 3000)]))]))])]",https://coppermountaintech.com/,M5180 2-Port 18 GHz Analyzer,Write a Python script that uses Qcodes Community to connect to a M5180 2-Port 18 GHz Analyzer Network Analyzer,,,,,"# This Python file uses the following encoding: utf-8
# Etienne Dumur <etienne.dumur@gmail.com>, august 2020
# Simon Zihlmannr <zihlmann.simon@gmail.com>, february/march 2021
import logging
import numpy as np
import cmath, math
from typing import Tuple, Any

from qcodes import VisaInstrument
from qcodes.utils.validators import Numbers, Enum, Ints, Bool
from qcodes.utils.helpers import create_on_off_val_mapping

from qcodes.instrument.parameter import (
    MultiParameter,
    ManualParameter,
    ParamRawDataType
)

log = logging.getLogger(__name__)

class FrequencySweepMagPhase(MultiParameter):
    """"""
    Sweep that returns magnitude and phase.
    """"""

    def __init__(self,
        name: str,
        start: float,
        stop: float,
        npts: int,
        instrument: ""M5180"",
        **kwargs: Any,
        ) -> None:
        """"""
        Linear frequency sweep that returns magnitude and phase for a single
        trace.

        Args:
            name (str): Name of the linear frequency sweep
            start (float): Start frequency of linear sweep
            stop (float): Stop frequency of linear sweep
            npts (int): Number of points of linear sweep
            instrument: Instrument to which sweep is bound to.
        """"""
        super().__init__(
            name,
            instrument=instrument,
            names=(
                f""{instrument.short_name}_{name}_magnitude"",
                f""{instrument.short_name}_{name}_phase""),
            labels=(
                f""{instrument.short_name} {name} magnitude"",
                f""{instrument.short_name} {name} phase"",
            ),
            units=(""dB"", ""rad""),
            setpoint_units=((""Hz"",), (""Hz"",)),
            setpoint_labels=(
                (f""{instrument.short_name} frequency"",),
                (f""{instrument.short_name} frequency"",),
            ),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        """"""Updates the setpoints and shapes based on start, stop and npts.

        Args:
            start (float): start frequency
            stop (float): stop frequency
            npts (int): number of points
        """"""
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> Tuple[ParamRawDataType, ParamRawDataType]:
        """"""Gets data from instrument

        Returns:
            Tuple[ParamRawDataType, ...]: magnitude, phase
        """"""
        assert isinstance(self.instrument, M5180)
        self.instrument.write('CALC1:PAR:COUN 1') # 1 trace
        self.instrument.write('CALC1:PAR1:DEF {}'.format(self.name))
        self.instrument.trigger_source('bus') # set the trigger to bus
        self.instrument.write('TRIG:SEQ:SING') # Trigger a single sweep
        self.instrument.ask('*OPC?') # Wait for measurement to complete

        # get data from instrument
        self.instrument.write('CALC1:TRAC1:FORM SMITH')  # ensure correct format
        sxx_raw = self.instrument.ask(""CALC1:TRAC1:DATA:FDAT?"")
        self.instrument.write('CALC1:TRAC1:FORM MLOG')

        # Get data as numpy array
        sxx = np.fromstring(sxx_raw, dtype=float, sep=',')
        sxx = sxx[0::2] + 1j*sxx[1::2]

        return self.instrument._db(sxx), np.unwrap(np.angle(sxx))


class PointMagPhase(MultiParameter):
    """"""
    Returns the average Sxx of a frequency sweep.
    Work around for a CW mode where only one point is read.
    npts=2 and stop = start + 1 (in Hz) is required.
    """"""

    def __init__(self,
        name: str,
        instrument: ""M5180"",
        **kwargs: Any,
        ) -> None:
        """"""Magnitude and phase measurement of a single point at start
        frequency.

        Args:
            name (str): Name of point measurement
            instrument:  Instrument to which parameter is bound to.
        """"""

        super().__init__(
            name,
            instrument=instrument,
            names=(
                f""{instrument.short_name}_{name}_magnitude"",
                f""{instrument.short_name}_{name}_phase""),
            labels=(
                f""{instrument.short_name} {name} magnitude"",
                f""{instrument.short_name} {name} phase"",
            ),
            units=(""dB"", ""rad""),
            setpoints=((), (),),
            shapes=((), (),),
            **kwargs,
        )

    def get_raw(self) -> Tuple[ParamRawDataType, ParamRawDataType]:
        """"""Gets data from instrument

        Returns:
            Tuple[ParamRawDataType, ...]: magnitude, phase
        """"""

        assert isinstance(self.instrument, M5180)
        # check that npts, start and stop fullfill requirements if point_check_sweep_first is True.
        if self.instrument.point_check_sweep_first:
            if self.instrument.npts() != 2:
                raise ValueError('Npts is not 2 but {}. Please set it to 2'.format(self.instrument.npts()))
            if self.instrument.stop() - self.instrument.start() != 1:
                raise ValueError('Stop-start is not 1 Hz but {} Hz. Please adjust'
                                'start or stop.'.format(self.instrument.stop()-self.instrument.start()))

        self.instrument.write('CALC1:PAR:COUN 1') # 1 trace
        self.instrument.write('CALC1:PAR1:DEF {}'.format(self.name[-3:]))
        self.instrument.trigger_source('bus') # set the trigger to bus
        self.instrument.write('TRIG:SEQ:SING') # Trigger a single sweep
        self.instrument.ask('*OPC?') # Wait for measurement to complete

        # get data from instrument
        self.instrument.write('CALC1:TRAC1:FORM SMITH')  # ensure correct format
        sxx_raw = self.instrument.ask(""CALC1:TRAC1:DATA:FDAT?"")

        # Get data as numpy array
        sxx = np.fromstring(sxx_raw, dtype=float, sep=',')
        sxx = sxx[0::2] + 1j*sxx[1::2]

        # Return the average of the trace, which will have ""start"" as
        # its setpoint
        sxx_mean = np.mean(sxx)
        return 20*math.log10(abs(sxx_mean)), cmath.phase(sxx_mean)


class M5180(VisaInstrument):
    """"""
    This is the QCoDeS python driver for the VNA M5180 from Copper Mountain
    """"""

    def __init__(self, name       : str,
                       address    : str,
                       terminator : str=""\n"",
                       timeout    : int=100000,
                       **kwargs):
        """"""
        QCoDeS driver for the VNA M5180 from Copper Mountain.
        This driver only uses one channel.

        Args:
            name (str): Name of the instrument.
            address (str): Address of the instrument.
            terminator (str): Terminator character of
                the string reply. Optional, default ``""\\n""``
            timeout (int): VISA timeout is set purposely
                to a long time to allow long spectrum measurement.
                Optional, default 100000
        """"""

        super().__init__(name       = name,
                         address    = address,
                         terminator = terminator,
                         timeout    = timeout,
                         **kwargs)

        self.add_function('reset', call_cmd='*RST')

        # set the unit of the electrical distance to meter
        self.write('CALC1:CORR:EDEL:DIST:UNIT MET')

        self.add_parameter(name='output',
                           label='Output',
                           get_parser=str,
                           get_cmd='OUTP:STAT?',
                           set_cmd='OUTP:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))

        self.add_parameter(name='power',
                           label='Power',
                           get_parser=float,
                           get_cmd='SOUR:POW?',
                           set_cmd='SOUR:POW {}',
                           unit='dBm',
                           vals=Numbers(min_value=-50,
                                        max_value=10))

        self.add_parameter(name='if_bandwidth',
                           label='IF Bandwidth',
                           get_parser=float,
                           get_cmd='SENS1:BWID?',
                           set_cmd='SENS1:BWID {}',
                           unit='Hz',
                           vals=Enum(*np.append(np.kron([1, 1.5, 2, 3, 5, 7],
                                                       10 ** np.arange(5)),
                                               np.kron([1, 1.5, 2, 3], 10 ** 5)
                                               )))

        self.add_parameter('averages_enabled',
                           label='Averages Status',
                           get_cmd='SENS1:AVER:STAT?',
                           set_cmd='SENS1:AVER:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))

        self.add_parameter('averages_trigger_enabled',
                           label='Trigger average status',
                           get_cmd='TRIG:SEQ:AVER?',
                           set_cmd='TRIG:SEQ:AVER {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))

        self.add_parameter('averages',
                           label='Averages',
                           get_cmd='SENS1:AVER:COUN?',
                           set_cmd='SENS1:AVER:COUN {}',
                           get_parser=int,
                           set_parser=int,
                           unit='',
                           vals=Numbers(min_value=1, max_value=999))

        self.add_parameter('electrical_delay',
                           label='Electrical delay',
                           get_cmd='CALC1:CORR:EDEL:TIME?',
                           set_cmd='CALC1:CORR:EDEL:TIME {}',
                           get_parser=float,
                           set_parser=float,
                           unit='s',
                           vals=Numbers(-10, 10))

        self.add_parameter('electrical_distance',
                           label='Electrical distance',
                           get_cmd='CALC1:CORR:EDEL:DIST?',
                           set_cmd='CALC1:CORR:EDEL:DIST {}',
                           get_parser=float,
                           set_parser=float,
                           unit='m',
                           vals=Numbers())

        self.add_parameter('clock_source',
                           label='Clock source',
                           get_cmd='SENSe1:ROSCillator:SOURce?',
                           set_cmd='SENSe1:ROSCillator:SOURce {}',
                           get_parser=str,
                           set_parser=str,
                           vals = Enum('int', 'Int', 'INT',
                                       'internal', 'Internal', 'INTERNAL',
                                       'ext', 'Ext', 'EXT',
                                       'external', 'External', 'EXTERNAL'))

        self.add_parameter(name='start',
                           label='Start Frequency',
                           get_parser=float,
                           get_cmd='SENS1:FREQ:STAR?',
                           set_cmd=self._set_start,
                           unit='Hz',
                           vals=Numbers(min_value=300e3,
                                        max_value=18e9-1))

        self.add_parameter(name='stop',
                           label='Stop Frequency',
                           get_parser=float,
                           get_cmd='SENS1:FREQ:STOP?',
                           set_cmd=self._set_stop,
                           unit='Hz',
                           vals=Numbers(min_value=300e3+1,
                                        max_value=18e9))

        self.add_parameter(name='center',
                           label='Center Frequency',
                           get_parser=float,
                           get_cmd='SENS1:FREQ:CENT?',
                           set_cmd=self._set_center,
                           unit='Hz',
                           vals=Numbers(min_value=100e3+1,
                                        max_value=18e9-1))

        self.add_parameter(name='span',
                           label='Frequency Span',
                           get_parser=float,
                           get_cmd='SENS1:FREQ:SPAN?',
                           set_cmd=self._set_span,
                           unit='Hz',
                           vals=Numbers(min_value=1,
                                        max_value=18e9-1))

        self.add_parameter('npts',
                           label='Number of points',
                           get_parser=int,
                           set_parser=int,
                           get_cmd='SENS1:SWE:POIN?',
                           set_cmd=self._set_npts,
                           unit='',
                           vals=Ints(min_value=2,
                                        max_value=200001))

        self.add_parameter('nb_traces',
                           label='Number of traces',
                           get_parser=int,
                           set_parser=int,
                           get_cmd='CALC1:PAR:COUN?',
                           set_cmd='CALC1:PAR:COUN {}',
                           unit='',
                           vals=Ints(min_value=1,
                                     max_value=16))

        self.add_parameter(name='trigger_source',
                           label='Trigger source',
                           get_parser=str,
                           get_cmd=self._get_trigger,
                           set_cmd=self._set_trigger,
                           vals = Enum('bus', 'external', 'internal', 'manual'))

        self.add_parameter(name='data_transfer_format',
                           label='Data format during transfer',
                           get_parser=str,
                           get_cmd='FORM:DATA?',
                           set_cmd='FORM:DATA {}',
                           vals = Enum('ascii', 'real', 'real32'))

        self.add_parameter(name='s11',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           parameter_class=FrequencySweepMagPhase)

        self.add_parameter(name='s12',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           parameter_class=FrequencySweepMagPhase)

        self.add_parameter(name='s21',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           parameter_class=FrequencySweepMagPhase)

        self.add_parameter(name='s22',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           parameter_class=FrequencySweepMagPhase)

        self.add_parameter(name='point_s11',
                           parameter_class=PointMagPhase)

        self.add_parameter(name='point_s12',
                           parameter_class=PointMagPhase)

        self.add_parameter(name='point_s21',
                           parameter_class=PointMagPhase)

        self.add_parameter(name='point_s22',
                           parameter_class=PointMagPhase)

        self.add_parameter(name=""point_check_sweep_first"",
            parameter_class=ManualParameter,
            initial_value=True,
            vals=Bool(),
            docstring=""Parameter that enables a few commands, which are called""
            ""before each get of a point_sxx parameter checking whether the vna""
            ""is setup correctly. Is recommended to be True, but can be turned""
            ""off if one wants to minimize overhead."",
        )

        self.connect_message()

    def _set_start(self, val: float) -> None:
        """"""Sets the start frequency and updates linear trace parameters.

        Args:
            val (float): start frequency to be set

        Raises:
            ValueError: If start > stop
        """"""
        stop = self.stop()
        if val >= stop:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        self.write(""SENS1:FREQ:STAR {}"".format(val))
        # we get start as the vna may not be able to set it to the
        # exact value provided.
        start = self.start()
        if abs(val - start) >= 1:
            log.warning(
                ""Could not set start to {} setting it to ""
                ""{}"".format(val, start)
            )
        self.update_lin_traces()

    def _set_stop(self, val: float) -> None:
        """"""Sets the start frequency and updates linear trace parameters.

        Args:
            val (float): start frequency to be set

        Raises:
            ValueError: If stop < start
        """"""
        start = self.start()
        if val <= start:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        self.write(""SENS1:FREQ:STOP {}"".format(val))
        # We get stop as the vna may not be able to set it to the
        # exact value provided.
        stop = self.stop()
        if abs(val - stop) >= 1:
            log.warning(
                ""Could not set stop to {} setting it to ""
                ""{}"".format(val, stop)
            )
        self.update_lin_traces()

    def _set_span(self, val: float) -> None:
        """"""Sets frequency span and updates linear trace parameters.

        Args:
            val (float): frequency span to be set
        """"""
        self.write(""SENS1:FREQ:SPAN {}"".format(val))
        self.update_lin_traces()

    def _set_center(self, val: float) -> None:
        """"""Sets center frequency and updates linear trace parameters.

        Args:
            val (float): center frequency to be set
        """"""
        self.write(""SENS1:FREQ:CENT {}"".format(val))
        self.update_lin_traces()

    def _set_npts(self, val: int) -> None:
        """"""Sets number of points and updates linear trace parameters.

        Args:
            val (int): number of points to be set.
        """"""
        self.write(""SENS1:SWE:POIN {}"".format(val))
        self.update_lin_traces()

    def _get_trigger(self) -> str:
        """"""Gets trigger source.

        Returns:
            str: Trigger source.
        """"""
        r = self.ask('TRIG:SOUR?')

        if r.lower()=='int':
            return 'internal'
        elif r.lower()=='ext':
            return 'external'
        elif r.lower()=='man':
            return 'manual'
        else:
            return 'bus'

    def _set_trigger(self, trigger: str) -> None:
        """"""Sets trigger source.

        Args:
            trigger (str): Trigger source
        """"""
        self.write('TRIG:SOUR '+trigger.upper())

    def get_s(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray,
                             np.ndarray, np.ndarray, np.ndarray, np.ndarray,
                             np.ndarray]:
        """"""
        Return all S parameters as magnitude in dB and phase in rad.

        Returns:
            Tuple[np.ndarray]: frequency [GHz],
            s11 magnitude [dB], s11 phase [rad],
            s12 magnitude [dB], s12 phase [rad],
            s21 magnitude [dB], s21 phase [rad],
            s22 magnitude [dB], s22 phase [rad]
        """"""

        self.write('CALC1:PAR:COUN 4') # 4 trace
        self.write('CALC1:PAR1:DEF S11') # Choose S11 for trace 1
        self.write('CALC1:PAR2:DEF S12') # Choose S12 for trace 2
        self.write('CALC1:PAR3:DEF S21') # Choose S21 for trace 3
        self.write('CALC1:PAR4:DEF S22') # Choose S22 for trace 4
        self.write('CALC1:TRAC1:FORM SMITH')  # Trace format
        self.write('CALC1:TRAC2:FORM SMITH')  # Trace format
        self.write('CALC1:TRAC3:FORM SMITH')  # Trace format
        self.write('CALC1:TRAC4:FORM SMITH')  # Trace format
        self.write('TRIG:SEQ:SING') # Trigger a single sweep
        self.ask('*OPC?') # Wait for measurement to complete

        # Get data as string
        freq_raw = self.ask(""SENS1:FREQ:DATA?"")
        s11_raw = self.ask(""CALC1:TRAC1:DATA:FDAT?"")
        s12_raw = self.ask(""CALC1:TRAC2:DATA:FDAT?"")
        s21_raw = self.ask(""CALC1:TRAC3:DATA:FDAT?"")
        s22_raw = self.ask(""CALC1:TRAC4:DATA:FDAT?"")

        # Get data as numpy array
        freq = np.fromstring(freq_raw, dtype=float, sep=',')
        s11 = np.fromstring(s11_raw, dtype=float, sep=',')
        s11 = s11[0::2] + 1j*s11[1::2]
        s12 = np.fromstring(s12_raw, dtype=float, sep=',')
        s12 = s12[0::2] + 1j*s12[1::2]
        s21 = np.fromstring(s21_raw, dtype=float, sep=',')
        s21 = s21[0::2] + 1j*s21[1::2]
        s22 = np.fromstring(s22_raw, dtype=float, sep=',')
        s22 = s22[0::2] + 1j*s22[1::2]

        return (np.array(freq), self._db(s11), np.array(np.angle(s11)),
                                self._db(s12), np.array(np.angle(s12)),
                                self._db(s21), np.array(np.angle(s21)),
                                self._db(s22), np.array(np.angle(s22)))

    def update_lin_traces(self) -> None:
        """"""
        Updates start, stop and npts of all trace parameters so that the
        setpoints and shape are updated for the sweep.
        """"""
        start = self.start()
        stop = self.stop()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, (FrequencySweepMagPhase)):
                try:
                    parameter.set_sweep(start, stop, npts)
                except AttributeError:
                    pass

    def reset_averages(self) -> None:
        """"""
        Resets average count to 0
        """"""
        self.write(""SENS1.AVER.CLE"")

    @staticmethod
    def _db(data: np.ndarray) -> np.ndarray:
        """"""
        Return dB from magnitude

        Args:
            data (np.ndarray): data to be transformed into dB.

        Returns:
            data (np.ndarray): data transformed in dB.
        """"""

        return 20.*np.log10(np.abs(data))
"
113,,https://en.wikipedia.org/wiki/Signal_generator,,1657.0,"Austin, Texas, USA",,,Rfsg,374.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","A producer of automated test equipment and virtual instrumentation software. Common applications include data acquisition, instrument control and machine vision. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/NationalInstruments/RFSG.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/tree/main/qcodes_contrib_drivers/drivers/NationalInstruments,National Instruments,"[OrderedDict([('id', 'attXAVi8mGWUwkEk7'), ('width', 960), ('height', 541), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/j_Cmz4uga8rm7Jk-W_hKJA/OFEsr4zAjNbG-yC55hU0noMqYtoPe9vQD-Gl-SI0_1-hw4p7TC8Qdz0fFEtGOyg7Gp-hqmHtvDJ5Uc0FHOeTZg/VpMBAVW2a1O5TmWcxSYkEtHm4BcyD8QObKnNg5JfgT0'), ('filename', '0x0.webp'), ('size', 3600), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4ZfSfzm3FWUK3mOB22JVow/iKinLC2EHIADrqenQyQb4vXtxsXSU3vw7pErcZG_x94ZnV7BNdl1ATxfilb4AcI9AzC_jsIekTtgJ4AgWnIY-b1Hh0id6SKbfLgxWmnsBXo/fH59fAbtvfp-o76XqOSe5kcylQsoXwwwMGdcmXpo_nU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Rc_oPk909VeMPUIitsLj0w/FGlkfJlj5eu6r1O9HbQw96t_v9q8ABFOEQoC6d-bOa2Qdc1ops_fMtexXqE0QP7SXa02gEfs2oNFOOrrKS_LXbc2EJwN2G-Q5nDLPE18cCU/8v_OfysCX2mh7OF_Gi8ehcKkabwz3aT5QxGDtwHH5Co'), ('width', 909), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VrmEJSvE-wFyX58WI74X5w/21j--KVJrXwHWTW9l2FxBDTcxAsHk77Bi_xQtjImpzHfA--vqGMI_jVdQr3fG77lJzEyZHS6dUQe__YLb2i04-hmeB9UHAvi4AiVzzQBF1Q/NpnfS_vHNbJaSo4ZYcewJF_7ZX-hLmRd65vYunzSeig'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ni.com/en-ca.html,RFSG,Write a Python script that uses Qcodes Community to connect to a RFSG RF Signal Generator,,,,,"import logging
from typing import Optional
from functools import partial

from qcodes.utils.helpers import create_on_off_val_mapping as on_off_map
from qcodes.utils.validators import Numbers

from .visa_types import (
        ViString, ViAttr, ViSession, ViReal64, ViBoolean, ViInt32,
        )
from .dll_wrapper import AttributeWrapper, NamedArgType
from .ni_dll_instrument import NIDLLInstrument

# Constants used for querying attributes.
# These can be found in the RFSG C API documentation, see below.
NIRFSG_ATTR_INSTRUMENT_FIRMWARE_REVISION = AttributeWrapper(ViAttr(1050510), ViString)
NIRFSG_ATTR_INSTRUMENT_MANUFACTURER      = AttributeWrapper(ViAttr(1050511), ViString)
NIRFSG_ATTR_INSTRUMENT_MODEL             = AttributeWrapper(ViAttr(1050512), ViString)
NIRFSG_ATTR_SPECIFIC_DRIVER_VENDOR       = AttributeWrapper(ViAttr(1050513), ViString)
NIRFSG_ATTR_SPECIFIC_DRIVER_REVISION     = AttributeWrapper(ViAttr(1050551), ViString)
NIRFSG_ATTR_SERIAL_NUMBER                = AttributeWrapper(ViAttr(1150026), ViString)
NIRFSG_ATTR_FREQUENCY                    = AttributeWrapper(ViAttr(1250001), ViReal64)
NIRFSG_ATTR_POWER_LEVEL                  = AttributeWrapper(ViAttr(1250002), ViReal64)
NIRFSG_ATTR_OUTPUT_ENABLED               = AttributeWrapper(ViAttr(1250004), ViBoolean)
NIRFSG_ATTR_REF_CLOCK_SOURCE             = AttributeWrapper(ViAttr(1150001), ViString)
NIRFSG_ATTR_ANALOG_MODULATION_TYPE       = AttributeWrapper(ViAttr(1150032), ViInt32)
NIRFSG_ATTR_ANALOG_MODULATION_AM_SENSITIVITY = AttributeWrapper(ViAttr(1150167), ViReal64)
NIRFSG_ATTR_PULSE_MODULATION_ENABLED     = AttributeWrapper(ViAttr(1250051), ViBoolean)

logger = logging.getLogger(__name__)


# Name mapping for analog modulation mode.
# These can be found in the NI RFSG header file, found by default in
# C:\Program Files (x86)\IVI Foundation\IVI\Include\niRFSG.h
# or in the online documentation: https://zone.ni.com/reference/en-XX/help/371025V-01/rfsgproperties/pnirfsg_anlgmod.type/
ANALOG_MOD_NAME_MAP = {
    ""none"": 0, # NIRFSG_VAL_NONE
    ""FM"": 2000, # NIRFSG_VAL_FM
    ""PM"": 2001, # NIRFSG_VAL_PM
    ""AM"": 2002, # NIRFSG_VAL_AM
}


CLK_SRC_MAP = {
    ""onboard"": ""OnboardClock"",
    ""clk_in"": ""ClkIn"",
    ""ref_in"": ""RefIn"",
    ""pxi_clk"": ""PXI_CLK"",
    ""ref_in_2"": ""RefIn2"",
    ""pxi_clk_master"": ""PXI_ClkMaster"",
}


class NationalInstruments_RFSG(NIDLLInstrument):
    r""""""
    This is the QCoDeS driver for National Instruments RF signal generator
    devices based on the NI-RFSG driver. As of NI-RFSG version 18.1, the
    supported devices are
    PXI-5610,  PXI-5650,  PXI-5651,  PXI-5652,  PXI-5670,  PXI-5671, PXIe-5611,
    PXIe-5644, PXIe-5645, PXIe-5646, PXIe-5650, PXIe-5651, PXIe-5652,
    PXIe-5653, PXIe-5654, PXIe-5672, PXIe-5673, PXIe-5673E, PXIe-5820,
    PXIe-5840.

    Documentation for the NI-RFSG C API can be found by default in the
    folder C:\Users\Public\Documents\National Instruments\NI-RFSG\Documentation

    Only very basic functionality is implemented.

    Tested with

    - PXIe-5654

    Args:
        name: Name for this instrument
        resource: Identifier for this instrument in NI MAX.
        dll_path: path to the NI-RFSG library DLL. If not provided, use the
            default location,
            ``C:\Program Files\IVI Foundation\IVI\bin\NiRFSG_64.dll``.
        id_query: whether to perform an ID query on initialization
        reset_device: whether to reset the device on initialization
    """"""

    # default DLL location
    dll_path = r""C:\Program Files\IVI Foundation\IVI\bin\NiRFSG_64.dll""
    # C:\Program Files (x86)\IVI Foundation\IVI\bin\NiRFSG.dll for 32-bit

    def __init__(self, name: str, resource: str,
                 dll_path: Optional[str] = None,
                 id_query: bool = False,
                 reset_device: bool = False,
                 **kwargs):

        super().__init__(name=name, resource=resource,
                         dll_path=dll_path or self.dll_path,
                         lib_prefix=""niRFSG"", **kwargs)

        # Wrap DLL calls
        self.wrapper.Initiate = self.wrapper.wrap_dll_function_checked(  # type: ignore[attr-defined]
                name_in_library=""Initiate"",
                argtypes=[NamedArgType(""vi"", ViSession)]
                )

        self.wrapper.Abort = self.wrapper.wrap_dll_function_checked(  # type: ignore[attr-defined]
                name_in_library=""Abort"",
                argtypes=[NamedArgType(""vi"", ViSession)])

        self.wrapper.ConfigureRF = self.wrapper.wrap_dll_function_checked(  # type: ignore[attr-defined]
                name_in_library=""ConfigureRF"",
                argtypes=[
                    NamedArgType(""vi"", ViSession),
                    NamedArgType(""frequency"", ViReal64),
                    NamedArgType(""powerLevel"", ViReal64),
                    ]
                )

        self.add_parameter(name=""frequency"",
                           unit=""Hz"",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_FREQUENCY),
                           set_cmd=self._set_frequency,
                           )

        self.add_parameter(name=""power_level"",
                           unit=""dBm"",
                           label=""power level"",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_POWER_LEVEL),
                           set_cmd=self._set_power_level,
                           )

        self.add_parameter(name=""output_enabled"",
                           label=""Output enabled"",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_OUTPUT_ENABLED),
                           set_cmd=partial(self.set_attribute,
                                           NIRFSG_ATTR_OUTPUT_ENABLED),
                           val_mapping=on_off_map(on_val=True, off_val=False),
                           initial_value=False,
                           )

        self.add_parameter(name=""pulse_mod_enabled"",
                           label=""Pulse modulation enabled"",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_PULSE_MODULATION_ENABLED
                                           ),
                           set_cmd=partial(self.set_attribute,
                                           NIRFSG_ATTR_PULSE_MODULATION_ENABLED
                                           ),
                           val_mapping=on_off_map(on_val=True, off_val=False),
                           initial_value=False,
                           )

        self.add_parameter(name=""analog_mod_type"",
                           label=""Analog modulation type"",
                           docstring=""Specifies the analog modulation format ""
                                     ""to use. FM = frequency modulation, PM = ""
                                     ""phase modulation, AM = amplitude ""
                                     ""modulation. Set to 'none' to disable ""
                                     ""analog modulation."",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_ANALOG_MODULATION_TYPE),
                           set_cmd=partial(self.set_attribute,
                                           NIRFSG_ATTR_ANALOG_MODULATION_TYPE),
                           val_mapping=ANALOG_MOD_NAME_MAP,
                           )

        self.add_parameter(name=""amplitude_mod_sensitivity"",
                           label=""Amplitude modulation sensitivity"",
                           docstring=""The modulation signal sent to AM IN is ""
                                     ""scaled by this percentage before ""
                                     ""multiplying the carrier wave."",
                           unit=""%/V"",
                           get_cmd=partial(
                                self.get_attribute,
                                NIRFSG_ATTR_ANALOG_MODULATION_AM_SENSITIVITY
                           ),
                           set_cmd=partial(
                                self.set_attribute,
                                NIRFSG_ATTR_ANALOG_MODULATION_AM_SENSITIVITY
                           ),
                           vals=Numbers(0, 100),
                           )

        self.add_parameter(name=""clock_source"",
                           label=""Reference clock source"",
                           docstring=""Specify the reference clock source for ""
                           ""the device. See the ``vals`` attribute for valid ""
                           ""values.\n\nThe values 'ref_in_2' and ""
                           ""'pxi_clk_master' are valid for PXIe-5840 with ""
                           ""PXIe-5653. For further details, see the NI-RFSG ""
                           ""documentation."",
                           get_cmd=partial(self.get_attribute,
                                           NIRFSG_ATTR_REF_CLOCK_SOURCE),
                           set_cmd=partial(self.set_attribute,
                                           NIRFSG_ATTR_REF_CLOCK_SOURCE),
                           val_mapping=CLK_SRC_MAP,
                           )

        self.initiate()
        self.connect_message()

    def initiate(self):
        """"""
        Initiate signal generation. This causes the NI-RFSG device to leave
        the Configuration state.
        """"""
        self.wrapper.Initiate(self._handle)

    def abort(self):
        """"""
        Stop signal generation and return to the Configuration state.
        """"""
        self.wrapper.Abort(self._handle)

    def _configure_rf(self, frequency: float, power_level: float,
                      initiate: bool):
        """"""
        NI-RFSG devices can only set both the frequency and power level
        simultatneously. Convenience methods are defined below for setting
        them individually.

        NOTE: PXI-5670/5671 and PXIe-5672 devices must be in the Configuration
        state before calling this function (by calling abort()), that is not
        checked here.

        Args:
            frequency: frequency in Hz
            power_level: power level in dBm
            initiate: if True, call self.initiate after configuring, which
                starts RF output
        """"""
        self.wrapper.ConfigureRF(  # type: ignore[attr-defined]
            self._handle,
            ViReal64(frequency),
            ViReal64(power_level)
        )

        if initiate:
            self.initiate()

    def _set_frequency(self, frequency: float, initiate: bool = False):
        power_level = self.get_attribute(NIRFSG_ATTR_POWER_LEVEL)
        self._configure_rf(frequency, power_level, initiate)

    def _set_power_level(self, power_level: float, initiate: bool = False):
        frequency = self.get_attribute(NIRFSG_ATTR_FREQUENCY)
        self._configure_rf(frequency, power_level, initiate)

    @property
    def vendor(self) -> str:
        return self.get_attribute(NIRFSG_ATTR_SPECIFIC_DRIVER_VENDOR)

    @property
    def model(self) -> str:
        return self.get_attribute(NIRFSG_ATTR_INSTRUMENT_MODEL)

    @property
    def serial(self) -> str:
        return self.get_attribute(NIRFSG_ATTR_SERIAL_NUMBER)

    @property
    def firmware(self) -> str:
        return self.get_attribute(NIRFSG_ATTR_INSTRUMENT_FIRMWARE_REVISION)

    def get_idn(self):
        return {
                ""vendor"": self.vendor,
                ""model"": self.model,
                ""serial"": self.serial,
                ""firmware"": self.firmware
        }

# class NationalInstruments_RFSG


# shorthand alias for the above
NI_RFSG = NationalInstruments_RFSG
"
117,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attAXR8c8ki57a3nQ'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/fNKOGo3rNtuaDJXhKDrRCg/QT8PP7mBZkVCHei3Vhtw_BzkCUzdf0DwqgqV4SJ9ZYP0cps70vcxEnvCR6Axq433idpbXB897BnfR4mF8zDd8x--dDMnnzGzsyj66HB3MYdDCroVPhNR8NeOqsJUzRS0/-4t2VVRfcRVvxbFVYk2YKYysquo27ml75jJJxVLZi_Y'), ('filename', 'vaunix-digital-attenuator-102.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PCvmt_rJHdeCSvD54j0tQw/WCNwcuWOvj9TfU_yUY8SrQ2_ePQKWG9kfpnZ9Qspu1cY08Uc6Lsubpzi_7X4evFHv0Np0BNaOhbs_wmS8LauEw/vckUDrXlfOgyG1Seh5d5v6OJBnfyZRsXXQED1DLpODE'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6dDhPwHovo8D2HwtIP84Jg/EP0Nd8-3ws_Sc2S8u6REAB1_YSnC1FWYv9ReDOtAEKs2y9afMRXqqFiaSneIYHnrFbNuvbfQ_YZNgcsMp_Fyfw/d0brUO5beK7v9EEfd4ANj3uxTmbezFnFVUasr8fZHAU'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vi9A8bv4Rv2AxlWhRbZcKA/p1FP_8ORI2q4-to4KC0BzMPFME5VvpnG_i4RHi4om2Keb7Z3_1SHqcKLOYywTxzkVs58riYJ9YzjI6TFPh0U-Q/fCDE2yydX8EGsucrpDEljKHIU0rwN_hDSQJd8P82Jng'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-HN Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 31.5 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-302p-hn-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-HN,Write a Python script that uses Qcodes Community to connect to a LDA-302P-HN ,615.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
122,https://bluefors.com/blog/enhanced-user-experience-with-temperature-controller/,https://bluefors.com/blog/enhanced-user-experience-with-temperature-controller/,"[OrderedDict([('id', 'attX0SFxuKJyGvviK'), ('width', 706), ('height', 355), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/C4ne8XfeO5jFohf5pbHF8w/4XNgsOniGn05Vgn2bdfjYowacWa9VdSt5RP7Vz3bZZTqISJcTYNS4hJW3qJSgZ50Dsfb3eGT67QpFisxv_Nsy_GhvkpeEto7LiqUwX62nHa45sqg97AH8yHeDYOYr4MZFWvSf4g9BFGRpiJ1FMsKyWi7WNzab26mSoJqu3hMIqQ/rzT-ZmvBW3GFJR5gYBbtVatwqg6M0hHgKXsB_cznJ3s'), ('filename', 'temperature-controller-for-bluefors-cryogenic-systems-706.png'), ('size', 224298), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1UtqXGeTvI6CqakkTFyiBQ/50Dvanmu_it3uHLa1RZoBqnZklXUYGlnAQp3HF_3G4hmrxsvmM_q0MZuy33ZOvWt2ImP4eCW9aNo_8cOqGdpRg/Q5DGKWU_HtPWzall52Y5ZxRPRweiOKsz06Qvb6D-dxY'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Gv9iM1BV9r8ClcDeLBL_HQ/XWSz8ZthON4WS4obSn0g2wP6riVfOl55uGVYUZwHjri1RNmD2ItXsoJazApRhXyUB1O7jlDVL1ShYKNR5KPiOQ/0bRAgBX8Ub3n_ag867KUX8E-DqTPmhczuL2HCpsBL78'), ('width', 706), ('height', 355)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iFxeJktpl9eYJRLg9lI3IA/WN2AolG9zF4QGFfCGtwUuT4UzIFfJFDOXceve6tPm9n-QTZwU7OQuNpEJN3cCspjMamXEyW_BAL9CeUc-Hllww/wE5koUNtm0Ud1jjV4ZJZ4PwHYTRgRw__NKICmHTl5RA'), ('width', 3000), ('height', 3000)]))]))])]",32.0,Finland,"With a modern and intuitive user interface, you gain direct control and overview of the dilution refrigerator system’s temperature status.",https://bluefors.com/blog/enhanced-user-experience-with-temperature-controller/,"Bluefors temperature controller
",109.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature","**Bluefors** is the world's leading manufacturer of ultra-low temperature dilution refrigerator measurement systems
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/BlueFors/BlueFors.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.BlueFors.html#module-qcodes_contrib_drivers.drivers.BlueFors.BlueFors,Bluefors,"[OrderedDict([('id', 'attXPNgeU0vdqC6YW'), ('width', 1064), ('height', 592), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7N90145xR6P1_11wS_qfNA/0eYxWtx5N0knwItA9-lDkmtVuoU8j-QMLtoZ0M8sC_sD_2s8J3EpOpLINNYxB5zrVpSRbms6RJ_tqJdLqBtdbQ46P9ZdbRRwGI-zQLyzrI8-2gjAhdlJWTxk8BpvU7RvKS0ir-APZZ4N8XIB9Gw7Ug/26qzuuPrwMzEqBriletlEO7083LNsGGqX6apSpgDh-A'), ('filename', 'bluefors_logos_RGB_300dpi_black_block-002.jpg'), ('size', 13721), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VirKYghKhkM7pGalBqLuRA/NOVBEqTLkOGzQGhjpPoNEAvN2nkWd6QndwaEnNxB-ML4q5-CqPvNUlecl7BwvmSeVz3rg_JlQsinEpmuq-gArQ/mK1gcHN9XsKyA56OEiw3FkYK3vDrrUvqVMoEcrJw8ng'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9o2jU8KGoZ91aMOHcTOKLw/tXmA3xL98rfqOJ4f0obMTObAqWd3BGJCIh6DxNSUI0NAVCSLau578HoQstogZeUeroXXTPJoP5VplPdGloVRMg/BKBGiYM4DAk7tC9uSDghXVCowF3SoPE8Y5hAV9n3LHU'), ('width', 920), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4F_oKlx_f5pU3nk-kAJshA/WqGvmL2e0vE-Jv5ypxSPtx9xqR4SANjYit9Cf-Z7JXICX7qPCL8JZtpv-dQnNXQVUvPe4H_UT0LxNIh5QdrOCw/uTOJVS_Q0ffIDXjhAhctgcz2-Qu1btrpW0M8g3AsLEI'), ('width', 3000), ('height', 3000)]))]))])]",https://bluefors.com/,"Bluefors temperature controller
","Write a Python script that uses Qcodes Community to connect to a Bluefors temperature controller
 Temperature Controllers",,,,,"# This Python file uses the following encoding: utf-8
# Etienne Dumur <etienne.dumur@gmail.com>, september 2020

import os
import pandas as pd
import numpy as np
from datetime import date
from typing import Optional
from qcodes.instrument.base import Instrument

class BlueFors(Instrument):
    """"""
    This is the QCoDeS python driver to extract the temperature and pressure
    from a BlueFors fridge
    """"""

    def __init__(self, name                      : str,
                       folder_path               : str,
                       channel_vacuum_can        : int,
                       channel_pumping_line      : int,
                       channel_compressor_outlet : int,
                       channel_compressor_inlet  : int,
                       channel_mixture_tank      : int,
                       channel_venting_line      : int,
                       channel_50k_plate         : int,
                       channel_4k_plate          : int,
                       channel_still             : int,
                       channel_mixing_chamber    : int,
                       channel_magnet            : Optional[int] = None,
                       **kwargs) -> None:
        """"""
        QCoDeS driver for BlueFors fridges.
        ! This driver get parameters from the fridge log files.
        ! It does not interact with the fridge electronics.

        Args:
        name: Name of the instrument.
        folder_path: Valid path toward the BlueFors log folder.
        channel_vacuum_can: channel of the vacuum can
        channel_pumping_line: channel of the pumping line.
        channel_compressor_outlet: channel of the compressor outlet.
        channel_compressor_inlet: channel of the compressor inlet.
        channel_mixture_tank: channel of the mixture tank.
        channel_venting_line: channel of the venting line.
        channel_50k_plate: channel of the 50k plate.
        channel_4k_plate: channel of the 4k plate.
        channel_still: channel of the still.
        channel_mixing_chamber: channel of the mixing chamber.
        channel_magnet: channel of the magnet.
        """"""

        super().__init__(name = name, **kwargs)

        self.folder_path = os.path.abspath(folder_path)

        self.add_parameter(name       = 'pressure_vacuum_can',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_vacuum_can),
                           docstring  = 'Pressure of the vacuum can',
                           )

        self.add_parameter(name       = 'pressure_pumping_line',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_pumping_line),
                           docstring  = 'Pressure of the pumping line',
                           )

        self.add_parameter(name       = 'pressure_compressor_outlet',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_compressor_outlet),
                           docstring  = 'Pressure of the compressor outlet',
                           )

        self.add_parameter(name       = 'pressure_compressor_inlet',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_compressor_inlet),
                           docstring  = 'Pressure of the compressor inlet',
                           )

        self.add_parameter(name       = 'pressure_mixture_tank',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_mixture_tank),
                           docstring  = 'Pressure of the mixture tank',
                           )

        self.add_parameter(name       = 'pressure_venting_line',
                           unit       = 'mBar',
                           get_parser = float,
                           get_cmd    = lambda: self.get_pressure(channel_venting_line),
                           docstring  = 'Pressure of the venting line',
                           )

        self.add_parameter(name       = 'temperature_50k_plate',
                           unit       = 'K',
                           get_parser = float,
                           get_cmd    = lambda: self.get_temperature(channel_50k_plate),
                           docstring  = 'Temperature of the 50K plate',
                           )

        self.add_parameter(name       = 'temperature_4k_plate',
                           unit       = 'K',
                           get_parser = float,
                           get_cmd    = lambda: self.get_temperature(channel_4k_plate),
                           docstring  = 'Temperature of the 4K plate',
                           )

        if channel_magnet is not None:
            self.add_parameter(name       = 'temperature_magnet',
                               unit       = 'K',
                               get_parser = float,
                               get_cmd    = lambda: self.get_temperature(channel_magnet),
                               docstring  = 'Temperature of the magnet',
                               )

        self.add_parameter(name       = 'temperature_still',
                           unit       = 'K',
                           get_parser = float,
                           get_cmd    = lambda: self.get_temperature(channel_still),
                           docstring  = 'Temperature of the still',
                           )

        self.add_parameter(name       = 'temperature_mixing_chamber',
                           unit       = 'K',
                           get_parser = float,
                           get_cmd    = lambda: self.get_temperature(channel_mixing_chamber),
                           docstring  = 'Temperature of the mixing chamber',
                           )

        self.connect_message()


    def get_temperature(self, channel: int) -> float:
        """"""
        Return the last registered temperature of the current day for the
        channel.

        Args:
            channel (int): Channel from which the temperature is extracted.

        Returns:
            temperature (float): Temperature of the channel in Kelvin.
        """"""

        folder_name = date.today().strftime(""%y-%m-%d"")
        file_path = os.path.join(self.folder_path, folder_name, 'CH'+str(channel)+' T '+folder_name+'.log')

        try:
            df = pd.read_csv(file_path,
                                delimiter = ',',
                                names     = ['date', 'time', 'y'],
                                header    = None)

            # There is no space before the day with BlueFors Control Software v2.2
            df.index = pd.to_datetime(df['date']+'-'+df['time'], format='%d-%m-%y-%H:%M:%S')

            return df.iloc[-1]['y']
        except (PermissionError, OSError) as err:
            self.log.warn('Cannot access log file: {}. Returning np.nan instead of the temperature value.'.format(err))
            return np.nan
        except IndexError as err:
            self.log.warn('Cannot parse log file: {}. Returning np.nan instead of the temperature value.'.format(err))
            return np.nan


    def get_pressure(self, channel: int) -> float:
        """"""
        Return the last registered pressure of the current day for the
        channel.

        Args:
            channel (int): Channel from which the pressure is extracted.

        Returns:
            pressure (float): Pressure of the channel in mBar.
        """"""

        folder_name = date.today().strftime(""%y-%m-%d"")
        file_path = os.path.join(self.folder_path, folder_name, 'maxigauge '+folder_name+'.log')

        try:
            df = pd.read_csv(file_path,
                            delimiter=',',
                            names=['date', 'time',
                                    'ch1_name', 'ch1_void1', 'ch1_status', 'ch1_pressure', 'ch1_void2', 'ch1_void3',
                                    'ch2_name', 'ch2_void1', 'ch2_status', 'ch2_pressure', 'ch2_void2', 'ch2_void3',
                                    'ch3_name', 'ch3_void1', 'ch3_status', 'ch3_pressure', 'ch3_void2', 'ch3_void3',
                                    'ch4_name', 'ch4_void1', 'ch4_status', 'ch4_pressure', 'ch4_void2', 'ch4_void3',
                                    'ch5_name', 'ch5_void1', 'ch5_status', 'ch5_pressure', 'ch5_void2', 'ch5_void3',
                                    'ch6_name', 'ch6_void1', 'ch6_status', 'ch6_pressure', 'ch6_void2', 'ch6_void3',
                                    'void'],
                            header=None)

            df.index = pd.to_datetime(df['date']+'-'+df['time'], format='%d-%m-%y-%H:%M:%S')

            return df.iloc[-1]['ch'+str(channel)+'_pressure']
        except (PermissionError, OSError) as err:
            self.log.warn('Cannot access log file: {}. Returning np.nan instead of the pressure value.'.format(err))
            return np.nan
        except IndexError as err:
            self.log.warn('Cannot parse log file: {}. Returning np.nan instead of the pressure value.'.format(err))
            return np.nan
"
124,https://downloads.gentec-eo.com/prod/cecfd555/MAESTRO-Product-specifications-Gentec-EO.pdf,https://en.wikipedia.org/wiki/Display,"[OrderedDict([('id', 'attnY8OZIObgRRtkH'), ('width', 1225), ('height', 950), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Zql9yfgbUWgrxnyzgupaTA/b0u72HRoef0VY7BYIGQnrWegCfcVI3F16kIapanp0FFEfqikiGaGf51wwusMCReuWlBhkHVa11FY6z9MZ7S0WOxVkatruezKmD1xgY53itI/91kJSGtIBTEsoUhZ2MXef3YB55Ehj0w85y7STzfsJvg'), ('filename', 'maestro.png'), ('size', 668995), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/TT6nCzIhYvwAc26BE7mGfg/pJZ8M1E3eIFWxgYzSl3L2aQHCXgPGnhmyHiYC39q23pTPoWEIlHbcZJXQ9-eF8eD98uQAF21wQZm0ZIq9OyBRQ/lsQAdOs2lV7TYADaZ8G3X-hgb5dZoddOTBoyOEz4P6U'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ruW6ebK3zNsi_put8l-ENg/--GvveE7xZ7EpwaRVmuytYjLo8O376VbCdqUsTsW9J-MV5pwUrksNiroB2BMoDrlq87gMPdBDNH8ktYZZPcirg/1hZgyq-F1z-IL7JFGC8I8g5K3PO6h6C2-IgnkEhYRbs'), ('width', 660), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Xwnm5VxgWZviPPzd_Qm6yg/l1IAj6W_mItTaZ2rE5r00-NfKpugUWfOuhCYQB7dp2NivlPNTKWbd9A9q9x0aP0J9LH2pdI87Xnto8yTPwAncQ/TRhGQ22LPOg0sELbN6jKk6lKCotGNY4Ve3DrDaTtvdc'), ('width', 3000), ('height', 3000)]))]))])]",14.0,Canda - QC,"Touchscreen display device for power & energy measurement. Single-channel, multiple outputs (USB, Ethernet, analog).
",https://www.gentec-eo.com/products/maestro,Gentec EO Maestro,138.0,['Screen Display'],"Touchscreen Display device
","Gentec-EO is a manufacturer of laser beam measurement technologies
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Gentec/Gentec_Maestro.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Gentec.html#module-qcodes_contrib_drivers.drivers.Gentec.Gentec_Maestro,Gentec Eo,"[OrderedDict([('id', 'attM49N3urZQzbQiJ'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/tYX7aoV2K7x8QOXCgtWE4g/c9xJ6LDofn_tmdIf2vFyuhMFRM4pgGcHm6MRW5kQmhh_GTCLEmbxtnCH18BO4Smin7PmabXFQhV5uB4eq3gCqEBN8mYN13vZqW2nyuskntKnwhTXGrCh3YqRMDrpimoN/2XPUMd03OOks1bUqSXRbaOkPqL8KfTU7aHksKnIS4W0'), ('filename', 'gentec-eo-logo-vector.png'), ('size', 4244), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mYAmm6jimvAO4AeL6HBZYg/3_VhlR336nHhkxBAnqnxoBucV-PlS8sSYniak5Ls94ZFFWU3iGTDZeRlhvlHnGPNpltlPU5t0EG9tcyoUgBUoA/Gz3BL8m4bxuppk7MmunhYdmFlFQ7r78Llv_bqwzXc28'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/lvwcmCOtpljKZ3K25vvEpw/cKl2e2pN17txns4diQJU6mca1YFzJMbEn7LbhYQY7FSKOw1z0ndhOs5eB2y372kj4Dmo6svKjpptr7AC9QpH6Q/3xMxWXZ--ovlNt_0Ac6W6z0uJ2Z21AoJGtjlO3vy6is'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/WAfFmnQAuLec0BlbcwvX5w/P9p1awyX3Xi-JBosrDjGZOzPfLw_q86Em06c3thXJx2KvGldGcqHl1TGgAd55YzKqShZLK8sSI53asG27hlbwA/AdcIB6eUCew-yRyrmYFcuvYk4MS19PE-ah2qzrCL8h8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.gentec-eo.com/,Gentec EO Maestro,Write a Python script that uses Qcodes Community to connect to a Gentec EO Maestro Screen Display,2400.0,,,,"from qcodes import VisaInstrument
from qcodes.utils.helpers import create_on_off_val_mapping


class Gentec_Maestro(VisaInstrument):
    r""""""
    Instrument driver for the Gentec Maestro powermeter.
    Args:
        name (str): Instrument name.
        address (str): ASRL address
        baud_rate (int): Baud rate for the connection.
    Attributes:
        model (str): Model identification.
        firmware_version (str): Firmware version.
    """"""

    def __init__(self, name, address, baud_rate=115200, **kwargs):

        super().__init__(name, address, **kwargs)

        # set baud rate
        self.visa_handle.baud_rate = baud_rate

        # get instrument information
        self.model, _, self.firmware_version = self._query_versions()

        # add parameters
        self.add_parameter('power',
                           get_cmd='*CVU',
                           get_parser=float,
                           label='Power',
                           unit='W')

        def wavelength_get_parser(ans):
            return int(ans[4:])
        self.add_parameter('wavelength',
                           get_cmd='*GWL',
                           set_cmd='*PWC{0:0>5}',
                           get_parser=wavelength_get_parser,
                           label='Wavelength',
                           unit='nm')

        def zero_offset_get_parser(ans):
            return int(ans[5:])
        self.add_parameter('zero_offset_enabled',
                           get_cmd='*GZO',
                           get_parser=zero_offset_get_parser,
                           val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
                           label='Zero offset enabled')

        # print connect message
        self.connect_message()

    # get methods
    def get_idn(self):
        return {'vendor': 'Gentec', 'model': self.model, 'firmware': self.firmware_version}

    # further methods
    def clear_zero_offset(self):
        self.write('*COU')

    def set_zero_offset(self):
        self.write('*SOU')

    def _query_versions(self):
        return self.ask('*VER').split()
"
128,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attjFawHPuZIhCIvm'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Tcao1N7OjTvm_2bwlC4Mwg/aP_f6S0BamNesjU-q2zhpCiS9upeMJsEQxZa-lX-TMeX71Mn8n2gKW1YawqiLrLJeo6MDp0Ago5xU6LIFoeFl6VTXh1kAFB246S_Hky5p0Vwrs0j-78IGUGPjtB67KZO/HmUcO-eyZGv5AC1U4DPugwty6vnSr155Gn7ITTNfyEo'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1NRe1eslamsBwGo5bYw-3w/KIclcvgjqHOkBu-lPO3LKD0vcMBZTFXpxe_yztwHQB3i6YbTxRk1pOjziHHsIPcc4-xJbfsMSvPWNIryXJ-H-w/aLrNaWpAV5bb4JC8Sj8B2bSe8oIW-_1c4Lq_25p84a8'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y4VtEMjAX8RN4wNi43Rv0g/I3WMLg0vmihz1eV3ZvbeGQb1yzQnv-AIDccgh3PMgSICbwPk0UglR0Aa6juUm6EEiRJju8eoRlYKw8s6Ec0eGA/lcU21GVvJ7Bkw-HEqH_WExtJvhjsccUvT-4v5OSqk3k'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sUUfTZ7JxfttdhubXl2_Jw/1CDC8kJyuNM7f2GiyqAAZE4-btZwBvNj_RVfRMC2KyT11RIBr7paLAQIAqHrQgK3jF1CwLCxqzxD941qe_rEaA/dOmd6KSbbHew9ePHQtH-MtkoRnQD0BmYwk7O-MB-Ka0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-102-75F Lab Brick USB programmable 75 Ohm digital attenuator has an input power of up to +30 dBm, and offers frequency coverage of 10 to 1,000 MHz. It has an attenuation range of 95 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-102-75f-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-102-75F,Write a Python script that uses Qcodes Community to connect to a LDA-102-75F ,539.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
131,https://assets-us-01.kc-usercontent.com/ecb176a6-5a2e-0000-8943-84491e5fc8d1/40f0b6d5-bd69-48db-98e8-4276899ca017/RS-ZVL_datasheet.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attVcgMzJB7cmmuql'), ('width', 610), ('height', 325), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/43NNoI-tg8Xv_flqhbrC3Q/EcHcCNkYrsfqdyH3yCB2WFKjWeNrWDe_mx_k4WJD5jDeK0-YcS6dWxgRp67AfPYLTkA-pK3voPiEvGZ7Av-g6cjRR5_FOSfmKMv_jA5KWG8/rqiRsUvtK2SF5RwiIqTM6fmZ3dZhdKlO6tk52tid-Bk'), ('filename', 'ZVL_front.webp'), ('size', 22220), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZtLd1bAJJg8xpNlHspZB-g/fwszaqfC7wFrXE4_zcNzONm2dwKMrUOQl7ijQbYbsX0euX_a9HUOaUAYC87I9Pv1vMoQvlu1suPIdsMwA9_CAR5nfFwRZHG54e3pUrTVUsk/D55GdqIT5fOHP5U_Hu-nhI9SpllZDZvOpqbFAgoedZM'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YPMQzaBm7Ug5lGoKj5ilPA/t5i96nKwb15lWkXOJ6izUmV7sBhNPpuq8_ZHcIDwVAvCwGohktEqqMCN-oK_z7ZmyFyLz8CLxdzIJUWSw7HfZY0BZzst23kY9x0B7n11Wh8/mUuxqOewGoBmRLLHraUVpAIPU4XgopCv_7v75xrm580'), ('width', 610), ('height', 325)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/grVpaG0k0-TA84Mv-lIHog/gzgcq8yJsT_Lel9S9xpLr3BXRx6qwDpFjyUTYdjMIzETZvPn8V48OMA2lrnjsUnorWq8Aka5Wi-Df1iw9fhfMPk9mS9yhylnMzfdK59GdQo/oJVkRbBrUAo5rT034tBcZhrKi_yyXnSroaJyJG6eNC8'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","The ZVL is a compact, cost-efficient, powerful and portable network analyzer. It is ideal for use in development, production, and service. It is the only instrument to combine the functions of a network analyzer, spectrum analyzer, and power meter in a single box, making you much more efficient.",https://www.electrorent.com/us/products/rf-and-microwave-network-analyzers/network-analyzers-%3C20ghz/rohde-and-schwarz/zvl13-1303650913/01t1O00000CkRfYQAV?gad=1&gclid=CjwKCAjw-vmkBhBMEiwAlrMeFwS5rA2XF9_QqijzKPoKvusrvgLdIM74vxkrHWdiBlSznwz6HsQP2BoCz5sQAvD_BwE,ZVL 13,480.0,"['Network Analyzer', 'Power Meters', 'Spectrum Analyzers']",A network analyzer is an instrument that measures the network parameters of electrical networks.,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/ZVL13.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.ZVL13,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,ZVL 13,"Write a Python script that uses Qcodes Community to connect to a {Device name} Network Analyzer, Power Meters, Spectrum Analyzers",,,,,"from typing import Any
import logging
from functools import partial
from typing import Optional

import numpy as np

from qcodes.utils.validators import Enum, Strings, Ints
from qcodes import VisaInstrument, Instrument
from qcodes import MultiParameter, ArrayParameter


log = logging.getLogger(__name__)


class FrequencySweepMagPhase(MultiParameter):

    def __init__(self, name: str, instrument: Instrument,
                 start: float, stop: float, npts: int, channel: int, **kwargs) -> None:
        super().__init__(name, names=("""", """"), shapes=((), ()), **kwargs)
        self._instrument = instrument
        self.set_sweep(start, stop, npts)
        self._channel = channel
        self.names = ('magnitude',
                      'phase')
        self.labels = (f'{instrument.short_name} magnitude',
                       f'{instrument.short_name} phase')
        self.units = ('', 'rad')
        self.setpoint_units = (('Hz',), ('Hz',))
        self.setpoint_labels = (
            (f'{instrument.short_name} frequency',),
            (f'{instrument.short_name} frequency',)
        )
        self.setpoint_names = (
            (f'{instrument.short_name}_frequency',),
            (f'{instrument.short_name}_frequency',)
        )


    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self):
        old_format = self._instrument.format()
        self._instrument.format('Complex')
        data = self._instrument._get_sweep_data(force_polar=True)
        self._instrument.format(old_format)
        return abs(data), np.angle(data)


class FrequencySweep(ArrayParameter):

    def __init__(self, name: str, instrument: Instrument,
                 start: float, stop: float, npts: int, channel: int, **kwargs) -> None:
        super().__init__(name, shape=(npts,),
                         instrument=instrument,
                         unit='dB',
                         label=f'{instrument.short_name} magnitude',
                         setpoint_units=('Hz',),
                         setpoint_labels=(f'{instrument.short_name}'
                                          ' frequency',),
                         setpoint_names=(f'{instrument.short_name}_frequency',),
                         **kwargs,
                         )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:

        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = (f,)
        self.shape = (npts,)

    def get_raw(self):
        data = self._instrument._get_sweep_data()
        if self._instrument.format() in ['Polar', 'Complex',
                                         'Smith', 'Inverse Smith']:
            log.warning(""QCoDeS Dataset does not currently support Complex ""
                        ""values. Will discard the imaginary part. In order to ""
                        ""acquire phase and amplitude use the ""
                        ""FrequencySweepMagPhase parameter."")
        return data


class ComplexSweep(ArrayParameter):
    def __init__(self, name: str, instrument: Instrument,
                 start: float, stop: float, npts: int, channel:int, **kwargs) -> None:
        super().__init__(name, shape=(npts,),
                         instrument=instrument,
                         unit='dB',
                         label=f'{instrument.short_name} magnitude',
                         setpoint_units=('Hz',),
                         setpoint_labels=(f'{instrument.short_name}'
                                          ' frequency',),
                         setpoint_names=(f'{instrument.short_name}_frequency',),
                         **kwargs,
                         )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        f = tuple(np.linspace(int(start), int(stop), num=2*npts))
        self.setpoints = (f,)
        self.shape = (2*npts,)

    def get_raw(self):
        data = self._instrument._get_sweep_data(force_polar=True)
        if self._instrument.format() in ['Polar', 'Complex',
                                         'Smith', 'Inverse Smith']:
            log.warning(""QCoDeS Dataset does not currently support Complex ""
                        ""values. Will discard the imaginary part. In order to ""
                        ""acquire phase and amplitude use the ""
                        ""FrequencySweepMagPhase parameter."")
        return data
    

class SAFrequencySweep(ArrayParameter):
    def __init__(self, name: str, instrument: Instrument,
                 start: float, stop: float, npts: int, channel: int, **kwargs) -> None:
        super().__init__(name, shape=(npts,),
                         instrument=instrument,
                         unit='dBm',
                         label=f'{instrument.short_name} magnitude',
                         setpoint_units=('Hz',),
                         setpoint_labels=(f'{instrument.short_name}'
                                          ' frequency',),
                         setpoint_names=(f'{instrument.short_name}_frequency',),
                         **kwargs,
                         )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:

        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = (f,)
        self.shape = (npts,)

    def get_raw(self):
        data = self._instrument._get_sweep_data_SA()
        return data


class ZVL13(VisaInstrument):
    def __init__(
            self,
            name: str,
            address: str,
            terminator='\n',
            **kwargs: Any):
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(name='mode',
                           label='VNA Mode',
                           get_cmd=self._get_mode,
                           set_cmd=self._set_mode,
                           get_parser=str)

        mode = self.mode.get()
        if mode == 'SAN':
            n = int(1)
            self._tracename = 'Trc1'
        if mode == 'NWA':
            _, trace_name = self._get_trace_name()
            self._tracename = trace_name

        self.inf_lim = 9e+3
        
        self.sup_lim = 13.6e+9

        self.timeout_sweep = 40
        self.timeout_sa = 40

        self.add_parameter('start',
                           get_cmd='FREQ:STAR?',
                           get_parser=float,
                           set_cmd=self._set_start,
                           unit = 'Hz',
                           label='Start Frequency')
        
        self.add_parameter('stop',
                           get_cmd='FREQ:STOP?',
                           get_parser=float,
                           set_cmd=self._set_stop,
                           unit = 'Hz',
                           label='Stop Frequency')
        
        self.add_parameter('center',
                           get_cmd='FREQ:CENT?',
                           get_parser=float,
                           set_cmd=self._set_center,
                           unit = 'Hz',
                           label='Center Frequency')
        
        self.add_parameter('span',
                            get_cmd='FREQ:SPAN?',
                            get_parser=float,
                            set_cmd=self._set_span,
                            unit = 'Hz',
                            label='Center Frequency')
        
        self.add_parameter('npts',
                           get_cmd='SWE:POIN?',
                           get_parser=int,
                           set_cmd=self._set_npts,
                           label='Number of points')
        
        self.add_parameter('power',
                            get_cmd='SOUR:POW?',
                            get_parser=float,
                            set_cmd=self._set_power,
                            unit = 'dBm',
                            label='Power')
        
        self.add_parameter('format',
                            vals=Strings(),
                            get_cmd=partial(self._get_format,
                                            tracename=self._tracename),
                            set_cmd=self._form,
                            label='Format')        
        
        self.add_parameter('avg',
                            get_parser=int,
                            vals=Ints(1, 5000),
                            get_cmd='AVER:COUN?',
                            set_cmd=self._average,
                            label='Averages')
        
        self.add_parameter(name='num_ports',
                           get_cmd='INST:PORT:COUN?',
                           get_parser=int)
        
        self.add_parameter(name='S_parameter',
                           label='S parameter',
                           get_cmd=f""CALC:PAR:MEAS? '{self._tracename}'"",
                           set_cmd=self._set_s_parameter,
                           vals=Strings())
        
        self.add_parameter(name='trace_mag_phase',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           channel = n,
                           parameter_class=FrequencySweepMagPhase)
        
        self.add_parameter(name='trace',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           channel = n,
                           parameter_class=FrequencySweep)
        
        self.add_parameter(name='S_trace',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           channel = n,
                           parameter_class=ComplexSweep)
        
        self.add_parameter(name='spectrum',
                           start=self.start(),
                           stop=self.stop(),
                           npts=self.npts(),
                           channel = n,
                           parameter_class=SAFrequencySweep)
        
        self.add_parameter(name='status',
                            get_cmd='CONF:CHAN1:STAT?',
                            set_cmd='CONF:CHAN1:STAT {{}}',
                            get_parser=int)
        
        self.add_parameter(name='rf_power',
                            get_cmd='OUTP?',
                            set_cmd=self._set_rf_power,
                            get_parser=int)
        
        self.add_parameter(name='bandwidth',
                           label='Bandwidth',
                           unit='Hz',
                           get_cmd='SENS:BAND?',
                           set_cmd=self._set_bandwidth,
                           get_parser=int)
        
        self.add_parameter(name='freq_step',
                           label='Frequency step size',
                           unit='Hz',
                           get_cmd='SENS:SWE:STEP?',
                           set_cmd=self._set_freq_step,
                           get_parser=int)

        self.calibration_file = 'Cal_17_11_2021.cal'
        
        self.add_function('autoscale', call_cmd = 'DISP:WIND:TRAC:Y:AUTO ONCE')

        self.add_function('electrical_delay_auto',
                          call_cmd='CORR:EDEL:AUTO ONCE')
        self.add_function('data_to_mem',
                          call_cmd='CALC:MATH:MEM')
        self.add_function('cont_meas_on',
                          call_cmd='INIT:CONT:ALL ON')
        self.add_function('cont_meas_off',
                          call_cmd='INIT:CONT:ALL OFF')

    def reset(self):
        self.write(""*RST"")

    def calibration(self):
        """"""
        Loads calibration file as specified by ``self.calibration_file``.
        """"""
        self.write(f""MMEMory:LOAD:CORRection 1, '{self.calibration_file}'"")

    def _get_mode(self):
        mode_raw = ((self.ask('INST?')).split('\n')[0]).strip()
        mode_mapping = {
            ""SAN"": ""sa"",
            ""NWA"": ""na"",
        }
        return mode_mapping[mode_raw]

    def _set_mode(self, mode: str):
        if mode == 'sa':
            self.sa_mode()
        elif mode == 'na':
            self.na_mode()
        else:
            raise AttributeError(
                'Wrong string. To set in Spectrum Analyzer mode write ""sa"", to set in Network Analyzer mode write ""na"".'
            )

    def sa_mode(self):
        self.write('INST SAN')
        n = int(1)
        self._tracename = 'Trc1'
        self.mode.cache.set(""sa"")

    def na_mode(self):
        self.write('INST NWA')

        _, trace_name = self._get_trace_name()
        self._tracename = trace_name

        self.mode.cache.set(""na"")

    def _get_trace_catalog(self):
        return self.ask(""CONFigure:TRACe:CATalog?"").split(',')

    def _get_trace_name(self):
        trace_catalog = self._get_trace_catalog()
        if len(trace_catalog) == 2:            
            ch, trace_name = trace_catalog
            n = ch[1]
            trace_name = trace_name[:-1]
        else:
            n = trace_catalog[0][1]
            trace_name = trace_catalog[1]
        return n, trace_name

    def _set_freq_step(self, n: int):
        min_step = (self.stop_f() - self.start_f())/(4001)
        max_step = (self.stop_f() - self.start_f())/1 

        if n>min_step and n<max_step:
            self.write(""SENS:SWE:STEP "" + str(n))
            self.update_traces()
        else:
            raise AttributeError('Step size must be in the range between' + str(min_step) +' Hz and ' + str(max_step) + ' Hz.')

    def _set_npts(self, n: int) -> None:
        self.write(""SWE:POIN "" + str(n))
        self.update_traces()
        
    def _set_s_parameter(self, msg: str) -> None:
        S_params = ['S11','S12','S21','S22']

        if msg in S_params:
            self.write(f""CALC:PAR:MEAS '{self._tracename}', '{msg}'"")
        else: 
            raise AttributeError('Illegal string. Allowed S parameters: S11, S12, S21, S22')

    def _set_bandwidth(self, val:int) -> None:
        if val <= 10e6 and val > 10:
            self.write('SENS:BAND '+str(int(val)))
        else: 
            raise AttributeError('Bandwidth value out of range')
        
    def _set_rf_power(self, val: int) -> None:
        if val == 0:
            self.write('OUTP OFF')
        elif val == 1: 
            self.write('OUTP ON')
        else:
            raise AttributeError('Write 1 to switch on and 0 to switch off')

    def _get_format(self, tracename: str) -> str:
        return self.ask(""CALC:FORM?"")

    def _form(self, msg:str) -> None:
        if msg == 'phase':                
            self.write('CALC:FORM PHAS')
        elif msg == 'dbm':
            self.write('CALC:FORM MLOG')
        elif msg == 'polar':                
            self.write('CALC:FORM POL')          
        elif msg == 'swr':                
            self.write('CALC:FORM SWR')
        elif msg == 'magnitude':
            self.write('CALC:FORM MLIN')            
        elif msg == 'real':                
            self.write('CALC:FORM REAL')
        elif msg == 'img':
            self.write('CALC:FORM IMAG')
        elif msg == 'unwrapped phase':                
            self.write('CALC:FORM UPH')
        elif msg == 'smith':
            self.write('CALC:FORM SMIT')
        elif msg == 'data/mem':
            self.data_to_mem()
            self.write('CALC:MATH:FUNC DIV')
        else:
            raise AttributeError(
                'Format does not exist. Choose one of the following: '
                'dbm, phase, polar, swr, magnitude, real, img, unwrapped phase, smith, data/mem'
            )

    def _average(self, num:float) -> None:
        self.write('AVER:STAT OFF')
        self.write('AVER:COUN ' + str(int(num)))
        self.write('AVER:STAT ON')
        self.write('AVER:CLE')
            
    def _set_start(self, val: float):
        start = val
        stop = self.stop()
        if start >= stop:
            raise ValueError(""Stop frequency must be larger than start frequency."")
        else:
            self.write('FREQ:STAR '+ str(int(start)))

        self.update_traces()
                
    def _set_stop(self, val: float):
        stop = val
        start = self.start()
        if stop <= start:
            raise ValueError(""Stop frequency must be larger than start frequency."")
        else:
            self.write('FREQ:STOP '+ str(int(stop)))

        self.update_traces()
                
    def _set_center(self, val: float):
        center = val

        if center <= self.inf_lim or center >= self.sup_lim:
            raise ValueError(""Out of the VNA limit."")
        else:
            self.write('FREQ:CENT '+ str(int(center)))

        self.update_traces()

    def _set_span(self, val: float):
        span = val   
        center = self.center()

        if center + span * 0.5 >= self.sup_lim or center - span * 0.5 <= self.inf_lim:
            raise ValueError(""Out of the VNA limit."")
        else:        
            self.write('FREQ:SPAN '+ str(int(span)))

        self.update_traces()

    def _set_power(self, val: float):        
        if val > 0:
            raise ValueError(
                ""Attenuation cannot be positive."")
        elif val < -40:
            raise ValueError(""Unleveled power"")
        else:
            self.write('SOUR:POW ' + str(int(val)))

    def _get_sweep_data(self, force_polar: bool = False):
        if force_polar:
            data_format_command = 'SDAT'
        else:
            data_format_command = 'FDAT'

        self.write('SENS:AVER:STAT ON')
        self.write('SENS:AVER:CLE')

        # preserve original state of the znb
        with self.status.set_to(1):
            self.root_instrument.cont_meas_off()
            try:
                with self.root_instrument.timeout.set_to(self.timeout_sweep):
                    self.write('SENS:SWEEP:COUNT '+ str(self.avg()))
                    self.write('INIT:IMMEDIATE:SCOPE:SINGLE')                        
                    self.write('INIT:CONT OFF')
                    self.write('INIT:IMM; *WAI')
                    self.write(""CALC:PAR:SEL '{self._tracename}'"")
                    data_str = self.ask(f'CALC:DATA? {data_format_command}')

                data = np.array(data_str.rstrip().split(',')).astype('float64')
            finally:
                self.root_instrument.cont_meas_on()
        return data

    def _get_sweep_data_SA(self):
        self.write('SENS:AVER:STAT ON')
        self.write('SENS:AVER:CLE')

        self.root_instrument.cont_meas_off()
        try:
            with self.root_instrument.timeout.set_to(self.timeout_sa):
                self.write('SENS:SWEEP:COUNT '+ str(self.avg()))
                self.write('INIT:IMMEDIATE:SCOPE:SINGLE')                        
                self.write('INIT:CONT OFF')
                self.write('INIT:IMM; *WAI')
                data_str = self.ask('FORM ASC;TRAC? TRACE1')

            data = np.array(data_str.rstrip().split(',')).astype('float64')
        finally:
            self.root_instrument.cont_meas_on()
        return data

    def update_traces(self):
        start = self.start()
        stop = self.stop()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, (ArrayParameter, MultiParameter)):
                try:
                    parameter.set_sweep(start, stop, npts)
                except AttributeError:
                    pass
"
134,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attjFawHPuZIhCIvm'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Tcao1N7OjTvm_2bwlC4Mwg/aP_f6S0BamNesjU-q2zhpCiS9upeMJsEQxZa-lX-TMeX71Mn8n2gKW1YawqiLrLJeo6MDp0Ago5xU6LIFoeFl6VTXh1kAFB246S_Hky5p0Vwrs0j-78IGUGPjtB67KZO/HmUcO-eyZGv5AC1U4DPugwty6vnSr155Gn7ITTNfyEo'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1NRe1eslamsBwGo5bYw-3w/KIclcvgjqHOkBu-lPO3LKD0vcMBZTFXpxe_yztwHQB3i6YbTxRk1pOjziHHsIPcc4-xJbfsMSvPWNIryXJ-H-w/aLrNaWpAV5bb4JC8Sj8B2bSe8oIW-_1c4Lq_25p84a8'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y4VtEMjAX8RN4wNi43Rv0g/I3WMLg0vmihz1eV3ZvbeGQb1yzQnv-AIDccgh3PMgSICbwPk0UglR0Aa6juUm6EEiRJju8eoRlYKw8s6Ec0eGA/lcU21GVvJ7Bkw-HEqH_WExtJvhjsccUvT-4v5OSqk3k'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sUUfTZ7JxfttdhubXl2_Jw/1CDC8kJyuNM7f2GiyqAAZE4-btZwBvNj_RVfRMC2KyT11RIBr7paLAQIAqHrQgK3jF1CwLCxqzxD941qe_rEaA/dOmd6KSbbHew9ePHQtH-MtkoRnQD0BmYwk7O-MB-Ka0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-2N Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 90 dB and a step size of 2.0 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software. ",https://vaunix.com/lda-302p-2n-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-2N,Write a Python script that uses Qcodes Community to connect to a LDA-302P-2N ,639.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
139,https://www.keysight.com/us/en/assets/7018-02222/data-sheets/5990-4327.pdf,https://www.keysight.com/us/en/products/spectrum-analyzers-signal-analyzers/x-series-signal-analyzers.html,"[OrderedDict([('id', 'attprLCdip5zIq9LN'), ('width', 1164), ('height', 528), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RqGSv4kwr_e9aJAFMIFEsw/q5LDVRCb4JSxcif-3XQofA4_FP5SKBD_W2mX3wJTjY4vwDFllJjU78dW4ZOrY1wkGFfgmRzEj2epLzYDis7Y7gDdcC-3MvoCYJ9FQpmRrds/SbPanc1oLVI5KwQ6l-pjuyJIcsQO0BT-A5VxGzBRTsE'), ('filename', 'N9000A.png'), ('size', 523353), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/taBI5AWB10G5k_af02Ugvw/g_7B5oQ5mXpxXdbwE4ZryJEQ0XpueqxQYRaOVKn94vtgyQhEJ3WlqDDxIJmGufDCYkN1XPhhaT-9Ifs_J4cMmw/Kw_IVI2_ZKqfnydRZlUWkBjRrmMwbSLLoPhy9rjD7Y0'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XDj2Yto0i742h91G2QVkvw/ue-X5Z4uBEOozGs8zdPHEeIzIG5Zum3aT1nMlFN2ogxLe0z8e82w8XlyIb08_OeZpoaqlzKcYcWlbZsJE84yTw/snRz6MbwQcMzGWUtoPVBRhI4lBGivHlSauciaRsK3lw'), ('width', 1129), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GMEvhj3jXbcIyPMDK5rCEg/PZL3mABZoj70Sa-ylye9p4P9BBhTefTWFRczPyiDYWnzG_0spxJ1G5BkXRBAy0eAbc-g0fw-9-cjfRw_6Me4XQ/q3FtXYMD93OLUm4WlAUakJ8vmlaSSJtyIrEOfWQjyoo'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"N9000A CXA Signal Analyzer, 9 kHz to 26.5 GHz
",https://www.keysight.com/us/en/product/N9000A/cxa-signal-analyzer-9khz-26-5ghz.html,Agilent N 9000 A,23.0,['Spectrum Analyzers'],"This starts with accessible performance, which is at the heart of every X-Series signal analyzer (spectrum analyzer). They put you closer to the signal analysis (spectrum analysis) answer by easily linking cause and effect. Across the full spectrum — from our CXA to our UXA — you will find the signal analysis (spectrum analysis) tools you need to design, test, and deliver your next breakthrough.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Agilent/Agilent_N9000A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Agilent.html#module-qcodes_contrib_drivers.drivers.Agilent.Agilent_N9000A,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hFdxirqR4naQeu68ZH6Diw/pR2x86JkyJkKajinRBXTY4BfCp1zHWliufEuMVSVwd_Bb8q9Xg5mIhg8LdwdB21HH7QPsOWe2gdG2-8E_K3TCcLLWHiV-5IzHfOwsVJEfUM/6bWPjBr-7t6KWFsj0hRtBfmws86LpokMC6uwSDQiyVk'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sv2aXGjIO_NWGxLBVHDvUA/kX3YP6PUOD32fNPAiPlir0pEI8PtoKF_xEVpb_8EruYAfaSYN1oQkiX-dadfMvCbTuoC77q9MvgC9OJ70n-xCgBUcAMQro0L5mruHr9uUqM/gWdTBrZyGkudHsMIlPowkD0t2KiAXnNV1zYIeH5oQK8'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qCPaUTY4BSpIl2Kwu9iZiQ/_fgWV7vpYVssr7JngXR1lp_e6NwNH3ImbHVu0nngWj6Bm7v2Dix2oMCG24VSmnbpOKTKz3PQ4SRP3mk6TU6bN5VuRdeDJntxunvPdtP6W8k/haT25_aQKzsRnu7tEG4rR-QQs5F5JOKd2wyqoV0V9-U'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gRf7rPY4f63YgJW8ROCMzw/9-wG6wSXxbBm0Evy9Wqdswt20_CLGxy0yUt5udG1g1IZmupoeXTirkCAn6BhWEzG0a366OQUBo7C_h2cufRriQOrWRCUjp4leZR3zqD4hPs/PLmSdEQB1Q9VE70JBKhAVc7RfFfiJYRAKe9smWOk4TE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT N9000A,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT N9000A Spectrum Analyzers,14000.0,"
",,,"# This Python file uses the following encoding: utf-8
# Etienne Dumur <etienne.dumur@gmail.com>, august 2020


from qcodes import VisaInstrument
from qcodes.utils.validators import Numbers


class Agilent_N9000A(VisaInstrument):
    """"""
    This is the QCoDeS python driver for the Agilent CXA N9000A power spectrum
    analyzer.
    """"""


    def __init__(self, name       : str,
                       address    : str,
                       terminator : str=""\n"",
                       **kwargs):
        r""""""
        QCoDeS driver for the power spectrum analyzer Agilent N9000A.

        Args:
            name (str): Name of the instrument.
            address (str): Address of the instrument.
            terminator (str, optional, by default ``""\n""``): Terminator character of
                the string reply.
        """"""


        super().__init__(name       = name,
                         address    = address,
                         terminator = terminator,
                         **kwargs)


        self.add_function('reset', call_cmd='*RST')


        self.add_parameter(name       = 'rf_center_frequency',
                           unit       = 'GHz',
                           get_parser = float,
                           set_cmd    = ':sense:frequency:rf:center {} GHz',
                           get_cmd    = ':sense:frequency:rf:center?',
                           docstring  = 'The RF center frequency',
                           vals       = Numbers(9e-6, 3)
                           )

        self.add_parameter(name       = 'video_bandwidth',
                           unit       = 'MHz',
                           get_parser = float,
                           set_cmd    = ':sense:chpower:bandwidth:video {} MHz',
                           get_cmd    = ':sense:chpower:bandwidth:video?',
                           docstring  = 'The analyzer post-detection filter (VBW)'
                           )

        self.add_parameter(name       = 'resolution_bandwidth',
                           unit       = 'MHz',
                           get_parser = float,
                           set_cmd    = ':sense:chpower:bandwidth:resolution {} MHz',
                           get_cmd    = ':sense:chpower:bandwidth:resolution?',
                           docstring  = 'The resolution bandwidth'
                           )

        self.add_parameter(name       = 'power',
                           unit       = 'dBm',
                           get_parser = lambda val, output='power' : self.power_parser(val, output),
                           get_cmd    = ':initiate:chpower; :fetch:chpower?',
                           docstring  = 'Absolute power at the RF center frequency'
                           )

        self.add_parameter(name       = 'power_spectral_density',
                           unit       = 'dBm/Hz',
                           get_parser = lambda val, output='psd' : self.power_parser(val, output),
                           get_cmd    = ':initiate:chpower; :fetch:chpower?',
                           docstring  = 'Power Spectral Density at the RF center frequency'
                           )
        
        self.connect_message()



    def power_parser(self, val: str, output: str) -> float:
        """"""
        Parse the reply from a strin containing 'power, psd' to float depending
        of the output.

        Args:
            val (str): Reply of the power spectral analyzer.
            output (str): Desired output format.

        Returns:
            power or power spectral density (float):
                power in dBm.
                power spectral density in dBm/Hz.
        """"""
        
        power, psd = val.split(',')
        
        if output=='power':
            return float(power)
        elif output=='psd':
            return float(psd)
        else: 
            return 0.
"
143,https://www.thorlabs.com/_sd.cfm?fileName=ETN015302-D02.pdf&partNumber=K10CR1/M,,"[OrderedDict([('id', 'attlzCWPu5WLQ2KHM'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Cz67NGjAeOsXr2Ac_-nPGA/PSK8nTu8sdfZarGJ3Mij-McGjF3Sl1JeSL4lF4k8--GQtYwXkZovc2-ZZbzxA6UPuq1yBVbQjZRebLMccJTWSI-qgdMo1INne0Nv9K5mSuA/ZPK-HDYx8WrOx7vVgcfwCH8-l_Akr-l5afXYg2HSa7w'), ('filename', 'ETN015303-xl.jpg'), ('size', 46688), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/EL-hxUZ_bs9vcvP_7-XqJg/iwd7mpU-vyWrKLRXM817AQ5lOcflaiFpqeRm0fbIm53WzSZM0P9iXgcuJ7xHuGs4NTRUeRsGvZ9GXkDLLIbpyQ/ArqRzahQTYNwhvYTfrBvFdVf5GzE_vEQZnvy3LgebfA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/jr1ZHQl3psWC_Z3j_44YBw/tpSJIIjF5NnsIrMTEeCa2-tfVs6LZ7qdLapNl6qA6oLsXfxfDlhiuSdcybicu97zHghX08SAr7hxQpZ8WqE3ig/AaiRdAuSNGHZ3AmSV2hGAkA2TjUbHPOXQEA7elxcNr8'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CxtDmi2L2KWvTKQIPzZJzQ/SE2ClMHWxpfOzQnGE20AAxFH3oSucJWPqLsvCxetX__D67FYicPgJW5ScSZkhmNYFyWPZ859rK1d_7n-V9ZDQg/ISmcXm1a89D6tvn3HLV78LxjVH3biFrATON1MqYZRuM'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,"The Kinesis K10CR1 is a compact, precision motorized rotation mount that accepts
Ø1"" optics and SM1-threaded components. It is also compatible with our 30 mm cage
systems (and 60 mm cage systems when used with adapter K10CR1A3)",https://www.thorlabs.com/drawings/5b93b1b36a318298-C04D2EB0-B3AB-5DFC-E6B2C996E0FF2E39/K10CR1-ManualforAPT.pdfhttps://www.thorlabs.com/_sd.cfm?fileName=ETN015302-D02.pdf&partNumber=K10CR1/M,K 10 CR 1,614.0,['Motion'],,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Thorlabs/K10CR1.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Thorlabs_K10CR1.ipynb,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CvgXbArkB27mn-PsYJbdKA/jsnVknsEqxjTF3CFPCLxHvs66QnCiYZlrKfOcYSKT0xlShMdVypaziFjxP-GbYNg2o2nq76d9Ht5yM4bP9o2TDL67EuBfoXyvODtMPd3CPc/E_KBqkl6cDSDcDXfLtNSq5XkXPqT9aqGVwHXLIwRZek'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Jfn9nSRvZW7vWKd0MIGCvw/-b0s1tsK7Jr-okNRoo-YO9QnD1OhX3my9LS0kawwb4B0pjtBcsNrUw35bHRIN8hLpo5Oj2XnkkGAgG3_47sDwA/fJoXn-ks6nJSad3lfq8kIYH241PfMgw8cN7nzjpqa7E'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/V12sgCHA4vKGEDSNnRvERg/BbUh5Ie3dcStXKs6vv_18n-FHe_g8pF8MVKEv_0qvX6r48VA9MCJpV8Rh5euFmU9Bgh7IEU3avXmcSj1WE-bBg/mw8N06nvz-TE83u6CHhkKd3g7QenZawZ2_mNg2PxIfU'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wu3UZ6gHLFH9ebCWIFbGUA/zfw97WSqJfvW-RxyEC9uihliGkYCpT-Ow3ZyWL5IDD6kLAlqBxTb2UoOQxP_cWhF6-yYkE5W0iI53rUuOkwd6A/8gmlAC3gkDu2TyIIbcFvdDygRU8DhgE2_mEfIzF3OaY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,K10CR1,Write a Python script that uses Qcodes Community to connect to a K10CR1 Motion,1501.21,,,,"import enum
from typing import Tuple, Optional

import qcodes.utils.validators as vals
from qcodes import Instrument

from .APT import Thorlabs_APT, ThorlabsHWType


class RotationDirection(enum.Enum):
    """"""Constants for the rotation direction of Thorlabs K10CR1 rotator""""""
    FORWARD = ""fwd""
    REVERSE = ""rev""


class HomeLimitSwitch(enum.Enum):
    """"""Constants for the home limit switch of Thorlabs K10CR1 rotator""""""
    REVERSE = ""rev""
    FORWARD = ""fwd""


class Thorlabs_K10CR1(Instrument):
    """"""
    Instrument driver for the Thorlabs K10CR1 rotator.

    Args:
        name: Instrument name.
        device_id: ID for the desired rotator.
        apt: Thorlabs APT server.

    Attributes:
        apt: Thorlabs APT server.
        serial_number: Serial number of the device.
        model: Model description.
        version: Firmware version.
    """"""

    def __init__(self, name: str, device_id: int, apt: Thorlabs_APT, **kwargs):
        super().__init__(name, **kwargs)

        # Save APT server reference
        self.apt = apt

        # initialization
        self.serial_number = self.apt.get_hw_serial_num_ex(ThorlabsHWType.K10CR1, device_id)
        self.apt.init_hw_device(self.serial_number)
        self.model, self.version, _ = self.apt.get_hw_info(self.serial_number)

        # Set velocity and move-home parameters to previous values. Otherwise the velocity is very
        # very low and it is not the velocity stored in the parameters... For whatever reason?
        self._set_velocity_parameters()
        self._set_home_parameters()

        # Helpers
        direction_val_mapping = {RotationDirection.FORWARD: 1,
                                 RotationDirection.FORWARD.value: 1,
                                 RotationDirection.REVERSE: 2,
                                 RotationDirection.REVERSE.value: 2}
        lim_switch_val_mapping = {HomeLimitSwitch.REVERSE: 1,
                                  HomeLimitSwitch.REVERSE.value: 1,
                                  HomeLimitSwitch.FORWARD: 4,
                                  HomeLimitSwitch.FORWARD.value: 4}

        # PARAMETERS
        # Position
        self.add_parameter(""position"",
                           get_cmd=self._get_position,
                           set_cmd=self._set_position,
                           vals=vals.Numbers(0, 360),
                           unit=u""\u00b0"",
                           label=""Position"")
        self.add_parameter(""position_async"",
                           get_cmd=None,
                           set_cmd=self._set_position_async,
                           vals=vals.Numbers(0, 360),
                           unit=u""\u00b0"",
                           label=""Position"")

        # Velocity Parameters
        self.add_parameter(""velocity_min"",
                           set_cmd=self._set_velocity_min,
                           get_cmd=self._get_velocity_min,
                           vals=vals.Numbers(0, 25),
                           unit=u""\u00b0/s"",
                           label=""Minimum Velocity"")
        self.add_parameter(""velocity_acceleration"",
                           set_cmd=self._set_velocity_acceleration,
                           get_cmd=self._get_velocity_acceleration,
                           vals=vals.Numbers(0, 25),
                           unit=u""\u00b0/s\u00b2"",
                           label=""Acceleration"")
        self.add_parameter(""velocity_max"",
                           set_cmd=self._set_velocity_max,
                           get_cmd=self._get_velocity_max,
                           vals=vals.Numbers(0, 25),
                           unit=u""\u00b0/s"",
                           label=""Maximum Velocity"")

        # Move home parameters
        self.add_parameter(""move_home_direction"",
                           set_cmd=self._set_home_direction,
                           get_cmd=self._get_home_direction,
                           val_mapping=direction_val_mapping,
                           label=""Direction for Moving Home"")
        self.add_parameter(""move_home_limit_switch"",
                           set_cmd=self._set_home_lim_switch,
                           get_cmd=self._get_home_lim_switch,
                           val_mapping=lim_switch_val_mapping,
                           label=""Limit Switch for Moving Home"")
        self.add_parameter(""move_home_velocity"",
                           set_cmd=self._set_home_velocity,
                           get_cmd=self._get_home_velocity,
                           vals=vals.Numbers(0, 25),
                           unit=u""\u00b0/s"",
                           label=""Velocity for Moving Home"")
        self.add_parameter(""move_home_zero_offset"",
                           set_cmd=self._set_home_zero_offset,
                           get_cmd=self._get_home_zero_offset,
                           vals=vals.Numbers(0, 360),
                           unit=u""\u00b0"",
                           label=""Zero Offset for Moving Home"")

        # FUNCTIONS
        # Stop motor
        self.add_function(""stop"",
                          call_cmd=self._stop,
                          args=[])

        # Moving direction
        self.add_function(""move_direction"",
                          call_cmd=self._move_direction,
                          args=[vals.Enum(*direction_val_mapping)],
                          arg_parser=lambda val: direction_val_mapping[val])

        # Enable/disable
        self.add_function(""enable"",
                          call_cmd=self._enable,
                          args=[])
        self.add_function(""disable"",
                          call_cmd=self._disable,
                          args=[])

        # Move home
        self.add_function(""move_home"",
                          call_cmd=self._move_home,
                          args=[])
        self.add_function(""move_home_async"",
                          call_cmd=self._move_home_async,
                          args=[])

        # print connect message
        self.connect_message()

    def get_idn(self):
        """"""Returns hardware information of the device.""""""
        return {""vendor"": ""Thorlabs"", ""model"": self.model,
                ""firmware"": self.version, ""serial"": self.serial_number}

    def _get_position(self) -> float:
        return self.apt.mot_get_position(self.serial_number)

    def _set_position(self, position: float):
        self.apt.mot_move_absolute_ex(self.serial_number, position, True)

    def _set_position_async(self, position: float):
        self.apt.mot_move_absolute_ex(self.serial_number, position, False)

    def _get_velocity_parameters(self) -> Tuple[float, float, float]:
        return self.apt.mot_get_velocity_parameters(self.serial_number)

    def _set_velocity_parameters(self,
                                 min_vel: Optional[float] = None, accn: Optional[float] = None, max_vel: Optional[float] = None):
        if min_vel is None or accn is None or max_vel is None:
            old_min_vel, old_accn, old_max_vel = self._get_velocity_parameters()
            if min_vel is None:
                min_vel = old_min_vel
            if accn is None:
                accn = old_accn
            if max_vel is None:
                max_vel = old_max_vel
        return self.apt.mot_set_velocity_parameters(self.serial_number, min_vel, accn, max_vel)

    def _get_velocity_min(self) -> float:
        min_vel, _, _ = self._get_velocity_parameters()
        return min_vel

    def _set_velocity_min(self, min_vel: float):
        self._set_velocity_parameters(min_vel=min_vel)

    def _get_velocity_acceleration(self) -> float:
        _, accn, _ = self._get_velocity_parameters()
        return accn

    def _set_velocity_acceleration(self, accn: float):
        self._set_velocity_parameters(accn=accn)

    def _get_velocity_max(self) -> float:
        _, _, max_vel = self._get_velocity_parameters()
        return max_vel

    def _set_velocity_max(self, max_vel: float):
        self._set_velocity_parameters(max_vel=max_vel)

    def _get_home_parameters(self) -> Tuple[int, int, float, float]:
        return self.apt.mot_get_home_parameters(self.serial_number)

    def _set_home_parameters(self, direction: Optional[int] = None, lim_switch: Optional[int] = None,
                             velocity: Optional[float] = None, zero_offset: Optional[float] = None):
        if direction is None or lim_switch is None or velocity is None or zero_offset is None:
            old_direction, old_lim_switch, old_velocity, old_zero_offset = self._get_home_parameters()
            if direction is None:
                direction = old_direction
            if lim_switch is None:
                lim_switch = old_lim_switch
            if velocity is None:
                velocity = old_velocity
            if zero_offset is None:
                zero_offset = old_zero_offset

        return self.apt.mot_set_home_parameters(self.serial_number,
                                                direction, lim_switch, velocity, zero_offset)

    def _get_home_direction(self) -> int:
        direction, _, _, _ = self._get_home_parameters()
        return direction

    def _set_home_direction(self, direction: int):
        self._set_home_parameters(direction=direction)

    def _get_home_lim_switch(self) -> int:
        _, lim_switch, _, _ = self._get_home_parameters()
        return lim_switch

    def _set_home_lim_switch(self, lim_switch: int):
        self._set_home_parameters(lim_switch=lim_switch)

    def _get_home_velocity(self) -> float:
        _, _, velocity, _ = self._get_home_parameters()
        return velocity

    def _set_home_velocity(self, velocity: float):
        self._set_home_parameters(velocity=velocity)

    def _get_home_zero_offset(self) -> float:
        _, _, _, zero_offset = self._get_home_parameters()
        return zero_offset

    def _set_home_zero_offset(self, zero_offset: float):
        self._set_home_parameters(zero_offset=zero_offset)

    def _stop(self):
        self.apt.mot_stop_profiled(self.serial_number)

    def _move_direction(self, direction: int):
        self.apt.mot_move_velocity(self.serial_number, direction)

    def _enable(self):
        self.apt.enable_hw_channel(self.serial_number)

    def _disable(self):
        self.apt.disable_hw_channel(self.serial_number)

    def _move_home(self):
        self.apt.mot_move_home(self.serial_number, True)

    def _move_home_async(self):
        self.apt.mot_move_home(self.serial_number, False)
"
144,https://www.batronix.com/pdf/Rohde-Schwarz/HMC804X/HMC804X_Datasheet_EN.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'atttUq01ic3TQNeuu'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gHnKR_WociH1yCWpq8-upg/6LU2zwTh6mu0VzWXm53IWPavk593zn4zlLYFE54NV32XlDYBiOpSf-Qn7O86tbR9jdnelYYj0KOGD2n6_MJEUHq_nqrv68NOKXHCl9ID9Q5eRcOX0KUfWHxFc5miGXb7FLz6QIukc9y_Ud-apmdgG5QLBV3rd8yBgQJrcYo3SxQ/eVGNS7rL3evkIKPiDxJfg7sb1Roatd5iaszm-B27QyA'), ('filename', 'hmc804x-dc-power-supply-front-view-rohde-schwarz_200_979_640_360_1.jpg'), ('size', 39364), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/fM8OjSB3afkyRb-R2CyH5A/O5ORB8MI6o81Myn7CJrqnr6DiAJV4E4F7Xg3b-sgNaAwzCsvDDKRfETPfwAG34CSKu1CXvF17kKUqkUDoynzAA/ZQOCBhYmunX2akRQx6A5ac-v12uZcdJmMuHnZ641moU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/EITKIzzXx0eEDw0FmHxLKg/pwBAg3xhVN_cWFyRvwF58wBCqGW39ghcACUmyxqEtr42R0oEr4mxGx5i8OKG-ZDZeQW3rtajdjGqeAX3kvGoCg/vEr2aqqJL_B3eEk_D9xKymdUwvD3HRWjUwOfrEO0PK4'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zkdqmeQh0Css-UQ4JbaYZA/V5hYPALg7POHQ36j7KCz0RQ2Fk82CvvtWWlsmOGg5a_wPuazcE4CnssWWmN4W-ImScuYSBchrx8nU_oIafOkpQ/SUWHyl6KS2YStHpzY9A-BVF-fd1Hkpk_3XAWqhwRPqw'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","the two-channel HMC8042 delivers a maximum of 5 A. The HMC804x family offers a wide range of logging functions, an integrated energy meter and electronic fuses that can be individually combined for each channel, making it ideal for hardware developers, labs and industrial environments. Linear switching power supplies ensure high efficiency, for minimum heat dissipation even at full load. Developers and industrial users benefit from useful functions such as sequenced start of channels, EasyArb and EasyRamp functions that are directly programmable on the device, an analog input for external control of voltage values, an external trigger input for controlling channels and arb steps, and adjustable overvoltage/overpower protection for each channel.",https://www.testequity.com/product/22868-2-HMC8042-02?gclid=CjwKCAjw-vmkBhBMEiwAlrMeFwUGdQlv0LWh2NEPZyw2XgfWgtfdPvk2wK7auon8PySZGMu5L_Qv2hoC-kIQAvD_BwE,HMC 8042,481.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMC8042.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMC8042,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMC 8042,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,1600.0,,,,"from .private.HMC804x import _RohdeSchwarzHMC804x

class RohdeSchwarzHMC8042(_RohdeSchwarzHMC804x):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMC8042 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, num_channels=2, **kwargs)
"
146,https://www.keysight.com/us/en/assets/7018-05391/data-sheets/5992-1797.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attzfnOP0CNrZnqTK'), ('width', 2000), ('height', 1685), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/WjH6DHkc1tuozZ6R4BXgyA/6JVG1eAZY_71rvZ7eyODalp3J4_4gxvpuxJn_wPbbo9am5hXE0xRaVa2r080zntvktGCGxZdjKvAft0qQW6ygsuPjJ5BeIxR1BRJ5n6WRC0/oZ_tVlFqHYHVvhfVrTFaYb6WsZjhpUq_y1nZbuwmd50'), ('filename', 'PROD-2747478-01.png'), ('size', 1198367), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hmb90GAyOC8qlnMKakFVNg/2eXxBDUwabpf0lwxLA1AGbE0MYzTxJ1oGsYi4pV2vfJV4TsgLxEIiYTLslJVwgH0GSjSQdhVTktzk3fK4I60NA/sJYm052uqXB_cLvxnzjHsOoPW7MnHTw1APAC48GcUEE'), ('width', 43), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sajMA2gG3_P4b8-_locgKw/DZj23NOaAIHgGkgyxzXZF7BGm0om8E9mYKV_9zzlQWkt6P1ir3gKpgRziZfEK90COJFb3gdu9foF1lE4wmcM6w/efSP3ybqmgBt8VySlkRMgG7DEtvufd95Njr7YjadVKU'), ('width', 608), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/lAFWg0GkNgbxRZuPnwDYYA/t0pO940qmFokaNfJYVQuJ5z8_EBsap8Qe5LkH404n_JlvYQLTYLfi0hu1qj-eB7QkuJAOWReM1SMef-MhPj4VQ/IBh2F6jpXfpFm9lKW37mbMxvVjuXLD6Vq1mvGoHR6Io'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"Keysight's M3201A PXIe arbitrary waveform generator offers 4 channels, on-board FPGA with optional FPGA software tools that enable real-time sequencing, inter-module synchronization, and graphical FPGA design environment.",https://www.keysight.com/us/en/products/arbitrary-waveform-generators/pxi-arbitrary-waveform-generators.html,Keysight M 3201 A,305.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Keysight/Keysight_M3201A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.Keysight_M3201A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT M3201A,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT M3201A RF Signal Generator,,,,,"# from qcodes import validators as validator
# from functools import partial
#
# from .SD_common.SD_Module import *
from .SD_common.SD_AWG import SD_AWG


class Keysight_M3201A(SD_AWG):
    """"""
    This is the qcodes driver for the Keysight M3201A AWG PXIe card

    Args:
        name (str): name for this instrument, passed to the base instrument
        chassis (int): chassis number where the device is located
        slot (int): slot number where the device is plugged in
    """"""

    def __init__(self, name, chassis=1, slot=7, **kwargs):
        super().__init__(name, chassis, slot, channels=4, triggers=8, **kwargs)
"
151,,https://en.wikipedia.org/wiki/Electric_generator,"[OrderedDict([('id', 'attJwDhnnFpXdEJS9'), ('width', 768), ('height', 512), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/OiH9ejhifv-uX8Ag4m2wUQ/N-yBaub4WA0VIirz-LBgtd95zVbHsONhJNa36N1J2JSieQKPFnAwNk212pP3BOpTHA6hnrLCCqDLYZPp3g1MjuyQf5UDoj5TN3jOO0Wr4ck/i9S32sUZBbQIIHvvAouG4V2Sotmq2UuzU5QJm0xCwvo'), ('filename', 'QDAC24_1024-768x512.png'), ('size', 70154), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Ac12FqCwumYG6yzuyM_S-Q/-URSRcm9PfAHqvlX8P46yoqsibKY9BzC43Vy1BDL_6nrpADCcy4PO7zYQyw0tBdjhIoabojM6xrXPTH6i0gUtw/cZbJx1IVzNikTtptNCjtApI96e7xAymd78mQ0imJLvE'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/i6WOl63SLG44GzZrx_vSVA/akCRZ4AoMtbB7wskLmyecQnKFoFHy--FcIOOoJWaLBgRC4hbvuU8utlSdLlcEPta1Wr6uIDdUYJ47ypDMoYWaQ/0d8XGe1iwkglp5_8AnIZH46AFwLOLiV37CJKFADa_HA'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6Ty1FANbOaBHXnzA65DCbQ/D4L9gPCS7HDK4KOnF0BbQRvJ0mSDPjSGXrliR7QQyG3nfMmLdtYG0EwAcXxlNK8QpCClLEtPVD126KlcBbv2-g/Twqq459VSEw1mTNMBbg1LCXbxrtisdH9jW5x-iCT7cg'), ('width', 3000), ('height', 3000)]))]))])]",2.0,"COPENHAGEN, DENMARK","The original and popular QDAC from QDevil is a high-precision low-noise computer-controlled voltage generator designed for DC and low-frequency control of high impedance devices, such as gates in quantum electronics and quantum computer qubits. It also comes in a “high-current” version which can source up to 10 mA, for example for flux biasing of superconducting qubits. In addition to precise and stable voltage output, the QDAC can measure output currents, for example, to detect leaking gates or shorted bonding wires. The QDAC originates from the laboratories of the Center for Quantum Devices at the University of Copenhagen, where it is used for quantum computing research. The QDAC has 24 channels and offers a cost-effective way of getting many high-quality D/A converter channels.",https://qdevil.com/qdac/,Qdac 1,425.0,"['Power Supplies', 'Digital-Analog Converter']","In electricity generation, a generator[1] is a device that converts motive power (mechanical energy) or fuel-based power (chemical energy) into electric power for use in an external circuit. Sources of mechanical energy include steam turbines, gas turbines, water turbines, internal combustion engines, wind turbines and even hand cranks. The first electromagnetic generator, the Faraday disk, was invented in 1831 by British scientist Michael Faraday. Generators provide nearly all of the power for electric power grids.","Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QDevil/QDAC1.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QDevil.html#module-qcodes_contrib_drivers.drivers.QDevil.QDAC1,Qdevil,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rt0ijk1tEeP19zdHVfttFg/7Ob5OL-aQOWHgJLTZlkxZkOheJC0cN05vXsNpZRsU4OHbtOmqBBAZlhmqBSOIWRZUvxG3tQKTXSQ-e54ZcKM4efr6Y_SsndOQXo4lN8vFmQ/I-pT2nu1se1zoP4Grs6M0aBZp6dNS5Hmy5wXPGCI3Vs'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/0EsL2PmoGiY38ganNXLIXA/6F3XRVRPwQG2h6M4Bzu3VIPyNK-686d5qDAzOEx2xCYQnhk8Vg07pNzWuBAXC2npzgWJXgkt6dViRWY8eZ3sVU8teqS8qPGyDsuTtzMWrPc/h8g-OEnf98sLQylcJtEMTjg0rbA7rnR_a4oTo-cTcLc'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/d6gt9ShC3wZMYSwCexAZnw/mZGS-M4xi-162d2C-IrVxIkwYbHnSu_oTyFSt63Y62UPZq_U0ZVVx0m3AIq4mw0JARmzx6D39IdlQ8eKbTwMDvKLUpoWkfuKXTiXoZFJZRM/sl6WH15UvsVy7nXyFYu3VwMHFJSsjBQr3yfODvcLbDQ'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qAV45QZXEAt3b7YfrCuZCQ/-_qwuyLIus2jW_R-Ivn54iGTzh4GJ0KYI11dJ8E6to-VWm4y7BzEtwY0eNjwiEC6jDFfyYzUOj4dbMd223m2Jfzz1gbcZCKF_BFv7jfyTfQ/je3Fsh2bnUiJYjz4JBzgEeN5qpp57TDjds1gIjtuek4'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,Qdac 1,"Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies, Digital-Analog Converter",,,,,"# QCoDeS driver for the QDevil QDAC using channels
# Adapted by QDevil from the qdev QDac driver in qcodes
# Version 2.2 QDevil 2023-02-20

import logging
import time
from collections import namedtuple
from enum import Enum
from functools import partial
from typing import Any, Dict, Optional, Sequence, Tuple, Union

import pyvisa
import pyvisa.constants
from pyvisa.resources.serial import SerialInstrument

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import MultiChannelInstrumentParameter, ParamRawDataType

LOG = logging.getLogger(__name__)


_ModeTuple = namedtuple('_ModeTuple', 'v i')


class Mode(Enum):
    """"""
    Enum type use as the mode parameter for channels
    defining the combined voltage and current range.

    get_label() returns a text representation of the mode.
    """"""
    vhigh_ihigh = _ModeTuple(v=0, i=1)
    vhigh_ilow = _ModeTuple(v=0, i=0)
    vlow_ilow = _ModeTuple(v=1, i=0)

    def get_label(self) -> str:
        _MODE_LABELS = {
                ""vhigh_ihigh"": ""V range high / I range high"",
                ""vhigh_ilow"": ""V range high / I range low"",
                ""vlow_ilow"": ""V range low / I range low""}
        return _MODE_LABELS[self.name]


class Waveform:
    # Enum-like class defining the built-in waveform types
    sine = 1
    square = 2
    triangle = 3
    staircase = 4
    all_waveforms = [sine, square, triangle, staircase]


class Generator:
    #  Class used in the internal book keeping of generators
    def __init__(self, generator_number: int):
        self.fg = generator_number
        self.t_end = 9.9e9


class QDacChannel(InstrumentChannel):
    """"""
    A single output channel of the QDac.

    Exposes chan.v, chan.i, chan.mode, chan.slope,
    chan.sync, chan.sync_delay, chan.sync_duration.\n
    NB: Set v to zero before changing mode if the
    mode_force lfag is False (default).
    """"""

    def __init__(self, parent: ""QDac"", name: str, channum: int):
        """"""
        Args:
            parent: The instrument to which the channel belongs.
            name: The name of the channel
            channum: The number of the channel (1-24 or 1-48)
        """"""
        super().__init__(parent, name)

        # Add the parameters
        self.add_parameter(name='v',
                           label=f'Channel {channum} voltage',
                           unit='V',
                           set_cmd=partial(self._parent._set_voltage, channum),
                           get_cmd=partial(self._parent._get_voltage, channum),
                           get_parser=float,
                           # Initial range. Updated on init and during
                           # operation:
                           vals=vals.Numbers(-9.99, 9.99)
                           )

        self.add_parameter(name='mode',
                           label=f'Channel {channum} mode.',
                           set_cmd=partial(self._parent._set_mode, channum),
                           get_cmd=None,
                           vals=vals.Enum(*list(Mode))
                           )

        self.add_parameter(name='i',
                           label=f'Channel {channum} current',
                           get_cmd=f'get {channum}',
                           unit='A',
                           get_parser=self._parent._current_parser
                           )

        self.add_parameter(name='slope',
                           label=f'Channel {channum} slope',
                           unit='V/s',
                           set_cmd=partial(self._parent._setslope, channum),
                           get_cmd=partial(self._parent._getslope, channum),
                           vals=vals.MultiType(vals.Enum('Inf'),
                                               vals.Numbers(1e-3, 10000))
                           )

        self.add_parameter(name='sync',
                           label=f'Channel {channum} sync output',
                           set_cmd=partial(self._parent._setsync, channum),
                           get_cmd=partial(self._parent._getsync, channum),
                           vals=vals.Ints(0, 4)  # Updated at qdac init
                           )

        self.add_parameter(name='sync_delay',
                           label=f'Channel {channum} sync pulse delay',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Numbers(0, 10000),
                           initial_value=0
                           )

        self.add_parameter(
                        name='sync_duration',
                        label=f'Channel {channum} sync pulse duration',
                        unit='s',
                        get_cmd=None, set_cmd=None,
                        vals=vals.Numbers(0.001, 10000),
                        initial_value=0.01
                        )

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> Dict[Any, Any]:
        update_currents = self._parent._update_currents and update
        if update and not self._parent._get_status_performed:
            self._parent._update_cache(update_currents=update_currents)
        # call update_cache rather than getting the status individually for
        # each parameter. This is only done if _get_status_performed is False
        # this is used to signal that the parent has already called it and
        # no need to repeat.
        if params_to_skip_update is None:
            params_to_skip_update = ('v', 'i', 'mode')
        snap = super().snapshot_base(
                            update=update,
                            params_to_skip_update=params_to_skip_update)
        return snap


class QDacMultiChannelParameter(MultiChannelInstrumentParameter):
    """"""
    The class to be returned by __getattr__ of the ChannelList. Here customised
    for fast multi-readout of voltages.
    """"""
    def __init__(self, channels: Sequence[InstrumentChannel],
                 param_name: str,
                 *args: Any,
                 **kwargs: Any):
        super().__init__(channels, param_name, *args, **kwargs)

    def get_raw(self) -> Tuple[ParamRawDataType, ...]:
        """"""
        Return a tuple containing the data from each of the channels in the
        list.
        """"""
        # For voltages, we can do something slightly faster than the naive
        # approach by asking the instrument for a channel overview.

        if self._param_name == 'v':
            qdac = self._channels[0]._parent
            qdac._update_cache(update_currents=False)
            output = tuple(chan.parameters[self._param_name].cache()
                           for chan in self._channels)
        else:
            output = tuple(chan.parameters[self._param_name].get()
                           for chan in self._channels)

        return output


class QDac(VisaInstrument):
    """"""
    Channelised driver for the QDevil QDAC voltage source.

    Exposes channels, temperature sensors and calibration output,
    and 'ramp_voltages' + 'ramp_voltages_2d' for multi channel ramping.

    In addition a 'mode_force' flag (default False) is exposed.
    'mode_force' (=True) is used to enable voltage range switching, via
    the channel 'mode' parameter, even at non-zero output voltages.

    Tested with Firmware Version: 1.07

    The driver assumes that the instrument is ALWAYS in verbose mode OFF
    and sets this as part of the initialization, so please do not change this.
    """"""

    # set nonzero value (seconds) to accept older status when reading settings
    max_status_age = 1

    def __init__(self,
                 name: str,
                 address: str,
                 update_currents: bool = False,
                 **kwargs: Any):
        """"""
        Instantiates the instrument.

        Args:
            name: The instrument name used by qcodes
            address: The VISA name of the resource
            update_currents: Whether to query all channels for their
                current sensor value on startup, which takes about 0.5 sec
                per channel. Default: False.

        Returns:
            QDac object
        """"""

        super().__init__(name, address, **kwargs)
        handle = self.visa_handle
        self._get_status_performed = False

        assert isinstance(handle, SerialInstrument)
        # Communication setup + firmware check
        handle.baud_rate = 460800
        handle.parity = pyvisa.constants.Parity(0)
        handle.data_bits = 8
        self.set_terminator('\n')
        handle.write_termination = '\n'
        self._write_response = ''
        firmware_version = self._get_firmware_version()
        if firmware_version < 1.07:
            LOG.warning(f""Firmware version: {firmware_version}"")
            raise RuntimeError('''
                No QDevil QDAC detected or the firmware version is obsolete.
                This driver only supports version 1.07 or newer. Please
                contact info@qdevil.com for a firmware update.
                ''')

        # Initialse basic information and internal book keeping
        self.num_chans = self._get_number_of_channels()
        num_boards = int(self.num_chans/8)
        self._output_n_lines = self.num_chans + 2
        self._chan_range = range(1, 1 + self.num_chans)
        self.channel_validator = vals.Ints(1, self.num_chans)
        self._reset_bookkeeping()

        # Add channels (and channel parameters)
        channels = ChannelList(self, ""Channels"", QDacChannel,
                               snapshotable=False,
                               multichan_paramclass=QDacMultiChannelParameter)

        for i in self._chan_range:
            channel = QDacChannel(self, f'chan{i:02}', i)
            channels.append(channel)
            self.add_submodule(f""ch{i:02}"", channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        # Updatechannel  sync port validator according to number of boards
        self._num_syns = max(num_boards-1, 1)
        for chan in self._chan_range:
            self.channels[chan-1].sync.vals = vals.Ints(0, self._num_syns)

        # Add non-channel parameters
        for board in range(num_boards):
            for sensor in range(3):
                label = f'Board {board}, Temperature {sensor}'
                self.add_parameter(name=f'temp{board}_{sensor}',
                                   label=label,
                                   unit='C',
                                   get_cmd=f'tem {board} {sensor}',
                                   get_parser=self._num_verbose)

        self.add_parameter(name='cal',
                           set_cmd='cal {}',
                           vals=vals.Ints(0, self.num_chans))

        self.add_parameter(name='mode_force',
                           label='Mode force',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Bool(),
                           initial_value=False)

        # Due to a firmware bug in 1.07 voltage ranges are always reported
        # vebosely. So for future compatibility we set verbose True
        self.write('ver 1')
        self._update_voltage_ranges()
        # The driver require verbose mode off except for the above command
        self.write('ver 0')
        self._verbose = False  # Just so that the code can check the state
        self.connect_message()
        LOG.info('[*] Querying all channels for voltages and currents...')
        self._update_cache(update_currents=update_currents)
        self._update_currents = update_currents
        self._load_state()
        LOG.info('[+] Done')

    def _reset_bookkeeping(self) -> None:
        """"""
        Resets all internal variables used for ramping and
        synchronization outputs.
        """"""
        # Assigned slopes. Entries will eventually be {chan: slope}
        self._slopes:  Dict[int, Union[str, float]] = {}
        # Function generators and triggers (used in ramping)
        self._fgs = set(range(1, 9))
        self._assigned_fgs: Dict[int, Generator] = {}  # {chan: fg}
        self._trigs = set(range(1, 10))
        self._assigned_triggers: Dict[int, int] = {}  # {fg: trigger}
        # Sync channels
        self._syncoutputs: Dict[int, int] = {}  # {chan: syncoutput}

    def _load_state(self) -> None:
        """"""
        Used as part of initiaisation. DON'T use _load_state() separately.\n
        Updates internal book keeping of running function generators.
        used triggers and active sync outputs.\n
        Slopes can not be read/updated as it is not possible to
        say if a generator is running because a slope has been assigned
        or because it is being ramped direcly (by e.g. ramp_voltages_2d()).
        """"""
        # Assumes that all variables and virtual
        # parameters have been initialised (and read)

        self.write('ver 0')  # Just to be on the safe side

        self._reset_bookkeeping()
        for ch_idx in range(self.num_chans):
            chan = ch_idx + 1
            # Check if the channels are being ramped
            # It is not possible to find out if it has a slope assigned
            # as it may be ramped explicitely by the user
            # We assume that generators are running, but we cannot know
            self.write(f'wav {chan}')
            fg_str, amplitude_str, offset_str = self._write_response.split(',')
            amplitude = float(amplitude_str)
            offset = float(offset_str)
            fg = int(fg_str)
            if fg in range(1, 9):
                voltage = self.channels[ch_idx].v.get()
                time_now = time.time()
                self.write(f'fun {fg}')
                response = self._write_response.split(',')
                waveform = int(response[0])
                # Probably this driver is involved if a stair case is assigned
                if waveform == Waveform.staircase:
                    if len(response) == 6:
                        step_length_ms, no_steps, rep, rep_remain_str, trigger \
                            = response[1:6]
                        rep_remain = int(rep_remain_str)
                    else:
                        step_length_ms, no_steps, rep, trigger = response[1:5]
                        rep_remain = int(rep)
                    ramp_time = 0.001 * float(step_length_ms) * int(no_steps)
                    ramp_remain = 0
                    if (amplitude != 0):
                        ramp_remain = (amplitude+offset-voltage)/amplitude
                    if int(rep) == -1:
                        time_end = time_now + 315360000
                    else:
                        time_end = (ramp_remain + max(0, rep_remain-1)) \
                                   * ramp_time + time_now + 0.001
                else:
                    if waveform == Waveform.sine:
                        period_ms, rep, rep_remain_str, trigger = response[1:5]
                    else:
                        period_ms, _, rep, rep_remain_str, trigger = response[1:6]
                    if int(rep) == -1:
                        time_end = time_now + 315360000  # 10 years from now
                    else:  # +1 is just a safe guard
                        time_end = time_now + 0.001 \
                                   * (int(rep_remain_str)+1) * float(period_ms)

                self._assigned_fgs[chan] = Generator(fg)
                self._assigned_fgs[chan].t_end = time_end
                if int(trigger) != 0:
                    self._assigned_triggers[fg] = int(trigger)
                for syn in range(1, self._num_syns+1):
                    self.write(f'syn {syn}')
                    syn_fg, delay_ms, duration_ms = \
                        self._write_response.split(',')
                    if int(syn_fg) == fg:
                        self.channels[ch_idx].sync.cache.set(syn)
                        self.channels[ch_idx].sync_delay(float(delay_ms)/1000)
                        self.channels[ch_idx].sync_duration(
                            float(duration_ms)/1000)

    def reset(self, update_currents: bool = False) -> None:
        """"""
        Resets the instrument setting all channels to zero output voltage
        and all parameters to their default values, including removing any
        assigned sync putputs, function generators, triggers etc.
        """"""
        # In case the QDAC has been switched off/on
        # clear the io buffer and set verbose False
        self.device_clear()
        self.write('ver 0')

        self.cal(0)
        # Resetting all slopes first will cause v.set() disconnect generators
        self.channels[0:self.num_chans].slope('Inf')
        self.channels[0:self.num_chans].v(0)
        self.channels[0:self.num_chans].mode(Mode.vhigh_ihigh)
        self.channels[0:self.num_chans].sync(0)
        self.channels[0:self.num_chans].sync_delay(0)
        self.channels[0:self.num_chans].sync_duration(0.01)

        if update_currents:
            self.channels[0:self.num_chans].i.get()
        self.mode_force(False)
        self._reset_bookkeeping()

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> Dict[Any, Any]:
        update_currents = self._update_currents and update is True
        if update:
            self._update_cache(update_currents=update_currents)
            self._get_status_performed = True
        # call _update_cache rather than getting the status individually for
        # each parameter. We set _get_status_performed to True
        # to indicate that each update channel does not need to call this
        # function as opposed to when snapshot is called on an individual
        # channel
        snap = super().snapshot_base(
                                update=update,
                                params_to_skip_update=params_to_skip_update)
        self._get_status_performed = False
        return snap

    #########################
    # Channel gets/sets
    #########################

    def _get_voltage(self, chan: int) -> str:
        """"""
        Clear the output from the instrument and ask for the current voltage

        Args:
            chan (int): The 1-indexed channel number
        """"""
        self.clear_read_queue()
        self.write(f'set {chan}')
        return self._write_response

    def _set_voltage(self, chan: int, v_set: float) -> None:
        """"""
        set_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
            v_set: The target voltage

        If a finite slope has been assigned, a function generator will
        ramp the voltage.
        """"""
        slope = self._slopes.get(chan, None)
        if not slope:
            # Should not be necessary to wav here.
            self.write('wav {ch} 0 0 0;set {ch} {voltage:.6f}'
                       .format(ch=chan, voltage=v_set))
            return
        # We need .get and not cache/get_latest in case a ramp
        # was interrupted
        v_start = self.channels[chan-1].v.get()
        v_span = v_set - v_start
        v_amplitude = abs(v_span)
        s_duration = v_amplitude / slope
        LOG.info(f'Slope: {slope}, time: {s_duration}')
        if v_amplitude <= 10:
            # SYNCing happens inside ramp_voltages
            self.ramp_voltages([chan], [v_start], [v_set], s_duration)
            return
        # Divide sweep into two parts
        v_half_span = v_span / 2
        s_half_duration = s_duration / 2
        v_half_way = v_start + v_half_span
        self.ramp_voltages([chan], [v_start], [v_half_way], s_half_duration)
        LOG.warning('Trying to ramp more than 10 volts. '
            'Waiting for first ramp to finish')
        time.sleep(s_half_duration)
        self.ramp_voltages([chan], [v_half_way], [v_set], s_half_duration)

    def _set_mode(self, chan: int, new_mode: Mode) -> None:
        """"""
        set_cmd for the QDAC's mode (combined voltage and current sense range).
        It is not possible to switch from voltage range without setting the
        the voltage to zero first or set the global mode_force parameter True.
        """"""
        def _clipto(value: float, min_: float, max_: float) -> float:
            errmsg = (""Voltage is outside the bounds of the new voltage range""
                      "" and is therefore clipped."")
            if value > max_:
                LOG.warning(errmsg)
                return max_
            elif value < min_:
                LOG.warning(errmsg)
                return min_
            else:
                return value

        # It is not possible ot say if the channel is connected to
        # a generator, so we need to ask.
        def wav_or_set_msg(chan: int, new_voltage: float) -> str:
            self.write(f'wav {chan}')
            fw_str = self._write_response
            gen, _, _ = fw_str.split(',')
            if int(gen) > 0:
                # The amplitude must be set to zero to avoid potential overflow
                # Assuming that voltage range is not changed during a ramp
                return 'wav {} {} {:.6f} {:.6f}'\
                        .format(chan, int(gen), 0, new_voltage)
            else:
                return f'set {chan} {new_voltage:.6f}'

        old_mode = self.channels[chan-1].mode.cache()
        new_vrange = new_mode.value.v
        old_vrange = old_mode.value.v
        new_irange = new_mode.value.i
        old_irange = old_mode.value.i
        message = ''
        max_zero_voltage = {0: 20e-6, 1: 3e-6}
        NON_ZERO_VOLTAGE_MSG = (
                'Please set the voltage to zero before changing the voltage'
                ' range in order to avoid jumps or spikes.'
                ' Or set mode_force=True to allow voltage range change for'
                ' non-zero voltages.')

        if old_mode == new_mode:
            return

        # If the voltage range is going to change we have to take care of
        # setting the voltage after the switch, and therefore read it first
        # We also need to make sure than only one of the voltage/current
        # relays is on at a time (otherwise the firmware will enforce it).

        if (new_irange != old_irange) and (new_vrange == old_vrange == 0):
            # Only the current sensor relay has to switch:
            message += f'cur {chan} {new_irange}'
        # The voltage relay (also) has to switch:
        else:
            # Current sensor relay on->off before voltage relay off->on:
            if new_irange < old_irange and new_vrange > old_vrange:
                message += f'cur {chan} {new_irange};'
            old_voltage = self.channels[chan-1].v.get()
            # Check if voltage is non-zero and mode_force is off
            if ((self.mode_force() is False) and
                    (abs(old_voltage) > max_zero_voltage[old_vrange])):
                raise ValueError(NON_ZERO_VOLTAGE_MSG)
            new_voltage = _clipto(
                    old_voltage, self.vranges[chan][new_vrange]['Min'],
                    self.vranges[chan][new_vrange]['Max'])
            message += f'vol {chan} {new_vrange};'
            message += wav_or_set_msg(chan, new_voltage)
            # Current sensor relay off->on after voltage relay on->off:
            if new_irange > old_irange and new_vrange < old_vrange:
                message += f';cur {chan} {new_irange}'
            self.channels[chan-1].v.vals = self._v_vals(chan, new_vrange)
            self.channels[chan-1].v.cache.set(new_voltage)

        self.write(message)

    def _v_vals(self, chan: int, vrange_int: int) -> vals.Numbers:
        """"""
        Returns the validator for the specified voltage range.
        """"""
        return vals.Numbers(self.vranges[chan][vrange_int]['Min'],
                            self.vranges[chan][vrange_int]['Max'])

    def _update_v_validators(self) -> None:
        """"""
        Command for setting all 'v' limits ('vals') of all channels to the
        actual calibrated output limits for the range each individual channel
        is currently in.
        """"""
        for chan in range(1, self.num_chans+1):
            vrange = self.channels[chan-1].mode.value.v
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange)

    def _num_verbose(self, s: str) -> float:
        """"""
        Turns a return value from the QDac into a number.
        If the QDac is in verbose mode, this involves stripping off the
        value descriptor.
        """"""
        if self._verbose:
            s = s.split(': ')[-1]
        return float(s)

    def _current_parser(self, s: str) -> float:
        """"""
        Parser for chXX_i parameter (converts from uA to A)
        """"""
        return 1e-6*self._num_verbose(s)

    def _update_cache(self, update_currents: bool = False) -> None:
        """"""
        Function to query the instrument and get the status of all channels.
        Takes a while to finish.

        The `status` call generates 27 or 51 lines of output. Send the command
        and read the first one, which is the software version line
        the full output looks like:
        Software Version: 1.07\r\n
        Channel\tOut V\t\tVoltage range\tCurrent range\n
        \n
        8\t  0.000000\t\tX 1\t\tpA\n
        7\t  0.000000\t\tX 1\t\tpA\n
        ... (all 24/48 channels like this)
        (no termination afterward besides the \n ending the last channel)
        """"""
        irange_trans = {'hi cur': 1, 'lo cur': 0}
        vrange_trans = {'X 1': 0, 'X 0.1': 1}

        # Status call, check the
        version_line = self.ask('status')
        if version_line.startswith('Software Version: '):
            self.version = version_line.strip().split(': ')[1]
        else:
            self._wait_and_clear()
            raise ValueError('unrecognized version line: ' + version_line)

        # Check header line
        header_line = self.read()
        headers = header_line.lower().strip('\r\n').split('\t')
        expected_headers = ['channel', 'out v', '', 'voltage range',
                            'current range']
        if headers != expected_headers:
            raise ValueError('unrecognized header line: ' + header_line)

        chans_left = set(self._chan_range)
        while chans_left:
            line = self.read().strip()
            if not line:
                continue
            chanstr, v, _, vrange, _, irange = line.split('\t')
            chan = int(chanstr)
            vrange_int = int(vrange_trans[vrange.strip()])
            irange_int = int(irange_trans[irange.strip()])
            mode = Mode((vrange_int, irange_int))
            self.channels[chan-1].mode.cache.set(mode)
            self.channels[chan-1].v.cache.set(float(v))
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange_int)
            chans_left.remove(chan)

        if update_currents:
            for chan in self._chan_range:
                self.channels[chan-1].i.get()

    def _setsync(self, chan: int, sync: int) -> None:
        """"""
        set_cmd for the chXX_sync parameter.

        Args:
            chan: The channel number (1-48 or 1-24)
            sync: The associated sync output (1-3 on 24 ch units
            or 1-5 on 48 ch units). 0 means 'unassign'
        """"""

        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                    f'Channel number must be 1-{self.num_chans}.')

        if sync == 0:
            oldsync = self.channels[chan-1].sync.cache()
            # try to remove the sync from internal bookkeeping
            self._syncoutputs.pop(chan, None)
            # free the previously assigned sync
            if oldsync is not None:
                self.write(f'syn {oldsync} 0 0 0')
            return

        # Make sure to clear hardware an _syncoutpus appropriately
        if chan in self._syncoutputs:
            # Changing SYNC port for a channel
            oldsync = self.channels[chan-1].sync.cache()
            if sync != oldsync:
                self.write(f'syn {oldsync} 0 0 0')
        elif sync in self._syncoutputs.values():
            # Assigning an already used SYNC port to a different channel
            oldchan = [ch for ch, sy in self._syncoutputs.items()
                       if sy == sync]
            self._syncoutputs.pop(oldchan[0], None)
            self.write(f'syn {sync} 0 0 0')

        self._syncoutputs[chan] = sync
        return

    def _getsync(self, chan: int) -> int:
        """"""
        get_cmd of the chXX_sync parameter
        """"""
        return self._syncoutputs.get(chan, 0)

    def print_syncs(self) -> None:
        """"""
        Print assigned SYNC ports, sorted by channel number
        """"""
        for chan, sync in sorted(self._syncoutputs.items()):
            print(f'Channel {chan}, SYNC: {sync} (V/s)')

    def _setslope(self, chan: int, slope: Union[float, str]) -> None:
        """"""
        set_cmd for the chXX_slope parameter, the maximum slope of a channel.
        With a finite slope the channel will be ramped using a generator.

        Args:
            chan: The channel number (1-24 or 1-48)
            slope: The slope in V/s.
            Write 'Inf' to release the channelas slope channel and to release
            the associated function generator. The output rise time will now
            only depend on the analog electronics.
        """"""
        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')

        if slope == 'Inf':
            # Set the channel in DC mode
            v_set = self.channels[chan-1].v.get()
            self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                       .format(ch=chan, voltage=v_set))

            # Now release the function generator and fg trigger (if possible)
            try:
                fg = self._assigned_fgs[chan]
                self._assigned_fgs[chan].t_end = 0
                self._assigned_triggers.pop(fg.fg)
            except KeyError:
                pass

            # Remove a sync output, if one was assigned
            if chan in self._syncoutputs:
                self.channels[chan-1].sync.set(0)
            # Now clear the assigned slope
            self._slopes.pop(chan, None)
        else:
            self._slopes[chan] = slope

    def _getslope(self, chan: int) -> Union[str, float]:
        """"""
        get_cmd of the chXX_slope parameter
        """"""
        return self._slopes.get(chan, 'Inf')

    def print_slopes(self) -> None:
        """"""
        Print the finite slopes assigned to channels, sorted by channel number
        """"""
        for chan, slope in sorted(self._slopes.items()):
            print(f'Channel {chan}, slope: {slope} (V/s)')

    def _get_minmax_outputvoltage(self, channel: int, vrange_int: int) -> Dict[str, float]:
        """"""
        Returns a dictionary of the calibrated Min and Max output
        voltages of 'channel' for the voltage given range (0,1) given by
        'vrange_int'
        """"""
        # For firmware 1.07 verbose mode and nn verbose mode give verbose
        # result, So this is designed for verbose mode
        if channel not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
        if vrange_int not in range(0, 2):
            raise ValueError('Range must be 0 or 1.')

        self.write(f'rang {channel} {vrange_int}')
        fw_str = self._write_response
        return {'Min': float(fw_str.split('MIN:')[1].split('MAX')[0].strip()),
                'Max': float(fw_str.split('MAX:')[1].strip())}

    def _update_voltage_ranges(self) -> None:
        # Get all calibrated min/max output values, requires verbose on
        # in firmware version 1.07
        self.write('ver 1')
        self.vranges = {}
        for chan in self._chan_range:
            self.vranges.update(
                {chan: {0: self._get_minmax_outputvoltage(chan, 0),
                        1: self._get_minmax_outputvoltage(chan, 1)}})
        self.write('ver 0')

    def write(self, cmd: str) -> None:
        """"""
        QDac always returns something even from set commands, even when
        verbose mode is off, so we'll override write to take this out
        if you want to use this response, we put it in self._write_response
        (but only for the very last write call)

        In this method we expect to read one termination char per command. As
        commands are concatenated by `;` we count the number of concatenated
        commands as count(';') + 1 e.g. 'wav 1 1 1 0;fun 2 1 100 1 1' is two
        commands. Note that only the response of the last command will be
        available in `_write_response`
        """"""

        LOG.debug(f""Writing to instrument {self.name}: {cmd}"")
        self.visa_handle.write(cmd)
        for _ in range(cmd.count(';')+1):
            self._write_response = self.visa_handle.read()
            if self._write_response.startswith('Error: '):
                LOG.warning(self._write_response)

    def read(self) -> str:
        return self.visa_handle.read()

    def _wait_and_clear(self, delay: float = 0.5) -> None:
        time.sleep(delay)
        self.visa_handle.clear()

    def clear_read_queue(self) -> Sequence[str]:
        """"""
        Flush the VISA message queue of the instrument

        Waits 1 ms between each read.

        Returns:
            Sequence[str]: Messages lingering in queue
        """"""
        lingering = list()
        with self.timeout.set_to(0.001):
            while True:
                try:
                    message = self.visa_handle.read()
                except pyvisa.VisaIOError:
                    break
                else:
                    lingering.append(message)
        return lingering

    def connect_message(self,
                        idn_param: str = 'IDN',
                        begin_time: Optional[float] = None) -> None:
        """"""
        Override of the standard Instrument class connect_message.
        Usually, the response to `*IDN?` is printed. Here, the
        software version is printed.
        """"""
        self.visa_handle.write('version')
        LOG.info('Connected to QDAC on {}, {}'.format(
                                    self._address, self.visa_handle.read()))

    def _get_firmware_version(self) -> float:
        """"""
        Check if the ""version"" command reponds. If so we probably have a QDevil
        QDAC, and the version number is returned. Otherwise 0.0 is returned.
        """"""
        self.write('version')
        fw_str = self._write_response
        if ((not (""Unrecognized command"" in fw_str))
                and (""Software Version: "" in fw_str)):
            fw_version = float(
                self._write_response.replace(""Software Version: "", """"))
        else:
            fw_version = 0.0
        return fw_version

    def _get_number_of_channels(self) -> int:
        """"""
        Returns the number of channels for the instrument
        """"""
        self.write('boardNum')
        fw_str = self._write_response
        return 8*int(fw_str.strip(""numberOfBoards:""))

    def print_overview(self, update_currents: bool =  False) -> None:
        """"""
        Pretty-prints the status of the QDac
        """"""

        self._update_cache(update_currents=update_currents)

        for ii in range(self.num_chans):
            line = f""Channel {ii+1} \n""
            line += ""    Voltage: {} ({}).\n"".format(
                self.channels[ii].v.cache(), self.channels[ii].v.unit
            )
            line += ""    Current: {} ({}).\n"".format(
                self.channels[ii].i.cache.get(get_if_invalid=False),
                self.channels[ii].i.unit,
            )
            line += f""    Mode: {self.channels[ii].mode.cache().get_label()}.\n""
            line += ""    Slope: {} ({}).\n"".format(
                self.channels[ii].slope.cache(), self.channels[ii].slope.unit
            )
            if self.channels[ii].sync.cache() > 0:
                line += '    Sync Out: {}, Delay: {} ({}), '\
                        'Duration: {} ({}).\n'.format(
                            self.channels[ii].sync.cache(),
                            self.channels[ii].sync_delay.cache(),
                            self.channels[ii].sync_delay.unit,
                            self.channels[ii].sync_duration.cache(),
                            self.channels[ii].sync_duration.unit,
                        )

            print(line)

    def _get_functiongenerator(self, chan: int) -> int:
        """"""
        Function for getting a free generator (of 8 available) for a channel.
        Used as helper function for ramp_voltages, but may also be used if the
        user wants to use a function generator for something else.
        If there are no free generators this function will wait for up to
        fgs_timeout for one to be ready.

        To mark a function generator as available for others set
        self._assigned_fgs[chan].t_end = 0

        Args:
            chan: (1..24/48) the channel for which a function generator is
                  requested.
        """"""
        fgs_timeout = 2  # Max time to wait for next available generator

        if len(self._assigned_fgs) < 8:
            fg = min(self._fgs.difference(
                        {g.fg for g in self._assigned_fgs.values()}))
            self._assigned_fgs[chan] = Generator(fg)
        else:
            # If no available fgs, see if one is soon to be ready
            # Nte, this does not handle if teh user has assigned the
            # same fg to multiple channels cheating the driver
            time_now = time.time()
            available_fgs_chans = []
            fgs_t_end_ok = [g.t_end for chan, g
                            in self._assigned_fgs.items()
                            if g.t_end < time_now+fgs_timeout]
            if len(fgs_t_end_ok) > 0:
                first_ready_t = min(fgs_t_end_ok)
                available_fgs_chans = [chan for chan, g
                                       in self._assigned_fgs.items()
                                       if g.t_end == first_ready_t]
                if first_ready_t > time_now:
                    LOG.warning('''
                    Trying to ramp more channels than there are generators.\n
                    Waiting for ramp generator to be released''')
                    time.sleep(first_ready_t - time_now)

            if len(available_fgs_chans) > 0:
                oldchan = available_fgs_chans[0]
                fg = self._assigned_fgs[oldchan].fg
                self._assigned_fgs.pop(oldchan)
                self._assigned_fgs[chan] = Generator(fg)
                # Set the old channel in DC mode
                v_set = self.channels[oldchan-1].v.cache()
                self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                           .format(ch=oldchan, voltage=v_set))
            else:
                raise RuntimeError('''
                Trying to ramp more channels than there are generators
                available. Please insert delays allowing channels to finish
                ramping before trying to ramp other channels, or reduce the
                number of ramped channels. Or increase fgs_timeout.''')
        return fg

    def ramp_voltages(
            self,
            channellist: Sequence[int],
            v_startlist: Sequence[float],
            v_endlist: Sequence[float],
            ramptime: float) -> float:
        """"""
        Function for smoothly ramping one channel or more channels
        simultaneously (max. 8). This is a shallow interface to
        ramp_voltages_2d. Function generators and triggers are
        are assigned automatically.

        Args:
            channellist:    List (int) of channels to be ramped (1 indexed)\n
            v_startlist:    List (int) of voltages to ramp from.
                            MAY BE EMPTY. But if provided, time is saved by
                            NOT reading the present values from the instrument.

            v_endlist:      List (int) of voltages to ramp to.\n
            ramptime:       Total ramp time in seconds (min. 0.002). Has
                            to be an integer number of 0.001 secs).\n
        Returns:
            Estimated time of the excecution of the 2D scan.

        NOTE: This function returns as the ramps are started. So you need
        to wait for 'ramptime' until measuring....
        """"""

        if ramptime < 0.002:
            LOG.warning('Ramp time too short: {:.3f} s. Ramp time set to 2 ms.'
                        .format(ramptime))
            ramptime = 0.002
        steps = int(ramptime*1000)
        return self.ramp_voltages_2d(
                            slow_chans=[], slow_vstart=[], slow_vend=[],
                            fast_chans=channellist, fast_vstart=v_startlist,
                            fast_vend=v_endlist, step_length=0.001,
                            slow_steps=1, fast_steps=steps)

    def ramp_voltages_2d(
            self,
            slow_chans: Sequence[int],
            slow_vstart: Sequence[float],
            slow_vend: Sequence[float],
            fast_chans: Sequence[int],
            fast_vstart: Sequence[float],
            fast_vend: Sequence[float],
            step_length: float,
            slow_steps: int,
            fast_steps: int) -> float:
        """"""
        Function for smoothly ramping two channel groups simultaneously with
        one slow (x) and one fast (y) group. used by 'ramp_voltages' where x is
        empty. Function generators and triggers are assigned automatically.

        Args:
            slow_chans:   List of channels to be ramped (1 indexed) in
                          the slow-group\n
            slow_vstart:  List of voltages to ramp from in the
                          slow-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            slow_vend:    list of voltages to ramp to in the slow-group.

            fast_chans:   List of channels to be ramped (1 indexed) in
                          the fast-group.\n
            fast_vstart:  List of voltages to ramp from in the
                          fast-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            fast_vend:    list of voltages to ramp to in the fast-group.

            step_length:  Time spent at each step in seconds
                          (min. 0.001) multiple of 1 ms.\n
            slow_steps:   number of steps in the slow direction.\n
            fast_steps:   number of steps in the fast direction.\n

        Returns:
            Estimated time of the excecution of the 2D scan.\n
        NOTE: This function returns as the ramps are started.
        """"""
        channellist = [*slow_chans, *fast_chans]
        v_endlist = [*slow_vend, *fast_vend]
        v_startlist = [*slow_vstart, *fast_vstart]
        step_length_ms = int(step_length*1000)

        if step_length < 0.001:
            LOG.warning('step_length too short: {:.3f} s. \nstep_length set to'
                        .format(step_length_ms) + ' minimum (1ms).')
            step_length_ms = 1

        if any([ch in fast_chans for ch in slow_chans]):
            raise ValueError(
                    'Channel cannot be in both slow_chans and fast_chans!')

        no_channels = len(channellist)
        if no_channels != len(v_endlist):
            raise ValueError(
                    'Number of channels and number of voltages inconsistent!')

        for chan in channellist:
            if chan not in range(1, self.num_chans+1):
                raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
            if not (chan in self._assigned_fgs):
                self._get_functiongenerator(chan)

        # Voltage validation
        for i in range(no_channels):
            self.channels[channellist[i]-1].v.validate(v_endlist[i])
        if v_startlist:
            for i in range(no_channels):
                self.channels[channellist[i]-1].v.validate(v_startlist[i])

        # Get start voltages if not provided
        if not slow_vstart:
            slow_vstart = [self.channels[ch-1].v.get() for ch in slow_chans]
        if not fast_vstart:
            fast_vstart = [self.channels[ch-1].v.get() for ch in fast_chans]

        v_startlist = [*slow_vstart, *fast_vstart]
        if no_channels != len(v_startlist):
            raise ValueError(
                'Number of start voltages do not match number of channels!')

        # Find trigger not aleady uses (avoid starting other
        # channels/function generators)
        if no_channels == 1:
            trigger = 0
        else:
            trigger = int(min(self._trigs.difference(
                                    set(self._assigned_triggers.values()))))

        # Make sure any sync outputs are configured
        for chan in channellist:
            if chan in self._syncoutputs:
                sync = self._syncoutputs[chan]
                sync_duration = int(
                                1000*self.channels[chan-1].sync_duration.get())
                sync_delay = int(1000*self.channels[chan-1].sync_delay.get())
                self.write('syn {} {} {} {}'.format(
                                            sync, self._assigned_fgs[chan].fg,
                                            sync_delay, sync_duration))

        # Now program the channel amplitudes and function generators
        msg = ''
        for i in range(no_channels):
            amplitude = v_endlist[i]-v_startlist[i]
            # TODO: if amplitute is too large, then split into two parts.
            # if abs(amplitude) > 10: ...
            ch = channellist[i]
            fg = self._assigned_fgs[ch].fg
            if trigger > 0:  # Trigger 0 is not a trigger
                self._assigned_triggers[fg] = trigger
            msg += f""wav {ch} {fg} {amplitude} {v_startlist[i]}""
            # using staircase = function 4
            nsteps = slow_steps if ch in slow_chans else fast_steps
            repetitions = slow_steps if ch in fast_chans else 1

            delay = step_length_ms \
                if ch in fast_chans else fast_steps*step_length_ms
            msg += ';fun {} {} {} {} {} {};'.format(
                        fg, Waveform.staircase, delay, int(nsteps),
                        repetitions, trigger)
            # Update latest values to ramp end values
            # (actually not necessary when called from _set_voltage)
            self.channels[ch-1].v.cache.set(v_endlist[i])
        self.write(msg[:-1])  # last semicolon is stripped

        # Fire trigger to start generators simultaneously, saving communication
        # time by not using triggers for single channel ramping
        if trigger > 0:
            self.write(f'trig {trigger}')

        # Update fgs dict so that we know when the ramp is supposed to end
        time_ramp = slow_steps * fast_steps * step_length_ms / 1000
        time_end = time_ramp + time.time()
        for chan in channellist:
            self._assigned_fgs[chan].t_end = time_end
        return time_ramp
"
157,https://coppermountaintech.com/wp-content/uploads/2020/04/Compact-S5048-Extended-Specification-Sheet.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'att3M5fxriQIUsEuj'), ('width', 1132), ('height', 633), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pomaPuY5kUzEOkmKchXWjQ/GBccGw5_c6umWd1vWvoyo8tAGENtY7Ll6eWwR8dAhwwB2W-ats-seabIlNhwRdbdfNEHjpQ8zF7wZKecW0lO4rkz5jDSlJIeAs9uBgn7DM4/qDwJ0M1SS7_Wc-nKjUcImjc2QK25pe9ts15wKdWIB6w'), ('filename', 'disS5048.png'), ('size', 273882), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4erqprm7psI5PIxg8RY7mQ/c2ySYLm9hCfXZu3q4Yk7MUQBzhJmVraxycSJSJLRroO8sumicIImOC9z7sheflgc6Jbea0SBrA2aDArtT-T6Cg/19PFZtaMMw_SQhPaAmTttU4Tz0o_omOfkcYAs7bCMb8'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/klYphjubd4rr0sYb3fdpDw/Snp9JvFY-H8aY2pm7ZiDD5-UXLDdPY5eA6Mm9-2m0UYdZs6y-KEfEauQDE845Env4O_8tJAd50ScaAXbQFpwxQ/ZTeTFe5BELxWCLa-SV8Y9CchXpUoR4NvOzFSCf-USZg'), ('width', 916), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7dX5I_CxlZD1suM4hto5uQ/p0K_5Zqx37d8TpddPt7PmWz7FlPpTBTKu6pvXKOpM83dyLQaJBFTiPR63tzoKQLngc9zidxq5qR3OBLPP1TZdA/ztG7sXA3Yc40KCx1uI1Ae_-8l6mprqE6Q16pRFLfMzc'), ('width', 3000), ('height', 3000)]))]))])]",301.0,US,"The S5048 Vector Network Analyzer delivers lab grade performance in a compact package, with all the features engineers have come to expect included standard in our software.",https://coppermountaintech.com/discontinued-s5048-2-port-4-8-ghz-analyzer/,S 5048,113.0,['Network Analyzer'],"A vector network analyzer achieves highly accurate measurements by correcting for the systematic errors in the instrument, the characteristics of cables, adapters and test fixtures","**Copper Mountain Technologies** develops innovative RF test and measurement solutions for engineers worldwide that enable engineers to extend their reach.

",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/CopperMountain/S5048.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.CopperMountain.html#module-qcodes_contrib_drivers.drivers.CopperMountain.S5048,Coppermountain,"[OrderedDict([('id', 'atthotVCDq0T4DOTa'), ('width', 1637), ('height', 1279), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Kqn3QsYiwkmYnTP1w6P2ew/dBXIvxdluKvssYIqH2UYKTzzt0O62xjKV752z531FBXL2v5fkbC1hVa5p-F0w78VZEmDtjAs8fYlMFqH5MePt1fg_pqTNFNs3KmJt-ZEtZE/BxNvPMh17ZyQATFobz2Y5SYWhz5ZitD9xyTlBeUxdBo'), ('filename', 'LOGO.webp'), ('size', 59418), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NV5TMyN3ZPi4Im7fC33VsQ/WSiAsBTLn2XM2MgYVvGSV1KfTwN6IomsWA8zjvFykOCdTBwc9TVprUhFI-KNbmFqOaXqO0DxnLuR6iv5NQalVEAEjjlB-s46Afh-anLXNqU/7yzwIZ8MwvkauYyXrAbG0B8lCeZvtXWL60kMoTdsis4'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hBvx_AHugUIWmK4JqSmIYA/tuCbiuumzr7GAVhFtDe8kWbPL1Hc2FEHCRXYJZEC2SP0RBvYfFpSU8ZlDqKKaUaK_uJetZ177eyC2JTd_wpmvw-aiAPf3k5uaFbIN6HSg_M/ic-7RCjjC9lN63WmPQY4pl9mRxJT-bxQXFcU2xNxQ4E'), ('width', 655), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6wojSJxiEGgMgc5YsRX94g/lnkaCG9rutL5VDazeGOzFrZ_yidEVZRdElaKnM6tsqEI3cIDErRMrE3pWu5ydkEkcee2N1clOdsEyxEE8KfVr6mxz01G0QlHxA_NFVlKQGg/PDCc-UCqVubEBxTrZixWYtMaj12wWwKBRBRr0N9Voeg'), ('width', 3000), ('height', 3000)]))]))])]",https://coppermountaintech.com/,S5048 2-Port 4.8 GHz Analyzer,Write a Python script that uses Qcodes Community to connect to a S5048 2-Port 4.8 GHz Analyzer Network Analyzer,,,True,,"from typing import Union
from functools import partial
import logging

import numpy as np

from qcodes.instrument.visa import VisaInstrument
from qcodes.instrument.parameter import ArrayParameter
import qcodes.utils.validators as vals

log = logging.getLogger(__name__)

_unit_map = {'Log Mag': 'dB',
             'Phase': 'degree',
             'Group Delay': None,
             'Smith': 'dim. less',
             'Polar': 'dim. less',
             'Lin mag': 'dim. less',
             'Real': None,
             'Imag': None,
             'SWR': 'dim. less'}


def CMTIntParser(value: str) -> int:
    """"""
    Small custom parser for ints

    Args:
        value: the VISA return string using exponential notation
    """"""
    return int(float(value))


class TraceNotReady(Exception):
    pass


class CMTS5048Trace(ArrayParameter):
    """"""
    Class to hold a the trace from the S5048 network analyzer

    Although the trace can have two values per frequency, this
    class only returns the first value
    """"""

    def __init__(self, name, instrument):
        super().__init__(name=name,
                         shape=(1,),  # is overwritten by prepare_trace
                         label='',  # is overwritten by prepare_trace
                         unit='',  # is overwritten by prepare_trace
                         setpoint_names=('Frequency',),
                         setpoint_labels=('Frequency',),
                         setpoint_units=('Hz',),
                         snapshot_get=False
                         )

        self._instrument = instrument

    def prepare_trace(self):
        """"""
        Update setpoints, units and labels
        """"""

        # we don't trust users to keep their fingers off the front panel,
        # so we query the instrument for all values

        fstart = self._instrument.start_freq()
        fstop = self._instrument.stop_freq()
        npts = self._instrument.trace_points()

        sps = np.linspace(fstart, fstop, npts)
        self.setpoints = (tuple(sps),)
        self.shape = (len(sps),)

        self.label = self._instrument.s_parameter()
        self.unit = _unit_map[self._instrument.display_format()]

        self._instrument._traceready = True

    def get_raw(self):
        """"""
        Return the trace
        """"""
        inst = self._instrument

        if not inst._traceready:
            raise TraceNotReady('Trace not ready. Please run prepare_trace.')

        inst.write('CALC:DATA:FDAT') 
        old_read_termination = inst.visa_handle.read_termination
        try:
            inst.visa_handle.read_termination = ''
            raw_resp = inst.visa_handle.read_raw()
        finally:
            inst.visa_handle.read_termination = old_read_termination

        first_points = B''
        
        for n in range((len(raw_resp)-4)//4):
            first_points += raw_resp[4:][2*n*4:(2*n+1)*4]

        dt = np.dtype('f')
        trace1 = np.fromstring(first_points, dtype=dt)


class CMTS5048(VisaInstrument):
    """"""
    This is the QCoDeS driver for the S5048 Network Analyzer
    """"""

    def __init__(self, name: str, address: str, **kwargs) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)

        self.add_parameter(
            'start_freq',
            label='Sweep start frequency',
            unit='Hz',
            set_cmd=partial(self.invalidate_trace, 'SENS:FREQ:STAR {}'),
            get_cmd='SENS:FREQ:STAR?',
            get_parser=float,
            vals=vals.Numbers(20000, 4800000000))

        self.add_parameter(
            'stop_freq',
            label='Sweep stop frequency',
            unit='Hz',
            set_cmd=partial(self.invalidate_trace, 'SENS:FREQ:STOP {}'),
            get_cmd='SENS:FREQ:STOP?',
            get_parser=float,
            vals=vals.Numbers(20000, 4800000000))

        self.add_parameter(
            'averaging',
            label='Averaging state',
            set_cmd='SENS:AVER{}',
            get_cmd='SENS:AVER?',
            val_mapping={'ON': 1, 'OFF': 0})

        self.add_parameter(
            'number_of_averages',
            label='Number of averages',
            set_cmd='SENS:AVER:COUN{}',
            get_cmd='SENS:AVER:COUN?',
            get_parser=CMTIntParser,
            vals=vals.Ints(0, 999))

        self.add_parameter(
            'trace_points',
            label='Number of points in trace',
            set_cmd=partial(self.invalidate_trace, 'SENS:SWE:POIN{}'),
            get_cmd='SENS:SWE:POIN?',
            get_parser=CMTIntParser,
            vals=vals.Enum(3, 11, 26, 51, 101, 201, 401,
                           801, 1601))

        self.add_parameter(
            'sweep_time',
            label='Sweep time',
            set_cmd='SENS:SWE:POIN:TIME{}',
            get_cmd='SENS:SWE:POIN:TIME?',
            unit='s',
            get_parser=float,
            vals=vals.Numbers(0, 0.3),
            )

        self.add_parameter(
            'output_power',
            label='Output power',
            unit='dBm',
            set_cmd='SOUR:POW{}',
            get_cmd='SOUR:POW?',
            get_parser=float,
            vals=vals.Numbers(-80, 20))
        
        self.add_parameter(
            's_parameter',
            label='S-parameter',
            set_cmd=self._s_parameter_setter,
            get_cmd=self._s_parameter_getter)


        # DISPLAY / Y SCALE PARAMETERS
        self.add_parameter(
            'display_format',
            label='Display format',
            set_cmd=self._display_format_setter,
            get_cmd=self._display_format_getter)

        # TODO: update this on startup and via display format
        self.add_parameter(
            'display_reference',
            label='Display reference level',
            unit=None,  # will be set by display_format
            get_cmd='DISP:WIND:TRAC:Y:RLEV?',
            set_cmd='DISP:WIND:TRAC:Y:RLEV{}',
            get_parser=float,
            vals=vals.Numbers(-10e-18, 1e18))

        self.add_parameter(
            'display_scale',
            label='Display scale',
            unit=None,  # will be set by display_format
            get_cmd='DISP:WIND:TRAC:Y:PDIV?',
            set_cmd='DISP:WIND:TRAC:Y:PDIV{}',
            get_parser=float,
            vals=vals.Numbers(-10e-18, 1e18))

        self.add_parameter(
            name='trace',
            parameter_class=CMTS5048Trace)

        # Startup
        self.startup()
        self.connect_message()
        
    def reset(self) -> None:
        """"""
        Resets the instrument to factory default state
        """"""
        # use OPC to make sure we wait for operation to finish
        self.ask('*OPC?;SYST:PRES')

    def run_continously(self) -> None:
        """"""
        Set the instrument in run continously mode
        """"""
        self.write('INIT:CONT:ALL:ON')

    def run_N_times(self, N: int) -> None:
        """"""
        Run N sweeps and then hold. We wait for a response before returning
        """"""

        st = self.sweep_time.get_latest()

        if N not in range(1, 1000):
            raise ValueError('Can not run {} times.'.format(N) +
                             ' please select a number from 1-999.')

        # set a longer timeout, to not timeout during the sweep
        new_timeout = 1000*st*N + 1000

        with self.timeout.set_to(new_timeout):
            log.debug(f'Making {N} blocking sweeps, setting VISA timeout to {new_timeout/1000} s.')
            self.ask(f'*OPC?;NUMG{N}')

    def invalidate_trace(self, cmd: str,
                         value: Union[float, int, str]) -> None:
        """"""
        Wrapper for set_cmds that make the trace not ready
        """"""
        self._traceready = False
        self.write(cmd.format(value))

    def startup(self) -> None:
        self._traceready = False
        self.display_format(self.display_format())

    def _s_parameter_setter(self, param: str) -> None:
        """"""
        set_cmd for the s_parameter parameter
        """"""
        allowed_s_params = {'S11', 'S12', 'S21', 'S22'}
        if param not in allowed_s_params:
            raise ValueError(f""Cannot set s-parameter to {param}, should be one of {allowed_s_params}"")

        # the trace labels changes
        self._traceready = False

        self.write(f""CALC:PAR:DEF \""{param}\"""")

    def _s_parameter_getter(self) -> str:
        """"""
        get_cmd for the s_parameter parameter
        """"""
        for cmd in ['S11', 'S12', 'S21', 'S22']:
            resp = self.ask('CALC:PAR:DEF?')
            if resp in ['1', '1\n']:
                break

        return cmd.replace('?', '')

    def _display_format_setter(self, fmt: str) -> None:
        """"""
        set_cmd for the display_format parameter
        """"""
        val_mapping = {'Log Mag': 'MLOG',
                       'Phase': 'PHAS',
                       'Group Delay': 'GDEL',
                       'Smith': 'SMIT',
                       'Polar': 'POL',
                       'Lin Mag': 'MLIN',
                       'Real': 'REAL',
                       'Imag': 'IMAG',
                       'SWR': 'SWR'}

        if fmt not in val_mapping:
            raise ValueError(f""Cannot set display_format to {fmt}, should be one of {set(val_mapping.keys())}"")

        self._traceready = False
        
        self.display_reference.unit = _unit_map[fmt]
        self.display_scale.unit = _unit_map[fmt] 
        
        self.write(f'CALC:FORM ""{val_mapping[fmt]}""')

    def _display_format_getter(self) -> str:
        """"""
        get_cmd for the display_format parameter
        """"""
        val_mapping = {'MLOG': 'Log Mag',
                       'PHAS': 'Phase',
                       'GDEL': 'Group Delay',
                       'SMIT': 'Smith',
                       'POL': 'Polar',
                       'MLIN': 'Lin Mag',
                       'REAL': 'Real',
                       'IMAG': 'Imag',
                       'SWR': 'SWR'}

        # keep asking until we find the currently used format
        for cmd in val_mapping:
            resp = self.ask(f'CALC:FORM? ""{cmd}""')
            if resp in {'1', '1\n'}:
                break

        return val_mapping[cmd]
"
158,https://www.keysight.com/us/en/assets/7018-05392/data-sheets/5992-1798.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attBCqJ6pAa942IBP'), ('width', 2000), ('height', 1700), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/tCD2GIGUOGcblcGSD0QfHQ/rxIoVkqNYehib1K4HeXxzwjOmADjvJDil4l_DhPNRWa-3D-kG8KWCuNh6Su7TyetWqiGJWhC6wlJ-ux49KDyFPvKBn_TldkyqK16HPV_Rto/9NjJ1UNXSq0lHbUUxPk8A9xsCFShJZr_X0zGLGG-mbU'), ('filename', 'PROD-2732831-01.png'), ('size', 1316028), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8ci4f5MHyhdVaxFApiVhwQ/mH_P0MmEhgYWNdbXSQbVYer9DLJ4gIVJQPHaUOPlmjaTeH92UWWiNwHO14KOOiFEfxC7YGMSEBlVOpF_3KTcuA/VeVJd5dBFuIS1Gc5rTtM_KSXDVoy5XiyoVxS1IE0fsQ'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/3ZTQPOGNzF22A2dck8wFQw/jtuXSYXWCIUhU2AErLDDXoPS5_Ht1TkWxee7bPTyEUzX00ka0yqYhD3XrLJQgDWuDfvivb13NCYoBMUTBFtfQw/7QTcrNpgJBQW-ObVo2W3LSJCLHGjWeLGj7y7yXfvxd0'), ('width', 602), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XZW-T52SrVhIZgEvN001xA/TAdxb07_7X0sJ3AlbjgqZUFidqXqzLrbpC299p7HUhdiYZbJx_j7RuC6xFbhiqHmu2l8pQKCPm75G_zK5VXd2Q/JTFSxhcO1wTxAyDScNJMsfe7SKsaVgAEcbrWg-ayZRI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"Keysight's M3202A PXIe arbitrary waveform generator offers 4 channels, on-board FPGA with optional software tools that enable real-time sequencing, inter-module synchronization, and graphical FPGA design environment.

",https://www.keysight.com/us/en/product/M3202A/pxie-arbitrary-waveform-generator-1-gsa-s-14-bit-400-mhz.html,M 3202 A,303.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Keysight/M3202A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.M3202A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT M3202A,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT M3202A RF Signal Generator,,,,,"from .SD_common.SD_AWG_Async import SD_AWG_Async


class M3202A(SD_AWG_Async):
    """"""
    qcodes driver for the Keysight M3202A AWG PXIe card.

    M3202A channel numbers start with 1.

    This driver is derived from SD_AWG_Async which uses a thread per module to
    upload waveforms concurrently. The sychronous methods like load_waveform are
    not available in this class.

    Example:
        awg1 = M3202A('awg1', 0, 2)
        ref_1 = awg1.upload_waveform(wave1)

        trigger_mode = keysightSD1.SD_TriggerModes.EXTTRIG
        awg1.awg_queue_waveform(1, ref_1, trigger_mode, 0, 1, 0)

    If you want to test M3202A based on the synchronous SD_AWG, then you can
    instantiate SD_AWG directly.
    Example:
        m3202a_sync = SD_AWG(name, chassis, slot, channels=4, triggers=8,
                             legacy_channel_numbering=False)

    Args:
        name: name for this instrument, passed to the base instrument
        chassis: chassis number where the device is located
        slot: slot number where the device is plugged in
    """"""
    def __init__(self, name: str, chassis: int, slot: int, **kwargs):
        super().__init__(name, chassis, slot, channels=4, triggers=8,
                         legacy_channel_numbering=False, **kwargs)

        module_name = 'M3202A'
        if self.module_name != module_name:
            raise Exception(f""Found module '{self.module_name}' in chassis ""
                            f""{chassis} slot {slot}; expected '{module_name}'"")
"
161,,https://en.wikipedia.org/wiki/Electric_generator,"[OrderedDict([('id', 'att3KT0VioIKKqGNv'), ('width', 300), ('height', 189), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6sKc9csqf_8MUAtjXYF-cg/sC1NYo94HAYsc2Jh42Z1g9hbYWnIS4Xnjz2kYKTKyOVUDBjFiQ31RT3vfeYChse-Adv-sO2S2BxkdCFCeXz6xs_e5Jab_amyrUU3VFWMeko/PibehRdsWe3OAbutt1qa2R5yRMroNQKj8Xwza8uBrKE'), ('filename', 'QDAC-II_01-300x189.jpg'), ('size', 5690), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/dMqEyopnvJ16X7T7u0ef3A/s5Xu4Fth66WTKDIHsgOHnYp5YjZx3RZ9ibd6BxoDfDsVk5ZMrQGgUGPaiQtjzbW0qYPvICCIlC90LL8H5TYorQ/K8N5cOQFRKS94j_F348OYQVLmp9t38Jsnaa0oWs1koc'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/c4mcCwHJ19-OJ2vmyttv6w/Ki_gEiafAsxJky-84AtyU5xtUejyowltrIbQFxAIpKuMOsawYSIH9UgXJvfshx1Ly1qNUJW0Zz4Qkb0cK18crw/0yYBwWxzFAaSX5yRa01uU6-RHsHR-U_cOivBu1JOCI0'), ('width', 300), ('height', 189)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qWhjE54yuyQjLSqrsRd52A/lw36qSO9iExvPRjHSfnQYb2GgBcMxpckOtjf3igKKCOLLtu87Lw12aUl3KXrE-QscQgoFP5hJaCoZxUkx9BT1A/o0X1SMXJF6HJTbI9cLqbMl-X5aCNsi-V0zrlQ5CJKEE'), ('width', 3000), ('height', 3000)]))]))])]",2.0,"COPENHAGEN, DENMARK","QDAC-II is the next generation of the successful QDAC from QDevil. It has all the outstanding features from its predecessor but is even more versatile and with superior performance. QDAC-II is a high-precision ultra-low-noise computer controlled DAC with 24 voltage generators, operating at a sample rate of 1MS/s – a thousand times faster than its predecessor. It is designed for DC and intermediate-frequency control of quantum devices, including, for example, gate electrodes and flux bias coils in qubits, but is a very versatile instrument that can be used for many other purposes. Each of the 24 channels has five voltage generators working in parallel: One for DC, a sine generator, a triangle generator, a square wave generator, and an arbitrary waveform generator (1 million points/second). Additionally, each channel is equipped with a DC current sensor with a resolution down to a few tens of pA, typically used for gate leakage detection and with sample rates up to 3 kHz.",https://qdevil.com/qdac-ii/,Qdac 2 Array,423.0,"['Power Supplies', 'Digital-Analog Converter']","In electricity generation, a generator[1] is a device that converts motive power (mechanical energy) or fuel-based power (chemical energy) into electric power for use in an external circuit. Sources of mechanical energy include steam turbines, gas turbines, water turbines, internal combustion engines, wind turbines and even hand cranks. The first electromagnetic generator, the Faraday disk, was invented in 1831 by British scientist Michael Faraday. Generators provide nearly all of the power for electric power grids.","Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QDevil/QDAC2_Array.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QDevil.html#module-qcodes_contrib_drivers.drivers.QDevil.QDAC2_Array,Qdevil,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rt0ijk1tEeP19zdHVfttFg/7Ob5OL-aQOWHgJLTZlkxZkOheJC0cN05vXsNpZRsU4OHbtOmqBBAZlhmqBSOIWRZUvxG3tQKTXSQ-e54ZcKM4efr6Y_SsndOQXo4lN8vFmQ/I-pT2nu1se1zoP4Grs6M0aBZp6dNS5Hmy5wXPGCI3Vs'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/0EsL2PmoGiY38ganNXLIXA/6F3XRVRPwQG2h6M4Bzu3VIPyNK-686d5qDAzOEx2xCYQnhk8Vg07pNzWuBAXC2npzgWJXgkt6dViRWY8eZ3sVU8teqS8qPGyDsuTtzMWrPc/h8g-OEnf98sLQylcJtEMTjg0rbA7rnR_a4oTo-cTcLc'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/d6gt9ShC3wZMYSwCexAZnw/mZGS-M4xi-162d2C-IrVxIkwYbHnSu_oTyFSt63Y62UPZq_U0ZVVx0m3AIq4mw0JARmzx6D39IdlQ8eKbTwMDvKLUpoWkfuKXTiXoZFJZRM/sl6WH15UvsVy7nXyFYu3VwMHFJSsjBQr3yfODvcLbDQ'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qAV45QZXEAt3b7YfrCuZCQ/-_qwuyLIus2jW_R-Ivn54iGTzh4GJ0KYI11dJ8E6to-VWm4y7BzEtwY0eNjwiEC6jDFfyYzUOj4dbMd223m2Jfzz1gbcZCKF_BFv7jfyTfQ/je3Fsh2bnUiJYjz4JBzgEeN5qpp57TDjds1gIjtuek4'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,Qdac 2 Array,"Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies, Digital-Analog Converter",,,,,"from .QDAC2 import QDac2, QDac2Channel, QDac2ExternalTrigger, \
    QDac2Trigger_Context, Arrangement_Context, ExternalInput, \
    comma_sequence_to_list_of_floats, diff_matrix
from typing import Tuple, Dict, Sequence, List, FrozenSet, Optional
import numpy as np
from time import sleep as sleep_s

# Version 0.1.1
#
# Guiding principles for this driver for multiple QDevil QDAC-IIs
# ---------------------------------------------------------------
#
# 1. Use the underlying QDAC2.py driver as much as possible.
#


#
# Future improvements
# -------------------
#
# - An array arrangement should support corrections between contacts
#   (which the indiviual arrangements on each instrument does).


def _check_for_reserved_outputs(triggers: Dict[str, int]) -> None:
    for trigger in triggers.values():
        if trigger in (4, 5):
            raise ValueError(f'External output trigger {trigger} is reserved')


class Array_Arrangement_Context:

    def __init__(self, qdacs: 'QDac2_Array',
                 contacts: Dict[str, Dict[str, int]],
                 output_triggers: Optional[Dict[str, Dict[str, int]]] = None,
                 internal_triggers: Optional[Sequence[str]] = None):
        self._qdacs = qdacs
        self._arrangements: Dict[str, Arrangement_Context] = dict()
        self._contacts: Dict[str, str] = dict()
        for qdac in qdacs._qdacs:
            qdac_name = qdac.full_name
            qdac_contacts = contacts.get(qdac_name, dict())
            qdac_outputs = output_triggers.get(qdac_name, dict()) if output_triggers else dict()
            is_contoller = (qdac_name == qdacs._controller_name)
            arrangement = None
            if is_contoller:
                _check_for_reserved_outputs(qdac_outputs)
                arrangement = \
                    qdac.arrange(qdac_contacts, qdac_outputs, internal_triggers)
            else:
                arrangement = qdac.arrange(qdac_contacts, qdac_outputs)
            self._arrangements[qdac_name] = arrangement
            for c_name in qdac_contacts.keys():
                if c_name in self._contacts:
                    raise ValueError(f'Contact name {c_name} used multiple times')
                self._contacts[c_name] = qdac_name

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        for arrangement in self._arrangements.values():
            arrangement.__exit__(exc_type, exc_val, exc_tb)
        return False

    @property
    def contact_names(self) -> Sequence[str]:
        """"""
        Returns:
           Sequence[str]: Channel names
        """"""
        return [name for name in self._contacts.keys()]

    def channel(self, contact: str) -> QDac2Channel:
        """"""
        Args:
            contact (str): Name

        Returns:
           QDac2Channel: Instrument channel
        """"""
        qdac = self._get_qdac_for(contact)
        arrangement = self._arrangements[qdac]
        return arrangement.channel(contact)

    def qdac_names(self) -> Sequence[str]:
        return [qdac.full_name for qdac in self._qdacs._qdacs]

    def virtual_voltage(self, contact: str) -> float:
        """"""
        Args:
            contact (str): Name of contact

        Returns:
            float: Voltage before correction
        """"""
        qdac = self._get_qdac_for(contact)
        arrangement = self._arrangements[qdac]
        return arrangement.virtual_voltage(contact)

    def set_virtual_voltages(self, contacts_to_voltages: Dict[str, float]) -> None:
        for qdac in self.qdac_names():
            qdac_voltages: Dict[str, float] = dict()
            for contact, voltage in contacts_to_voltages.items():
                if self._get_qdac_for(contact) == qdac:
                    qdac_voltages[contact] = voltage
            arrangement = self._arrangements[qdac]
            arrangement.set_virtual_voltages(qdac_voltages)

    def currents_A(self, nplc: int = 1, current_range: str = ""low"") -> Sequence[float]:
        """"""Measure currents on all contacts

        The order is that of contacts()

        Args:
            nplc (int, optional): Number of powerline cycles to average over
            current_range (str, optional): Current range (default low)
        """"""
        # Setup current measurement on all instruments
        for qdac in self.qdac_names():
            arrangement = self._arrangements[qdac]
            channels_suffix = arrangement._all_channels_as_suffix()
            arrangement._qdac.write(f'sens:rang {current_range},{channels_suffix}')
            arrangement._qdac.write(f'sens:nplc {nplc},{channels_suffix}')
        # Discard first reading because of possible output-capacitor effects, etc
        slowest_line_freq_Hz = 50
        sleep_s(1 / slowest_line_freq_Hz)
        for qdac in self.qdac_names():
            arrangement = self._arrangements[qdac]
            channels_suffix = arrangement._all_channels_as_suffix()
            arrangement._qdac.ask(f'read? {channels_suffix}')
        # Then make a proper reading on all instruments
        sleep_s((nplc + 1) / slowest_line_freq_Hz)
        values: List[float] = list()
        for qdac in self.qdac_names():
            arrangement = self._arrangements[qdac]
            channels_suffix = arrangement._all_channels_as_suffix()
            currents = arrangement._qdac.ask(f'read? {channels_suffix}')
            values += comma_sequence_to_list_of_floats(currents)
        return values

    def leakage(self, modulation_V: float, nplc: int = 2) -> np.ndarray:
        """"""Run a simple leakage test between the contacts

        Each contact is changed in turn and the resulting change in current from
        steady-state is recorded.  The resulting resistance matrix is calculated
        as modulation_voltage divided by current_change.

        Args:
            modulation_V (float): Virtual voltage added to each contact
            nplc (int, Optional): Powerline cycles to wait for each measurement

        Returns:
            ndarray: contact-to-contact resistance in Ohms
        """"""
        steady_state_A, currents_matrix = self._leakage_currents(modulation_V, nplc, 'low')
        with np.errstate(divide='ignore'):
            return np.abs(modulation_V / diff_matrix(steady_state_A, currents_matrix))

    def _leakage_currents(self, modulation_V: float, nplc: int,
                          current_range: str
                          ) -> Tuple[Sequence[float], Sequence[Sequence[float]]]:
        steady_state_A = self.currents_A(nplc, 'low')
        currents_matrix = list()
        for qdac in self.qdac_names():
            arrangement = self._arrangements[qdac]
            for index, channel_nr in enumerate(arrangement.channel_numbers):
                original_V = arrangement._virtual_voltages[index]
                arrangement._effectuate_virtual_voltage(index, original_V + modulation_V)
                currents = self.currents_A(nplc, current_range)
                arrangement._effectuate_virtual_voltage(index, original_V)
                currents_matrix.append(currents)
        return steady_state_A, currents_matrix

    def _get_qdac_for(self, contact: str) -> str:
        try:
            return self._contacts[contact]
        except KeyError:
            raise ValueError(f'No contact named ""{contact}""')



class QDac2_Array:
    """"""A collection of interconnected QDAC-IIs

    The instruments are required to be connected as described in section 5.5
    'Synchronization of multiple QDAC-II units' in the manual.  The sync
    cables must be left in place after sync, so that the clock is
    continuously distributed, and the Controller can trigger all Listerners
    by sending pulses from Ext Out 4 to all Ext In 3 simultaneously.
    """"""

    def __init__(self, controller: QDac2, listeners: Sequence[QDac2]):
        self._controller = controller
        self._qdacs = [controller, *listeners]  # Order is important
        self._check_unique_names()

    @property
    def trigger_out(self) -> int:
        return 4

    @property
    def common_trigger_in(self) -> ExternalInput:
        return ExternalInput(3)

    @property
    def controller(self) -> str:
        """"""
            Returns:
               str: Name of Controller
        """"""
        return self._controller_name

    @property
    def names(self) -> FrozenSet[str]:
        """"""
            Returns:
               FrozenSet[str]: Names of all QDAC-IIs in the array
        """"""
        return self._qdac_names

    def allocate_trigger(self) -> QDac2Trigger_Context:
        """"""Allocate internal trigger on the Controller

        Returns:
            QDac2Trigger_Context: context manager
        """"""
        return self._controller.allocate_trigger()

    def connect_external_trigger(self, port: int, trigger: QDac2Trigger_Context,
                                 width_s: float = 1e-6
                                 ) -> None:
        """"""Route internal trigger to external trigger

        Args:
            port (int): External output trigger number
            trigger (QDac2Trigger_Context): Internal trigger
            width_s (float, optional): Output trigger width in seconds (default 1ms)
        """"""
        self._controller.connect_external_trigger(port, trigger, width_s)

    def trigger(self, internal_trigger: QDac2Trigger_Context):
        """"""Fire an internal trigger on the Controller

        Args:
            QDac2Trigger_Context: internal trigger
        """"""
        self._controller.trigger(internal_trigger)

    def sync(self) -> None:
        """"""Synchronizes the array of QDAC-IIs

        The Listeners will stop using their own clock and start using the
        Controller's clock.
        """"""
        if len(self._qdacs) < 2:
            raise ValueError('Need at least two instruments to sync')
        self._controller_write(['syst:cloc:send on'])
        self._listeners_write(['syst:cloc:sour ext', 'syst:cloc:sync'])
        self._controller_write(['syst:cloc:sync', 'outp:sync:sign'])

    def arrange(self, contacts: Dict[str, Dict[str, int]],
                output_triggers: Optional[Dict[str, Dict[str, int]]] = None,
                internal_triggers: Optional[Sequence[str]] = None
                ) -> Array_Arrangement_Context:
        """"""An arrangement of contacts across several QDAC-II instruments

        The arrangement is a collection of QDac2.arrangement, one for each
        instrument but with a dedicated controller.

        See QDac2.arrangement() for further documentation.  Note that an
        array arrangement does not (yet) support corrections between contacts
        (which the indiviual arrangements on each instrument does).

        Args:
            contacts (Dict[str,Dict[str, int]]): Instrument name to contact-name/channel pairs
            output_triggers (Dict[str,Dict[str, int]], optional): Instrument name to name/output-trigger pairs
            internal_triggers (Sequence[str], optional): List of names of internal triggers to allocate on the controller

        Returns:
            Array_Arrangement_Context: context manager
        """"""
        return Array_Arrangement_Context(self, contacts, output_triggers,
                                         internal_triggers)

    def _controller_write(self, commands: List[str]) -> None:
        for command in commands:
            self._controller.write(command)

    def _listeners_write(self, commands: List[str]) -> None:
        listeners = self._qdacs[1:]
        for listener in listeners:
            for command in commands:
                listener.write(command)

    def _check_unique_names(self) -> None:
        self._controller_name = self._controller.full_name
        self._qdac_names = frozenset([qdac.full_name for qdac in self._qdacs])
        if len(self._qdac_names) != len(self._qdacs):
            raise ValueError(f'Instruments need to have unique names: {self._qdac_names}')
"
164,https://www.farnell.com/datasheets/3677014.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attmHFq2Bu50vVFGs'), ('width', 300), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/eq1v_-C9wUQvKT-EPD3USg/Yd1qpVJDcjGu059oEheqAvQNyCJPw2LRoaad_E0Mr-s8z-_zHHxr0JZmfMdsVZhEr1fbTUfDZkaJraw0gMlMpxGbsQOmbQ9-Ezs_Ujmt85s/YCU7gLbwH9jWQ_FY-7ZgJv0VnF5I0HuijpiX_rWULUM'), ('filename', 'HMP2030_04-875-.jpg'), ('size', 16316), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mzkB3tmGhJJyyQbTTCk4ag/ZRujoh-zfYDI6KELs8nd7lIQumDLE72bDEZCKiXCe706k0z-tBt7wyyqW0L9t-7rx-3y0UbHqrK4fUJ0al94eg/_PKg3w49sZh1Bn3GtDKc9foB8_7Qj1BMBKxB98SVk7U'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Z3YoXFznl7DXrVJqqZ6aRw/QKcG_-bMo0StIPlWO4eaISjCeedbMzexvMPGs-W-esjf1-_SX1GZOgvXL_dkGJtjwQt-udBPMHjg9V3x-ywAdg/F4skRDmdQ-ZZ1ComJOO-zkOw6tvVjoXpl4EY6_8pACM'), ('width', 300), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9EuzCTkJqYoA68W2lMvDxQ/wkucFiMV9afMJ966UAfQRfWriCd9YvYwI0Z3_Dt2v_DvOluwpGoFhW5mRHhobMEsR1t1o3tmN65osyONKiizaQ/8BVTPy6mONW5whRpYJZuYrdDEzm0G0KJoKFk8nbdHls'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",The R&S HMP2020 two-channel power supply deliver up to 188 W total output power,https://www.tequipment.net/Rohde-&-Schwarz/HMP2020/DC-Power-Supplies-/-Lab-Power-Supplies/?gclid=CjwKCAjw-vmkBhBMEiwAlrMeFwYpZRtIgfIz93ieslLUYQquAPXSMNXgoggVpuLMDUcB8NwBOp2wUxoCNKcQAvD_BwE,HMP 2020,484.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMP2020,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMP2020.py,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMP 2020,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,1945.0,,,,
171,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attDZEn0j6ttyKWqa'), ('width', 735), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VNpRTBAVmBaX7_OMtBuIFg/RLJ9rl7_HLQdb2nYKfLoBlxQdR-qjOM9DYP5WnSK069ceURz0duvuACMbTCrbyfKBLmGiqFCuW-Fl-6yq_jsjl7JPmz7SJ0QjzNSA4497es/PRMB_jbp8maqZAIybLkoPiYVikOL2Pv1-JBUTxAri7M'), ('filename', 'lda-802-12.png'), ('size', 97818), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Hrgji4vH1EMEVGIvia-ClA/Nkemhvl7WOYUYQx_Bv3umCkbP4c_QyjljHRV6Stvm4-jtJGhKVg9collw8XgHkU70Yqa9cFL_0KFREalk7YRjw/4-fMp3pg1FwB0vmXxbNuvXjEVOohtfJQ1k2EJ2McR4I'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DSC3Mpvn19vt-sZSruUwBg/9Fyy81QXgG2IfreyBJRwFO6B8kvNAnJqRrrw-KyuV5Ns_ALVc_xiy-dK0yupUMbBbqxI8FGOXbFmx81YyP9JNA/A8kEds8bBPoIYctJfT21Oo4FiCpOk3HAlAHiJOoG2IM'), ('width', 735), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/B8Bg4VJL1Gy5eTHj7vY2aw/eeBFbpLbEYKyHRSmBYcF0YqU14aZeFc5UZMq3tLQF9cYG-gwqsoPnPbeUKj6aTxdXlr0jbQSHjt0dC8wjXmorg/P8VdTC240r9eAOD7R--7GF5NbQlAjvGjrgM7Jp3vdAg'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802-12 Digital Attenuator is a rack mounted 12-channel high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802-12 provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802-12-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802-12,Write a Python script that uses Qcodes Community to connect to a LDA-802-12 ,8500.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
180,,https://en.wikipedia.org/wiki/Analog-to-digital_converter,"[OrderedDict([('id', 'attZrjq58VqBzHqyT'), ('width', 900), ('height', 651), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wp99XKHqj7QjIpkdfenZPg/U7JV__xX7fn2lTXz3hH_snyYrsp8cWYAC-TTER8Igv5cqdLBMna9hW-s7rU0gDXvil79kMRGE6Cznmk-776q7LjE-CrZh83xZV5BTmvynKI/fco12RIM2pvP5UqAAGPVM7Wqq0rg7AdXQ0V_4QOqLZ0'), ('filename', '1631520501071.jpg'), ('size', 72487), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/2klw5f4VuY2mxICmk9QvrA/aMrtfR0ohImpjbIP_qTfhjFI9NGHc1caj-1NcpOfOI72RXDP5MHczzMg-W29QbmPDsUHoa0nMVcU5z-N1CuNfA/k2NQRoyVkwZtttkms5U2ql9SU_p_bsvs21vvw9NkrGg'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/i1-m6oEgfD0NJ-VRW6MGYw/sn6mS4WHjVEoM1SPyq25zAb-WqYeOUJ24zLdSMsxGobjzl853IjEfByyugz2oD1ooMqJY0OFoe6k8s215W-m_g/5FpBK8OuFVNuTz9kDN6c8BVMkc5eBSIpsUYADfM7rVo'), ('width', 708), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/0gYFshvGc_7lEG5jRaV0wg/DP08qDwsUDc6qzrEBixkoHGl0hcYH5qKhKNfDF79Nefj8q35VQbE1vHr-QifOdsk46zfvD0px8wuVREbP3F63g/mmyHHNSS02tpsmRs1MYbY2dJCSZcDIQ9FG_hn2396ZI'), ('width', 3000), ('height', 3000)]))]))])]",1657.0,"Austin, Texas, USA","Data acquisition (DAQ) is the process of measuring an electrical or physical phenomenon, such as voltage, current, temperature, pressure, or sound. A DAQ system consists of sensors, DAQ measurement hardware, and a computer with programmable software such as LabVIEW.

",https://www.ni.com/en-ca/shop/data-acquisition.html,DAQ,373.0,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","A producer of automated test equipment and virtual instrumentation software. Common applications include data acquisition, instrument control and machine vision. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/NationalInstruments/DAQ.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.NationalInstruments.html,National Instruments,"[OrderedDict([('id', 'attXAVi8mGWUwkEk7'), ('width', 960), ('height', 541), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/j_Cmz4uga8rm7Jk-W_hKJA/OFEsr4zAjNbG-yC55hU0noMqYtoPe9vQD-Gl-SI0_1-hw4p7TC8Qdz0fFEtGOyg7Gp-hqmHtvDJ5Uc0FHOeTZg/VpMBAVW2a1O5TmWcxSYkEtHm4BcyD8QObKnNg5JfgT0'), ('filename', '0x0.webp'), ('size', 3600), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4ZfSfzm3FWUK3mOB22JVow/iKinLC2EHIADrqenQyQb4vXtxsXSU3vw7pErcZG_x94ZnV7BNdl1ATxfilb4AcI9AzC_jsIekTtgJ4AgWnIY-b1Hh0id6SKbfLgxWmnsBXo/fH59fAbtvfp-o76XqOSe5kcylQsoXwwwMGdcmXpo_nU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Rc_oPk909VeMPUIitsLj0w/FGlkfJlj5eu6r1O9HbQw96t_v9q8ABFOEQoC6d-bOa2Qdc1ops_fMtexXqE0QP7SXa02gEfs2oNFOOrrKS_LXbc2EJwN2G-Q5nDLPE18cCU/8v_OfysCX2mh7OF_Gi8ehcKkabwz3aT5QxGDtwHH5Co'), ('width', 909), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VrmEJSvE-wFyX58WI74X5w/21j--KVJrXwHWTW9l2FxBDTcxAsHk77Bi_xQtjImpzHfA--vqGMI_jVdQr3fG77lJzEyZHS6dUQe__YLb2i04-hmeB9UHAvi4AiVzzQBF1Q/NpnfS_vHNbJaSo4ZYcewJF_7ZX-hLmRd65vYunzSeig'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ni.com/en-ca.html,DAQ,Write a Python script that uses Qcodes Community to connect to a DAQ DAQ boards,,,,,"""""""Qcodes drivers for National Instrument mutlifunction I/O devices (DAQs).

Requires nidaqmx package: https://nidaqmx-python.readthedocs.io/en/latest/

This was written for/tested with National Instruments USB-6363 DAQ,
but the nidaqmx API is pretty general, so I expect it will work with other devices
with minimal changes.

For an example of synchronously writing data to multiple analog outputs and
acquiring data on multiple analog inputs, see
https://scanning-squid.readthedocs.io/en/latest/_modules/microscope/susceptometer.html#SusceptometerMicroscope.scan_surface
""""""

from typing import Dict, Optional, Sequence, Any, Union
import numpy as np

import nidaqmx
from nidaqmx.constants import AcquisitionType, TaskMode
from qcodes.instrument.base import Instrument
from qcodes.instrument.parameter import Parameter, ArrayParameter, ParameterWithSetpoints
from qcodes.utils.helpers import create_on_off_val_mapping
from nidaqmx.constants import LineGrouping

class DAQAnalogInputVoltages(ArrayParameter):
    """"""Acquires data from one or several DAQ analog inputs.

    Args:
        name: Name of parameter (usually 'voltage').
        task: nidaqmx.Task with appropriate analog inputs channels.
        samples_to_read: Number of samples to read. Will be averaged based on shape.
        shape: Desired shape of averaged array, i.e. (nchannels, target_points).
        timeout: Acquisition timeout in seconds.
        kwargs: Keyword arguments to be passed to ArrayParameter constructor.
    """"""
    def __init__(self, name: str, task: Any, samples_to_read: int,
                 shape: Sequence[int], timeout: Union[float, int], **kwargs) -> None:
        super().__init__(name, shape, **kwargs)
        self.task = task
        self.nchannels, self.target_points = shape
        self.samples_to_read = samples_to_read
        self.timeout = timeout
        
    def get_raw(self):
        """"""Averages data to get `self.target_points` points per channel.
        If `self.target_points` == `self.samples_to_read`, no averaging is done.
        """"""
        data_raw = np.array(self.task.read(number_of_samples_per_channel=self.samples_to_read, timeout=self.timeout))
        return np.mean(np.reshape(data_raw, (self.nchannels, self.target_points, -1)), 2)
    
class DAQAnalogInputs(Instrument):
    """"""Instrument to acquire DAQ analog input data in a qcodes Loop or measurement.

    Args:
        name: Name of instrument (usually 'daq_ai').
        dev_name: NI DAQ device name (e.g. 'Dev1').
        rate: Desired DAQ sampling rate per channel in Hz.
        channels: Dict of analog input channel configuration.
        task: fresh nidaqmx.Task to be populated with ai_channels.
        min_val: minimum of input voltage range (-0.1, -0.2, -0.5, -1, -2, -5 [default], or -10)
        max_val: maximum of input voltage range (0.1, 0.2, 0.5, 1, 2, 5 [default], or 10)
        clock_src: Sample clock source for analog inputs. Default: None
        samples_to_read: Number of samples to acquire from the DAQ
            per channel per measurement/loop iteration.
            Default: 2 (minimum number of samples DAQ will acquire in this timing mode).
        target_points: Number of points per channel we want in our final array.
            samples_to_read will be averaged down to target_points.
        timeout: Acquisition timeout in seconds. Default: 60.
        kwargs: Keyword arguments to be passed to Instrument constructor.
    """"""
    def __init__(self, name: str, dev_name: str, rate: Union[int, float], channels: Dict[str, int],
                 task: Any, min_val: Optional[float]=-5, max_val: Optional[float]=5,
                 clock_src: Optional[str]=None, samples_to_read: Optional[int]=2,
                 target_points: Optional[int]=None, timeout: Optional[Union[float, int]]=60, **kwargs) -> None:
        super().__init__(name, **kwargs)
        if target_points is None:
            if samples_to_read == 2: # minimum number of samples DAQ will read in this timing mode
                target_points = 1
            else:
                target_points = samples_to_read
        self.rate = rate
        nchannels = len(channels)
        self.samples_to_read = samples_to_read
        self.task = task
        self.metadata.update({
            'dev_name': dev_name,
            'rate': f'{rate} Hz',
            'channels': channels})
        for ch, idx in channels.items():
            channel = f'{dev_name}/ai{idx}'
            self.task.ai_channels.add_ai_voltage_chan(channel, ch, min_val=min_val, max_val=max_val)
        if clock_src is None:
            # Use default sample clock timing: ai/SampleClockTimebase
            self.task.timing.cfg_samp_clk_timing(
                rate,
                sample_mode=AcquisitionType.FINITE,
                samps_per_chan=samples_to_read)
        else:
            # Clock the inputs on some other clock signal, e.g. ao/SampleClock for synchronous acquisition
            self.task.timing.cfg_samp_clk_timing(
                    rate,
                    source=clock_src,
                    sample_mode=AcquisitionType.FINITE,
                    samps_per_chan=samples_to_read
            )
        # We need a parameter in order to acquire voltage in a qcodes Loop or Measurement
        self.add_parameter(
            name='voltage',
            parameter_class=DAQAnalogInputVoltages,
            task=self.task,
            samples_to_read=samples_to_read,
            shape=(nchannels, target_points),
            timeout=timeout,
            label='Voltage',
            unit='V'
        ) 

class DAQAnalogOutputVoltage(Parameter):
    """"""Writes data to one or several DAQ analog outputs. This only writes one channel at a time,
    since Qcodes ArrayParameters are not settable.

    Args:
        name: Name of parameter (usually 'voltage').
        dev_name: DAQ device name (e.g. 'Dev1').
        idx: AO channel index.
        kwargs: Keyword arguments to be passed to ArrayParameter constructor.
    """"""
    def __init__(self, name: str, dev_name: str, idx: int, **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.dev_name = dev_name
        self.idx = idx
        self._voltage = np.nan
     
    def set_raw(self, voltage: Union[int, float]) -> None:
        with nidaqmx.Task('daq_ao_task') as ao_task:
            channel = f'{self.dev_name}/ao{self.idx}'
            ao_task.ao_channels.add_ao_voltage_chan(channel, self.name)
            ao_task.write(voltage, auto_start=True)
        self._voltage = voltage

    def get_raw(self):
        """"""Returns last voltage array written to outputs.
        """"""
        return self._voltage

class DAQAnalogOutputs(Instrument):
    """"""Instrument to write DAQ analog output data in a qcodes Loop or measurement.

    Args:
        name: Name of instrument (usually 'daq_ao').
        dev_name: NI DAQ device name (e.g. 'Dev1').
        channels: Dict of analog output channel configuration.
        **kwargs: Keyword arguments to be passed to Instrument constructor.
    """"""
    def __init__(self, name: str, dev_name: str, channels: Dict[str, int], **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.metadata.update({
            'dev_name': dev_name,
            'channels': channels})
        # We need parameters in order to write voltages in a qcodes Loop or Measurement
        for ch, idx in channels.items():
            self.add_parameter(
                name=f'voltage_{ch.lower()}',
                dev_name=dev_name,
                idx=idx,
                parameter_class=DAQAnalogOutputVoltage,
                label='Voltage',
                unit='V'
            )
            
class DAQDigitalOutputState(Parameter):
    """"""Writes data to one or several DAQ digital outputs.

    Args:
        name: Name of parameter (usually 'voltage').
        dev_name: DAQ device name (e.g. 'Dev1').
        lines: DO lines.
        kwargs: Keyword arguments to be passed to ParameterWithSetpoints constructor.
    """"""
    def __init__(self, name: str, dev_name: str, lines: Union[list, str], **kwargs) -> None:
        super().__init__(name, get_cmd=None, **kwargs)
        self.dev_name = dev_name

        if type(lines) is str:
            lineString = dev_name + '/' + lines
        else:
            comma = [', ']*len(lines)
            dev = [dev_name+'/']*len(lines)
            lineString = ''
            lineString = lineString.join([val for set in zip(dev, lines, comma) for val in set][0:-1])

        self.lines = lineString

    def set_raw(self, state: Union[list, bool]) -> None:
        with nidaqmx.Task('daq_do_task') as do_task:
            do_task.do_channels.add_do_chan(self.lines,
                                            line_grouping=LineGrouping.CHAN_PER_LINE)
            do_task.write(state, auto_start=True)


class DAQDigitalOutputs(Instrument):
    """"""Instrument to write DAQ digital output data in a qcodes Loop or measurement.

    Args:
        name: Name of instrument (usually 'daq_do').
        dev_name: NI DAQ device name (e.g. 'PXI1Slot2').
        lines: DO lines.
        **kwargs: Keyword arguments to be passed to Instrument constructor.
    """"""
    def __init__(self, name: str, dev_name: str, lines: Union[list, str], **kwargs) -> None:
        super().__init__(name, **kwargs)

        self.metadata.update({
            'dev_name': dev_name,
            'lines': lines})
        
        self.lines = lines
        
        self.add_parameter(
                name='state',
                dev_name=dev_name,
                lines=lines,
                parameter_class=DAQDigitalOutputState,
                label='DO state'
        )
"
183,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attBMWDZd2KeFE3R4'), ('width', 623), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DoTffxTfgUni7AAdTUu9cQ/0_wUatLqkUGr5WqvYTrbK3NGrto18wVo7Mq5pv5YIFsB3FnDoZp1CDD2oN0ruY1OpMgcU-KTLUtw0vkuK2rejr01Sy597nVXm6m1RV_j2WPIZe7Ut7ZrF4Z6-zJ7hz4b/wusXIOGHTmFU84m8RIjQtOVPsOP8CixW4fPMik4Odzk'), ('filename', 'vx-new-product-lda906v-8-(1).png'), ('size', 418145), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SwaYdv3mFCzLSKR2ClQXLw/snBBnhk6qS-j3N_LmeoEafe9f5E7LlhU5CYU_1PGcVYp6etQraJ5HlSkHfm5L6ffLnOyU2kDti0p7N02_OBNYQ/60qnWZNefDmFLZmxoev3JsOF9CHROs2xbLg8ujNc3ik'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/enNCMAIItM9Cs3l9gG1PEA/lKKNM-1V7lQmySIfzNmS6a9VeN6mMZqHONfVEnZinbdoO4r7z5DuHG45NRynUjQGXvfGY0WBplISU26RW-5-Fw/t75v-9B_9LdRRarvn4xsqp5cmO5tbzMlL1V41NN7v6c'), ('width', 512), ('height', 631)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BBlQQYSpS0YLHtby_kZOtA/JJi5Sk3-XksGr-pr4VQZ2bVX9xkmQiYyMx7iEKQAYprpsrRkq7qn5638oc1TGvglYWFwxoSDj-eS067GIW-NPg/TWrVb-RmDX0B1TQdZS6lN729ZuoOBp1XmbM6kVLQeoc'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-908V-8 Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator. The LDA-908V-8 provides calibrated attenuation from 1 to 8000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 90 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-908v-8-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-908V-8,Write a Python script that uses Qcodes Community to connect to a LDA-908V-8 ,3499.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
186,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'att6VaAHLw9x5bwHe'), ('width', 749), ('height', 597), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ERcxhL5FY9OoWmeX6Z62Sg/fKIkh0A4vpYroUUN_rsXWCSuomPQCAySO3kb1pTC809LsNgx1_sslKfxTsKFNRpzXHviPFYKI-xslgM6f7ahlfd0XDJ_gTrYu4ua-8TYZ1osxNFUB_uRq4tcyQUwWPDX/s05UzWfIYg1YUZP30ja1h0d4WPrNq1U40-aLjjjcuzg'), ('filename', 'lda-403-product-photo.png'), ('size', 432745), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Ag8fqxF-UwzHnVkNxDFrtQ/Gfxc-OqurXptgtunj0rN0L29hOXtTNxpqdUEnepbhf2H2GuuIa84a5eerryUIat75cAjzOSRez9qb-GDVxHWtg/6tdQhE48grtCZY391QXDpEGZaELj7e5Tjc588L63DQA'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NJaNv11gh7-Xddjdi_ftgA/SxDgPayvKduvlbThgrlGLNTDcBkU4veYLjjFL43IlSouFV7LpRHDcVQvkFqWgvhS1kUU-vJ5SdpOf7s4vhnGTw/QeXKYJdioCr6nrMEjci5JW-xRfKT9AXmVmykc99OWSo'), ('width', 642), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Im2T7uHCWp9DoBmOeCMukg/7PX2quhWncw19YIxedFt5aUlcOmLSnBjciBrv2Emx1V9pHqZKyHyZgCGw7i_itpAtAWp6lJ6BGOr750wcmi1VQ/dd4SqbSHTsVeSKZkmBuCpY3-fWCYecCCt6-S0Y4SqHc'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-403 offers both USB and Ethernet interfaces. The USB port uses a native HID interface to avoid the difficulties inherent in using older serial or IEEE-488 interfaces implemented over USB. As a result, Lab Brick users can get to work faster without having to install kernel level drivers, and Lab Brick devices can be easily used on any system that supports USB HID devices, including low-cost embedded computers using Linux or similar operating systems. The Ethernet interface is configurable for Static IP or DHCP with the ability to assign the HTTP port for extra security.


The LDA-403 Digital Attenuator is a bidirectional, 50 Ohm step attenuator. The LDA-403 provides attenuation control from 0.1 to 40 GHz with a step size of 0.5 dB.",https://vaunix.com/lda-403-01-40-ghz-frequency-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-403,Write a Python script that uses Qcodes Community to connect to a LDA-403 ,2995.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
191,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attjFawHPuZIhCIvm'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Tcao1N7OjTvm_2bwlC4Mwg/aP_f6S0BamNesjU-q2zhpCiS9upeMJsEQxZa-lX-TMeX71Mn8n2gKW1YawqiLrLJeo6MDp0Ago5xU6LIFoeFl6VTXh1kAFB246S_Hky5p0Vwrs0j-78IGUGPjtB67KZO/HmUcO-eyZGv5AC1U4DPugwty6vnSr155Gn7ITTNfyEo'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1NRe1eslamsBwGo5bYw-3w/KIclcvgjqHOkBu-lPO3LKD0vcMBZTFXpxe_yztwHQB3i6YbTxRk1pOjziHHsIPcc4-xJbfsMSvPWNIryXJ-H-w/aLrNaWpAV5bb4JC8Sj8B2bSe8oIW-_1c4Lq_25p84a8'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y4VtEMjAX8RN4wNi43Rv0g/I3WMLg0vmihz1eV3ZvbeGQb1yzQnv-AIDccgh3PMgSICbwPk0UglR0Aa6juUm6EEiRJju8eoRlYKw8s6Ec0eGA/lcU21GVvJ7Bkw-HEqH_WExtJvhjsccUvT-4v5OSqk3k'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sUUfTZ7JxfttdhubXl2_Jw/1CDC8kJyuNM7f2GiyqAAZE4-btZwBvNj_RVfRMC2KyT11RIBr7paLAQIAqHrQgK3jF1CwLCxqzxD941qe_rEaA/dOmd6KSbbHew9ePHQtH-MtkoRnQD0BmYwk7O-MB-Ka0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-2 Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 90 dB and a step size of 2.0 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-302p-2-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-2,Write a Python script that uses Qcodes Community to connect to a LDA-302P-2 ,599.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
192,,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attNVbfKwdtG9nAid'), ('width', 305), ('height', 276), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MnNL3giPee635iTZcmJtLw/Hdy7t3q84S6PCasGwJ9KVzNe0wnLW_jSvjriQglTo7APpzzIhRgTJKDB9iw197RG6_alVwDEBFPZGJW7ELEsyVwgmeWTU4JC2ftnusSzunjcl63spAKEyrCAYwEDSvGK/sZiFP2yIv973CRyrS33G2u0PwOn_JmwhFbzTZk8eRuw'), ('filename', 'motorized_variable_wheel_attenuator.jpg'), ('size', 9727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kyRVcez-PVk812OeWiaUIQ/LYgBop3PbmRdkKikyxOPVAbKooAdvzFEigT3fr8bW4kz1DFtN45GIzHGF_RzktI7GgtCwvFcwJSGoJMsJJExmA/QZkSXmI7D07aQ9HcgQg9D90Yx2IqLTw7mjUd5KFQS30'), ('width', 40), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NN6Ln22RT0VzR2nxb1rg0g/5JeMUAOGofxnrox7NvWA2RQrlVIljebUkPs_EW5MQgp2qiI3POpEiz12nU7_vvYz__aq5cGFmdzeglKZzqgpjw/-VjE8RsES2tgZIYIxf4RVqIODakSNRoKdtDOKAfiU5U'), ('width', 305), ('height', 276)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5IeACF1zBn5vpMAEvcKAeA/ZqRW_sT0p8moiV1EmVJ5TEZ7u7bnSQYXx0Cl8Oi45tmSZeQYmj7B8NoT578zSQ-hu8rYYoRhyDtgup8ZKdTo3w/YhavjOrwMJJkdGOFFyNy-Ju-47oi8vWg2z9NWTyjDGQ'), ('width', 3000), ('height', 3000)]))]))])]",5.0,Lithuania,"Motorized Variable Two Wheels Attenuators 10MWA168 consists of two filter wheels. Each wheel contains eight filter mounts of ØD mm with clear aperture of Ød mm. Each mount is inclined by 4 degrees to prevent mutual reflections between filters. We supply the attenuator 10MWA168-20 with a standard, most popular, set of filters. See the table below. Alternatively, optics could be manufactured to individual orders. Or we could supply the attenuator without filters, which you can fit by yourself. 10MWA168-1 model comes WITHOUT filters. You bring a filter of each wheel into the optical path easily by hand or using automation. A single step motor drives the two wheels. A computer can operate the filter attenuator via a controller. Controllers are sold separately. For fastening, the attenuator has clearance slots for M6 and M4 screws. There are also two M6 holes, and one M4 hole (opposite to one of the M6 holes). Material: black anodized aluminium.",https://www.standa.lt/products/catalog/motorised_positioners?item=233,Standa 10 MWA 168,529.0,['Lockin Amplifiers'],"An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Standa has it's own industrial base that includes CNC turning, milling, grinding machines. Standa's design department, while developing standard products presented in Standa's catalogue (such as motorized and manual translation and rotation stages, motion controllers, optical tables, vibration isolation systems, optical mounts and holders, optics, dpss lasers and etc.) also develops the equipment for OEM customers. Some examples of it, after the agreement with OEM customers, are shown on this website. Standa currently has several laser product development laboratories.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Standa/Standa_10MWA168.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/Standa_10MWA168.html,Standa,"[OrderedDict([('id', 'att2pFOPlQ9KlvPIt'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ib4GeEJORMg_XDqrYFhacw/tgCOO2jPH-yCM23rRXldWmFGM9Vdlh8wYsjrMCNRlBofRsK7B2leyxNTV6ralgkwUL56Jwkr9JkZchfMNYpTk0_5VTQyuB74qKOKV1D4KsY/HwozbBPZjobQs8yoPFp20Z4I5QR3i3-ynvbxU01m6nk'), ('filename', '1580914811189.jpeg'), ('size', 10393), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mOZVSSscQ-4ix1QPAFNMqQ/_tOARvZPZoNTiAD5orC20M-pC59-pXKZdpatfuigWrCNNiNkokyT9-CCvvZ02uXWOjxRwx9cAWbMaDQa6IOTuA/g5MJgzrQD6YlguxV-LbGzXYw858h3td3wV2U2ZjQlbU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/o-bFEhpyY-wpZnAFctOVhA/GKQL7BnMGQ90HRMnmzdjMyNtDcc326Yc2oMP744rGvzolApji9oNyeXBOuNsqsoEWk7DT4OBAMWACdphGJpB1g/gejf4qRJHzpJtxNga-HZy9InXCf67izi0VTC_yaxpH4'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/T2HOd_EKP49VA5Q9nI-SiA/1SXo1Y2WSyZSByFMDSG_9NRKVTdof48Q_L1F_pkJ0-HjKN2ThUgm68cyPnGxx6GzlpT0Y907_bhpduRmI_jJ0g/MlHzUGC3JmVJ0eydBiqp4j2ssDMw-AUYLHXmjz_qp1c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.standa.lt/,Standa 10MWA168,Write a Python script that uses Qcodes Community to connect to a Standa 10MWA168 Lockin Amplifiers,,,,,"from qcodes import Instrument
import ctypes
import numpy as np
import os
import time


class DeviceInformation(ctypes.Structure):
    _fields_ = [
        (""Manufacturer"", ctypes.c_char * 5),
        (""ManufacturerId"", ctypes.c_char * 3),
        (""ProductDescription"", ctypes.c_char * 9),
        (""Major"", ctypes.c_uint),
        (""Minor"", ctypes.c_uint),
        (""Release"", ctypes.c_uint),
    ]


class GetPosition(ctypes.Structure):
    _fields_ = [
        (""Position"", ctypes.c_int),
        (""uPosition"", ctypes.c_int),
        (""EncPosition"", ctypes.c_longlong),
    ]


class Status(ctypes.Structure):
    _fields_ = [
        (""MoveSts"", ctypes.c_uint),
        (""MvCmdSts"", ctypes.c_uint),
        (""PWRSts"", ctypes.c_uint),
        (""EncSts"", ctypes.c_uint),
        (""WindSts"", ctypes.c_uint),
        (""CurPosition"", ctypes.c_int),
        (""uCurPosition"", ctypes.c_int),
        (""EncPosition"", ctypes.c_longlong),
        (""CurSpeed"", ctypes.c_int),
        (""uCurSpeed"", ctypes.c_int),
        (""Ipwr"", ctypes.c_int),
        (""Upwr"", ctypes.c_int),
        (""Iusb"", ctypes.c_int),
        (""Uusb"", ctypes.c_int),
        (""CurT"", ctypes.c_int),
        (""Flags"", ctypes.c_uint),
        (""GPIOFlags"", ctypes.c_uint),
        (""CmdBufFreeSpace"", ctypes.c_uint),
    ]


class libximc:
    # TODO: use error check, implement wait for stop function from dll

    # default dll path
    _dll_path = 'C:\\Program Files\\XILab\\libximc.dll'

    # success and error codes
    _success_codes = {0: 'Ok'}
    _error_codes = {-1: 'Error', -2: 'NotImplemented', -3: 'ValueError', -4: 'NoDevice'}

    def __init__(self, dll_path=None, verbose=False):
        # save attributes
        self.verbose = verbose

        # connect to the dll
        current_path = os.getcwd()
        try:
            os.chdir(os.path.dirname(self._dll_path))
            self.dll = ctypes.windll.LoadLibrary(dll_path or self._dll_path)
        finally:
            os.chdir(current_path)

        # set resource type
        self.dll.enumerate_devices.restype = ctypes.POINTER(DeviceInformation)

    def error_check(self, code, function_name=''):
        if code in self._success_codes.keys():
            if self.verbose:
                print(""libximc: [%s]: %s"" % (function_name, self._success_codes[code]))
        elif code in self._error_codes.keys():
            print(""libximc: [%s]: %s"" % (function_name, self._error_codes[code]))
            raise Exception(self._error_codes[code])
        else:
            print(""libximc: [%s]: Unknown code: %s"" % (function_name, code))
            raise Exception()

    def command_move(self, device_id, position, u_position):
        self.dll.command_move(device_id, position, u_position)

    def enumerate_devices(self, probe_flags):
        enumeration = self.dll.enumerate_devices(probe_flags, b"""")
        return enumeration

    def get_device_name(self, device_enumeration, device_index):
        device_name = self.dll.get_device_name(device_enumeration, device_index)
        return device_name

    def get_position(self, device_id, get_position):
        self.dll.get_position(device_id, get_position)

    def get_status(self, device_id, status):
        self.dll.get_status(device_id, status)

    def open_device(self, device_name):
        device_id = self.dll.open_device(device_name)
        return device_id


class Standa_10MWA168(Instrument):

    def __init__(self, name, serial_number, dll_path=None, **kwargs):
        super().__init__(name, **kwargs)

        # link to dll
        self.libximc = libximc(dll_path=dll_path)

        # instrument constants
        self.filter_wheel_1 = [-1, 0, 1, -1, 1, 2, -1, 1, 2, 3, 3, 3, 1, 2, 4, 4, 1, 2, 5, 5, 4, 1, 2, 6, 6, 6, 2, 5, 6, 6, 6]
        self.filter_wheel_2 = [-1, 0, -1, 1, 1, 1, 2, 2, 2, -1, 1, 2, 3, 3, -1, 2, 4, 4, -1, 1, 3, 5, 5, -1, 1, 2, 6, 4, 4, 5, 6]
        self.offset_wheel_1 = 0.
        self.offset_wheel_2 = 62.
        self.revolution = 200.
        self.distance = self.revolution / 8.

        # initialization
        self.serial_number = serial_number
        device_enumeration = self.libximc.enumerate_devices(0)
        enumeration_name = self.libximc.get_device_name(device_enumeration, 0)
        self.device_id = self.libximc.open_device(enumeration_name)

        # Time to wait (in seconds) between setting up wheel 1 and 2
        self.set_transmittance_sleep_time = 10.0

        # add parameters
        self.add_parameter('transmittance',
                           set_cmd=self._set_transmittance,
                           label='Transmittance',
                           val_mapping={
                               1: 0, 0: 1, 9.0e-1: 2, 8.0e-1: 3, 7.2e-1: 4, 4.0e-1: 5, 3.0e-1: 6, 2.7e-1: 7,
                               1.5e-1: 8, 1.0e-1: 9, 8.0e-2: 10, 3.0e-2: 11, 2.7e-2: 12, 1.5e-2: 13, 1.0e-2: 14,
                               3.0e-3: 15, 2.7e-3: 16, 1.5e-3: 17, 1.0e-3: 18, 8.0e-4: 19, 3.0e-4: 20, 2.7e-4: 21,
                               1.5e-4: 22, 1.0e-4: 23, 8.0e-5: 24, 3.0e-5: 25, 1.5e-5: 26, 3.0e-6: 27, 3.0e-7: 28,
                               3.0e-8: 29, 3.0e-9: 30})

        self.add_parameter('position',
                           set_cmd=self._set_position,
                           get_cmd=self._get_position,
                           get_parser=float,
                           label='Position')

        self.add_parameter('status',
                           get_cmd=self._get_status,
                           get_parser=int,
                           label='status')

        self.connect_message()

    # get methods
    def _get_position(self):
        position = GetPosition()
        self.libximc.get_position(self.device_id, ctypes.byref(position))
        return position.Position

    def _get_status(self):
        status = Status()
        self.libximc.get_status(self.device_id, ctypes.byref(status))
        return status.MoveSts

    # set methods
    def _set_position(self, position):
        self.libximc.command_move(self.device_id, int(position), 0)

    def _set_transmittance(self, transmittance_id):
        # get filter to set
        filter_wheel_1 = self.filter_wheel_1[transmittance_id]
        filter_wheel_2 = self.filter_wheel_2[transmittance_id]

        # get current position
        current_position = self.position.get()

        # determine new positions
        position_wheel_2 = self.offset_wheel_2 + self.distance * filter_wheel_2 + \
                           np.ceil(current_position / self.revolution + 2) * self.revolution
        position_wheel_1 = self.offset_wheel_1 + self.distance * filter_wheel_1 + \
                           np.ceil(current_position / self.revolution + 2) * self.revolution

        if position_wheel_1 > position_wheel_2:
            print('new', position_wheel_1, position_wheel_2)
            position_wheel_1 -= self.revolution

        # set position of the second wheel
        self.position.set(np.floor(position_wheel_2))
        time.sleep(self.sleep_time / 10.0)  # default: 1 s
        for i in range(100):
            if self.status.get() == 0:
                break

        # wait another time
        time.sleep(self.sleep_time)  # default: 10 s

        # set position of the first wheel
        self.position.set(np.floor(position_wheel_1))
        time.sleep(self.sleep_time / 10.0)  # default: 1 s
        for i in range(100):
            if self.status.get() == 0:
                break

        time.sleep(self.sleep_time / 100.0)  # default: 0.1 s
"
200,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attA12ZwM8fNa8gjn'), ('width', 824), ('height', 644), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MfSNSub_MvPNSGT0erc-wg/gCsgILff-hD690zJkEfpP_ZgJFGDiXaol1R0nugRY1Ni85kTFOVi-fs7soZdsfQ_XkN28OHpBQsWFnqzQzmiv7Mf34_sDxkm3Xdh2wxR5IVwk9MuMiyVC67Q1RXNDyl7/fQdm5iBrQGKjodd2e2MDn--teaEbdP_2qLWeFUgZVTk'), ('filename', 'vaunix-digital-attenuator-602eh.png'), ('size', 818096), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FDTFqaWU0-570WKdy0rwqQ/DhRBy2ARWEMvd2d69xdjSds0gauCDliOYm6djNMyFKUX4Q9nYG-t-BR7OMxaJAFOxldkk7TfIGNRzmrrrP2cKw/iJ_9IrjMhGA6pb4mVHRnvH1wpSNxxG0pXeFq58x2Qac'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iwVC7Zo_7c8_TFOIao3mNQ/8L4Eh6eBbb_T1AgCon9l0_NvpajEgFNr2nmiKGNxMBAq_pxGvzQ1bH8DddHSLTOVyrRhfiuTga1cdXHfWc5A1g/YqQdn36hmOUyRrFXpbB7ouXOhGot1M7Sc2VDczRSbX4'), ('width', 655), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/aFGRQ3GaRNFc4QxceQCkWg/ZyvLpkogEIleTVKH2Zzd_IYPc5uV_EEQoZ9uyJdTSHFyTemv45fiL45vd8n6YViIGFAYj5AHv2WtYqgsCYtyEg/j7U9chyIKS7hMZg3oR7jLDUkdJn-rsBJyNFl1Y5SWPA'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-602E Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +30 dBm, and offers frequency coverage of 400 to 6,000 MHz. It has an attenuation range of 120 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-602e-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-602E,Write a Python script that uses Qcodes Community to connect to a LDA-602E ,850.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
204,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attqV64iL6RuJEnkA'), ('width', 405), ('height', 420), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mepp0Q8KE06-caXJxKxPJQ/bnZHMXPFm5Hv3C5eQ6yd6vIpMif725Ayua454pv4T3qgxHSGFt9vTvQXhG_xiaHSbtc-AekVTrXW-g-y7gWiS1Rh4SwAwCz7en9I1moqKew/eZsQbgeyKtaLHHGEtCsvh7EiBWxjC-0yhnyk-imFaQw'), ('filename', 'vaunix-lda802-8.png'), ('size', 168290), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iSsUIbmzIZhLZD-2x-n8fg/0chx3cqaWCTERXMmtghNBY-0OFxyC7imV2Fa-l0IDBLPPLpiyGqTMVxwuddScUxZ_oWjlQoRiMUMgTJouxjJ9g/rJVEnDVNH27lTWldvPoQaHqimS0aedr0Ikv7WxHuWGg'), ('width', 35), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7DrNB89aF__hgNuWvfFeuA/QXT_JfOGTRrS_ZTIpF8HTGLfWwyYS_k2vpgkhVFYo8xWI_UX0UE5mVZ0VdAreAK7L1ZycIDknkQUpDjfJoeq-g/rxfjU9L6KKgUv5HPQ82LQQF3Q7KSsJETGU9bLU3Susw'), ('width', 405), ('height', 420)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ry4RwNIolUeBMwi3Npyz1w/qtS5qdzxsFBH5HdR9KiIAPUvugfUjyx2yXRR8quzWhAYIVrYHOocC5TUx_r8aZ22hAyXiztTVLwO2iJ-IzUKGg/uvxARL3djzXip1Gpl4cTuOy-Ww076VU3MNtWsmTO3a0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802-8 Digital Attenuator is an 8-channel high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802-8 provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface(GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802-8-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802-8,Write a Python script that uses Qcodes Community to connect to a LDA-802-8 ,3999.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
212,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ILM200.pdf,"https://blog.wika.us/applications/liquid-level-gauge-cryogenic-gas/?doing_wp_cron=1688070411.6589620113372802734375#:~:text=Liquid%20Gas%20Tanks-,Cryo%20Gauge%2C%20the%20All%2Din%2DOne%20Device%20for%20Measuring,liquid%20level%20and%20working%20pressure.",,367.3,"Abingdon, United Kingdom",ILM200 is a family of intelligent Cryogen Level Meters with general application in systems containing liquid helium or liquid nitrogen.,http://lmu.web.psi.ch/docu/manuals/bulk_manuals/OxfordInstruments/ILM200.pdf,ILM 200,402.0,['Power Meters'],"Cryo Gauge, the All-in-One Device for Measuring Fluid Level and Working Pressure in Liquid Gas Tanks.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Oxford/ILM200.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Oxford.html#module-qcodes_contrib_drivers.drivers.Oxford.ILM200,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y_6-qvrLUbX3UWbyIcHbgQ/4dkRL2i6ehKYPq2XsN-_7uhD1kytqs2h_Ze0kMEKut9Fvjb9A7PF18KjlvYBlNKdtpyAzcr6rDtUxwMu-3DdVyvV_kqD7VHCwvNZkdi_ZZQ/wkMbsMuSXvhAwG1mMXHayw8Qy-vSPyl0bAYt3zx6l-g'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cfffXlD5ASxTnp78JUzIaA/i2F1xVP4TOsAl1Leq188vYRR6RvsWrQslhK2ajYXkuBDhG04IcF309n2qgWp-io1G2N5HDu_ADfraamLLGM--g/LJ3NHogm9R8legLTmReuTVP5PjqPSEaPg1RHaqW3kiY'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ANarfozobYPgYKtJuIJsWQ/IKd3zp1wzTi3GeF91pPBD8Ez7C5DNOjTK5QPT0kYrB09jqVfyl9sBYMtJOwuIpxyHlOh5CDR3MSWC5TSlw8ZTw/yZVCIhWYW_fPD0KpL1DUpSw7-sMm_C_jVmpO9Nlp0UA'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xkx_TAnkplww1LDxk9W3SA/o-OYEUZB05-StGWB0Wg3TO9AWpeQ7z1fGzP8LNnMByL0geOOTU-4R1vQX49-M_m-hK0oelGX8WoWdZmflXxSwA/ueaFgoiP4CGYFuPw0p0E_zfzbBh_S6xau545LdedmQs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,ILM 200,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Meters,,,,,"# OxfordInstruments_ILM200.py class, to perform the communication between the Wrapper and the device
# Copyright (c) 2017 QuTech (Delft)
# Code is available under the available under the `MIT open-source license <https://opensource.org/licenses/MIT>`__
#
# Pieter Eendebak <pieter.eendebak@tno.nl>, 2017
# Takafumi Fujita <t.fujita@tudelft.nl>, 2016
# Guenevere Prawiroatmodjo <guen@vvtp.tudelft.nl>, 2009
# Pieter de Groot <pieterdegroot@gmail.com>, 2009


from time import sleep
import pyvisa
import logging
from qcodes import VisaInstrument


class OxfordInstruments_ILM200(VisaInstrument):
    """"""
    This is the qcodes driver for the Oxford Instruments ILM 200 Helium Level Meter.

    Usage:
    Initialize with
    <name> = instruments.create('name', 'OxfordInstruments_ILM200', address='<Instrument address>')
    <Instrument address> = ASRL4::INSTR

    Note: Since the ISOBUS allows for several instruments to be managed in parallel, the command
    which is sent to the device starts with '@n', where n is the ISOBUS instrument number.

    """"""

    def __init__(self, name, address, number=1, **kwargs):
        """"""
        Initializes the Oxford Instruments ILM 200 Helium Level Meter.

        Args:
            name (str): name of the instrument
            address (str): instrument address
            number (int): ISOBUS instrument number (number=1 is specific to the ILM in F008)

        Returns:
            None
        """"""
        logging.debug(__name__ + ' : Initializing instrument')
        super().__init__(name, address, **kwargs)

        self.visa_handle.set_visa_attribute(pyvisa.constants.VI_ATTR_ASRL_STOP_BITS,
                                            pyvisa.constants.VI_ASRL_STOP_TWO)
        self._address = address
        self._number = number
        self._values = {}

        self.add_parameter('level',
                           label='level',
                           get_cmd=self._do_get_level,
                           unit='%')
        self.add_parameter('status',
                           get_cmd=self._do_get_status)
        self.add_parameter('rate',
                           get_cmd=self._do_get_rate,
                           set_cmd=self._do_set_rate)

        # a dummy command to avoid the initial error
        try:
            self.get_idn()
            sleep(70e-3)  # wait for the device to be able to respond
            self._read()  # to flush the buffer
        except Exception as ex:
            logging.debug(ex)

    def _execute(self, message):
        """"""
        Write a command to the device and read answer. This function writes to
        the buffer by adding the device number at the front, instead of 'ask'.

        Args:
            message (str) : write command for the device

        Returns:
            None
        """"""
        logging.info(
            __name__ + ' : Send the following command to the device: %s' % message)
        self.visa_handle.write('@%s%s' % (self._number, message))
        sleep(70e-3)  # wait for the device to be able to respond
        result = self._read()
        if result.find('?') >= 0:
            print(""Error: Command %s not recognized"" % message)
        else:
            return result

    def _read(self):
        """"""
        Reads the total bytes in the buffer and outputs as a string.

        Args:
            None

        Returns:
            message (str)
        """"""
        # because protocol has no termination chars the read reads the number
        # of bytes in the buffer
        bytes_in_buffer = self.visa_handle.bytes_in_buffer
        # a workaround for a timeout error in the pyvsia read_raw() function
        with(self.visa_handle.ignore_warning(pyvisa.constants.VI_SUCCESS_MAX_CNT)):
            mes = self.visa_handle.visalib.read(
                self.visa_handle.session, bytes_in_buffer)
        # cannot be done on same line for some reason
        mes = str(mes[0].decode())
        return mes

    def get_idn(self):
        """"""
        Overrides the function of Instrument since ILM does not support `*IDN?`

        This string is supposed to be a
        comma-separated list of vendor, model, serial, and firmware, but
        semicolon and colon are also common separators so we accept them here
        as well.

        Returns:
            A dict containing vendor, model, serial, and firmware.
        """"""
        try:
            idstr = ''  # in case self.ask fails
            idstr = self._get_version().split()
            # form is supposed to be comma-separated, but we've seen
            # other separators occasionally
            idparts = [idstr[3] + ' ' + idstr[4], idstr[0], idstr[5],
                       idstr[1] + ' ' + idstr[2]]
            # in case parts at the end are missing, fill in None
            if len(idparts) < 4:
                idparts += [None] * (4 - len(idparts))
        except Exception as ex:
            logging.warn('Error getting or interpreting *IDN?: ' + repr(idstr))
            logging.debug(ex)
            idparts = [None, None, None, None]

        return dict(zip(('vendor', 'model', 'serial', 'firmware'), idparts))

    def get_all(self):
        """"""
        Reads all implemented parameters from the instrument,
        and updates the wrapper.
        """"""
        logging.info(__name__ + ' : reading all settings from instrument')
        self.level.get()
        self.status.get()
        self.rate.get()

    def close(self):
        """"""
        Safely close connection
        """"""
        logging.info(__name__ + ' : Closing ILM200 connection')
        self.local()
        super().close()

    # Functions: Monitor commands
    def _get_version(self):
        """"""
        Identify the device

        Args:
            None

        Returns:
            identification (str): should be 'ILM200 Version 1.08 (c) OXFORD 1994\r'
        """"""
        logging.info(__name__ + ' : Identify the device')
        return self._execute('V')

    def _do_get_level(self):
        """"""
        Get Helium level of channel 1.

        Args:
            None

        Returns:
            result (float) : Helium level
        """"""
        logging.info(__name__ + ' : Read level of channel 1')
        result = self._execute('R1')
        return float(result.replace(""R"", """")) / 10

    def _do_get_status(self):
        """"""
        Get status of the device.
        """"""
        logging.info(__name__ + ' : Get status of the device.')
        result = self._execute('X')
        usage = {
            0: ""Channel not in use"",
            1: ""Channel used for Nitrogen level"",
            2: ""Channel used for Helium Level (Normal pulsed operation)"",
            3: ""Channel used for Helium Level (Continuous measurement)"",
            9: ""Error on channel (Usually means probe unplugged)""
        }
        # current_flowing = {
        # 0 : ""Curent not flowing in Helium Probe Wire"",
        # 1 : ""Curent not flowing in Helium Probe Wire""
        # }
        # auto_fill_status = {
        # 00 : ""End Fill (Level > FULL)"",
        # 01 : ""Not Filling (Level < FULL, Level > FILL)"",
        # 10 : ""Filling (Level < FULL, Level > FILL)"",
        # 11 : ""Start Filling (Level < FILL)""
        # }
        return usage.get(int(result[1]), ""Unknown"")

    def _do_get_rate(self):
        """"""
        Get helium meter channel 1 probe rate

        Input:
            None

        Output:
            rate(int) :
            0 : ""SLOW""
            1 : ""FAST""
        """"""
        rate = {
            1: ""1 : Helium Probe in FAST rate"",
            0: ""0 : Helium Probe in SLOW rate""
        }
        result = self._execute('X')
        return rate.get(int(format(int(result[5:7]), '08b')[6]), ""Unknown"")

    def remote(self):
        """"""
        Set control to remote & locked
        """"""
        logging.info(__name__ + ' : Set control to remote & locked')
        self.set_remote_status(1)

    def local(self):
        """"""
        Set control to local & locked
        """"""
        logging.info(__name__ + ' : Set control to local & locked')
        self.set_remote_status(0)

    def set_remote_status(self, mode):
        """"""
        Set remote control status.

        Args:
            mode(int) :
            0 : ""Local and locked"",
            1 : ""Remote and locked"",
            2 : ""Local and unlocked"",
            3 : ""Remote and unlocked"",

        Returns:
            None
        """"""
        status = {
            0: ""Local and locked"",
            1: ""Remote and locked"",
            2: ""Local and unlocked"",
            3: ""Remote and unlocked"",
        }
        logging.info(__name__ + ' : Setting remote control status to %s' %
                     status.get(mode, ""Unknown""))
        self._execute('C%s' % mode)

    # Functions: Control commands (only recognised when in REMOTE control)
    def set_to_slow(self):
        """"""
        Set helium meter channel 1 to slow mode.
        """"""
        self.set_remote_status(1)
        logging.info(__name__ + ' : Setting Helium Probe in SLOW rate')
        self._execute('S1')
        self.set_remote_status(3)

    def set_to_fast(self):
        """"""
        Set helium meter channel 1 to fast mode.
        """"""
        self.set_remote_status(1)
        logging.info(__name__ + ' : Setting Helium Probe in FAST rate')
        self._execute('T1')
        self.set_remote_status(3)

    def _do_set_rate(self, rate):
        """"""
        Set helium meter channel 1 probe rate

        Args:
            rate(int) :
            0 : ""SLOW""
            1 : ""FAST""
        """"""
        self.set_remote_status(1)
        if rate == 0:
            self.set_to_slow()
        elif rate == 1:
            self.set_to_fast()
        self.set_remote_status(3)
        logging.info(self._do_get_rate())
"
216,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attBMWDZd2KeFE3R4'), ('width', 623), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DoTffxTfgUni7AAdTUu9cQ/0_wUatLqkUGr5WqvYTrbK3NGrto18wVo7Mq5pv5YIFsB3FnDoZp1CDD2oN0ruY1OpMgcU-KTLUtw0vkuK2rejr01Sy597nVXm6m1RV_j2WPIZe7Ut7ZrF4Z6-zJ7hz4b/wusXIOGHTmFU84m8RIjQtOVPsOP8CixW4fPMik4Odzk'), ('filename', 'vx-new-product-lda906v-8-(1).png'), ('size', 418145), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SwaYdv3mFCzLSKR2ClQXLw/snBBnhk6qS-j3N_LmeoEafe9f5E7LlhU5CYU_1PGcVYp6etQraJ5HlSkHfm5L6ffLnOyU2kDti0p7N02_OBNYQ/60qnWZNefDmFLZmxoev3JsOF9CHROs2xbLg8ujNc3ik'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/enNCMAIItM9Cs3l9gG1PEA/lKKNM-1V7lQmySIfzNmS6a9VeN6mMZqHONfVEnZinbdoO4r7z5DuHG45NRynUjQGXvfGY0WBplISU26RW-5-Fw/t75v-9B_9LdRRarvn4xsqp5cmO5tbzMlL1V41NN7v6c'), ('width', 512), ('height', 631)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BBlQQYSpS0YLHtby_kZOtA/JJi5Sk3-XksGr-pr4VQZ2bVX9xkmQiYyMx7iEKQAYprpsrRkq7qn5638oc1TGvglYWFwxoSDj-eS067GIW-NPg/TWrVb-RmDX0B1TQdZS6lN729ZuoOBp1XmbM6kVLQeoc'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA906V-8 Digital Attenuator is a highly accurate, bidirectional, 8-channel step attenuator. It provides calibrated attenuation from 200 to 6000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 90 dB of control range. This Digital Attenuator is an easily portable USB powered device and is sized to fit into a single rack unit for ATE applications. It can be used with WiMAX, 3G, 4G, 5G, LTE, DVB and microwave radio fading simulators as well as in engineering and production test labs.",https://vaunix.com/lda-906v-8-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-906V-8,Write a Python script that uses Qcodes Community to connect to a LDA-906V-8 ,3499.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
217,https://keysight.com/us/en/assets/7018-01210/data-sheets/5989-0697.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'atthXG7KbstnBFyH7'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4Up5iqLOToYjOerjs8b4gQ/-jjDm0m8k60SJVQ1xe9eknTHJZBOSNwZNEe7ulhQ3VuWBuC6Ei50Ij4RD2o8yvY5heE84101pWzSCDnBYPOvZdSy-g9iWHGlXS2IScD8US0/rumlvTwcf23dksD4MNErkiIrYL9vS1c6yQqOiGwsOdQ'), ('filename', 'E8267D_3_1600x900.png'), ('size', 1699895), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/lGnrN4-_slpU9uMcXUdSZw/mVV6NG3q6Jo0Ypdd_DuDDC2rR8QvQltxaBglLJodGBGWLDmX2uJvOE-3IL8U0NuwzPoy77XvjWlHQTKyE6mBqg/jWo6agt3I-3md8eVnzP2ooqa_0jDjK-U8F9ZGFoKa5Y'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/3b7v9yGB_6S92XNVMOhyGQ/XhIHSCKN_SUXn2fl4fGJrnp79u0DnesnnLwtYlpdh9VqnFrYAjCPenOkCI4Tu6gowL6L4e2Yy7JecKIftSf5ag/tOKRPMbZ9P58WOfrBkqQUO71mihs5ukm6xBR6UXNEMA'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/o9IHv74zxGexJZGKtl_iSQ/sSqDzNuyN--1DxhPQvnKJ1KsqSYXur1nl-LXWqu7OwKlK5vVz9uyjVpuJRLKkQ3dxu2JLor9-1G0o3-6Ce844A/x1iK3ENVgFCqRRvSS9n4pzNm0ZGPDw_k_p_X2mJ2uKI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"The E8267D PSG Vector Signal Generator is the highest performance, fully-integrated microwave vector signal generator from 100 kHz to 44 GHz, allowing you to create realistic wideband radar, electronic warfare (EW), and satellite communications (SATCOM) waveforms.
",https://www.keysight.com/us/en/product/E8267D/psg-vector-signal-generator-100-khz-44-ghz.html,Keysight E 8267 D,307.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/agilent/Agilent_E8267C.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.Keysight_E8267D,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT E8267D PSG,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT E8267D PSG RF Signal Generator,,,,,"from typing import Any, Union

import numpy as np

from qcodes.instrument import VisaInstrument
from qcodes.validators import Enum, Numbers


class AgilentE8267C(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Agilent E8267C signal generator.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\n"", **kwargs)
        # general commands
        self.add_parameter(
            name=""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=""FREQ?"",
            set_cmd=""FREQ {}"",
            get_parser=float,
            vals=Numbers(min_value=100e3, max_value=40e9),
        )
        self.add_parameter(
            name=""freq_offset"",
            label=""Frequency offset"",
            unit=""Hz"",
            get_cmd=""FREQ:OFFS?"",
            set_cmd=""FREQ:OFFS {}"",
            get_parser=float,
            vals=Numbers(min_value=-200e9, max_value=200e9),
        )
        self.add_parameter(
            ""freq_mode"",
            label=""Frequency mode"",
            set_cmd=""FREQ:MODE {}"",
            get_cmd=""FREQ:MODE?"",
            vals=Enum(""FIX"", ""CW"", ""SWE"", ""LIST""),
        )
        self.add_parameter(
            ""pulse_width"",
            label=""Pulse width"",
            unit=""ns"",
            set_cmd=""PULM:INT:PWID {}"",
            get_cmd=""PULM:INT:PWID?"",
            vals=Numbers(min_value=10e-9, max_value=20e-9),
        )
        self.add_parameter(
            name=""phase"",
            label=""Phase"",
            unit=""deg"",
            get_cmd=""PHAS?"",
            set_cmd=""PHAS {}"",
            get_parser=self.rad_to_deg,
            set_parser=self.deg_to_rad,
            vals=Numbers(min_value=-180, max_value=179),
        )
        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=""POW?"",
            set_cmd=""POW {}"",
            get_parser=float,
            vals=Numbers(min_value=-135, max_value=25),
        )
        self.add_parameter(
            name=""power_offset"",
            label=""Power offset"",
            unit=""dBm"",
            get_cmd=""POW:OFFS?"",
            set_cmd=""POW:OFFS {}"",
            get_parser=float,
            vals=Numbers(min_value=-200, max_value=200),
        )
        self.add_parameter(
            name=""output_rf"",
            get_cmd=""OUTP?"",
            set_cmd=""OUTP {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        self.add_parameter(
            name=""modulation_rf"",
            get_cmd=""OUTP:MOD?"",
            set_cmd=""OUTP:MOD {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        # reset values after each reconnect
        self.power(0)
        self.power_offset(0)
        self.connect_message()
        self.add_function(""reset"", call_cmd=""*RST"")

    # functions to convert between rad and deg
    @staticmethod
    def deg_to_rad(
        angle_deg: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.deg2rad(float(angle_deg))

    @staticmethod
    def rad_to_deg(
        angle_rad: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.rad2deg(float(angle_rad))
"
218,could not find,https://www.by-rutgers.nl/IV-converter.html,"[OrderedDict([('id', 'attGlLlqDetchBZyY'), ('width', 602), ('height', 180), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/En3giq3sDRjeuAjNdXUaZA/Np6baxPK_h3e6hmUSAyWHHcnckVI3qoZjhmIfdbMtPfODTAVu0UY72Ad-uxuVLDpvPkfwbTtPAD4vDd7TfMGndDQRXwvANG-ZTZ0T-6wWcw/_irtMd585OJ32_RsgBNdL-j1PahNxpKpaDfm1wEqTuQ'), ('filename', 'ivvidac2.jpg'), ('size', 103635), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/bs4lHedg1fzVhEPTFnbYeQ/pfN6HJ8nQsQIRSkMEah9h01IBusGQVbGTCQrY5NT8lxV3Qd5bKOr29VmCL_0Axv0-DC5_zcxjOxxtZTbo_k0BA/S7VxkvpanTiCd0o9Rzd_njW7PLy8uboR05x5oNq57i4'), ('width', 120), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/nmt2sQp8M4Da7WCoo1ocFw/wnPeOQwWkKDbaZ1P2n-T_UCfdAuSswdeFpTWhWCjCYTZ7pWeZFWY8W8kWVgvuvymuZCbAQ7SryGETGIuKCLw1A/fJd4CVUECbiaWrr69Jgq4ah_4pUBbL7pbsPaFoEHYBA'), ('width', 602), ('height', 180)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/WIWNSlSY2i1sd5uRC4WcRQ/roIpoTq05Ol91LBTBy6oVap7oaaeuXJsn_GzzbzQUescguareEdeoxRI2u4FAo0zgzf9Hkxe62o9ROBuw9xkig/9Y1kYH_K3sjAqeWL_ScMEdKKe202DzB5MODCdTMpO60'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands",An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law	https://en.wikipedia.org/wiki/Ohmmeter,https://qtwork.tudelft.nl/~mtiggelman/spi-rack/power.html,Ivvi,438.0,['IV Converter'],An I/V-convertor is intended to convert the current from a DAC (Digital Analog Convertor) into an analog voltage and to filter this signal to keep out the alias frequencies,"At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/IVVI.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.IVVI,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,IVVI,Write a Python script that uses Qcodes Community to connect to a IVVI IV Converter,,,True,,"import time
import logging
import numpy as np
import pyvisa  # used for the parity constant
import traceback
import threading
import math

from qcodes import VisaInstrument, validators as vals
from qcodes.utils.validators import Bool, Numbers


class IVVI(VisaInstrument):
    '''
    Status: Alpha version, tested for basic get-set commands
        TODO:
            - Add adjustable range and rate protection per channel
            - Add error handling for the specific error messages in the
              protocol
            - Remove/fine-tune manual sleep statements

    This is the python driver for the D5 module of the IVVI-rack
    see: http://qtwork.tudelft.nl/~schouten/ivvi/doc-d5/index-d5.htm

    A descriptor for the data protocol can be found at
    http://qtwork.tudelft.nl/~schouten/ivvi/doc-d5/rs232linkformat.txt
    A copy of this file can be found at the bottom of this file.
    '''
    
    full_range = 4000.0
    half_range = full_range / 2
    resolution = 16
    dac_quata = full_range / 2**resolution

    def __init__(self, name, address, reset=False, numdacs=16, dac_step=10,
                 dac_delay=.1, safe_version=True,
                 polarity=['BIP', 'BIP', 'BIP', 'BIP'],
                 use_locks=False, **kwargs):
        '''
        Initialzes the IVVI, and communicates with the wrapper

        Args:
            name (str)        : name of the instrument
            address (str)     : ASRL address
            reset (bool)         : resets to default values, default=false
            numdacs (int)        : number of dacs, multiple of 4, default=16
            polarity (List[str]) : list of polarities of each set of 4 dacs
                                   choose from 'BIP', 'POS', 'NEG',
                                   default=['BIP', 'BIP', 'BIP', 'BIP']
            dac_step (float)         : max step size for dac parameter
            dac_delay (float)        : delay (in seconds) for dac
            safe_version (bool)    : if True then do not send version commands
                                     to the IVVI controller
            use_locks (bool) : if True then locks are used in the `ask`
                              function of the driver. The IVVI driver is not
                              thread safe, this locking mechanism makes it
                              thread safe at the cost of making the call to ask
                              blocking.
        '''
        t0 = time.time()
        super().__init__(name, address, **kwargs)
        if use_locks:
            self.lock = threading.Lock()
        else:
            self.lock = None

        self.safe_version = safe_version

        if numdacs % 4 == 0 and numdacs > 0:
            self._numdacs = int(numdacs)
        else:
            raise ValueError('numdacs must be a positive multiple of 4, '
                             'not {}'.format(numdacs))

        # values based on descriptor
        self.visa_handle.baud_rate = 115200
        self.visa_handle.parity = pyvisa.constants.Parity(1)  # odd parity
        self.visa_handle.write_termination = ''
        self.visa_handle.read_termination = ''

        self.add_parameter('version',
                           get_cmd=self._get_version)

        self.add_parameter('check_setpoints',
                           get_cmd=None, set_cmd=None,
                           initial_value=False,
                           label='Check setpoints',
                           vals=Bool(),
                           docstring=('Whether to check if the setpoint is the'
                                      ' same as the current DAC value to '
                                      'prevent an unnecessary set command.'))

        # Time to wait before sending a set DAC command to the IVVI
        self.add_parameter('dac_set_sleep',
                           get_cmd=None, set_cmd=None,
                           initial_value=0.05,
                           label='DAC set sleep',
                           unit='s',
                           vals=Numbers(0),
                           docstring=('When check_setpoints is set to True, '
                                      'this is the waiting time between the'
                                      'command that checks the current DAC '
                                      'values and the final set DAC command'))

        # Minimum time to wait before the read buffer contains data
        self.add_parameter('dac_read_buffer_sleep',
                           get_cmd=None, set_cmd=None,
                           initial_value=0.025,
                           label='DAC read buffer sleep',
                           unit='s',
                           vals=Numbers(0),
                           docstring=('While receiving bytes from the IVVI, '
                                      'sleeping is done in multiples of this '
                                      'value. Change to a lower value for '
                                      'a shorter minimum time to wait.'))

        self.add_parameter('dac_voltages',
                           label='Dac voltages',
                           get_cmd=self._get_dacs)

        self.add_function(
            'trigger',
            call_cmd=self._send_trigger
        )

        # initialize pol_num, the voltage offset due to the polarity
        self.pol_num = np.zeros(self._numdacs)

        for i in range(1, numdacs + 1):
            self.add_parameter(
                'dac{}'.format(i),
                label='Dac {}'.format(i),
                unit='mV',
                get_cmd=self._gen_ch_get_func(self._get_dac, i),
                set_cmd=self._gen_ch_set_func(self._set_dac, i),
                vals=vals.Numbers(self.pol_num[i - 1],
                                  self.pol_num[i - 1] + self.full_range),
                step=dac_step,
                inter_delay=dac_delay,
                max_val_age=10)

        for i in range(int(self._numdacs / 4)):
            self.set_pol_dacrack(polarity[i], np.arange(1 + i * 4, 1 + (i + 1) * 4),
                                 get_all=False)

        self._update_time = 5  # seconds
        self._time_last_update = 0  # ensures first call will always update

        t1 = time.time()

        # make sure we ignore termination characters
        # See http://www.ni.com/tutorial/4256/en/#toc2 on Termination Character
        # Enabled
        v = self.visa_handle
        v.set_visa_attribute(pyvisa.constants.VI_ATTR_TERMCHAR_EN, 0)
        v.set_visa_attribute(pyvisa.constants.VI_ATTR_ASRL_END_IN, 0)
        v.set_visa_attribute(pyvisa.constants.VI_ATTR_ASRL_END_OUT, 0)
        v.set_visa_attribute(pyvisa.constants.VI_ATTR_SEND_END_EN, 0)

        # basic test to confirm we are properly connected
        try:
            self.get_all()
        except Exception as ex:
            print('IVVI: get_all() failed, maybe connected to wrong port?')
            print(traceback.format_exc())

        print('Initialized IVVI-rack in %.2fs' % (t1 - t0))

    def get_idn(self):
        """"""
        Overwrites the get_idn function using constants as the hardware
        does not have a proper \*IDN function.
        """"""
        # not all IVVI racks support the version command, so return a dummy
        return -1

        idparts = ['QuTech', 'IVVI', 'None', self.version()]

        return dict(zip(('vendor', 'model', 'serial', 'firmware'), idparts))

    def _get_version(self):
        if self.safe_version:
            return -1
        else:
            # ask for the version of more recent modules
            # some of the older modules cannot handle this command
            mes = self.ask(bytes([3, 4]))
            ver = mes[2]
            return ver

    def get_all(self):
        return self.snapshot(update=True)

    def set_dacs_zero(self):
        for i in range(self._numdacs):
            self.set('dac{}'.format(i + 1), 0)

    def linspace(self, start: float, end: float, samples: int, flexible: bool = False, bip: bool = True):
        """"""
        Creates array of voltages, with correct alignment to the DAC
        quantisation, in a similar manner to numpy.linspace.
        This guarantees an even spacing and no double sampling inside
        the requested range.

        Args:
            start: the start of the voltage range, in millivolts
            end: the end of the voltage range, in millivolts
            samples: number of sample voltages
            flexible: occasionally get a different number of samples if
                they can still fit inside the range.
            bip: if the dac set to bi-polar (-2V to +2V) or
                not (-4 to -0, or 0 to +4),

        Returns:
            list of voltages in millivolts suitable for the ivvi DAC.
            Voltages are inside [start:end]
            Voltages are evenly spaced
            Voltages align with the DAC quantisation.

        Examples:
            normal usage::

                linspace(-100,100,8) -> [-99.88555733577478, .. 6 more ..
                                        , 99.64141298542764]
            
                linspace(-1000, 1000, 2000) ->
                    [-976.4858472571908, .. 1998 more .., 975.6923781185626 ]

            A flexable number of points::

                linspace(-1000, 1000, 2000, True) ->
                    [-999.9237048905165, .. 2046 more .., 999.1302357518883]

                4 bits is the optimal spacing, so this gives 2048 (= 2^11)
                points in a 2 V range

            Insufficient resolution::

                linspace(500, 502, 100) -> ValueError: Insufficient resolution
                    for 100 samples in the range 500 to 502. Maximum :16

                This prevents oversampling. Use flexable = True to adapt the number
                of points.
                                     
            Resolution limited sweep using the flexable option::

                linspace(500, 502, 100, True) -> [500.0991836423285, .. 14 more ..
                                                 , 501.9302662699321]
            
            A too narrow range::

                linspace(0, 0.01, 100, True) # -> ValueError: No DAC values exist
                                                  in the range 0 : 0.01

                Even using the flexable option can not help if there are no
                valid values in the requested range.
        """"""

        if not isinstance(samples, (int)):
            raise ValueError('samples: must be an integer')
        if not isinstance(start, (int, float)):
            raise ValueError('start: must be a number')
        if not isinstance(end, (int, float)):
            raise ValueError('end: must be a number')
        if samples < 2:
            raise ValueError('points: needs to be 2 or more')

        use_reversed = end < start
        if use_reversed:
            start,end = end,start
        half = 0.5 if bip else 0.0 # half bit difference between bip and neg,pos
        byte_start =  int(math.ceil(half + start/self.dac_quata))
        byte_end = int(math.floor(half + end/self.dac_quata))
        delta_bytes =  abs(byte_end - byte_start)-1
        spacing =  max(int(math.floor(delta_bytes / (samples-1))),2)
        l =  [(el+half)*self.dac_quata
              for el in range(byte_start, byte_end,spacing)]
        # Adjust the points until the length is correct
        if not flexible:
            if len(l) > samples:
                if (len(l) - samples)%2==1:
                    l = l[1:]
                s = int((len(l) - samples) / 2)
                if s > 0:
                    l = l[s:-s]
            if len(l) < samples:
                msg = ( 'Insufficient resolution for '+ str(samples)
                       + ' samples in the range '
                       + str(start)+' to ' + str(end) )
                msg += '. Maximum :' + str(len(l))
                raise ValueError(msg)
        if len(l) == 0:
            msg = ('No DAC values exist in the range ' +
                    str(start) + ' : ' + str(end)
                  )
            raise ValueError(msg)

        if use_reversed:
             l = list(reversed(l))
        return l

    # Conversion of data
    def _mvoltage_to_bytes(self, mvoltage):
        '''
        Converts a mvoltage on a 0mV-4000mV scale to a 16-bit integer
        equivalent

        output is a list of two bytes

        Input:
            mvoltage (float) : a mvoltage in the 0mV-4000mV range

        Output:
            (dataH, dataL) (int, int) : The high and low value byte equivalent
        '''
        bytevalue = int(round(mvoltage / self.full_range * 65535))
        return bytevalue.to_bytes(length=2, byteorder='big')

    def _bytes_to_mvoltages(self, byte_mess):
        '''
        Converts a list of bytes to a list containing
        the corresponding mvoltages
        '''
        values = list(range(self._numdacs))
        for i in range(self._numdacs):
            # takes two bytes, converts it to a 16 bit int and then divides by
            # the range and adds the offset due to the polarity
            values[i] = ((byte_mess[2 + 2 * i] * 256 + byte_mess[3 + 2 * i]) /
                         65535.0 * self.full_range) + self.pol_num[i]
        return values

    # Communication with device
    def _get_dac(self, channel):
        """"""
        Returns dac channel in mV
        channels range from 1-numdacs

        this version is a wrapper around the IVVI get function.
        it only updates
        """"""
        return self._get_dacs()[channel - 1]

    def _set_dac(self, channel, mvoltage):
        """"""
        Sets the specified dac to the specified voltage.
        A check to prevent setting the same value is performed if
        the check_setpoints flag was set.

        Input:
            mvoltage (float) : output voltage in mV
            channel (int)    : 1 based index of the dac

        Output:
            reply (string) : errormessage
        Private version of function
        """"""
        proceed = True

        if self.check_setpoints():
            cur_val = self.get('dac{}'.format(channel))
            # dac range in mV / 16 bits FIXME make range depend on polarity
            byte_res = self.full_range / 2**16
            # eps is a magic number to correct for an offset in the values
            # the IVVI returns (i.e. setting 0 returns byte_res/2 = 0.030518
            # with rounding
            eps = 0.0001

            proceed = False

            if (mvoltage > (cur_val + byte_res / 2 + eps) or
                    mvoltage < (cur_val - byte_res / 2 - eps)):
                proceed = True

            if self.dac_set_sleep() > 0.0:
                time.sleep(self.dac_set_sleep())

        # only update the value if it is different from the previous one
        # this saves time in setting values, set cmd takes ~650ms
        if proceed:
            polarity_corrected = mvoltage - self.pol_num[channel - 1]
            byte_val = self._mvoltage_to_bytes(polarity_corrected)
            message = bytes([2, 1, channel]) + byte_val

            reply = self.ask(message)
            self._time_last_update = 0  # ensures get command will update

            return reply

    def _get_dacs(self):
        '''
        Reads from device and returns all dacvoltages in a list

        Input:
            None

        Output:
            voltages (float[]) : list containing all dacvoltages (in mV)

        get dacs command takes ~450ms according to ipython timeit
        '''
        if (time.time() - self._time_last_update) > self._update_time:
            message = bytes([self._numdacs * 2 + 2, 2])
            # workaround for an error in the readout that occurs sometimes
            max_tries = 10
            for i in range(max_tries):
                try:
                    reply = self.ask(message)
                    self._mvoltages = self._bytes_to_mvoltages(reply)
                    self._time_last_update = time.time()
                    break
                except Exception as ex:
                    logging.warning('IVVI communication error trying again')
            if i + 1 == max_tries:  # +1 because range goes stops before end
                raise ex
        return self._mvoltages

    def write(self, message, raw=False):
        '''
        Protocol specifies that a write consists of
        descriptor size, error_code, message

        returns message_len
        '''
        # This is used when write is used in the ask command
        expected_answer_length = None

        if not raw:
            expected_answer_length = message[0]
            message_len = len(message) + 2

            error_code = bytes([0])
            message = bytes([message_len]) + error_code + message
        self.visa_handle.write_raw(message)

        return expected_answer_length

    def ask(self, message, raw=False):
        '''
        Send <message> to the device and read answer.
        Raises an error if one occurred
        Returns a list of bytes
        '''
        if self.lock:
            max_tries = 10
            for i in range(max_tries):
                if self.lock.acquire(timeout=.05):
                    break
                else:
                    logging.warning('IVVI: cannot acquire the lock')
            if i + 1 == max_tries:
                raise Exception('IVVI: lock is stuck')
        # Protocol knows about the expected length of the answer
        message_len = self.write(message, raw=raw)
        reply = self.read(message_len=message_len)
        if self.lock:
            self.lock.release()

        return reply

    def _read_raw_bytes_direct(self, size):
        """""" Read raw data using the visa lib """"""
        with(self.visa_handle.ignore_warning(pyvisa.constants.VI_SUCCESS_MAX_CNT)):
            data, statuscode = self.visa_handle.visalib.read(
                self.visa_handle.session, size)

        return data

    def _read_raw_bytes_multiple(self, size, maxread=512, verbose=0):
        """""" Read raw data in blocks using the visa lib
        Arguments:
            size (int) : number of bytes to read
            maxread (int) : maximum size of block to read
            verbose (int): verbosity level
        Returns:
            ret (bytes): bytes read from the device
        The pyvisa visalib.read does not always terminate at a newline, this
        is a workaround.
        Also see: https://github.com/qdev-dk/Qcodes/issues/276
                  https://github.com/hgrecco/pyvisa/issues/225
        Setting both VI_ATTR_TERMCHAR_EN and VI_ATTR_ASRL_END_IN to zero
        should allow the driver to ignore termination characters, this
        function is an additional safety mechanism.
        """"""
        ret = []
        instr = self.visa_handle
        with self.visa_handle.ignore_warning(pyvisa.constants.VI_SUCCESS_MAX_CNT):
            nread = 0
            while nread < size:
                nn = min(maxread, size - nread)
                chunk, status = instr.visalib.read(instr.session, nn)
                ret += [chunk]
                nread += len(chunk)
                if verbose:
                    print('_read_raw: %d/%d bytes' % (len(chunk), nread))
        ret = b''.join(ret)
        return ret

    def read(self, message_len=None):
        # because protocol has no termination chars the read reads the number
        # of bytes in the buffer
        bytes_in_buffer = 0
        timeout = 1
        t0 = time.time()
        t1 = t0
        bytes_in_buffer = 0
        if message_len is None:
            message_len = 1  # ensures at least 1 byte in buffer

        while bytes_in_buffer < message_len:
            t1 = time.time()

            if self.dac_read_buffer_sleep() > 0.0:
                time.sleep(self.dac_read_buffer_sleep())

            bytes_in_buffer = self.visa_handle.bytes_in_buffer
            if t1 - t0 > timeout:
                raise TimeoutError()
        # a workaround for a timeout error in the pyvsia read_raw() function
        mes = self._read_raw_bytes_multiple(bytes_in_buffer)

        # if mes[1] != 0:
        # see protocol descriptor for error codes
        #     raise Exception('IVVI rack exception ""%s""' % mes[1])
        return mes

    def set_pol_dacrack(self, flag, channels, get_all=True):
        '''
        Changes the polarity of the specified set of dacs

        Input:
            flag (str) : 'BIP', 'POS' or 'NEG'
            channel (int) : 0 based index of the rack
            get_all (bool): if True (default) perform a get_all

        Output:
            None
        '''
        flagmap = {'NEG': -self.full_range, 'BIP': -self.half_range, 'POS': 0}
        if flag.upper() not in flagmap:
            raise KeyError('Tried to set invalid dac polarity %s', flag)

        val = flagmap[flag.upper()]
        for ch in channels:
            self.pol_num[ch - 1] = val
            name = ""dac"" + str(ch)
            self.set_parameter_bounds(name, val,
                                      val + self.full_range)

        if get_all:
            self.get_all()

    def get_pol_dac(self, channel):
        '''
        Returns the polarity of the dac channel specified

        Input:
            channel (int) : 1 based index of the dac

        Output:
            polarity (str) : 'BIP', 'POS' or 'NEG'
        '''
        val = self.pol_num[channel - 1]

        if (val == -self.full_range):
            return 'NEG'
        elif (val == -self.half_range):
            return 'BIP'
        elif (val == 0):
            return 'POS'
        else:
            return 'Invalid polarity in memory'

    def set_parameter_bounds(self, name, min_value, max_value):
        parameter = self.parameters[name]
        if not isinstance(parameter.vals, Numbers):
            raise Exception('Only the Numbers validator is supported.')
        parameter.vals._min_value = min_value
        parameter.vals._max_value = max_value

    def _gen_ch_set_func(self, fun, ch):
        def set_func(val):
            return fun(ch, val)
        return set_func

    def _gen_ch_get_func(self, fun, ch):
        def get_func():
            return fun(ch)
        return get_func

    def _send_trigger(self):
        msg = bytes([2, 6])
        self.write(msg)
        self.read()  # Flush the buffer, else the command will only work the first time.

    def round_dac(self, value, dacname=None):
        """""" Round a value to the interal precision of the instrument

        Args:
            value (float): value to be rounded
            dacname (str or int or None): name or index of dac channel
        Returns:
            float: rounded value

        """"""
        if dacname is None:
            dacidx = 0  # assume all dacs have the same pol_num
        elif isinstance(dacname, str):
            dacidx = int(dacname[3:]) - 1
        else:
            dacidx = dacname

        value_pol_corr = value - self.pol_num[dacidx]
        value_bytes = self._mvoltage_to_bytes(value_pol_corr)
        value_round = (value_bytes[0] * 256 + value_bytes[1]) / \
            65535.0 * self.full_range + self.pol_num[dacidx]
        return value_round

    def adjust_parameter_validator(self, param):
        """"""Adjust the parameter validator range based on the dac resolution.

        The dac's of the IVVI have a finite resolution. If the validator range
        min and max values are not values the dac's can actually have, then it
        can occur that a set command results in the dac's going to a value just
        outside the validator range. Adjusting the validators with this
        function prevents that.

        Args:
            param (Parameter): a dac of the IVVI instrument
        """"""
        if not isinstance(param.vals, Numbers):
            raise Exception('Only the Numbers validator is supported.')
        min_val = param.vals._min_value
        max_val = param.vals._max_value

        min_val_upd = self.round_dac(min_val, param.name)
        max_val_upd = self.round_dac(max_val, param.name)

        param.vals = Numbers(min_val_upd, max_val_upd)


'''
RS232 PROTOCOL
-----------------------
BAUTRATE    115200
DATA BITS   8
PARITY      ODD
STOPBITS    1

Descriptor data PC-> MC

Byte        Name               Description                              value
--------------------------------------------------------------------------------------------------------
0        Descriptor size         Size of this descriptor                4 (action 2,4,6,7)
                                                                        5 (action 7)
                                                                        7 (action 1,3)
                                                                        11 (action 5)
1        Error                                                          0
2        Data out size           Number of bytes that has to be         2 (action 0,1,3,5,6)
                                 send by the MC after receiving         3 (action 4)
                                 descriptor                             4 (action 7)
                                                                        34 (action 2)
3        Action                                                         0= no operation
                                                                        1= set Dac value
                                                                        2= request DAC data
                                                                        3= continues send data to DAC
                                                                        4= ask for Program  ion
                                                                        5= set bits interface
                                                                        6= generate trigger output
                                                                        7= request data from specified DAC

4        Dac nr                  Nr of DAC to be updated                1 to 16
5        DataH                   High byte to DAC                       0 to $ff
6        DataL                   Low byte to DAC                        0 to $ff
7        data bit 24-31          interfaceBit24_31                      0 to $ff
8        data bit 16-23          interfaceBit16_23                      0 to $ff
9        data bit 08-15          interfaceBit08_15                      0 to $ff
10       data bit 00-07          interfaceBit00_07                      0 to $ff
--------------------------------------------------------------------------------------------------------


Descriptor data MC-> PC
--------------------------------------------------------------------------------------------------------
0        Descriptor size         Size of this descriptor                1
1        Error                   0x00 = no Error detected               1
                                 0x01 =
                                 0x02 =
                                 0x04 = Parity
                                 0x08 = Overrun
                                 0x10 = Frame Error
                                 0x20 = WatchDog reset detected (32)
                                 0x40 = DAC does not exist(64)
                                 0x80 = WrongAction (128)
2        Version                 program version                       1
2        DAC1                    Value of DAC1                         2
4        DAC2                    Value of DAC2                         2
..
32       DAC16                   Value of DAC16                        2
--------------------------------------------------------------------------------------------------------
'''
"
230,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attA12ZwM8fNa8gjn'), ('width', 824), ('height', 644), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MfSNSub_MvPNSGT0erc-wg/gCsgILff-hD690zJkEfpP_ZgJFGDiXaol1R0nugRY1Ni85kTFOVi-fs7soZdsfQ_XkN28OHpBQsWFnqzQzmiv7Mf34_sDxkm3Xdh2wxR5IVwk9MuMiyVC67Q1RXNDyl7/fQdm5iBrQGKjodd2e2MDn--teaEbdP_2qLWeFUgZVTk'), ('filename', 'vaunix-digital-attenuator-602eh.png'), ('size', 818096), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FDTFqaWU0-570WKdy0rwqQ/DhRBy2ARWEMvd2d69xdjSds0gauCDliOYm6djNMyFKUX4Q9nYG-t-BR7OMxaJAFOxldkk7TfIGNRzmrrrP2cKw/iJ_9IrjMhGA6pb4mVHRnvH1wpSNxxG0pXeFq58x2Qac'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iwVC7Zo_7c8_TFOIao3mNQ/8L4Eh6eBbb_T1AgCon9l0_NvpajEgFNr2nmiKGNxMBAq_pxGvzQ1bH8DddHSLTOVyrRhfiuTga1cdXHfWc5A1g/YqQdn36hmOUyRrFXpbB7ouXOhGot1M7Sc2VDczRSbX4'), ('width', 655), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/aFGRQ3GaRNFc4QxceQCkWg/ZyvLpkogEIleTVKH2Zzd_IYPc5uV_EEQoZ9uyJdTSHFyTemv45fiL45vd8n6YViIGFAYj5AHv2WtYqgsCYtyEg/j7U9chyIKS7hMZg3oR7jLDUkdJn-rsBJyNFl1Y5SWPA'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-602EH Lab Brick USB programmable 50 Ohm high resolution digital attenuator has an input power of up to +28 dBm, and offers frequency coverage of 200 to 6,000 MHz. It has an attenuation range of 120 dB and a step size of 0.1 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-602eh-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-602EH,Write a Python script that uses Qcodes Community to connect to a LDA-602EH ,875.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
235,https://www.keysight.com/us/en/assets/7018-06712/data-sheets/5980-0232.pdf,https://www.keysight.com/us/en/assets/7018-06481/white-papers/5992-3625.pdf,"[OrderedDict([('id', 'att6q8HhGlRlrC1ar'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ch33UVK6L5tDofkh1i97wA/Lfvze_oK5ZVlCqlBfztfSX_P_LLiAde_31czdz0akDq2956Suhd-445DkVv62Lha2m0v0G4r4Yv0idPgs3sfeXJXjQaJsp57JwDQnIUZGGY/yIckbdgvh1xNx0-Datox5e_EqZQQGS6tWbMoN19OpsE'), ('filename', 'N3300A_Front_Left.png'), ('size', 1447932), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wDubmR2tom8wf8QTuHimxw/0Uhwx3p9UhZHZcibPUxVzbG3OaMshraH1wOp7DRDmt9FlvLzqAhldwSBoI2mPdLRy9hwMgwSEvVEdHbSzwmy_A/_0rC-sT_QtP-7toiU8n4fvCV_igt-wrP510p3rrQFiA'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zTIEKQGBUVkMF7lVzBUJVA/r3X2-k6NEC7JgjQ_EeLZAxDLqEFkbQKV7sMNjbAZ1iqMvRnfpVXN9sjm-V8LIPjCvIupr6-k7_szUBXMceFTEA/lzXrAQo6L3MA_Bk_p6MYh_boSESUcGx136-0hGzAeA4'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/68aHrKPfnJ6xAPWz7hZHlg/PP4B82GQEyO5svwD3S4qxZFgtvD7-iv35gA3EU4YjEfhSVw4bWJ_EYYWkHIv82ifzEkEu41vyxlx-i5iqmD_tQ/Z8-LQOeiq-Ls6_fh86ndENG-xCmLVOFf7jEVoOYyhG4'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"The Keysight N3300A is a full-rack width mainframe with 6-slots that accepts combinations of N330x user-installable load modules (150 W to 600 W) for easy system configuration and future reconfiguration. The N3300A holds up to six N3302A, N3303A, N3304A, N3307A load modules, or three N3305A, N3306A double-wide modules, allowing a total up to 1,800 watts of maximum power.
",https://www.keysight.com/us/en/product/N3300A/1800-watt-dc-electronic-load-mainframe.html,Keysight M 3300 A,304.0,['Electronic Loads'],"An electronic load is a test instrument designed to sink current and absorb power out of a power source. If a power supply is used to power a device, an electronic load is used to test the power supply by emulating the device under test (DUT). Power supplies and electronic loads are complementary test equipment. The power supply tests electronic circuits under specific sourcing conditions. The electronic load tests the energy sources or energy conversion blocks under specific loading constraints. An electronic load is a programmable instrument that offers the user various modes of control such as constant voltage (CV), constant current (CC), constant power (CP) or constant resistance (CR).
","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Keysight/Keysight_M3300A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.Keysight_M3300A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT N3300A,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT N3300A Electronic Loads,3683.0,,,,"###################################################################################
#                                                                                 #
#                               Driver file for M3300A                            #
#                                                                                 #
###################################################################################
#                                                                                 #
# Written by: Mark Johnson                                                        #
# Also see: http://www.keysight.com/en/pd-2747490-pn-M3300A                       #
#                                                                                 #
###################################################################################

try:
    from .SD_common.SD_AWG import SD_AWG
    from .SD_common.SD_DIG import SD_DIG
except ImportError:
    raise ImportError('To use the M3300A driver, install the keysight module')

class M3300A_AWG(SD_AWG):
    """""" Driver for the AWG of the Keysight M3300A card.

    Args:
        name (str)    : name for this instrument, passed to the base instrument
        chassis (int) : chassis number where the device is located
        slot (int)    : slot number where the device is plugged in
    Example:
        AWG = AWG('M3300A')
    """"""
    def __init__(self, name, chassis=1, slot=8, **kwargs):
        super().__init__(name, chassis=1, slot=8, channels=4, triggers=8, **kwargs)

class M3300A_DIG(SD_DIG):
    """""" Driver for the digitizer of the keysight M3300A card.

    Args:
        name (str)    : name for this instrument, passed to the base instrument
        chassis (int) : chassis number where the device is located
        slot (int)    : slot number where the device is plugged in

    Example:
        DIG  = DIG('M3300A')
    """"""
    def __init__(self, name, chassis=1, slot=8, **kwargs):
        super().__init__(name, chassis, slot, channels=8, triggers=8, **kwargs)
"
237,could not find,https://en.wikipedia.org/wiki/Ohmmeter,"[OrderedDict([('id', 'attYUtLFk025sbBng'), ('width', 418), ('height', 1521), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UK7RZ-wLDY-m0bbUl4D2zg/Az_WowuGyjT7kGEfWxcfJpQD8yhdXjCBauzjJ1FLSzzW3YCFd8qhAKVWpHm5hPK3qdhiIDAjyOtZx5CejqTl1t3FnQKFT4q6yYjaPNTSyiE/PHfhi0R564LPZFWiRYYhw5Y8OWCjp377jXMpA_Bxcf8'), ('filename', 'FrontD4.png'), ('size', 20536), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/EUfK580R7_Qyq5XrxbIBNg/-GTEdjbDhZGo81G8QyA9ahnTsNyz1pcMQ4tAhSmI-RdtUIarIEWgIpqZxm8eprOrggRisnMEUMsX2PUgGIkxfw/4IZNapA9Q5Irsb971Z1fiKCwJWyJKzIohRR8K0yP92g'), ('width', 10), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VOwtuf1h9f8M8Cjxp9ibRw/mQUPZoycnOgtTf1YZ-ypRN7_gFn1Nr1cJvAMiHLP5jlV5VS6CKl7WdmGYOLwwa_s3TCh0V0jPiteOTgtZHoRBw/ur-ST2LkqWeJDo2w5n25rH-oFWvx6kiS9Tl7n_aVunU'), ('width', 418), ('height', 1521)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FArXzd4PZ5kvNRGJyNUhrA/kXPOLfFCRoWBKt5LXIdcqDKdEoK5xLZ_YZMx_qYGOTJ40y2_UZe3fRgld3NrMnUIgqdMB6zXp50nygZVDoJNtw/7yQtORa0SHl5DKCnzDEPB3ZNFMIzGJy3YKOAp4ls_08'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands","The D4 module contains 2 individual 24-bit ADCs (Analog to Digital Converters) with an input range of ±4V and a data rate ranging from 1.7 Hz to 83 kHz. As it is designed as alternative to Keithley DMMs, it offers similar or better performance in terms of noise, resolution, temperature drift, INL and 50 Hz rejection. For details, see specifications.",https://qtwork.tudelft.nl/~mtiggelman/modules/v-measure/d4.html,D4,439.0,['Power Meters'],An ohmmeter is an electrical instrument that measures electrical resistance (the opposition offered by a circuit or component to the flow of electric current). Multimeters also function as ohmmeters when in resistance-measuring mode. An ohmmeter applies current to the circuit or component whose resistance is to be measured. It then measures the resulting voltage and calculates the resistance using Ohm’s law,"At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/D4.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.D4,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,D4,Write a Python script that uses Qcodes Community to connect to a D4 Power Meters,,,,,"from qcodes.instrument.base import Instrument
try:
    from spirack import D4_module
except ImportError:
    raise ImportError(('The D4_module class could not be found. '
                       'Try installing it using pip install spirack'))

from functools import partial

class D4(Instrument):
    """"""
    Qcodes driver for the D4 ADC SPI-rack module. Requires installation
    of the 'spirack' package using pip.

    Args:
        name (str): name of the instrument.

        spi_rack (SPI_rack): instance of the SPI_rack class as defined in
            the spirack package. This class manages communication with the
            individual modules.

        module (int): module number as set on the hardware.
    """"""

    def __init__(self, name, spi_rack, module, **kwargs):
        super().__init__(name, **kwargs)

        self.d4 = D4_module(spi_rack, module)

        self.add_parameter('mode',
                           label='Mode',
                           get_cmd=self.get_mode)

        self.add_parameter('filter_value',
                           label='Filter value',
                           get_cmd=self.get_filter_value)

        self.add_parameter('buffers_enabled',
                           label='Buffers enabled',
                           get_cmd=self.get_buffers_enabled)

        for i in range(2):
            self.add_parameter('adc{}'.format(i + 1),
                               label='ADC {}'.format(i + 1),
                               get_cmd=partial(self.d4.singleConversion, i),
                               units='V')

    def get_mode(self):
        return self.d4.mode

    def get_filter_value(self):
        return self.d4.filter_val

    def get_buffers_enabled(self):
        return self.d4.buf_en
"
240,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attreAllvLxRUZp7O'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BdrxWPRFn---V8Tv2hnttg/HtWqVdTzWw786JY9FVrfRQyimSYS9iZy8wPQkvqmcYK-nccEAytk_SH777nXLzOBHmnl3SH5AZoJ7_PnfnrMSIsbqH2sqOqmWLrJ5Jjtxf23YHtm0eWS1f-vzqe5khy6/-0kcTFgoDVFYKGIfEOhRFOAc-nCbkX3ZZ-BBcSmInRo'), ('filename', 'vaunix-lda-908-digital-attenuator.png'), ('size', 167485), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/r3ZtBDMbCC3sRSfB4ec0xA/uiboM-zrTRBGcPOPbefMr7ViBSI-d3UJXC_e6OJPPKiXvSg18FHIEUu7qUZUoUTevYMdpQG_DHnautnFTdGdPQ/3YhFF1fvaSXZQw-uLeNpmjQ8daXVU0KDvgBvPatv0xo'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GtlSqc7soqdfUX8t84SuNA/KMg5dX3JiVIg9pkRS3-I5qTpI5uRFMDjbzxQ4MnLKkqQpC_wjr9NXPP2Hcec8doSB2YkoGF8JF7UKX_qp22RJQ/EPSRHnL-oNcs9H_DQjWmM8lD1IwoC3tSJwqS7CycA-c'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/P1yDkTeWxHuwaRY6XsbC6A/64UDHQmGnE32uogI6HnnVI3JB7_RUexgWkffSABsfJI4NRrLhf44IrRggUphNTNOf0SZAA1UyOU9AYKwVTR79g/KICsAj5GS9LJS2CCoy0Rva8vIJE5LT2pIDleGfhMOMk'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-908V Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator. The LDA-908V provides calibrated attenuation from 200 to 8000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 90 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-908v-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-908V,Write a Python script that uses Qcodes Community to connect to a LDA-908V ,599.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
242,https://lasphotonics.com/wp-content/uploads/2020/12/zi_hf2li_leaflet_web.pdf,https://en.wikipedia.org/wiki/Lock-in_amplifier,"[OrderedDict([('id', 'attP2nH7AT3gRy554'), ('width', 1183), ('height', 387), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9HJDiS2NIy9fQGO8qktrKQ/LWaeAP-7eobKgwZXt8zdco-e8u7k-ShTfTfp60LMimEBgDNqAJTWFWWsimqutrSwhdnpIsmILDHi5h81tsIsbBLZGtNPS5wOafmuazZPPAc/5eRpiWsXX1h9TYP2l1t09dvWbbWq6MswjjvIF39dBhQ'), ('filename', 'hf2li_persp.png.webp'), ('size', 27462), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GXUiwDjeyW9zn0ryPJ_lUQ/6ODEz7f6VLPBJHHmbo15dp7n4owdgE0H3WRvd1XfFdJMgqVwGy2YvGoHX0tX-uWah37vWWeGKwTd9X-8wIFD1ftdkoO-5waEdWsnIJrH5tI/yEYLuGEUaWXK6RO1s5nWSKRGHOx-0Wa_2bFFzJIO_dk'), ('width', 110), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/0rk7j8rDMwYz8aHTn1OMPA/34j1C7eUNk9cLVmObbJil5SbhNPeMEaPaHpfLo7dzkB7sH3HJHfXFR00c2oNyT30hSB_ev3HOLf-xjeKGFGNnHM8tSImiuStxS6e4DEOhCY/9G6KDAninfyKdrUfc-yGmiReiensK8oyhgTx-zp5PCk'), ('width', 1183), ('height', 387)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/SBpn6ToNCQEz4fzVcbrNWA/h7XyOC6FkNk8BcI_MRtQSQjJ6JZhK9C_wa2riE3-Goxc4LvzZIIbHLu_FIUmcOPiD1J4iystw8KuPZCbjujstUD2hbEymZq_n2hrp5PcdUg/U32ID513s2mb7MlD5I7c3q0LIaxhWXC7kSixAF5fV-k'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,The Zurich Instruments HF2LI is a digital lock-in amplifier covering the frequency range between DC and 50 MHz. It is the instrument of choice for the characterization of MEMS devices such as gyroscopes and for measurements in the area of microfluidics.,https://www.zhinst.com/americas/en/products/hf2li-lock-in-amplifier,HF 2 LI,650.0,['Lockin Amplifiers'],"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/ZurichInstruments/HF2LI.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/ZurichInstruments_HF2LI.ipynb,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Nhkgwh64AuogSl3HWobl2Q/rQDQ1GNPkIq-GhACurIJJZxLiHEOnOLLRIBSwQeiBMmaqHOy-wUrt2n-Tvpfw5hH3Eup_ifOZhM4n8m8pq0CjxZGl3pAfV6mMXnkolSlybCNocXKouqbYzfqcK4jFdpD/SKZVV7j5hDwPZHgu_Q5i9AQeRpkYKkinzBJbAiBFkuo'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DV0ujSSrAJU3tHZZcN2NSA/8JeKB-Jpys2BIlZqsTAHmKF9-jppmBKmGmlEckoBtdN8otIRJNHyuxBKfLYD4vVAfyFOOlwoyM97SmbnXOYYLA/PiE1JpBZIGxy_o-SWd1tiSrP9Na18_Qk_oQ8Sd8B-YE'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FzFWiuhLcQdI5sgfhFAmrg/qGaYae2vNfXTXgUkvbw50ZwzoArdYDJ_xZ5wEBpjRyZNb6jJOPuIyl16l6PZNtxyHWLGuBUAUm4M_4MT4MQzXg/pCT8wFuAw7yLVs0L6AqPzTW6k9UOYWw_3452tjsMAnQ'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/AZ4g8jrEIKeTJWaFe2R2zg/rTqIW8FwmQdlkRyUz-N2OYEK6zt0fmq12VCQVFsiVyar5I6-eMdHqr_VWX0OYsBuKeP1MqV_p4lyzDDba34jVQ/JiXFWfnDh71ZNiYlld55xkwWB-aibfR43E5ET7IZntI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,HF2LI,Write a Python script that uses Qcodes Community to connect to a HF2LI Lockin Amplifiers,,,,,"from typing import Dict, List, Optional, Sequence, Any, Union
import numpy as np
import logging
log = logging.getLogger(__name__)

import zhinst.utils
import qcodes as qc
from qcodes.instrument.base import Instrument
import qcodes.utils.validators as vals

class HF2LI(Instrument):
    """"""Qcodes driver for Zurich Instruments HF2LI lockin amplifier.

    This driver is meant to emulate a single-channel lockin amplifier,
    so one instance has a single demodulator, a single sigout channel,
    and multiple auxout channels (for X, Y, R, Theta, or an arbitrary manual value).
    Multiple instances can be run simultaneously as independent lockin amplifiers.

    This instrument has a great deal of additional functionality that is
    not currently supported by this driver.

    Args:
        name: Name of instrument.
        device: Device name, e.g. ""dev204"", used to create zhinst API session.
        demod: Index of the demodulator to use.
        sigout: Index of the sigout channel to use as excitation source.
        auxouts: Dict of the form {output: index},
            where output is a key of HF2LI.OUTPUT_MAPPING, for example {""X"": 0, ""Y"": 3}
            to use the instrument as a lockin amplifier in X-Y mode with auxout channels 0 and 3.
        num_sigout_mixer_channels: Number of mixer channels to enable on the sigouts. Default: 1.
    """"""
    OUTPUT_MAPPING = {-1: 'manual', 0: 'X', 1: 'Y', 2: 'R', 3: 'Theta'}
    def __init__(self, name: str, device: str, demod: int, sigout: int,
        auxouts: Dict[str, int], num_sigout_mixer_channels: int=1, **kwargs) -> None:
        super().__init__(name, **kwargs)
        instr = zhinst.utils.create_api_session(device, 1, required_devtype='HF2LI')
        self.daq, self.dev_id, self.props = instr
        self.demod = demod
        self.sigout = sigout
        self.auxouts = auxouts
        log.info(f'Successfully connected to {name}.')

        for ch in self.auxouts:
            self.add_parameter(
                name=ch,
                label=f'Scaled {ch} output value',
                unit='V',
                get_cmd=lambda channel=ch: self._get_output_value(channel),
                get_parser=float,
                docstring=f'Scaled and demodulated {ch} value.'
            )
            self.add_parameter(
                name=f'gain_{ch}',
                label=f'{ch} output gain',
                unit='V/Vrms',
                get_cmd=lambda channel=ch: self._get_gain(channel),
                get_parser=float,
                set_cmd=lambda gain, channel=ch: self._set_gain(gain, channel),
                vals=vals.Numbers(),
                docstring=f'Gain factor for {ch}.'
            )
            self.add_parameter(
                name=f'offset_{ch}',
                label=f'{ch} output offset',
                unit='V',
                get_cmd=lambda channel=ch: self._get_offset(channel),
                get_parser=float,
                set_cmd=lambda offset, channel=ch: self._set_offset(offset, channel),
                vals=vals.Numbers(-2560, 2560),
                docstring=f'Manual offset for {ch}, applied after scaling.'
            )
            self.add_parameter(
                name=f'output_{ch}',
                label=f'{ch} outptut select',
                get_cmd=lambda channel=ch: self._get_output_select(channel),
                get_parser=str
            )
            # Making output select only gettable, since we are
            # explicitly mapping auxouts to X, Y, R, Theta, etc.
            self._set_output_select(ch)
            
        self.add_parameter(
            name='phase',
            label='Phase',
            unit='deg',
            get_cmd=self._get_phase,
            get_parser=float,
            set_cmd=self._set_phase,
            vals=vals.Numbers(-180,180)
        )
        self.add_parameter(
            name='time_constant',
            label='Time constant',
            unit='s',
            get_cmd=self._get_time_constant,
            get_parser=float,
            set_cmd=self._set_time_constant,
            vals=vals.Numbers()
        )  
        self.add_parameter(
            name='frequency',
            label='Frequency',
            unit='Hz',
            get_cmd=self._get_frequency,
            get_parser=float
        ) 
        self.add_parameter(
            name='sigout_range',
            label='Signal output range',
            unit='V',
            get_cmd=self._get_sigout_range,
            get_parser=float,
            set_cmd=self._set_sigout_range,
            vals=vals.Enum(0.01, 0.1, 1, 10)
        )
        self.add_parameter(
            name='sigout_offset',
            label='Signal output offset',
            unit='V',
            get_cmd=self._get_sigout_offset,
            get_parser=float,
            set_cmd=self._set_sigout_offset,
            vals=vals.Numbers(-1, 1),
            docstring='Multiply by sigout_range to get actual offset voltage.'
        )
        for i in range(num_sigout_mixer_channels):
            self.add_parameter(
                name=f'sigout_enable{i}',
                label=f'Signal output mixer {i} enable',
                get_cmd=lambda mixer_channel=i: self._get_sigout_enable(mixer_channel),
                get_parser=float,
                set_cmd=lambda amp, mixer_channel=i: self._set_sigout_enable(mixer_channel, amp),
                vals=vals.Enum(0,1,2,3),
                docstring=""""""\
                0: Channel off (unconditionally)
                1: Channel on (unconditionally)
                2: Channel off (will be turned off on next change of sign from negative to positive)
                3: Channel on (will be turned on on next change of sign from negative to positive)
                """"""
            )
            self.add_parameter(
                name=f'sigout_amplitude{i}',
                label=f'Signal output mixer {i} amplitude',
                unit='Gain',
                get_cmd=lambda mixer_channel=i: self._get_sigout_amplitude(mixer_channel),
                get_parser=float,
                set_cmd=lambda amp, mixer_channel=i: self._set_sigout_amplitude(mixer_channel, amp),
                vals=vals.Numbers(-1, 1),
                docstring='Multiply by sigout_range to get actual output voltage.'
            )

    def _get_phase(self) -> float:
        path = f'/{self.dev_id}/demods/{self.demod}/phaseshift/'
        return self.daq.getDouble(path)

    def _set_phase(self, phase: float) -> None:
        path = f'/{self.dev_id}/demods/{self.demod}/phaseshift/'
        self.daq.setDouble(path, phase)
        
    def _get_gain(self, channel: str) -> float:
        path = f'/{self.devid}/auxouts/{self.auxouts[channel]}/scale/'
        return self.daq.getDouble(path)

    def _set_gain(self, gain: float, channel: str) -> None:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/scale/'
        self.daq.setDouble(path, gain)

    def _get_offset(self, channel: str) -> float:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/offset/'
        return self.daq.getDouble(path)

    def _set_offset(self, offset: float, channel: str) -> None:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/offset/'
        self.daq.setDouble(path, offset)

    def _get_output_value(self, channel: str) -> float:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/value/'
        return self.daq.getDouble(path)

    def _get_output_select(self, channel: str) -> str:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/outputselect/'
        idx = self.daq.getInt(path)
        return self.OUTPUT_MAPPING[idx]

    def _set_output_select(self, channel: str) -> None:
        path = f'/{self.dev_id}/auxouts/{self.auxouts[channel]}/outputselect/'
        keys = list(self.OUTPUT_MAPPING.keys())
        idx = keys[list(self.OUTPUT_MAPPING.values()).index(channel)]
        self.daq.setInt(path, idx)

    def _get_time_constant(self) -> float:
        path = f'/{self.dev_id}/demods/{self.demod}/timeconstant/'
        return self.daq.getDouble(path)

    def _set_time_constant(self, tc: float) -> None:
        path = f'/{self.dev_id}/demods/{self.demod}/timeconstant/'
        self.daq.setDouble(path, tc)

    def _get_sigout_range(self) -> float:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/range/'
        return self.daq.getDouble(path)

    def _set_sigout_range(self, rng: float) -> None:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/range/'
        self.daq.setDouble(path, rng)

    def _get_sigout_offset(self) -> float:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/offset/'
        return self.daq.getDouble(path)

    def _set_sigout_offset(self, offset: float) -> None:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/offset/'
        self.daq.setDouble(path, offset)

    def _get_sigout_amplitude(self, mixer_channel: int) -> float:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/amplitudes/{mixer_channel}/'
        return self.daq.getDouble(path)

    def _set_sigout_amplitude(self, mixer_channel: int, amp: float) -> None:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/amplitudes/{mixer_channel}/'
        self.daq.setDouble(path, amp)

    def _get_sigout_enable(self, mixer_channel: int) -> int:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/enables/{mixer_channel}/'
        return self.daq.getInt(path)

    def _set_sigout_enable(self, mixer_channel: int, val: int) -> None:
        path = f'/{self.dev_id}/sigouts/{self.sigout}/enables/{mixer_channel}/'
        self.daq.setInt(path, val)

    def _get_frequency(self) -> float:
        path = f'/{self.dev_id}/demods/{self.demod}/freq/'
        return self.daq.getDouble(path)

    def sample(self) -> dict:
        path = f'/{self.dev_id}/demods/{self.demod}/sample/'
        return self.daq.getSample(path)
        
"
244,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attsdQ8UwcgOTb7gn'), ('width', 961), ('height', 1109), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/-m2vlJ5nvCHwrSLYOZGgSA/6GiTOC-o2zUBsgJedgGcu9qvGTSv6q6qRBiELPZGFXjujIJRcpEQz8i3PR0mNPsAWpF2xJK_SWCxWV-Nq2dehVSKXn8LgNzy1B8Zv5XI09LgtaHX54sBApFAjSPejhiY/vznbLFRiVyqAs6bp5X0WvYWK397BmiL1LI0fIK8BoVo'), ('filename', 'lda-608v-4-product-photo.jpg'), ('size', 79951), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8-eys4sP9s8DPsa1ASTJRQ/NZwxc0bbDTn0gdyqI9AQkKZLSedN7VI-HW2MH179GzS7wKB4SNLVKi63HGKpFfIjo0PDp8eEaobxEfhSum_hlQ/zuzKU8odjwtLNOnxeaAGHmyrPCH0yyeN0BKRFouhUko'), ('width', 31), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/InaRg28lKF5N7aSETopk_Q/ThMiJlI5_gwu_SKYYL0X9HD7oZJsM74p7IUp2CHZ_pawG-RiKRPiihY8BPkJ5dMkxmNvVGH3gAUQcEnWZzaE4g/qlCpz7-OFlEE5g92hV8AM3wUn9voVh5rs4PzSvvnH2Q'), ('width', 512), ('height', 591)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/-vBWAJV7N3bSSgZnQ2ilwA/aZTwmio1zHu7dI7tPd2tLja5KM4-9BPyokzNK0gjKbZk7BNzHKTsuU6CQzZIrnesMoOe_USehsgvEXsILAD9dQ/iTJw2Gadard5T2aDKu5_kaMUvQjYzEhfkrV42HEovFc'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-608V-4 Digital Attenuator is a highly accurate, bidirectional, 50 Ohm step attenuator with 4 independently controlled attenuator paths. The LDA-608V-4 provides calibrated attenuation from 200 to 8000 MHz with an amazing step size of 0.1 dB and typical accuracy <0.25 dB over 60 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-608v-4-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-608V-4,Write a Python script that uses Qcodes Community to connect to a LDA-608V-4 ,1400.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
249,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attreAllvLxRUZp7O'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BdrxWPRFn---V8Tv2hnttg/HtWqVdTzWw786JY9FVrfRQyimSYS9iZy8wPQkvqmcYK-nccEAytk_SH777nXLzOBHmnl3SH5AZoJ7_PnfnrMSIsbqH2sqOqmWLrJ5Jjtxf23YHtm0eWS1f-vzqe5khy6/-0kcTFgoDVFYKGIfEOhRFOAc-nCbkX3ZZ-BBcSmInRo'), ('filename', 'vaunix-lda-908-digital-attenuator.png'), ('size', 167485), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/r3ZtBDMbCC3sRSfB4ec0xA/uiboM-zrTRBGcPOPbefMr7ViBSI-d3UJXC_e6OJPPKiXvSg18FHIEUu7qUZUoUTevYMdpQG_DHnautnFTdGdPQ/3YhFF1fvaSXZQw-uLeNpmjQ8daXVU0KDvgBvPatv0xo'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GtlSqc7soqdfUX8t84SuNA/KMg5dX3JiVIg9pkRS3-I5qTpI5uRFMDjbzxQ4MnLKkqQpC_wjr9NXPP2Hcec8doSB2YkoGF8JF7UKX_qp22RJQ/EPSRHnL-oNcs9H_DQjWmM8lD1IwoC3tSJwqS7CycA-c'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/P1yDkTeWxHuwaRY6XsbC6A/64UDHQmGnE32uogI6HnnVI3JB7_RUexgWkffSABsfJI4NRrLhf44IrRggUphNTNOf0SZAA1UyOU9AYKwVTR79g/KICsAj5GS9LJS2CCoy0Rva8vIJE5LT2pIDleGfhMOMk'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-203B Digital Attenuator is a bidirectional, 50 Ohm step attenuator. The LDA-203B provides 63 dB of attenuation control over the frequency range of 1 to 20 GHz with a step size of 0.5 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-203b-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-203B,Write a Python script that uses Qcodes Community to connect to a LDA-203B ,1199.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
252,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'att3jTMa94X7WP4EY'), ('width', 408), ('height', 336), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/f-04eIlQOQmrvrj99pFRzQ/nEaGHBFXO4N7EX2uj1eN9BLn3J8rq5tvMVNh925OQ5sO2djmpbiVK6BKtjj9ceX6PGfIbz6cfzEXgNLuhopr8JbJ6roHW_4gjZ9tOjSXRTXme1RvROqx6n9CNCLbYkGr/kKIQKfM9xQUDqGqCcm_gBzQSY6kdAqVpNy_b8YV6ops'), ('filename', 'vaunix-digital-attenuator-n.png'), ('size', 122214), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/EzlUHpf9K0yCVvPc2mFe0Q/6kbOGp12MKfRyWueaS_gO0COeRLpjxCEdwjqUUpxhbs0fhBqEbP1wxubv-AMwN22FsVL8qXTvqQVY-dwSmpSNg/0rP8A2E57VHr7qfEjGNFLmIpMdgJj9tFvpMSxVC68ow'), ('width', 44), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/OsubHIleC2A3cPWNNxQZTA/Dbma_x4suWmvarSe_kg01Cn0PS1DkMFm3gAhWhSVBOIT36xAcBoJl1bMJ0gttjiiYdfRaPSCVssKkUwHgl4_zQ/FR9WpoiXFibiNBpV6t7ApBDmGaGNZlvwxwmddm0573c'), ('width', 408), ('height', 336)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/B3DdGLSZKsqbPovpBgts7Q/JMtthj2gyi9mazE0BvlfiTV3XirQGfCUJ4c_bQOBQbrtLLsg-KLP1n9u5YamEhspuHg6w8cPFkwvs-v7zGM3rg/siLr88WLexJt7pioPAycMpxzqwSTIxtQ5y-UEMEBGY8'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-102N Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +22 dBm, and offers frequency coverage of 10 to 1,000 MHz. It has an attenuation range of 63 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-102n-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-102N,Write a Python script that uses Qcodes Community to connect to a LDA-102N ,415.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
255,https://www.thorlabs.com/_sd.cfm?fileName=19737-D02.pdf&partNumber=PRM1Z8,,"[OrderedDict([('id', 'attM9BeZyqKK8IwaA'), ('width', 780), ('height', 780), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/N7iKtUwkSL37DAXPjZxdIA/SDxt-z0fJNQN5x8oKtG4x_MtUhtNbtD_YKko-uLXUBKntMFC2-uqCy50YDt88uJOvqVfUtr3d7dnEIoOqNuJwGwdRyBtCDLqmHh7mRFsBE4/Kl0jn_lx0eWHI8z-9ltzSedrn44vPTmm94R0wAci-CQ'), ('filename', '4092_PRM1Z8_SGL.jpg'), ('size', 37807), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/QZ6kHzMunhz7_gJNp84-Iw/w-972eyL_8VCbtwHu3zOg1fWjcanw-UbLtpmczmI9ZpD656ZoAQhzXav-uzoc-XUjDRChxiOTPyt1SeAbyoQVw/BTnpebNYWKYEIvUnuYpYUGp3z6t751WCqmarvqAYbz0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/IF_71CWA87de2miM-0Fq1w/0aZ7R1ZfEErA6ifiwk3NnyLeX05D0V8ub5eOPbA2LluH6l1TuweN1Op4Jz8-8iny0jbsInEyKpfysLkxw9m69w/QhsZCJ3MV3TeNgGQUYo-cHlBrsylHto4sK6-pvyGgRs'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Mn_WBjfXi1ASQD6uLBMCTg/HeHuak24y8YPuQtKRrgwvcQoUggl9WDbeBINw7oWd_7hy7Gu3jF9-f9JjwP8_mN1Y58xAXNKe1leSUTEz3wNNg/7jTEb2zX6eihV89K019SUY8qUfsi86UJVcJhZIro4XQ'), ('width', 3000), ('height', 3000)]))]))])]",550.0,USA,"The PRM1Z8 is a small, compact, DC servo motorized 360° rotation mount and stage that accepts Ø1"" optics and SM1-threaded components. The user can measure the angular displacement by using the Vernier dial in conjunction with the graduation marks that are marked on the rotating plate in 1° increments. This rotation stage/mount is also equipped with a home limit switch to facilitate automated rotation to the precise 0° position, allowing absolute angular positioning thereafter. The limit switch is designed to allow continuous rotation of the stage over multiple 360° cycles.",https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=2875&pn=PRM1Z8,PRM 1 Z 8,618.0,['Motion'],,"Thorlabs, Inc. is an American privately held optical equipment company headquartered in Newton, New Jersey. The company was founded in 1989 by Alex Cable, who serves as its current president and CEO. As of 2018, Thorlabs has annual sales of approximately $500 million.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Thorlabs/PRM1Z8.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Thorlabs_PRM1Z8.ipynb,Thorlabs,"[OrderedDict([('id', 'attRmyBjaipm6atue'), ('width', 295), ('height', 50), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CvgXbArkB27mn-PsYJbdKA/jsnVknsEqxjTF3CFPCLxHvs66QnCiYZlrKfOcYSKT0xlShMdVypaziFjxP-GbYNg2o2nq76d9Ht5yM4bP9o2TDL67EuBfoXyvODtMPd3CPc/E_KBqkl6cDSDcDXfLtNSq5XkXPqT9aqGVwHXLIwRZek'), ('filename', 'Thorlabs_Logo_Red.png'), ('size', 3614), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Jfn9nSRvZW7vWKd0MIGCvw/-b0s1tsK7Jr-okNRoo-YO9QnD1OhX3my9LS0kawwb4B0pjtBcsNrUw35bHRIN8hLpo5Oj2XnkkGAgG3_47sDwA/fJoXn-ks6nJSad3lfq8kIYH241PfMgw8cN7nzjpqa7E'), ('width', 212), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/V12sgCHA4vKGEDSNnRvERg/BbUh5Ie3dcStXKs6vv_18n-FHe_g8pF8MVKEv_0qvX6r48VA9MCJpV8Rh5euFmU9Bgh7IEU3avXmcSj1WE-bBg/mw8N06nvz-TE83u6CHhkKd3g7QenZawZ2_mNg2PxIfU'), ('width', 295), ('height', 50)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wu3UZ6gHLFH9ebCWIFbGUA/zfw97WSqJfvW-RxyEC9uihliGkYCpT-Ow3ZyWL5IDD6kLAlqBxTb2UoOQxP_cWhF6-yYkE5W0iI53rUuOkwd6A/8gmlAC3gkDu2TyIIbcFvdDygRU8DhgE2_mEfIzF3OaY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thorlabs.com/,PRM1Z8,Write a Python script that uses Qcodes Community to connect to a PRM1Z8 Motion,1037.67,,,,"from qcodes import Instrument
from .APT import Thorlabs_APT, ThorlabsHWType


class Thorlabs_PRM1Z8(Instrument):
    """"""
    Instrument driver for the Thorlabs PRMZ1Z8 polarizer wheel.

    Args:
        name: Instrument name.
        device_id: ID for the desired polarizer wheel.
        apt: Thorlabs APT server.

    Attributes:
        apt: Thorlabs APT server.
        serial_number: Serial number of the polarizer wheel.
        model: Model description.
        version: Firmware version.
    """"""

    def __init__(self, name: str, device_id: int, apt: Thorlabs_APT, **kwargs):

        super().__init__(name, **kwargs)

        # save APT server link
        self.apt = apt

        # initialization
        self.serial_number: int = self.apt.get_hw_serial_num_ex(ThorlabsHWType.PRM1Z8, device_id)
        self.apt.init_hw_device(self.serial_number)
        self.model, self.version, _ = self.apt.get_hw_info(self.serial_number)

        # add parameters
        self.add_parameter('position',
                           get_cmd=self._get_position,
                           set_cmd=self._set_position,
                           unit=u""\u00b0"",
                           label='Position')

        # print connect message
        self.connect_message()

    # get methods
    def get_idn(self):
        return {'vendor': 'Thorlabs', 'model': self.model,
                'firmware': self.version, 'serial': self.serial_number}

    def _get_position(self):
        return self.apt.mot_get_position(self.serial_number)

    # set methods
    def _set_position(self, position):
        self.apt.mot_move_absolute_ex(self.serial_number, position, True)
"
257,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attquOEHC31yDwYV2'), ('width', 735), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/s3Ejtf1gPUmjQyg4EKEkdA/KPzaY8ND3BlB8KmqRqLm3wnetpGlJfApyn8jG5XR056LGMsDD_ABSLehvk6NsQpjtuSPCIzs1sxyCY6TA5SH_Uj98eg5emPpfJSo7LL21pQ/jR1Lr3vs7Mzfui4tcsFR_lLCnbYAu8z10KNPtHb_jYQ'), ('filename', 'lda-802-16-product.png'), ('size', 134941), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ezNfsl6y73p8LMLCMfuDvQ/0bBnHc47rmW4x_88PVUjfUdXp620Pg6kljABJ0lBuM_mcUj-yAVFmDnmD8UUSyzP1ir6LxkI5umFotSTbPa8nA/Bts-7ZtckueLWunSiar-4Yuo_bsJ4ww-JEoq1_eL7vY'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/R2S_eajYeUngTVp3T7QWjA/EADRiu7OD65BLljPJrTBrbVFHRuq-KpR7V6Sfr2UATNyBjVeVc8MjxlByabTX0CsEyCrq07_aE97GFe3W4onBg/qMYl-YPdElypYK4y8tKMR19t5iI9i0ffl2S9fL-qag8'), ('width', 735), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/OBnzpbTwdd5AxUgJNBruqg/C95xx-80jklI82ioidFt1Oc9HMzoCEnbx-mMpcFtmhCQ-IuHGYXE_aaVACHKwpj04fM-j3ldZ9cWkaGSVH3j1Q/joYnkYaAajvXGsIC8Jv3ikZThWrhKW2qBCOg32kI4eM'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802-16 Digital Attenuator is a rack mounted 16-channel high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802-16 provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and user defined fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802-16-high-resolution-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802-16,Write a Python script that uses Qcodes Community to connect to a LDA-802-16 ,9500.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
263,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attEHHnQFKIW24UvA'), ('width', 394), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/no9xBP5On8uccGQGAI5PmA/Xmlzi-CkU9q1XJSxqB9fdjUq9A0BUhjMd1Jt5ZvXGAmbRk9_yBvL2j0sWge4HAhKcSSZXgZJyWN-XvF0CtruuSuMygQ0f43sEGQGQ0NTjHI/revBRokkkguKCUAcWHw08FFQ1binv1B0AS6E5se7dws'), ('filename', 'vaunix-lda-133.png'), ('size', 87729), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8xL8KAC_MJVTDL0_Tab7YQ/pc8EBvJwnRFGhvzn3WpiHC4drfuwhgCkivNaFoOotj_0jUglEaASHUYr7EO-COIaBCzPR0j38GclaPYJ20fqEw/mR0Nyvc5QXTfMoKcS2sh9R8L8I4a9uAmLYAoI-k9o-k'), ('width', 52), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FWFB94KLjTI7nXadznEjpQ/2lmzapCKmXEtnNVXTIeOuqXHODarbOAHTzA-Dqs8hWqoIsJu9dc4Hkn9Fo4FwO4K4Ny-l-5lzTNpuqqbfcXf-w/hNoZdVlQRFuuL-xmyD_W4D17PVeqa_jz0ZDVpXpDdmM'), ('width', 394), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5FA_HtrPjQVNASMeFX4JzQ/F9mais3CbTB3N-SWjsqQpEBw6XK7W4vWb_ebXaux9oVpBVMGvhtcxwyPL5OsZ-6kTtVaLBVoQCfFT_JR_GxiVg/4-iu7KQREp8fS7srZmnmmHuHLVjowEsPNY_p61o-C-g'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-133 Digital Attenuator is a bidirectional, 50 Ohm step attenuator. The LDA-133 provides fast attenuation changes from 10 to 13000 MHz with a step size of 0.5 dB and 63 dB of control range. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-133-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-133,Write a Python script that uses Qcodes Community to connect to a LDA-133 ,649.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
264,could not find,"https://www.analog.com/en/technical-articles/low-power-iq-modulator-for-digital-communications.html#:~:text=What's%20an%20IQ%20Modulator%3F,and%20phase%20can%20be%20selected.","[OrderedDict([('id', 'attfLjCw8p5KPkUum'), ('width', 250), ('height', 996), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mOzknA31JqAjO31EOiXcnQ/twENcGwwk-zz4JPfMZ9MRQxkSMjg_dIa6x2GM6150pdlZIMC_3UkrbwW5bGs7cP1o2rBpkug3QqftSVpmfSJ7LZHTKekqNjQA19zvbwoeFE/Tb6e2JQg90zxxsXE5at2hw5F_Dw-6rUSMwZbZ8A9Am0'), ('filename', 'FrontF1d.png'), ('size', 334389), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/u0N7nYdYLnMUceOGAuq-KA/pAyES9dZXSFKfQwut89MTQFhaw-Mf7QAMgOWpYzh3tmSWDkuo4a3yqpZ1fAqjEz69rnyNNLiEOQesFzmgVVY4A/r-38yM52LiNkzKLgETlUm6YFWbERKDgp0MMRmTnWRzw'), ('width', 9), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/28Th6XJMjmycfWYLZ7jKEQ/-phMbfMovp1fvAz-eb89ukLLmuLzW0y-KJKUPiFAcwCta76ehoSX45Y6vVVfHMRUrAggpXDhlhxGLL6Xz7JLRg/pLwNPMO6mFgkOd_BfWd-lFlH2hTPrqGJ-s10uQI3HZ8'), ('width', 250), ('height', 996)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/2X5MfW3zQt4GlM7gvLYtQg/_lhz-cr7c8DY0DsM73w1JKjw8EGmOvNQYaUi35gvm1XrnOuWKxr5r6Kcz2g3Zd8uLS8Lt7fDg9aLmw08Ir4HuQ/gPXKdSTk7uiC4m7j-q9TNZHEayCJIzKV3P5zVAnTUgY'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands",The F1d module is an IQ demodulator ranging from 40 MHz to 1.4 GHz. It was initially designed for reflectometry and to be used in conjuction with the S5i RF source and the M2j low noise amplifier.,https://qtwork.tudelft.nl/~mtiggelman/modules/rf/f1d.html,F1D,435.0,['RF Signal Generator'],"An IQ modulator is a device that converts baseband information into RF signals. Internally, two double-balanced mixers are combined as shown below. By modulating with both in-phase (I) and quadrature (Q) inputs, any arbitrary output amplitude and phase can be selected.  ","At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/F1d.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.F1d,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,F1d	,Write a Python script that uses Qcodes Community to connect to a F1d	 RF Signal Generator,,,,,"from qcodes.instrument.base import Instrument
from qcodes.utils.validators import Enum

try:
    from spirack import F1d_module
except ImportError:
    raise ImportError(('The F1d_module class could not be found. '
                       'Try installing it using pip install spirack'))


class F1d(Instrument):
    """"""
    Qcodes driver for the F1d IQ-Mixer SPI-rack module.

    Args:
        name (str): name of the instrument.

        spi_rack (SPI_rack): instance of the SPI_rack class as defined in
            the spirack package. This class manages communication with the
            individual modules.

        module (int): module number as set on the hardware.

    The `enable_remote` parameter sets the F1d module in remote mode. When settings are changed on the
    hardware front panel, then the remote mode is deactivated

    """"""

    def __init__(self, name, spi_rack, module, **kwargs):
        super().__init__(name, **kwargs)

        self.f1d = F1d_module(spi_rack, module)

        self.add_parameter('remote_settings',
                           label='Remote settings',
                           get_cmd=self.get_remote_settings)

        self.add_parameter('IQ_filter',
                           label='IQ filter',
                           set_cmd=self.f1d.set_IQ_filter,
                           unit='MHz',
                           vals=Enum(1, 3, 10),
                           docstring='Low-pass filter after demodulation')

        self.add_parameter('I_gain',
                           label='I gain',
                           set_cmd=self.f1d.set_I_gain,
                           vals=Enum('low', 'mid', 'high'),
                           docstring='Gain of amplifier of demodulatd signal')

        self.add_parameter('Q_gain',
                           label='Q gain',
                           set_cmd=self.f1d.set_Q_gain,
                           vals=Enum('low', 'mid', 'high'),
                           docstring='Gain of amplifier of demodulatd signal')

        self.add_parameter('RF_level',
                           label='RF level',
                           get_cmd=self.f1d.get_RF_level,
                           unit='dBm')

        self.add_parameter('LO_level',
                           label='LO level',
                           get_cmd=self.f1d.get_LO_level,
                           unit='dBm')

        self.add_parameter('enable_remote',
                           label='Enable remote',
                           set_cmd=self.f1d.enable_remote, docstring='getting the remote status is not possible')
        self.add_function('clear_rf_clip',
                          call_cmd=self.f1d.clear_rf_clip)
        self.add_function('is_rf_clipped',
                          call_cmd=self.f1d.rf_clipped)

    def get_remote_settings(self):
        return self.f1d.remote_settings
"
269,,https://en.wikipedia.org/wiki/Signal_generator,,2500.0,"Munich, Germany","The Rohde & Schwarz SMW200A-B140 is the vector signal generator for the most demanding applications

",https://www.trsrentelco.com/products/rohde-schwarz-smw200a-b140?utm_source=google&utm_medium=cpc&utm_campaign={campaign}&utm_agid=143634755188&kwd=&ad_type=629507024539&device=c&placement=&match_type=&gclid=Cj0KCQjw8NilBhDOARIsAHzpbLDicdUNeBPYFjO4e97wmrtasu68AG4TErW4fvZzZexgopXQBkpkFaMaAi00EALw_wcB&gad=1,"SMW 200A - B140
",476.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/SMW200Asim.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.SMW200Asim,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,"SMW 200A - B140
",Write a Python script that uses Qcodes Community to connect to a {Device name} RF Signal Generator,,,,,"# -*- coding: utf-8 -*-
""""""Simulation for the QCoDeS-Driver SMW200A.

This simulation is used to generate meanfull answers
to the comunication from the driver if the hardware
is not available.

Authors:
    Michael Wagener, ZEA-2, m.wagener@fz-juelich.de
""""""
import pyvisa
from qcodes.instrument.visa import VisaInstrument
from qcodes.utils.validators import Numbers


class MockVisa(VisaInstrument):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.add_parameter('state',
                           get_cmd='STAT?', get_parser=float,
                           set_cmd='STAT:{:.3f}',
                           vals=Numbers(-20, 20))

    def set_address(self, address):
        self.visa_handle = MockVisaHandle()


class MockVisaHandle:
    '''
    Simulate the API needed for a visa handle.
    '''
    
    # List of possible commands asked the instrument to give a realistic answer.
    cmddef = {'*IDN?': 'Rohde&Schwarz,SMW200A,1412.0000K02/105578,04.30.005.29 SP2',
              '*OPT?': 'SMW-B13T,SMW-B22,SMW-B120,SMW-K22,SMW-K23',
              
              'STAT?': '0',
              
              'SOUR1:FREQ?': '20000000000.0',
              'SOUR1:POW:POW?': '-145.0',
              'OUTP1:STAT?': '0',
              'SOUR1:FREQ:MODE?': 'CW',
              'SOUR1:FREQ:CENT?': '300000000.0',
              'SOUR1:FREQ:SPAN?': '400000000.0',
              'SOUR1:FREQ:STAR?': '100000000.0',
              'SOUR1:FREQ:STOP?': '500000000.0',
              'SOUR1:FREQ:LOSC:INP:FREQ?': '0',
              'SOUR1:FREQ:LOSC:MODE?': 'INT',
              'SOUR1:FREQ:LOSC:OUTP:FREQ?': '0',
              'SOUR1:FREQ:LOSC:OUTP:STAT?': '0',
              
              'SOUR1:SWE:POW:AMOD?': 'AUTO',
              'SOUR1:SWE:POW:DWEL?': '0.01',
              'SOUR1:SWE:POW:MODE?': 'AUTO',
              'SOUR1:SWE:POW:POIN?': '21',
              'SOUR1:SWE:POW:STEP?': '1.0',
              'SOUR1:SWE:POW:SHAP?': 'SAWT',
              'SOUR1:SWE:POW:RETR?': '0',
              'SOUR1:SWE:POW:RUNN?': '0',
              'SOUR1:SWE:DWEL?': '0.01',
              'SOUR1:SWE:MODE?': 'AUTO',
              'SOUR1:SWE:POIN?': '401',
              'SOUR1:SWE:SPAC?': 'LIN',
              'SOUR1:SWE:SHAP?': 'SAWT',
              'SOUR1:SWE:RETR?': '0',
              'SOUR1:SWE:RUNN?': '0',
              'SOUR1:SWE:STEP:LOG?': '1.0',
              'SOUR1:SWE:STEP?': '1000000.0',
              
              'SOUR:LFO1:BAND?': 'BW10',
              'SOUR:LFO1:STAT?': '0',
              'SOUR:LFO1:OFFS?': '0',
              'SOUR:LFO1:SOUR?': 'LF1',
              'SOUR:LFO1:VOLT?': '1.0',
              'SOUR:LFO1:PER?': '0.001',
              
              'SOUR1:LFO1:FREQ?': '1000.0',
              'SOUR1:LFO:FREQ:MAN?': '1000.0',
              'SOUR1:LFO:FREQ:STAR?': '1000.0',
              'SOUR1:LFO:FREQ:STOP?': '50000.0',
              'SOUR1:LFO:FREQ:MODE?': 'CW',
              
              'SOUR:LFO2:BAND?': 'BW10',
              'SOUR:LFO2:STAT?': '0',
              'SOUR:LFO2:OFFS?': '0',
              'SOUR:LFO2:SOUR?': 'EXT1',
              'SOUR:LFO2:VOLT?': '1.0',
              
              'SOUR1:LFO:SWE:DWEL?': '0.01',
              'SOUR1:LFO:SWE:MODE?': 'AUTO',
              'SOUR1:LFO:SWE:POIN?': '50',
              'SOUR1:LFO:SWE:SHAP?': 'SAWT',
              'SOUR1:LFO:SWE:RETR?': '0',
              'SOUR1:LFO:SWE:RUNN?': '0',
              'SOUR1:LFO:SWE:SPAC?': 'LIN',
              'SOUR1:LFO:SWE:STEP:LOG?': '1.0',
              'SOUR1:LFO:SWE:STEP?': '1000.0',
              
              'SOUR1:AM1:STAT?': '0',
              'SOUR1:AM1:SOUR?': 'LF1',
              'SOUR1:AM1:DEPT?': '50.0',
              'SOUR1:AM:RAT?': '50.0', # Ratio Path2 to Path1
              'SOUR1:AM:SENS?': '50.0', # Sensitivity for EXT
              
              'SOUR1:AM2:STAT?': '0',
              'SOUR1:AM2:SOUR?': 'LF1',
              'SOUR1:AM2:DEPT?': '50.0',        
              
              'SOUR1:FM1:STAT?': '0',
              'SOUR1:FM1:DEV?': '1000.0',
              'SOUR1:FM1:SOUR?': 'LF1',
              'SOUR1:FM:RAT?': '100.0',
              'SOUR1:FM:MODE?': 'NORM',
              'SOUR1:FM:SENS?': '1000.0',
              
              'SOUR1:FM2:STAT?': '0',
              'SOUR1:FM2:DEV?': '1000.0',
              'SOUR1:FM2:SOUR?': 'EXT1',
              
              'SOUR1:PM1:STAT?': '0',
              'SOUR:PM1:DEV?': '1',
              'SOUR1:PM1:SOUR?': 'LF1',
              'SOUR1:PM:MODE?': 'HBAN',
              'SOUR1:PM:RAT?': '100',
              'SOUR1:PM:SENS?': '1',
              
              'SOUR1:PM2:STAT?': '0',
              'SOUR:PM2:DEV?': '1',
              'SOUR1:PM2:SOUR?': 'EXT1',
              'SOUR1:PM:MODE?': 'HBAN',
              
              'SOUR1:PULM:MODE?': '0',
              'SOUR1:PULM:DOUB:DEL?': '0',
              'SOUR1:PULM:DOUB:WID?': '0',
              'SOUR1:PULM:TRIG:MODE?': '0',
              'SOUR1:PULM:PER?': '2.0',
              'SOUR1:PULM:WIDT?': '0',
              'SOUR1:PULM:DEL?': '0',
              'SOUR1:PULM:STAT?': '0',
              'SOUR1:PULM:SOUR?': 'EXT',
              'SOUR1:PULM:TTYP?': 'FAST',
              'SOUR1:PULM:OUTP:VID:POL?': 'NORM',
              'SOUR1:PULM:POL?': 'NORM',
              'SOUR1:PULM:IMP?': 'G1K',
              'SOUR1:PULM:TRIG:EXT:IMP?': 'G50',
              
              'SOUR1:PGEN:OUTP:POL?': 'NORM',
              'SOUR1:PGEN:OUTP:STAT': 'OFF',
              'SOUR1:PGEN:STAT': 'OFF',
              
              'SOUR1:IQ:SOUR?': 'BAS',
              'SOUR1:IQ:STAT?': '0',
              'SOUR1:IQ:GAIN?': 'DB4',
              'SOUR1:IQ:CRES?': '0.0',
              'SOUR1:IQ:SWAP:STAT?': '0',
              'SOUR1:IQ:WBST?': '0',
              
              'SOUR1:IQ:OUTP:ANAL:STAT?': '0',
              'SOUR1:IQ:OUTP:ANAL:TYPE?': 'SING',
              'SOUR1:IQ:OUTP:ANAL:MODE?': 'FIX',
              'SOUR1:IQ:OUTP:LEV?': '1.0',
              'SOUR1:IQ:OUTP:ANAL:BIAS:COUP:STAT?': '0',
              'SOUR1:IQ:OUTP:ANAL:BIAS:I?': '0',
              'SOUR1:IQ:OUTP:ANAL:BIAS:Q?': '0',
              'SOUR1:IQ:OUTP:ANAL:OFFS:I?': '0',
              'SOUR1:IQ:OUTP:ANAL:OFFS:Q?': '0',

              'SOUR2:IQ:OUTP:ANAL:STAT?': '0',
              'SOUR2:IQ:OUTP:ANAL:TYPE?': 'SING',
              'SOUR2:IQ:OUTP:ANAL:MODE?': 'FIX',
              'SOUR2:IQ:OUTP:LEV?': '1.0',
              'SOUR2:IQ:OUTP:ANAL:BIAS:COUP:STAT?': '0',
              'SOUR2:IQ:OUTP:ANAL:BIAS:I?': '0',
              'SOUR2:IQ:OUTP:ANAL:BIAS:Q?': '0',
              'SOUR2:IQ:OUTP:ANAL:OFFS:I?': '0',
              'SOUR2:IQ:OUTP:ANAL:OFFS:Q?': '0'
              }
    
    def __init__(self):
        self.state = 0
        self.closed = False

    def clear(self):
        self.state = 0

    def close(self):
        # make it an error to ask or write after close
        self.closed = True

    def write(self, cmd):
        if self.closed:
            raise RuntimeError(""Trying to write to a closed instrument"")
        try:
            num = float(cmd.split(':')[-1])
        except:
            num = 1
        self.state = num

        if num < 0:
            raise ValueError('be more positive!')

        if num == 0:
            ret_code = pyvisa.constants.VI_ERROR_TMO
        else:
            ret_code = 0

        return len(cmd), ret_code

    def ask(self, cmd):
        if self.closed:
            raise RuntimeError(""Trying to ask a closed instrument"")
        if self.state > 10:
            raise ValueError(""I'm out of fingers"")
        return self.state

    def query(self, cmd):
        if cmd in self.cmddef:
            return self.cmddef[cmd]
        if self.state > 10:
            raise ValueError(""I'm out of fingers"")
        return self.state
"
271,https://download.tek.com/datasheet/AFG3000_Series_Arbitrary-Function_Generators_Datasheet_76W-18656-5.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attBOBaWZ7JnXO5HZ'), ('width', 600), ('height', 436), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KILymPmJoU8sfrwuHY9qjQ/SMN2or2i6epcOIrZ1r5VT3UYrCaOXiiW6mv0FWegdPVw2vlb1g6cbH3FLYNkgI4kNkh0eto7sJp-vF7BN5h4iaopABIkgSZOCq-o07u-IIk/y0HWdGYlP8aedR-l-TWdnrxbewx9ly9EmYukJ813zyM'), ('filename', '129031630.webp'), ('size', 21366), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/3S-fTm7nm20qrHte9ALxJA/vbWANYIFV6TbEDtdl-tg_szPIl9u6UpRNwCW8WLV3QjR4hVzBaqJs80ZMhxA8cvgPJUqQnOVpbJi2w_Zmh2BKgHYr-eam6XjAw_cgs4PxGs/lZ3mE4G4jeCErn2ZMbDYLmELwAmwApyu9QU3tyaQGc0'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MWDOxIgQzZvg-wP6RP7_jw/0cYbpMpDFYjRxS6YKHnb10Nmku3UqhlArWzj5rGSU9DhNU5xHTkbn7_tQBaXhPzlnKXMAiHjRKS4jFYwtGbBjT2uU-jVcKxWHBFkUT73d3I/QM0LYh5xHGQN1j9hcOWxjqA5BpHJ1SJ1TOaRtZn60yY'), ('width', 600), ('height', 436)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DC2EpklO1-NV9b4UdP8vLQ/Gzm3CEghkK5FniE6q-MgjqfB6kGewuE66QUlKHojEPYfC26fsybHeRevuO18AcSlbzMiV0Bsu4886eTfJ2_PE-62jGMs191pCjEFYUfTS3Q/Wa9jQJZWwzJ4o4S7aP_H0s2PTdgGuT6m9DTrt9GYUmY'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,"Unmatched performance, versatility, intuitive operation, and affordability make the AFG3000 Series of Function, Arbitrary Waveform, and Pulse Generators the most useful instruments in the industry.

Users can choose from 12 different standard waveforms. Arbitrary waveforms can be generated up to 128 K in length at high sampling rates. On pulse waveforms, leading and trailing edge time can be set independently. External signals can be connected and added to the output signal. Dual-channel models can generate two identical or completely different signals. All instruments feature a highly stable time base with only ±1 ppm drift per year.

A large screen shows all relevant waveform parameters and graphical wave shape at a single glance. This gives full confidence in the signal settings and lets you focus on the task at hand. Shortcut keys provide direct access to frequently used functions and parameters. Others can be selected conveniently through clearly structured menus. This reduces the time needed for learning and relearning how to use the instrument. Look and feel are identical to the world's most popular TDS3000 Oscilloscopes.",https://www.tek.com/en/datasheet/afg3000-series,AFG 3000,581.0,['Function Generators'],"a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Tektronix/AFG3000.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Tektronix_AFG3000_series.ipynb,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/t9x5w9mixNN1vX3Lcnk4ig/U_1pMs3_ygzDCnX71pbdHfcaKdp2vkRUI--wQkW2FVlaPwf5o-dR5TyQbAnNX1xDOepj5PX9bax2Q8-pfFusJg/w15ap4s4nBtHZQtX6RSEmCtmPpjoW_ZVIeB4BXdLqJI'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/XloCyiOlywNa6txqtyw0IA/h3_a4-JvRiikrMaHbp2g9HWROsI5h8KoDEDEnpaoPmcdgA_Ohfylo4N3qBnBIWxDCC7ErYMaPQ7drXE1JshFug/HndoVMRnuWm752IlWSIyQqTAs8ysFvjn6aiNeKsMxAc'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mJgOPZVY10D66DbfwNJREQ/C6trfbs3rBZ1sN_CF3zgdc97w96WU26TnFdcBioC3d7HtulvxtfJdj2DyvOGyTcUV90FSAunpKbDaHGmlM0NUg/4ljeWTMHT2fz_3FzcZnh_fxRNdP-A7nZtO9m2riHjbo'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/jNvKuDBu35rSaGiSNL7PBw/xcthBJoaHTUOXvL6-_vVwE3qPOdZn7gBdnVPJeG3PGLeDf-JrewfSx4wLjXDlweD3lKZsSTEM_mvKOCI2hhkag/0L-9ZxtzmarHg4fRdh9EVNGcSaSmDHNhD_s5594IJUg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,AFG3000,Write a Python script that uses Qcodes Community to connect to a AFG3000 Function Generators,,,True,,"from typing import Any, Tuple, Sequence, cast

import numpy as np
from qcodes import VisaInstrument
import qcodes.utils.validators as vals
from qcodes.utils.helpers import create_on_off_val_mapping



MIN_WAVEFORM_LENGTH = 2
MAX_WAVEFORM_LENGTH = 131072


class AFG3000(VisaInstrument):
    """"""Qcodes driver for Tektronix AFG3000 series arbitrary function generator.

    Not all instrument functionality is included here.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', timeout=20, **kwargs)

        self.add_parameter(
            name='trigger_mode',
            label='Trigger mode',
            get_cmd='OUTPut:TRIGger:MODE?',
            get_parser=str,
            set_cmd='OUTPut:TRIGger:MODE {}',
            vals=vals.Enum('TRIGger', 'TRIG', 'SYNC')
        )

        on_off_map = create_on_off_val_mapping(on_val=1, off_val=0)

        # Source/output parameters, 2 channels
        for src in [1, 2]:

            # Outputs
            self.add_parameter(
                name=f'impedance_output{src}',
                label=f'Output {src} impedance',
                unit='Ohm',
                get_cmd=f'OUTPut{src}:IMPedance?',
                get_parser=float,
                set_cmd=f'OUTPut{src}:IMPedance {{}}OHM',
                vals=vals.Numbers(1,10000)
            )
            self.add_parameter(
                name=f'polarity_output{src}',
                label=f'Output {src} polarity',
                get_cmd=f'OUTPut{src}:POLarity?',
                get_parser=str,
                set_cmd=f'OUTPut{src}:POLarity {{}}',
                vals=vals.Enum('NORMal', 'NORM', 'INVerted', 'INV')
            )
            self.add_parameter(
                name=f'state_output{src}',
                label=f'Output {src} state',
                get_cmd=f'OUTPut{src}:STATe?',
                set_cmd=f'OUTPut{src}:STATe {{}}',
                val_mapping=on_off_map
            )

            # Amplitude modulation
            self.add_parameter(
                name=f'am_depth{src}',
                label=f'Source {src} AM depth',
                unit='%',
                get_cmd=f'SOURce{src}:AM:DEPTh?',
                get_parser=float,
                set_cmd=f'SOURce{src}:AM:DEPTh {{}}PCT',
                vals=vals.MultiType(vals.Numbers(min_value=0, max_value=120),
                                    vals.PermissiveMultiples(divisor=0.1),
                                    combiner='AND')
            )

            # Frequency modulation
            self.add_parameter(
                name=f'fm_deviation{src}',
                label=f'Source {src} FM deviation',
                unit='Hz',
                get_cmd=f'SOURce{src}:FM:DEViation?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FM:DEViation {{}}Hz',
                vals=vals.Numbers()
            )

            # Phase modulation
            self.add_parameter(
                name=f'pm_deviation{src}',
                label=f'Source {src} PM deviation',
                unit='degrees',
                get_cmd=f'SOURce{src}:PM:DEViation?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PM:DEViation {{}}DEG',
                vals=vals.Ints(0, 180)
            )

            # Pulse-width modulation
            self.add_parameter(
                name=f'pwm_duty_deviation{src}',
                label=f'Source {src} PWM duty cycle deviation',
                unit='%',
                get_cmd=f'SOURce{src}:PWM:DEViation:DCYCle?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PWM:DEViation:DCYCle {{}}PCT',
                vals=vals.Numbers(0, 100)
            )

            # Amplitude, frequency, phase, and pulse-width modulation
            for mod_type in ['AM', 'FM', 'PM', 'PWM']:
                self.add_parameter(
                    name=f'{mod_type.lower()}_internal_freq{src}',
                    label=f'Source {src} {mod_type} interal frequency',
                    unit='Hz',
                    get_cmd=f'SOURce{src}:{mod_type}:INTernal:FREQuency?',
                    get_parser=float,
                    set_cmd=f'SOURce{src}:{mod_type}:INTernal:FREQuency {{}}Hz',
                    vals=vals.MultiType(vals.Numbers(min_value=2e-3, max_value=5e4),
                                        vals.PermissiveMultiples(divisor=1e-3),
                                        combiner='AND')
                )
                self.add_parameter(
                    name=f'{mod_type.lower()}_internal_function{src}',
                    label=f'Source {src} {mod_type} interal function',
                    get_cmd=f'SOURce{src}:{mod_type}:INTernal:FUNCtion?',
                    get_parser=str,
                    set_cmd=f'SOURce{src}:{mod_type}:INTernal:FUNCtion {{}}',
                    vals=vals.Enum(
                    'SINusoid', 'SIN',
                    'SQUare',  'SQU',
                    'TRIangle', 'TRI',
                    'RAMP',
                    'NRAMp', 'NRAM',
                    'PRNoise', 'PRN',
                    'USER', 'USER1', 'USER2', 'USER3', 'USER4',
                    'EMEMory', 'EMEM',
                    'EFILe', 'EFIL')
                )
                self.add_parameter(
                    name=f'{mod_type.lower()}_internal_efile{src}',
                    label=f'Source {src} {mod_type} interal EFile',
                    get_cmd=f'SOURce{src}:{mod_type}:INTernal:FUNCtion:EFILe?',
                    get_parser=str,
                    set_cmd=f'SOURce{src}:{mod_type}:INTernal:FUNCtion:EFILe {{}}',
                    vals=vals.Strings()
                )
                self.add_parameter(
                    name=f'{mod_type.lower()}_internal_source{src}',
                    label=f'Source {src} {mod_type} source',
                    get_cmd=f'SOURce{src}:{mod_type}:SOURce?',
                    get_parser=str,
                    set_cmd=f'SOURce{src}:{mod_type}:SOURce? {{}}',
                    vals=vals.Enum('INTernal', 'INT', 'EXTernal', 'EXT')
                )
                self.add_parameter(
                    name=f'{mod_type.lower()}_state{src}',
                    label=f'Source {src} {mod_type} interal state',
                    get_cmd=f'SOURce{src}:{mod_type}:STATe?',
                    set_cmd=f'SOURce{src}:{mod_type}:STATe {{}}',
                    val_mapping=on_off_map
                )

            # Burst mode
            self.add_parameter(
                name=f'burst_mode{src}',
                label=f'Source {src} burst mode',
                get_cmd=f'SOURce{src}:BURSt:MODE?',
                get_parser=str,
                set_cmd=f'SOURce{src}:BURSt:MODE {{}}',
                vals=vals.Enum('TRIGgered', 'TRIG', 'GATed', 'GAT')
            )
            self.add_parameter(
                name=f'burst_ncycles{src}',
                label=f'Source {src} burst N cycles',
                get_cmd=f'SOURce{src}:BURSt:NCYCles?',
                get_parser=float,
                set_cmd=f'SOURce{src}:BURSt:NCYCles {{}}',
                vals=vals.MultiType(
                    vals.Ints(min_value=1, max_value=1000000),
                    vals.Enum('INFinity', 'INF', 'MAXimum', 'MAX', 'MINimum', 'MIN'))
            )
            self.add_parameter(
                name=f'burst_state{src}',
                label=f'Source {src} burst state',
                get_cmd=f'SOURce{src}:BURSt:STATe?',
                set_cmd=f'SOURce{src}:BURSt:STATe {{}}',
                val_mapping=on_off_map
            )
            self.add_parameter(
                name=f'burst_tdelay{src}',
                label=f'Source {src} burst time delay',
                unit='s',
                get_cmd=f'SOURce{src}:BURSt:TDELay?',
                get_parser=float,
                set_cmd=f'SOURce{src}:BURSt:TDELay {{}}s',
                vals=vals.Numbers(0, 85)
            )

            if src == 1:
                combine_enum: Tuple[str, ...] = (
                    ""NOISe"",
                    ""NOIS"",
                    ""EXTernal"",
                    ""EXT"",
                    ""BOTH"",
                    """",
                )
            else:
                combine_enum = ('NOISe', 'NOIS', '')
            self.add_parameter(
                name=f'combine{src}',
                label=f'Source {src} combine signals',
                get_cmd=f'SOURce{src}:COMBine:FEED?',
                get_parser=str,
                set_cmd=f'SOURce{src}:COMBine:FEED {{}}',
                vals=vals.Enum(combine_enum)
            )

            # Frequency controls
            self.add_parameter(
                name=f'center_freq{src}',
                label=f'Source {src} center frequency',
                unit='Hz',
                get_cmd=f'SOURce{src}:FREQuency:CENTer?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FREQuency:CENTer {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'freq_concurrent{src}',
                label=f'Source {src} concurrent frequency',
                get_cmd=f'SOURce{src}:FREQuency:CONCurrent?',
                set_cmd=f'SOURce{src}:FREQuency:CONCurrent {{}}',
                val_mapping=on_off_map
            )
            self.add_parameter(
                name=f'freq_cw{src}',
                label=f'Source {src} continuous frequency',
                unit='Hz',
                get_cmd=f'SOURce{src}:FREQuency:CW?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FREQuency:CW {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'freq_mode{src}',
                label=f'Source {src} frequency mode',
                get_cmd=f'SOURce{src}:FREQuency:MODE?',
                get_parser=str,
                set_cmd=f'SOURce{src}:FREQuency:MODE {{}}',
                vals=vals.Enum('CW', 'FIXed', 'FIX', 'SWEep', 'SWE')
            )
            self.add_parameter(
                name=f'freq_span{src}',
                label=f'Source {src} frequency span',
                unit='Hz',
                get_cmd=f'SOURce{src}:FREQuency:SPAN?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FREQuency:SPAN {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'freq_start{src}',
                label=f'Source {src} frequency start',
                unit='Hz',
                get_cmd=f'SOURce{src}:FREQuency:STARt?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FREQuency:STARt {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'freq_stop{src}',
                label=f'Source {src} frequency stop',
                unit='Hz',
                get_cmd=f'SOURce{src}:FREQuency:STOP?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FREQuency:STOP {{}}Hz',
                vals=vals.Numbers()
            )

            # FSK modulation
            self.add_parameter(
                name=f'fsk_freq{src}',
                label=f'Source {src} FSK frequency',
                unit='Hz',
                get_cmd=f'SOURce{src}:FSKey:FREQuency?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FSKey:FREQuency {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'fsk_internal_rate{src}',
                label=f'Source {src} FSK internal rate',
                unit='Hz',
                get_cmd=f'SOURce{src}:FSKey:INTernal:RATE?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FSKey:INTernal:RATE {{}}Hz',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'fsk_source{src}',
                label=f'Source {src} FSK source',
                get_cmd=f'SOURce{src}:FSKey:SOURce?',
                get_parser=str,
                set_cmd=f'SOURce{src}:FSKey:SOURce {{}}',
                vals=vals.Enum('INTernal', 'INT', 'EXTernal', 'EXT')
            )
            self.add_parameter(
                name=f'fsk_state{src}',
                label=f'Source {src} FSK state',
                get_cmd=f'SOURce{src}:FSKey:STATe?',
                set_cmd=f'SOURce{src}:FSKey:STATe {{}}',
                val_mapping=on_off_map
            )

            # Function parameters
            self.add_parameter(
                name=f'function_efile{src}',
                label=f'Source {src} function efile',
                get_cmd=f'SOURce{src}:FUNCtion:EFILe?',
                get_parser=str,
                set_cmd=f'SOURce{src}:FUNCtion:EFILe {{}}',
                vals=vals.Strings()
            )
            self.add_parameter(
                name=f'function_ramp_symmetry{src}',
                label=f'Source {src} function ramp symmetry',
                unit='%',
                get_cmd=f'SOURce{src}:FUNCtion:RAMP:SYMMetry?',
                get_parser=float,
                set_cmd=f'SOURce{src}:FUNCtion:RAMP:SYMMetry {{}}PCT',
                vals=vals.Numbers(0, 100)
            )
            self.add_parameter(
                name=f'function_shape{src}',
                label=f'Source {src} function shape',
                get_cmd=f'SOURce{src}:FUNCtion:SHAPe?',
                get_parser=str,
                set_cmd=f'SOURce{src}:FUNCtion:SHAPe {{}}',
                vals=vals.Enum(
                'SINusoid', 'SIN',
                'SQUare',  'SQU',
                'TRIangle', 'TRI',
                'RAMP',
                'NRAMp', 'NRAM',
                'PRNoise', 'PRN',
                'USER', 'USER1', 'USER2', 'USER3', 'USER4',
                'EMEMory', 'EMEM',
                'EFILe', 'EFIL',
                'USER', 'USER1',
                'USER2', 'USER3', 'USER4',
                'EMEMory', 'EMEM',
                'EFILe', 'EFIL')
            )

            # Phase parameters
            self.add_parameter(
                name=f'phase{src}',
                label=f'Source {src} phase',
                unit='degrees',
                get_cmd=f'SOURce{src}:PHASe:ADJust?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PHASe:ADJust {{}}DEG',
                vals=vals.Numbers(-180, 180)
            )

            # Pulse parameters
            self.add_parameter(
                name=f'pulse_duty_cycle{src}',
                label=f'Source {src} pulse duty cycle',
                unit='%',
                get_cmd=f'SOURce{src}:PULSe:DCYCle?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:DCYCle {{}}PCT',
                vals=vals.Numbers(1e-3, 99.999)
            )
            self.add_parameter(
                name=f'pulse_delay{src}',
                label=f'Source {src} pulse delay',
                unit='s',
                get_cmd=f'SOURce{src}:PULSe:DELay?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:DELay {{}}s',
                vals=vals.Numbers(min_value=0)
            )
            self.add_parameter(
                name=f'pulse_hold{src}',
                label=f'Source {src} pulse hold',
                get_cmd=f'SOURce{src}:PULSe:HOLD?',
                get_parser=str,
                set_cmd=f'SOURce{src}:PULSe:HOLD {{}}',
                vals=vals.Enum('WIDTh', 'WIDT', 'DUTY')
            )
            self.add_parameter(
                name=f'pulse_period{src}',
                label=f'Source {src} pulse period',
                unit='s',
                get_cmd=f'SOURce{src}:PULSe:PERiod?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:PERiod {{}}s',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'pulse_trans_lead{src}',
                label=f'Source {src} pulse leading edge time',
                unit='s',
                get_cmd=f'SOURce{src}:PULSe:TRANsition:LEADing?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:TRANsition:LEADing {{}}s',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'pulse_trans_trail{src}',
                label=f'Source {src} pulse trailing edge time',
                unit='s',
                get_cmd=f'SOURce{src}:PULSe:TRANsition:TRAiling?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:TRANsition:TRAiling {{}}s',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'pulse_width{src}',
                label=f'Source {src} pulse width',
                unit='s',
                get_cmd=f'SOURce{src}:PULSe:WIDTh?',
                get_parser=float,
                set_cmd=f'SOURce{src}:PULSe:WIDTh {{}}s',
                vals=vals.Numbers()
            )

            # Sweep parameters
            self.add_parameter(
                name=f'sweep_hold_time{src}',
                label=f'Source {src} sweep hold time',
                unit='s',
                get_cmd=f'SOURce{src}:SWEep:HTIMe?',
                get_parser=float,
                set_cmd=f'SOURce{src}:SWEep:HTIMe {{}}s',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'sweep_mode{src}',
                label=f'Source {src} sweep mode',
                get_cmd=f'SOURce{src}:SWEep:MODE?',
                get_parser=str,
                set_cmd=f'SOURce{src}:SWEep:MODE {{}}',
                vals=vals.Enum('AUTO', 'MANual', 'MAN')
            )
            self.add_parameter(
                name=f'sweep_return_time{src}',
                label=f'Source {src} sweep return time',
                unit='s',
                get_cmd=f'SOURce{src}:SWEep:RTIMe?',
                get_parser=float,
                set_cmd=f'SOURce{src}:SWEep:RTIMe {{}}s',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'sweep_spacing{src}',
                label=f'Source {src} sweep spacing',
                get_cmd=f'SOURce{src}:SWEep:SPACing?',
                get_parser=str,
                set_cmd=f'SOURce{src}:SWEep:SPACing {{}}',
                vals=vals.Enum('LINear', 'LIN', 'LOGarithmic', 'LOG')
            )
            self.add_parameter(
                name=f'sweep_time{src}',
                label=f'Source {src} sweep time',
                unit='s',
                get_cmd=f'SOURce{src}:SWEep:TIME?',
                get_parser=float,
                set_cmd=f'SOURce{src}:SWEep:TIME {{}}s',
                vals=vals.Numbers(1e-3, 300)
            )

            # Voltage parameters
            self.add_parameter(
                name=f'voltage_concurrent{src}',
                label=f'Source {src} concurrent voltage',
                get_cmd=f'SOURce{src}:VOLTage:CONCurrent:STATe?',
                set_cmd=f'SOURce{src}:VOLTage:CONCurrent:STATe {{}}',
                val_mapping=on_off_map
            )
            self.add_parameter(
                name=f'voltage_high{src}',
                label=f'Source {src} high voltage level',
                unit='V',
                get_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:HIGH?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:HIGH {{}}V',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'voltage_low{src}',
                label=f'Source {src} low voltage level',
                unit='V',
                get_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:LOW?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:LOW {{}}V',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'voltage_offset{src}',
                label=f'Source {src} voltage offset',
                unit='V',
                get_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:OFFSet?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:OFFSet {{}}V',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'voltage_unit{src}',
                label=f'Source {src} voltage unit',
                get_cmd=f'SOURce{src}:VOLTage:UNIT?',
                get_parser=str,
                set_cmd=f'SOURce{src}:VOLTage:UNIT {{}}',
                vals=vals.Enum('VPP', 'VRMS', 'DBM')
            )
            self.add_parameter(
                name=f'voltage_amplitude{src}',
                label=f'Source {src} voltage amplitude',
                get_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:AMPLitude?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LEVel:IMMediate:AMPLitude {{}}V',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'voltage_limit_high{src}',
                label=f'Source {src} voltage limit high',
                unit='V',
                get_cmd=f'SOURce{src}:VOLTage:LIMit:HIGH?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LIMit:HIGH {{}}V',
                vals=vals.Numbers()
            )
            self.add_parameter(
                name=f'voltage_limit_low{src}',
                label=f'Source {src} voltage limit low',
                unit='V',
                get_cmd=f'SOURce{src}:VOLTage:LIMit:LOW?',
                get_parser=float,
                set_cmd=f'SOURce{src}:VOLTage:LIMit:LOW {{}}V',
                vals=vals.Numbers()
            )

        # Noise parameters
        for src in [3, 4]:
            self.add_parameter(
                name=f'noise_level{src}',
                label=f'Source {src} relative noise level',
                unit='%',
                get_cmd=f'SOURce{src}:POWer:LEVel:IMMediate:AMPLitude?',
                get_parser=float,
                set_cmd=f'SOURce{src}:POWer:LEVel:IMMediate:AMPLitude {{}}PCT',
                vals=vals.Numbers(0, 50),
                docstring='Noise level applied to output, as a percentage of current amplitude.'
            )

        self.add_parameter(
            name='ref_osc_source',
            label='Reference clock source',
            get_cmd='SOURce:ROSCillator:SOURce?',
            get_parser=str,
            set_cmd='SOURce:ROSCillator:SOURce {}',
            vals=vals.Enum('INTernal', 'INT', 'EXTernal', 'EXT')
        )

        # Trigger parameters
        self.add_parameter(
            name='trigger_slope',
            label='Trigger slope',
            get_cmd='TRIGger:SEQuence:SLOPe?',
            get_parser=str,
            set_cmd='TRIGger:SEQuence:SLOPe {}',
            vals=vals.Enum('POSitive', 'POS', 'NEGative', 'NEG')
        )
        self.add_parameter(
            name='trigger_source',
            label='Trigger source',
            get_cmd='TRIGger:SEQuence:SOURce?',
            get_parser=str,
            set_cmd='TRIGger:SEQuence:SOURce {}',
            vals=vals.Enum('TIMer', 'TIM', 'EXTernal', 'EXT')
        )
        self.add_parameter(
            name='trigger_timer',
            label='Trigger timer period',
            unit='s',
            get_cmd='TRIGger:SEQuence:TIMer?',
            get_parser=float,
            set_cmd='TRIGger:SEQuence:TIMer {}s',
            vals=vals.Numbers(1e-6, 500)
        )

        self.snapshot(update=True)
        self.connect_message()

    def self_calibrate(self) -> None:
        self.write('CALibration:ALL')
        self.wait()

    def self_test(self) -> None:
        self.write('DIAGnostic:ALL')
        self.wait()

    def abort(self) -> None:
        self.write('ABORt')
        self.wait()

    def reset(self) -> None:
        self.log.info(f'Resetting {self.name}.')
        self.write('*RST')
        self.wait()

    def wait(self) -> None:
        self.write('*WAI')

    def save(self, location: int) -> None:
        if location not in [0, 1, 2, 3, 4]:
            raise ValueError(f'Location must be in {[0, 1, 2, 3, 4]}.')
        self.log.info(f'Instrument settings saved to location {location}.')
        self.write(f'*SAVE {location}')

    def recall(self, location: int) -> None:
        if location not in [0, 1, 2, 3, 4]:
            raise ValueError(f'Location must be in {[0, 1, 2, 3, 4]}.')
        self.log.info(f'Recalling instrument settings from location {location}.')
        self.write(f'*RCL {location}')

    def synchronize_phase(self, src: int) -> None:
        self.log.info('Synchronizing CH1 and CH2 phase.')
        self.write(f'SOURce{src}:PHASe:INITiate')

    def reset_edit_memory(self, points: int = 1000):
        """"""
        Reset the contents of the edit memory (EMEM), and set its size to
        `points`.

        Each point will be initialized with the value 8191, which corresponds
        to the voltage half-way between `voltage_low` and `voltage_high`.
        """"""
        if (points < MIN_WAVEFORM_LENGTH or
            points > MAX_WAVEFORM_LENGTH):
            raise ValueError(f""Trying to reset edit memory with invalid length: {points}"")

        self.write(f""DATA:DEFINE EMEM,{points}"")

    def upload_waveform(self, waveform: Sequence[float], memory: int):
        """"""
        Upload a waveform to the editable memory (EMEM), and then copy it to the
        USER1, USER2, USER3 or USER4 memory.

        The waveform data should contain values in the range 0..1. Note that
        the actual voltage values that are output will depend on the values of
        the `voltage_low1/2` and `voltage_high1/2` parameters; 0 will be
        mapped to `voltage_low` and 1 to `voltage_high`.

        Args:
            waveform: sequence of points containing the waveform data,
                containing values from 0 to 1.
            memory: The USER# memory where to to store the waveform, from 1 to 4.
        """"""
        if (len(waveform) < MIN_WAVEFORM_LENGTH or
            len(waveform) > MAX_WAVEFORM_LENGTH):
            raise ValueError(f""Invalid waveform length: {len(waveform)}"")

        if memory not in [1, 2, 3, 4]:
            raise ValueError(f""Invalid value for memory: '{memory}'"")

        # convert to numpy array and raise ValueError if data contains inf or nan
        wf_array = np.asarray_chkfinite(waveform)

        if np.any(wf_array > 1.0):
            raise ValueError(""Waveform contains data above 1.0"")
        if np.any(wf_array < 0.0):
            raise ValueError(""Waveform contains data below 0.0"")

        self.reset_edit_memory(len(waveform))

        # convert waveform to two-byte integer values in the range 0..16382 (= 2**14-2)
        wf_codes = (wf_array * (2**14-2)).astype(np.uint16)

        # write data to the editable memory
        self.visa_handle.write_binary_values(
            f""DATA:DATA EMEM,"",
            cast(Sequence[float], wf_codes), # cast to make types correct
            datatype=""H"", # unsigned short (16 bits)
            is_big_endian=True, # the AFG expects data in big endian order
            header_fmt=""ieee"",
        )

        # copy data from editable memory to USER.
        self.write(f""DATA:COPY USER{memory},EMEM"")


class AFG3252(AFG3000):
    pass

"
272,https://www.thinksrs.com/downloads/pdfs/catalog/SIM928c.pdf,https://en.wikipedia.org/wiki/Voltage_source,"[OrderedDict([('id', 'attTD8m3kQGLIOYHV'), ('width', 1004), ('height', 1556), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YyelvSr2b6V-ZRIRfKU6Yw/Td5G17ercf04M2ishOZhUlQZzcmm8aM64rMrTkIDWCKtFj1Fe7oinXyHFLCaYaD8LGIbIrP0UXxb6U1fBRrz2X7W3ecO49eH6gUInYhXBOI/Xr4BsaZbIYXh5e9F2rqA5dDc4bD_BW9p3Dc3lXgfxBo'), ('filename', 'SIM928 MainPic.jpg'), ('size', 1109678), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/llqJcAWYmquWGOTawvcLZA/EuR-w-n2hNtDEQyRugiMaGUBU8P1zqjida04XlYdgCOkekat4-rlupHJyNMBOaPnCEvaXu6KZybbn4MzZX_lVw/SEUY72MKh7f64nPVuaspdz_hN6XxBWjKCl4DArD7qZI'), ('width', 23), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xPpXcrIlcsDul6KQKOCZOg/pqSiG9DEhJnIaOANkFadh4veqqECWgfPrrUom37dNPHcX7BZxiKXuA6SkBMo7zC--8EZuv-Mmuj5goUPialu9A/gBxR5o7qjWp5h5Vj7U-WwPdS7UYLKCcOQOeC6Ao1I_8'), ('width', 512), ('height', 793)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gDCLHGffraFJG4oBBuKy8w/SjWGXDVSTtLMb36aqU3ZwJydGDVJEU_W4_FB-De6ERO9pfDsjkE80JVqcC8mDg9KZO14ProN_vC74OOvARpqOA/MupZnCSSaM46hI9swS41PwJy-EobOM4Bm7jOdlmt0hI'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,"The SIM928 Isolated Voltage Source is ideal for applications where ultra-clean DC voltage is required. Voltage can be set between ±20 VDC with millivolt resolution, and the source can drive up to ±10 mA. The output circuit is optically isolated from all earth-referenced charging circuitry, providing maximum flexibility and noise immunity. The system can float to ±40 V, and the output is short-circuit protected.",https://www.thinksrs.com/products/sim928.html,SIM 928,538.0,['Power Supplies'],"A voltage source is a two-terminal device which can maintain a fixed voltage.[1] An ideal voltage source can maintain the fixed voltage independent of the load resistance or the output current. However, a real-world voltage source cannot supply unlimited current.

A voltage source is the dual of a current source. Real-world sources of electrical energy, such as batteries and generators, can be modeled for analysis purposes as a combination of an ideal voltage source and additional combinations of impedance elements.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/StanfordResearchSystems/SIM928.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.StanfordResearchSystems.html#module-qcodes_contrib_drivers.drivers.StanfordResearchSystems.SIM928,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/LesBfJ6XEYNjGgVAthmPDA/Q1SasCNkGkuvMO1vO8Z8xebLwWwQeQ4E-IzWjTm9BPhI0Td0wZ8QpACpWrFZUSpYG5JDcVjoJ3MMMRIK-rNPA-yOP7OyGaM-Gxy-hN34jVklC-iyj7-zRqmO6Xk0qpHU/DPLrIKnaAmcBfcqZCKKyjo4674gdKVupf3_4Atl5458'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zG0QIhbria87hQjH4IVx4w/5NfKbdU46h7kQMsI2WzLy8lKUmWvBWshmgDJa8Z0Ypcz7LXH-UOQ30JH_aT6Buw9ZEf0rMSAQNs0T9M0tChyn6a1w5rDKT2QtKJ_FnsrjY0/fm88CzcRcKAJEZHN-v4gAhED1LqQgFP3NYmaD2ZWUiI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VjkNGqWA01UOkXvaITSQiQ/a3XsRmKqFkURdttgH3l7LAUIssbaspkHxt4qS9KfZH3EPellK-tkRCAx5HNl00dfsHe9B7WvXZkoaI4lAchsvuvr_Fq-l0eCk7ygriAxrCc/peT4eD06uEFuOumddvBb4RSmrqXoWDfpLNvJEkjSmdk'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/y45bjnKcKfXHAnMf_zQSnw/JBUGXK8QdSYtkgYeriw4Txf4GLnDb8j1uVJ1_ajFtgORBV0p6AGauQRS4N5PjPLWN0eCSWALwEfiKzJpIZB0dqLGyOMBm1e6twkWiXKCiYs/bYnjdhYN-EyAS4aVeoGPGyHzH0kqaju0Vqi8arGN7Pk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,SIM 928,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,1695.0,,,,"from functools import partial
import logging
import numpy as np
import time

from qcodes.instrument.visa import VisaInstrument
from qcodes.utils import validators as vals

log = logging.getLogger(__name__)

class SIM928(VisaInstrument):
    """"""
    A driver for Stanford Research Systems SIM 928 DC source modules installed
    in a SIM900 mainframe.

    Args:
        name (str): An identifier for this instrument, particularly for
            attaching it to a ``Station``.
        address (str): The visa resource name to use to connect.
        slot_names (Dict[int]): An dictionary that optionally maps slot numbers
            to user-defined module names. Default ``{}``.
        timeout (int, float): Seconds to allow for responses. Default ``5``.
        metadata (Optional[Dict]): Additional static metadata to add to this
            instrument's JSON snapshot.
    """"""

    def __init__(self, name, address, slot_names=None, **kw):
        super().__init__(name, address=address, terminator='\n', **kw)

        if slot_names is None:
            self.slot_names = {}
        else:
            self.slot_names = slot_names
        self.module_nr = {}
        for i in self.slot_names:
            if self.slot_names[i] in self.module_nr:
                raise ValueError('Duplicate names in slot_names')
            self.module_nr[self.slot_names[i]] = i

        self.write('*DCL')  # device clear
        self.write('FLSH')  # flush port buffers
        self.write('SRST')  # SIM reset (causes 100 ms delay)
        time.sleep(0.5)

        self.modules = self.find_modules()
        for i in self.modules:
            self.write_module(i, 'TERM LF')
            module_name = self.slot_names.get(i, i)
            self.add_parameter('IDN_{}'.format(module_name),
                               label=""IDN of module {}"".format(module_name),
                               get_cmd=partial(self.get_module_idn, i))
            self.add_parameter('volt_{}'.format(module_name), unit='V',
                               label=""Output voltage of module ""
                                     ""{}"".format(module_name),
                               vals=vals.Numbers(-20, 20),
                               get_cmd=partial(self.get_voltage, i),
                               set_cmd=partial(self._set_voltage, i))
            self.add_parameter('volt_{}_step'.format(module_name), unit='V',
                               label=""Step size when changing the voltage ""
                                     ""smoothly on module ""
                                     ""{}"".format(module_name),
                               get_cmd=None, set_cmd=None,
                               vals=vals.Numbers(0, 20), initial_value=0.005)
        self.add_parameter('smooth_timestep', unit='s',
                           label=""Delay between sending the write commands""
                                 ""when changing the voltage smoothly"",
                           get_cmd=None, set_cmd=None,
                           vals=vals.Numbers(0, 1), initial_value=0.05)

        super().connect_message()

    def get_module_idn(self, i):
        """"""
        Get the vendor, model, serial number and firmware version of a module.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module whose id is returned.

        Returns:
            A dict containing vendor, model, serial, and firmware.
        """"""
        if not isinstance(i, int):
            i = self.module_nr[i]
        idstr = self.ask_module(i, '*IDN?')
        idparts = [p.strip() for p in idstr.split(',', 3)]
        if len(idparts) < 4:
            idparts += [None] * (4 - len(idparts))
        return dict(zip(('vendor', 'model', 'serial', 'firmware'), idparts))

    def find_modules(self):
        """"""
        Query the SIM900 mainframe for which slots have a SIM928 module present.

        Returns:
             A list of slot numbers where a SIM928 module is present (starting
                 from 1)
        """"""
        CTCR = self.ask('CTCR?')
        CTCR = int(CTCR) >> 1
        modules = []
        for i in range(1, 10):
            if CTCR & 1 != 0 and self.get_module_idn(i)['model'] == 'SIM928':
                modules.append(i)
            CTCR >>= 1
        return modules

    def ask_module(self, i, cmd):
        """"""
        Write a command string to a module and return a response.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to ask from.
            cmd (str): The VISA query string.

        Returns:
            The response string from the module.
        """"""
        if not isinstance(i, int):
            i = self.module_nr[i]
        msg = 'SNDT {},""{}""'.format(i, cmd)
        self.write(msg)
        time.sleep(100e-3)
        msg = 'GETN? {},128'.format(i)
        msg = self.ask(msg)
        # first read consumes the terminator of the message from the submodule,
        # so we have a terminator from the message to us still in the input
        # buffer.
        self.visa_handle.read()

        if msg[:2] != '#3':
            raise RuntimeError('Unexpected format of answer: {}'.format(msg))
        return msg[5:]

    def write_module(self, i, cmd):
        """"""
        Write a command string to a module with NO response expected.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to write to.
            cmd (str): The VISA command string.
        """"""
        if not isinstance(i, int):
            i = self.module_nr[i]
        self.write('SNDT {},""{}""'.format(i, cmd))

    def set_voltage(self, i, voltage):
        """"""
        Set the output voltage of a module.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to set the voltage of.
            voltage (float): The value to set the voltage to.
        """"""
        if not isinstance(i, int):
            name = i
            i = self.module_nr[i]
        else:
            name = self.slot_names.get(i, i)
        self.parameters['volt_{}'.format(name)].set(voltage)

    def _set_voltage(self, i, voltage):
        """"""
        Set the output voltage of a module.

        Args:
            i (int): Slot number of the module to set the voltage of.
            voltage (float): The value to set the voltage to.
        """"""
        self.write_module(i, 'VOLT {:.3f}'.format(voltage))

    def get_voltage(self, i):
        """"""
        Get the output voltage of a module.

        Args:
           i (int, str): Slot number or module name (as in ``slot_names``)
               of the module to get the voltage of.

        Returns:
            The current voltage of module ``i`` as a ``float``.
        """"""
        if not isinstance(i, int):
            i = self.module_nr[i]
        return float(self.ask_module(i, 'VOLT?'))

    def set_smooth(self, voltagedict, equitime=False):
        """"""
        Set the voltages as specified in ``voltagedict` smoothly,
        by changing the output on each module at a rate
        ``volt_#_step/smooth_timestep``.

        Args:
            voltagedict (Dict[float]): A dictionary where keys are module slot
                numbers or names and values are the desired output voltages.
            equitime (bool): If ``True``, uses smaller step sizes for some of
                the modules so that all modules reach the desired value at the
                same time.
        """"""

        # convert voltagedict to contain module names only and validate inputs
        vdict = {}
        for i in voltagedict:
            if not isinstance(i, int):
                if self.module_nr[i] not in self.modules:
                    raise KeyError('There is no module named {}'.format(i))
                name = i
            else:
                if i not in self.modules:
                    raise KeyError('There is no module in slot {}'.format(i))
                name = self.slot_names.get(i, i)
            vdict[name] = voltagedict[i]
            self.parameters['volt_{}'.format(name)].validate(vdict[name])

        intermediate = []
        if equitime:
            maxsteps = 0
            deltav = {}
            for i in vdict:
                deltav[i] = vdict[i]-self.get('volt_{}'.format(i))
                stepsize = self.get('volt_{}_step'.format(i))
                steps = abs(int(np.ceil(deltav[i]/stepsize)))
                if steps > maxsteps:
                    maxsteps = steps
            for s in range(maxsteps):
                intermediate.append({})
                for i in vdict:
                    intermediate[-1][i] = vdict[i] - \
                                          deltav[i]*(maxsteps-s-1)/maxsteps
        else:
            done = []
            prevvals = {}
            for i in vdict:
                prevvals[i] = self.get('volt_{}'.format(i))
            while len(done) != len(vdict):
                intermediate.append({})
                for i in vdict:
                    if i in done:
                        continue
                    stepsize = self.get('volt_{}_step'.format(i))
                    deltav = vdict[i]-prevvals[i]
                    if abs(deltav) <= stepsize:
                        intermediate[-1][i] = vdict[i]
                        done.append(i)
                    elif deltav > 0:
                        intermediate[-1][i] = prevvals[i] + stepsize
                    else:
                        intermediate[-1][i] = prevvals[i] - stepsize
                    prevvals[i] = intermediate[-1][i]

        for voltages in intermediate:
            for i in voltages:
                self.set_voltage(i, voltages[i])
            time.sleep(self.smooth_timestep())

    def get_module_status(self, i):
        """"""
        Gets and clears the status bytes corresponding to the registers ESR,
        CESR and OVSR of module ``i``.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to get the status of.

        Returns:
            int, int, int: The bytes corresponding to standard event,
            communication error and overload statuses of module ``i``
        """"""
        stdevent = self.ask_module(i, '*ESR?')
        commerr = self.ask_module(i, 'CESR?')
        overload = self.ask_module(i, 'OVSR?')
        return stdevent, commerr, overload

    def reset_module(self, i):
        """"""
        Sends the SIM Reset signal to module i.

        Causes a break signal (MARK level) to be asserted for 100 milliseconds
        to module i. Upon receiving the break signal the modul will flush its
        internal input buffer, reset its command parser, and default to 9600
        baud communications.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to reset.
        """"""
        if not isinstance(i, int):
            i = self.module_nr[i]
        self.write('SRST {}'.format(i))


    def check_module_errors(self, i, raiseexc=True):
        """"""
        Check if any errors have occurred on module ``i`` and clear the status
        registers.

        Args:
            i (int, str): Slot number or module name (as in ``slot_names``)
                of the module to check the error of.
            raiseexc (bool): If true, raises an exception if any errors have
                occurred. Default ``True``.

        Returns:
            list[str]: A list of strings with the error messages that have
            occurred.
        """"""
        stdevent, commerr, overload = self.get_module_status(i)
        OPC, INP, QYE, DDE, EXE, CME, URQ, PON \
            = self.byte_to_bits(int(stdevent))
        PARITY, FRAME, NOISE, HWOVRN, OVR, RTSH, CTSH, DCAS \
            = self.byte_to_bits(int(commerr))
        Overload, Overvoltage, BatSwitch, BatFault, _, _, _, _ \
            = self.byte_to_bits(int(overload))

        errors = []
        warnings = []
        if INP:
            errors.append('Input Buffer Error.')
        if QYE:
            errors.append('Query Error.')
        if DDE:
            code = self.ask_module(i, 'LDDE?')
            errors.append('Device Dependant Error: {}.'.format(code))
        if EXE:
            code = self.ask_module(i, 'LEXE?')
            msg = {0: 'No error',
                   1: 'Illegal value',
                   2: 'Wrong token',
                   3: 'Invalid bit'}.get(int(code), 'Unknown')
            if int(code) > 3 or int(code) == 0:
                warnings.append('Execution Error: {} ({}).'.format(msg, code))
            else:
                errors.append('Execution Error: {} ({}).'.format(msg, code))
        if CME:
            code = self.ask_module(i, 'LCME?')
            msg = {0: 'No error',
                   1: 'Illegal command',
                   2: 'Undefined command',
                   3: 'Illegal query',
                   4: 'Illegal set',
                   5: 'Missing parameter(s)',
                   6: 'Extra parameter(s)',
                   7: 'Null parameter(s)',
                   8: 'Parameter buffer overflow',
                   9: 'Bad floating-point',
                   10: 'Bad integer',
                   11: 'Bad integer token',
                   12: 'Bad token value',
                   13: 'Bad hex block',
                   14: 'Unknown token'}.get(int(code), 'Unknown')
            if int(code) > 14 or int(code) == 0:
                warnings.append('Command Error: {} ({}).'.format(msg, code))
            else:
                errors.append('Command Error: {} ({}).'.format(msg, code))
        if PARITY:
            errors.append('Parity Error.')
        if FRAME:
            errors.append('Framing Error.')
        if NOISE:
            errors.append('Noise Error.')
        if HWOVRN:
            errors.append('Hardware Overrun.')
        if OVR:
            errors.append('Input Buffer Overrun.')
        if RTSH:
            errors.append('Undefined Error (RTSH).')
        if CTSH:
            errors.append('Undefined Error (CTSH).')
        if Overload:
            errors.append('Current Overload.')
        if Overvoltage:
            errors.append('Voltage Overload.')
        if BatFault:
            errors.append('Battery Fault.')

        if raiseexc:
            if len(errors) != 0:
                raise Exception(' '.join(errors + warnings))
        return errors + warnings

    @staticmethod
    def byte_to_bits(x):
        """"""
        Convert an integer to a list of bits

        Args:
            x (int): The number to convert.

        Returns:
            list[bool]: A list of the lowest 8 bits of ``x`` where ``True``
            represents 1 and ``False`` 0.
        """"""
        bits = []
        for _ in range(8):
            if x & 1 != 0:
                bits.append(True)
            else:
                bits.append(False)
            x >>= 1
        return bits
"
282,https://www.attocube.com/downloads/anc350-piezo-motion-und-readout-controller.pdf,"https://www.pi-usa.us/en/products/piezo-drivers-controllers-power-supplies-high-voltage-amplifiers#:~:text=A%20piezo%20controller%20or%20driver,or%20even%20piezo%20power%20supply.","[OrderedDict([('id', 'attMnS7OGE1ekFDIP'), ('width', 407), ('height', 124), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8nwalA0Vo2YXI-1g7In1zQ/cl0uAY2lPrcJ_kkszvQLI3G0f3Hsg7wIBkkSsrKUeS8ecsL-Sxu9lF4s6QyPJ-twy91j68v-LtDE3Nz-4CQK73BOho8zmcar5LRlkr1gG0g/lRbDkxxy1QE9dGAs72T5u-JG8VEJWt3Cbl9Pjo5lDm8'), ('filename', 'téléchargement.jpeg'), ('size', 7609), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/--Zh7KRFkd89xmMv8zyJ2g/KRXaiNjRowN2XYSeo_MPKdgHcKZhWM_FckPneiSnSrQ_xvtBGI-ufEbAKzbIcMcxyVxUA98TamOZYDIXzIasXw/-o9ZiTOQryiwikymV6ea1ro7LKD7cMGImibu_SC8TYw'), ('width', 118), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/_tHlQlghS-0oJQUGu4kiwg/Pg0weZ0IpFZIV66M6CGONO7IIHL_xfqiLwcm78ruzV4PuJUVPJK7lKvZ_eJUOVd5VzO1rE-fnDwZ4cLmzy290A/X8flwdnJWmQSzqygvrsqgGSs6qBH0pPu8nmhJCmXHoc'), ('width', 407), ('height', 124)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/lWh8Ptwc1guT0zLvxKd4KA/0UIlTPwnqBcsVYl5icC-0R2Oi565FR308XZR3C6gCcvwwW7WwMVBmLWMyOTTBXrI8nEUkNW6_v10e29HsaVP3g/mCdjNzuzhLp8iIX6Q2oNatqnAfzU_tFbmatzuiq5OgI'), ('width', 3000), ('height', 3000)]))]))])]",14.0,Germany,multi-functional piezo controller for closed loop positioners,https://www.attocube.com/downloads/anc350-piezo-motion-und-readout-controller.pdf,"ANC 350
",101.0,['Positional Controller'],A piezo controller or driver is used to control the motion of a piezo positioning device.,"**Attocube** is a leading pioneer for nanotechnology solutions in precision motion and nanopositioning applications, cryogenic microscopy,

",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Attocube/ANC350.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Attocube.html#module-qcodes_contrib_drivers.drivers.Attocube.ANC350,Attocube,"[OrderedDict([('id', 'attWQX0ELCTRZLEuX'), ('width', 363), ('height', 138), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RZXJyhGnVx_CBAWK96C5Vg/HH4L1oQDzuw4CFWkM764uX-NRIxswR9zMZMFvYs4Ktdiy-obxKwsGDByFxJbCIsB2Jz0tmU-c0SKP606_hQL8GnIbQN3kJYyAuP6sRYaJ0M/TPnJcmlYROoayhDCoI5SH4By_nJD3RL3-zD5eU7VgaU'), ('filename', 'images.png'), ('size', 4389), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/JAW5jkzk7Yn7x0mx7FkFOQ/wr1orcMh1jvKD2NmiZT7pjPq393dIR_Ntd0Bpt8ZXXT_zEd9IUGopWQe-2piazDtrLVv-Teqp7JrWd8nF6xz_g/mobq7TBD2ZSLqmD9Yjgzgh4xNK0Hh-aPCfRnRarxjNU'), ('width', 95), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/IRq5mA1PhY4edsQU-Jxr5A/oJR1cJ-wo_CkRfqpHcK1Jxy8DvF6d3HAB66cPzmQGrE01u_6ZWjCIyyxl2IpcNEeYs5msJHKcKndD-Ys3PMFPQ/aZmM1U3zQUbxBuSdR6rwrMtDFcvlTz4pg4YRKf_7mfA'), ('width', 363), ('height', 138)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Efc6LsW8Ogndme8cLJsdIw/aJ5YJxfVkeUS9f9KhgTDdPxCumZGxQ4YQ9XUwNbc2XRoCum1bBO0fxXvnsT5aUO3gnTo2X3Oe5Nq4NJCOSEbLQ/QliecBvaBXFdGEaf_XBaTv1kUWoQ6cIh8D9oEx3wOjg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.attocube.com/en,ANC 350 PIEZO Controller,Write a Python script that uses Qcodes Community to connect to a ANC 350 PIEZO Controller Positional Controller,,,,,"﻿from typing import Any, Callable, Dict, Optional, Union

import qcodes.utils.validators as vals
from qcodes.instrument.base import Instrument
from qcodes.instrument.channel import InstrumentChannel, ChannelList

from .ANC350Lib import ANC350LibActuatorType, ANC350v3Lib, ANC350v4Lib


class Anc350Axis(InstrumentChannel):
    """"""
    Representation of an axis of the ANC350

    The Attocube ANC350 has 3 axis, one for every direction.

    Args:
        parent: the Instrument that the channel is attached to
        name: the name of the axis itself
        axis: the index of the axis (0..2)

    Attributes:
        position: Get the current position on a single axis
        frequency: Set the frequency of the output signal. Depending on positioner type and usage of other axes one can
            adjust the frequency from 1Hz up to 5kHz (only on one axis at one time is a frequency above 2kHz allowed)
        amplitude: Value for the drive voltage of the piezo drive. Bychanging this value, the step size of the
            positioner can be varied. Value for the drive voltage of the piezo drive. Bychanging this value, the step
            size of the positioner can be varied.
        status:
        voltage: Sets the DC level on the voltage output when no sawtooth based motion and no feedback loop
            is active.
        target_position: Sets the target position for automatic motion (start_auto_move). For linear type actuators the
            position unit is m, for goniometers and rotators it is degree.
        target_range: Defines the range around the target position where the target is considered to be reached.
        actuator: Selects the actuator to be used for the axis from actuator presets.
        actuator_name: Get the name of the currently selected actuator
        capacitance: Performs a measurement of the capacitance of the piezo motor and returns the result. If no
            motor is connected, the result will be 0.
            The function doesn't return before the measurement is complete; this will take a few seconds of time.
    """"""

    def __init__(self, parent: ""ANC350"", name: str, axis: int):
        super().__init__(parent, name)

        self._axis = axis

        self.add_parameter(""position"",
                           label=""Position"",
                           get_cmd=self._get_position,
                           unit=""mm or m°"")

        self.add_parameter(""frequency"",
                           label=""Frequency"",
                           get_cmd=self._get_frequency,
                           set_cmd=self._set_frequency,
                           vals=vals.Ints(1, 5000),
                           unit=""Hz"")

        self.add_parameter(""amplitude"",
                           label=""Amplitude"",
                           get_cmd=self._get_amplitude,
                           set_cmd=self._set_amplitude,
                           vals=vals.Numbers(0, 70),
                           unit=""V"")

        self.add_parameter(""status"",
                           label=""Status"",
                           get_cmd=self._get_status)

        self.add_parameter(""target_position"",
                           label=""Target Position"",
                           get_cmd=None,
                           set_cmd=self._set_target_position,
                           vals=vals.Numbers(),
                           unit=""mm or m°"")

        self.add_parameter(""target_range"",
                           label=""Target Range"",
                           get_cmd=None,
                           set_cmd=self._set_target_range,
                           vals=vals.Numbers(),
                           unit=""mm or m°"")

        self.add_parameter(""actuator"",
                           label=""Actuator"",
                           get_cmd=None,
                           set_cmd=self._set_actuator,
                           vals=vals.Ints(0, 255))

        self.add_parameter(""actuator_type"",
                           label=""Actuator Type"",
                           get_cmd=self._get_actuator_type)

        self.add_parameter(""actuator_name"",
                           label=""Actuator Name"",
                           get_cmd=self._get_actuator_name)

        self.add_parameter(""capacitance"",
                           label=""Capacitance"",
                           get_cmd=self._get_capacitance,
                           unit=""nF"")

        if self._parent._version_no >= 4:
            voltage_get: Optional[Callable] = self._get_voltage
        else:
            voltage_get = None

        self.add_parameter(""voltage"",
                           label=""Voltage"",
                           get_cmd=voltage_get,
                           set_cmd=self._set_voltage,
                           vals=vals.Numbers(0, 70),
                           unit=""V"")  # Internal resolution: mV (0.001)

        self.add_parameter(""output"",
                           label=""Output"",
                           val_mapping={False: 0,
                                        True: 1,
                                        ""off"": 0,
                                        ""on"": 1,
                                        ""auto"": 2},
                           get_cmd=self._get_output,
                           set_cmd=self._set_output)

        # Set actual unit (either mm or m°) to positional parameters
        self._update_position_unit()

    # Version 3
    # ---------
    def single_step(self, backward: Optional[Union[bool, str, int]] = None) -> None:
        """"""
        Triggers a single step in desired direction.

        Args:
            backward: Step direction forward (False) or backward (True). Beside True/False, you can
                      set the direction to ""forward""/""backward"" or +1/-1 (default: forward or False)
        """"""
        backward = self._map_direction_parameter(backward)

        self._parent._lib.start_single_step(self._parent._device_handle, self._axis, backward)

    def multiple_steps(self, steps: int) -> None:
        """"""
        Performs multiple steps. The direction depends on the sign (+: forward, -: backward)

        Args:
            steps: Number of steps to move. The sign indicates the moving direction (+: forward,
                   -: backward)
        """"""
        backward = (steps < 0)
        
        for i in range(abs(steps)):
            self.single_step(backward)

    def start_continuous_move(self, backward: Optional[Union[bool, str, int]] = None) -> None:
        """"""
        Starts continuous motion in forward or backward direction.
        Other kinds of motion are stopped.

        Args:
            backward: Step direction forward (False) or backward (True). Beside True/False, you can
                      set the direction to ""forward""/""backward"" or +1/-1 (default: forward or False)
        """"""
        backward = self._map_direction_parameter(backward)

        self._parent._lib.start_continuous_move(self._parent._device_handle, self._axis, True,
                                                backward)

    def stop_continuous_move(self) -> None:
        """"""Stops continuous motion in forward or backward direction.""""""
        self._parent._lib.start_continuous_move(self._parent._device_handle, self._axis, False,
                                                False)

    _direction_mapping: Dict[Any, bool] = {
        ""forward"": False,
        ""backward"": True,
        +1: False,
        -1: True
    }

    @classmethod
    def _map_direction_parameter(cls, backward: Optional[Union[bool, str, int]]) -> bool:
        if backward is None:
            return False
        if backward in [False, True]:
            return bool(backward)

        if backward in cls._direction_mapping:
            return cls._direction_mapping[backward]

        raise ValueError(f""Unexpected value for argument `backward`. Allowed values are: ""
                         f""{[None, False, True, *cls._direction_mapping.keys()]}"")

    _relative_mapping: Dict[Any, bool] = {
        ""absolute"": True,
        ""relative"": False
    }

    def enable_auto_move(self, relative: Optional[Union[bool, str]] = None) -> None:
        """"""
        Enables automatic moving

        Args:
            relative: If the target position is to be interpreted absolute (False) or relative to
                      the current position (True).
        """"""
        relative = self._map_relative_parameter(relative)

        self._parent._lib.start_auto_move(self._parent._device_handle, self._axis, True, relative)

    def disable_auto_move(self) -> None:
        """"""Disables automatic moving""""""
        self._parent._lib.start_auto_move(self._parent._device_handle, self._axis, False, False)

    @classmethod
    def _map_relative_parameter(cls, relative: Optional[Union[bool, str]]) -> bool:
        if relative is None:
            return False
        if relative in [False, True]:
            return bool(relative)

        if relative in cls._relative_mapping:
            return cls._relative_mapping[relative]
        
        allowed_values = "", "".join(cls._relative_mapping.keys())
        raise ValueError(f""Unexpected value for argument `relative`. Allowed values are: None, ""
                         f""False, True, {allowed_values}"")

    def _get_position(self) -> float:
        """"""
        Get the current position of this axis

        Returns:
            Current position in millimeters [mm] (linear type actuators) or millidegrees [m°]
            (goniometers and rotators)
        """"""
        # Conversion from meters (degrees) to millimeters (millidegrees) because the wrapper works
        # with meters (degrees)
        return self._parent._lib.get_position(self._parent._device_handle, self._axis) * 1e3

    def _set_position(self, position: float) -> None:
        """"""(EXPERIMENTAL FUNCTION)
        The axis moves to the given position with the target range that is set before.

        Args:
            position: The position the axis moves to
        """"""
        self._set_target_position(position)
        self._set_output(2)  # 2 = ""auto""

    def _get_frequency(self) -> float:
        """"""
        Returns the frequency parameter of this axis.

        Returns:
            Frequency in Hertz [Hz], internal resolution is 1 Hz
        """"""
        return self._parent._lib.get_frequency(self._parent._device_handle, self._axis)

    def _set_frequency(self, frequency: float) -> None:
        """"""
        Sets the frequency parameter for this axis

        Args:
            frequency (float): Frequency in Hertz [Hz], internal resolution is 1 Hz
        """"""
        frequency = int(round(frequency))

        self._parent._lib.set_frequency(self._parent._device_handle, self._axis, frequency)

    def _get_amplitude(self) -> float:
        """"""
        Returns the amplitude parameter of this axis.

        Returns:
            Amplitude in Volts [V]
        """"""
        return self._parent._lib.get_amplitude(self._parent._device_handle, self._axis)

    def _set_amplitude(self, amplitude: float) -> None:
        """"""
        Sets the amplitude parameter for an axis

        Args:
            amplitude: Amplitude in Volts [V] (internal resolution is 1mV)
        """"""
        self._parent._lib.set_amplitude(self._parent._device_handle, self._axis, amplitude)

    def _get_status(self) -> Dict[str, bool]:
        """"""
        Reads status information about an axis

        Returns:
            A Dictionary containing the information about an axis:
                connected: True, if the axis is connected to a sensor.
                enabled: True, if the axis voltage output is enabled.
                moving: True, if the axis is moving.
                target: True, if the target is reached in automatic positioning.
                eot_fwd: True, if end of travel detected in forward direction.
                eot_bwd: True, if end of travel detected in backward direction.
                error: True, if the axis' sensor is in error state.
        """"""
        keys = (""connected"", ""enabled"", ""moving"", ""target"", ""eot_fwd"", ""eot_bwf"", ""error"")
        status = self._parent._lib.get_axis_status(self._parent._device_handle, self._axis)

        return dict(zip(keys, status))

    def _set_voltage(self, voltage: float) -> None:
        """"""
        Sets the DC level on the voltage output when no sawtooth based motion and no feedback loop
        is active.

        Args:
            voltage: DC output voltage in Volts [V], internal resolution is 1 mV
        """"""
        self._parent._lib.set_dc_voltage(self._parent._device_handle, self._axis, voltage)

    def _set_target_position(self, target: float) -> None:
        """"""
        Sets the target position for automatic motion.
        For linear type actuators the position unit is mm, for goniometers and rotators it is m°.

        Args:
            target: Target position in millimeters [mm] or millidegrees [m°]. Internal resolution is
                    1 nm or 1 µ°.
        """"""
        # Conversion from meters (degrees) to millimeters (millidegrees) because the wrapper works
        # with meters (degrees)
        self._parent._lib.set_target_position(self._parent._device_handle, self._axis,
                                              target * 1e-3)

    def _set_target_range(self, target_range: float) -> None:
        """"""
        Sets the range around the target position where the target is considered to be reached.
        For linear type actuators the position unit is mm, for goniometers and rotators it is m°.

        Args:
             target_range: Target range in millimeters [mm] or millidegrees [m°]. Internal
                           resolution is 1 nm or 1 µ°.
        """"""
        # Conversion from meters (degrees) to millimeters (millidegrees) because the wrapper works
        # with meters (degrees)
        self._parent._lib.set_target_range(self._parent._device_handle, self._axis,
                                           target_range * 1e-3)

    def _set_actuator(self, actuator: int) -> None:
        """"""
        Selects the actuator to be used for the axis from actuator presets. And changes the unit of the position
        parameters if necessary.

        Args:
            actuator: Actuator selection (0..255)
        """"""
        old_actuator_type = self._get_actuator_type()
        self._parent._lib.select_actuator(self._parent._device_handle, self._axis, actuator)

        self._update_position_unit(old_actuator_type)

    def _update_position_unit(self, old_actuator_type: Optional[ANC350LibActuatorType] = None) \
            -> None:
        """"""Checks the current actuator type and sets the corresponding unit for position-parameters.

        Args:
            old_actuator_type: Actuator type before changing it. This parameter is used to determine,
                               if the actuator type has changed. If not, there is no need to update
                               the unit. This parameter is optional. If it is None, the unit is
                               always updated.
        """"""
        actuator_type = self._get_actuator_type()

        if actuator_type != old_actuator_type:
            if actuator_type == ANC350LibActuatorType.Linear:
                unit = ""mm""
            else:
                unit = ""m°""

            self.position.unit = unit
            self.target_position.unit = unit
            self.target_range.unit = unit

    def _get_actuator_type(self) -> ANC350LibActuatorType:
        """"""
        Get the type of the currently selected actuator

        Returns:
            Type of the actuator
        """"""
        return self._parent._lib.get_actuator_type(self._parent._device_handle, self._axis)

    def _get_actuator_name(self) -> str:
        """"""
        Returns the name of the currently selected actuator

        Returns:
            Name of the actuator
        """"""
        return self._parent._lib.get_actuator_name(self._parent._device_handle, self._axis)

    def _get_capacitance(self) -> float:
        """"""
        Returns the motor capacitance
        Performs a measurement of the capacitance of the piezo motor and returns the result. If no
        motor is connected, the result will be 0.
        The function doesn't return before the measurement is complete; this will take a few seconds
        of time.

        Returns:
            Capacitance in Farad [nF]
        """"""
        # 1e9 as factor for the conversion from F to nF
        return self._parent._lib.measure_capacitance(self._parent._device_handle, self._axis) * 1e9

    def _set_output(self, enable: int) -> None:
        """"""
        Enables or disables the voltage output of this axis.

        Args:
            enable: Enable/disable voltage output:
                    - 0: disable
                    - 1: enable
                    - 2: enable until end of travel is detected
        """"""
        auto_off = False

        if enable == 0:
            enable = False
        elif enable == 1 or enable == 2:
            if enable == 2:  # enable, but automatically disable when end of travel is detected
                auto_off = True
            enable = True
        else:
            raise ValueError(""enable"")

        self._parent._lib.set_axis_output(self._parent._device_handle, self._axis, enable, auto_off)

    def _get_output(self) -> int:
        """"""Reads the voltage output status.

        Returns:
            1, if the axis voltage output is enabled. 0, if it is disabled.
        """"""
        return 1 if self._get_status()[""enabled""] else 0

    # Version 4
    # ---------
    def _get_voltage(self) -> float:
        """"""
        Reads back the current DC level (only supported by library with version 4)

        Returns:
            DC output voltage in Volts [V]
        """"""
        return self._parent._lib.get_dc_voltage(self._parent._device_handle, self._axis)


class ANC350(Instrument):
    """"""
    Qcodes driver for the ANC350

    Args:
        name: the name of the instrument itself
        library: library that fits to the version of the device and provides the appropriate dll
                 wrappers
        inst_no: Sequence number of the device to connect to (default: 0, the first device found)
    """"""

    def __init__(self, name: str, library: ANC350v3Lib, inst_no: int = 0):
        super().__init__(name)

        if isinstance(library, ANC350v4Lib):
            self._version_no = 4
        elif isinstance(library, ANC350v3Lib):
            self._version_no = 3
        else:
            raise NotImplementedError(""Only version 3 and 4 of ANC350's driver-DLL are currently ""
                                      ""supported"")

        self._lib = library
        self._device_no = inst_no
        self._device_handle = self._lib.connect(inst_no)

        axischannels = ChannelList(self, ""Anc350Axis"", Anc350Axis)
        for nr, axis in enumerate(['x', 'y', 'z']):
            axis_name = f""{axis}_axis""
            axischannel = Anc350Axis(parent=self, name=axis_name, axis=nr)
            axischannels.append(axischannel)
            self.add_submodule(axis_name, axischannel)
        axischannels.lock()
        self.add_submodule(""axis_channels"", axischannels)

    def close(self) -> None:
        """"""
        Closes the connection to the device. The device handle becomes invalid.
        """"""
        self._lib.disconnect(self._device_handle)
        super().close()

    def save_params(self) -> None:
        """"""
        Saves parameters to persistent flash memory in the device. They will be present as defaults
        after the next power-on.
        """"""
        self._lib.save_params(self._device_handle)

    def get_idn(self) -> Dict[str, Optional[str]]:
        """"""
        Returns a dictionary with information about the device

        Returns:
            A dictionary containing vendor, model, serial number and firmware version
        """"""
        serial = self._lib.get_device_info(self._device_no)[2]

        return {""vendor"": ""Attocube"", ""model"": ""ANC350"",
                ""serial"": serial, ""firmware"": str(self._version_no)}
"
300,https://www.attocube.com/downloads/anc300.pdf,"https://www.pi-usa.us/en/products/piezo-drivers-controllers-power-supplies-high-voltage-amplifiers#:~:text=A%20piezo%20controller%20or%20driver,or%20even%20piezo%20power%20supply.","[OrderedDict([('id', 'attgPaevs1VijaVeP'), ('width', 840), ('height', 550), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PIKapv9ATjTZ6yqn7vT6aw/qNU3EUFYMkWgax-eZs_0HMz5k8wBaMiXmj0nFOHqSDTJidyxuhqsg-vfLnrDwj45SJxKi5NYp8jtf5PluwZYpHGEEHAPY19SgsLPcs2puuI/ZVU-ZLSwRctmPb7cLBXhQGmHTq-qtxDXmZaGAEDR48Y'), ('filename', 'ANC300.jpg'), ('size', 196981), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mrlZi4At253x5YSO0Yz6pg/4cZR65std0XP2asHiE6otRuNlYAJDlmJRxbLy6uTBdMKnYk0RXuKuusOQGQH_rAd26wPnWteDH1U7w-qB5OuTA/Gj-jyX69gZfnxaiztqgRienfKhFcQANHZKvhdn588P0'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5m1KQsumWc70oLiAzC53SQ/qkKlbv9LW_n4YbJhYrbBA-XjqHGj1KngrzcYGfqu-RkUDobZqJHBfgw5421Lj_Rtxdu0Dw5Z9T5YcXnWqA6ZNA/h2OLNddLk9dZEwLcth2mVlBVjod3kalL6IfJgI7i-kQ'), ('width', 782), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mZqsvxJAFEj9QTdXcPe2Ng/m7VkGlZdd5O1wQICKFcA0XLL6nSLP-unotSsp1rOEvVQcclQccF_TS6C3DGzn1G1MTKoDUOSaAQcVzUz1AiEJg/d0v2kLCPJupTsggkdFiDjq0GYKRc7CPeEByS4E7GZC0'), ('width', 3000), ('height', 3000)]))]))])]",14.0,Germany,The ANC300 is a modular positioner control unit providing suitable drive signals to actuate attocube's open loop positioners or scanners manually or under computer control.,https://www.attocube.com/en/products/nanopositioners/motion-controllers-overview/anc300,"ANC 300 
",94.0,['Positional Controller'],A piezo controller or driver is used to control the motion of a piezo positioning device.,"**Attocube** is a leading pioneer for nanotechnology solutions in precision motion and nanopositioning applications, cryogenic microscopy,

",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Attocube/ANC300.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Attocube.html#module-qcodes_contrib_drivers.drivers.Attocube.ANC300,Attocube,"[OrderedDict([('id', 'attWQX0ELCTRZLEuX'), ('width', 363), ('height', 138), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RZXJyhGnVx_CBAWK96C5Vg/HH4L1oQDzuw4CFWkM764uX-NRIxswR9zMZMFvYs4Ktdiy-obxKwsGDByFxJbCIsB2Jz0tmU-c0SKP606_hQL8GnIbQN3kJYyAuP6sRYaJ0M/TPnJcmlYROoayhDCoI5SH4By_nJD3RL3-zD5eU7VgaU'), ('filename', 'images.png'), ('size', 4389), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/JAW5jkzk7Yn7x0mx7FkFOQ/wr1orcMh1jvKD2NmiZT7pjPq393dIR_Ntd0Bpt8ZXXT_zEd9IUGopWQe-2piazDtrLVv-Teqp7JrWd8nF6xz_g/mobq7TBD2ZSLqmD9Yjgzgh4xNK0Hh-aPCfRnRarxjNU'), ('width', 95), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/IRq5mA1PhY4edsQU-Jxr5A/oJR1cJ-wo_CkRfqpHcK1Jxy8DvF6d3HAB66cPzmQGrE01u_6ZWjCIyyxl2IpcNEeYs5msJHKcKndD-Ys3PMFPQ/aZmM1U3zQUbxBuSdR6rwrMtDFcvlTz4pg4YRKf_7mfA'), ('width', 363), ('height', 138)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Efc6LsW8Ogndme8cLJsdIw/aJ5YJxfVkeUS9f9KhgTDdPxCumZGxQ4YQ9XUwNbc2XRoCum1bBO0fxXvnsT5aUO3gnTo2X3Oe5Nq4NJCOSEbLQ/QliecBvaBXFdGEaf_XBaTv1kUWoQ6cIh8D9oEx3wOjg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.attocube.com/en,ANC300,Write a Python script that uses Qcodes Community to connect to a ANC300 Positional Controller,,,True,,"# -*- coding: utf-8 -*-
""""""QCoDeS- Driver for the Attocube ANC300 controller.

This driver can be used with a simulation class (ANC300sim.py) to generate
reasonable answers to all requests. The only thing is to change two times
the comments as shown below (real mode/simulation mode).

Attention - the device has not feedback from the motor. That means, the current position is
not known. The driver can send a move command and the controller behaves like there is a motor
connected to it, even if there is no motor available.

Author:
    Michael Wagener, FZJ / ZEA-2, m.wagener@fz-juelich.de
""""""

import time
import logging
import pyvisa

# real mode:
from qcodes.instrument import VisaInstrument
# simulation mode:
#from qcodes_contrib_drivers.drivers.Attocube.ANC300sim import MockVisa

## do not forget to change the main class accordingly:
## real  -> class ANC300(VisaInstrument):
## simul -> class ANC300(MockVisa):

from qcodes.instrument import InstrumentChannel, ChannelList
from qcodes import validators as vals


log = logging.getLogger(__name__)



class Anc300Axis(InstrumentChannel):

    def __init__(self, parent: 'ANC300', name: str, axis: int, sn: str) -> None:
        """"""Creates a new Anc300Axis class instance.

        The Attocube ANC300 piezo controller has up to 7 axis. Each of them are controlled
        by the same class.

        Args:
            parent: the internal QCoDeS name of the instrument this axis belongs to
            name: the internal QCoDeS name of the axis itself
            axis: the Index of the axis (1..7)
            sn: serial number of the axis controller to change some features

        Attributes:
            frequency: Set the frequency of the output signal. The maximum is restricted by the
                combination of output voltage and Capacitance of the piezo actuators.
            amplitude: Set the maximum level of the output signal.
            voltage: (Readonly) Reads the current stepping voltage.
            offset: Add a constant voltage to the output signal. Attention: the output level is
                only from 0 to 150 V.
            filter: Set the filter frequency of the internal low pass filter.
                For the ANM150 this attribute is not present.
                For the ANM200 and ANM300 this attribute has different allowed values.
            mode: Setting to a certain mode typically switches other functionalities off.
                'gnd': Setting to this mode diables all outputs and connects them to chassis mass.
                'inp': (Not for ANM150) In this mode, AC-IN and DC-IN can be enabled using the
                specific attributes. Setting to inp mode disables stepping and offset modes.
                'cap': Setting to cap mode starts a capacitance measurement. The axis returns to
                gnd mode afterwards. It is not needed to switch to gnd mode before.
                'stp': This enables stepping mode. AC-IN and DC-IN functionalities are not modified,
                while an offset function would be turned off.
                'off': This enables offset mode. AC-IN and DC-IN functionalities are not modified,
                while any stepping would be turned off.
                'stp+': This enables additive offset + stepping mode. Stepping waveforms are added
                to an offset. AC-IN and DC-IN functionalities are not modified.
                'stp-': This enables subtractive offset + stepping mode. Stepping waveforms are
                subtracted from an offset. AC-IN and DC-IN functionalities, are not modified.
            ac: When switching on the AC-IN feature, a voltage of up to 10 VAC can be added to the
                output (gain 1, no amplification) using the AC-IN BNC on the frontplate of the module.
            dc: When switching on the DC-IN feature, a voltage in the range -10 .. +10 V can be
                added to the output. The gain is 15.
            move: Start the movement with the given steps. For moving out use positive numbers and
                to move in use negative numbers.
            start: Start a continous movement in the given direction.
            triggerUp: Set/get input trigger up number on axis
            triggerDown: Set/get input trigger down number on axis
        """"""
        super().__init__(parent, name)
        self._axisnr = axis
        if sn != 'ANM200':
            self.add_parameter('frequency',
                               label='Set/get the stepping frequency',
                               get_cmd='getf {}'.format(axis),
                               set_cmd='setf {}'.format(axis)+' {}',
                               vals=vals.Ints(1, 10000),
                               get_parser=int,
                               unit='Hz',
                               docstring=""""""
                               Set the frequency of the output signal. The maximum is restricted by
                               the combination of output voltage and Capacitance of the piezo actuators.
                               """"""
                               )
        self.add_parameter('amplitude',
                           label='Set/get the stepping amplitude',
                           get_cmd='getv {}'.format(axis),
                           set_cmd='setv {}'.format(axis)+' {}',
                           vals=vals.Numbers(0.0, 150.0),
                           get_parser=float,
                           unit='V',
                           docstring=""Set the maximum level of the output signal.""
                           )
        self.add_parameter('voltage',
                           label='Set/get the stepping voltage',
                           get_cmd='geto {}'.format(axis),
                           set_cmd=False,
                           get_parser=float,
                           unit='V',
                           docstring=""Reads the current stepping voltage.""
                           )
        self.add_parameter('offset',
                           label='Set/get the offset voltage',
                           get_cmd='geta {}'.format(axis),
                           set_cmd='seta {}'.format(axis)+' {}',
                           vals=vals.Numbers(0.0, 150.0),
                           get_parser=float,
                           unit='V',
                           docstring=""""""
                           Add a constant voltage to the output signal.
                           Attention: the output level is only from 0 to 150 V.
                           """"""
                           )
        if sn == 'ANM200':
            self.add_parameter('filter',
                               label='Set/get filter setting',
                               get_cmd='getfil {}'.format(axis),
                               set_cmd='setfil {}'.format(axis)+' {}',
                               vals=vals.Enum('1.6', '16', '160', '1600'),
                               unit='Hz',
                               docstring=""Set the filter frequency of the internal low pass filter.""
                               )
        if sn == 'ANM300':
            self.add_parameter('filter',
                               label='Set/get filter setting',
                               get_cmd='getfil {}'.format(axis),
                               set_cmd='setfil {}'.format(axis)+' {}',
                               vals=vals.Enum('off', '16', '160'),
                               unit='Hz',
                               docstring=""Set the filter frequency of the internal low pass filter.""
                               )
        if sn == 'ANM150':
            mode_vals = ['gnd', 'cap', 'stp', 'off', 'stp+', 'stp-']
        elif sn == 'ANM200':
            mode_vals = ['gnd', 'cap', 'stp', 'off', 'stp+', 'stp-', 'inp']
        else: # ANM300
            mode_vals = ['gnd', 'cap', 'stp', 'off', 'stp+', 'stp-', 'inp']
        mode_docs = """"""
                    'gnd': Setting to this mode diables all outputs and connects them to chassis mass.
                    'cap': Setting to cap mode starts a capacitance measurement. The axis returns to
                           gnd mode afterwards. It is not needed to switch to gnd mode before.
                    'stp': This enables stepping mode. AC-IN and DC-IN functionalities are not
                           modified, while an offset function would be turned off.
                    'off': This enables offset mode. AC-IN and DC-IN functionalities are not
                           modified, while any stepping would be turned off.
                    'stp+': This enables additive offset + stepping mode. Stepping waveforms are
                            added to an offset. AC-IN and DC-IN functionalities are not modified.
                    'stp-': This enables subtractive offset + stepping mode. Stepping waveforms are
                            subtracted from an offset. AC-IN and DC-IN functionalities, are not modified.
                    """"""
        if 'inp' in mode_vals:
            mode_docs += """"""
                         'inp': In this mode, AC-IN and DC-IN can be enabled using the specific
                         attributes. Setting to inp mode disables stepping and offset modes.
                         """"""
        self.add_parameter('mode',
                           label='Set/get mode',
                           get_cmd='getm {}'.format(axis),
                           set_cmd='setm {}'.format(axis)+' {}',
                           vals=vals.Enum(*mode_vals),
                           docstring=""""""
                           Setting to a certain mode typically switches other functionalities off.
                           Especially, there are the following modes:
                           """""" + mode_docs
                           )
        if sn != 'ANM150':
            self.add_parameter('ac',
                               label='Set/get status of AC-IN input',
                               get_cmd='getaci {}'.format(axis),
                               set_cmd='setaci {}'.format(axis)+' {}',
                               vals=vals.Enum('off', 'on'),
                               docstring=""""""
                               When switching on the AC-IN feature, a voltage of up to 10 VAC
                               can be added to the output (gain 1, no amplification) using
                               the AC-IN BNC on the frontplate of the module.
                               """"""
                               )
            self.add_parameter('dc',
                               label='Set/get status of DC-IN input',
                               get_cmd='getdci {}'.format(axis),
                               set_cmd='setdci {}'.format(axis)+' {}',
                               vals=vals.Enum('off', 'on'),
                               docstring=""""""
                               When switching on the DC-IN feature, a voltage in the range
                               -10 .. +10 V can be added to the output. The gain is 15.
                               """"""
                               )
        self.add_parameter('move',
                           label='Move steps',
                           get_cmd=False,
                           set_cmd=self._domove,
                           vals=vals.Ints(),
                           docstring=""""""
                           Start the movement with the given steps. For moving out
                           use positive numbers and to move in use negative numbers.
                           """"""
                           )
        self.add_parameter('start',
                           label='Move continously',
                           get_cmd=False,
                           set_cmd=self._contmove,
                           vals=vals.Enum('up', 'down'),
                           docstring=""Start a continous movement in the given direction.""
                           )
        self.add_parameter('triggerUp',
                           label='Set/get input trigger up number on axis',
                           get_cmd='gettu {}'.format(axis),
                           set_cmd='settu {}'.format(axis)+' {}',
                           vals=vals.Enum('off', '1', '2', '3', '4', '5', '6', '7'),
                           docstring=""Set/get input trigger up number on axis""
                           )
        self.add_parameter('triggerDown',
                           label='Set/get input trigger down numbers on axis',
                           get_cmd='gettd {}'.format(axis),
                           set_cmd='settd {}'.format(axis)+' {}',
                           vals=vals.Enum('off', '1', '2', '3', '4', '5', '6', '7'),
                           docstring=""Set/get input trigger down number on axis""
                           )


    def _domove(self, value: int):
        """"""
        Internal helper function to start the movement. This will not wait until the move is
        finished. So multiple axis can be started one after the other.

        Args:
            value: the amount of steps to move, the sign denotes the direction

        Returns:
            None

        Raises:
            ValueError: if the value is zero
        """"""
        if value < 0:
            self._parent.write('stepd {} {}'.format(self._axisnr, -value))
        elif value > 0:
            self._parent.write('stepu {} {}'.format(self._axisnr, value))
        else:
            raise ValueError(""zero is an invalid move parameter"")


    def _contmove(self, direc: str):
        """"""
        Internal helper function to start the continous movement. This will not wait until the move
        is finished. So multiple axis can be started one after the other.

        Args:
            direc: the direction 'up' or 'down'

        Returns:
            None

        Raises:
            ValueError: if the given direction is invalid
        """"""
        if direc == 'up':
            self._parent.write('stepu {} c'.format(self._axisnr))
        elif direc == 'down':
            self._parent.write('stepd {} c'.format(self._axisnr))
        else:
            raise ValueError(""no 'up' or 'donw' given"")


    def waitMove(self, wait=1.0, timeout=0):
        """"""Global function to wait until the movement is finished.

        The commandinterface has the function 'stepw n' to wait until the axis stops moving. The
        controller sends the 'OK' after the axis stops, so the communication is hanging. In the
        former version with the pyserial interface, it will work fine. But the visa library
        throws an error if the communication timed out. After this, the read function didn't
        get the needed 'OK'. To avoid this, this routine asks the current output voltage. This
        voltage will be zero if the axis has stopped.

        Args:
            wait: time to wait between the checks
            timeout: number of seconds to generate a RuntimeError if not finished moving

        Returns:
            None. This function will block, until the motion of this axis has been stopped.
        """"""
        start = time.time()
        while True:
            volt = self._parent.ask('geto {}'.format(self._axisnr))
            if float(volt) == 0.0:
                return
            time.sleep(wait)
            if timeout > 0:
                if time.time() - start >= timeout:
                    raise RuntimeError('waitMove timed out')


    def stopMove(self):
        """"""
        Global function to stop the movement.
        """"""
        self._parent.write('stop {}'.format(self._axisnr))



class Anc300TriggerOut(InstrumentChannel):

    def __init__(self, parent: 'ANC300', name: str, num: int) -> None:
        """"""The Attocube ANC300 piezo controller has three trigger outputs.

        This function cannot be tested because this function belongs to a specific controller
        feature code. This code was not available during the tests.

        Args:
            parent: the internal QCoDeS name of the instrument this output belongs to
            name: the internal QCoDeS name of the output itself
            num: the Index of the trigger output

        Attributes:
            state: Set / get the state of the output
        """"""
        super().__init__(parent, name)
        self.add_parameter('state',
                           label='Set/get trigger output level',
                           get_cmd='getto {}'.format(num),
                           set_cmd='setto {}'.format(num)+' {}',
                           val_mapping={'off': 0, 'on': 1},
                           vals=vals.Enum('off', 'on'),
                           docstring=""Sets the trigger output signal""
                           )



class ANC300(VisaInstrument):
#class ANC300(MockVisa):
    """"""
    This is the qcodes driver for the Attocube ANC300.

    Be careful to correct the parameters if not useing the USB port.

    Status:
        coding: finished
        communication tests: done
        usage in experiment: not yet
    """"""

    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, 5, '\r\n', **kwargs)

        # configure the port
        if 'ASRL' not in address:
            self.visa_handle.baud_rate = 38400 # USB has no baud rate parameter
        self.visa_handle.stop_bits = pyvisa.constants.StopBits.one
        self.visa_handle.parity = pyvisa.constants.Parity.none
        self.visa_handle.read_termination = '\r\n'
        self.parameters.pop('IDN') # Get rid of this parameter

        # for security check the ID from the device
        self.idn = self.ask(""ver"")
        log.debug(""Main version:"", self.idn)
        if not self.idn.startswith(""attocube ANC300""):
            raise RuntimeError(""Invalid device ID found: ""+str(self.idn))

        # Now request all serial numbers of the axis modules. The first 6 chars are the id
        # of the module type. This will be used to enable special parameters.
        # Instantiate the axis channels only for available axis
        axischannels = ChannelList(self, ""Anc300Channels"", Anc300Axis,
                                   snapshotable=False)
        for ax in range(1, 7+1):
            try:
                tmp = self.ask('getser {}'.format(ax))
                name = 'axis{}'.format(ax)
                axischan = Anc300Axis(self, name, ax, tmp[:6])
                axischannels.append(axischan)
                self.add_submodule(name, axischan)
            except:
                pass
        axischannels.lock()
        self.add_submodule('axis_channels', axischannels)

        # instantiate the trigger channels even if they could not be tested
        triggerchannels = ChannelList(self, ""Anc300Trigger"", Anc300TriggerOut,
                                      snapshotable=False)
        for ax in [1, 2, 3]:
            name = 'trigger{}'.format(ax)
            trigchan = Anc300TriggerOut(self, name, ax)
            triggerchannels.append(trigchan)
            self.add_submodule(name, trigchan)
        triggerchannels.lock()
        self.add_submodule('trigger_channels', triggerchannels)


    def write_raw(self, cmd: str) -> None:
        """"""Write cmd and wait until the 'OK' or 'ERROR' comes back from the device.

        Args:
            cmd: Command to write to controller.

        Returns:
            None

        Raises:
            RuntimeError: if Error-Message from the device is read.
        """"""
        status = super().ask_raw(cmd) # send the command to the device and read the echo/status
        if status == cmd:
            # now the device sends an echo
            status = self.visa_handle.read() # read the status line again
        if status.startswith('OK'):
            return
        if status.startswith('ERROR'):
            raise RuntimeError(status)
        # the line before the 'ERROR' a message will be send from the device
        response = status
        status = self.visa_handle.read() # read the last status line
        if status.startswith('ERROR'):
            raise RuntimeError(response)
        return


    def ask_raw(self, cmd: str) -> str:
        """"""Query instrument with cmd and return response.

        Args:
            cmd: Command to write to controller.

        Returns:
            Response of Attocube controller to the query.

        Raises:
            RuntimeError: if Error-Message from the device is read.
        """"""
        response = super().ask_raw(cmd) # send the command to the device and read the echo/status
        if response.startswith('> '): # sometimes the response starts with '> '. I don't know why.
            response = response[2:]
        if response == cmd:
            # now the device has send an echo
            response = self.visa_handle.read() # read the response line again
            if response.startswith('> '):
                response = response[2:]
        status = self.visa_handle.read() # read the status line
        if status.startswith('OK'):
            if '=' in response:
                # ""frequency = 220 Hz"" -> filter the 220
                tmp = response.split('=')
                return tmp[1].split()[0] # a single value
            return response # the complete string
        if status.startswith('ERROR'):
            raise RuntimeError(response)
        # the 'ver' command answers with two lines...
        response = response + "" - "" + status
        status = self.visa_handle.read() # read the second status line
        if status.startswith('ERROR'):
            raise RuntimeError(response)
        return response


    def stopall(self):
        """"""
        Routine to stop all axis, regardless if the axis is available
        """"""
        self.log.debug(""Stop all axis."")
        for a in range(7):
            self.write('stop {}'.format(a+1))


    def close(self):
        """"""
        Override of the base class' close function
        """"""
        self.log.debug(""Close the device."")
        super().close()


    def version(self):
        """"""
        Read all possible version informations.

        Args:
            None

        Returns:
            Dict with all version informations
        """"""
        retval = dict()
        retval['Version'] = self.ask('ver')
        retval['ContrSN'] = self.ask('getcser')
        for i in range(7):
            try:
                retval['SN{}'.format(i+1)] = self.ask('getser {}'.format(i+1))
            except:
                # if the axis module is not installed ...
                retval['SN{}'.format(i+1)] = 'EMPTY'
        return retval


    def getall(self, submod=""*""):
        """"""
        Read all parameters and retun them to the caller. This will scan all
        submodules with all parameters, so in this function no changes are
        necessary for new modules or parameters.

        Args:
            submod: (optional) returns only the parameters for this submodule

        Returns:
            dict with all parameters, the key is the modulename and the parametername
        """"""
        retval = dict()
        if submod == ""*"":
            # ID and options only if all modules are returned
            retval.update(self.version())

        for m in self.submodules:
            mod = self.submodules[m]
            if not isinstance(mod, ChannelList) and (submod in (""*"", m)):
                for p in mod.parameters:
                    par = mod.parameters[p]
                    try:
                        if par.unit:
                            val = str(par()).strip() + "" "" + par.unit
                        else:
                            val = str(par()).strip()
                    except:
                        val = ""** not readable **""
                    retval.update({m + ""."" + p: val})

        return retval
"
301,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'att5AGenWWmWko8L9'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/IroNwsfGEQpwoBoYJCKrRg/BpzC1Fb60fKhdqS2z_TwTrgUEYnEx5qD-WPymR3HxJiYv9-nrKzWptaSkxq-BY_PFOhGRl952RnQf0YnbFCG_euLdDdJHg4NvOESXgDLtgg7OajXE13eWUJyCEU22KzS/tplP9nc4kN1TPrjXmHqUsKwen9o9JbDOxmTMifwKNRk'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qdtxxV90Skuioc3I7rw92g/pT7uvkBUjvrVOW73RcTRyrTJSMTBdlm4nPh7FWu8JgSnKaJJ86iHrXdPQqa2lelerj6GeTUa7llTta1fGwmNlw/u2KBkcm3H5Kji5BL0rW1TwTSGElIpzynuhms0ELCI4I'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/dAz6G8ODGUQl82lBxWuKJw/pazdC4t4Kfhd51JeYhL-pT62MkL2uTlLIi6_Zr4vEJYC9TB7xShJUQKVm35bxw9YZgkTNE7opumcVTwKVRPkOw/NF0HFnvPBXzYjyzS2Np0QcrznKVDMFaNDXbikbBZ64w'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Yms9Y3lVgqXjc1cpMEHS9Q/XZQn0iMB4PXhcINMJ2EPceA_lNaOQr5YqCrXAscTU4LYLYMNQQ10gfV8dTON_aIfRrYJEyOrrKCp-Y4WyUUtmQ/TbCuG7WWzI8ZCr5VIkiRI_fhUqvyc5ezocnG1-cZ-V4'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-1 Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 63 dB and a step size of 1.0 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-302p-1-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-1,Write a Python script that uses Qcodes Community to connect to a LDA-302P-1 ,575.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
310,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attAXR8c8ki57a3nQ'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/fNKOGo3rNtuaDJXhKDrRCg/QT8PP7mBZkVCHei3Vhtw_BzkCUzdf0DwqgqV4SJ9ZYP0cps70vcxEnvCR6Axq433idpbXB897BnfR4mF8zDd8x--dDMnnzGzsyj66HB3MYdDCroVPhNR8NeOqsJUzRS0/-4t2VVRfcRVvxbFVYk2YKYysquo27ml75jJJxVLZi_Y'), ('filename', 'vaunix-digital-attenuator-102.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PCvmt_rJHdeCSvD54j0tQw/WCNwcuWOvj9TfU_yUY8SrQ2_ePQKWG9kfpnZ9Qspu1cY08Uc6Lsubpzi_7X4evFHv0Np0BNaOhbs_wmS8LauEw/vckUDrXlfOgyG1Seh5d5v6OJBnfyZRsXXQED1DLpODE'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/6dDhPwHovo8D2HwtIP84Jg/EP0Nd8-3ws_Sc2S8u6REAB1_YSnC1FWYv9ReDOtAEKs2y9afMRXqqFiaSneIYHnrFbNuvbfQ_YZNgcsMp_Fyfw/d0brUO5beK7v9EEfd4ANj3uxTmbezFnFVUasr8fZHAU'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vi9A8bv4Rv2AxlWhRbZcKA/p1FP_8ORI2q4-to4KC0BzMPFME5VvpnG_i4RHi4om2Keb7Z3_1SHqcKLOYywTxzkVs58riYJ9YzjI6TFPh0U-Q/fCDE2yydX8EGsucrpDEljKHIU0rwN_hDSQJd8P82Jng'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-302P-H Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +33 dBm, and offers frequency coverage of 10 to 3,000 MHz. It has an attenuation range of 31.5 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-302p-h-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-302P-H,Write a Python script that uses Qcodes Community to connect to a LDA-302P-H ,575.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
318,https://www.keysight.com/us/en/assets/7018-05629/data-sheets/5992-2124.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attfXBGjHDEkyg09M'), ('width', 1351), ('height', 899), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KsfawgxYkxMsAnkN6f0-KQ/lTL0nRd0wcp9auAZx-FZrOWYhD6Duqz8OsDO2z-GtU9QAPQj5j2m5pVBFT999ir9_LqUQTxazeinAws19yOUz-liImwdWfmZPb2pAC4w7gS-v3lwBj6HwNVgM3b1Yfgb/0_42vUPrEu1LmjXXk8yjVKnsCH3mdDZTqeGnKbdMoX8'), ('filename', 'e36313a-front-1503x1000-White-min.jpeg'), ('size', 366543), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/dn-CwVHU7hXoBsClmbU1nQ/VEPNxXkoJ7yWLXghIdIGU_HK-lZ04N8oKADkqWG_mRSIxNArvADt8YFQygWDuuxDiByrQdODFlAnWxhEV05haA/1VYYmgBb0mzAhBp5_-A9t_UMtaD65GlYQ9Ru8Fg73fw'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rXpXIkNBfBI5685KfUOEaA/KHAVHYFuOHY-2yRdDhyktTgxCG5wYz7zuY-wGxr3wkao8OdUxmoC1iBDnu_nVugdvtGd64xzIWFE1mOD-1bLXg/qDm9f8ze8gUXTPb5FWO6HzMhNL5lbfJrTNJ_B1pzFCI'), ('width', 769), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/HAwibJ8GjaXdCi1GeomR7Q/FrFtnJTETTk-wi4BwikVbCLJzsl59D-2u8-2RubT2NqBPKu-0b_Aun_hyOrmGMo2isF6xjOaZGiUwmrq43sOAQ/76wgJtWAcB5t77xnbtuTE95S0NImZaRKL4V_lczh8pI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,"The triple output, 160 W, E36313A provides small, compact size for bench use; low output ripple and noise; built-in measurements and basic programmable features with USB and LAN, and optional GPIB interfaces.","https://www.altoo.dk/Keysight+E36313A+160W+Triple+Output+Power+Supply-+6V-+10A+-+2X+25V-+2A.htm#:~:text=The%20triple%20output%2C%20160%20W,LAN%2C%20and%20optional%20GPIB%20interfaces.","Keysight E36313A
",308.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Keysight/Keysight_E36313A.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.Keysight_E36313A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT E36313A,Write a Python script that uses Qcodes Community to connect to a KEYSIGHT E36313A Power Supplies,3130.28,,,,"from qcodes import VisaInstrument
from qcodes import Instrument
from qcodes.instrument.channel import InstrumentChannel


class E36313AChannel(InstrumentChannel):
    """"""

    """"""
    def __init__(self, parent: Instrument, name: str, chan: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
            attached.
            name: The name of the channel
            chan: The number of the channel in question (1-3)
        """"""
        # Sanity Check inputs
        if name not in ['ch1', 'ch2', 'ch3']:
            raise ValueError(""Invalid Channel: {}, expected 'ch1' or 'ch2' or 'ch3'""
                             .format(name))
        if chan not in [1, 2, 3]:
            raise ValueError(""Invalid Channel: {}, expected '1' or '2' or '3'""
                             .format(chan))

        super().__init__(parent, name)

        self.add_parameter('source_voltage',
                           label=""Channel {} Voltage"".format(chan),
                           get_cmd='VOLT? (@{:d})'.format(chan),
                           get_parser=float,
                           set_cmd='VOLT {{:.8G}},(@{:d})'.format(chan),
                           unit='V')

        self.add_parameter('source_current',
                           label=""Channel {} Current"".format(chan),
                           get_cmd='CURR? (@{:d})'.format(chan),
                           get_parser=float,
                           set_cmd='CURR {{:.8G}},(@{:d})'.format(chan),
                           unit='A')

        self.add_parameter('voltage',
                           get_cmd='MEAS:VOLT? (@{:d})'.format(chan),
                           get_parser=float,
                           label='Channel {} Voltage'.format(chan),
                           unit='V')

        self.add_parameter('current',
                           get_cmd='MEAS:CURR? (@{:d})'.format(chan),
                           get_parser=float,
                           label='Channel {} Current'.format(chan),
                           unit='A')

        self.add_parameter('enable',
                           get_cmd='OUTP? (@{:d})'.format(chan),
                           set_cmd='OUTP {{:d}},(@{:d})'.format(chan),
                           val_mapping={'on':  1, 'off': 0})

        self.channel = chan


class E36313A(VisaInstrument):
    """"""
    This is the qcodes driver for the Keysight E36313A programmable DC power supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, terminator='\n', **kwargs)

        # The E36313A supports two channels
        for ch_num in [1, 2, 3]:
            ch_name = ""ch{:d}"".format(ch_num)
            channel = E36313AChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)

        self.connect_message()

    def get_idn(self):
        IDN = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN.split(','))
        IDN = {'vendor': vendor, 'model': model,
               'serial': serial, 'firmware': firmware}
        return IDN
"
323,could not find,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'atttQsl2GO2NVZvPL'), ('width', 250), ('height', 981), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5afzdOiFf6u08lAK1f1CrQ/gMzrxGeFEbp70-NJFfvNxo0azrtX-IzQyjENO9SDJBsbLQ1C08Ekyheu3ebggXOHSwCiaIkqufIaSvEKmbffTOunJC7xToFihqad7jO02j0/hoNEpEtv_Xd8V9o7ULgtuBrOjfmttl_62Hfd1AjAQVQ'), ('filename', 'FrontS5i.png'), ('size', 350973), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cIQOPoQ_5DCqHbM5eIZQpw/AShXVVqMA4XMmaOTDu1IKL2N-0TY32owrE3cDdaeZ25l1kmuN3dAon2cooCPLiFTrDI1X5LoBYgu5nsOkSfWEQ/WasVyA_hAzev9naGAOpJK0QcO-h0RlOf2sYUsSAvCAs'), ('width', 9), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4xJ9gF81r9jdKhPiIamA8w/zOZK_w8SkvPPRZJaPaDIRjouQVsyZQamXhHPmHSfH4XTd2bEaOH33O3GNo74EDYlajdkZG_MyZufoCu4lo0GNw/Btajdi7hvGJyLpQVRHe5dVBz-6FKLhiIdL4iN5zTgR8'), ('width', 250), ('height', 981)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Xf6_Qs6xtJoDPR6qjtZK0A/oSY23CfphO1mQ7HlgcfbAzcgUhtPsrEnicGDrlRMsmCM6XfsS9cUCg_G8hPuVplPRMF_lfopWhxM-cSbXcLCKg/mP2csZWdwd8dd_0fb7G9yQA864JKmhRSMqGlivz73wM'), ('width', 3000), ('height', 3000)]))]))])]",41.3,"CJ Delft, Netherlands","The S5i module is a RF source ranging from 40 MHz to 4 GHz, initially designed for reflectometry. The output power of the fundamental frequency ranges from -20 dBm to 14 dBm and can be controlled by both the front panel and via software. The RF output can be muted by an external source, which gives an on/off ratio of larger than 60 dB.

",https://qtwork.tudelft.nl/~mtiggelman/modules/rf/s5i.html,S5I,437.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","At QuTech, we work on a radically new technology with world-changing potential. Our mission: to develop scalable prototypes of a quantum computer and an inherently safe quantum internet, based on the fundamental laws of quantum mechanics.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/QuTech/S5i.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.QuTech.html#module-qcodes_contrib_drivers.drivers.QuTech.S5i,Qutech,"[OrderedDict([('id', 'atttaTZUsXgNNgwbC'), ('width', 1504), ('height', 747), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mN2xtf2p0zIVZD_EsTLuGQ/I_AGFevjoHNT5KcBSBfvxAEF-1XuhxBOhE681HKUqNTV02HmhH8VMto9CBHSF4Shyd627Rpy1fpDyYCMxUsE0m_vn-2ihpmQyy2gOR_IDpI/G_MUKoe0kjrsDQVSb8tS_I0G9Slrw4lMB0pc3ucH8GQ'), ('filename', 'QuTech_Main_rgb.jpg'), ('size', 158522), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/GkOsDDbCU22ydBTTOWTkwQ/oPUCVQhziZY7wcMEXQZjfT7s3IBsIXq-oAbeT_5ZSJPSaSvm4QqnkUASS5lvTrigmasFluWh6VZpXprGKjFZEg/LWAfrORpIrD8z6a1w5UEqKmEERuHdLpbAhMBqhQvBR8'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RkDF26qe74WElr-X-MS1Qg/n_0KJfpdzXRNzAkd6JraxTKN9m3X7Iiy1_09EKzEF84G70BlbykrjeBZG5fUOKm9VdI9JxhjyB26OD8V4KHyrg/gSFgs3dE-RKZXDsRR2aqVYprO2oAEAurHNhNfjuJkas'), ('width', 1031), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/pRZuCWaKRkT08qRzMR5ddA/yvgnUgbTLPaSmaBNbb12Vginxk4M96K348YOA27E-_W6Xlv8M8EwLR_EKScVAFZdlI5IxnEeg5G3VIse0VQMBQ/Qf47YXAs0Mn8R4NWl07hU1Jrxjmh-SFzyOS7_h7WFBo'), ('width', 3000), ('height', 3000)]))]))])]",https://qutech.nl/,S5i,Write a Python script that uses Qcodes Community to connect to a S5i RF Signal Generator,,,,,"from qcodes.instrument.base import Instrument
from qcodes.utils.validators import Bool, Numbers

try:
    from spirack import S5i_module
except ImportError:
    raise ImportError(('The S5i_module class could not be found. '
                       'Try installing it using pip install spirack'))


class S5i(Instrument):
    """"""
    Qcodes driver for the S5i RF generator SPI-rack module.

    Args:
        name (str): name of the instrument.
        spi_rack (SPI_rack): instance of the SPI_rack class as defined in
            the spirack package. This class manages communication with the
            individual modules.
        module (int): module number as set on the hardware.
        frequency (float): RF frequency at startup, default is 41 MHz.
        enable_output (bool): Switch device output on or off, default is True.
        output_level (int): RF output level in dBm, default is 0 dBm.
    """"""

    def __init__(self, name, spi_rack, module, frequency=41e6,
                 enable_output=True, output_level=0, **kwargs):
        super().__init__(name, **kwargs)

        self.s5i = S5i_module(spi_rack, module, frequency=frequency,
                              enable_output=enable_output,
                              output_level=output_level)

        self.add_parameter('output_enabled',
                           label='RF output enabled',
                           initial_value=enable_output,
                           set_cmd=self.s5i.enable_output_soft,
                           vals=Bool(),
                           docstring='Switches output on/off')

        self.add_parameter('frequency_stepsize',
                           label='Frequency stepsize',
                           get_cmd=self._get_stepsize,
                           set_cmd=self.s5i.set_stepsize,
                           unit='Hz',
                           vals=Numbers(),
                           docstring='Set the optimal frequency stepsize for '
                                     'a minimal phase noise')

        self.add_parameter('frequency',
                           label='Frequency',
                           initial_value=frequency,
                           get_cmd=self._get_rf_frequency,
                           set_cmd=self.s5i.set_frequency,
                           unit='Hz',
                           vals=Numbers(40e6, 4e9),
                           docstring='Set RF frequency')

        self.add_parameter('power',
                           label='Output Power',
                           initial_value=output_level,
                           set_cmd=self.s5i.set_output_power,
                           unit='dBm',
                           vals=Numbers(-14, 20),
                           docstring='Set output power')

    def optimize_for_frequency(self):
        """"""
        This method finds the optimum stepsize for the set frequency.

        The stepsize affects the phase noise of the instrument. The smaller the
        stepsize, the greater is the phase noise. So this method sets the
        stepsize as large as possible for the current reference frequency.

        """"""
        stepsize = self.s5i.get_optimal_stepsize(self.s5i.rf_frequency)
        self.s5i.set_stepsize(stepsize)

    def _get_stepsize(self):
        return self.s5i.stepsize

    def _get_rf_frequency(self):
        return self.s5i.rf_frequency
"
327,https://andor.oxinst.com/assets/uploads/products/andor/documents/andor-idus-401-specifications.pdf,"https://www.horiba.com/int/scientific/technologies/detectors/what-is-a-ccd-detector/#:~:text=A%20CCD%20or%20Charge%20Coupled,visible%20and%20near%2Dinfra%20light.","[OrderedDict([('id', 'att2wAStG9m5mVbNZ'), ('width', 1000), ('height', 866), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BcoE0gzGh3AG65U13kWJHg/icOSQVe7XH39oP2gn9jPQnW6EnpgdE9vt1EfggBrk_eLnQAzA0g7CDX-y9-zJJqt1HKbVzh8LZ0gYxdtYnz_H6y5HnDEj4a4a8kZXT5qW9M/EOKh_4ng3WZWI7XWNJSGFCoRuN1mNgTCwnZ2-2NmKBg'), ('filename', 'idus-401-product.png'), ('size', 645710), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/OBTRCpi2Pp-KIKk4e95STQ/A_CiaNWqeFnl10MNb7R_GL-uN2S5Q0f-ADqV6MIkRdsXY4zaMxX-iv9jBgfVoqTObD5NHWGDhW5F6BcuomwNug/GFbWA9qMOs-Glu4LQlOil1fk4u05Xcr89BPa26yiwTc'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ddx12bhtk3HzsHL4ToDAw/_A0WG59rD-6eVw45fVOye7bFPw0VmXfyp0UnYEziqSKresJ3j3BSQyOguWqNHFnq5EhpActGtGM6OSaKB4cLfQ/1N6HSajBacUaMuSHETIneTOv2upSEAweyXWMb8bQZsk'), ('width', 591), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/D6FegWPCodkvXXff4JJ-EA/-O89dIMhXBflKZ6TDH7Fp1xsGGAaEvKPggE7qBw8AAN-Vxs0_qkmNGqPN9c2iyJs5ZXcor4vDdiZwkLyQb6MHw/BIZtCvOXc9f_hPNb0lc_au3cd2MBlgZzr6htU7HW-mc'), ('width', 3000), ('height', 3000)]))]))])]",230.0,UK,"The Scientific Grade, 1024 x 127 deep depletion spectroscopy CCD camera is ideally suited to rapid analysis, multi-channel and low-light applications including fluorescence and Raman spectroscopy.",https://andor.oxinst.com/products/idus-spectroscopy-cameras/idus-401,DU 401,80.0,['Spectrometers'],A CCD or Charge Coupled Device is a highly sensitive photon detector.,"Leaders In The Development & Manufacture of Cameras, Microscopy and Spectroscopy Systems.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Andor/DU401.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Andor.html#qcodes_contrib_drivers.drivers.Andor.DU401.Andor_DU401,Andor,"[OrderedDict([('id', 'att2wclSxDYBZ5XdP'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ShEslxOZl34gI-8EZ_MG9g/twATzAQr_tiaaPKNPlzD3NdoFRbkHN7xtffGUtgk9ryfNWuTGv5zUWl70uxjhlUNTZHOIDE__WvRGB46BBuOzA/CFN-M_So7iF8gpoLNkGnlHIFIhRrvSnWijXqVUf-dpo'), ('filename', '3672.jpg'), ('size', 29221), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/TKqZruYpKNEqvYLv78Utkw/g1wxrneNwNF3AQN0uVnLz2Ri3lVnGq7wIjfsHSOjK_rOIWXdHV59yVps3imKXe3U8CD8zAyRrbNlde1a2uQR-Q/JuZdvpvvstwXPPHFxDylF8EPPewqz2WVQISQ2NQMjqA'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KDql0vLcxwffhfno9BOzAw/vQy72UbmYI1O8PU79cWeBuae_Hx_WN6AwFeF-AlolGH8G9D6cUdJBVCrNgZhwcvUPv7aOuhoprbR5WOzjslg8Q/Kq6mXiYA8pRlpUCPfRBTjt05958N-i61oKh56CQsKuw'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/b5b6HEknORB_lP7wehRXDw/2n_ltniQZyruV4B1cD5opyNBmLTkP6d3BjPsqdvLt52n3OC3NnZC2Zmk56vMSvCxgRBDnvbqkTAedpnW6Dod5A/kINF2RnLUdbGIQHHvv_pRn5tSeTeG5RO9JTPSGuC1gc'), ('width', 3000), ('height', 3000)]))]))])]",https://andor.oxinst.com/,IDUS 401 CCD,Write a Python script that uses Qcodes Community to connect to a IDUS 401 CCD Spectrometers,,,,,"import os, sys
from typing import Dict, List, Optional, Tuple, Any
from qcodes import Instrument, Parameter
from qcodes.utils.validators import Ints
from qcodes.utils.helpers import create_on_off_val_mapping
import ctypes


class atmcd64d:
    """"""
    Wrapper class for the atmcd64.dll Andor library.
    The class has been tested for an Andor iDus DU401 BU2.

    Args:
        dll_path: Path to the atmcd64.dll file. If not set, a default path is used.
        verbose: Flag for the verbose behaviour. If true, successful events are printed.

    Attributes:
        verbose: Flag for the verbose behaviour.
        dll: WinDLL object for atmcd64.dll.

    """"""

    # default dll path
    _dll_path = 'C:\\Program Files\\Andor SDK\\atmcd64d.dll'

    # success and error codes
    _success_codes = {20002: 'DRV_SUCCESS', 20035: 'DRV_TEMP_NOT_STABILIZED', 20036: 'DRV_TEMPERATURE_STABILIZED',
                      20037: 'DRV_TEMPERATURE_NOT_REACHED'}
    _error_codes = {
        20001: 'DRV_ERROR_CODES', 20003: 'DRV_VXDNOTINSTALLED', 20004: 'DRV_ERROR_SCAN', 20005: 'DRV_ERROR_CHECK_SUM',
        20006: 'DRV_ERROR_FILELOAD', 20007: 'DRV_UNKNOWN_FUNCTION', 20008: 'DRV_ERROR_VXD_INIT',
        20009: 'DRV_ERROR_ADDRESS', 20010: 'DRV_ERROR_PAGELOCK', 20011: 'DRV_ERROR_PAGE_UNLOCK',
        20012: 'DRV_ERROR_BOARDTEST', 20013: 'DRV_ERROR_ACK', 20014: 'DRV_ERROR_UP_FIFO', 20015: 'DRV_ERROR_PATTERN',
        20017: 'DRV_ACQUISITION_ERRORS', 20018: 'DRV_ACQ_BUFFER', 20019: 'DRV_ACQ_DOWNFIFO_FULL',
        20020: 'DRV_PROC_UNKNOWN_INSTRUCTION', 20021: 'DRV_ILLEGAL_OP_CODE', 20022: 'DRV_KINETIC_TIME_NOT_MET',
        20023: 'DRV_ACCUM_TIME_NOT_MET', 20024: 'DRV_NO_NEW_DATA', 20026: 'DRV_SPOOLERROR',
        20027: 'DRV_SPOOLSETUPERROR', 20033: 'DRV_TEMPERATURE_CODES', 20034: 'DRV_TEMPERATURE_OFF',
        20038: 'DRV_TEMPERATURE_OUT_RANGE', 20039: 'DRV_TEMPERATURE_NOT_SUPPORTED', 20040: 'DRV_TEMPERATURE_DRIFT',
        20049: 'DRV_GENERAL_ERRORS', 20050: 'DRV_INVALID_AUX', 20051: 'DRV_COF_NOTLOADED', 20052: 'DRV_FPGAPROG',
        20053: 'DRV_FLEXERROR', 20054: 'DRV_GPIBERROR', 20064: 'DRV_DATATYPE', 20065: 'DRV_DRIVER_ERRORS',
        20066: 'DRV_P1INVALID', 20067: 'DRV_P2INVALID', 20068: 'DRV_P3INVALID', 20069: 'DRV_P4INVALID',
        20070: 'DRV_INIERROR', 20071: 'DRV_COFERROR', 20072: 'DRV_ACQUIRING', 20073: 'DRV_IDLE',
        20074: 'DRV_TEMPCYCLE', 20075: 'DRV_NOT_INITIALIZED', 20076: 'DRV_P5INVALID', 20077: 'DRV_P6INVALID',
        20078: 'DRV_INVALID_MODE', 20079: 'DRV_INVALID_FILTER', 20080: 'DRV_I2CERRORS',
        20081: 'DRV_DRV_I2CDEVNOTFOUND', 20082: 'DRV_I2CTIMEOUT', 20083: 'DRV_P7INVALID', 20089: 'DRV_USBERROR',
        20090: 'DRV_IOCERROR', 20091: 'DRV_VRMVERSIONERROR', 20093: 'DRV_USB_INTERRUPT_ENDPOINT_ERROR',
        20094: 'DRV_RANDOM_TRACK_ERROR', 20095: 'DRV_INVALID_TRIGGER_MODE', 20096: 'DRV_LOAD_FIRMWARE_ERROR',
        20097: 'DRV_DIVIDE_BY_ZERO_ERROR', 20098: 'DRV_INVALID_RINGEXPOSURES', 20990: 'DRV_ERROR_NOCAMERA',
        20991: 'DRV_NOT_SUPPORTED', 20992: 'DRV_NOT_AVAILABLE', 20115: 'DRV_ERROR_MAP', 20116: 'DRV_ERROR_UNMAP',
        20117: 'DRV_ERROR_MDL', 20118: 'DRV_ERROR_UNMDL', 20119: 'DRV_ERROR_BUFFSIZE', 20121: 'DRV_ERROR_NOHANDLE',
        20130: 'DRV_GATING_NOT_AVAILABLE', 20131: 'DRV_FPGA_VOLTAGE_ERROR', 20099: 'DRV_BINNING_ERROR',
        20100: 'DRV_INVALID_AMPLIFIER', 20101: 'DRV_INVALID_COUNTCONVERT_MODE'}

    def __init__(self, dll_path: Optional[str] = None, verbose: bool = False):
        if sys.platform != 'win32':
            self.dll: Any = None
            raise OSError(""\""atmcd64d\"" is only compatible with Microsoft Windows"")
        else:
            self.dll = ctypes.windll.LoadLibrary(dll_path or self._dll_path)
        self.verbose = verbose

    def error_check(self, code, function_name=''):
        if code in self._success_codes.keys():
            if self.verbose:
                print(""atmcd64d: [%s]: %s"" % (function_name, self._success_codes[code]))
        elif code in self._error_codes.keys():
            print(""atmcd64d: [%s]: %s"" % (function_name, self._error_codes[code]))
            raise Exception(self._error_codes[code])
        else:
            print(""atmcd64d: [%s]: Unknown code: %s"" % (function_name, code))
            raise Exception()

    def cooler_off(self) -> None:
        code = self.dll.CoolerOFF()
        self.error_check(code, 'CoolerOFF')

    def cooler_on(self) -> None:
        code = self.dll.CoolerON()
        self.error_check(code, 'CoolerON')

    def get_acquired_data(self, size) -> List[int]:
        c_data_array = ctypes.c_int * size
        c_data = c_data_array()
        code = self.dll.GetAcquiredData(ctypes.pointer(c_data), size)
        self.error_check(code, 'GetAcquiredData')
        acquired_data = []
        for i in range(len(c_data)):
            acquired_data.append(c_data[i])
        return acquired_data

    def get_acquisition_timings(self) -> Tuple[float, float, float]:
        c_exposure = ctypes.c_float()
        c_accumulate = ctypes.c_float()
        c_kinetic = ctypes.c_float()
        code = self.dll.GetAcquisitionTimings(ctypes.byref(c_exposure), ctypes.byref(c_accumulate), ctypes.byref(c_kinetic))
        self.error_check(code, 'GetAcquisitionTimings')
        return c_exposure.value, c_accumulate.value, c_kinetic.value

    def get_camera_handle(self, camera_index) -> int:
        c_camera_handle = ctypes.c_long()
        code = self.dll.GetCameraHandle(camera_index, ctypes.byref(c_camera_handle))
        self.error_check(code, 'GetCameraHandle')
        return c_camera_handle.value

    def get_camera_serial_number(self) -> int:
        c_serial_number = ctypes.c_int()
        code = self.dll.GetCameraSerialNumber(ctypes.byref(c_serial_number))
        self.error_check(code, 'GetCameraSerialNumber')
        return c_serial_number.value

    def get_hardware_version(self) -> Tuple[int, int, int, int, int, int]:
        c_pcb = ctypes.c_int()
        c_decode = ctypes.c_int()
        c_dummy1 = ctypes.c_int()
        c_dummy2 = ctypes.c_int()
        c_firmware_version = ctypes.c_int()
        c_firmware_build = ctypes.c_int()
        code = self.dll.GetHardwareVersion(ctypes.byref(c_pcb), ctypes.byref(c_decode), ctypes.byref(c_dummy1),
                                           ctypes.byref(c_dummy2), ctypes.byref(c_firmware_version),
                                           ctypes.byref(c_firmware_build))
        self.error_check(code)
        return c_pcb.value, c_decode.value, c_dummy1.value, c_dummy2.value, c_firmware_version.value, \
            c_firmware_build.value

    def get_head_model(self) -> str:
        c_head_model = ctypes.create_string_buffer(128)
        code = self.dll.GetHeadModel(c_head_model)
        self.error_check(code)
        return c_head_model.value.decode('ascii')

    def get_detector(self) -> Tuple[int, int]:
        c_x_pixels = ctypes.c_int()
        c_y_pixels = ctypes.c_int()
        code = self.dll.GetDetector(ctypes.byref(c_x_pixels), ctypes.byref(c_y_pixels))
        self.error_check(code, 'GetDetector')
        return c_x_pixels.value, c_y_pixels.value

    def get_filter_mode(self) -> int:
        c_mode = ctypes.c_int()
        code = self.dll.GetFilterMode(ctypes.byref(c_mode))
        self.error_check(code, 'GetFilterMode')
        return c_mode.value

    def get_status(self) -> int:
        c_status = ctypes.c_int()
        code = self.dll.GetStatus(ctypes.byref(c_status))
        self.error_check(code, 'GetStatus')
        return c_status.value

    def get_temperature(self) -> int:
        c_temperature = ctypes.c_int()
        code = self.dll.GetTemperature(ctypes.byref(c_temperature))
        self.error_check(code, 'GetTemperature')
        return c_temperature.value

    def get_temperature_range(self) -> Tuple[int, int]:
        c_min_temp = ctypes.c_int()
        c_max_temp = ctypes.c_int()
        code = self.dll.GetTemperatureRange(ctypes.byref(c_min_temp), ctypes.byref(c_max_temp))
        self.error_check(code, 'GetTemperatureRange')
        return c_min_temp.value, c_max_temp.value

    def initialize(self, directory: str) -> None:
        code = self.dll.Initialize(directory)
        self.error_check(code, 'Initialize')

    def is_cooler_on(self) -> int:
        c_cooler_status = ctypes.c_int()
        code = self.dll.IsCoolerOn(ctypes.byref(c_cooler_status))
        self.error_check(code, 'IsCoolerOn')
        return c_cooler_status.value

    def set_accumulation_cycle_time(self, cycle_time: float) -> None:
        c_cycle_time = ctypes.c_float(cycle_time)
        code = self.dll.SetAccumulationCycleTime(c_cycle_time)
        self.error_check(code, 'SetAccumulationCycleTime')

    def set_acquisition_mode(self, mode: int) -> None:
        c_mode = ctypes.c_int(mode)
        code = self.dll.SetAcquisitionMode(c_mode)
        self.error_check(code, 'SetAcquisitionMode')

    def set_current_camera(self, camera_handle: int) -> None:
        c_camera_handle = ctypes.c_long(camera_handle)
        code = self.dll.SetCurrentCamera(c_camera_handle)
        self.error_check(code, 'SetCurrentCamera')

    def set_exposure_time(self, exposure_time: float) -> None:
        c_time = ctypes.c_float(exposure_time)
        code = self.dll.SetExposureTime(c_time)
        self.error_check(code, 'SetExposureTime')

    def set_filter_mode(self, mode: int) -> None:
        c_mode = ctypes.c_int(mode)
        code = self.dll.SetFilterMode(c_mode)
        self.error_check(code, 'SetFilterMode')

    def set_number_accumulations(self, number: int) -> None:
        c_number = ctypes.c_int(number)
        code = self.dll.SetNumberAccumulations(c_number)
        self.error_check(code, 'SetNumberAccumulations')

    def set_read_mode(self, mode: int) -> None:
        code = self.dll.SetReadMode(mode)
        self.error_check(code, 'SetReadMode')

    def set_shutter(self, typ: int, mode: int, closing_time: int, opening_time: int) -> None:
        c_typ = ctypes.c_int(typ)
        c_mode = ctypes.c_int(mode)
        c_closing_time = ctypes.c_int(closing_time)
        c_opening_time = ctypes.c_int(opening_time)
        code = self.dll.SetShutter(c_typ, c_mode, c_closing_time, c_opening_time)
        self.error_check(code, 'SetShutter')

    def set_temperature(self, temperature: int) -> None:
        c_temperature = ctypes.c_int(temperature)
        code = self.dll.SetTemperature(c_temperature)
        self.error_check(code, 'SetTemperature')

    def set_trigger_mode(self, mode: int) -> None:
        c_mode = ctypes.c_int(mode)
        code = self.dll.SetTriggerMode(c_mode)
        self.error_check(code, 'SetTriggerMode')

    def shut_down(self) -> None:
        code = self.dll.ShutDown()
        self.error_check(code, 'ShutDown')

    def start_acquisition(self) -> None:
        code = self.dll.StartAcquisition()
        self.error_check(code, 'StartAcquisition')

    def wait_for_acquisition(self) -> None:
        code = self.dll.WaitForAcquisition()
        self.error_check(code, 'WaitForAcquisition')


class Spectrum(Parameter):
    """"""
    Parameter class for a spectrum taken with an Andor CCD.
    The spectrum is saved in a list with the length being set by the number of pixels on the CCD.

    Args:
        name: Parameter name.
    """"""

    def __init__(self, name: str, instrument: ""Andor_DU401"", **kwargs):
        super().__init__(name, instrument=instrument, **kwargs)
        self.ccd = instrument

    def get_raw(self) -> List[int]:
        # get acquisition mode
        acquisition_mode = self.ccd.acquisition_mode.get()

        # start acquisition
        self.ccd.atmcd64d.start_acquisition()

        if acquisition_mode == 'single scan':
            # wait for single acquisition
            self.ccd.atmcd64d.wait_for_acquisition()
        elif acquisition_mode == 'accumulate':
            # wait for accumulate acquisition
            number_accumulations = self.ccd.number_accumulations.get()
            for i in range(number_accumulations):
                self.ccd.atmcd64d.wait_for_acquisition()

        # get and return spectrum
        return self.ccd.atmcd64d.get_acquired_data(self.ccd.x_pixels)

    def set_raw(self, value):
        raise NotImplementedError()


class Andor_DU401(Instrument):
    """"""
    Instrument driver for the Andor DU401 BU2 CCD.

    Args:
        name: Instrument name.
        dll_path: Path to the atmcd64.dll file. If not set, a default path is used.
        camera_id: ID for the desired CCD.
        setup: Flag for the setup of the CCD. If true, some default settings will be sent to the CCD.

    Attributes:
        serial_number: Serial number of the CCD.
        head_model: Head model of the CCD.
        firmware_version: Firmware version of the CCD.
        firmware_build: Firmware build of the CCD.
        x_pixels: Number of pixels on the x axis.
        y_pixels: Number of pixels on the y axis.

    """"""

    # TODO (SvenBo90): implement further acquisition modes
    # TODO (SvenBo90): implement further read modes
    # TODO (SvenBo90): implement further trigger modes
    # TODO (SvenBo90): add and delete parameters dynamically when switching acquisition mode or read mode
    # TODO (SvenBo90): handle shutter closing and opening timings

    def __init__(self, name: str, dll_path: Optional[str] = None, camera_id: int = 0, setup: bool = True, **kwargs):
        super().__init__(name, **kwargs)

        # link to dll
        self.atmcd64d = atmcd64d(dll_path=dll_path)

        # initialization
        self.atmcd64d.initialize(' ')
        self.atmcd64d.set_current_camera(self.atmcd64d.get_camera_handle(camera_id))

        # get camera information
        self.serial_number = self.atmcd64d.get_camera_serial_number()
        self.head_model = self.atmcd64d.get_head_model()
        self.firmware_version = self.atmcd64d.get_hardware_version()[4]
        self.firmware_build = self.atmcd64d.get_hardware_version()[5]
        self.x_pixels, self.y_pixels = self.atmcd64d.get_detector()

        # add the instrument parameters
        self.add_parameter('accumulation_cycle_time',
                           get_cmd=self.atmcd64d.get_acquisition_timings,
                           set_cmd=self.atmcd64d.set_accumulation_cycle_time,
                           get_parser=lambda ans: float(ans[1]),
                           unit='s',
                           label='accumulation cycle time')

        self.add_parameter('acquisition_mode',
                           set_cmd=self.atmcd64d.set_acquisition_mode,
                           val_mapping={
                               'single scan': 1,
                               'accumulate': 2
                           },
                           label='acquisition mode')

        self.add_parameter('cooler',
                           get_cmd=self.atmcd64d.is_cooler_on,
                           set_cmd=self._set_cooler,
                           val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
                           label='cooler')

        self.add_parameter('exposure_time',
                           get_cmd=self.atmcd64d.get_acquisition_timings,
                           set_cmd=self.atmcd64d.set_exposure_time,
                           get_parser=lambda ans: float(ans[0]),
                           unit='s',
                           label='exposure time')

        self.add_parameter('filter_mode',
                           get_cmd=self.atmcd64d.get_filter_mode,
                           set_cmd=self.atmcd64d.set_filter_mode,
                           val_mapping=create_on_off_val_mapping(on_val=2, off_val=0),
                           label='filter mode')

        self.add_parameter('number_accumulations',
                           set_cmd=self.atmcd64d.set_number_accumulations,
                           label='number accumulations')

        self.add_parameter('read_mode',
                           set_cmd=self.atmcd64d.set_read_mode,
                           val_mapping={'full vertical binning': 0})

        min_temperature, max_temperature = self.atmcd64d.get_temperature_range()
        self.add_parameter('set_temperature',
                           set_cmd=self.atmcd64d.set_temperature,
                           vals=Ints(min_value=min_temperature,
                                     max_value=max_temperature),
                           unit=u""\u00b0""+'C',
                           label='set temperature')

        self.add_parameter('shutter_mode',
                           set_cmd=self._set_shutter_mode,
                           val_mapping={
                               'fully auto': 0,
                               'permanently open': 1,
                               'permanently closed': 2},
                           label='shutter mode')

        self.add_parameter('spectrum',
                           parameter_class=Spectrum,
                           shape=(1, self.x_pixels),
                           label='spectrum')

        self.add_parameter('temperature',
                           get_cmd=self.atmcd64d.get_temperature,
                           unit=u""\u00b0""+'C',
                           label='temperature')

        self.add_parameter('trigger_mode',
                           set_cmd=self.atmcd64d.set_trigger_mode,
                           val_mapping={'internal': 0})

        # set up detector with default settings
        if setup:
            self.cooler.set(True)
            self.set_temperature.set(-60)
            self.read_mode.set('full vertical binning')
            self.acquisition_mode.set('single scan')
            self.trigger_mode.set('internal')
            self.shutter_mode.set('fully auto')

        # print connect message
        self.connect_message(idn_param='IDN')

    # get methods
    def get_idn(self) -> Dict[str, Optional[str]]:
        return {'vendor': 'Andor', 'model': self.head_model,
                'serial': str(self.serial_number), 'firmware': str(self.firmware_version)+'.'+str(self.firmware_build)}

    # set methods
    def _set_cooler(self, cooler_on: int) -> None:
        if cooler_on == 1:
            self.atmcd64d.cooler_on()
        elif cooler_on == 0:
            self.atmcd64d.cooler_off()

    def _set_shutter_mode(self, shutter_mode: int) -> None:
        self.atmcd64d.set_shutter(1, shutter_mode, 30, 30)

    # further methods
    def close(self) -> None:
        self.atmcd64d.shut_down()
        super().close()
"
328,,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attPXdbudcTsNYYUG'), ('width', 300), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/bdzG9Gs88xoh9lb17J4Xgw/UY42hg1vjGmneW5zfRLmUFn-GSNi9_uNZyQqsVQ703bSIps8yn3YCzOKrh6FWruOI87vNzFr8QpkgyqwFvtdqxxpbczhvurALsWtPav7BhU/YKvQmoc1wSG4ORBw_7HPf8becxWcZhQiRG1ZZslZo3M'), ('filename', 'HMP2030_04-875-.jpg'), ('size', 16316), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iv_zUTTduUKFgRnHD4F0sg/9FyPSxRjjrnqtKjEQoi_aocOkqGZrSbLkF1IchEsyHj-6oSFO5FmPRRdrdWjxTQWtgTYxW1F8Yea4vLm2iWGfw/baQmjhCkkZi3UyLRUISQiNF809_L-JX2DPSTpYfMwjo'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/3W9YkTb3fUGTp2QGfOV_-Q/t7iudMjrsfyPp1pK2iV_JmWobNBdWcKBZ0sAf4ct7teq2I5RwAxpHuWXdREmOAoFw_RLbHhDqZY9EnPRzWoOzQ/jMFjzjZ_zvM9XNieZLwtvJxfZST_hSOKHQGKuIGn8so'), ('width', 300), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/CqInD0yLkJ-Jhlt59kF2Gg/AWC_ZIibkgCae8ci6WWA-atH4RaQxPvp5QfB-EFLmDOb8xdu5Ecly6ExB4H8JCVaMjijuJJ7HUJiaad9lCQFRA/7ExJWUqxAzZFxv9doDTxc-goKlZCsqF_aSG_zEoss5c'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany","2 or 3 channels with max. 188 W total output power.
Maximum output voltage of 32 V per channel.
Maximum output power per channel: 80 W.
Maximum output current per channel: 5 A.
Intuitive, price-transparent online product configurator.",https://www.rohde-schwarz.com/ca/products/test-and-measurement/dc-power-supplies/rs-hmp2000-power-supply-series_63493-43468.html,HMP 2030,488.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMP2030.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMP2030,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMP 2030,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,1796.43,,,,"from .private.HMP import _RohdeSchwarzHMP


class RohdeSchwarzHMP4040(_RohdeSchwarzHMP):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMP2030 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, model_no=2030, **kwargs)"
335,https://www.aviosys.com/products/downloads/manuals/power/9258S-T-SP-TP_manual.pdf,https://en.wikipedia.org/wiki/Network_switch,"[OrderedDict([('id', 'att0zclj7IIoSZuYP'), ('width', 640), ('height', 391), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/e43P_AXU-QZ37zPP7pUTFA/8kc2ZG-TetJP2GEZkIY4l2rkAnnS6itneZcr_IQnV-LVVM05GCDJq_hLlsb4j41nX2xtoV7HavVwh6CSdfDqx1g9tz964AcxBE5mHyj-ryw/IbRYKPlORpbJg5jyezTPRSWInKiP_WjmJTGpwqz5CJs'), ('filename', '9258T-PING.png'), ('size', 282935), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/JvzG1yunje3XdCUA1cQgBg/7DDTIfmzYIidAabOU9ME9Y3aR4ceHEWQ31DkyFTdP2LwK4SEEK8WwcF-uVFfZDdPfDV_NvJo0Ll6xB3Un7DInA/Dx5wCdwS7XTUBuDA7beh8GV6n0SRRZPrmZTyTh-4uEY'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZxdS88C0a7Dpv9-i59i2lg/qL2mQnokSbeqCgkIXvEp_c3TGMVaJLosXbTg3ruWYVni4RNyagK3FZ6ss-wzGO_lSltC6WNw1QMtm6CW300GwA/iwWgaYzpiqbtAOVaXX8qegH5JM_gGB-WT8a-6wGiBks'), ('width', 640), ('height', 391)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/nX67GNM7GC7S6O8zvgnCRg/LB82WIZGLKzHfXQQTxwir7yaBeEMZMkhAbsvNvNzw7fcYrvgc-Nl8HoeAzaHXuPkdNabdIcygsGrd15ybVI37Q/RkomCmf243SRFbVLmmAyrrimAjt33xob6E44vUa-9c0'), ('width', 3000), ('height', 3000)]))]))])]",5.0,Taiwan,"IP9258 is a web controller which can be easily used in the industry field
",https://www.aviosys.com/products/9258.php,IP Power 9258 S,102.0,['Power Supplies'],"Power Supply for Super conducting Application
","**Aviosys** IP POWER is a remote power management device that allows you to control power on/off and monitor power status of connected devices
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Aviosys/IP_Power_9258S.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Aviosys.html#module-qcodes_contrib_drivers.drivers.Aviosys.IP_Power_9258S,Aviosys,"[OrderedDict([('id', 'att3z1eq8Rv7vZ3tM'), ('width', 300), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/umfkW9kOT0G0fvyuWVZEFg/2HgqgOy3M_EJLrMBWaT2rjEMTJqr3axV_cgE8JupTlVyG9xNbVTz3ByU2QXtGT1V2uzCEK4U2FyInT0S2ePHRm0V5qCQBA7PeES1cES6Odo/CZDB2DS1k-AZIEx4yU7oT9kpfm8StSBNQvinD8tYRoY'), ('filename', 'aviosys_2.png'), ('size', 7294), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ovNS9dySXAuUL2_jcpb0sw/u_J9-9MnSeG5ySjBy1CzX3cJkncQhbfjGnhhQmyt-jwP4EqjLjHsrXV4x6qnkhGiuqYqHrgquCfVzijUqGP93A/XThF9DIYuyYKcMs22JSoigF6RskioEZpzPvdVCpYduA'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kVqq9CdTftT5823-ecFYVg/A9qSXbFja2ivPTiZA3xshgjw7VwK_zN10aAbDvWYo9Y4aQ0SenokqUEMgfryuq9eAleg9tWulgUVTPOUIiEmuw/scww5nCpwYZdauUqTUNhDB7MMfckR7Ns8d9IxM5LmaE'), ('width', 300), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7seliSbdryiLOIcdYFZrFw/PWG62eG6879mXXzGZeGEJy5P53WPBgueIr3dcYiVxzxP1nIpycESMkYbdjLUASFpmeTwWbiSjnTh_qeRR_e2Xw/eZSt8bcKcW37k25Uc_KdJ_Mealdh8qX3wucK6QzSvRg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aviosys.com/,IP Power 9258 S,Write a Python script that uses Qcodes Community to connect to a IP Power 9258 S Power Supplies,335.0,,True,,"from qcodes import Instrument, InstrumentChannel, ChannelList
from qcodes.utils.validators import Enum
from qcodes.utils.helpers import create_on_off_val_mapping
import urllib.request


class PowerChannel(InstrumentChannel):
    """"""
    Channel class for a socket on the Aviosys IP Power 9258S.

    Args:
        parent: Parent instrument.
        name: Channel name.
        channel: Alphabetic channel id.
    """"""

    CHANNEL_IDS = {'A': 1, 'B': 2, 'C': 3, 'D': 4}
    CHANNEL_NAMES = Enum(*CHANNEL_IDS.keys())

    def __init__(self, parent: Instrument, name: str, channel: str):

        super().__init__(parent, name)

        # validate the channel id
        PowerChannel.CHANNEL_NAMES.validate(channel)
        self._id_name = channel
        self._id_number = PowerChannel.CHANNEL_IDS[channel]

        # add parameters
        self.add_parameter('power_enabled',
                           get_cmd=self._get_power_enabled,
                           set_cmd=self._set_power_enabled,
                           get_parser=int,
                           val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
                           label='Power {}'.format(self._id_name))

    # get methods
    def _get_power_enabled(self):
        request = urllib.request.Request(self.parent.address+'/set.cmd?cmd=getpower')
        response = urllib.request.urlopen(request)
        request_read = response.read()
        return request_read.decode(""utf-8"")[4 + self._id_number * 6]

    # set methods
    def _set_power_enabled(self, power):
        request = urllib.request.Request(f""{self.parent.address}/set.cmd?cmd=setpower+p6{self._id_number}={power}"")
        urllib.request.urlopen(request)


class Aviosys_IP_Power_9258S(Instrument):
    """"""
    Instrument driver for the Aviosys IP Power 9258S. The IP Power 9258S is a network power controller. The device
    controls up to four power channels, that can be turned on and off. With this instrument also non-smart instruments
    can be controlled remotely.

    Args:
        name: Instrument name.
        address: http address.
        login_name: http login name.
        login_password: http login password.

    Attributes:
        address: http address.
    """"""

    def __init__(self, name: str, address: str, login_name: str, login_password: str, **kwargs):

        super().__init__(name, **kwargs)

        # save access settings
        self.address = address

        # set up http connection
        password_manager = urllib.request.HTTPPasswordMgrWithDefaultRealm()
        password_manager.add_password(None, self.address, login_name, login_password)
        handler = urllib.request.HTTPBasicAuthHandler(password_manager)
        opener = urllib.request.build_opener(handler)
        urllib.request.install_opener(opener)

        # add channels
        channels = ChannelList(self, ""PowerChannels"", PowerChannel, snapshotable=False)
        for id_name in PowerChannel.CHANNEL_IDS.keys():
            channel = PowerChannel(self, 'Chan{}'.format(id_name), id_name)
            channels.append(channel)
            self.add_submodule(id_name, channel)
        channels.lock()
        self.add_submodule(""channels"", channels)

        # print connect message
        self.connect_message()

    # get functions
    def get_idn(self):
        return {'vendor': 'Aviosys', 'model': 'IP Power 9258S'}
"
337,,https://www.ni.com/en-ca/shop/hardware/products/pxi-multiplexer-switch-module.html,"[OrderedDict([('id', 'attbpux2WyKJM6ROw'), ('width', 534), ('height', 600), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/TvhSfgve6ykOup0aYbR4Ug/7WjUXTEUnJW3x1OExRWyHlG4d-etLNTgM_dh5RneM5vC2NnT-4vsFiDinzrdZggYSgi71nZcWcud4oVPC0AF25pENgIdUYedTlNBStMYies/apqRTgLkUK0fGcuL2Mnop3QW4iof6JQdeG8fAWb6wAs'), ('filename', 'NI_PXI2597_Mux_View1.jpg'), ('size', 64299), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y_NKdezjr_qxhrqWDqvlsA/4wjomjnHqgoGOlaRnX64DOt0ofMmkHE36wPhM_42xGx8l7q0DR0lZnnpE-K1noEFVPTB4x5JPY7jZ15EZfelQw/yIsBWbwwW8lOOD0aRlEUmpaD_ZpcbGMnaZ3HGy3ogTQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/yfxIvWh6P5cr-AMdepRkKA/z3fu_0FUZ4-oAKP5mUXUofm7Eh98fsHLSi880PXOMps9IuXumLtZJuW_wt-gaemNZlUcFIrpTczPAEy4F8IIDQ/uPHG3uXunSz3q9-LVRtztNVaCEni585hIR1rHGUUUZA'), ('width', 512), ('height', 575)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZSBri4puy5CbgoNjliKRvg/sv_f0m4KMD0MAhyxvzFUKYdb3BHLKmzxji27rymichq_4NMM6D7ZOiL5k47wkttNCAFshH4xpMKGIwN2Y_JT4w/VvxcKzVZOkMHT2dorpzu30Ywvcy6qS2fxeA-0ScCTHA'), ('width', 3000), ('height', 3000)]))]))])]",1657.0,"Austin, Texas, USA","26.5 GHz, 50 Ω, 6x1 (SP6T) Terminated PXI RF Multiplexer Switch Module—The PXI‑2597 is ideal for passing high-order harmonics from PXI RF Signal Upconverter modules or routing multiple sources to PXI RF Signal Downconverter modules. The internal termination of the PXI‑2597 helps prevent high-power reflections that arise from open channels on the module. You can use the PXI‑2597 onboard relay count tracking feature to predict relay lifetime and reduce unexpected system downtime. 

",https://www.ni.com/en-ca/support/model.pxi-2597.html,Pxie 2597,379.0,['Multiplexer Switch Modules'],"PXI Multiplexer Switch Modules are ideal for high-channel-count applications that need to connect measurement or signal generation instruments to various test points on devices or units under test (DUTs or UUTs). PXI Multiplexer Switch Modules use a variety of relay types, including electromechanical armature relays, reed relays,  field-effect transistor (FET) relays, and solid-state relays, each with their own benefits, allowing you to choose a multiplexer that fits your requirements. To program the switches, you can use the IVI-compliant NI-SWITCH driver software, complete with help documentation, example programs, and a soft front panel application for interactive control of switches. For intelligent management of complex switch systems, NI Switch Executive provides additional software tools to help you design, build, and deploy your switching system.","A producer of automated test equipment and virtual instrumentation software. Common applications include data acquisition, instrument control and machine vision. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/NationalInstruments/PXIe_2597.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/NationalInstruments_PXIe_2597.html,National Instruments,"[OrderedDict([('id', 'attXAVi8mGWUwkEk7'), ('width', 960), ('height', 541), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/j_Cmz4uga8rm7Jk-W_hKJA/OFEsr4zAjNbG-yC55hU0noMqYtoPe9vQD-Gl-SI0_1-hw4p7TC8Qdz0fFEtGOyg7Gp-hqmHtvDJ5Uc0FHOeTZg/VpMBAVW2a1O5TmWcxSYkEtHm4BcyD8QObKnNg5JfgT0'), ('filename', '0x0.webp'), ('size', 3600), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4ZfSfzm3FWUK3mOB22JVow/iKinLC2EHIADrqenQyQb4vXtxsXSU3vw7pErcZG_x94ZnV7BNdl1ATxfilb4AcI9AzC_jsIekTtgJ4AgWnIY-b1Hh0id6SKbfLgxWmnsBXo/fH59fAbtvfp-o76XqOSe5kcylQsoXwwwMGdcmXpo_nU'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Rc_oPk909VeMPUIitsLj0w/FGlkfJlj5eu6r1O9HbQw96t_v9q8ABFOEQoC6d-bOa2Qdc1ops_fMtexXqE0QP7SXa02gEfs2oNFOOrrKS_LXbc2EJwN2G-Q5nDLPE18cCU/8v_OfysCX2mh7OF_Gi8ehcKkabwz3aT5QxGDtwHH5Co'), ('width', 909), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VrmEJSvE-wFyX58WI74X5w/21j--KVJrXwHWTW9l2FxBDTcxAsHk77Bi_xQtjImpzHfA--vqGMI_jVdQr3fG77lJzEyZHS6dUQe__YLb2i04-hmeB9UHAvi4AiVzzQBF1Q/NpnfS_vHNbJaSo4ZYcewJF_7ZX-hLmRd65vYunzSeig'), ('width', 3000), ('height', 3000)]))]))])]",https://www.ni.com/en-ca.html,NI PXIe-2597,Write a Python script that uses Qcodes Community to connect to a NI PXIe-2597 Multiplexer Switch Modules,9655.0,,,https://nubilight.nubicom.co.kr/upload/datasheet/374209e.pdf,"from typing import Optional, Dict
from qcodes.utils.validators import Enum
from .Switch import NI_Switch


class NI_PXIe_2597(NI_Switch):
    r""""""
    QCoDeS driver for National Instruments RF switch PXIe-2597. The device
    connects the common ""com"" port to any of the 6 other ports, labeled
    ""ch1""...""ch6"" by default. Use the ``name_mapping`` argument to alias the
    channel names.

    Args:
        name: Qcodes name for this instrument
        resource: Network address or VISA alias for the instrument.
        name_mapping: Optional mapping from default channel names to custom
            aliases
        reset_device: whether to reset the device on initialization
    """"""
    def __init__(self, name: str, resource: str,
                 name_mapping: Optional[Dict[str, str]] = None,
                 reset_device: bool = False, **kwargs):

        if name_mapping is not None:
            # don't mutate external dict
            name_mapping = name_mapping.copy()
            name_mapping[""com""] = ""com""

        super().__init__(name, resource, name_mapping, reset_device, **kwargs)

        valid_choices = [ch.short_name for ch in self.channels]
        valid_choices.remove(""com"")

        self.add_parameter(name=""channel"",
                           get_cmd=self._get_channel,
                           set_cmd=self._set_channel,
                           vals=Enum(*tuple(valid_choices + [None])),
                           post_delay=1,
                           docstring='Name of the channel where the common '
                                     '""com"" port is connected to',
                           label=f""{self.short_name} active channel"")

    def _set_channel(self, name_to_connect: Optional[str]) -> None:
        if name_to_connect is None:
            self.channels.com.disconnect_from_all()
        else:
            ch = getattr(self.channels, name_to_connect)
            self.channels.com.connect_to(ch)

    def _get_channel(self) -> Optional[str]:
        com_list = self.channels.com.connection_list
        if len(com_list) == 0:
            return None
        elif len(com_list) == 1:
            return com_list[0].short_name
        else:
            raise RuntimeError(""this shouldn't happen."")
"
338,https://www.messcomp.com/manual/42531113.pdf,https://en.wikipedia.org/wiki/Data_acquisition,"[OrderedDict([('id', 'atttn17bBvVxljItN'), ('width', 440), ('height', 440), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Ly-HoZowLJ5F8DhQdGU54A/5Ogs-gOEUJVN-vVIenIYMDgPwy8K9IZcek8DdYyhGhnRaV0PWDedHYavhXzp-LG1N8QUlJPWedJnorC8e9oAWxxfdy3ZDKrIqlhjepZ2LH8xZkfmHZDH3I-w5BoEEZUo/LDMg_7khindY_yD3BLtl_qHtSOe0qS8QYF3JJjgM8k8'), ('filename', 'PCIE-1751_03_B20131007101209.png'), ('size', 184733), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/fFsXD-eRTl6AucdkMrNgYA/sWjF5VxChp3eHmGAvdBlOBKheTRQ-o3KQkuA9Uk3o5rPxiKP4yS3r2eTTith72hNJXaSengXItCuerkBMtwTOQ/tgTWIfYiGwq35zruaRefiEFOZiqXTDmNaDaLeHQmHtA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/odhPRO1SWUU-WKCoxrDJRw/o93J86CCMiknTrPpzR1XRr1h8PDFWBXQU5Mdw2c6-3nJLKHuSbosYEHEmU6mbQGIJIC34h44voN0UJG4iL-9RQ/qvcwEvGvItlnFgEEtdogfejNfkYepFmW8bYm2ysZVfs'), ('width', 440), ('height', 440)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/T491jT4b6zJ7IoIHg2FrxQ/P7FukEbuWNziXIMGVFylnRoT4SPheveQmGiBAWorcI0TzEbxtjDRa9TmjxRm3Cvn45Vp8Z1rFgMtgQSFT1ZeIw/XDXUlWGlQS9f795PLt0nV25m_s1-d_QExNFic62T9XU'), ('width', 3000), ('height', 3000)]))]))])]",2313.0,Taiwan,"Peripheral Component Interconnect Express (PCIe or PCI-E) is a serial expansion bus standard for connecting a computer to one or more peripheral devices.

PCIE-1751 is a 48-bit digital I/O card for the PCI Express bus. Its 48 channels are divided into six 8-bit I/O ports and users can configure each 4-channel per port (nibble) as input or output via software. PCIE-1751 also provides three 32-bit counters.",https://www.advantech.com/en/products/1-2mlkco/pcie-1751/mod_8d9d9d1d-c24f-47ca-9d65-4b934092714d,PCIE 1751,0.0,['DAQ boards'],Data acquisition is the process of sampling signals that measure real-world physical conditions and converting the resulting samples into digital numeric values that can be manipulated by a computer.,"Advantech is a leader in providing trusted innovative embedded and automation products and solutions.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Advantech/PCIE_1751.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/_modules/qcodes_contrib_drivers/drivers/Advantech/PCIE_1751.html,Advantech,"[OrderedDict([('id', 'attUrNN03NsSIClyd'), ('width', 493), ('height', 102), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/NT_KZt0EZe-wUKk0cHQ3MQ/9913XI7UrXU11l54Td-lqakOS4AKz0DSmCDTlmqL7Z2Lx2-CjUJSGNvIa85qPdxAwtJveIA35gvEfVVtiqWNq7b4Ap-PryynXRJeZ1tLFLw/WwChFoGQ_AeFahsBuxD0csehWNA_wrs3Y7AtQFRMn94'), ('filename', 'image.png'), ('size', 9821), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/62HNdt-plBoJbqgaYaGK2Q/ay4Q_TTTXgJNDFyOjgfKNKTiLIONOKaKFQaxYbFBdjdQfS8OOiciJPuUuLHwiGLSzOGKdI2An0XbmSbKnvxRRQ/gieHqYivl96DfATrsVUvmMeFz1WAk8trKPKYuMPa3dY'), ('width', 174), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5b7O47PAx8WgHS1CbK2VMw/o8Ms4XwZjNgKg9kP5ep-HqCSz23aw2BjNRoMrUlq2kdjb-HOqUf2Rt1I3Bn3539GiErnV1bqVas_avAR6zrtig/R4w6uw71Hf3RYReisjWajzkIk7uws6LeHTwe_Qj7wGs'), ('width', 493), ('height', 102)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/flWnLvE9fu4eGVcIfpo1cQ/63h0proey2UkxMhwkpvU5_gXWiDOFbwRfWk7MEENUWA0bGOUpjiFLpvP8Vabphg1nVuv0W0_X0x71Z_gagY2gQ/YLpFwSJ15sTXh3vN9vOV8p3oNOs9Im7Bhx55VPQyqXE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.advantech.com/en,PCIE 1751,Write a Python script that uses Qcodes Community to connect to a PCIE 1751 DAQ boards,166.6,"To connect to a PCIE-1751 DAQ (Data Acquisition) board using the QCoDeS community library in Python, you need to install the necessary dependencies. Run the following command to install QCoDeS community:

\`\`\`shell
pip install qcodes-community
\`\`\`

Once QCoDeS community is installed, you can use it to connect to your PCIE-1751 DAQ board. Here's an example script that demonstrates how to connect to the board and read an analog input channel:

\`\`\`python
import qcodes as qc
from qcodes\_contrib\_drivers.drivers.Advantech.PCIe1751 import PCIe1751

\# Create a connection to the PCIE-1751 DAQ board
daq\_board = PCIe1751(""daq\_board"", ""PCIe1751"") # Replace with your specific DAQ board identifier

\# Set up the analog input channel
channel\_name = ""ai0"" # Replace with the desired analog input channel name
voltage\_range = ""AD\_B\_10\_V"" # Set the voltage range of the channel

daq\_board.add\_analog\_input\_channel(channel\_name, voltage\_range)

\# Read the analog input value
measurement = daq\_board.channels[channel\_name].get() # Read the value of the analog input channel
print(""Analog input value:"", measurement)

\# Close the connection to the DAQ board
daq\_board.close()
\`\`\`

In the example script, we import the necessary modules and instantiate an instance of the \`PCIe1751\` class, which represents the PCIE-1751 DAQ board. Make sure to replace \`""PCIe1751""\` with the specific identifier for your PCIE-1751 board.

Next, we set up the analog input channel using the \`add\_analog\_input\_channel()\` method. Replace \`""ai0""\` with the desired analog input channel name on your DAQ board. Adjust the \`voltage\_range\` parameter to match the voltage range supported by your specific DAQ board and the signals you expect to measure. The \`AD\_B\_10\_V\` range corresponds to a ±10V input voltage range.

We then read the value of the analog input channel using the \`get()\` method of the corresponding channel. Replace \`""ai0""\` with the channel name you specified earlier. The \`measurement\` variable will contain the value read from the channel.

Finally, we close the connection to the DAQ board.

Please note that the example script assumes you have the appropriate driver installed for your PCIE-1751 DAQ board (in this case, the \`PCIe1751\` driver from the QCoDeS community). You may need to install additional dependencies or use a different driver depending on your specific DAQ board model. Refer to the QCoDeS community documentation and the instrument driver documentation for more details on connecting to your specific DAQ board.
",,,"import cffi
import collections
from functools import partial
import logging
import os

from qcodes.instrument.base import Instrument
from qcodes.utils import validators as vals

log = logging.getLogger(__name__)


class DAQNaviException(Exception):
    """"""
    Exception raised if one of the Advantech's DAQNavi library's functions
    encounters an error.
    """"""


class DAQNaviWarning(Warning):
    """"""
    Warning raised if one of the Advantech's DAQNavi library's functions
    encounters a warning condition.
    """"""


class Advantech_PCIE_1751(Instrument):
    """"""
    Driver for DIO card from Advantech. The card has six 8255 PPI mode
    C DI/O ports, each containing 8 pins, that can be configured for either
    input or output in groups of four.

    The Advantech drivers have to be installed so that biodaq.dll can be
    accessed. This QCodes driver uses python's C foreign function interface
    cffi to call the necessary functions from the dynamically linked library.
    Automatically loads the declaration of the library from the
    _bdaqctrl.h file, that can be generated by running only the C preprocessor
    on the header included with Advantech drivers:

        gcc -D_BDAQ_C_INTERFACE -E bdaqctrl.h > _bdaqctrl.h

    Before running the above command, WIN32 and _WIN32 should be undefined at
    the start of the bdaqctrl.h and #include <stdlib.h> should be commented
    out.

    Current version of this driver implements only instant digital input and
    output. Buffered input and output, interrupts and counters are not
    implemented.

    Tested with driver version 3.1.10.0 and ddl version 3.1.12.1.
    """"""

    def __init__(self, name, device_description=""PCIE-1751,BID#0"", **kw):
        super().__init__(name, **kw)

        self.device_description = device_description

        # parse the header for function and structure declarations
        self.ffi = cffi.FFI()
        package_directory = os.path.dirname(os.path.abspath(__file__))
        header_file = os.path.join(package_directory, '_bdaqctrl.h')
        with open(header_file) as h:
            self.ffi.cdef(h.read())
        self.dll = self.ffi.dlopen(""biodaq.dll"")

        # create the digital input and output devices
        self.info = self.ffi.new(""DeviceInformation *"")
        self.info.Description = self.device_description
        self.info.DeviceNumber = -1
        self.info.DeviceMode = self.dll.ModeWriteWithReset
        self.info.ModuleIndex = 0

        self.di = self.dll.AdxInstantDiCtrlCreate()
        self.check(self.dll.InstantDiCtrl_setSelectedDevice(self.di, self.info))
        self.do = self.dll.AdxInstantDoCtrlCreate()
        self.check(self.dll.InstantDoCtrl_setSelectedDevice(self.do, self.info))

        # Create QCoDeS parameters
        for i in range(self.port_count()):
            self.add_parameter(
                'port{}_dir'.format(i),
                label='Port {} direction'.format(i),
                vals=vals.Enum(0x00, 0x0f, 0xf0, 0xff),
                get_cmd=partial(self._get_port_direction, i),
                set_cmd=partial(self._set_port_direction, i),
                docstring=""The direction (input or output) of the digital i/o ""
                          ""port nr {}. Possible values are\n""
                          ""    0x00 indicating that all pins of the port are ""
                          ""configured as inputs\n""
                          ""    0x0f indicating that pins 0 to 3 are configured ""
                          ""as outputs and pins 4 to 7 as inputs\n""
                          ""    0xf0 indicating that pins 0 to 3 are configured ""
                          ""as inputs and pins 4 to 7 as outputs\n""
                          ""    0xff indicating that all pins are configured as ""
                          ""outputs"".format(i))

        self.connect_message()

    def read_port(self, i, n=1):
        """"""
        Reads and returns the values of ports i, ..., i+n-1.
        For n=1 returns a single integer which encodes the 8 bit values,
        for n>1 returns a list of integers.
        """"""
        values = self.ffi.new('uint8[]', n)
        self.check(self.dll.InstantDiCtrl_ReadAny(self.di, i, n, values))
        if n == 1:
            return values[0]
        else:
            return list(values)

    def write_port(self, i, value):
        """"""
        Writes values to output ports. If value is an integer, writes its
        binary representation to the pins of port i. If value is a list of
        integers, writes the binary representations of their values to the pins
        of ports i, ..., i+len(value)-1 respectively.
        """"""
        if isinstance(value, collections.abc.Iterable):
            vallist = list(value)
        else:
            vallist = [value]
        data = self.ffi.new('uint8[]', vallist)
        log.debug('PCIE-1751: Write({}, {}, {})'.format(i, len(vallist),
                                                        vallist))
        self.check(self.dll.InstantDoCtrl_WriteAny(self.do, i, len(vallist),
                                                   data))

    def read_pin(self, port, pin):
        """"""
        Reads and returns the value pin pin of port port.
        """"""
        data = self.ffi.new('uint8 *')
        self.check(self.dll.InstantDiCtrl_ReadBit(self.di, port, pin, data))
        return data[0]

    def write_pin(self, port, pin, value):
        """"""
        Sets pin pin of port port to 1 if value != 0, and to 0 otherwise.
        """"""
        self.check(self.dll.InstantDoCtrl_WriteBit(self.do, port, pin, value))

    def port_count(self):
        """"""
        Returns the number of ports on the device. Each port contains 8 input
        or output pins.
        """"""
        return self.dll.InstantDoCtrl_getPortCount(self.do)

    def check(self, errorcode):
        """"""
        Checks the errorcode and raises an Exception if error occurred.
        """"""
        if errorcode == self.dll.Success:
            return
        elif errorcode < 0xE0000000:
            message = self.ERRORMSG.get(errorcode, ""Undefined error code."")
            raise DAQNaviWarning(""DAQNavi warning {:#010X}: {}"".format(
                errorcode, message))
        else:
            message = self.ERRORMSG.get(errorcode, ""Undefined error code."")
            raise DAQNaviException(""DAQNavi error {:#010X}: {}"".format(
                errorcode, message))

    def close(self):
        self.dll.InstantDoCtrl_Dispose(self.do)
        self.dll.InstantDiCtrl_Dispose(self.di)
        super().close()

    def _get_port_direction(self, i):
        """"""
        Returns the direction of port i as a 8-bit number where for each bit,
        the value 0 means that the corresponding pin is set up as an input and
        the value 1 means that it is set up as an output.
        """"""
        pcoll = self.dll.InstantDoCtrl_getPortDirection(self.do)
        port_objs = self._ICollection_to_list(pcoll, 'PortDirection *')
        return self.dll.PortDirection_getDirection(port_objs[i])

    def _set_port_direction(self, i, direction):
        """"""
        i is the number of the port to configure
        direction has to be one of the following:
            0x00 for all pins configured as inputs
            0x0f for the 4 lower pins configured as outputs and 4 higher pins
                 as inputs
            0xf0 for the 4 lower pins configured as inputs and 4 higher pins as
                 outputs
            0xff for all pins configured as outputs
        """"""
        pcoll = self.dll.InstantDoCtrl_getPortDirection(self.do)
        port_objs = self._ICollection_to_list(pcoll, 'PortDirection *')
        self.check(self.dll.PortDirection_setDirection(port_objs[i], direction))

    def _ICollection_to_list(self, collection, ctype='void *'):
        """"""
        collection is a cffi object of type 'ICollection *'
        ctype is the data type of the collection members
        """"""
        n = self.dll.ICollection_getCount(collection)
        result = [None] * n
        for i in range(n):
            voidptr_i = self.dll.ICollection_getItem(collection, i)
            result[i] = self.ffi.cast(ctype, voidptr_i)
        return result

    def get_idn(self):
        return {'vendor': 'Advantech',
                'model': self.device_description.split(',')[0],
                'serial': '',
                'firmware': ''}

    ERRORMSG = {
        0x00000000: ""The operation is completed successfully."",
        0xA0000000: ""The interrupt resource is not available."",
        0xA0000001: ""The parameter is out of the range."",
        0xA0000002: ""The property value is out of range."",
        0xA0000003: ""The property value is not supported."",
        0xA0000004: ""The property value conflicts with the current state."",
        0xA0000005: ""The value range of all channels in a group should be ""
                    ""same, such as 4~20mA of PCI-1724."",
        0xE0000000: ""The handle is NULL or its type doesn't match the required ""
                    ""operation."",
        0xE0000001: ""The parameter value is out of range."",
        0xE0000002: ""The parameter value is not supported."",
        0xE0000003: ""The parameter value format is not the expected."",
        0xE0000004: ""Not enough memory is available to complete the operation."",
        0xE0000005: ""The data buffer is null."",
        0xE0000006: ""The data buffer is too small for the operation."",
        0xE0000007: ""The data length exceeded the limitation."",
        0xE0000008: ""The required function is not supported."",
        0xE0000009: ""The required event is not supported."",
        0xE000000A: ""The required property is not supported."",
        0xE000000B: ""The required property is read-only."",
        0xE000000C: ""The specified property value conflicts with the current ""
                    ""state."",
        0xE000000D: ""The specified property value is out of range."",
        0xE000000E: ""The specified property value is not supported."",
        0xE000000F: ""The handle hasn't own the privilege of the operation the ""
                    ""user wanted."",
        0xE0000010: ""The required privilege is not available because someone ""
                    ""else had own it."",
        0xE0000011: ""The driver of specified device was not found."",
        0xE0000012: ""The driver version of the specified device mismatched."",
        0xE0000013: ""The loaded driver count exceeded the limitation."",
        0xE0000014: ""The device is not opened."",
        0xE0000015: ""The required device does not exist."",
        0xE0000016: ""The required device is unrecognized by driver."",
        0xE0000017: ""The configuration data of the specified device is lost or ""
                    ""unavailable."",
        0xE0000018: ""The function is not initialized and can't be started."",
        0xE0000019: ""The function is busy."",
        0xE000001A: ""The interrupt resource is not available."",
        0xE000001B: ""The DMA channel is not available."",
        0xE000001C: ""Time out when reading/writing the device."",
        0xE000001D: ""The given signature does not match with the device ""
                    ""current one."",
        0xE000001E: ""The function cannot be executed while the buffered AI is ""
                    ""running."",
        0xE000001F: ""The value range is not available in single-ended mode."",
        0xE000FFFF: ""Undefined error."",
    }
"
344,https://www.axiomtest.com/documents/models/Rohde%20&%20Schwarz%20SMR40%20Data%20Sheet.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'att6KDS5uA5PCNxIw'), ('width', 275), ('height', 80), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/-vaxM882C6YkvMCpL_T7Qg/ftNmyzgqWogc1GetV2Oelx_TmrLGG_uvgmNl166XsVcxSsWr45ur4HnSL-hDXyu8bJW8lkfl7pkdswRoXlwBN3buQqbOXkYU0fqa4PsrBQU/pOPU_KzXOpDtN6lhyBsFs1XfEy0JWddqK6LkIZEWsc0'), ('filename', 'thd_RS_SMR40.jpg'), ('size', 22958), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ck6yko3nImo7a46wJYxsQ/OfCdyPK8QqZlrhFWsKVhTNChwhv8B-rSCh9cwrjQLIGvO6PkTW63_qUloll9XzK1LWZjpB_NW1_EBDs5Je0A5A/zomRAxKTT5QcjRteoCsCkplxJfhLV_u3VrZSjpAAQ3M'), ('width', 124), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BNBQ_p4M7TuIMaZxMIpLqg/7Z3M-FI8-SatIyhmRNG-4vEuEsJdKhgCHooR-SxNZ4bBLHIe09GOLBSq1oUWDCail0iGDcpL6rC0l0ha1lCZlw/z38PJM5HTliFVSo_pUxppaoa_A9_9hsD2P4klDAXiVY'), ('width', 275), ('height', 80)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/51TTRh8Qv3oqUaz0R3inlQ/-MpuFS3arWfiHfE3IKzqAbEB2809TpHVdWViPm9h7NR8zMd1-WH027JMHWnwbf2aPblIAjFmJ9cRyjeNPVNW2A/7T5yLKNEGeW8RovzeMqN8Wa7ajFgwJadTFFSncwGAO8'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",The R&S SMR40 Signal Generator is designed as CW generator with pulse modulation capability with frequency coverage from 1 GHz up to 40 GHz. The lower limit can be expanded to 10 MHz by the optional Frequency Extension 0.01 GHz to 1 GHz  (option B11).,"https://www.axiomtest.com/Signal-Generators/Signal-Generators-Over-20-GHz,-Up-To-40-GHz/Rohde-_and_-Schwarz/SMR40/Signal-Generator,-40-GHz/#:~:text=Signal%20Generator%2C%2040%20GHz,-Signal%20Generators%20%3E%3E%20Signal&text=The%20R%26S%20SMR40%20Signal%20Generator,1%20GHz%20(option%20B11).",SMR 40,478.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/SMR40.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.SMR40,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,SMR 40,Write a Python script that uses Qcodes Community to connect to a {Device name} RF Signal Generator,,,,,"# Driver for microwave source RS_SMR40
#
# Written by Takafumi Fujita (t.fujita@tudelft.nl)
# This program is based on RS_SMR40.py in QTlab
#

import logging

from qcodes import VisaInstrument
from qcodes import validators as vals

log = logging.getLogger(__name__)

class RohdeSchwarz_SMR40(VisaInstrument):
    """"""
    This is the qcodes driver for the Rohde & Schwarz SMR40 signal generator
    Status: beta-version.

    Work still pending:
        - Add all parameters that are in the manual
        - Add test suite
        - See if there can be a common driver for RS mw sources from which
          different models inherit

    This driver does not contain all commands available for the SMR40 but
    only the ones most commonly used.

    """"""

    def __init__(self, name, address, verbose=1, reset=False, **kwargs):
        self.verbose = verbose
        log.debug(__name__ + ' : Initializing instrument')
        super().__init__(name, address, **kwargs)

        # TODO(TF): check what parser parameters can do
        #           check what 'tags=['sweep']' and 'types' do in qtlab
        #           fix format types
        self.add_parameter('frequency',
                           label='Frequency',
                           get_cmd=self.do_get_frequency,
                           set_cmd=self.do_set_frequency,
                           vals=vals.Numbers(10e6, 40e9),
                           unit='Hz')
        self.add_parameter('power',
                           label='Power',
                           get_cmd=self.do_get_power,
                           set_cmd=self.do_set_power,
                           vals=vals.Numbers(-30, 25),
                           unit='dBm')
        self.add_parameter('status',
                           get_cmd=self.do_get_status,
                           set_cmd=self.do_set_status,
                           vals=vals.Strings())

        # TODO(TF): check how to fix the get functions
        self.add_parameter('status_of_modulation',
                           get_cmd=self.do_get_status_of_modulation,
                           set_cmd=self.do_set_status_of_modulation,
                           vals=vals.Strings())
        self.add_parameter('status_of_ALC',
                           get_cmd=self.do_get_status_of_ALC,
                           set_cmd=self.do_set_status_of_ALC,
                           vals=vals.Strings())
        self.add_parameter('pulse_delay',
                           get_cmd=self.do_get_pulse_delay,
                           set_cmd=self.do_set_pulse_delay)

        # TODO(TF): check the way of defining this type of functions, where logging is added
        # self.add_function('reset')
        # self.add_function('get_all')

        if reset:
            self.reset()
        else:
            self.get_all()

        self.connect_message()

    # Functions
    def reset(self):
        """"""Resets the instrument to default values.

        Args:
            None

        Output:
            None

        """"""
        log.info(__name__ + ' : Resetting instrument')
        self.write('*RST')
        # TODO: make it printable
        self.get_all()

    def get_all(self):
        """"""Reads all implemented parameters from the instrument, and updates
        the wrapper.

        Args:
            None

        Output:
            None

        """"""
        log.info(__name__ + ' : reading all settings from instrument')
        # TODO: make it printable
        self.frequency.get()
        self.power.get()
        self.status.get()

    # Communication functions
    def do_get_frequency(self):
        """"""Get frequency from device.

        Args:
            None

        Output:
            frequency (float) : frequency in Hz

        """"""
        log.debug(__name__ + ' : reading frequency from instrument')
        return float(self.ask('SOUR:FREQ?'))

    def do_set_frequency(self, frequency):
        """"""Set frequency of device.

        Args:
            frequency (float) : frequency in Hz

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting frequency to %s GHz' % frequency)
        self.write('SOUR:FREQ %e' % frequency)

    def do_get_power(self):
        """"""Get output power from device.

        Args:
            None

        Output:
            power (float) : output power in dBm

        """"""
        log.debug(__name__ + ' : reading power from instrument')
        return float(self.ask('SOUR:POW?'))

    def do_set_power(self, power):
        """"""Set output power of device.

        Args:
            power (float) : output power in dBm

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting power to %s dBm' % power)
        self.write('SOUR:POW %e' % power)

    def do_get_status(self):
        """"""Get status from instrument.

        Args:
            None

        Output:
            status (str) : 'on or 'off'

        """"""
        log.debug(__name__ + ' : reading status from instrument')
        stat = self.ask(':OUTP:STAT?')

        # TODO: fix
        if stat == '1\n':
            return 'ON'
        elif stat == '0\n':
            return 'OFF'
        else:
            raise ValueError('Output status not specified : %s' % stat)

    def do_set_status(self, status):
        """"""Set status of instrument.

        Args:
            status (str) : 'on or 'off'

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting status to ""%s""' % status)
        if status.upper() in ('ON', 'OFF'):
            status = status.upper()
        else:
            raise ValueError('set_status(): can only set on or off')
        self.write(':OUTP:STAT %s' % status)

    def do_get_status_of_modulation(self):
        """"""Get status from instrument.

        Args:
            None

        Output:
            status (str) : 'on' or 'off'

        """"""
        log.debug(__name__ + ' : reading status from instrument')
        stat = self.ask(':SOUR:PULM:STAT?')

        # TODO: fix
        # if stat == '1':
        # return 'ON'
        # elif stat == '0':
        # return 'OFF'
        if stat == '1\n':
            return 'ON'
        elif stat == '0\n':
            return 'OFF'
        else:
            raise ValueError('Output status not specified : %s' % stat)

    def do_set_status_of_modulation(self, status):
        """"""Set status of modulation.

        Args:
            status (str) : 'on' or 'off'

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting status to ""%s""' % status)
        if status.upper() in ('ON', 'OFF'):
            status = status.upper()
        else:
            raise ValueError('set_status(): can only set on or off')
        self.write(':SOUR:PULM:STAT %s' % status)

    def do_get_status_of_ALC(self):
        """"""Get status from instrument.

        Args:
            None

        Output:
            status (str) : 'on or 'off'

        """"""
        log.debug(__name__ + ' : reading ALC status from instrument')
        stat = self.ask(':SOUR:POW:ALC?')

        # TODO: fix
        # if stat == '1':
        # return 'ON'
        # elif stat == '0':
        # return 'OFF'
        if stat == '1\n':
            return 'ON'
        elif stat == '0\n':
            return 'OFF'
        else:
            raise ValueError('Output status not specified : %s' % stat)

    def do_set_status_of_ALC(self, status):
        """"""Set status of instrument.

        Args:
            status (str) : 'on or 'off'

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting ALC status to ""%s""' % status)
        if status.upper() in ('ON', 'OFF'):
            status = status.upper()
        else:
            raise ValueError('set_status(): can only set on or off')
        self.write(':SOUR:POW:ALC %s' % status)

    def do_get_pulse_delay(self):
        """"""Get output power from device.

        Args:
            None

        Output:
            power (float) : output power in dBm

        """"""
        log.debug(__name__ + ' : reading pulse delay from instrument')
        return float(self.ask('SOUR:PULS:DEL?'))

    def do_set_pulse_delay(self, delay):
        """"""Set output power of device.

        Args:
            power (float) : output power in dBm

        Output:
            None

        """"""
        log.debug(
            __name__ + ' : setting pulse delay to %s seconds' % str(delay))
        self.write('SOUR:PULS:DEL 1us')

    # Shortcuts
    def off(self):
        """"""Set status to 'off'.

        Args:
            None

        Output:
            None

        """"""
        self.status.set('off')

    def on(self):
        """"""Set status to 'on'.

        Args:
            None

        Output:
            None

        """"""
        self.status.set('on')

    def off_modulation(self):
        """"""Set status of modulation to 'off'.

        Args:
            None

        Output:
            None

        """"""
        self.set_status_of_modulation('off')

    def on_modulation(self):
        """"""Set status of modulation to 'on'.

        Args:
            None

        Output:
            None

        """"""
        self.set_status_of_modulation('on')

    def set_ext_trig(self):
        """"""Set to the external trigger mode.

        Args:
            None

        Output:
            None

        """"""
        log.debug(__name__ + ' : setting to the external trigger mode')
        self.write('TRIG:PULS:SOUR EXT_TRIG')
"
345,https://www.jlab.org/div_dept/physics_division/dsg/technical_documentation/HDice/Manuals_and_Specifications/Oxford%20IPS120-10.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attmQ7Nb3HgLUBAiu'), ('width', 700), ('height', 700), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/T_muf5mHMtJRWusQHz2vog/m5UAfYYEeiML9cwipxEQ--nuNLhr1o3N-hET4-geriDdNukaYT7FTnZFyudinCRb7yDh8F7Zs_RInxeTJkpZyBiUjq5ax7Hrmi_ZNQT7Vew/Y1oTof-HbsDj4fNMffE6oD5kro1n3q3hVxxE9Xcklik'), ('filename', 'Mercury_IPS_E1-120.jpg'), ('size', 22336), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/mYCnJguJAYuQ-PXoIBWv6A/YBGoxGk8YEomyzJimcr3kLwq8En4iE-tyVEhs8YJ-91tRveivAQg_2BV3DDyGd2vThb8FSQAYClWSFkQXxlTJg/5cTNq-JcWRBt5msxbB563QlSwNPC5XkHbgKw2f8akvY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kSjJ3uADQ8AaN1shaApZbQ/4J0RgNAEIHJRrU91zjZ8yAyTDDsJedTU-BIvZZuUm6owRWd1E0vO5gZm0JNy1WXJzEDM1nPybqXChBEWKGjOWQ/0K_zFCztZim6HQb013FDkvTMyuG4kvD_yan-Q6V4yWY'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5mEpp-6Oaz4RyBxHAdRvWA/SDFWf5tyl8laDC1FQPCb6047Wjm5LzgvMaIAmO_whvrj9iKAq97ykG9LVYN1yZtJx4gGnFwpNx69KretVbuf-w/a1eGHepB6IrAKvJGq1gKTJVNJjX-x7af3Mfeagcs2nQ'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",MERC-IPS-120 MercuryIPS 120 A 10 V superconducting magnet power supply. The Mercury iPS is configurable and is made up of two units: The Mercury main unit E1-060 and Mercury secondary slave unit E1-061.,https://estore.oxinst.com/eu/products/system-spares/magnet-systems/mercury-electronics-and-cables/zidE1-120,IPS 120,399.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Oxford/IPS120.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Oxford.html#module-qcodes_contrib_drivers.drivers.Oxford.IPS120,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y_6-qvrLUbX3UWbyIcHbgQ/4dkRL2i6ehKYPq2XsN-_7uhD1kytqs2h_Ze0kMEKut9Fvjb9A7PF18KjlvYBlNKdtpyAzcr6rDtUxwMu-3DdVyvV_kqD7VHCwvNZkdi_ZZQ/wkMbsMuSXvhAwG1mMXHayw8Qy-vSPyl0bAYt3zx6l-g'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cfffXlD5ASxTnp78JUzIaA/i2F1xVP4TOsAl1Leq188vYRR6RvsWrQslhK2ajYXkuBDhG04IcF309n2qgWp-io1G2N5HDu_ADfraamLLGM--g/LJ3NHogm9R8legLTmReuTVP5PjqPSEaPg1RHaqW3kiY'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ANarfozobYPgYKtJuIJsWQ/IKd3zp1wzTi3GeF91pPBD8Ez7C5DNOjTK5QPT0kYrB09jqVfyl9sBYMtJOwuIpxyHlOh5CDR3MSWC5TSlw8ZTw/yZVCIhWYW_fPD0KpL1DUpSw7-sMm_C_jVmpO9Nlp0UA'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xkx_TAnkplww1LDxk9W3SA/o-OYEUZB05-StGWB0Wg3TO9AWpeQ7z1fGzP8LNnMByL0geOOTU-4R1vQX49-M_m-hK0oelGX8WoWdZmflXxSwA/ueaFgoiP4CGYFuPw0p0E_zfzbBh_S6xau545LdedmQs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,IPS 120,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,15982.85,,,,"# OxfordInstruments_IPS120.py class, to perform the communication between the Wrapper and the device
# Copyright (c) 2017 QuTech (Delft)
# Code is available under the available under the `MIT open-source license <https://opensource.org/licenses/MIT>`_

# Sjaak van Diepen <c.j.vandiepen@gmail.com>, 2017
# Takafumi Fujita <t.fujita@tudelft.nl>, 2016
# Mohammad Shafiei <m.shafiei@tudelft.nl>, 2011
# Guenevere Prawiroatmodjo <guen@vvtp.tudelft.nl>, 2009
# Pieter de Groot <pieterdegroot@gmail.com>, 2009


import logging
from qcodes import VisaInstrument
from qcodes import validators as vals
from time import sleep
import pyvisa


log = logging.getLogger(__name__)

class OxfordInstruments_IPS120(VisaInstrument):
    """"""This is the driver for the Oxford Instruments IPS 120 Magnet Power Supply

    The IPS 120 can connect through both RS232 serial as well as GPIB. The
    commands sent in both cases are similar. When using the serial connection,
    commands are prefaced with '@n' where n is the ISOBUS number.
    """"""

    _GET_STATUS_MODE = {
            0: ""Amps, Magnet sweep: fast"",
            1: ""Tesla, Magnet sweep: fast"",
            4: ""Amps, Magnet sweep: slow"",
            5: ""Tesla, Magnet sweep: slow"",
            8 : ""Amps, (Magnet sweep: unaffected)"",
            9 : ""Tesla, (Magnet sweep: unaffected)""}

    _GET_STATUS_MODE2 = {
            0: ""At rest"",
            1: ""Sweeping"",
            2: ""Sweep limiting"",
            3: ""Sweeping & sweep limiting"",
            5: ""Unknown""}

    _GET_STATUS_SWITCH_HEATER = {
            0: ""Off magnet at zero (switch closed)"",
            1: ""On (switch open)"",
            2: ""Off magnet at field (switch closed)"",
            5: ""Heater fault (heater is on but current is low)"",
            8: ""No switch fitted""}

    _GET_STATUS_REMOTE = {
            0: ""Local and locked"",
            1: ""Remote and locked"",
            2: ""Local and unlocked"",
            3: ""Remote and unlocked"",
            4: ""Auto-run-down"",
            5: ""Auto-run-down"",
            6: ""Auto-run-down"",
            7: ""Auto-run-down""}

    _GET_SYSTEM_STATUS = {
            0: ""Normal"",
            1: ""Quenched"",
            2: ""Over Heated"",
            3: ""Warming Up"",
            4: ""Fault""}

    _GET_SYSTEM_STATUS2 = {
            0: ""Normal"",
            1: ""On positive voltage limit"",
            2: ""On negative voltage limit"",
            3: ""Outside negative current limit"",
            4: ""Outside positive current limit""}

    _GET_POLARITY_STATUS1 = {
            0: ""Desired: Positive, Magnet: Positive, Commanded: Positive"",
            1: ""Desired: Positive, Magnet: Positive, Commanded: Negative"",
            2: ""Desired: Positive, Magnet: Negative, Commanded: Positive"",
            3: ""Desired: Positive, Magnet: Negative, Commanded: Negative"",
            4: ""Desired: Negative, Magnet: Positive, Commanded: Positive"",
            5: ""Desired: Negative, Magnet: Positive, Commanded: Negative"",
            6: ""Desired: Negative, Magnet: Negative, Commanded: Positive"",
            7: ""Desired: Negative, Magnet: Negative, Commanded: Negative""}

    _GET_POLARITY_STATUS2 = {
            1: ""Negative contactor closed"",
            2: ""Positive contactor closed"",
            3: ""Both contactors open"",
            4: ""Both contactors closed""}

    _SET_ACTIVITY = {
            0: ""Hold"",
            1: ""To set point"",
            2: ""To zero""}

    _WRITE_WAIT = 100e-3 # seconds

    def __init__(self, name, address, use_gpib=False, number=2, **kwargs):
        """"""Initializes the Oxford Instruments IPS 120 Magnet Power Supply.

        Args:
            name (str)    : name of the instrument
            address (str) : instrument address
            use_gpib (bool)  : whether to use GPIB or serial
            number (int)     : ISOBUS instrument number. Ignored if using GPIB.
        """"""
        super().__init__(name, address, terminator='\r', **kwargs)

        self._address = address
        self._number = number
        self._values = {}
        self._use_gpib = use_gpib

        # Add parameters
        self.add_parameter('mode',
                           get_cmd=self._get_mode,
                           set_cmd=self._set_mode,
                           vals=vals.Ints())
        self.add_parameter('mode2',
                           get_cmd=self._get_mode2)
        self.add_parameter('activity',
                           get_cmd=self._get_activity,
                           set_cmd=self._set_activity,
                           vals=vals.Ints())
        self.add_parameter('switch_heater',
                           get_cmd=self._get_switch_heater,
                           set_cmd=self._set_switch_heater,
                           vals=vals.Ints())
        self.add_parameter('field_setpoint',
                           unit='T',
                           get_cmd=self._get_field_setpoint,
                           set_cmd=self._set_field_setpoint,
                           vals=vals.Numbers(-14, 14))
        self.add_parameter('sweeprate_field',
                           unit='T/min',
                           get_cmd=self._get_sweeprate_field,
                           set_cmd=self._set_sweeprate_field,
                           vals=vals.Numbers(0, 0.7))
        self.add_parameter('system_status',
                           get_cmd=self._get_system_status)
        self.add_parameter('system_status2',
                           get_cmd=self._get_system_status2)
        self.add_parameter('polarity',
                           get_cmd=self._get_polarity)
        self.add_parameter('voltage',
                           unit='V',
                           get_cmd=self._get_voltage)
        self.add_parameter('voltage_limit',
                           unit='V',
                           get_cmd=self._get_voltage_limit)

        # Find the F field limits
        MaxField = self.field_setpoint.vals._max_value
        MinField = self.field_setpoint.vals._min_value
        MaxFieldSweep = self.sweeprate_field.vals._max_value
        MinFieldSweep = self.sweeprate_field.vals._min_value
        # A to B conversion
        ABconversion = 115.733 / 14  # Ampere per Tesla
        self.add_parameter('current_setpoint',
                           unit='A',
                           get_cmd=self._get_current_setpoint,
                           set_cmd=self._set_current_setpoint,
                           vals=vals.Numbers(ABconversion * MinField,
                                             ABconversion * MaxField))
        self.add_parameter('sweeprate_current',
                           unit='A/min',
                           get_cmd=self._get_sweeprate_current,
                           set_cmd=self._set_sweeprate_current,
                           vals=vals.Numbers(ABconversion * MinFieldSweep,
                                             ABconversion * MaxFieldSweep))
        self.add_parameter('remote_status',
                           get_cmd=self._get_remote_status,
                           set_cmd=self._set_remote_status,
                           vals=vals.Ints())
        self.add_parameter('current',
                           unit='A',
                           get_cmd=self._get_current)
        self.add_parameter('magnet_current',
                           unit='A',
                           get_cmd=self._get_magnet_current)
        self.add_parameter('field',
                           unit='T',
                           get_cmd=self._get_field)
        self.add_parameter('persistent_current',
                           unit='A',
                           get_cmd=self._get_persistent_current)
        self.add_parameter('persistent_field',
                           unit='T',
                           get_cmd=self._get_persistent_field)
        self.add_parameter('magnet_inductance',
                           unit='H',
                           get_cmd=self._get_magnet_inductance)
        self.add_parameter('lead_resistance',
                           unit='mOhm',
                           get_cmd=self._get_lead_resistance)
        self.add_parameter('current_limit_lower',
                           unit='A',
                           get_cmd=self._get_current_limit_lower)
        self.add_parameter('current_limit_upper',
                           unit='A',
                           get_cmd=self._get_current_limit_upper)
        self.add_parameter('heater_current',
                           unit='mA',
                           get_cmd=self._get_heater_current)
        self.add_parameter('trip_field',
                           unit='T',
                           get_cmd=self._get_trip_field)
        self.add_parameter('trip_current',
                           unit='A',
                           get_cmd=self._get_trip_current)

        if not self._use_gpib:
            self.visa_handle.set_visa_attribute(
                    pyvisa.constants.VI_ATTR_ASRL_STOP_BITS,
                    pyvisa.constants.VI_ASRL_STOP_TWO)
            # to handle VisaIOError which occurs at first read
            try:
                self.visa_handle.write('@%s%s' % (self._number, 'V'))
                sleep(self._WRITE_WAIT)
                self._read()
            except pyvisa.VisaIOError:
                pass

    def get_all(self):
        """"""
        Reads all implemented parameters from the instrument,
        and updates the wrapper.
        """"""
        self.snapshot(update=True)

    def _execute(self, message):
        """"""
        Write a command to the device and return the result.

        Args:
            message (str) : write command for the device

        Returns:
            Response from the device as a string.
        """"""
        self.log.info('Send the following command to the device: %s' % message)

        if self._use_gpib:
            return self.ask(message)

        self.visa_handle.write('@%s%s' % (self._number, message))
        sleep(self._WRITE_WAIT)  # wait for the device to be able to respond
        result = self._read()
        if result.find('?') >= 0:
            print(""Error: Command %s not recognized"" % message)
        else:
            return result

    def _read(self):
        """"""
        Reads the total bytes in the buffer and outputs as a string.

        Returns:
            message (str)
        """"""
        bytes_in_buffer = self.visa_handle.bytes_in_buffer
        with(self.visa_handle.ignore_warning(pyvisa.constants.VI_SUCCESS_MAX_CNT)):
            mes = self.visa_handle.visalib.read(
                self.visa_handle.session, bytes_in_buffer)
        mes = str(mes[0].decode())
        return mes

    def identify(self):
        """"""Identify the device""""""
        self.log.info('Identify the device')
        return self._execute('V')

    def examine(self):
        """"""Examine the status of the device""""""
        self.log.info('Examine status')

        print('System Status: ')
        print(self.system_status())

        print('Activity: ')
        print(self.activity())

        print('Local/Remote status: ')
        print(self.remote_status())

        print('Switch heater: ')
        print(self.switch_heater())

        print('Mode: ')
        print(self.mode())

        print('Polarity: ')
        print(self.polarity())

    def remote(self):
        """"""Set control to remote and unlocked""""""
        self.log.info('Set control to remote and unlocked')
        self.remote_status(3)

    def local(self):
        """"""Set control to local and unlocked""""""
        self.log.info('Set control to local and unlocked')
        self.remote_status(2)

    def close(self):
        """"""Safely close connection""""""
        self.log.info('Closing IPS120 connection')
        self.local()
        super().close()

    def get_idn(self):
        """"""
        Overides the function of Instrument since IPS120 does not support `*IDN?`

        This string is supposed to be a comma-separated list of vendor, model,
        serial, and firmware, but semicolon and colon are also common
        separators so we accept them here as well.

        Returns:
            A dict containing vendor, model, serial, and firmware.
        """"""
        idparts = ['Oxford Instruments', 'IPS120', None, None]

        return dict(zip(('vendor', 'model', 'serial', 'firmware'), idparts))

    def _get_remote_status(self):
        """"""
        Get remote control status

        Returns:
            result(str) :
            ""Local & locked"",
            ""Remote & locked"",
            ""Local & unlocked"",
            ""Remote & unlocked"",
            ""Auto-run-down"",
            ""Auto-run-down"",
            ""Auto-run-down"",
            ""Auto-run-down""
        """"""
        self.log.info('Get remote control status')
        result = self._execute('X')
        return self._GET_STATUS_REMOTE[int(result[6])]

    def _set_remote_status(self, mode):
        """"""
        Set remote control status.

        Args:
            mode(int): Refer to _GET_STATUS_REMOTE for allowed values and
            meanings.
        """"""
        if mode in self._GET_STATUS_REMOTE.keys():
            self.log.info('Setting remote control status to %s'
                    % self._GET_STATUS_REMOTE[mode])
            self._execute('C%s' % mode)
        else:
            print('Invalid mode inserted: %s' % mode)

    def _get_system_status(self):
        """"""
        Get the system status

        Returns:
            result (str) :
            ""Normal"",
            ""Quenched"",
            ""Over Heated"",
            ""Warming Up"",
            ""Fault""
        """"""
        result = self._execute('X')
        self.log.info('Getting system status')
        return self._GET_SYSTEM_STATUS[int(result[1])]

    def _get_system_status2(self):
        """"""
        Get the system status

        Returns:
            result (str) :
            ""Normal"",
            ""On positive voltage limit"",
            ""On negative voltage limit"",
            ""Outside negative current limit"",
            ""Outside positive current limit""
        """"""
        result = self._execute('X')
        self.log.info('Getting system status')
        return self._GET_SYSTEM_STATUS2[int(result[2])]

    def _get_current(self):
        """"""
        Demand output current of device

        Returns:
            result (float) : output current in Amp
        """"""
        self.log.info('Read output current')
        result = self._execute('R0')
        return float(result.replace('R', ''))

    def _get_voltage(self):
        """"""
        Demand measured output voltage of device

        Returns:
            result (float) : output voltage in Volt
        """"""
        self.log.info('Read output voltage')
        result = self._execute('R1')
        return float(result.replace('R', ''))

    def _get_magnet_current(self):
        """"""
        Demand measured magnet current of device

        Returns:
            result (float) : measured magnet current in Amp
        """"""
        self.log.info('Read measured magnet current')
        result = self._execute('R2')
        return float(result.replace('R', ''))

    def _get_current_setpoint(self):
        """"""
        Return the set point (target current)

        Returns:
            result (float) : Target current in Amp
        """"""
        self.log.info('Read set point (target current)')
        result = self._execute('R5')
        return float(result.replace('R', ''))

    def _set_current_setpoint(self, current):
        """"""
        Set current setpoint (target current)

        Args:
            current (float) : target current in Amp
        """"""
        self.log.info('Setting target current to %s' % current)
        self.remote()
        self._execute('I%s' % current)
        self.local()
        self.field_setpoint()

    def _get_sweeprate_current(self):
        """"""
        Return sweep rate (current)

        Returns:
            result (float) : sweep rate in A/min
        """"""
        self.log.info('Read sweep rate (current)')
        result = self._execute('R6')
        return float(result.replace('R', ''))

    def _set_sweeprate_current(self, sweeprate):
        """"""
        Set sweep rate (current)

        Args:
            sweeprate(float) : Sweep rate in A/min.
        """"""
        self.remote()
        self.log.info('Set sweep rate (current) to %s A/min' % sweeprate)
        self._execute('S%s' % sweeprate)
        self.local()
        self.sweeprate_field()

    def _get_field(self):
        """"""
        Demand output field

        Returns:
            result (float) : magnetic field in Tesla
        """"""
        self.log.info('Read output field')
        result = self._execute('R7')
        return float(result.replace('R', ''))

    def _get_field_setpoint(self):
        """"""
        Return the set point (target field)

        Returns:
            result (float) : Field set point in Tesla
        """"""
        self.log.info('Read field set point')
        result = self._execute('R8')
        return float(result.replace('R', ''))

    def _set_field_setpoint(self, field):
        """"""
        Set the field set point (target field)

        Args:
            field (float) : target field in Tesla
        """"""
        self.log.info('Setting target field to %s' % field)
        self.remote()
        self._execute('J%s' % field)
        self.local()
        self.current_setpoint()

    def _get_sweeprate_field(self):
        """"""
        Return sweep rate (field)

        Returns:
            result (float) : sweep rate in Tesla/min
        """"""
        self.log.info('Read sweep rate (field)')
        result = self._execute('R9')
        return float(result.replace('R', ''))

    def _set_sweeprate_field(self, sweeprate):
        """"""
        Set sweep rate (field)

        Args:
            sweeprate(float) : Sweep rate in Tesla/min.
        """"""
        self.log.info('Set sweep rate (field) to %s Tesla/min' % sweeprate)
        self.remote()
        self._execute('T%s' % sweeprate)
        self.local()
        self.sweeprate_current()

    def _get_voltage_limit(self):
        """"""
        Return voltage limit

        Returns:
            result (float) : voltage limit in Volt
        """"""
        self.log.info('Read voltage limit')
        result = self._execute('R15')
        result = float(result.replace('R', ''))
        self.voltage.vals = vals.Numbers(-result, result)
        return result

    def _get_persistent_current(self):
        """"""
        Return persistent magnet current

        Returns:
            result (float) : persistent magnet current in Amp
        """"""
        self.log.info('Read persistent magnet current')
        result = self._execute('R16')
        return float(result.replace('R', ''))

    def _get_trip_current(self):
        """"""
        Return trip current

        Returns:
            result (float) : trip current om Amp
        """"""
        self.log.info('Read trip current')
        result = self._execute('R17')
        return float(result.replace('R', ''))

    def _get_persistent_field(self):
        """"""
        Return persistent magnet field

        Returns:
            result (float) : persistent magnet field in Tesla
        """"""
        self.log.info('Read persistent magnet field')
        result = self._execute('R18')
        return float(result.replace('R', ''))

    def _get_trip_field(self):
        """"""
        Return trip field

        Returns:
            result (float) : trip field in Tesla
        """"""
        self.log.info('Read trip field')
        result = self._execute('R19')
        return float(result.replace('R', ''))

    def _get_heater_current(self):
        """"""
        Return switch heater current

        Returns:
            result (float) : switch heater current in milliAmp
        """"""
        self.log.info('Read switch heater current')
        result = self._execute('R20')
        return float(result.replace('R', ''))

    def _get_current_limit_upper(self):
        """"""
        Return safe current limit, most positive

        Returns:
            result (float) : safe current limit, most positive in Amp
        """"""
        self.log.info('Read safe current limit, most positive')
        result = self._execute('R22')
        return float(result.replace('R', ''))

    def _get_current_limit_lower(self):
        """"""
        Return safe current limit, most negative

        Returns:
            result (float) : safe current limit, most negative in Amp
        """"""
        self.log.info('Read safe current limit, most negative')
        result = self._execute('R21')
        return float(result.replace('R', ''))

    def _get_lead_resistance(self):
        """"""
        Return lead resistance

        Returns:
            result (float) : lead resistance in milliOhm
        """"""
        self.log.info('Read lead resistance')
        result = self._execute('R23')
        return float(result.replace('R', ''))

    def _get_magnet_inductance(self):
        """"""
        Return magnet inductance

        Returns:
            result (float) : magnet inductance in Henry
        """"""
        self.log.info('Read magnet inductance')
        result = self._execute('R24')
        return float(result.replace('R', ''))

    def _get_activity(self):
        """"""
        Get the activity of the magnet. Possibilities: Hold, Set point, Zero or Clamp.

        Returns:
            result(str) : ""Hold"", ""Set point"", ""Zero"" or ""Clamp"".
        """"""
        self.log.info('Get activity of the magnet.')
        result = self._execute('X')
        return self._SET_ACTIVITY[int(result[4])]

    def _set_activity(self, mode):
        """"""
        Set the activity to Hold, To Set point or To Zero.

        Args:
            mode (int): See _SET_ACTIVITY for values and meanings.
        """"""
        if mode in self._SET_ACTIVITY.keys():
            self.log.info('Setting magnet activity to %s'
                    % self._SET_ACTIVITY[mode])
            self.remote()
            self._execute('A%s' % mode)
            self.local()
        else:
            print('Invalid mode inserted.')

    def hold(self):
        """"""Set the device activity to Hold""""""
        self.activity(0)

    def to_setpoint(self):
        """"""Set the device activity to ""To set point"". This initiates a sweep.""""""
        self.activity(1)

    def to_zero(self):
        """"""
        Set the device activity to ""To zero"". This sweeps te magnet back to zero.
        """"""
        self.activity(2)

    def _get_switch_heater(self):
        """"""
        Get the switch heater status.

        Returns:
            result(str): See _GET_STATUS_SWITCH_HEATER.
        """"""
        self.log.info('Get switch heater status')
        result = self._execute('X')
        return self._GET_STATUS_SWITCH_HEATER[int(result[8])]

    def _set_switch_heater(self, mode):
        """"""
        Set the switch heater Off or On. Note: After issuing a command it is necessary to wait
        several seconds for the switch to respond.
        Args:
            mode (int) :
            0 : Off
            1 : On
        """"""
        if mode in [0, 1]:
            self.log.info('Setting switch heater to %d' % mode)
            self.remote()
            self._execute('H%s' % mode)
            print(""Setting switch heater... (wait 40s)"")
            self.local()
            sleep(40)
        else:
            print('Invalid mode inserted.')
        sleep(0.1)
        self.switch_heater()

    def heater_on(self):
        """"""Switch the heater on, with PSU = Magnet current check""""""
        current_in_magnet = self.persistent_current()
        current_in_leads = self.current()
        if self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[1]:
            print('Heater is already on!')
        else:
            if self.mode2() == self._GET_STATUS_MODE2[0]:
                if current_in_leads == current_in_magnet:
                    self.switch_heater(1)
                else:
                    print('Current in the leads is not matching persistent current!')
            else:
                print('Magnet supply not at rest, cannot switch on heater!')
        self.switch_heater()

    def set_persistent(self):
        """"""
        Puts magnet into persistent mode

        Note: After turning of the switch heater we will wait for additional 20
        seconds before we put the current to zero. This is done to make sure
        that the switch heater is cold enough and becomes superconducting.
        """"""
        if self.mode2() == self._GET_STATUS_MODE2[0]:
            self.heater_off()
            print('Waiting for the switch heater to become superconducting')
            sleep(20)
            self.to_zero()
            self.get_all()
        else:
            print('Magnet is not at rest, cannot put it in persistent mode')
        self.get_all()

    def leave_persistent_mode(self):
        """"""
        Read out persistent current, match the current in the leads to that current
        and switch on heater
        """"""
        if self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[2]:
            field_in_magnet = self.persistent_field()
            field_in_leads = self.field()
            self.hold()
            self.field_setpoint(field_in_magnet)
            self.to_setpoint()

            while field_in_leads != field_in_magnet:
                field_in_leads = self.field()
            self.heater_on()
            self.hold()

        elif self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[1]:
            print('Heater is already on, so the magnet was not in persistent mode')
        elif self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[0]:
            print('Heater is off, field is zero. Turning on switch heater.')
            self.heater_on()

        self.get_all()

    def run_to_field(self, field_value):
        """"""
        Go to field value

        Args:
            field_value (float): the magnetic field value to go to in Tesla
        """"""

        if self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[1]:
            self.hold()
            self.field_setpoint(field_value)
            self.to_setpoint()
        else:
            print('Switch heater is off, cannot change the field.')
        self.get_all()

    def run_to_field_wait(self, field_value):
        """"""
        Go to field value and wait until it's done sweeping.

        Args:
            field_value (float): the magnetic field value to go to in Tesla
        """"""
        if self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[1]:
            self.hold()
            self.field_setpoint(field_value)
            self.remote()
            self.to_setpoint()
            magnet_mode = self.mode2()
            while magnet_mode != self._GET_STATUS_MODE2[0]:
                magnet_mode = self.mode2()
                sleep(0.5)
        else:
            print('Switch heater is off, cannot change the field.')
        self.get_all()
        self.local()

    def heater_off(self):
        """"""Switch the heater off""""""
        if (self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[0] or
                self.switch_heater() == self._GET_STATUS_SWITCH_HEATER[2]):
            print('Heater is already off!')
        else:
            if self.mode2() == self._GET_STATUS_MODE2[0]:
                self.switch_heater(0)
            else:
                print('Magnet is not at rest, cannot switch of the heater!')

    def _get_mode(self):
        """"""
        Get the mode of the device

        Returns:
            mode(str): See _GET_STATUS_MODE.
        """"""
        self.log.info('Get device mode')
        result = self._execute('X')
        return self._GET_STATUS_MODE[int(result[10])]

    def _get_mode2(self):
        """"""
        Get the sweeping mode of the device

        Returns:
            mode(str): See _GET_STATUS_MODE2.
        """"""
        self.log.info('Get device mode')
        result = self._execute('X')
        return self._GET_STATUS_MODE2[int(result[11])]

    def _set_mode(self, mode):
        """"""
        Args:
            mode(int): Refer to _GET_STATUS_MODE dictionary for the allowed
            mode values and meanings.
        """"""
        if mode in self._GET_STATUS_MODE.keys():
            self.log.info('Setting device mode to %s' % self._GET_STATUS_MODE[mode])
            self.remote()
            self._execute('M%s' % mode)
            self.local()
        else:
            print('Invalid mode inserted.')

    def _get_polarity(self):
        """"""
        Get the polarity of the output current

        Returns:
            result (str): See _GET_POLARITY_STATUS1 and _GET_POLARITY_STATUS2.
        """"""
        self.log.info('Get device polarity')
        result = self._execute('X')
        return self._GET_POLARITY_STATUS1[int(result[13])] + \
            "", "" + self._GET_POLARITY_STATUS2[int(result[14])]
"
353,https://www.keysight.com/us/en/assets/7018-01788/technical-overviews/5989-8323.pdf,https://en.wikipedia.org/wiki/Lock-in_amplifier,,5420.0,USA,,,Keysight J 7211,306.0,['Lockin Amplifiers'],"An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.
","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Keysight/Keysight_J7211.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Keysight.html#module-qcodes_contrib_drivers.drivers.Keysight.Keysight_J7211,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/zEyVOZwTjtxm3d5x2kl5kg/nUN92GLZPavPwOQkIkVzZWuvhifV50cULKU2Wm-uwFq8vETHXQHQDL6g7wS4Om912m6hkyAdQIWewBOdsQRqL2Y_noZ3qALGZsrXx8QuWEc/T9iCCsiuUUZYrEtkKuvPgTGiVXs2lgyH73OSnSbaYB8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/kFwE72vjTlEHDQqOBsLo8Q/eNI7wqnsPcBT35vFB-_cCbvkoZ9DTajCebXLGXndPREFPso382EGetl6wRjIlB_70dbDB48_NWnats1xaA_gJ8K912F4LOeyfDTW0cjE5hM/avh0Xc88GRgD1ZPKmi9tsX497tI244pgNVu3dMYPGOo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/4KQEWXplK96PMRCt65AzJw/Z74zlNAG0rI-r1YLRzp9sV_opqMk16JTBkoXe15-U5iPHCOrA2CG1Zz9OexOCWyWUaJ_NgdPPYrxvPkzgCe1GZkdQdwSNN2zVfTXzAxqbLw/f9vpKkz0CwQio8kJ0VqLiovlyAzxpm89XUxHJh-vRK8'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UKMYoJDGs1FEJ1eKyboBbQ/bMTSKYmhlH7stb9avuJNU8w_B65iECZVn-gz0T9POhi-3WLHMI4rGqzftko3QNjAHMCb8lx2ZpdsNH124mAPNpEDQXNTN6Q9iU1Fbx9pgQM/prexXjZ_dSwk1SLC2oWGq1wZWsyFtrpFA3ZF_e9TJBc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,KEYSIGHT J7211/A/B/C (Series),Write a Python script that uses Qcodes Community to connect to a KEYSIGHT J7211/A/B/C (Series) Lockin Amplifiers,,,,,"from qcodes.instrument.visa import VisaInstrument
from qcodes.utils.validators import Ints
from typing import Optional


class Keysight_J7211(VisaInstrument):
    r""""""
    Qcodes driver for the Keysight J7211 Attenuation Control Unit.
    Tested with J7211B.

    Args:
        name: Instrument name
        address: Address or VISA alias of instrument
        attenuation: Optional attenuation level (in dB) to set on startup
        terminator: Termination character in VISA communication.
    """"""

    def __init__(self, name: str, address: str,
                 attenuation: Optional[int] = None,
                 terminator=""\r"", **kwargs):
        super().__init__(name=name, address=address,
                         terminator=terminator, **kwargs)

        model = self.IDN()['model']
        if model in [""J7211A"", ""J7211B""]:
            vals = Ints(0, 120)
        elif model in [""J7211C""]:
            vals = Ints(0, 100)
        else:
            raise RuntimeError(f""Model {model} is not supported."")

        self.add_parameter('attenuation', unit='dB',
                           set_cmd='ATT {:03.0f}',
                           get_cmd='ATT?',
                           get_parser=int,
                           vals=vals,
                           initial_value=attenuation)

        self.connect_message()
"
362,https://andor.oxinst.com/assets/uploads/products/andor/documents/andor-shamrock-750-specifications.pdf,https://en.wikipedia.org/wiki/Spectrometer,"[OrderedDict([('id', 'attOpEVsiqQFB5kDf'), ('width', 1000), ('height', 866), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Vxmww7vqM45Xei924e1AdQ/mbVrOTU4HlhzfOh9-uYQ5Tm5ffCLxNlpxWyC0aecdnrDuRZtVfYC5Zk9sF264FeWrx106k00UNfLUqDhsQVhEK6LjY_vmGnYzxitBoR9swc/Fdy1sS3AGK6qpRknr462eFPNFo2LSoDoQdo8Rm7hnNE'), ('filename', 'shamrock-750-product.png'), ('size', 469885), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/AZshY3ySI3uinIIPOBoDWw/ReX4YNgnvhAAqGYjz1ZTluf84lVKag0SCjF-F0xANgBGcV9wK5ak14cGFaQF4CrQwFOxSinYp60AtegqmdQ3lQ/255GMnQL4FUeOfGxOTuz6etO1sof-oOUa9uc6fONnkE'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/uJu0BodB3OI1dSJuVzwCWw/hMSNX1_SaQzR3Im4Nke3U30zfSs8us6DrJNtlHgWuW3tCHYKmOS4w8wopDeZVYJb7H5BOQ4oBj2Ff5Fw9JlhXw/4cENWMvGyp_6VfohbZiaIllHiXWzoZ0Crori8fUaqBs'), ('width', 591), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KVMw1rcl9zP27oReRPdThQ/X2Zh-bbtylzqwLPTjInPDWK3cXRCeLMaWhHDEr1y_MV1CHtBkQYA3Pc96u_72ny5YUFXU7MyKkhhu1qIeBX_ZA/P8r6tsjrFeRE3jiw3gz8AYKJUd2_2FDtQdg0ucY_DT0'), ('width', 3000), ('height', 3000)]))]))])]",230.0,UK,"The Andor Shamrock SR-750 is based on Czerny-Turner optical design. The Shamrock is available as a pre-aligned detector/spectrometer option allowing for seamless integration of software, electronics, optics and detector. There is also a fast and interactive graphical software interface allowing full control of all the spectrograph functions.",https://andor.oxinst.com/products/kymera-and-shamrock-spectrographs/shamrock-750,SR 750,499.0,['Spectrometers'],A spectrometer is a scientific instrument used to separate and measure spectral components of a physical phenomenon. Spectrometer is a broad term often used to describe instruments that measure a continuous variable of a phenomenon where the spectral components are somehow mixed,"Leaders In The Development & Manufacture of Cameras, Microscopy and Spectroscopy Systems.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Shamrock/SR750.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Shamrock_SR750.ipynb,Andor,"[OrderedDict([('id', 'att2wclSxDYBZ5XdP'), ('width', 400), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ShEslxOZl34gI-8EZ_MG9g/twATzAQr_tiaaPKNPlzD3NdoFRbkHN7xtffGUtgk9ryfNWuTGv5zUWl70uxjhlUNTZHOIDE__WvRGB46BBuOzA/CFN-M_So7iF8gpoLNkGnlHIFIhRrvSnWijXqVUf-dpo'), ('filename', '3672.jpg'), ('size', 29221), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/TKqZruYpKNEqvYLv78Utkw/g1wxrneNwNF3AQN0uVnLz2Ri3lVnGq7wIjfsHSOjK_rOIWXdHV59yVps3imKXe3U8CD8zAyRrbNlde1a2uQR-Q/JuZdvpvvstwXPPHFxDylF8EPPewqz2WVQISQ2NQMjqA'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/KDql0vLcxwffhfno9BOzAw/vQy72UbmYI1O8PU79cWeBuae_Hx_WN6AwFeF-AlolGH8G9D6cUdJBVCrNgZhwcvUPv7aOuhoprbR5WOzjslg8Q/Kq6mXiYA8pRlpUCPfRBTjt05958N-i61oKh56CQsKuw'), ('width', 400), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/b5b6HEknORB_lP7wehRXDw/2n_ltniQZyruV4B1cD5opyNBmLTkP6d3BjPsqdvLt52n3OC3NnZC2Zmk56vMSvCxgRBDnvbqkTAedpnW6Dod5A/kINF2RnLUdbGIQHHvv_pRn5tSeTeG5RO9JTPSGuC1gc'), ('width', 3000), ('height', 3000)]))]))])]",https://andor.oxinst.com/,Shamrock 750,Write a Python script that uses Qcodes Community to connect to a Shamrock 750 Spectrometers,,,,,"from qcodes import Instrument
from qcodes.utils.validators import Ints, Numbers
import ctypes
import os
import sys
import logging
from typing import Optional

logger = logging.getLogger(__name__)


class ShamrockCIF:
    """"""
    Wrapper class for the ShamrockCIF.dll library.

    The class has been tested for a Shamrock SR750.

    Args:
        dll_path: Path to the ShamrockCIF.dll file. If not set, a default path is used.
        verbose: Flag for the verbose behaviour. If true, successful events are printed.

    Attributes:
        verbose: Flag for the verbose behaviour.
        dll: WinDLL object for ShamrockCIF.dll.
    """"""

    # default dll path
    _dll_path = 'C:\\Program Files\\Andor SDK\\Shamrock64\\ShamrockCIF.dll'

    # success and error codes
    _success_codes = {20202: 'SHAMROCK_SUCCESS'}
    _error_codes = {
        20201: 'SHAMROCK_COMMUNICATION_ERROR',
        20266: 'SHAMROCK_P1INVALID',
        20267: 'SHAMROCK_P2INVALID',
        20268: 'SHAMROCK_P3INVALID',
        20269: 'SHAMROCK_P4INVALID',
        20270: 'SHAMROCK_P5INVALID',
        20275: 'SHAMROCK_NOT_INITIALIZED',
        20292: 'SHAMROCK_NOT_AVAILABLE'
    }

    def __init__(self, dll_path: Optional[str] = None, verbose: bool = False):
        if sys.platform != 'win32':
            raise OSError(""\""ShamrockCIF\"" is only compatible with Microsoft Windows"")

        # save attributes
        self.verbose: bool = verbose

        # connect to the DLL
        current_path = os.getcwd()
        try:
            os.chdir(os.path.dirname(self._dll_path))
            self.dll = ctypes.windll.LoadLibrary(dll_path or self._dll_path)
        finally:
            os.chdir(current_path)

    def error_check(self, code, function_name=''):
        if code in self._success_codes.keys():
            if self.verbose:
                logger.info(f""ShamrockCIF: [{function_name}]: {self._success_codes[code]}"")
        elif code in self._error_codes.keys():
            error_string = f""ShamrockCIF: [{function_name}]: {self._error_codes[code]}""
            logger.error(error_string)
            raise Exception(error_string)
        else:
            error_string = f""ShamrockCIF: [{function_name}]: Unknown code: {code}""
            logger.error(error_string)
            raise Exception(error_string)

    # dll functions
    def close(self):
        code = self.dll.ShamrockClose()
        self.error_check(code, 'ShamrockClose')

    def get_calibration(self, device, number_pixels):
        c_device = ctypes.c_int(device)
        c_calibration = (ctypes.c_float * number_pixels)()
        c_number_pixels = ctypes.c_int(number_pixels)
        code = self.dll.ShamrockGetCalibration(c_device, c_calibration, c_number_pixels)
        self.error_check(code, 'ShamrockGetCalibration')
        return [max(0.0, v) for v in c_calibration]

    def get_grating(self, device):
        c_device = ctypes.c_int(device)
        c_grating = ctypes.c_int()
        code = self.dll.ShamrockGetGrating(c_device, ctypes.byref(c_grating))
        self.error_check(code, 'ShamrockGetGrating')
        return c_grating.value

    def get_grating_info(self, device, grating):
        c_device = ctypes.c_int(device)
        c_grating = ctypes.c_int(grating)
        c_lines = ctypes.c_float()
        c_blaze = ctypes.create_string_buffer(64)
        c_home = ctypes.c_int()
        c_offset = ctypes.c_int()
        code = self.dll.ShamrockGetGratingInfo(c_device, c_grating, ctypes.byref(c_lines), c_blaze, ctypes.byref(c_home), ctypes.byref(c_offset))
        self.error_check(code, 'ShamrockGetGratingInfo')
        return c_lines.value, c_blaze.value, c_home.value, c_offset.value

    def get_number_devices(self):
        c_no_devices = ctypes.c_int()
        code = self.dll.ShamrockGetNumberDevices(ctypes.byref(c_no_devices))
        self.error_check(code, 'ShamrockGetNumberDevices')
        return c_no_devices.value

    def get_number_gratings(self, device):
        c_device = ctypes.c_int(device)
        c_no_gratings = ctypes.c_int()
        code = self.dll.ShamrockGetNumberGratings(c_device, ctypes.byref(c_no_gratings))
        self.error_check(code, 'ShamrockGetNumberGratings')
        return c_no_gratings.value

    def get_number_pixels(self, device):
        c_device = ctypes.c_int(device)
        c_number_pixels = ctypes.c_int()
        code = self.dll.ShamrockGetNumberPixels(c_device, ctypes.byref(c_number_pixels))
        self.error_check(code, 'ShamrockGetNumberPixels')
        return c_number_pixels.value

    def get_pixel_width(self, device):
        c_device = ctypes.c_int(device)
        c_width = ctypes.c_float()
        code = self.dll.ShamrockGetPixelWidth(c_device, ctypes.byref(c_width))
        self.error_check(code, 'ShamrockGetPixelWidth')
        return c_width.value

    def get_serial_number(self, device):
        c_device = ctypes.c_int(device)
        c_serial = ctypes.create_string_buffer(128)
        code = self.dll.ShamrockGetSerialNumber(c_device, c_serial)
        self.error_check(code, 'ShamrockGetSerialNumber')
        return c_serial.value.decode('ascii')

    def get_slit(self, device):
        c_device = ctypes.c_int(device)
        c_width = ctypes.c_float()
        code = self.dll.ShamrockGetSlit(c_device, ctypes.byref(c_width))
        self.error_check(code, 'ShamrockGetSlit')
        return c_width.value

    def get_wavelength(self, device):
        c_device = ctypes.c_int(device)
        c_wavelength = ctypes.c_float()
        code = self.dll.ShamrockGetWavelength(c_device, ctypes.byref(c_wavelength))
        self.error_check(code, 'ShamrockGetWavelength')
        return c_wavelength.value

    def get_wavelength_limits(self, device, grating):
        c_device = ctypes.c_int(device)
        c_grating = ctypes.c_int(grating)
        c_min = ctypes.c_float()
        c_max = ctypes.c_float()
        code = self.dll.ShamrockGetWavelengthLimits(c_device, c_grating, ctypes.byref(c_min), ctypes.byref(c_max))
        self.error_check(code, 'ShamrockGetWavelengthLimits')
        return c_min.value, c_max.value

    def initialize(self):
        code = self.dll.ShamrockInitialize("""")
        self.error_check(code, 'ShamrockInitialize')

    def set_grating(self, device, grating):
        c_device = ctypes.c_int(device)
        c_grating = ctypes.c_int(grating)
        code = self.dll.ShamrockSetGrating(c_device, c_grating)
        self.error_check(code, 'ShamrockSetGrating')

    def set_number_pixels(self, device, number_pixels):
        c_device = ctypes.c_int(device)
        c_number_pixels = ctypes.c_int(number_pixels)
        code = self.dll.ShamrockSetNumberPixels(c_device, c_number_pixels)
        self.error_check(code, 'ShamrockSetNumberPixels')

    def set_pixel_width(self, device, width):
        c_device = ctypes.c_int(device)
        c_width = ctypes.c_float(width)
        code = self.dll.ShamrockSetPixelWidth(c_device, c_width)
        self.error_check(code, 'ShamrockSetPixelWidth')

    def set_slit(self, device, width):
        c_device = ctypes.c_int(device)
        c_width = ctypes.c_float(width)
        code = self.dll.ShamrockSetSlit(c_device, c_width)
        self.error_check(code, 'ShamrockSetSlit')

    def set_wavelength(self, device, wavelength):
        c_device = ctypes.c_int(device)
        c_wavelength = ctypes.c_float(wavelength)
        code = self.dll.ShamrockSetWavelength(c_device, c_wavelength)
        self.error_check(code, 'ShamrockSetWavelength')


class Shamrock_SR750(Instrument):
    """"""
    Instrument driver for the Shamrock SR750 spectrometer.

    Args:
        name: Instrument name.
        dll_path: Path to the ShamrockCIF.dll file. If not set, a default path is used.
        device_id: ID for the desired spectrometer.
        ccd_number_pixels: Number of pixels on the connected CCD.
        ccd_pixel_width: Pixel width on the connected CCD.

    Attributes:
        ShamrockCIF: DLL wrapper for ShamrockCIF.dll
        device_id: Spectrometer device ID.
        serial_number: Serial number of the spectrometer.
        number_gratings: Number of gratings on the spectrometer.
    """"""

    def __init__(self, name: str,
                 dll_path: Optional[str] = None, device_id: int = 0,
                 ccd_number_pixels: int = 1024, ccd_pixel_width: int = 26,
                 **kwargs):

        super().__init__(name, **kwargs)

        # link to dll
        self.ShamrockCIF: ShamrockCIF = ShamrockCIF(dll_path=dll_path)

        # store device number
        self.device_id: int = device_id

        # initialize Shamrock
        self.ShamrockCIF.initialize()

        # read info from Shamrock
        self.serial_number: int = self.ShamrockCIF.get_serial_number(self.device_id)
        self.number_gratings: int = self.ShamrockCIF.get_number_gratings(self.device_id)

        # send CCD info to Shamrock
        self.ShamrockCIF.set_number_pixels(self.device_id, ccd_number_pixels)
        self.ShamrockCIF.set_pixel_width(self.device_id, ccd_pixel_width)

        # add the instrument parameters
        self.add_parameter('blaze',
                           get_cmd=self._get_blaze,
                           get_parser=int,
                           label='Blaze')

        self.add_parameter('calibration',
                           get_cmd=self._get_calibration,
                           unit='nm',
                           label='Calibration')

        self.add_parameter('grating',
                           get_cmd=self._get_grating,
                           set_cmd=self._set_grating,
                           get_parser=int,
                           vals=Ints(min_value=1,
                                     max_value=self.number_gratings),
                           label='Grating')

        self.add_parameter('groove_density',
                           get_cmd=self._get_groove_density,
                           get_parser=int,
                           unit='l/mm',
                           label='Groove density')

        self.add_parameter('slit',
                           get_cmd=self._get_slit,
                           set_cmd=self._set_slit,
                           get_parser=int,
                           vals=Ints(min_value=10,
                                     max_value=2500),
                           unit=u""\u03BC""+'m',
                           label='Slit')

        min_wavelength, max_wavelength = self.ShamrockCIF.get_wavelength_limits(self.device_id, self._get_grating())
        self.add_parameter('wavelength',
                           get_cmd=self._get_wavelength,
                           set_cmd=self._set_wavelength,
                           get_parser=float,
                           vals=Numbers(min_value=min_wavelength,
                                        max_value=max_wavelength),
                           unit='nm',
                           label='Wavelength')

        # print connect message
        self.connect_message()

    # get methods

    def _get_blaze(self):
        grating = self.ShamrockCIF.get_grating(self.device_id)
        grating_info = self.ShamrockCIF.get_grating_info(self.device_id, grating)
        return grating_info[1]

    def _get_calibration(self):
        return self.ShamrockCIF.get_calibration(self.device_id, 1024)

    def _get_grating(self):
        return self.ShamrockCIF.get_grating(self.device_id)

    def _get_groove_density(self):
        grating = self.ShamrockCIF.get_grating(self.device_id)
        grating_info = self.ShamrockCIF.get_grating_info(self.device_id, grating)
        return grating_info[0]

    def get_idn(self):
        return {'vendor': 'Shamrock', 'serial': self.serial_number}

    def _get_slit(self):
        return self.ShamrockCIF.get_slit(self.device_id)

    def _get_wavelength(self):
        return self.ShamrockCIF.get_wavelength(self.device_id)

    # set methods

    def _set_grating(self, grating):
        self.ShamrockCIF.set_grating(self.device_id, grating)
        min_wavelength, max_wavelength = self.ShamrockCIF.get_wavelength_limits(self.device_id, grating)
        self.wavelength.vals = Numbers(min_value=min_wavelength, max_value=max_wavelength)

    def _set_slit(self, val):
        self.ShamrockCIF.set_slit(self.device_id, val)

    def _set_wavelength(self, wavelength):
        self.ShamrockCIF.set_wavelength(self.device_id, wavelength)

    # further methods

    def close(self):
        self.ShamrockCIF.close()
        super().close()
"
371,,https://en.wikipedia.org/wiki/Photon_counting,,5.0,"Delft, Zuid-Holland, The Netherlands",,,Singlequantum,508.0,['Photon Counting System'],"Photon counting is a technique in which individual photons are counted using a single-photon detector (SPD). A single-photon detector emits a pulse of signal for each detected photon.
","At Single Quantum, we confront every challenge with innovation, dedication, and passion. Founded in 2012, our team emerged as true pioneers of single photon detection technology: we were among the first to manufacture and commercialize superconducting nanowire single photon detectors. Since then, our multi-channel Single Quantum Eos photon detection system has been chosen by more than 100 academic and industrial labs all over the world to perform complex optical measurements.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/SingleQuantum/SingleQuantum.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.SingleQuantum.html,Singlequantum,"[OrderedDict([('id', 'attFUj5zrgN4njy3J'), ('width', 453), ('height', 111), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/UzKe6voJxt_AgmGBUqkueA/bzTM9PXmv9jFWmaBObbOmYkMFp4sfJULreS_hUN2s6v0zShFh1CA9R5u8qaxmo27Tz3wH0dlvq4EluAhFJejDtifB5CXN_-gfAVYbWnEB_w/7xf16e-DarK6jxIs3AhhshLsVXztjBd-SbsYADge-Ys'), ('filename', 'download (8).png'), ('size', 5477), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/aC6yKl_T1raEU_-sksycZg/jgRx4xRgX0rQu4S4c2lB31A0FdI3FgKcuOsk21GHFRjRt7w6brSn2AGqU-9zI1EKs-7Ts1WEY1tLwYCtaKh4DA/DOkggpRnydc2A1GVQ2zGd8qyM4GlXUG0bekedCrrGog'), ('width', 147), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/rFjrR_1nPvTDYmbxVwNQ6w/KAZttTa2KdV-woeULA9uz8ffUsGiHxXv_z3mx6KwXn5PFOhvXMcQ_otAJY97PTTnBtUTLBnYkQ7EPau5_CQFfA/1eLxf05GowTjr-AGuESlll0SC6Gteyl1-VsrYIUARAo'), ('width', 453), ('height', 111)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VHeTUG37HlpgevBCjOgC3w/fWkX5uFc_llRM3uHwAknkeJG2AInvYMLhMVho6DClh5eIc2CERaIv3qO4f4tAvVHWodRXllYgJiIfAOYmLQTow/tM7LdRzNMEoNNQS-1nOwXx8oCxKUCGZwrX9VsLR0lHE'), ('width', 3000), ('height', 3000)]))]))])]",https://singlequantum.com/,Singlequantum,Write a Python script that uses Qcodes Community to connect to a {Device name} Photon Counting System,,,,,"""""""
The MIT License (MIT)

Copyright (c) 2020 Single Quantum B. V.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
""""""

import numpy as np
import socket
import json
import threading
import time
import sys

from qcodes.instrument.ip import Instrument
from qcodes.instrument.base import Parameter
from qcodes.instrument.parameter import ParameterWithSetpoints, MultiParameter
from qcodes.utils.validators import Arrays


class SQTalk(threading.Thread):
    def __init__(self, TCP_IP_ADR='localhost', TCP_IP_PORT=12000,
                 error_callback=None):
        threading.Thread.__init__(self)
        self.TCP_IP_ADR = TCP_IP_ADR
        self.TCP_IP_PORT = TCP_IP_PORT

        self.socket = socket.socket(
            socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.TCP_IP_ADR, self.TCP_IP_PORT))
        self.socket.settimeout(.1)
        self.BUFFER = 10000000
        self.shutdown = False
        self.labelProps = dict()

        self.error_callback = error_callback

        self.lock = threading.Lock()

    def close(self):
        # Print(""Closing Socket"")
        self.socket.close()
        self.shutdown = True

    def send(self, msg):
        self.socket.send(bytes(msg, ""utf-8""))

    def sub_jsons(self, msg):
        """"""Return sub json strings.
        {}{} will be returned as [{},{}]
        """"""
        i = 0
        result = []
        split_msg = msg.split('}{')
        for s in range(len(split_msg)):
            if i == 0 and len(split_msg) == 1:
                result.append(split_msg[s])
            elif i == 0 and len(split_msg) > 1:
                result.append(split_msg[s] + ""}"")
            elif i == len(split_msg) - 1 and len(split_msg) > 1:
                result.append(""{"" + split_msg[s])
            else:
                result.append(""{"" + split_msg[s] + ""}"")
            i += 1
        return result

    def add_labelProps(self, data):
        if ""label"" in data.keys():
            # After get labelProps, queries also bounds, units etc...
            if isinstance(data[""value""], (dict)):
                self.labelProps[data[""label""]] = data[""value""]
            # General label communication, for example from broadcasts
            else:
                try:
                    self.labelProps[data[""label""]
                                    ][""value""] = data[""value""]
                except Exception:
                    None

    def check_error(self, data):
        if ""label"" in data.keys():
            if ""Error"" in data[""label""]:
                self.error_callback(data[""value""])

    def get_label(self, label):
        timeout = 10
        dt = .1
        i = 0
        while True:
            if i * dt > timeout:
                raise IOError(""Could not acquire label"")
            try:
                return self.labelProps[label]
            except Exception:
                self.send(json.dumps(
                    {""request"": ""labelProps"", ""value"": ""None""}))
                time.sleep(dt)
            i += 1

    def get_all_labels(self, label):
        return self.labelProps

    def run(self):
        self.send(json.dumps(
            {""request"": ""labelProps"", ""value"": ""None""}))
        rcv_msg = []

        while self.shutdown is False:
            try:
                rcv = """" + rcv_msg[1]
            except Exception:
                rcv = """"
            data = {}
            r = """"
            while ""\x17"" not in rcv:
                try:
                    r = str(self.socket.recv(self.BUFFER), 'utf-8')
                except Exception:
                    None
                rcv = rcv + r

            rcv_msg = rcv.split(""\x17"")

            for rcv_line in rcv_msg:
                rcv_split = self.sub_jsons(rcv_line)
                for msg in rcv_split:
                    try:
                        data = json.loads(msg)
                    except Exception:
                        None

                    with self.lock:
                        self.add_labelProps(data)
                        self.check_error(data)


class SQCounts(threading.Thread):
    def __init__(
            self,
            TCP_IP_ADR='localhost',
            TCP_IP_PORT=12345,
            CNTS_BUFFER=100):
        threading.Thread.__init__(self)
        self.lock = threading.Lock()
        self.rlock = threading.RLock()
        self.TCP_IP_ADR = TCP_IP_ADR
        self.TCP_IP_PORT = TCP_IP_PORT

        self.socket = socket.socket(
            socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.TCP_IP_ADR, self.TCP_IP_PORT))
        # self.socket.settimeout(.1)
        self.BUFFER = 1000000
        self.shutdown = False

        self.cnts = []
        self.CNTS_BUFFER = CNTS_BUFFER
        self.n = 0

    def close(self):
        # print(""Closing Socket"")
        self.socket.close()
        self.shutdown = True

    def get_n(self, n):
        n0 = self.n
        while self.n < n0 + n:
            time.sleep(0.001)
        cnts = self.cnts
        return cnts[-n:]

    def run(self):
        while self.shutdown is False:
            data_raw = str(self.socket.recv(self.BUFFER), 'utf-8')

            data_newline = data_raw.split('\n')

            v = []
            for d in data_newline[0].split(','):
                v.append(float(d))

            with self.lock:
                self.cnts.append(v)
                # Keep Size of self.cnts
                len_ = len(self.cnts)
                if len_ > self.CNTS_BUFFER:
                    self.cnts = self.cnts[len_ - self.CNTS_BUFFER:]
                self.n += 1


class ChannelArray(ParameterWithSetpoints):
    """"""Fetches the correct row from the matrix counters,  based on the channel
    This is a parameter with setpoints, where the setpoints are the time stamps
    Args:
        channel (int): the channel number to select the row from the counters matrix
    Return (numpy_array): a numpy vector of length npts, containing the counts
    """"""

    def __init__(self, channel, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._channel = channel

    def get_raw(self):
        return self.root_instrument.counters.get_latest()[
            self._channel]


class TimeArray(Parameter):
    """"""Fetches the row with time stamps, currently channel 0
    This parameter is used as the setpoints for the channelarray
    Args:
        channel (int): the channel number to select the row from the counters matrix (channel 0 is the timestamp)
    Return (numpy_array): a numpy vector of length npts, containing the time stamps
    """"""

    def __init__(self, channel, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._channel = channel

    def get_raw(self):
        return np.array(self.root_instrument.counters.get_latest()[
            self._channel])


class CommunicationHandler(object):
    """"""Handles the communication, creates JSON strings""""""

    def __init__(
            self,
            root_instrument,
            log,
            TCP_IP_ADR='localhost',
            CONTROL_PORT=12000,
            COUNTS_PORT=12345):
        self.root_instrument = root_instrument
        self.log = log
        self.TCP_IP_ADR = TCP_IP_ADR
        self.CONTROL_PORT = CONTROL_PORT
        self.COUNTS_PORT = COUNTS_PORT
        self.NUMBER_OF_DETECTORS = 0

        self.talk = SQTalk(
            TCP_IP_ADR=self.TCP_IP_ADR,
            TCP_IP_PORT=self.CONTROL_PORT,
            error_callback=self.error)
        # Daemonic Thread close when main progam is closed
        self.talk.daemon = True
        self.talk.start()

        self.cnts = SQCounts(TCP_IP_ADR=self.TCP_IP_ADR,
                             TCP_IP_PORT=self.COUNTS_PORT)
        # Daemonic Thread close when main progam is closed
        self.cnts.daemon = True
        self.cnts.start()

        self.NUMBER_OF_DETECTORS = self.talk.get_label(
            ""NumberOfDetectors"")[""value""]

    def acquire_cnts_t(self):
        """"""Acquire n count measurments transposed.
        Return (numpy_array): Acquired counts with timestamp in first row.
        """"""
        n = self.root_instrument.npts()
        cnts = self.cnts.get_n(n)
        return np.array(cnts).T

    def set_measurement_periode(self, t_in_ms):
        msg = json.dumps(
            dict(
                command=""SetMeasurementPeriod"",
                label=""InptMeasurementPeriod"",
                value=t_in_ms))
        self.talk.send(msg)

    def get_number_of_detectors(self):
        return self.talk.get_label(""NumberOfDetectors"")[""value""]

    def get_measurement_periode(self):
        """"""Get measurment periode in ms.
        Return (float): time
        """"""
        return self.talk.get_label(""InptMeasurementPeriod"")[""value""]

    def get_bias_current(self):
        return self.talk.get_label(""BiasCurrent"")[""value""]

    def get_trigger_level(self):
        return self.talk.get_label(""TriggerLevel"")[""value""]

    def get_bias_voltage(self):
        msg = json.dumps(dict(request=""BiasVoltage""))
        self.talk.send(msg)
        return self.talk.get_label(""BiasVoltage"")[""value""]

    def set_bias_current(self, current_in_uA):
        array = current_in_uA
        msg = json.dumps(dict(command=""SetAllBiasCurrents"",
                              label=""BiasCurrent"", value=array))
        self.talk.send(msg)

    def set_trigger_level(self, trigger_level_mV):
        array = trigger_level_mV
        msg = json.dumps(dict(command=""SetAllTriggerLevels"",
                              label=""TriggerLevel"", value=array))
        self.talk.send(msg)

    def enable_detectors(self, state=True):
        msg = json.dumps(dict(command=""DetectorEnable"",
                              label=""DetectorEnable"", value=state))
        self.talk.send(msg)

    def set_dark_counts_auto_iv(self, dark_counts):
        """"""Set the dark counts for the automatic detector calibration.
        After this command execute: self.auto_cali_bias_currents()
        """"""
        if self.NUMBER_OF_DETECTORS != len(dark_counts):
            raise ValueError(
                'Dark counts not the same lenght as number of detectors')
        else:
            msg = json.dumps(
                dict(
                    command=""DarkCountsAutoIV"",
                    label=""DarkCountsAutoIV"",
                    value=dark_counts))
            self.talk.send(msg)

    def auto_cali_bias_currents(self):
        """"""Performs the automatic bias calibration. Make sure that no light reaches the detectors during this procedure.
        To check if this function has finished use self.auto_cali_finished() which return true or false.
        """"""
        msg = json.dumps(
            dict(
                command=""AutoCaliBiasCurrents"",
                value=True))
        self.talk.send(msg)

    def auto_cali_finished(self):
        """"""Check if auto calibration of the bias currents to find a given dark count value has finished.
        Returns: True if finished, False otherwise
        """"""
        msg = json.dumps(dict(request=""StartAutoIV""))
        self.talk.send(msg)
        return not(self.talk.get_label(""StartAutoIV"")[""value""])

    def error(self, error_msg):
        """"""Called in case of an error""""""
        self.log.warning(""ERROR DETECTED"")
        self.log.warning(error_msg)


class WebSQControlqcode(Instrument):
    """"""The instrument.

    IMPORTANT: the QCoDeS parameter 'counters' updates the time stamp and counters from the detectors.
    Always call 'counters' if you want to fetch the next 'npts' counts.
    """"""

    def __init__(self, name, address, port, **kwargs):
        # super().__init__(name, address, port, **kwargs)
        super().__init__(name, **kwargs)

        self.TCP_IP_ADR = address
        self.CONTROL_PORT = port
        self.COUNTS_PORT = 12345
        self.NUMBER_OF_DETECTORS = 0

        self.comm = CommunicationHandler(self.root_instrument, self.log,
                                         self.TCP_IP_ADR, self.CONTROL_PORT, self.COUNTS_PORT)

        self.NUMBER_OF_DETECTORS = self.comm.talk.get_label(
            ""NumberOfDetectors"")[""value""]

        self.add_parameter(
            'bias_current',
            unit='uA',
            get_cmd=self.comm.get_bias_current,
            set_cmd=self.comm.set_bias_current,
            docstring='Bias current setting'
        )

        self.add_parameter(
            name='npts',
            initial_value=1,
            label='Number of points',
            get_cmd=None,
            set_cmd=None,
            docstring='Number of points to acquire (see measurement_periode)'
        )

        self.add_parameter(
            'detectors',
            get_cmd=self.comm.enable_detectors,
            set_cmd=None,
            docstring='Enables/disables the detectors'
        )

        self.add_parameter(
            'number_of_detectors',
            get_cmd=self.comm.get_number_of_detectors,
            set_cmd=None,
            docstring='Gets the number of detectors in the instrument'
        )

        self.add_parameter(
            'counters',
            get_cmd=self.comm.acquire_cnts_t,
            docstring='Acquire points'
        )

        self.add_parameter(
            'measurement_periode',
            unit='ms',
            get_cmd=self.comm.get_measurement_periode,
            set_cmd=self.comm.set_measurement_periode,
            docstring='Measurement periode setting, determines the time that each point counts'
        )

        self.add_parameter(
            'timing',
            unit='ms',
            label='Time',
            parameter_class=TimeArray,
            channel=0,
            vals=Arrays(shape=(self.npts.get_latest, )),
            docstring='Parameter with timestamps for each point acquired'
        )

        for i in range(self.NUMBER_OF_DETECTORS):
            channel = i + 1
            name = 'channel' + str(channel)

            self.add_parameter(
                name,
                unit='',
                label='Counts',
                parameter_class=ChannelArray,
                channel=channel,
                setpoints=(self.timing,),
                vals=Arrays(shape=(self.npts.get_latest, )),
                snapshot_value=True,
                docstring='Parameter with setpoints with the counts for each point acquired'
            )

        self.add_parameter(
            'trigger_level',
            unit='mV',
            get_cmd=None,
            set_cmd=self.comm.set_trigger_level,
            docstring='Trigger level setting'
        )

        self.add_parameter(
            'bias_voltage',
            unit='mV',
            get_cmd=self.comm.get_bias_voltage,
            set_cmd=None,
            docstring='Gets the bias voltage'
        )

        self.connect_message()
"
376,https://docs.zhinst.com/pdf/ziHDAWG_UserManual.pdf,,"[OrderedDict([('id', 'attDrX4Vlwjak4Pks'), ('width', 1183), ('height', 549), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZCKrGmt1XxFrGeTkGBpE0w/3ddbJZfeGHPuB6dZj-3AT3jrkkZvjZ-FPe89AOzXmKo3vIgR6aVy0cPpaxdKWnWbDUMNtnHTZIrICPZSfY4jG9L_hiLG2G_0T8NsVUDGO3F64q2KjV9FNatxPMlYP91j/O9-PDuhhiI_h5RnhaNAaa-XK-Q0hNLaxt9A9yaO6zGQ'), ('filename', 'hdawg8_front_2560.jpg.webp'), ('size', 57176), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/L3dhG3j4UC3xJbfvkc-v0w/v5X71qxL5G2bBxJaHMs-_avCwYL0liT06MZ_N0ITDEm9lUW5nohAWvrKUE7tZoMSIXMG8n7Ze_ZrPU1AeQ76RoApgkkPKk_cO7Iue3cJQj4/NhVKlpR3UIR0F5QQfFw6w3qc1EnitS5AQikGk8HmWnI'), ('width', 78), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5qPMfCry-z96ASR-GFCbdw/kNqoigftCAnkXmVM9qPFOqO0ZqrSBszgq7aD6nmNP2XGYxTlwLR4m4wgcWo1Pir6y2PejwLdLodaAfRNaIcE-Ad96J1LfcQVzIR7vWTuOKg/NwofTdDfUHYKLOWSy04if_7VmGV65PJizQNLmlX9Xps'), ('width', 1103), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iXFnqXnm541lVxBrIdtuhQ/V24g5Abhhab6I-q3T9ukGO2xnP6CzERsTm0w5vxNtXqiVtbsScO9UFFx9oa4bUpLoYYmPMl1auoe34vO9GoItagSTaM5hI7KrWzpLkjuNjc/p_pQmgarIvlM4lUWu2DEGo2M-Xi_9SjrkFo0yG9csp4'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,"The Zurich Instruments HDAWG multi-channel Arbitrary Waveform Generator has one of the highest channel densities available in its class and is designed for advanced signal generation up to 750 MHz bandwidth. The HDAWG comes with either 4 or 8 DC-coupled, single-ended analog output channels with 16-bit vertical resolution.",https://zhinst.com/americas/en/products/hdawg-arbitrary-waveform-generator,Zihdawg 8,649.0,['Wavemeters'],,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/ZurichInstruments/ZIHDAWG8.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/ZurichInstruments/ZIHDAWG8.py,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Nhkgwh64AuogSl3HWobl2Q/rQDQ1GNPkIq-GhACurIJJZxLiHEOnOLLRIBSwQeiBMmaqHOy-wUrt2n-Tvpfw5hH3Eup_ifOZhM4n8m8pq0CjxZGl3pAfV6mMXnkolSlybCNocXKouqbYzfqcK4jFdpD/SKZVV7j5hDwPZHgu_Q5i9AQeRpkYKkinzBJbAiBFkuo'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/DV0ujSSrAJU3tHZZcN2NSA/8JeKB-Jpys2BIlZqsTAHmKF9-jppmBKmGmlEckoBtdN8otIRJNHyuxBKfLYD4vVAfyFOOlwoyM97SmbnXOYYLA/PiE1JpBZIGxy_o-SWd1tiSrP9Na18_Qk_oQ8Sd8B-YE'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FzFWiuhLcQdI5sgfhFAmrg/qGaYae2vNfXTXgUkvbw50ZwzoArdYDJ_xZ5wEBpjRyZNb6jJOPuIyl16l6PZNtxyHWLGuBUAUm4M_4MT4MQzXg/pCT8wFuAw7yLVs0L6AqPzTW6k9UOYWw_3452tjsMAnQ'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/AZ4g8jrEIKeTJWaFe2R2zg/rTqIW8FwmQdlkRyUz-N2OYEK6zt0fmq12VCQVFsiVyar5I6-eMdHqr_VWX0OYsBuKeP1MqV_p4lyzDDba34jVQ/JiXFWfnDh71ZNiYlld55xkwWB-aibfR43E5ET7IZntI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,HDAWG,Write a Python script that uses Qcodes Community to connect to a HDAWG Wavemeters,,,,,"import csv
import json
import os
import re
import textwrap
import time
from functools import partial
from typing import Any, List, Tuple, Union, Sequence, Dict, Optional

import numpy as np
import zhinst.utils

from qcodes import Instrument
from qcodes.utils import validators as validators

WARNING_CLIPPING = r""^Warning \(line: [0-9]+\): [a-zA-Z0-9_]+ has a higher "" \
                   r""amplitude than 1.0, waveform amplitude will be limited "" \
                   r""to 1.0$""
WARNING_TRUNCATING = r""^Warning \(line: [0-9]+\): waveform \S+ cut "" \
                     r""down to playable length from [0-9]+ to [0-9]+ samples "" \
                     r""\(should be a multiple of 8 samples for single channel"" \
                     r"" or 4 samples for dual channel waveforms\)$""
WARNING_ANY = r""^Warning \(line: [0-9]+\):.*$""


class CompilerError(Exception):
    """""" Errors that occur during compilation of sequence programs.""""""


class ZIHDAWG8(Instrument):
    """"""
    QCoDeS driver for ZI HDAWG8.
    Requires ZI LabOne software to be installed on the computer running QCoDeS
    (tested using LabOne 18.05.54618 and firmware 53866).
    Furthermore, the Data Server and Web Server must be running and a connection
    between the two must be made.

    Compiler warnings, when uploading and compiling a sequence program, can
    be treated as errors. This is desirable if the user of the driver does
    not want clipping or truncating of waveform to happen silently by the
    compiler. Warnings are constants on the module level and can be added to the
    drivers attribute ``warnings_as_errors``. If warning are added, they
    will raise a CompilerError.
    """"""

    def __init__(self, name: str, device_id: str, **kwargs) -> None:
        """"""
        Create an instance of the instrument.

        Args:
            name: The internal QCoDeS name of the instrument
            device_ID: The device name as listed in the web server.
        """"""
        super().__init__(name, **kwargs)
        self.api_level = 6
        (self.daq, self.device, self.props) = zhinst.utils.create_api_session(
            device_id, self.api_level,
            required_devtype='HDAWG')
        self.awg_module = self.daq.awgModule()
        self.awg_module.set('awgModule/device', self.device)
        self.awg_module.execute()
        node_tree = self.download_device_node_tree()
        self.create_parameters_from_node_tree(node_tree)
        self.warnings_as_errors: List[str] = []
        self._compiler_sleep_time = 0.01

    def snapshot_base(self, update: Optional[bool] = True,
                      params_to_skip_update: Optional[Sequence[str]] = None
                      ) -> Dict:
        """""" Override the base method to ignore 'feature_code' by default.""""""
        params_to_skip = ['features_code']
        if params_to_skip_update is not None:
            params_to_skip += list(params_to_skip_update)
        return super(ZIHDAWG8, self).snapshot_base(update=update,
                                                   params_to_skip_update=params_to_skip)

    def snapshot(self, update=True):
        """""" Override base method to make update default True.""""""
        return super(ZIHDAWG8, self).snapshot(update)

    def enable_channel(self, channel_number: int) -> None:
        """"""
        Enable a signal output, turns on a blue LED on the device.

        Args:
            channel_number: Output channel that should be enabled.
        """"""
        self.set('sigouts_{}_on'.format(channel_number), 1)

    def disable_channel(self, channel_number: int) -> None:
        """"""
        Disable a signal output, turns off a blue LED on the device.

        Args:
            channel_number: Output channel that should be disabled.
        """"""
        self.set('sigouts_{}_on'.format(channel_number), 0)

    def start_awg(self, awg_number: int):
        """"""
        Activate an AWG

        Args:
            awg_number: The AWG that should be enabled.
        """"""
        self.set('awgs_{}_enable'.format(awg_number), 1)

    def stop_awg(self, awg_number: int) -> None:
        """"""
        Deactivate an AWG

        Args:
            awg_number: The AWG that should be disabled.
        """"""
        self.set('awgs_{}_enable'.format(awg_number), 0)

    def waveform_to_wave(self, wave_name: str, waveform: np.ndarray) -> None:
        """"""
        Write waveforms to a .wave file in the modules data directory so that it
        can be referenced and used in a sequence program.

        Args:
            wave_name: Name of the wave file, is used by a sequence program.
            waveforms: Waveforms that is to be written to a .wave file.
        """"""
        data_dir = self.awg_module.getString('awgModule/directory')
        wave_dir = os.path.join(data_dir, ""awg"", ""waves"")
        if not os.path.isdir(wave_dir):
            raise Exception(f""AWG module wave directory {wave_dir} does not exist or is not a directory"")
        wave_file = os.path.join(wave_dir, wave_name + '.wave')

        wave_array = zhinst.utils.convert_awg_waveform(waveform)
        wave_array.tofile(wave_file)

    def waveform_to_csv(self, wave_name: str, *waveforms: list) -> None:
        """"""
        Write waveforms to a CSV file in the modules data directory so that it
        can be referenced and used in a sequence program. If more than one
        waveform is provided they will be played simultaneously but on separate
        outputs.

        Args:
            wave_name: Name of the CSV file, is used by a sequence program.
            waveforms: One or more waveforms that are to be written to a
                CSV file. Note if there are more than one waveforms then they
                have to be of equal length, if not the longer ones will be
                truncated.
        """"""
        data_dir = self.awg_module.getString('awgModule/directory')
        wave_dir = os.path.join(data_dir, ""awg"", ""waves"")
        if not os.path.isdir(wave_dir):
            raise Exception(
                ""AWG module wave directory {} does not exist or is not a ""
                ""directory"".format(
                    wave_dir))
        csv_file = os.path.join(wave_dir, wave_name + '.csv')
        with open(csv_file, ""w"", newline='') as f:
            writer = csv.writer(f, delimiter=';')
            writer.writerows(zip(*waveforms))

    @staticmethod
    def generate_csv_sequence_program(wave_info: List[
        Tuple[int, Union[str, None], Union[str, None]]]) -> str:
        """"""
        A method that generates a sequence program that plays waveforms from
        csv files.

        Args:
            wave_info: A list of tuples containing information about the waves
                that are to be played. Every tuple should have a channel number
                and wave, marker or both wave and marker.

        Returns:
            A sequence program that can be compiled and uploaded.

        """"""
        awg_program = textwrap.dedent(""""""
                HEADER
                DECLARATIONS
                while(true){
                    playWave(WAVES);
                }
                """""")
        sequence_header = '// generated by {}\n'.format(__name__)
        awg_program = awg_program.replace('HEADER', sequence_header)
        declarations = ZIHDAWG8._generate_declarations(wave_info)
        awg_program = awg_program.replace('DECLARATIONS', declarations)
        play_wave_arguments = ZIHDAWG8._get_waveform_arguments(wave_info)
        awg_program = awg_program.replace('WAVES', play_wave_arguments)
        return awg_program

    @staticmethod
    def _generate_declarations(wave_info):
        declarations = """"
        for _, wave, marker in wave_info:
            if wave is not None and marker is not None:
                declarations += ('wave {0} = ""{0}"";\n'.format(wave))
                declarations += ('wave {0} = ""{0}"";\n'.format(marker))
                declarations += ('{0} = {0} + {1};\n'.format(wave, marker))
            elif wave is not None:
                declarations += ('wave {0} = ""{0}"";\n'.format(wave))
            elif marker is not None:
                declarations += ('wave {0} = ""{0}"";\n'.format(marker))
        return declarations

    @staticmethod
    def _get_waveform_arguments(wave_info):
        argument_string = ('{}, {}' * len(wave_info)).replace('}{', '}, {')
        play_wave_arguments = []
        for channel, wave, marker in wave_info:
            play_wave_arguments.append(channel)
            wave = wave if wave is not None else marker
            play_wave_arguments.append(wave)
        return argument_string.format(*play_wave_arguments)

    def upload_sequence_program(self, awg_number: int,
                                sequence_program: str) -> int:
        """"""
        Uploads a sequence program to the device equivalent to using the the
        sequencer tab in the device's gui.

        Args:
            awg_number: The AWG that the sequence program will be uploaded to.
            sequence_program: A sequence program that should be played on the
                device.

        Returns:
            0 is Compilation was successful with no warnings.
            2 if Compilation was successful but with warnings.

        Raises:
            CompilerError: If error occurs during compilation of the sequence
                program, or if a warning is elevated to an error.
        """"""
        self.awg_module.set('awgModule/index', awg_number)
        self.awg_module.set('awgModule/compiler/sourcestring', sequence_program)
        while len(self.awg_module.get('awgModule/compiler/sourcestring')
                  ['compiler']['sourcestring'][0]) > 0:
            time.sleep(self._compiler_sleep_time)

        if self.awg_module.getInt('awgModule/compiler/status') == 1:
            raise CompilerError(
                self.awg_module.getString('awgModule/compiler/statusstring'))
        elif self.awg_module.getInt('awgModule/compiler/status') == 2:
            self._handle_compiler_warnings(
                self.awg_module.getString('awgModule/compiler/statusstring'))
        while self.awg_module.getDouble('awgModule/progress') < 1.0:
            time.sleep(self._compiler_sleep_time)

        return self.awg_module.getInt('awgModule/compiler/status')

    def _handle_compiler_warnings(self, status_string: str) -> None:
        warnings = [warning for warning in status_string.split('\n') if
                    re.search(WARNING_ANY, warning) is not None]
        errors = []
        for warning in warnings:
            for warning_as_error in self.warnings_as_errors:
                if re.search(warning_as_error, warning) is not None:
                    errors.append(warning)
            if warning not in errors:
                self.log.warning(warning)
        if len(errors) > 0:
            raise CompilerError('Warning treated as an error.', *errors)

    def upload_waveform(self, awg_number: int, waveform: list,
                        index: int) -> None:
        """"""
        Upload a waveform to the device memory at a given index.

        Note:
            There needs to be a place holder on the device as this only replaces
            a data in the device memory but does not allocate new memory space.

        Args:
            awg_number: The AWG where waveform should be uploaded to.
            waveform: An array of floating point values from -1.0 to 1.0, or
                integers in the range (-32768...+32768)
            index: Index of the waveform that will be replaced. If there are
                more than 1 waveforms used then the index corresponds to the
                position of the waveform in the Waveforms sub-tab of the AWG tab
                in the GUI.
        """"""
        self.set('awgs_{}_waveform_index'.format(awg_number), index)
        self.daq.sync()
        self.set('awgs_{}_waveform_data'.format(awg_number), waveform)

    def set_channel_grouping(self, group: int) -> None:
        """"""
        Set the channel grouping mode of the device.

        Args:
            group: 0: groups of 2. 1: groups of 4. 2: groups of 8 i.e., one
                sequencer program controls 8 outputs.
        """"""
        self.set('system_awg_channelgrouping', group)

    def create_parameters_from_node_tree(self, parameters: dict) -> None:
        """"""
        Create QuCoDeS parameters from the device node tree.

        Args:
            parameters: A device node tree.
        """"""
        for parameter in parameters.values():
            getter = partial(self._getter, parameter['Node'],
                             parameter['Type']) if 'Read' in parameter[
                'Properties'] else None
            setter = partial(self._setter, parameter['Node'],
                             parameter['Type']) if 'Write' in parameter[
                'Properties'] else False
            options = validators.Enum(
                *[int(val) for val in parameter['Options'].keys()]) \
                if parameter['Type'] == 'Integer (enumerated)' else None
            parameter_name = self._generate_parameter_name(parameter['Node'])
            self.add_parameter(name=parameter_name,
                               set_cmd=setter,
                               get_cmd=getter,
                               vals=options,
                               docstring=parameter['Description'],
                               unit=parameter['Unit']
                               )

    @staticmethod
    def _generate_parameter_name(node):
        values = node.split('/')
        return '_'.join(values[2:]).lower()

    def download_device_node_tree(self, flags: int = 0) -> dict:
        """"""
        Args:
            flags:
                ziPython.ziListEnum.settingsonly (0x08): Returns only nodes
                which are marked as setting
                ziPython.ziListEnum.streamingonly (0x10): Returns only
                streaming nodes
                ziPython.ziListEnum.subscribedonly (0x20): Returns only
                subscribed nodes
                ziPython.ziListEnum.basechannel (0x40): Return only one instance
                of a node in case of multiple channels

                Or any combination of flags can be used.

        Returns:
            A dictionary of the device node tree.
        """"""
        node_tree = self.daq.listNodesJSON('/{}/'.format(self.device), flags)
        return json.loads(node_tree)

    def _setter(self, name: str, param_type: str, value: Any) -> None:
        if param_type == ""Integer (64 bit)"" or \
                param_type == 'Integer (enumerated)':
            self.daq.setInt(name, value)
        elif param_type == ""Double"":
            self.daq.setDouble(name, value)
        elif param_type == ""String"":
            self.daq.setString(name, value)
        elif param_type == ""ZIVectorData"":
            self.daq.vectorWrite(name, value)

    def _getter(self, name: str, param_type: str) -> Any:
        if param_type == ""Integer (64 bit)"" or \
                param_type == 'Integer (enumerated)':
            return self.daq.getInt(name)
        elif param_type == ""Double"":
            return self.daq.getDouble(name)
        elif param_type == ""String"":
            return self.daq.getString(name)
        elif param_type == ""ZIVectorData"":
            return self.daq.getAsEvent(name)
"
377,,,,367.3,"Abingdon, United Kingdom",,,Kelvinox,396.0,,,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://qcodes.github.io/Qcodes_contrib_drivers/_modules/qcodes_contrib_drivers/drivers/Oxford/kelvinox.html#OxfordInstruments_Kelvinox_IGH,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Oxford.html#qcodes_contrib_drivers.drivers.Oxford.kelvinox.OxfordInstruments_Kelvinox_IGH,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Y_6-qvrLUbX3UWbyIcHbgQ/4dkRL2i6ehKYPq2XsN-_7uhD1kytqs2h_Ze0kMEKut9Fvjb9A7PF18KjlvYBlNKdtpyAzcr6rDtUxwMu-3DdVyvV_kqD7VHCwvNZkdi_ZZQ/wkMbsMuSXvhAwG1mMXHayw8Qy-vSPyl0bAYt3zx6l-g'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/cfffXlD5ASxTnp78JUzIaA/i2F1xVP4TOsAl1Leq188vYRR6RvsWrQslhK2ajYXkuBDhG04IcF309n2qgWp-io1G2N5HDu_ADfraamLLGM--g/LJ3NHogm9R8legLTmReuTVP5PjqPSEaPg1RHaqW3kiY'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ANarfozobYPgYKtJuIJsWQ/IKd3zp1wzTi3GeF91pPBD8Ez7C5DNOjTK5QPT0kYrB09jqVfyl9sBYMtJOwuIpxyHlOh5CDR3MSWC5TSlw8ZTw/yZVCIhWYW_fPD0KpL1DUpSw7-sMm_C_jVmpO9Nlp0UA'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/xkx_TAnkplww1LDxk9W3SA/o-OYEUZB05-StGWB0Wg3TO9AWpeQ7z1fGzP8LNnMByL0geOOTU-4R1vQX49-M_m-hK0oelGX8WoWdZmflXxSwA/ueaFgoiP4CGYFuPw0p0E_zfzbBh_S6xau545LdedmQs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Kelvinox,Write a Python script that uses Qcodes Community to connect to a {Device name} ,,,,,
381,https://www.lakeshore.com/docs/default-source/product-downloads/331_manual.pdf?sfvrsn=5ed3bf08_1,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attpTGvKOo21mFXrh'), ('width', 505), ('height', 273), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ME4iGD3g1ABcl9f8R31tZA/bLyhsq7F-UzTh-CuKEOz1qfC_b8QWIGwtdAWWHHLSEcH7vAHrmRCdDvNleAaFaFBpR5S8VYvj9RZVendQBCGMA/lqE1GB1b6J-9A5pVMn-nGsp-_hM8XQBaGhbhEpcm-5E'), ('filename', '331.png'), ('size', 155224), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/5jzAd1tamCHomcy1Z4IVjQ/YKfh-6thcoe5BoOuRLlO3yvB4xhwcxB49QOFVcWy9CBv7GFD0FpFI8FDbla_gWrrsONueMJOIS7xuVMxw-RYXA/ldllmeBV8KhVDtRgoY34g9cVOdXlmBGq7YnKFlNvmvc'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/vkCvglvKMGtytgoFHbT43Q/b1toM5PfskYuSSuOGwofaoXac2iyJGRcMTrujD2S7SknhoqenRCBvgqUABBVClWGrUaBSmznlY2pqSmwqL_Z3w/qhHL9WdFlXVfcKgYsoRCtcUnJHv_3deCySDL8mAYqlQ'), ('width', 505), ('height', 273)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/1eRwwIVrYAq-ebWyZPGBGw/0eqBE2lO3OTkoEr7xS-wWG26N-i0D0LdlxsTO8lL6YwWYXfuXZO1KtevnFGBNfeTWVyeaZZ9Pfhn68_BqLEXmA/9fTjHbuyRxmVssr-tcrBvCAfk4unc_x0s7NW5dPEf-s'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA","The Model 331 cryogenic temperature controller combines the easy operation and unsurpassed reliability of the Model 330 with improved sensor input and interface flexibility, including compatibility with negative temperature coefficient (NTC) resistance temperature detectors (RTDs). Backed by the Lake Shore tradition of excellence in cryogenic sensors and instrumentation, the Model 331 temperature controller sets the standard for mid-price range temperature control instruments.",https://www.lakeshore.com/products/categories/overview/discontinued-products/discontinued-products/model-331-cryogenic-temperature-controller,Model 331,352.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Lakeshore/Model_331.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/Lakeshore_311.html,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PWH-0qXMZ-YU6DxH9_bh1w/RTmN9aXU4KJU4p1BTrMg9gf94-lTVxTS34gThfTqkvlk8ehlyiUI8488ttSgn8EJ9YLN8neaJUqBIT1GTgjpAmy4IFkL_Q6I3ZSmFM-pcVY/RMyxaTdA3wiMIIQR-w3LlzNIrOj9fh1QsU0moRZSKC8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Wnm-4-kXGmjsAAihAwlzww/P2ZJJuZ8Njhi0sHBoJSP9W600OU1Hy1tbGMOj_pETpY-k94kRAEnjTn8Ywq7oALl_BhGVUX9843ad56Kc-kKWHkeNEwCcNDiQZjj-txr9KM/ARzEi-tVwwTlLAFXFxt5Z18jdBIwByAScKcgRUWcOJQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hOJVFSF5xKDDpZjUQa2mKA/23HPggxz1ldiOlaTxdnrQt3myY6aOXyxHX5_8sL6vSxhAHqj0vIbThwV7DuYiRdnWcdlDiWYrVY49iFcxZ60wSOvf3gKTR50xTTwvAzMF-8/rlCQdCo_WbAlL3m8JHwt0DF4sUWUxmzNx3vXa0_hYIc'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VnPm6FsrkfnwRFKwB4J2BA/Uci9khKt3BCmCsF6Jr5NI6ga5vrXKVezaXU_yALJw1McVqPn_nmgbFrLvxeG2vTbXL-LH3BS_n7vJb8moOaD9tL7a2F22-iVR6hLloyfHdQ/zkMC_8IpnH6D5WfvMmpS1Zw1XDj91XWOeeucYksrlHY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Model 331,Write a Python script that uses Qcodes Community to connect to a {Device name} Temperature Controllers,,,True,,"from qcodes import VisaInstrument, InstrumentChannel, ChannelList
from qcodes.utils.validators import Enum


class SensorChannel(InstrumentChannel):
    """"""
    Channel class for the Lakeshore 331.

    Args:
        parent: The parent Lakeshore 331.
        name: The channel name.
        channel: The channel ID.

    Attributes:
        channel: The channel ID.
    """"""

    _channel_values = Enum('A', 'B')

    def __init__(self, parent: ""Model_331"", name: str, channel: str):
        super().__init__(parent, name)

        # validate the channel value
        self._channel_values.validate(channel)
        self.channel = channel

        # add parameters
        self.add_parameter('temperature',
                           get_cmd='KRDG? {}'.format(self.channel),
                           get_parser=float,
                           label='temperature {}'.format(self.channel),
                           unit='K')

        self.add_parameter('sensor_raw',
                           get_cmd='SRDG? {}'.format(self.channel),
                           get_parser=float,
                           label='sensor raw {}'.format(self.channel),
                           unit=u""\u03A9"")  # TODO: this will vary based on sensor type

        self.add_parameter('sensor_status',
                           get_cmd='RDGST? {}'.format(self.channel),
                           val_mapping={
                               'ok': 0,
                               'invalid reading': 1,
                               'temp underrange': 16,
                               'temp overrange': 32,
                               'sensor units zero': 64,
                               'temp overrange, sensor units zero': 96,
                               'Sensor Units Overrange': 128,
                               'temp underrange, sensor units overrange': 144},
                           label='sensor status {}'.format(self.channel))


class Model_331(VisaInstrument):
    """"""
    Instrument class for the Lakeshore 331.

    Args:
        name: The channel name.
        address: The GPIB address.
    """"""

    _loop = 1

    def __init__(self, name: str, address: str, **kwargs):
        super().__init__(name, address, terminator=""\r\n"", **kwargs)

        # add channels
        channels = ChannelList(self, ""TempSensors"", SensorChannel, snapshotable=False)
        for channel_id in ('A', 'B'):
            channel = SensorChannel(self, 'Chan{}'.format(channel_id), channel_id)
            channels.append(channel)
            self.add_submodule(channel_id, channel)
        channels.lock()
        self.add_submodule(""channels"", channels)

        # add parameters
        self.add_parameter('heater_output',
                           get_cmd='HTR?',
                           get_parser=float,
                           label='heater output',
                           unit='%')

        self.add_parameter('heater_range',
                           get_cmd='RANGE?',
                           get_parser=int,
                           set_cmd='RANGE {}',
                           val_mapping={
                               'off': 0,
                               '0.5W': 1,
                               '5W': 2,
                               '50W': 3},
                           label='heater range')

        self.add_parameter('input',
                           get_cmd='CSET? %i' % self._loop,
                           set_cmd='CSET ' + str(self._loop) + ',{},1,1,1',
                           get_parser=lambda ans: ans[0],
                           label='input')

        self.add_parameter('setpoint',
                           get_cmd='SETP? '+str(self._loop),
                           set_cmd='SETP ' + str(self._loop) + ', {}',
                           get_parser=float,
                           label='setpoint',
                           unit='K')

        # print connect message
        self.connect_message()
"
382,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attUTENiRF6l0AFcO'), ('width', 327), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/sGNEAE4l_R6Xk9Urz_tyiw/mmys9GuiT2axqHYeqL9eUV4r5zKzCmvkRu7jCg_GbsHScAP_s9ExJg5cCb1__9hFnhq2oOlOHXLz2E0qhau1gNnOoxcbj0KKwNOtoke_vhc/93qRwmsbtyav37FP7OK4hJtfbrjFft67m3B2aXcestA'), ('filename', 'vaunix-lda-602q.png'), ('size', 121735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZvFqd1XuSOeW5geWRvgOrg/AvHhfkGK2vCq1_YT-FZfaJFU7Y4sDiiIbAfl4MY6u31P9QQYspCAc-8G8LAPHnGJRfwX5_pknD6-U0KPp-YGZQ/kqYkN6BIYe1b_7qhDDNw4bGNxTqyOCpnzT0AyvgkAy8'), ('width', 30), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/nftQVbatbpiaWG4D2KLS9Q/O6F-0SvxM-6mALEgV-7aYFi2xo3jeUQkf_gsIgRE0R3_Xw0kVS72o6CDYqWVGjiER4VyO_fL2cmFFEdf5DDTbQ/aiS6ectJ7z9La8zUYFUe5heq249tkjGkVilYUrV2mYc'), ('width', 327), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9e3b7VvyCI-xja5pVCe9yg/BTskEdxS9jrZVTtOahGydB2h0nOuYoF6317W312e0M1Xo7ZXa0dkNgJ7a5rXIDovxN5r8xGN2rgRGglVKJBfmA/O8ErBnFZ0iTxyeKVhJ3B3yt07o6NCW-oCmKCACMqDi8'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-602Q Lab Brick USB programmable 50 Ohm high resolution digital attenuator has an input power of up to +28 dBm, and offers frequency coverage of 200 to 6,000 MHz. It has an attenuation range of 120 dB and a step size of 0.1 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-602q-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-602Q,Write a Python script that uses Qcodes Community to connect to a LDA-602Q ,2900.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
387,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attA12ZwM8fNa8gjn'), ('width', 824), ('height', 644), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/MfSNSub_MvPNSGT0erc-wg/gCsgILff-hD690zJkEfpP_ZgJFGDiXaol1R0nugRY1Ni85kTFOVi-fs7soZdsfQ_XkN28OHpBQsWFnqzQzmiv7Mf34_sDxkm3Xdh2wxR5IVwk9MuMiyVC67Q1RXNDyl7/fQdm5iBrQGKjodd2e2MDn--teaEbdP_2qLWeFUgZVTk'), ('filename', 'vaunix-digital-attenuator-602eh.png'), ('size', 818096), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/FDTFqaWU0-570WKdy0rwqQ/DhRBy2ARWEMvd2d69xdjSds0gauCDliOYm6djNMyFKUX4Q9nYG-t-BR7OMxaJAFOxldkk7TfIGNRzmrrrP2cKw/iJ_9IrjMhGA6pb4mVHRnvH1wpSNxxG0pXeFq58x2Qac'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/iwVC7Zo_7c8_TFOIao3mNQ/8L4Eh6eBbb_T1AgCon9l0_NvpajEgFNr2nmiKGNxMBAq_pxGvzQ1bH8DddHSLTOVyrRhfiuTga1cdXHfWc5A1g/YqQdn36hmOUyRrFXpbB7ouXOhGot1M7Sc2VDczRSbX4'), ('width', 655), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/aFGRQ3GaRNFc4QxceQCkWg/ZyvLpkogEIleTVKH2Zzd_IYPc5uV_EEQoZ9uyJdTSHFyTemv45fiL45vd8n6YViIGFAYj5AHv2WtYqgsCYtyEg/j7U9chyIKS7hMZg3oR7jLDUkdJn-rsBJyNFl1Y5SWPA'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-802EH Digital Attenuator is a high dynamic range, bidirectional, 50 Ohm step attenuator. The LDA-802EH provides 120 dB of attenuation control range from 200 to 8000 MHz with a step size of 0.1 dB. The attenuators are easily programmable for fixed attenuation, swept attenuation ramps and fading profiles directly from the included Graphical User Interface (GUI). Alternatively, for users wishing to develop their own interface, Vaunix supplies LabVIEW drivers, Windows API DLL files, Linux drivers, Python examples and much more.",https://vaunix.com/lda-802eh-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-802EH,Write a Python script that uses Qcodes Community to connect to a LDA-802EH ,875.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
389,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/lstc_625_l.pdf?sfvrsn=35bdc355_1,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attgwvzzpIaSMC8Ir'), ('width', 505), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/3mWyx5TrAV0H37qRG9n9Uw/czKza6eutCCXrlBgRCdf4c-3SdVW9mkTI7tJS1My1kYvunwln8BEOx_U5VKOAr7NHQL8lpiG_6DC42Z8lFyNBg/4Gkza37aYNidQC8c8tih78ssK-NHHazRXuhCqmVb7TM'), ('filename', '625.png'), ('size', 132679), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/K1M7Jjio8Pzihuc1rfhoDA/MK-KWnvn0MRS4xPQeToG2JLuxxujOsZt7xVOOUBboqgQK6DQOFSAly8VXaiVekeEIZQqtLGChl6Hr5ITd9I2-g/16rEJYiMRWaarjEuKaab20oRqKdOdvCIyQU2_BNBmI0'), ('width', 95), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/d8AT1sK7BdRQaeJkkmsgnw/rP7e-1wfEH585UQm9YnWxQHO78NRhnuqeqEv-m-OCo_P8eUwOu4wKgqpPcJpA_1-i-CmzmNObOsjYH7Xa4HEDA/yZUJdIveKvFzIx28n94NfGJaGZwuHVk59X-U01wHtWA'), ('width', 505), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/7rLtW5JNkWEkuKWGo3a2Ug/ASZ0CW-a0naTy86OJgy4DUQtWmz7rzYoZzAfP0GET_oB1oMGb_D09bHRBqdMT7z3NKtaSMN72JowYzdBHku1cw/omDBCm2x8oHhjd-jfT68XgBisuQ5J2UhWm2LzH9Xxb8'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA","The Model 625 superconducting magnet power supply is the ideal supply for small to medium sized superconducting magnets used in high sensitivity materials research applications. The Model 625 is a practical alternative to both the larger, one size fits all, superconducting magnet supplies and the endless adaptations of generic power supplies. By limiting output power, Lake Shore was able to concentrate on the performance requirements of the most demanding magnet users. The resulting Model 625 provides high precision, low noise, safety, and convenience.",https://www.lakeshore.com/products/categories/overview/material-characterization-products/superconducting-magnet-power-supply/model-625-superconducting-magnet-power-supply,Model 625,349.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Lakeshore/Model_625.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/examples/Lakeshore_625.html,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/PWH-0qXMZ-YU6DxH9_bh1w/RTmN9aXU4KJU4p1BTrMg9gf94-lTVxTS34gThfTqkvlk8ehlyiUI8488ttSgn8EJ9YLN8neaJUqBIT1GTgjpAmy4IFkL_Q6I3ZSmFM-pcVY/RMyxaTdA3wiMIIQR-w3LlzNIrOj9fh1QsU0moRZSKC8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Wnm-4-kXGmjsAAihAwlzww/P2ZJJuZ8Njhi0sHBoJSP9W600OU1Hy1tbGMOj_pETpY-k94kRAEnjTn8Ywq7oALl_BhGVUX9843ad56Kc-kKWHkeNEwCcNDiQZjj-txr9KM/ARzEi-tVwwTlLAFXFxt5Z18jdBIwByAScKcgRUWcOJQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/hOJVFSF5xKDDpZjUQa2mKA/23HPggxz1ldiOlaTxdnrQt3myY6aOXyxHX5_8sL6vSxhAHqj0vIbThwV7DuYiRdnWcdlDiWYrVY49iFcxZ60wSOvf3gKTR50xTTwvAzMF-8/rlCQdCo_WbAlL3m8JHwt0DF4sUWUxmzNx3vXa0_hYIc'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/VnPm6FsrkfnwRFKwB4J2BA/Uci9khKt3BCmCsF6Jr5NI6ga5vrXKVezaXU_yALJw1McVqPn_nmgbFrLvxeG2vTbXL-LH3BS_n7vJb8moOaD9tL7a2F22-iVR6hLloyfHdQ/zkMC_8IpnH6D5WfvMmpS1Zw1XDj91XWOeeucYksrlHY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Model 625,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,11951.0,,,,"import logging
import time
from typing import Union, Tuple


from qcodes import VisaInstrument
from qcodes.utils.validators import  Numbers, Enum


class Lakeshore625(VisaInstrument):
    """"""
    Driver for the Lakeshore Model 625 superconducting magnet power supply.

    This class uses T/A and A/s as units.

    Args:
        name (str): a name for the instrument
        coil_constant (float): Coil contant of magnet, in untis of T/A
        field_ramp_rate (float): Magnetic field ramp rate, in units of T/min
        address (str): VISA address of the device
    """"""

    def __init__(self, name: str, coil_constant: float,  field_ramp_rate: float, address: str,
                 reset: bool=False, terminator:str='', **kwargs) -> None:

        super().__init__(name, address, terminator=terminator, **kwargs)
    
        # Add reset function
        self.add_function('reset', call_cmd='*RST')
        if reset:
            self.reset()

        # Add power supply parameters
        self.add_parameter(name='current_limit',
                           unit=""A"",
                           set_cmd=self._set_curent_limit,
                           get_cmd=self._get_current_limit,
                           get_parser=float,
                           vals=Numbers(0, 60.1),
                           docstring=""Maximum output current""
                           )
        
        self.add_parameter(name='voltage_limit',
                           unit=""V"",
                           set_cmd=self._set_voltage_limit,
                           get_cmd=self._get_voltage_limit,
                           get_parser=float,
                           vals=Numbers(0, 5),
                           docstring=""Maximum compliance voltage""
                           )
        
        self.add_parameter(name='current_rate_limit',
                           unit=""A/s"",
                           set_cmd=self._set_current_rate_limit,
                           get_cmd=self._get_current_rate_limit,
                           get_parser=float,
                           vals=Numbers( 0.0001, 99.999),
                           docstring=""Maximum current ramp rate""
                           )
        
        self.add_parameter(name='voltage',
                           unit = 'V',
                           set_cmd=""SETV {}"",
                           get_cmd='RDGV?',
                           get_parser=float,
                           vals=Numbers(-5, 5)
                           )
        
        self.add_parameter(name='current',
                           unit = 'A',
                           set_cmd=""SETI {}"",
                           get_cmd='RDGI?',
                           get_parser=float,
                           vals=Numbers(-60, 60)
                           )
        
        self.add_parameter(name='current_ramp_rate',
                           unit = 'A/s',
                           set_cmd=""RATE {}"",
                           get_cmd='RATE?',
                           get_parser=float
                           )
        
        self.add_parameter(name='ramp_segments',
                           set_cmd=""RSEG {}"",
                           get_cmd='RSEG?',
                           get_parser=int,
                           val_mapping={'disabled': 0,
                                        'enabled': 1}
                           )
        
        self.add_parameter(name='persistent_switch_heater',
                           set_cmd=self._set_persistent_switch_heater_status,
                           get_cmd=self._get_persistent_switch_heater_status,
                           get_parser=int,
                           val_mapping={'disabled': 0,
                                        'enabled': 1}
                           )
    
        self.add_parameter(name='quench_detection',
                           set_cmd=self._set_quench_detection_status,
                           get_cmd=self._get_quench_detection_status,
                           get_parser=int,
                           val_mapping={'disabled': 0,
                                        'enabled': 1}
                           )
    
        self.add_parameter(name='quench_current_step_limit',
                           unit = 'A/s',
                           set_cmd=self._set_quench_current_step_limit,
                           get_cmd=self._get_quench_current_step_limit,
                           get_parser=float,
                           vals=Numbers(0.01, 10)
                           )

        self.add_parameter(name='ramping_state',
                           get_cmd=self._get_ramping_state,
                           vals=Enum('ramping', 'not ramping')
                           )
        
        self.add_parameter(name='operational_error_status',
                           get_cmd=self._get_operational_errors,
                           get_parser=str
                           )
        
        self.add_parameter(name='oer_quench',
                           get_cmd=self._get_oer_quench_bit,
                           get_parser=int,
                           val_mapping={'no quench detected': 0,
                                        'quench detected': 1}
                           )


        # Add solenoid parameters
        self.add_parameter(name='coil_constant_unit',
                           set_cmd=self._set_coil_constant_unit,
                           get_cmd=self._get_coil_constant_unit,
                           get_parser=int,
                           val_mapping={'T/A': 0,
                                        'kG/A': 1},
                           docstring=""unit of the coil constant, either T/A (default) or kG/A""
                           )
    
        self.add_parameter(name='coil_constant',
                           unit = self.coil_constant_unit,
                           set_cmd=self._update_coil_constant,
                           get_cmd=self._get_coil_constant,
                           get_parser=float,
                           vals=Numbers(0.001, 999.99999)  # what are good numbers here?
                           )
        
        self.add_parameter(name='field',
                           unit = 'T',
                           set_cmd=self.set_field,
                           get_cmd='RDGF?',
                           get_parser=float
                           )
        
        self.add_parameter(name='field_ramp_rate',
                           unit = 'T/min',
                           set_cmd=self._set_field_ramp_rate,
                           get_cmd=self._get_field_ramp_rate,
                           get_parser=float,
                           docstring=""Field ramp rate (T/min)""
                           )

   
        # Add clear function
        self.add_function('clear', call_cmd='*CLS')
        
        # disable persistent switch heater by default
        self.persistent_switch_heater('disabled')
        
        # disable ramp segments by default
        self.ramp_segments('disabled')
        
        # set coil constant unit to T/A by default
        self.coil_constant_unit('T/A')

        # assign init parameters
        self.coil_constant(coil_constant)
        self.field_ramp_rate(field_ramp_rate)

        # print connect message
        self.connect_message()


    def _sleep(self, t: float) -> None:
        """"""
        Sleep for a number of seconds t. If we are or using
        the PyVISA 'sim' backend, omit this
        """"""
        simmode = getattr(self, 'visabackend', False) == 'sim'

        if simmode:
            return
        else:
            time.sleep(t)


    # get functions returning several values
    def _get_limit(self) -> Tuple[float, float, float]:
        """"""
        Limit Output Settings Query

        Returns
        -------
            <current>, <voltage>, <rate>
        """"""
        raw_string = self.ask('LIMIT?')
        current_limit, voltage_limit, current_rate_limit = raw_string.split(',')
        return float(current_limit), float(voltage_limit), float(current_rate_limit)


    def _get_persistent_switch_heater_setup(self) -> Tuple[int, float, float]:
        """"""
        Persistent Switch Heater Parameter Query

        Returns
        -------
            <enable>, <current>, <delay>
        """"""
        raw_string = self.ask('PSHS?')
        status, psh_current, psh_delay = raw_string.split(',')
        return int(status), float(psh_current), float(psh_delay)


    def _get_quench_detection_setup(self) -> Tuple[int, float]:
        """"""
        Quench Parameter Query

        Returns
        -------
            <enable>, <rate>
        """"""
        raw_string = self.ask('QNCH?')
        status, current_step_limit = raw_string.split(',')
        return int(status), float(current_step_limit)


    def _get_field_setup(self) -> Tuple[str, float]:
        """"""
        Computed Magnetic Field Parameter Query

        Returns
        -------
            <units>, <constant>
        """"""
        raw_string = self.ask('FLDS?')
        unit, coil_constant = raw_string.split(',')
        return str(unit), float(coil_constant)    


    # get functions for parameters
    def _get_current_limit(self) -> float:
        """"""
        Get maximum allowed output current setting.

        Returns
        -------
            <current>
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        return current_limit


    def _get_voltage_limit(self) -> float:
        """"""
        Gets maximum allowed compliance voltage setting
        
        Returns
        -------
            <voltage>
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        return voltage_limit


    def _get_current_rate_limit(self) -> float:
        """"""
        Gets maximum allowed output current ramp rate setting

        Returns
        -------
            <rate>
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        return current_rate_limit


    def _get_persistent_switch_heater_status(self) -> int:
        """"""
        Queries if there is a persistent switch: 0 = Disabled (no PSH), 1 = Enabled

        Returns
        -------
            status
        """"""
        status, psh_current, psh_delay = self._get_persistent_switch_heater_setup()
        return status


    def _get_quench_detection_status(self) -> int:
        """"""
        Queries if quench detection is to be used: 0 = Disabled, 1 = Enabled

        Returns
        -------
            status
        """"""
        status, current_step_limit = self._get_quench_detection_setup()
        return status


    def _get_quench_current_step_limit(self) -> float:
        """"""
        Gets current step limit for quench detection

        Returns
        -------
            <rate>
        """"""
        status, current_step_limit = self._get_quench_detection_setup()
        return current_step_limit


    def _get_coil_constant(self) -> float:
        """"""
        Gets magnetic field constant in either T/A or kG/A depending on units

        Returns
        -------
            <constant>
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup()
        return coil_constant


    def _get_coil_constant_unit(self) -> str:
        """"""
        Gets the units of the magnetic field constant: 0 = T/A, 1 = kG/A

        Returns
        -------
            <units>
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup()
        return coil_constant_unit


    def _get_field_ramp_rate(self) -> float:
        """"""
        Gets the field ramp rate in units of T/min

        Returns
        -------
            field_ramp_rate (T/min)
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup() # in T/A by default
        current_ramp_rate = self.current_ramp_rate()    # in A/s
        field_ramp_rate = current_ramp_rate * coil_constant * 60 # in T/min
        return field_ramp_rate


    def _get_ramping_state(self) -> str:
        """"""
        Gets the ramping state of the power supply (corresponds to blue LED on panel)
        Is inferred from the status bit register

        Returns
        -------
            ramping state
        """"""
        operation_condition_register = self.ask('OPST?')
        bin_OPST = bin(int(operation_condition_register))[2:]
        if len(bin_OPST)<2:
            rampbit = 1
        else:
            # read second bit, 0 = ramping, 1 = not ramping
            rampbit = int(bin_OPST[-2])
        if rampbit == 1:
            return 'not ramping'
        else:
            return 'ramping'


    def _get_operational_errors(self) -> str:
        """"""
        Error Status Query

        Returns
        -------
            error status
        """"""
        error_status_register = self.ask('ERST?')
        # three bytes are read at the same time, the middle one is the operational error status
        operational_error_registor = error_status_register.split(',')[1]
        
        #prepend zeros to bit-string such that it always has length 9
        oer_bit_str = bin(int(operational_error_registor))[2:].zfill(9)
        return oer_bit_str


    def _get_oer_quench_bit(self) -> int:
        """"""
        Returns the oer quench bit

        Returns
        -------
            quench bit
        """"""
        return int(self._get_operational_errors()[3])


    # set functions for parameters
    def _set_curent_limit(self, current_limit_setpoint: float) -> None:
        """"""
        Sets maximum allowed output current
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        self.write_raw('LIMIT {}, {}, {}'.format(current_limit_setpoint, voltage_limit, current_rate_limit))


    def _set_voltage_limit(self, voltage_limit_setpoint: float) -> None:
        """"""
        Sets maximum allowed compliance voltage
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        self.write_raw('LIMIT {}, {}, {}'.format(current_limit, voltage_limit_setpoint, current_rate_limit))


    def _set_current_rate_limit(self, current_rate_limit_setpoint: float) -> None:
        """"""
        Sets maximum allowed output current ramp rate
        """"""
        current_limit, voltage_limit, current_rate_limit = self._get_limit()
        self.write_raw('LIMIT {}, {}, {}'.format(current_limit, voltage_limit, current_rate_limit_setpoint))


    def _set_persistent_switch_heater_status(self, status_setpoint: int) -> None:
        """"""
        Specifies if there is a persistent switch: 0 = Disabled (no PSH), 1 = Enabled
        """"""
        status, psh_current, psh_delay = self._get_persistent_switch_heater_setup()
        self.write_raw('PSHS {}, {}, {}'.format(status_setpoint, psh_current, psh_delay))


    def _set_quench_detection_status(self, status_setpoint: int) -> None:
        """"""
        Specifies if quench detection is to be used: 0 = Disabled, 1 = Enabled
        """"""
        status, current_step_limit = self._get_quench_detection_setup()
        self.write_raw('QNCH {}, {}'.format(status_setpoint, current_step_limit))


    def _set_quench_current_step_limit(self, current_step_limit_setpoint: float) -> None:
        """"""
        Specifies the current step limit for quench detection
        """"""
        status, current_step_limit = self._get_quench_detection_setup()
        self.write_raw('QNCH {}, {}'.format(status, current_step_limit_setpoint))


    def _set_coil_constant(self, coil_constant_setpoint: float) -> None:
        """"""
        Specifies the magnetic field constant in either T/A or kG/A depending on units
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup()
        self.write_raw('FLDS {}, {}'.format(coil_constant_unit, coil_constant_setpoint))


    def _set_coil_constant_unit(self, coil_constant_unit_setpoint: str) -> None:
        """"""
        Specifies the units of the magnetic field constant: 0 = T/A, 1 = kG/A
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup()
        self.write_raw('FLDS {}, {}'.format(coil_constant_unit_setpoint, coil_constant))


    def _update_coil_constant(self, coil_constant_setpoint: float) -> None:
        """"""
        Updates the coil_constant and with it all linked parameters
        """"""
        # read field_ramp_rate before chaning coil constant
        field_ramp_rate = self.field_ramp_rate()
        # set the coil constant
        self._set_coil_constant(coil_constant_setpoint)
        # update the current ramp rate, leaving the field ramp rate unchanged
        current_ramp_rate_setpoint = field_ramp_rate / coil_constant_setpoint / 60   # current_ramp_rate is in A/s
        self.current_ramp_rate(current_ramp_rate_setpoint)


    def _set_field_ramp_rate(self, field_ramp_rate_setpoint: float) -> None:
        """"""
        Sets the field ramp rate in units of T/min by setting the corresponding current_ramp_rate
        """"""
        coil_constant_unit, coil_constant = self._get_field_setup() # in T/A by default
        current_ramp_rate_setpoint = field_ramp_rate_setpoint / coil_constant / 60   # current_ramp_rate is in A/s
        self.current_ramp_rate(current_ramp_rate_setpoint)


    def set_field(self, value: float, block: bool=True) -> None:
        """"""
        Ramp to a certain field

        Args:
            value: field setpoint
            block: Whether to wait until the field has finished setting
        """"""

        self.write('SETF {}'.format(value))
        # Check if we want to block
        if not block:
            return

        # Otherwise, wait until no longer ramping
        self.log.debug(f'Starting blocking ramp of {self.name} to {value}')
        self._sleep(0.5)    # wait for a short time for the power supply to fall into the ramping state
        while self.ramping_state() == 'ramping':
            self._sleep(0.3)
        self._sleep(2.0)
        self.log.debug(f'Finished blocking ramp')
        return
"
390,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'att1Jmm1YPpJucecK'), ('width', 408), ('height', 336), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/E1wGE6DMkHmg1oSJVMQmIg/tJLfiqJ9l8eEuRlkPeyYZFvRy5wu7G5ISGmDvNti5GS2S9_M6CBegjcahr-WbfT5qET28qJC1O48fqya4HISCbyYbqaB4z0HIhBisId12WbD4uJ86s0rQRVouk26eqvz/C0o5R6QGOSPNoBHwVrP7yyebV5AJayfHwF8xAIp0uss'), ('filename', 'vaunix-digital-attenuator-n.png'), ('size', 122214), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/RSyDYyw1Mz2LQwJClmWWuQ/5nJO1VInohWIqPPtzYdb7zxcwlvzLRlNJWxCJvA5Ojm4qi_b1nodcLappCbT4_O9X9tOjIFSHdUV6HvKthdWrg/2dFOnSKwpdfRjNnCDfPezVoICwmTmx8Mv2dAVbGfeww'), ('width', 44), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9y_gL5qmyzTzP3BfPF7V_g/SaZfM2c1w8UmGXVPhapbUetT4kmQufpuV65J7nZ6c5zwbtw6Q3Zf5nYB64nEJ7s7UzKPi1aXTXgi3eAdkDUv0A/JdyqW6vT02hY0tgEmE_ESzWOW3iMXLWsrQ36CuO1cR4'), ('width', 408), ('height', 336)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/bCLuOq3VbPQLl6UYAvQTfA/YcpmKw4GZ7x4ma82PtJYgAjxf7WYYfzkvIfbQ4Se7qNXvxhGyesdZ3M9lvcPrfiTFlxr-OfWYYohgwu2Z9iEiQ/CYQU9A3jZly8-JXwcR6v6EdQcIS5gPMXy0l8NQ42JOE'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-602N Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +22 dBm, and offers frequency coverage of 6 to 6,000 MHz. It has an attenuation range of 63 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-602n-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-602N,Write a Python script that uses Qcodes Community to connect to a LDA-602N ,539.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
393,https://vaunix.com/resources/digital%20attenuators-datasheet.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attYKLluQOr4BaFkT'), ('width', 411), ('height', 297), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/D9mV38iFSjKsC_SyjDiqUg/T2OjNUuv9BELAkT6v8Tk0H2sOoTt-5A7_57Uhx42Q2MCNped7b06TWcyRVXELmuMf_sVBbjJshTkfPGzL5rkywIt4UArbddDiE8jKmF29rpBCdqsFn0stt0B6N_vMce7/jH90ecE6ufgQZU5nhCDCr7gCDvEIgsQJSB3e3rCPyho'), ('filename', 'vaunix-digital-attenuator.png'), ('size', 109500), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/8njMODoYpWFj918nqtS5Sg/ZWqL1TwKXn6akiCzUw1pVXmygTKPtdOaUtRhohnkOW5Mb6i3i1lL722DHA2igN9Rj_2Oefz7kbQOI71DJQJWWg/sfuZil6Tx9BWX5TJrzWQBcdcyVW3kxXOuwd9NNzhDD0'), ('width', 50), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/_KVtx-xBimIyp4RMu9RbuQ/3tiOzj7_-ckhWE3KH5oCGoyPsJAQzlPLvqHdM7TwGSZ5dziSML6b-PIOLZ_5f3cCeSfRy_ZceyoJJ4v_bFikjg/U8u7aX2jWH6VmG7a72RfqTWIZ-ZIZmuCCAhK5n9w7Qs'), ('width', 411), ('height', 297)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/ZX04Z_POP1iQPjLQ-JWhFg/oJKcrtAvo_T5qGz9rGwX_TCQjjdmNu76YOlb9AyRc3agJhgA0vagOOyv2jK-fYwaGSMchufbShQEnk98bq9iog/OORY-LQ2aXTOdce5OwdkfIOeoIRMq8vJ6uNW6fviqK4'), ('width', 3000), ('height', 3000)]))]))])]",5.0,USA,"The LDA-602 Lab Brick USB programmable 50 Ohm digital attenuator has an input power of up to +22 dBm, and offers frequency coverage of 6 to 6,000 MHz. It has an attenuation range of 63 dB and a step size of 0.5 dB. The unit is powered and controlled by USB connection to a PC or self-powered hub, and is programmable for fixed attenuation or swept attenuation ramps directly from the included graphical user interface (GUI) software.",https://vaunix.com/lda-602-programmable-digital-attenuator/,LDA,629.0,,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Vaunix Technology Corp. designs, manufactures, and services RF and microwave test equipment and digital radio communications products. Utilizing our deep RF and software engineering expertise, rooted in microwave radio and wireless equipment repair and testing, Vaunix developed the Lab Brick® family of electronic test products, which set a new standard for cost, size, and simplicity of wireless testing devices. Powered by a USB connection and controlled by easy-to-use, graphical-user-interface (GUI) software, Lab Bricks have been designed to meet the needs of wireless engineers and technicians who want to create flexible, customized system solutions either in the lab or in the field. We 've expanded our Lab Brick® family of electronic test products to include Attenuator Matrix solutions that double as Wireless [Handover Test Systems](https://vaunix.com/handover-test-systems/) to give our test technicians and product engineers the advanced capability to solve unique wireless _handover _testing challenges and bring affordability, functionality, reliability and simplicity to the microwave test bench. 
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/Vaunix/LDA.py,Qcodes Community,https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/docs/examples/Vaunix_LDA.ipynb,Vaunix,"[OrderedDict([('id', 'attyMYkkEMIf5IRX3'), ('width', 200), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/Th7_AvEwvIKHTm2ScT-q6g/hs9TpkK4Qgxy7rgZLEGiBmgdlOI3hmhbzwf5yEALLolXPnvv51LLZNl5oGTSccZ-JUF8nGTZZAVallahJoxxESMFsxDioef9HxaGzP_6vag/OfWKn9c1zZW3jiN4PnCKOlSO1NZn1n4ggNwMqPxJEgQ'), ('filename', '110_Vaunix-200_200.jpg'), ('size', 9642), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/wWITIyI50c9wAfs3LCWH1Q/KmEv0SmNWE-T6PhhdY7t2pyGM3GBrNWgF-zinj5JqGyl_9npAZp1wciC23rOytzmpPRvwDN5yMtKBNtHm378PQ/EZnTlhvCipeacFXFbNhz7LvAi_yK_pcpQkkuOFdQ-2M'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gopyNI8Myr7ps2T5cT8CGw/ngqtK2_vMA-LcxhEtuAo6dQ0Wa_SwSQKJixcNhYO26t9dWAO8Z9SBdStlVkJpEX7Z89pyB9IDUBOdRecxXgGuA/J1is0DhJhzhCzqiezxPgyhvrBvdkuOwiiScS21WJleA'), ('width', 200), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/YSymbtB07FSnSzorHzx72A/KZsvbF-TQts_TyZn95-nfakarzVsn4cGMdDR0_QJOXzPSW7mVIe2rnM-z984T15nmNEP0bClNaFjAo4g1ApYbg/jFmMISX3q3036TD9vrVS6jLuN1z5x38grBqH_VqcXgE'), ('width', 3000), ('height', 3000)]))]))])]",https://vaunix.com/,LDA-602,Write a Python script that uses Qcodes Community to connect to a LDA-602 ,499.0,,,,"r""""""
This is the QCoDeS driver for Vaunix LDA digital attenuators. It requires the
DLL that comes with the instrument, ``VNX_atten64.dll`` and/or
``VNX_atten.dll``, for 64-bit Windows and 32-bit Windows, respectively. If the
instrument has more than one physical channel, ``InstrumentChannel`` s are
created for each one. If the instrument has only one physical channel, no
channels are created and the parameters will be assigned to this instrument
instead. The sweep profiles available in the API are not implemented.

Tested with 64-bit system and

- LDA-133
- LDA-802Q

""""""

import logging
from typing import Optional, Dict, Callable, Union, cast
from functools import partial
from platform import architecture
import os
import sys
import ctypes
import time

from qcodes import Instrument, InstrumentChannel, Parameter
from qcodes.utils.validators import Numbers

logger = logging.getLogger(__name__)

class Vaunix_LDA(Instrument):
    dll_path = None

    def __init__(self, name: str,
                 serial_number: int,
                 dll_path: Optional[str] = None,
                 channel_names: Optional[Dict[int, str]] = None,
                 test_mode: bool = False,
                 **kwargs):
        r""""""
        QCoDeS Instrument for Vaunix LDA digital attenuators.

        Args:
            name: Qcodes name for this instrument
            serial_number: Serial number of the instrument, used to identify
                it.
            dll_path: Look for the LDA DLLs in this directory. Sets the dll
                path as class attribute that is used for future instances for
                which ``dll_path`` is not given.
            channel_names: Optionally assign these names to the channels.
            test_mode: If True, simulates communication with an LDA-102
                (serial:55102). Does not communicate with physical devices. For
                testing purposes.
        """"""
        begin_time = time.time()

        self.serial_number = serial_number
        self.reference = None

        if channel_names is None:
            channel_names = {}

        self.dll = self._get_dll(dll_path)
        self.dll.fnLDA_SetTestMode(test_mode)  # Test API without communication

        # Find all Vaunix devices, init the one with matching serial number.
        num_devices = self.dll.fnLDA_GetNumDevices()
        device_IDs = ctypes.c_int * num_devices
        device_refs = device_IDs()
        self.dll.fnLDA_GetDevInfo(device_refs)
        devices = {self.dll.fnLDA_GetSerialNumber(ref): ref
                   for ref in device_refs}
        self.reference = devices.get(self.serial_number, ""not found"")
        if self.reference == ""not found"":
            raise ValueError(f""LDA with serial number {self.serial_number}""
                             f"" was not found in the system. Found: {devices}"")

        self.dll.fnLDA_InitDevice(self.reference)

        # call superclass init only after DLL has been successfully loaded
        super().__init__(name=name, **kwargs)

        num_channels = self.dll.fnLDA_GetNumChannels(self.reference)
        if num_channels == 1:
            # don't add Channel objects, add parameters directly instead
            _add_lda_parameters(self)
        else:
            for i in range(1, num_channels + 1):
                name = channel_names.get(i, f""ch{i}"")
                ch = LdaChannel(parent=self, channel_number=i, name=name)
                self.add_submodule(name, ch)

        self.connect_message(begin_time=begin_time)

    def _get_dll(self, dll_path: Optional[str] = None) -> ctypes.CDLL:
        r""""""
        Load correct DLL from ``dll_path`` based on bitness of the operating
        system.

        Args:
            dll_path: path to the directory that contains the Vaunix LDA DLL.
                By default, use class attribute ``Vaunix_LDA.dll_path``.
        """"""
        path = dll_path or Vaunix_LDA.dll_path
        if path is None:
            raise ValueError(""DLL path for Vaunix LDA was not provided. ""
                             ""Either set ``Vaunix_LDA.dll_path`` or provide ""
                             ""it as an argument to the constructor."")

        if sys.platform != ""win32"":
            raise OSError(f""LDA is not supported on {sys.platform}."")
        bitness = architecture()[0]
        if ""64bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten64"")
        elif ""32bit"" in bitness:
            full_path = os.path.join(path, ""VNX_atten"")
        else:
            raise OSError(f""Unknown bitness of system: {bitness}"")

        try:
            dll = ctypes.cdll.LoadLibrary(full_path)
        except OSError as e:
            # typeshead seems to be unaware that winerror is an attribute
            # under windows
            winerror = getattr(e, ""winerror"", None)
            if winerror is not None and winerror == 126:
                # 'the specified module could not be found'
                raise OSError(f""Could not find DLL at '{full_path}'"")
            else:
                raise

        return dll

    def get_idn(self) -> Dict[str, Optional[str]]:

        buf = ctypes.create_string_buffer(300)
        self.dll.fnLDA_GetModelNameA(self.reference, buf)
        model = str(buf.value.decode())

        return {""vendor"": ""Vaunix"",
                ""model"": model,
                ""serial"":  self.dll.fnLDA_GetSerialNumber(self.reference),
                ""firmware"": self.dll.fnLDA_GetDLLVersion(),
                }

    def close(self) -> None:
        if hasattr(self, ""dll""):
            self.dll.fnLDA_CloseDevice(self.reference)
        super().close()

    def save_settings(self) -> None:
        """"""
        Save current settings to memory. Settings are automatically loaded
        during power on.
        """"""
        self.dll.fnLDA_SaveSettings(self.reference)


class LdaChannel(InstrumentChannel):
    """"""
    Channel corresponding to one input-output pair of the LDA digital
    attenuator.
    """"""
    def __init__(self, parent: Vaunix_LDA,
                 channel_number: int,
                 name: str):
        super().__init__(parent=parent, name=name)
        self.channel_number = channel_number
        _add_lda_parameters(self)


def _add_lda_parameters(inst: Union[Vaunix_LDA, LdaChannel]) -> None:
    """"""
    Helper function for adding parameters to either LDA root instrument,
    or channels inside it.
    Args:
        inst: the instrument or channel to add the parameters to.
    """"""
    root_instrument = cast(Vaunix_LDA, inst.root_instrument)
    inst.add_parameter(""attenuation"",
                       parameter_class=LdaAttenuation,
                       set_parser=float,
                       )
    wf_vals = LdaWorkingFrequency.get_validator(root_instrument)
    if wf_vals:
        inst.add_parameter(""working_frequency"",
                           parameter_class=LdaWorkingFrequency,
                           vals=wf_vals,
                           )


class LdaParameter(Parameter):
    scaling = 1.0  # Scaling from integers from API to physical quantities

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 dll_get_function: Callable, dll_set_function: Callable,
                 **kwargs):
        """"""
        Parameter associated with one channel of the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
            dll_get_function: DLL function that gets the value
            dll_get_function: DLL function that sets the value
        """"""
        super().__init__(name, instrument, **kwargs)
        self._reference = instrument.root_instrument.reference
        self._dll_get_function = partial(dll_get_function, self._reference)
        self._dll_set_function = partial(dll_set_function, self._reference)

    def _switch_channel(self) -> None:
        """"""
        Switch to this channel.
        """"""
        if hasattr(self.instrument, ""channel_number""):
            instr = cast(Instrument, self.instrument)
            instr.root_instrument.dll.fnLDA_SetChannel(self._reference,
                                                       instr.channel_number)

    def get_raw(self) -> float:
        """"""
        Switch to this channel and return current value.
        """"""
        self._switch_channel()
        value = self._dll_get_function()
        if value < 0:
            raise RuntimeError(f'{self._dll_get_function.func.__name__} '
                               f'returned error {value}')
        return value * self.scaling

    def set_raw(self, value: float) -> None:
        """"""
        Switch to this channel and set to ``value`` .
        """"""
        self._switch_channel()
        value = round(value / self.scaling)
        error_msg = self._dll_set_function(value)
        if error_msg != 0:
            raise RuntimeError(f'{self._dll_set_function.func.__name__} '
                               f'returned error {error_msg}')


class LdaAttenuation(LdaParameter):
    """"""
    Attenuation of one channel in the LDA.
    """"""
    scaling = 0.05  # integers returned by the API correspond to 0.05 dB

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        dll = instrument.root_instrument.dll

        ref = instrument.root_instrument.reference
        min_att = dll.fnLDA_GetMinAttenuationHR(ref) * self.scaling
        max_att = dll.fnLDA_GetMaxAttenuationHR(ref) * self.scaling
        vals = Numbers(min_att, max_att)

        label = ""Attenuation""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetAttenuationHR,
                         dll_set_function=dll.fnLDA_SetAttenuationHR,
                         vals=vals,
                         unit=""dB"",
                         label=label,
                         **kwargs,
                         )


class LdaWorkingFrequency(LdaParameter):
    """"""
    Working frequency of one channel of the LDA. Not supported on all models.
    """"""
    scaling = 100_000  # integers returned by the API correspond to 100kHz

    def __init__(self, name: str,
                 instrument: Union[Vaunix_LDA, LdaChannel],
                 **kwargs):
        """"""
        Attenuation of one channel in the LDA.

        Args:
            name: parameter name
            instrument: parent instrument, either LDA or LDA channel
        """"""
        dll = instrument.root_instrument.dll

        label = ""Working frequency""
        if isinstance(instrument, LdaChannel):
            # prefix label to make channels more easily distinguishable in plots
            label = f""{instrument.short_name} {label}""

        super().__init__(name, instrument,
                         dll_get_function=dll.fnLDA_GetWorkingFrequency,
                         dll_set_function=dll.fnLDA_SetWorkingFrequency,
                         unit=""Hz"",
                         label=label,
                         docstring=""Frequency at which the ""
                                   ""attenuation is most accurate."",
                         **kwargs
                         )

    @classmethod
    def get_validator(cls, root_instrument: Vaunix_LDA) -> Optional[Numbers]:
        """"""
        Returns validator for working frequency, if ``root_instrument``
        supports it. Else returns None.
        """"""
        max_freq = root_instrument.dll.fnLDA_GetMaxWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        min_freq = root_instrument.dll.fnLDA_GetMinWorkingFrequency(
                    root_instrument.reference) * cls.scaling
        # if feature is not supported, these values will be equal
        if max_freq > min_freq:
            return Numbers(min_freq, max_freq)
        else:
            return None


# shorthand
LDA = Vaunix_LDA
"
394,https://www.farnell.com/datasheets/3677014.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attnmvc17oqo4yC3i'), ('width', 520), ('height', 380), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/n_EU2RNPCxubfsC_s9oD9g/lAMDoLWuW-EIKCb_8iWu5JZtS-zZ9caYih1qRe8HDicXOFdQXjwgND5OO4MJioPfNrpo8u5es-3sXRfkoDrR6Q/Q6bI1gwXhjpi61satmh-yX6MxaxKXi-jLfMdPDGB2wk'), ('filename', '4040.jpg'), ('size', 39656), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/jpRbT8d5ayD4Ho0uGbvAVg/4Clw-5UI8e7ysTiXoDMjDwqxvPEujTybqV16q3X0IUz0g67acD0o_t-wQVz2ZS5OvMIAVQtIt21E5y_H_UFbLg/ZEqf376f_E2_W8VoFlEKNH1awi8AecVSsMsprlT3QWk'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/WO91aM3twH35H-Ckv3t1rA/GWiuwySBgUknfCLkkP1zDu4DeWyUEfXvWHVo4_rYz2-Ec1o8DCkzRyuPqyJemUoER3msiuXsD38DvUkaPZL6GA/fSYLHA73NAnPC_L2jFxXCzARswlbgWE5nk1AVRuBns0'), ('width', 520), ('height', 380)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/uTDXGNsqlWHUArjteYAB8Q/E_QzFInBPoOAx0oAd91EDLXdaBxZbid9G6bFXcrr8dmSwoJlfoTvbC9jZ-zuuW2m8jSYjIFKBog7RrNmWC8bvw/-D-lj_ruidCJIYZfEix3UIIR2VB6rKfL-xnz5TMPuls'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",The Rohde & Schwarz HMP4030 power supply belongs to the HMP series and has 3 channels and a power of 384W. All three channels have an output voltage of 0-32V and an output current of 0-10A. The Rohde & Schwarz HMP series are programmable DC power supplies.,"https://eleshop.eu/rohde-schwarz-hmp4030.html#:~:text=Details,are%20programmable%20DC%20power%20supplies.",HMP 4030,487.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes_contrib_drivers/blob/main/qcodes_contrib_drivers/drivers/RohdeSchwarz/HMP4030.py,Qcodes Community,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.RohdeSchwarz.html#module-qcodes_contrib_drivers.drivers.RohdeSchwarz.HMP4030,Rohdeschwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/BnHAJQTCk53sJYPBA3eIQw/-lOEHsJie7MvR0c6Pwhtlow6VDsuRYUiZX9s0pIo8g6V4Ay4XaHVx6jtyV2w07lUt9VIK098F7oMEMgKcT-ecEtC8tYrJktW_FvD4-cKV0w/CI2e4rOC1HT9jQZ63dW0nWKnnNVa1zVdcXYXeYexPKw'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/9ek8cJ0M05co27belb2RIQ/Nn1aUWXHmIYmkvaz_R3HnnciIzKUk3YjAD0ymBDD-_SJ4DDuGccKIPQIPS3H8L-3wXVFt_sVPUdzxH_y3yK98g/-olnDkZgvEhRB8BHY7EuvlSYmAEVD-HFBJL1G0wnh_8'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/qVoms86uvHyiAvg2g-9oEA/K7yWKPrJcldIsH7GeJArJkdFyzkMRq24QFgaa2dexB03aNBanxQgw3vvqBf7YYkz42Sl0vUlRd7iFtPGJGT5LQ/f0cyTxVNnX6ttFJNREmU3Gc5vBLrFriXoLMUl6dgkh8'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690063200000/gijFULL319IfXIwxhG_ehA/pEdYn3wQeFvy8tEOkWJLnUwfyqqjmtJbDx9w1kIkEdEXWRJaFBk3204Ebbpgdz07ZfX-bgtfcs-XN_69fDeH7Q/6rwW8TPaUJnHJPrTsiTMrDNQcXQZzREVZtMF098IMiQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,HMP 4030,Write a Python script that uses Qcodes Community to connect to a {Device name} Power Supplies,2189.19,,,,"from .private.HMP import _RohdeSchwarzHMP


class RohdeSchwarzHMP4030(_RohdeSchwarzHMP):
    """"""
    This is the qcodes driver for the Rohde & Schwarz HMP4030 Power Supply
    """"""
    def __init__(self, name, address, **kwargs):
        super().__init__(name, address, model_no=4030, **kwargs)"
