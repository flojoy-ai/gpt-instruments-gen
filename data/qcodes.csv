,Device datasheet (PDF),Category description link,Device picture,"Yearly revenue (millions, USD)",Vendor headquarters,Vendor logo URL,Device Description,Device Description Link,Device,Field 1,Device Category,Category Description,Vendor wikipedia or cruncbase description,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Library,Python docs link,Vendor,Vendor logo,Vendor website,Image URL,Corrected device name,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,QA Notes,docstring
5,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,https://en.wikipedia.org/wiki/Arbitrary_waveform_generator,"[OrderedDict([('id', 'attUw2UrpImX6Whdc'), ('width', 1418), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UQ6lGIS5BRrvmotnQ4LaSQ/s3C1_LakcE0UmtfNrCfwxHj9bbUv3jwlBWbByhCNSSmMnEW7DEh6FaGh-S5t8mHzvgwVpHKGmcDvUcheMEV5jxiD-Pl2VI4vULSPVha4Cew/CqdzgxaDPoss1QQmRt6hXvAuEHhxhYrjxIfFt8ZaaC8'), ('filename', '94T6987-40.jpg'), ('size', 99871), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-SAiXsSQu4maUYc8N5s56w/a22iZB5gxYLDRkKUKgME0iKS4igZjTWHZ1h0u7jnq4A3h1u9AxWsxU2MFBEYfJ9zVpistgjG9wYopOgxuRQoXg/UFJIJbtMyswEHWpkRldJSQHM74ZLvrbc_MwppUlmcvY'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hpBhMI2eyOOMs5aem75Pvg/_r2_ynOqAQqMsKMbJreHvcxEoG9g2KclcHzjwIiJXcoTIAaIOy_zlZEXd8cmDAkQk8E6MgmerdC7J4pLMATWmg/mWkzCn-CZsaJJRC62xzG4Y0RMwdagIFHMqVOc5q29S4'), ('width', 980), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2Je9iThkiX9vwnrt2gMBoA/RmKsaMB-E7LtV0PtP4G5L0wK5h-g9j2x5wzFix8uTOVPxjZ89aoqLJjGwgxC48b0acmmFV9K70pBcG81V3Y1_g/eAURIm4OBj8wRsPcvb3HuHnHwT95RVxH-oyZFn14Fw8'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 33511B waveform generator provides Keysight's exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements.
","https://www.keysight.com/us/en/product/33511B/waveform-generator-20-mhz-1-channel-arb.html#:~:text=The%2033511B%20waveform%20generator%20provides,for%20your%20most%20demanding%20measurements.",Keysight 33511 B,290.0,['RF Signal Generator'],An arbitrary waveform generator (AWG) is a piece of electronic test equipment used to generate electrical waveforms. These waveforms can be either repetitive or single-shot (once only) in which case some kind of triggering source is required (internal or external).,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33511B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782425/Instruments/RF%20Signal%20Generator/Keysight-33511B/Keysight-33511B.jpg,Keysight 33511B,Write a Python script that uses Qcodes to connect to a Keysight 33511B RF Signal Generator,2760.0,,,,"from functools import partial
import logging
from typing import Union, Any

from qcodes import VisaInstrument, validators as vals
from qcodes.instrument.channel import InstrumentChannel
from qcodes.instrument.base import Instrument
from qcodes.instrument_drivers.Keysight.private.error_handling import \
    KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class OutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a waveform generator
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


class SyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output. Has very few parameters for
    single channel instruments
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels+1):
            channel = OutputChannel(self, f'ch{i}', i)
            self.add_submodule(f'ch{i}', channel)

        sync = SyncChannel(self, 'sync')
        self.add_submodule('sync', sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
9,https://www.lakeshore.com/docs/default-source/product-downloads/manuals/372_manual.pdf?sfvrsn=906d7988_4,https://en.wikipedia.org/wiki/Resistance_thermometer,"[OrderedDict([('id', 'attP2S5AlGl1nkoZY'), ('width', 505), ('height', 152), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RBM6CFZYDB3p6VI7mWOABQ/iMVxzJj1HRzMSuDsmwoht4rIYAlGH9WEVh_UXsYnjN-KRQp4ltCNy8DissC407n83E7UgR6D5R5IawfuIywQaw/v4EKyzX95mUNfM88HIvSD3qR65lVcvpS5YUNfYacqmk'), ('filename', '372.png'), ('size', 107074), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/T1sMmmqA-b8zxFrG2_3mHg/DiUP1CYcBOeZJrhze-8rmMzZBpoSSuf-Kb1PlhFyjofUEFUWZ5zpHoLiJP2i63wZbZooo_sPil7YaQsipaxCPQ/Q1L_nrpPagfmsB6Y0Ih-rj07LVAW-OUGDz2w5u81eL8'), ('width', 120), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kjUy35ylcyf1yZ4wCGLTlQ/8Zsnme1P8tRrZFop-jGjoeWx48F2ifY21Rtg5KSAdCYTsiCCqnGMFaf8PpdOpSd9R5qAAPUIf4l7Yjkk7YvNTQ/q_UbBn_WWQ0qywTTaTqGrh9jpCnVPn2UZ0YnSQ9BhT0'), ('width', 505), ('height', 152)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9PGftcxlxD1FgpszkQ_yqw/Tp1Jm4M4ThU9ZEbjglY9aAqbzz-r97vz68eU_1PFFZ20nw1t_whGSipgRcUvpM6j6RTPUGuupotYzYFWpLcuFw/qSBuWEtR2yFjCvSuQ0qxsE92UnJNAH0Ap0aDyMMns1E'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,The Model 372 AC resistance bridge and temperature controller builds on the solid foundation provided by the original Lake Shore AC resistance bridge. The Model 372 provides the best possible temperature measurement and control capabilities for dilution refrigerators (DRs) that are intended to be operated below 100 mK. The Model 372 makes it easy to perform multiple tasks that were once very difficult to perform reliably at ultra-low temperatures:,https://www.lakeshore.com/products/categories/overview/temperature-products/ac-resistance-bridges/model-372-ac-resistance-bridge-temperature-controller,Lakeshore Model 372,358.0,"['Temperature Controllers', 'Power Meters']","Resistance thermometers, also called resistance temperature detectors (RTDs), are sensors used to measure temperature. Many RTD elements consist of a length of fine wire wrapped around a heat-resistant ceramic or glass core but other constructions are also used. The RTD wire is a pure material, typically platinum (Pt), nickel (Ni), or copper (Cu). The material has an accurate resistance/temperature relationship which is used to provide an indication of temperature. As RTD elements are fragile, they are often housed in protective probes.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_372.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel372,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782428/Instruments/Temperature%20Controllers/Lakeshore-Model-372/Lakeshore-Model-372.png,Lakeshore Model 372,"Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers, Power Meters",9149.0,,,,"from typing import Any, ClassVar

import qcodes.validators as vals
from qcodes.instrument_drivers.Lakeshore.lakeshore_base import (
    BaseOutput,
    BaseSensorChannel,
    LakeshoreBase,
)
from qcodes.parameters import Group, GroupParameter

# There are 16 sensors channels (a.k.a. measurement inputs) in Model 372
_n_channels = 16


class LakeshoreModel372Output(BaseOutput):
    """"""An InstrumentChannel for control outputs (heaters) of Lakeshore Model 372""""""

    MODES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""monitor_out"": 1,
        ""open_loop"": 2,
        ""zone"": 3,
        ""still"": 4,
        ""closed_loop"": 5,
        ""warm_up"": 6,
    }
    POLARITIES: ClassVar[dict[str, int]] = {""unipolar"": 0, ""bipolar"": 1}
    RANGES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""31.6μA"": 1,
        ""100μA"": 2,
        ""316μA"": 3,
        ""1mA"": 4,
        ""3.16mA"": 5,
        ""10mA"": 6,
        ""31.6mA"": 7,
        ""100mA"": 8,
    }

    _input_channel_parameter_kwargs: ClassVar[dict[str, Any]] = {
        ""get_parser"": int,
        ""vals"": vals.Numbers(1, _n_channels),
    }

    def __init__(
        self, parent: ""LakeshoreModel372"", output_name: str, output_index: int
    ) -> None:
        super().__init__(parent, output_name, output_index, has_pid=True)

        # Add more parameters for OUTMODE command
        # and redefine the corresponding group
        self.add_parameter(
            ""polarity"",
            label=""Output polarity"",
            docstring=""Specifies output polarity (not "" ""applicable to warm-up heater)"",
            val_mapping=self.POLARITIES,
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""use_filter"",
            label=""Use filter for readings"",
            docstring=""Specifies controlling on unfiltered or "" ""filtered readings"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""delay"",
            label=""Delay"",
            unit=""s"",
            docstring=""Delay in seconds for setpoint change "" ""during Autoscanning"",
            vals=vals.Ints(0, 255),
            get_parser=int,
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.mode,
                self.input_channel,
                self.powerup_enable,
                self.polarity,
                self.use_filter,
                self.delay,
            ],
            set_cmd=f""OUTMODE {output_index}, {{mode}}, ""
            f""{{input_channel}}, ""
            f""{{powerup_enable}}, {{polarity}}, ""
            f""{{use_filter}}, {{delay}}"",
            get_cmd=f""OUTMODE? {output_index}"",
        )

        self.P.vals = vals.Numbers(0.0, 1000)
        self.I.vals = vals.Numbers(0.0, 10000)
        self.D.vals = vals.Numbers(0, 2500)


class LakeshoreModel372Channel(BaseSensorChannel):
    """"""
    An InstrumentChannel representing a single sensor on a Lakeshore Model 372.

    """"""
    SENSOR_STATUSES = {
        0: ""OK"",
        1: ""CS OVL"",
        2: ""VCM OVL"",
        4: ""VMIX OVL"",
        8: ""VDIF OVL"",
        16: ""R. OVER"",
        32: ""R. UNDER"",
        64: ""T. OVER"",
        128: ""T. UNDER"",
    }

    def __init__(self, parent: ""LakeshoreModel372"", name: str, channel: str):
        super().__init__(parent, name, channel)

        # Parameters related to Input Channel Parameter Command (INSET)
        self.add_parameter(
            ""enabled"",
            label=""Enabled"",
            docstring=""Specifies whether the input/channel is ""
            ""enabled or disabled. At least one ""
            ""measurement input channel must be ""
            ""enabled. If all are configured to ""
            ""disabled, channel 1 will change to ""
            ""enabled."",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""dwell"",
            label=""Dwell"",
            docstring=""Specifies a value for the autoscanning "" ""dwell time."",
            unit=""s"",
            get_parser=int,
            vals=vals.Numbers(1, 200),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""pause"",
            label=""Change pause time"",
            docstring=""Specifies a value for "" ""the change pause time"",
            unit=""s"",
            get_parser=int,
            vals=vals.Numbers(3, 200),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""curve_number"",
            label=""Curve"",
            docstring=""Specifies which curve the channel uses: ""
            ""0 = no curve, 1 to 59 = standard/user ""
            ""curves. Do not change this parameter ""
            ""unless you know what you are doing."",
            get_parser=int,
            vals=vals.Numbers(0, 59),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""temperature_coefficient"",
            label=""Change pause time"",
            docstring=""Sets the temperature coefficient that ""
            ""will be used for temperature control if ""
            ""no curve is selected (negative or ""
            ""positive). Do not change this parameter ""
            ""unless you know what you are doing."",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.enabled,
                self.dwell,
                self.pause,
                self.curve_number,
                self.temperature_coefficient,
            ],
            set_cmd=f""INSET {self._channel}, ""
            f""{{enabled}}, {{dwell}}, {{pause}}, ""
            f""{{curve_number}}, ""
            f""{{temperature_coefficient}}"",
            get_cmd=f""INSET? {self._channel}"",
        )

        # Parameters related to Input Setup Command (INTYPE)
        self.add_parameter(
            ""excitation_mode"",
            label=""Excitation mode"",
            docstring=""Specifies excitation mode"",
            val_mapping={""voltage"": 0, ""current"": 1},
            parameter_class=GroupParameter,
        )
        # The allowed values for this parameter change based on the value of
        # the 'excitation_mode' parameter. Moreover, there is a table in the
        # manual that assigns the numbers to particular voltage/current ranges.
        # Once this parameter is heavily used, it can be implemented properly
        # (i.e. using val_mapping, and that val_mapping is updated based on the
        # value of 'excitation_mode'). At the moment, this parameter is added
        # only because it is a part of a group.
        self.add_parameter(
            ""excitation_range_number"",
            label=""Excitation range number"",
            docstring=""Specifies excitation range number ""
            ""(1-12 for voltage excitation, 1-22 for ""
            ""current excitation); refer to the manual ""
            ""for the table of ranges"",
            get_parser=int,
            vals=vals.Numbers(1, 22),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""auto_range"",
            label=""Auto range"",
            docstring=""Specifies auto range setting"",
            val_mapping={""off"": 0, ""current"": 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""range"",
            label=""Range"",
            val_mapping={
                ""2.0 mOhm"": 1,
                ""6.32 mOhm"": 2,
                ""20.0 mOhm"": 3,
                ""63.2 mOhm"": 4,
                ""200 mOhm"": 5,
                ""632 mOhm"": 6,
                ""2.00 Ohm"": 7,
                ""6.32 Ohm"": 8,
                ""20.0 Ohm"": 9,
                ""63.2 Ohm"": 10,
                ""200 Ohm"": 11,
                ""632 Ohm"": 12,
                ""2.00 kOhm"": 13,
                ""6.32 kOhm"": 14,
                ""20.0 kOhm"": 15,
                ""63.2 kOhm"": 16,
                ""200 kOhm"": 17,
                ""632 kOhm"": 18,
                ""2.0 MOhm"": 19,
                ""6.32 MOhm"": 20,
                ""20.0 MOhm"": 21,
                ""63.2 MOhm"": 22,
            },
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""current_source_shunted"",
            label=""Current source shunt"",
            docstring=""Current source either not shunted ""
            ""(excitation on), or shunted ""
            ""(excitation off)"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""units"",
            label=""Preferred units"",
            docstring=""Specifies the preferred units parameter ""
            ""for sensor readings and for the control ""
            ""setpoint (kelvin or ohms)"",
            val_mapping={""kelvin"": 1, ""ohms"": 2},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.excitation_mode,
                self.excitation_range_number,
                self.auto_range,
                self.range,
                self.current_source_shunted,
                self.units,
            ],
            set_cmd=f""INTYPE {self._channel}, ""
            f""{{excitation_mode}}, ""
            f""{{excitation_range_number}}, ""
            f""{{auto_range}}, {{range}}, ""
            f""{{current_source_shunted}}, ""
            f""{{units}}"",
            get_cmd=f""INTYPE? {self._channel}"",
        )


class LakeshoreModel372(LakeshoreBase):
    """"""
    QCoDeS driver for Lakeshore Model 372 Temperature Controller.

    Note that interaction with the control input (referred to as 'A' in the
    Computer Interface Operation section of the manual) is not implemented.
    """"""

    channel_name_command: dict[str, str] = {
        f""ch{i:02}"": str(i) for i in range(1, 1 + _n_channels)
    }
    input_channel_parameter_values_to_channel_name_on_instrument = {
        i: f""ch{i:02}"" for i in range(1, 1 + _n_channels)
    }

    CHANNEL_CLASS = LakeshoreModel372Channel

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, **kwargs)

        heaters = {""sample_heater"": 0, ""warmup_heater"": 1, ""analog_heater"": 2}
        for heater_name, heater_index in heaters.items():
            self.add_submodule(
                heater_name, LakeshoreModel372Output(self, heater_name, heater_index)
            )
"
10,https://download.tek.com/datasheet/System_46_Datasheet_1KW-5043-1.pdf,https://en.wikipedia.org/wiki/RF_switch,"[OrderedDict([('id', 'attHVeNSj5kOnUdtj'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4bjiaPI1TU8jkPcDfiTgiQ/g6bQnLliPqs0fqwuvQPSGKcpGKZSnfTqzAkngaf4RF2fcqxiIW0jBdeEOJh5ywvofF_JjXLMGuOYUEr4o7mvSlpVDD670bT0EOh39Kglrqc/uKYTUEicyUJW9SbdDmlCC13reTjFuW24EizhGTla4dU'), ('filename', 'S46T_CAT1_1.jpg'), ('size', 15412), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/x_9Hlabnh6HfBBhnPTR5qQ/Ik7GrwT1xqIku3FeJwHsyAvnm9uzQQXOpvY8yyJWZ_Prs940NPlCSTTqp5EJBJAHT7oRev82PTHgDFOBdYLgnw/D4S_AY8WuCO3gYpyjg3Ytnm2tEmEvV13lhmiw3Ewa80'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Td3bSxP_7hOcNn6pWJh7vw/VHmx4oC9dpnZVk-qv1m5w-MpM5Y6IORHvscGvAlDwzg63uIGCsNVIJb_3DpNO55NvZpbgdLzAVEv5ao3Oj-kYA/Fr6GcGmwsCw9gbBqku6jGyzaFQt0gyeX7U8W7qLUJQw'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pywd20ltfjNwrTdRDDialg/WFPMzmX_GhIU9bRlqDublbCssHM2YE7t4Pba80NjZlVKelD9ARUPvR5wDgnA_TnYhcUj4jKiadO5iZVMGGOb4w/8cu0yUWGNxGgfaefbvMYDgOW0oGWaTK4mXo7xcaWIzM'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,S46 Microwave Switch Systems are designed to simplify the automated switching needed to test a wide range of RF and telecommunication products and devices. The S46 can control 32 relay contacts in a package as small as a 2U high (3.5 in) full-rack enclosure.,https://www.tek.com/en/products/keithley/switching-and-data-acquisition-systems/s46-rf-microwave-switching,Keithley S 46,254.0,['Switch'],"An RF switch or microwave switch is a device to route high frequency signals through transmission paths. RF (radio frequency) and microwave switches are used extensively in microwave test systems for signal routing between instruments and devices under test (DUT). Incorporating a switch into a switch matrix system enables you to route signals from multiple instruments to single or multiple DUTs. This allows multiple tests to be performed with the same setup, eliminating the need for frequent connects and disconnects. The entire testing process can be automated, increasing the throughput in high-volume production environments.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_s46.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.KeithleyS46,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782430/Instruments/Switch/Keithley-S46/Keithley-S46.jpg,Keithley S46,Write a Python script that uses Qcodes to connect to a Keithley S46 Switch,,,,,"""""""
Driver for the Keithley S46 RF switch
""""""
import re
from itertools import product
from typing import Any, Optional

from qcodes.instrument import Instrument, VisaInstrument
from qcodes.parameters import Parameter, ParamRawDataType


class KeithleyS46LockAcquisitionError(Exception):
    pass


class KeithleyS46RelayLock:
    """"""
    The S46 either has six pole or a four pole relays. For example, channels
    'A1' to 'A6' are all on relay 'A'. However, channels 'R1' to 'R8' are all on
    individual relays.

    Only one channel per relay may be closed at any given time to prevent
    degradation of RF performance and even switch damage. See page 2-11
    of the manual. To enforce this, a lock mechanism has been implemented.
    """"""

    def __init__(self, relay_name: str):
        self.relay_name = relay_name
        self._locked_by: Optional[int] = None

    def acquire(self, channel_number: int) -> None:
        """"""
        Request a lock acquisition
        """"""
        if self._locked_by is not None and self._locked_by != channel_number:
            raise KeithleyS46LockAcquisitionError(
                f""Relay {self.relay_name} is already in use by channel ""
                f""{self._locked_by}""
            )
        else:
            self._locked_by = channel_number

    def release(self, channel_number: int) -> None:
        """"""
        Release a lock.
        """"""
        if self._locked_by == channel_number:
            self._locked_by = None


class S46Parameter(Parameter):
    """"""
    A parameter class for S46 channels. We do not use the QCoDeS
    InstrumentChannel class because our channel has one state parameter,
    which can either be ""open"" or ""close"".

    Args:
        name
        instrument
        channel_number
        lock: Acquire the lock when closing and release when opening
    """"""

    def __init__(
        self,
        name: str,
        instrument: Optional[Instrument],
        channel_number: int,
        lock: KeithleyS46RelayLock,
        **kwargs: Any,
    ):
        super().__init__(name, instrument, **kwargs)

        self._lock = lock
        self._channel_number = channel_number

        if self._get(get_cached=True) == ""close"":
            try:
                self._lock.acquire(self._channel_number)
            except KeithleyS46LockAcquisitionError as e:
                raise RuntimeError(
                    ""The driver is initialized from an undesirable instrument ""
                    ""state where more then one channel on a single relay is ""
                    ""closed. It is advised to power cycle the instrument. ""
                    ""Refusing to initialize driver!""
                ) from e

    def _get(self, get_cached: bool) -> str:
        assert isinstance(self.instrument, KeithleyS46)
        closed_channels = self.instrument.closed_channels.get_latest()

        if not get_cached or closed_channels is None:
            closed_channels = self.instrument.closed_channels.get()

        return ""close"" if self.name in closed_channels else ""open""

    def get_raw(self) -> ParamRawDataType:
        return self._get(get_cached=False)

    def set_raw(self, value: ParamRawDataType) -> None:

        if value == ""close"":
            self._lock.acquire(self._channel_number)
        elif value == ""open"":
            self._lock.release(self._channel_number)

        if self.instrument is None:
            raise RuntimeError(
                ""Cannot set the value on a parameter ""
                ""that is not attached to an instrument.""
            )
        self.instrument.write(f"":{value} (@{self._channel_number})"")

    def is_closed(self) -> bool:
        """"""
        Returns: True if channels is closed, False otherwise.
        """"""
        return self.get() == ""close""

    @property
    def channel_number(self) -> int:
        return self._channel_number


class KeithleyS46(VisaInstrument):

    relay_names: list[str] = [""A"", ""B"", ""C"", ""D""] + [f""R{j}"" for j in range(1, 9)]

    # Make a dictionary where keys are channel aliases (e.g. 'A1', 'B3', etc)
    # and values are corresponding channel numbers.
    channel_numbers: dict[str, int] = {
        f""{a}{b}"": count + 1
        for count, (a, b) in enumerate(product([""A"", ""B"", ""C"", ""D""], range(1, 7)))
    }
    channel_numbers.update({f""R{i}"": i + 24 for i in range(1, 9)})
    # Make a reverse dict for efficient alias lookup given a channel number
    aliases = {v: k for k, v in channel_numbers.items()}

    def __init__(self, name: str, address: str, **kwargs: Any):

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_parameter(
            ""closed_channels"",
            get_cmd="":CLOS?"",
            get_parser=self._get_closed_channels_parser,
        )

        self._available_channels: list[str] = []

        for relay_name, channel_count in zip(
            KeithleyS46.relay_names, self.relay_layout
        ):

            relay_lock = KeithleyS46RelayLock(relay_name)

            for channel_index in range(1, channel_count + 1):
                # E.g. For channel 'B2', channel_index is 2
                if channel_count > 1:
                    alias = f""{relay_name}{channel_index}""
                else:
                    alias = relay_name  # For channels R1 to R8, we have one
                    # channel per relay. Channel alias = relay name

                self.add_parameter(
                    alias,
                    channel_number=KeithleyS46.channel_numbers[alias],
                    lock=relay_lock,
                    parameter_class=S46Parameter,
                )

                self._available_channels.append(alias)

    @staticmethod
    def _get_closed_channels_parser(reply: str) -> list[str]:
        """"""
        The SCPI command "":CLOS ?"" returns a reply in the form
        ""(@1,9)"", if channels 1 and 9 are closed. Return a list of
        strings, representing the aliases of the closed channels
        """"""
        closed_channels_str = re.findall(r""\d+"", reply)
        return [KeithleyS46.aliases[int(i)] for i in closed_channels_str]

    def open_all_channels(self) -> None:
        for channel_name in self.closed_channels():
            self.parameters[channel_name].set(""open"")

    @property
    def relay_layout(self) -> list[int]:
        """"""
        The relay layout tells us how many channels we have per relay. Note
        that we can have zero channels per relay.
        """"""
        return [int(i) for i in self.ask("":CONF:CPOL?"").split("","")]

    @property
    def available_channels(self) -> list[str]:
        return self._available_channels
"
11,https://docs.zhinst.com/pdf/ziUHFQA_UserManual.pdf,https://www.zhinst.com/americas/en/products/shfqa-quantum-analyzer,"[OrderedDict([('id', 'att3VgCNpet0BxOHv'), ('width', 1183), ('height', 362), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6EFLtq4a9bnowB3bGhHNXg/F6WxyswNnc6xq6djmxvITSmXqZWsl3nMfOyRZ93dqYK8wAlEZOgSHE3-5-hSYxftBIVS-3yRn9da_LmHWarIUtYU_MMtUt9gfsb3h5OF_iewd_fsiD61c3QAKQ7coyyL/xHeXkCoEJdKnsa_e87NuNq2_2QiWBky_IweKntgZ5fY'), ('filename', 'uhfqa_schraeg_2800.png.webp'), ('size', 25058), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ObzfI4UIoShmbeCm9CFW9Q/68ztpzGQQFWyBVL35FbaVKhIT1qJZPp7tWGMIwHoxPqei1BJ3HoC6UuYxK3Hgzm1CYlyHEDMzBktlMcyKpc92tiisJNQDlkZo_HgojcgpBU/Yk0T9ZwheIu6HqS8pY5kdSV29cGdvW5ZfRgMKZUcLCQ'), ('width', 118), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lUpPDRNqWWsAEbTkM2-TAg/uduE0ikJCqYTQ9rwBXkoqj2rHKVhNii8mxHreLD5UnUfC531rctJ-fYWEhzO5aUxXA_lcpBqw5j8iFRQZ6yBgqx6UlwSrWmPBEKERsChHJ8/2kmzN7jX6DVyEulsr9vBI6Gvb27FJSZKJIQ7WQTzMto'), ('width', 1183), ('height', 362)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mZ-mnBGTZkWivIeUcxHhYw/vx91oQGusPcPnpJzvK9frjlO_43FUybXhFllSLLXhFcheo4jLqg1S1aF8jkMf8eZRe-Ml1hquEJgMNApZZz22yM615ehA0BfULjE538gvaY/8gNnHhEzDq_aV1qsQUb2BhJATklW6cYSYW70gJiRVyA'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments UHFQA Quantum Analyzer is a unique instrument for parallel readout of up to 10 superconducting or spin qubits with highest speed and fidelity. The UHFQA operates on a frequency span of up to ±600 MHz with nanosecond timing resolution, and it features 2 signal inputs and outputs for IQ base-band operation. Thanks to its low-latency signal processing chain of matched filters, real-time matrix operations, and state discrimination, the UHFQA supports the development of ambitious quantum computing projects for 100 qubits and more.",https://www.zhinst.com/americas/en/products/uhfqa-quantum-analyzer,Uhfqa,641.0,['Quantum Analyzer'],"The SHFQA enables multi-state discrimination with optimal signal-to-noise ratio and minimal latency thanks to its advanced sequencer and its low-latency signal processing chain with matched filters and result correlation. The data are transmitted in real-time to other instruments for active qubit reset or global error correction protocols. Controlled through the LabOne software suite comprising the user interface, several APIs and LabOne Q, the SHFQA supports quantum computing projects with sizes ranging from a few to several hundreds of qubits.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqa.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.uhfqa.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782431/Instruments/Quantum%20Analyzer/UHFQA/UHFQA.webp,UHFQA,Write a Python script that uses Qcodes to connect to a UHFQA Quantum Analyzer,,,,,"""""""Autogenerated module for the SHFQA QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import Sequence, Waveforms
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQA(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQA.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
13,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'attgSpBoGYLMyzxqA'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i50hGPWtr7UvKDRCf7Hl7A/eItEC1lAZ83zQWUNFByGvsh40Dm5OTcyxzYS1xUY0Si1jgiMX2NLl3IXCGiS-E5-vchryLTQ_8FJ6_UkygyxtkHzE0qvbPavIEsRGYzlr-w/3eLrbzySQtXe05alcWEcbshQTv1Y7leYKnue5Q6o4eQ'), ('filename', 'PL303QMD-1000px.jpg'), ('size', 183214), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tw-hdMackWyzySyCDRD2bA/uIJYJfifIW4HEvP-AdHl-btJ4ZcJjsSq43B4HwAjdgZIO4Gp66-36kroZaeygQpVymqpmuQo5w_ycQd5wlPwTw/kWabGmRz8SfIf9UnpXdpw_7oR-lwH_zLTCu_qQyqurg'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qt6RnAIJ2we_unfb0GjwYA/uvH6pEF9HhSXjdWgwve75pFqxpoUcJ8Fr4oxwdDSckrzJ8HEiIXHL9quz2Dl5qxKGXd0tPRtVAEtF6zqXTPTHg/6vRkYLSPB2riOaaT7gx77YMxrYKPTI0CLOTcNGIQhI0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6DMfhNFVL87CZOKUMrzU6w/XmnSiN34gzrvGNAh77gQd-298T0x3nLwJOdM823qZQR8XdT-LUAtHWesprQjTSUCX16h8AoZ4hplqnmpu5LKXw/GQxeqTpnedsbibDIqEyvNwr4t05lKP925EQ_HhvAc00'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Dual Output, 2 x 30V/3A, USB, RS232 & LAN Interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 303 QMD P,49.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL303QMDP,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782432/Instruments/Power%20Supplies/PL303QMD-P/PL303QMD-P.jpg,PL303QMD-P,Write a Python script that uses Qcodes to connect to a PL303QMD-P Power Supplies,1150.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
16,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,"[OrderedDict([('id', 'attSsiYamVSrHxqrI'), ('width', 1164), ('height', 566), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DWfH9ZrNl5OdKloVoc1hmA/d16GYRMeolumsUtzVrbC4_X5AEg-DQMRyHk9KeT5frs1pybtb2CR7sBgDk5qcLJEL6aCIHs0QWfMqpO1tOJdFikaccLbtfB42lv-pYWFHJI/qZ-pbc7g1MmzUAIw5bnHf4dXbubF7aOwtzQm7NlR6Ec'), ('filename', '34410A.png'), ('size', 439324), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3TCqXBE6_gKVZ01jMgNHzA/z99LMk9n7x7Imycv6lTtc_qKGlMfy0dSL62iB5rR8OjYCvQ_KKF2dlkR-NAS1ulaGPYMIri6grxjFgWOilE8bA/L_62vE5_gLlSU5Tr_XFm8q4SHcPo6Oayx6HvGKXYKwY'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/p35Gimncw3hPkzNSAUBYvg/uGGkwzxwJo1ACq3DFZbEJBo8YIU2J8AcGEEYT1GaLlsQUqOiDwOwDDFSaVZbAhjxoUNGzX05s5kZV0u6xc8EOQ/QfUezoTL3zcmM34Oir4BePS8-bmJ0c8L2rSJ8WvmQ9s'), ('width', 1053), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5EkGdUnE4vzVSZn4xTV1Fw/d8I4aonFaMMHkFwrfP_NZje_AdqJeaDm4LSY-Dp3aj2za9uKgZy1k6dCy6uPaYfuRUEkllYPFhdbpomGrNcQjw/j2CFDr3GYFlZhCGWRiB43tceNgIm3pZvXDEjiQVLsYE'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"The Keysight Technologies, Inc. 34410A and 34411A 6½-Digit DMMs build on the phenomenal success of the industry-standard Keysight 34401A. These new meters offer improved accuracy, expanded measurement capability, dramatically improved measurement speed and throughput, and modern computer interfaces including LAN and USB.",https://www.keysight.com/us/en/product/34410A/digital-multimeter-6-digit.html,Agilent 34410A,32.0,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.Agilent34410A,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iBkD5hWEdE9VzBFEnSeOfA/NjWxUxjJA8yGPExBiN-PkZNjv4VfBExywq89pMu9c9Ra2W7et-Aw64QgEaSQebRctQuA2kL2PnwYRmggAnp4lSGJ5zznVS6ye7vLZh646iQ/Kl7uXhhhwfiGUId4CxlN-USzNex2x6CGk7CVIvfLvQ4'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f6t0-WbC6cKqyn0DT117iA/QPT0gpK6FG2qsOLK-bt0IxmOydbb6-9Pxg2hNGQF0mxWHfXPYXFiZagCw1Yj9qkKeKEbN-OQzc1R1_lDDq3DCa-N0BRerbz5SnzZQJlzbJ8/iuupeOUi0pSC13qOqrqjRHiA-gwJTseDKR1IenXqWtY'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cFs4Pvz6m9YFSFnAUBP9Jw/NgiAU7UcTKsj4PX6Lzw6SkhLC1rCN7-KpOyUy0E3yh7QLAbmpKXYyYKq1x_OkoLZAlEY7R20W5zF_Vo0-E3cUyiYsxgXKf9_RTswNy3Wd7w/GhCXNKTSYmUF5vw3ifd6HKHmQkYlHKJQaWCVYa06Xqg'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pxy_7pX_47hdW9iN2Gvi7A/4LRl2aDd8IoPIwJ53KRuFtJ4dEG8aRW8frebU514v4lYFkRRLyyF7Kcfv4Q3zGQT19g9Bs1hNet5CN1YxdFcjM9hQIBoBBiixzvExLQHvMM/RhEKW_l5u-Xiv303cIU5H_n4SPQvKttNDyTSjmqpWkI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782435/Instruments/Multimeters/Keysight-34410A/Keysight-34410A.png,Keysight 34410A,Write a Python script that uses Qcodes to connect to a Keysight 34410A Multimeters,,,True,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
19,https://download.tek.com/datasheet/1KW-60906-0_Series_2600BDatasheet_112718.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attH0k7mcZZK9q4aR'), ('width', 320), ('height', 146), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qYLP2j_VI9qawuVm4FgkFg/XNLff_k0AoaGKmWD7pC8uSEG2YPeZux6YxsO70hFqEGq5kkLHdwL1sj_r-DP05XQmU-97Uewby3CnnV-lqDGxXyFa2s8bk95-idCx3gyXyk/h7NDeNm-oDSTHT53t0akbLsnIC1z8LlK6x0M7-hOoV8'), ('filename', '2604b.webp'), ('size', 7146), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LW3S8OEO-fA0FG0md3vM0w/F9RO9_9bfLjykQmB7QBHTtGAUL4rR9Iwm3w-o28P_vfdGBRvZ9KDJ7OiSAPzb8LJERlL1wZOu2ogvYodwRnd31DHMVvCtJ0gAAZ9kl3peHc/Gap0vsoJM1Yhti2gTluRntQhff-x1rwUJdZFnHZ384Y'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OYmgG4NEQUglEBShHosRGQ/pUICRoTDzTw3-RvZ9EBOXO38fe88ePBGQHHizQIt9VqHyRzdvapskzQl9atiVXrQUIdCRw--ngepHztpS-vcBJY262dOAKVm5CdXgo053yI/vv2Skwlbni1Qse1TH1ubcvNvXSPpli0c9TLHVuf0nF4'), ('width', 320), ('height', 146)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jIk1yg5CKhu9l6FznBsK3w/45KgfE9tKbL28sTrRZd40PTkv1eJ_w5C9Uo7nwR3IY73itVIQvacIZHn2nxYcjYzcEA0m2NG_N3WuPnl-ShkFXK0u_IDHKHm1-4-iY7GjNQ/rZea2iEYNRG_xeR4Th0VgZwx4GrGq55BUsWbExQ1O4o'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2604B SourceMeter SMU instrument is a new dual channel SMU instrument with best-in-class value and performance. Its tightly integrated four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The Model 2604B is equipped with our high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2604B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2602B SourceMeter SMU Instrument that includes digital I/O, TSP-Link technology, and contact check function. The wide range of 3A DC, 10A pulse, 40V output makes the Model 2604B suitable for testing a wide range of higher current devices, materials, components, and sub-assemblies.",https://airtable.com/appltTe3yZzVV3Ouj/tblL9tOZ9MjjSCZoS/viwuhy7fMXGLRPE9u?blocks=hide,Keithley 2604 B,247.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2604B.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2604B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782437/Instruments/Power%20Supplies/Keithley-2604B/Keithley-2604B.webp,Keithley 2604B,Write a Python script that uses Qcodes to connect to a Keithley 2604B Power Supplies,17514.0,,,,"from ._Keithley_2600 import Keithley2600


class Keithley2604B(Keithley2600):
    """"""
    QCoDeS driver for the Keithley 2604B Source-Meter
    """"""

    pass
"
23,https://download.tek.com/datasheet/76W-20381-3.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'att98yXFO6xRfBxDx'), ('width', 721), ('height', 481), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8A8k0BlxgpD2xrbCLBWUoA/prBdJbuT9OPOOxAJ5l-dXuUOiSUOK6FiYwe2_zxtvpr9jHYW0i4zFb2OAOYBaEYpoHUR-KBsJNPnIGosdf7QfcCEPlcrhBVq8KMXuGuKOOQ/qtXV-Iy3jsnRCPv0PPV4yHTlGVJQfb4vwc6TEgE5EbA'), ('filename', 'TEKAWG5208-1.webp'), ('size', 21040), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xcI4uy4jL7D6oTaXmk0UwQ/CdvJUB9wkORdLbnrGvd2BjYdPe5FprXEjQHXDYQtZ5zrDIvv3FziuWjTM861Z93o_bA8tCp0FJiE4_-1qVMEXjBI2ZLlk62t6NmXGxlwPJs/J_GMCA2woqP9tIpyw-Ibge5dCQsDSmJGdN7r7NOUvb0'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B8bZvEzhKXkb47MKlPSo_g/eit_Y-Glg9hN-Pz1TeyyjZA4dQvdJUjAv1wVG_PwamAqYJFcukGlwJMtmb5uJeLFzr7mayiapPsuIbyNomgYDkmxFcQLvPTsg6ttJvqfqEA/BFdr8YVoNILszyFZSYhLypNFyq6Ru8TFqaXHPrlVAIc'), ('width', 721), ('height', 481)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7MU9RscZl4gq_pim7MXiwA/de5dVGFqXuOcULheAt86hTKM8COmXcI5L21TUkaPgjubBAeeHlPu_ZFTXquIRsiRrJ5yh8829oNs14fa7y-jnDrqa6S1vTGM1BavpO0ZYY8/TqpPOs94bklp-YR8Q88w8sScOPprodSMp1lphXHMdFY'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"AWG5000 Series models, with a 14
bits DA converter based sample rate
from 600 MS/s to 1.2 GS/s, two to four output channels, synchronized four to eight digital marker outputs, and 28-channels of digital data outputs, easilysolve the toughest measurement challenges in wireless base band I/Q communications, digital consumer product design such as imaging devices, data conversion equipment and semiconductor design and test",https://www.tek.com/en/datasheet/awg5000-series,AWG 5208,557.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG5208.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG5208,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782440/Instruments/RF%20Signal%20Generator/AWG5208/AWG5208.webp,AWG5208,Write a Python script that uses Qcodes to connect to a AWG5208 RF Signal Generator,,,True,,"from typing import Any

from .AWG70000A import AWG70000A


class TektronixAWG5208(AWG70000A):
    """"""
    The QCoDeS driver for Tektronix AWG5208
    """"""

    def __init__(self, name: str, address: str,
                 timeout: float = 10, **kwargs: Any) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds).
        """"""

        super().__init__(name, address, num_channels=8,
                         timeout=timeout, **kwargs)


class AWG5208(TektronixAWG5208):
    """"""
    Alias with non-conformant name left for backwards compatibility
    """"""

    pass
"
24,https://www.baspi.ch/_files/ugd/68eb62_d9c26342fd8f4960a2ebee967ff5a9d4.pdf,https://www.by-rutgers.nl/IV-converter.html,"[OrderedDict([('id', 'attrqrvLofLNFwEwM'), ('width', 1556), ('height', 686), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gA3zqylz04vUWnwD6XbnaQ/LCe01YJoBbme6cbq7em9A2_nqvbKYjTiBIonQZjU5tunrTMVUZxuqhkoZSaT8gBt309-IE_PQgf0TnjyBqMmVYnMJHz29EXmZk2V3jFapEc/UxZlimjyHlURoA0ppOrU327SxVFV7FuWxu0jYY9Wthk'), ('filename', 'IV converter.webp'), ('size', 125458), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BFiq0b6WTvCv3ELJNQ75yw/Ayg775OKiAEjgDpZpAKURi2rQld2jB8n9nDKJJoYSDwI2IJPDFDlSFN5Y4CwY8xsG4pJXGbLmg77o75qDKsTQXq2eQudRbciF7sYI2ber-M/NW3MXQu6Iw5mi35lmfmXEr1Cqfk9YCjDR0huiybJ75Q'), ('width', 82), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xTuq8MEc6NsIgGjhVv3TDg/xqzzB7E2WCJInGoeCUXHRPBBeJtlXF9vuai6Y_d8ViwyzqP0QWS4F8jXWTNplDgpUcncD9r6LOCqCHiUgr1HtBggpccyhw6N9OgvrZ4_c9U/axvD9CrKMogrRQDNsOPfHRV4MYPrIREd2ywpfn1K8Jw'), ('width', 1161), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Xh5HPxKsjkzPFNJei9hSAg/EmDNkg7i13zWFNk2jPFoMtM1pPb2BlPY94t_W8glpXvLr6SnHO9oQUwCs40OqzqUpjRaB5WIukXX1qNRMZ7W5bKCVGeRKUpzFER7OU71ork/r7uYQVWLgOLW5_07Y8beeOlhvEOOwnWEkaphxC8TqIs'), ('width', 3000), ('height', 3000)]))]))])]",1.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116675/Instruments/Vendor%20Logos/Basel.png,"The low-noise high-stability (LNHS) I to V Converter offers ultra-low noise, excellent stability, and unique features such as a floating input and the possibility to apply an external bias voltage",https://www.baspi.ch/low-noise-high-stab-itov-conv,SP 983 C,105.0,['IV Converter'],An I/V-convertor is intended to convert the current from a DAC (Digital Analog Convertor) into an analog voltage and to filter this signal to keep out the alias frequencies,"Basel Precision Instruments develop ultra-low-noise precision laboratory and scientific electronics for applications requiring ultra-high sensitivity, such as low-temperature quantum physics.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/basel/BaselSP983c.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Basel.html#qcodes.instrument_drivers.basel.BaselSP983c,Basel,"[OrderedDict([('id', 'attcofhhVdBDZ49OD'), ('width', 2359), ('height', 1152), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/sgBCv3__KaBxrbSymVRP7g/GjPhwz9w8kRkCugzus-QhtnUzLB0fd9Nlj1rcOOzDB6h2GnWuAi-gseDACLYHJkJlg-VpBiR9do0Lq2N8XxPpFEXVj7PhojNk0ZElBPiKdg/2YV0oORcYuzGLubY5GquF72qKRFX62Qdml63_rRyz3A'), ('filename', 'baspi-logo-i.jpg'), ('size', 238504), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qYXdFpLC53FyrSavF-lqJA/f_AaawubCIsW2xZaDyROvZ_eim2VBVI6TVhv3vSm4hGD7WkDCDyCIZ7w64m-QUvOsdUvNjJd54PZ6wz8xrJvfw/hnQJw3Kf3xFuamQkALom-ZWZqtIB9OFt9kDJQmhnHxM'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KazY-lT2GAKcpw8h7W7seA/8AEfaYgNHsTeSb-yhabTkdg41xbz00pID5NzlDFguPifsy9wrnqHgZXbSE4GUBlG9HVx2NxCMFaf00BsJCfo0g/XWFN2Xph7xEvwsYZssVodazOK66K94zkz8xeHMpgCWY'), ('width', 1048), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/E47Q5jGfBbWAgxg_X47xPQ/zd1zz9Gjqb9Fsb7TLAX0oJ5h4z4al2XOdT0TUxaXFP4vVK4PCah1KS5TPuXMlGOvBJeNDuTHX2KzhaQ1VzZaOw/6jcUuYMhdg-rR_tqse5QCTRxX7uh717wSEifWOoWRaE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.baspi.ch/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782441/Instruments/IV%20Converter/SP983c/SP983c.webp,SP983c,Write a Python script that uses Qcodes to connect to a SP983c IV Converter,,,,,"from typing import Optional

from .BaselSP983 import BaselSP983


class BaselSP983c(BaselSP983):
    """"""
    A virtual driver for the Basel SP 983c current to voltage converter.

    This driver supports both the SP 983 and SP 983c models. These differ only
    in their handling of input offset voltage. It is the responsibility of the
    user to capture the input offset, (from the voltage supply) and compensate
    that as needed for SP 983. For SP 983c model, 'input_offset_voltage'
    argument can be used to set up offset (This doesn't work for SP 983c01
    model).

    Note that, as this is a purely virtual driver, there is no support
    for the remote control interface (SP 983a). It is the responsibility of
    the user to ensure that values set here are in accordance with the values
    set on the instrument.

    Args:
        name
        input_offset_voltage: (Optional) A source input offset voltage
            parameter. The range for input is -10 to 10 Volts and it is
            user's responsibility to ensure this. This source parameter is
            used to set offset voltage parameter of the preamp and the
            source parameter should represent a voltage source that is
            connected to the ""Offset Input Voltage"" connector of the SP983C.
    """"""

    def get_idn(self) -> dict[str, Optional[str]]:
        vendor = ""Physics Basel""
        model = ""SP 983c""
        serial = None
        firmware = None
        return {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
"
28,https://docs.zhinst.com/pdf/ziSHFQC_UserManual.pdf,https://www.zhinst.com/americas/en/products/shfqc-qubit-controller,"[OrderedDict([('id', 'att78kCP7VAAtY058'), ('width', 1183), ('height', 405), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/m2IhdUknWKl7WuzAstEpzQ/BozW0xkmOxhu-5HTRtSeZ_xrfEafOI1Yftp6FVQa4s6W5OmZmAm0YWdTRhajU1i9PHdU5i5_3O9m_aBcDVFDvPSQON-c4hzbpFhAeDJSCiVtIOVG4mj6Y0e_AsFLyoJ5/w3izATsS9A3f-efkati07se8LmT6lyiIu3P9XjofpN8'), ('filename', 'SHFQC_8_schraeg_2800.jpg.webp'), ('size', 39270), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oI31OwbssrPsKNIlsHHQDA/JDU6GSbSPFd1l1aLZQQelAh4AaXAriqCqIV40Vqc1B5SzNm9YfNdfCf5XY4znI3w49DYrqaPryrNWc-5Oqv2eUQ1kGNtFsfWZ03en0Zcjso/ikWdFR9-rEhQrZoN5vvOt1AFztDR71i9Z4153yQ64xw'), ('width', 105), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/D-G43xA6Fs2Wmva0RMT8ww/IbLvD5yG3X5IwmUQxbHODKyV19M4mWTzJ8Zwhi2quX_LlHUL6wlrDSPGRaSl7VA_c20yfJZbzq_4IxDzouv3LAcK6cUsdWLwqtsPZZZUIkw/4Kj4IDJV8_UseUoIvmlp6Mqfd6_VrZp_d9iQYXGB93Y'), ('width', 1183), ('height', 405)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NUhsu3jHiIo3F2XJdXD6_g/PGi9cuFktPr_JCNUVhF068tH05i8IUB5kn6yzw2FeL0NkwEp9m9tq6DQVM9sdNIaRVYqhBTKjYyZRFxvetTrjD2BEeuUBu85Xd6jcKhdhNo/Hic_oPMnWQE1RGCZfP9dLbMwOYZk6_7UufGCA6C63TI'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The SHFQC Qubit Controller can control, read out and provide fast feedback on up to 6 superconducting qubits. It integrates the functionality of the SHFQA Quantum Analyzer, the SHFSG Signal Generator and more in a single instrument. ",https://www.zhinst.com/americas/en/products/shfqc-qubit-controller,Shfqc,643.0,['Qubit Controller'],"Each control channel of the SHFQC has its own powerful sequencer for creating phase- and timing-programmable waveforms, so that a single SHFQC can control or couple qubits with pulses from DC to 8.5 GHz, and react at any time on measurements from the readout channel. With the SHFQC-16W upgrade option, the readout channel's freely configurable integration weights and readout-pulse memories are doubled from 8 to 16. This provides more flexibility in configuring the readout, e.g. by enabling full real-time control and readout of 6 qutrits.

","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqc.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfqc.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782444/Instruments/Qubit%20Controller/SHFQC/SHFQC.webp,SHFQC,Write a Python script that uses Qcodes to connect to a SHFQC Qubit Controller,,,,,"""""""Autogenerated module for the SHFQC QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWGCore(ZINode):
    """"""AWG Core Node.""""""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""awg"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)

    def configure_marker_and_trigger(
        self, *, trigger_in_source: str, trigger_in_slope: str, marker_out_source: str
    ) -> None:
        """"""Configures the trigger inputs and marker outputs of the AWG.

        Args:
            trigger_in_source: Alias for the trigger input used by the
                sequencer. For a list of available values use:
                `available_trigger_inputs`
            trigger_in_slope: Alias for the slope of the input trigger
                used by sequencer. For a list of available values use
                `available_trigger_inputs`
            marker_out_source: Alias for the marker output source used by
                the sequencer. For a list of available values use
                `available_trigger_slopes`
        """"""
        return self._tk_object.configure_marker_and_trigger(
            trigger_in_source=trigger_in_source,
            trigger_in_slope=trigger_in_slope,
            marker_out_source=marker_out_source,
        )

    @property
    def available_trigger_inputs(self) -> List:
        """"""List the available trigger sources for the sequencer.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_trigger_slopes(self) -> List:
        """"""List the available trigger slopes for the sequencer.""""""
        return self._tk_object.available_trigger_slopes

    @property
    def available_marker_outputs(self) -> List:
        """"""List the available trigger marker outputs for the sequencer.""""""
        return self._tk_object.available_marker_outputs


class SGChannel(ZINode):
    """"""Signal Generator Channel for the SHFSG.

    :class:`SGChannel` implements basic functionality to configure SGChannel
    settings of the :class:`SHFSG` instrument.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""sgchannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.awg:

            self.add_submodule(
                ""awg"",
                AWGCore(
                    self,
                    self._tk_object.awg,
                    zi_node=self._tk_object.awg.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self, *, enable: bool, output_range: int, center_frequency: float, rf_path: bool
    ) -> None:
        """"""Configures the RF input and output.

        Args:
            enable: Flag if the signal output should be enabled.
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency before modulation
            rf_path: Flag if the RF(True) or LF(False) path should be
                configured.
        """"""
        return self._tk_object.configure_channel(
            enable=enable,
            output_range=output_range,
            center_frequency=center_frequency,
            rf_path=rf_path,
        )

    def configure_pulse_modulation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        global_amp: float = 0.5,
        gains: tuple = (1.0, -1.0, 1.0, 1.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configure the pulse modulation.

        Configures the sine generator to digitally modulate the AWG output, for
        generating single sideband AWG signals

        Args:
            enable: Flag if the modulation should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used to modulate the AWG
                outputs. (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            global_amp: Global scale factor for the AWG outputs. (default = 0.5)
            gains: Sets the four amplitudes used for single sideband generation.
                Default values correspond to upper sideband with a positive
                oscillator frequency. (default = (1.0, -1.0, 1.0, 1.0))
            sine_generator_index: Selects which sine generator to use on a
                given channel.
        """"""
        return self._tk_object.configure_pulse_modulation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            global_amp=global_amp,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    def configure_sine_generation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        gains: tuple = (0.0, 1.0, 1.0, 0.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configures the sine generator output.

        Configures the sine generator output of a specified channel for generating
        continuous wave signals without the AWG.

        Args:
            enable: Flag if the sine generator output should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used by the sine generator
                (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            gains: Sets the four amplitudes used for single sideband
                generation. Default values correspond to upper sideband with a
                positive oscillator frequency.
                Gains are set in the following order I/sin, I/cos, Q/sin, Q/cos.
                (default = (0.0, 1.0, 1.0, 0.0))
            sine_generator_index: Selects which sine generator to use on a given
                channel
        """"""
        return self._tk_object.configure_sine_generation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    @property
    def awg_modulation_freq(self) -> float:
        """"""Modulation frequency of the AWG.

        Depends on the selected oscillator.
        """"""
        return self._tk_object.awg_modulation_freq


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQC(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQC.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.sgchannels:

            channel_list = ZIChannelList(
                self,
                ""sgchannels"",
                SGChannel,
                zi_node=self._tk_object.sgchannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.sgchannels):
                channel_list.append(
                    SGChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.sgchannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""sgchannels"", channel_list)

        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
29,https://www.farnell.com/datasheets/3540326.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attU27V7yxtikH7Dx'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IJ2fmQEiQg7XwbtQU7rOxQ/gVdS8wFupgIaEjihBCzV2a761wpDnm7AzY8BF9Wa9sZUMfhgNgmljBnuiH7i2LqsrewTYAApsJmDDXFSWvRSb0BUup_y_25cTFMpnNvdAyQ/FHM13Th10KEstKNVGHnQyXFMt3-MAhZVCrBhxz08aLo'), ('filename', '7510.webp'), ('size', 20588), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nOfYJzXObrVfAGtZcVBkfQ/XNSmqPCj_a5iJiXvKr8C0wpZgjiLrmND4e1PzbkYLCsVlrb0V7uTSxx_8O-W8lzVullTYWijFrPdvPunOh1ns6TnZboCJxtPO0nRR0FkjLo/i9uLXUl4f27adFM2aPZ42zD6eWo4NrAJE4-po1UToI4'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3n3bBpbflK6wmal4vPUQfg/lZXhvPyxyuRGbvQ-4eNTbrYVpozomrQ8Ni-zUrADHeCOW60QaxI6TeDymcMAB9PeWw8YPxzcgessTqFDSaBaqiTuZ6DSAJ6tcmNg61gmeow/QhzM9fCJHXMKcF2N_vH4ncDSp16bAK8XLdTAUhf94-Y'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cZpLQ8UXW2UtqdD1IyfEUg/Ni2YqtKe-mTiQ9ex4MpovItrpIOeG_AMk3kC0XNXQOVaGpETVOTIFqx_tddwhVTGaumaBHqQWTxqHOoFJnbWgaXsuEwh14x-5eXWx-lY7d4/3Dr8X4Pj_yKDSCgsmYxg8mIO0tqV1Sm-iP3sCAlZv34'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The DMM7510 7.5 digit multimeter combines a precision, high-resolution digital multimeter (DMM), graphical touchscreen display, and high-speed, high-resolution digitizer to create the first graphical sampling multimeter. With pA-level sensitivity and 1Msample/s sampling, it accurately measures ultra-low sleep mode currents and transmit drain currents from wireless devices. ",https://www.tek.com/en/products/keithley/digital-multimeter/dmm7510,Keithley 7510,252.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_7510.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley7510,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782445/Instruments/Multimeters/DMM7510-Keithley/DMM7510-Keithley.webp,DMM7510 Keithley ,Write a Python script that uses Qcodes to connect to a DMM7510 Keithley  Multimeters,7050.0,,,,"from collections.abc import Sequence
from types import TracebackType
from typing import Any, Optional, Union, cast

import numpy as np

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    DelegateParameter,
    MultiParameter,
    Parameter,
    ParamRawDataType,
    create_on_off_val_mapping,
    invert_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Lists, Numbers


class DataArray7510(MultiParameter):
    """"""
    Data class when user selected more than one field for data output.
    """"""

    _data: tuple[tuple[Any, ...], ...] = ((), ())

    def __init__(
        self,
        names: Sequence[str],
        shapes: Sequence[Sequence[int]],
        setpoints: Optional[Sequence[Sequence[Any]]],
        **kwargs: Any,
    ):
        super().__init__(
            name=""data_array_7510"",
            names=names,
            shapes=shapes,
            setpoints=setpoints,
            **kwargs,
        )
        for param_name in self.names:
            self.__dict__.update({param_name: []})

    def get_raw(self) -> Optional[tuple[ParamRawDataType, ...]]:
        return self._data


class GeneratedSetPoints(Parameter):
    """"""
    A parameter that generates a setpoint array from start, stop and num points
    parameters.
    """"""

    def __init__(
        self,
        start: Parameter,
        stop: Parameter,
        n_points: Parameter,
        *args: Any,
        **kwargs: Any,
    ):
        super().__init__(*args, **kwargs)
        self._start = start
        self._stop = stop
        self._n_points = n_points

    def get_raw(self) -> np.ndarray:
        start = self._start()
        assert start is not None
        stop = self._stop()
        assert stop is not None
        n_points = self._n_points()
        assert n_points is not None

        return np.linspace(start, stop, n_points)


class Keithley7510Buffer(InstrumentChannel):
    """"""
    Treat the reading buffer as a submodule, similar to Sense.
    """"""

    default_buffer = {""defbuffer1"", ""defbuffer2""}

    buffer_elements = {
        ""date"": ""DATE"",
        ""measurement_formatted"": ""FORMatted"",
        ""fractional_seconds"": ""FRACtional"",
        ""measurement"": ""READing"",
        ""relative_time"": ""RELative"",
        ""seconds"": ""SEConds"",
        ""measurement_status"": ""STATus"",
        ""time"": ""TIME"",
        ""timestamp"": ""TSTamp"",
        ""measurement_unit"": ""UNIT"",
    }

    inverted_buffer_elements = invert_val_mapping(buffer_elements)

    def __init__(
        self,
        parent: ""Keithley7510"",
        name: str,
        size: Optional[int] = None,
        style: str = """",
    ) -> None:
        super().__init__(parent, name)
        self._size = size
        self.style = style

        if self.short_name not in self.default_buffer:
            # when making a new buffer, the ""size"" parameter is required.
            if size is None:
                raise TypeError(
                    ""buffer() missing 1 required positional argument: 'size'""
                )
            self.write(f"":TRACe:MAKE '{self.short_name}', {self._size}, {self.style}"")
        else:
            # when referring to default buffer, ""size"" parameter is not needed.
            if size is not None:
                self.log.warning(
                    f""Please use method 'size()' to resize default buffer ""
                    f""{self.short_name} size to {self._size}.""
                )

        self.add_parameter(
            ""size"",
            get_cmd=f"":TRACe:POINts? '{self.short_name}'"",
            set_cmd=f"":TRACe:POINts {{}}, '{self.short_name}'"",
            get_parser=int,
            docstring=""The number of readings a buffer can store."",
        )

        self.add_parameter(
            ""number_of_readings"",
            get_cmd=f"":TRACe:ACTual? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the number of readings in the reading buffer."",
        )

        self.add_parameter(
            ""last_index"",
            get_cmd=f"":TRACe:ACTual:END? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the last index of readings in the reading buffer."",
        )

        self.add_parameter(
            ""first_index"",
            get_cmd=f"":TRACe:ACTual:STARt? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the starting index of readings in the reading "" ""buffer."",
        )

        self.add_parameter(
            ""data_start"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            docstring=""First index of the data to be returned."",
        )

        self.add_parameter(
            ""data_end"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            docstring=""Last index of the data to be returned."",
        )

        self.add_parameter(
            ""elements"",
            get_cmd=None,
            get_parser=self._from_scpi_to_name,
            set_cmd=None,
            set_parser=self._from_name_to_scpi,
            vals=Lists(Enum(*list(self.buffer_elements.keys()))),
            docstring=""List of buffer elements to read."",
        )

        self.add_parameter(
            ""setpoints_start"",
            label=""start value for the setpoints"",
            source=None,
            parameter_class=DelegateParameter,
        )

        self.add_parameter(
            ""setpoints_stop"",
            label=""stop value for the setpoints"",
            source=None,
            parameter_class=DelegateParameter,
        )

        self.add_parameter(
            ""n_pts"", label=""total n for the setpoints"", get_cmd=self._get_n_pts
        )

        self.add_parameter(
            ""setpoints"",
            parameter_class=GeneratedSetPoints,
            start=self.setpoints_start,
            stop=self.setpoints_stop,
            n_points=self.n_pts,
            vals=Arrays(shape=(self.n_pts.get_latest,)),
        )

        self.add_parameter(
            ""t_start"",
            label=""start time"",
            unit=""s"",
            initial_value=0,
            get_cmd=None,
            set_cmd=None,
            set_parser=float,
        )

        self.add_parameter(
            ""t_stop"",
            label=""stop time"",
            unit=""s"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            set_parser=float,
        )

        self.add_parameter(
            ""fill_mode"",
            get_cmd=f"":TRACe:FILL:MODE? '{self.short_name}'"",
            set_cmd=f"":TRACe:FILL:MODE {{}}, '{self.short_name}'"",
            vals=Enum(""CONT"", ""continuous"", ""ONCE"", ""once""),
            docstring=""if a reading buffer is filled continuously or is filled""
            "" once and stops"",
        )

    def _from_name_to_scpi(self, element_names: list[str]) -> list[str]:
        return [self.buffer_elements[element] for element in element_names]

    def _from_scpi_to_name(self, element_scpis: list[str]) -> list[str]:
        if element_scpis is None:
            return []
        return [self.inverted_buffer_elements[element] for element in element_scpis]

    def _get_n_pts(self) -> int:
        return self.data_end() - self.data_start() + 1

    def set_setpoints(
        self, start: Parameter, stop: Parameter, label: Optional[str] = None
    ) -> None:
        self.setpoints_start.source = start
        self.setpoints_stop.source = stop
        self.setpoints.unit = start.unit
        if label is not None:
            self.setpoints.label = label

    def __enter__(self) -> ""Keithley7510Buffer"":
        return self

    def __exit__(
        self,
        exception_type: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None:
        self.delete()

    @property
    def available_elements(self) -> set[str]:
        return set(self.buffer_elements.keys())

    @property
    def n_elements(self) -> int:
        return max(1, len(self.elements()))

    @property
    def data(self) -> DataArray7510:
        return self._get_data()

    def get_last_reading(self) -> str:
        """"""
        This method requests the latest reading from a reading buffer.

        """"""
        if not self.elements():
            return self.ask(f"":FETCh? '{self.short_name}'"")
        fetch_elements = [self.buffer_elements[element] for element in self.elements()]
        return self.ask(f"":FETCh? '{self.short_name}', {','.join(fetch_elements)}"")

    def _get_data(self) -> DataArray7510:
        """"""
        This command returns the data in the buffer, depends on the user
        selected elements.
        """"""
        try:
            _ = self.setpoints()
        except NotImplementedError:
            # if the ""setpionts"" has not been implemented, use a time series
            # with parameters ""t_start"" and ""t_stop"":
            self.set_setpoints(self.t_start, self.t_stop)

        if self.parent.digi_sense_function() == ""None"":
            # when current sense is not digitize sense
            sense_function = self.parent.sense_function()
            unit = Keithley7510Sense.function_modes[sense_function][""unit""]
        else:
            # when current sense is digitize sense
            sense_function = self.parent.digi_sense_function()
            unit = Keithley7510DigitizeSense.function_modes[sense_function][""unit""]

        elements_units = {
            ""date"": ""str"",
            ""measurement_formatted"": ""str"",
            ""fractional_seconds"": ""s"",
            ""measurement"": unit,
            ""relative_time"": ""s"",
            ""seconds"": ""s"",
            ""measurement_status"": """",
            ""time"": ""str"",
            ""timestamp"": ""str"",
            ""measurement_unit"": ""str"",
        }

        if not self.elements():
            raw_data = self.ask(
                f"":TRACe:DATA? ""
                f""{self.data_start()}, ""
                f""{self.data_end()}, ""
                f""'{self.short_name}'""
            )
        else:
            elements = [self.buffer_elements[element] for element in self.elements()]
            raw_data = self.ask(
                f"":TRACe:DATA? {self.data_start()}, ""
                f""{self.data_end()}, ""
                f""'{self.short_name}', ""
                f""{','.join(elements)}""
            )

        all_data = raw_data.split("","")

        if len(self.elements()) == 0:
            elements = [""measurement""]
        else:
            elements = self.elements()
        n_elements = len(elements)

        units = tuple(elements_units[element] for element in elements)
        processed_data = dict.fromkeys(elements)
        for i, (element, unit) in enumerate(zip(elements, units)):
            if unit == ""str"":
                processed_data[element] = np.array(all_data[i::n_elements])
            else:
                processed_data[element] = np.array(
                    [float(v) for v in all_data[i::n_elements]]
                )

        data = DataArray7510(
            names=tuple(elements),
            shapes=((self.n_pts(),),) * n_elements,
            units=units,
            setpoints=((self.setpoints(),),) * n_elements,
            setpoint_units=((self.setpoints.unit,),) * n_elements,
            setpoint_names=((self.setpoints.label,),) * n_elements,
        )
        data._data = tuple(
            tuple(processed_data[element]) for element in elements  # type: ignore[arg-type]
        )
        for i in range(len(data.names)):
            setattr(data, data.names[i], tuple(processed_data[data.names[i]]))  # type: ignore[arg-type]
        return data

    def clear_buffer(self) -> None:
        """"""
        Clear the data in the buffer
        """"""
        self.write(f"":TRACe:CLEar '{self.short_name}'"")

    def trigger_start(self) -> None:
        """"""
        This method makes readings using the active measure function and
        stores them in a reading buffer.
        """"""
        self.write(f"":TRACe:TRIGger '{self.short_name}'"")

    def delete(self) -> None:
        if self.short_name not in self.default_buffer:
            self.parent.submodules.pop(f""_buffer_{self.short_name}"")
            self.parent.buffer_name(""defbuffer1"")
            self.write(f"":TRACe:DELete '{self.short_name}'"")


class Keithley7510Sense(InstrumentChannel):
    """"""
    The sense module of the Keithley 7510 DMM, based on the sense module of
    Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of modes listed in the dictionary
            ""function_modes"", e.g.,  ""current"", ""voltage"", or ""resistance"".
            ""voltage""/""current"" is for DC voltage/current.
            ""Avoltage""/""Acurrent"" is for AC voltage/current.
            ""resistance"" is for two-wire measurement of resistance.
            ""Fresistance"" is for Four-wire measurement of resistance.

            All parameters and methods in this submodule should only be
            accessible to the user if
            self.parent.sense_function.get() == self._proper_function. We
            ensure this through the 'sense' property on the main driver class
            which returns the proper submodule for any given function mode.
    """"""

    function_modes = {
        ""voltage"": {
            ""name"": '""VOLT:DC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 1000),
        },
        ""Avoltage"": {
            ""name"": '""VOLT:AC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 700),
        },
        ""current"": {
            ""name"": '""CURR:DC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(10e-6, 10),
        },
        ""Acurrent"": {
            ""name"": '""CURR:AC""',
            ""unit"": ""A"",
            ""range_vals"": Numbers(1e-3, 10),
        },
        ""resistance"": {
            ""name"": '""RES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(10, 1e9),
        },
        ""Fresistance"": {
            ""name"": '""FRES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(1, 1e9),
        },
    }

    def __init__(self, parent: VisaInstrument, name: str, proper_function: str) -> None:

        super().__init__(parent, name)

        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.sense_function

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            get_parser=float,
            unit=unit,
            docstring=""Make measurements, place them in a reading buffer, and ""
            ""return the last reading."",
        )

        self.add_parameter(
            ""auto_range"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO?"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Determine if the measurement range is set manually or ""
            ""automatically for the selected measure function."",
        )

        self.add_parameter(
            ""range"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe?"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe {{}}"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
            docstring=""Determine the positive full-scale measure range."",
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=f"":SENSe:{self._proper_function}:NPLCycles?"",
            set_cmd=f"":SENSe:{self._proper_function}:NPLCycles {{}}"",
            vals=Numbers(0.01, 10),
            get_parser=float,
            docstring=""Set the time that the input signal is measured for the ""
            ""selected function.(NPLC = number of power line cycles)"",
        )

        self.add_parameter(
            ""auto_delay"",
            get_cmd=f"":SENSe:{self._proper_function}:DELay:AUTO?"",
            set_cmd=f"":SENSe:{self._proper_function}:DELay:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Enable or disable the automatic delay that occurs ""
            ""before each measurement."",
        )

        self.add_parameter(
            ""user_number"",
            get_cmd=None,
            set_cmd=None,
            vals=Ints(1, 5),
            docstring=""Set the user number for user-defined delay."",
        )

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            vals=Numbers(0, 1e4),
            unit=""second"",
            docstring=""Set a user-defined delay that you can use in the ""
            ""trigger model."",
        )

        self.add_parameter(
            ""auto_zero"",
            get_cmd=f"":SENSe:{self._proper_function}:AZERo?"",
            set_cmd=f"":SENSe:{self._proper_function}:AZERo {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enable or disable automatic updates to the internal ""
            ""reference measurements (autozero) of the instrument."",
        )

        self.add_parameter(
            ""auto_zero_once"",
            set_cmd="":SENSe:AZERo:ONCE"",
            docstring=""Cause the instrument to refresh the reference and ""
            ""zero measurements once"",
        )

        self.add_parameter(
            ""average"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enable or disable the averaging filter for measurements ""
            ""of the selected function."",
        )

        self.add_parameter(
            ""average_count"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage:COUNt?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage:COUNt {{}}"",
            vals=Numbers(1, 100),
            docstring=""Set the number of measurements that are averaged when ""
            ""filtering is enabled."",
        )

        self.add_parameter(
            ""average_type"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage:TCONtrol?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage:TCONtrol {{}}"",
            vals=Enum(""REP"", ""rep"", ""MOV"", ""mov""),
            docstring=""Set the type of averaging filter that is used for the ""
            ""selected measure function when the measurement filter ""
            ""is enabled."",
        )

    def _get_user_delay(self) -> str:
        get_cmd = f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return self.ask(get_cmd)

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()} {value}""
        )
        self.write(set_cmd)

    def _measure(self) -> Union[float, str]:
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure? '{buffer_name}'""))

    def clear_trace(self, buffer_name: str = ""defbuffer1"") -> None:
        """"""
        Clear the data buffer
        """"""
        self.write(f"":TRACe:CLEar '{buffer_name}'"")


class Keithley7510DigitizeSense(InstrumentChannel):
    """"""
    The Digitize sense module of the Keithley 7510 DMM.
    """"""

    function_modes: dict[str, dict[str, Any]] = {
        ""None"": {""name"": '""NONE""', ""unit"": """", ""range_vals"": None},
        ""voltage"": {
            ""name"": '""VOLT""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 1000),
        },
        ""current"": {
            ""name"": '""CURR""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(10e-6, 10),
        },
    }

    def __init__(self, parent: VisaInstrument, name: str, proper_function: str) -> None:

        super().__init__(parent, name)

        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.digi_sense_function

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            unit=unit,
            docstring=""Make measurements, place them in a reading buffer, and ""
            ""return the last reading."",
        )

        self.add_parameter(
            ""range"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:RANGe?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:RANGe {{}}"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
            docstring=""Determine the positive full-scale measure range."",
        )

        self.add_parameter(
            ""input_impedance"",
            get_cmd="":SENSe:DIGitize:VOLTage:INPutimpedance?"",
            set_cmd="":SENSe:DIGitize:VOLTage:INPutimpedance {}"",
            vals=Enum(""AUTO"", ""MOHM10""),
            docstring=""Determine when the 10 MΩ input divider is enabled. ""
            ""'MOHM10' means 10 MΩ for all ranges."",
        )

        self.add_parameter(
            ""acq_rate"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:SRATE?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:SRATE {{}}"",
            vals=Ints(1000, 1000000),
            docstring=""Define the precise acquisition rate at which the ""
            ""digitizing measurements are made."",
        )

        self.add_parameter(
            ""aperture"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:APERture?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:APERture {{}}"",
            unit=""us"",
            docstring=""Determine the aperture setting."",
        )

        self.add_parameter(
            ""count"",
            get_cmd=""SENSe:DIGitize:COUNt?"",
            set_cmd=""SENSe:DIGitize:COUNt {}"",
            vals=Ints(1, 55000000),
            docstring=""Set the number of measurements to digitize when a ""
            ""measurement is requested"",
        )

    def _measure(self) -> Union[float, str]:
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure:DIGitize? '{buffer_name}'""))


class Keithley7510(VisaInstrument):
    """"""
    The QCoDeS driver for the Keithley 7510 DMM
    """"""

    def __init__(self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""sense_function"",
            set_cmd="":SENSe:FUNCtion {}"",
            get_cmd="":SENSe:FUNCtion?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley7510Sense.function_modes.items()
            },
            docstring=""Add sense functions listed in the function modes."",
        )

        self.add_parameter(
            ""digi_sense_function"",
            set_cmd="":DIGitize:FUNCtion {}"",
            get_cmd="":DIGitize:FUNCtion?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley7510DigitizeSense.function_modes.items()
            },
            docstring=""Make readings using the active digitize function."",
        )

        self.add_parameter(
            ""buffer_name"",
            get_cmd=None,
            set_cmd=None,
            docstring=""Name of the reading buffer in use."",
        )

        self.add_parameter(
            ""trigger_block_list"",
            get_cmd="":TRIGger:BLOCk:LIST?"",
            docstring=""Return the settings for all trigger model blocks."",
        )

        self.add_parameter(
            ""trigger_in_ext_clear"",
            set_cmd="":TRIGger:EXTernal:IN:CLEar"",
            docstring=""Clear the trigger event on the external in line."",
        )

        self.add_parameter(
            ""trigger_in_ext_edge"",
            get_cmd="":TRIGger:EXTernal:IN:EDGE?"",
            set_cmd="":TRIGger:EXTernal:IN:EDGE {}"",
            vals=Enum(""FALL"", ""RIS"", ""falling"", ""rising"", ""EITH"", ""either""),
            docstring=""Type of edge that is detected as an input on the ""
            ""external trigger in line"",
        )

        self.add_parameter(
            ""overrun_status"",
            get_cmd="":TRIGger:EXTernal:IN:OVERrun?"",
            docstring=""Return the event detector overrun status."",
        )

        self.add_parameter(
            ""digitize_trigger"",
            get_cmd="":TRIGger:DIGitize:STIMulus?"",
            set_cmd="":TRIGger:DIGitize:STIMulus {}"",
            vals=Enum(""EXT"", ""external"", ""NONE""),
            docstring=""Set the instrument to digitize a measurement the next ""
            ""time it detects the specified trigger event."",
        )

        self.add_parameter(
            ""system_errors"",
            get_cmd="":SYSTem:ERRor?"",
            docstring=""Return the oldest unread error message from the event ""
            ""log and removes it from the log."",
        )

        for proper_sense_function in Keithley7510Sense.function_modes:
            self.add_submodule(
                f""_sense_{proper_sense_function}"",
                Keithley7510Sense(self, ""sense"", proper_sense_function),
            )

        for proper_sense_function in Keithley7510DigitizeSense.function_modes:
            self.add_submodule(
                f""_digi_sense_{proper_sense_function}"",
                Keithley7510DigitizeSense(self, ""digi_sense"", proper_sense_function),
            )

        self.buffer_name(""defbuffer1"")
        self.buffer(name=self.buffer_name())
        self.connect_message()

    @property
    def sense(self) -> Keithley7510Sense:
        """"""
        We have different sense modules depending on the sense function.

        Return the correct source module based on the sense function.
        """"""
        sense_function = self.sense_function.get_latest() or self.sense_function()
        submodule = self.submodules[f""_sense_{sense_function}""]
        return cast(Keithley7510Sense, submodule)

    @property
    def digi_sense(self) -> Keithley7510DigitizeSense:
        """"""
        We have different sense modules depending on the sense function.

        Return the correct source module based on the sense function.
        """"""
        if self.digi_sense_function() == ""None"":
            raise AttributeError(
                ""Please use 'digi_sense_function()' to select""
                "" a digitize function first""
            )
        sense_function = (
            self.digi_sense_function.get_latest() or self.digi_sense_function()
        )
        submodule = self.submodules[f""_digi_sense_{sense_function}""]
        return cast(Keithley7510DigitizeSense, submodule)

    def buffer(
        self, name: str, size: Optional[int] = None, style: str = """"
    ) -> Keithley7510Buffer:
        self.buffer_name(name)
        if f""_buffer_{name}"" in self.submodules:
            return cast(Keithley7510Buffer, self.submodules[f""_buffer_{name}""])
        new_buffer = Keithley7510Buffer(parent=self, name=name, size=size, style=style)
        self.add_submodule(f""_buffer_{name}"", new_buffer)
        return new_buffer

    def initiate(self) -> None:
        """"""
        This command starts the trigger model.
        """"""
        self.write("":INITiate"")

    def wait(self) -> None:
        """"""
        This command postpones the execution of subsequent commands until all
        previous overlapped commands are finished.
        """"""
        self.write(""*WAI"")

    def clear_status(self) -> None:
        """"""
        This command clears the event registers of the Questionable Event and
        Operation Event Register set. It does not affect the Questionable Event
        Enable or Operation Event Enable registers.
        """"""
        self.write(""*CLS"")

    def reset(self) -> None:
        """"""
        Returns the instrument to default settings, cancels all pending
        commands.
        """"""
        self.write(""*RST"")
"
30,https://www.keysight.com/us/en/assets/9018-03959/technical-specifications/9018-03959.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attZoKpo6CTDzBvzw'), ('width', 500), ('height', 311), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1cb6yEv4ZZSVsJsvo0j2bw/2-2bxTCrD8xCRkenpyuJHTqTEStDrf5OAedv3dpzFIDgsoOJTAh9dTuMfCZt5WYQelWlWDgJseRi1ufIg_06sZMjj28jUD0D_fu886wOiug/eUpiUfr9VnqOpTLcE073V2yGc36xRROxnoGNzELzuF4'), ('filename', 'N5222B.2.jpg'), ('size', 32062), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/m9njKESeXxp9tzehzJb06g/BFfC62koSWSBBWNPRNKAHIdOp667JRHgzRbuTXVIy2UPdr2v03ilCEaLtw71JV_-M-bcWcqr1JPpjdKdlBeUZg/HuEp_kaknUvp44u5sOtrLl8KNG4WA25I9uegMruBU_w'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/V4nUtubQkTCR-wrtIHT5qg/HjFkzruNR60iGX_JGPIsmfggdDKT__q69T_zoAKJADRGWlwQ8zNMU-WoBlZZ21kaMcIer39cssn9Cxuy6-HWAw/-0IuJJclblhTL764q-KD2thHIZHXE0JnL_Up69Ib1IM'), ('width', 500), ('height', 311)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LvHk-YXHPxNn12lCHw-6Ig/IOowaxDMe0ieDvok506Jo3OhWAhe6zGBId1e3xxWighUJo8JQa-een4yumlwcMRYhkRDsPKt0ajk7JNKd1oorQ/v6IzQNQNQAt6iRddlHrIMt-BsOlkm9e1EGcwGXVS0nU'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight N5222B PNA Microwave Network Analyzer 10 MHz to 26.5 GHz is an integrated and flexible test engine that can measure active devices such as amplifiers, mixers, and frequency converters. This analyzer operates at a frequency range of 900 Hz to 26.5 GHz. The Keysight N5222B provides a combination of excellent hardware and powerful measurement applications to measure a broad range of devices quickly and accurately. ",https://www.atecorp.com/products/keysight-technologies/n5222b,Keysight N 5222 B,288.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N52xx.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5222B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782445/Instruments/Network%20Analyzer/Keysight-5222B/Keysight-5222B.jpg,Keysight 5222B,Write a Python script that uses Qcodes to connect to a Keysight 5222B Network Analyzer,,,,,"from typing import Sequence, Union, Any
import time
import re
import logging

import numpy as np
from pyvisa import VisaIOError, errors
from qcodes import (VisaInstrument, InstrumentChannel, ArrayParameter,
                    ChannelList)
from qcodes.utils.validators import Ints, Numbers, Enum, Bool

logger = logging.getLogger()

class PNASweep(ArrayParameter):
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 **kwargs: Any) -> None:

        super().__init__(name,
                         instrument=instrument,
                         shape=(0,),
                         setpoints=((0,),),
                         **kwargs)

    @property  # type: ignore[override]
    def shape(self) -> Sequence[int]:  # type: ignore[override]
        if self._instrument is None:
            return (0,)
        return (self._instrument.root_instrument.points(),)

    @shape.setter
    def shape(self, val: Sequence[int]) -> None:
        pass

    @property  # type: ignore[override]
    def setpoints(self) -> Sequence[np.ndarray]:  # type: ignore[override]
        if self._instrument is None:
            raise RuntimeError(""Cannot return setpoints if not attached ""
                               ""to instrument"")
        start = self._instrument.root_instrument.start()
        stop = self._instrument.root_instrument.stop()
        return (np.linspace(start, stop, self.shape[0]),)

    @setpoints.setter
    def setpoints(self, val: Sequence[int]) -> None:
        pass


class FormattedSweep(PNASweep):
    """"""
    Mag will run a sweep, including averaging, before returning data.
    As such, wait time in a loop is not needed.
    """"""
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 sweep_format: str,
                 label: str,
                 unit: str,
                 memory: bool = False) -> None:
        super().__init__(name,
                         instrument=instrument,
                         label=label,
                         unit=unit,
                         setpoint_names=('frequency',),
                         setpoint_labels=('Frequency',),
                         setpoint_units=('Hz',)
                         )
        self.sweep_format = sweep_format
        self.memory = memory

    def get_raw(self) -> Sequence[float]:
        if self._instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr = self._instrument.root_instrument
        # Check if we should run a new sweep
        if root_instr.auto_sweep():
            prev_mode = self._instrument.run_sweep()
        # Ask for data, setting the format to the requested form
        self._instrument.format(self.sweep_format)
        data = root_instr.visa_handle.query_binary_values('CALC:DATA? FDATA',
                                                          datatype='f',
                                                          is_big_endian=True)
        data = np.array(data)
        # Restore previous state if it was changed
        if root_instr.auto_sweep():
            root_instr.sweep_mode(prev_mode)

        return data


class PNAPort(InstrumentChannel):
    """"""
    Allow operations on individual PNA ports.
    Note: This can be expanded to include a large number of extra parameters...
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 port: int,
                 min_power: Union[int, float],
                 max_power: Union[int, float]) -> None:
        super().__init__(parent, name)

        self.port = int(port)
        if self.port < 1 or self.port > 4:
            raise ValueError(""Port must be between 1 and 4."")

        pow_cmd = f""SOUR:POW{self.port}""
        self.add_parameter(""source_power"",
                           label=""power"",
                           unit=""dBm"",
                           get_cmd=f""{pow_cmd}?"",
                           set_cmd=f""{pow_cmd} {{}}"",
                           get_parser=float,
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.source_power.vals = Numbers(min_value=min_power,
                                         max_value=max_power)


class PNATrace(InstrumentChannel):
    """"""
    Allow operations on individual PNA traces.
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 trace_name: str,
                 trace_num: int) -> None:
        super().__init__(parent, name)
        self.trace_name = trace_name
        self.trace_num = trace_num

        # Name of parameter (i.e. S11, S21 ...)
        self.add_parameter('trace',
                           label='Trace',
                           get_cmd=self._Sparam,
                           set_cmd=self._set_Sparam)
        # Format
        # Note: Currently parameters that return complex values are not
        # supported as there isn't really a good way of saving them into the
        # dataset
        self.add_parameter('format',
                           label='Format',
                           get_cmd='CALC:FORM?',
                           set_cmd='CALC:FORM {}',
                           vals=Enum('MLIN', 'MLOG', 'PHAS',
                                     'UPH', 'IMAG', 'REAL'))

        # And a list of individual formats
        self.add_parameter('magnitude',
                           sweep_format='MLOG',
                           label='Magnitude',
                           unit='dB',
                           parameter_class=FormattedSweep)
        self.add_parameter('linear_magnitude',
                           sweep_format='MLIN',
                           label='Magnitude',
                           unit='ratio',
                           parameter_class=FormattedSweep)
        self.add_parameter('phase',
                           sweep_format='PHAS',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter('unwrapped_phase',
                           sweep_format='UPH',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter(""group_delay"",
                           sweep_format='GDEL',
                           label='Group Delay',
                           unit='s',
                           parameter_class=FormattedSweep)
        self.add_parameter('real',
                           sweep_format='REAL',
                           label='Real',
                           unit='LinMag',
                           parameter_class=FormattedSweep)
        self.add_parameter('imaginary',
                           sweep_format='IMAG',
                           label='Imaginary',
                           unit='LinMag',
                           parameter_class=FormattedSweep)

    def run_sweep(self) -> str:
        """"""
        Run a set of sweeps on the network analyzer.
        Note that this will run all traces on the current channel.
        """"""
        root_instr = self.root_instrument
        # Store previous mode
        prev_mode = root_instr.sweep_mode()
        # Take instrument out of continuous mode, and send triggers equal to
        # the number of averages
        if root_instr.averages_enabled():
            avg = root_instr.averages()
            root_instr.reset_averages()
            root_instr.group_trigger_count(avg)
            root_instr.sweep_mode('GRO')
        else:
            root_instr.sweep_mode('SING')

        # Once the sweep mode is in hold, we know we're done
        try:
            while root_instr.sweep_mode() != 'HOLD':
                time.sleep(0.1)
        except KeyboardInterrupt:
            # If the user aborts because (s)he is stuck in the infinite loop
            # mentioned above, provide a hint of what can be wrong.
            msg = ""User abort detected. ""
            source = root_instr.trigger_source()
            if source == ""MAN"":
                msg += ""The trigger source is manual. Are you sure this is "" \
                       ""correct? Please set the correct source with the "" \
                       ""'trigger_source' parameter""
            elif source == ""EXT"":
                msg += ""The trigger source is external. Is the trigger "" \
                       ""source functional?""
            logger.warning(msg)

        # Return previous mode, incase we want to restore this
        return prev_mode

    def write(self, cmd: str) -> None:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        super().write(cmd)

    def ask(self, cmd: str) -> str:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        return super().ask(cmd)

    def _Sparam(self) -> str:
        """"""
        Extrace S_parameter from returned PNA format
        """"""
        paramspec = self.root_instrument.get_trace_catalog()
        specs = paramspec.split(',')
        for spec_ind in range(len(specs)//2):
            name, param = specs[spec_ind*2:(spec_ind+1)*2]
            if name == self.trace_name:
                return param
        raise RuntimeError(""Can't find selected trace on the PNA"")

    def _set_Sparam(self, val: str) -> None:
        """"""
        Set an S-parameter, in the format S<a><b>, where a and b
        can range from 1-4
        """"""
        if not re.match(""S[1-4][1-4]"", val):
            raise ValueError(""Invalid S parameter spec"")
        self.write(f""CALC:PAR:MOD:EXT \""{val}\"""")


class PNABase(VisaInstrument):
    """"""
    Base qcodes driver for Agilent/Keysight series PNAs
    http://na.support.keysight.com/pna/help/latest/Programming/GP-IB_Command_Finder/SCPI_Command_Tree.htm

    Note: Currently this driver only expects a single channel on the PNA. We
          can handle multiple traces, but using traces across multiple channels
          may have unexpected results.
    """"""

    def __init__(self,
                 name: str,
                 address: str,
                 # Set frequency ranges
                 min_freq: Union[int, float], max_freq: Union[int, float],
                 # Set power ranges
                 min_power: Union[int, float], max_power: Union[int, float],
                 nports: int, # Number of ports on the PNA
                 **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.min_freq = min_freq
        self.max_freq = max_freq

        #Ports
        ports = ChannelList(self, ""PNAPorts"", PNAPort)
        for port_num in range(1, nports+1):
            port = PNAPort(self, f""port{port_num}"", port_num,
                           min_power, max_power)
            ports.append(port)
            self.add_submodule(f""port{port_num}"", port)
        ports.lock()
        self.add_submodule(""ports"", ports)

        # Drive power
        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

        # IF bandwidth
        self.add_parameter('if_bandwidth',
                           label='IF Bandwidth',
                           get_cmd='SENS:BAND?',
                           get_parser=float,
                           set_cmd='SENS:BAND {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=1, max_value=15e6))

        # Number of averages (also resets averages)
        self.add_parameter('averages_enabled',
                           label='Averages Enabled',
                           get_cmd=""SENS:AVER?"",
                           set_cmd=""SENS:AVER {}"",
                           val_mapping={True: '1', False: '0'})
        self.add_parameter('averages',
                           label='Averages',
                           get_cmd='SENS:AVER:COUN?',
                           get_parser=int,
                           set_cmd='SENS:AVER:COUN {:d}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=65536))

        # Setting frequency range
        self.add_parameter('start',
                           label='Start Frequency',
                           get_cmd='SENS:FREQ:STAR?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STAR {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('stop',
                           label='Stop Frequency',
                           get_cmd='SENS:FREQ:STOP?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STOP {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('center',
                           label='Center Frequency',
                           get_cmd='SENS:FREQ:CENT?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:CENT {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('span',
                           label='Frequency Span',
                           get_cmd='SENS:FREQ:SPAN?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:SPAN {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))

        # Number of points in a sweep
        self.add_parameter('points',
                           label='Points',
                           get_cmd='SENS:SWE:POIN?',
                           get_parser=int,
                           set_cmd='SENS:SWE:POIN {}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=100001))

        # Electrical delay
        self.add_parameter('electrical_delay',
                           label='Electrical Delay',
                           get_cmd='CALC:CORR:EDEL:TIME?',
                           get_parser=float,
                           set_cmd='CALC:CORR:EDEL:TIME {:.6e}',
                           unit='s',
                           vals=Numbers(min_value=0, max_value=100000))

        # Sweep Time
        self.add_parameter('sweep_time',
                           label='Time',
                           get_cmd='SENS:SWE:TIME?',
                           get_parser=float,
                           unit='s',
                           vals=Numbers(0, 1e6))
        # Sweep Mode
        self.add_parameter('sweep_mode',
                           label='Mode',
                           get_cmd='SENS:SWE:MODE?',
                           set_cmd='SENS:SWE:MODE {}',
                           vals=Enum(""HOLD"", ""CONT"", ""GRO"", ""SING""))
        # Group trigger count
        self.add_parameter('group_trigger_count',
                           get_cmd=""SENS:SWE:GRO:COUN?"",
                           get_parser=int,
                           set_cmd=""SENS:SWE:GRO:COUN {}"",
                           vals=Ints(1, 2000000))
        # Trigger Source
        self.add_parameter('trigger_source',
                           get_cmd=""TRIG:SOUR?"",
                           set_cmd=""TRIG:SOUR {}"",
                           vals=Enum(""EXT"", ""IMM"", ""MAN""))

        # Traces
        self.add_parameter('active_trace',
                           label='Active Trace',
                           get_cmd=""CALC:PAR:MNUM?"",
                           get_parser=int,
                           set_cmd=""CALC:PAR:MNUM {}"",
                           vals=Numbers(min_value=1, max_value=24))
        # Note: Traces will be accessed through the traces property which
        # updates the channellist to include only active trace numbers
        self._traces = ChannelList(self, ""PNATraces"", PNATrace)
        self.add_submodule(""traces"", self._traces)
        # Add shortcuts to first trace
        trace1 = self.traces[0]
        params = trace1.parameters
        if not isinstance(params, dict):
            raise RuntimeError(f""Expected trace.parameters to be a dict got ""
                               f""{type(params)}"")
        for param in params.values():
            self.parameters[param.name] = param
        # And also add a link to run sweep
        self.run_sweep = trace1.run_sweep
        # Set this trace to be the default (it's possible to end up in a
        # situation where no traces are selected, causing parameter snapshots
        # to fail)
        self.active_trace(trace1.trace_num)

        # Set auto_sweep parameter
        # If we want to return multiple traces per setpoint without sweeping
        # multiple times, we should set this to false
        self.add_parameter('auto_sweep',
                           label='Auto Sweep',
                           set_cmd=None,
                           get_cmd=None,
                           vals=Bool(),
                           initial_value=True)

        # A default output format on initialisation
        self.write('FORM REAL,32')
        self.write('FORM:BORD NORM')

        self.connect_message()

    @property
    def traces(self) -> ChannelList:
        """"""
        Update channel list with active traces and return the new list
        """"""
        # Keep track of which trace was active before. This command may fail
        # if no traces were selected.
        try:
            active_trace = self.active_trace()
        except VisaIOError as e:
            if e.error_code == errors.StatusCode.error_timeout:
                active_trace = None
            else:
                raise

        # Get a list of traces from the instrument and fill in the traces list
        parlist = self.get_trace_catalog().split("","")
        self._traces.clear()
        for trace_name in parlist[::2]:
            trace_num = self.select_trace_by_name(trace_name)
            pna_trace = PNATrace(self, f""tr{trace_num}"",
                                 trace_name, trace_num)
            self._traces.append(pna_trace)

        # Restore the active trace if there was one
        if active_trace:
            self.active_trace(active_trace)

        # Return the list of traces on the instrument
        return self._traces

    def get_options(self) -> Sequence[str]:
        # Query the instrument for what options are installed
        return self.ask('*OPT?').strip('""').split(',')

    def get_trace_catalog(self) -> str:
        """"""
        Get the trace catalog, that is a list of trace and sweep types
        from the PNA.

        The format of the returned trace is:
            trace_name,trace_type,trace_name,trace_type...
        """"""
        return self.ask(""CALC:PAR:CAT:EXT?"").strip('""')

    def select_trace_by_name(self, trace_name: str) -> int:
        """"""
        Select a trace on the PNA by name.

        Returns:
            The trace number of the selected trace
        """"""
        self.write(f""CALC:PAR:SEL '{trace_name}'"")
        return self.active_trace()

    def reset_averages(self) -> None:
        """"""
        Reset averaging
        """"""
        self.write(""SENS:AVER:CLE"")

    def averages_on(self) -> None:
        """"""
        Turn on trace averaging
        """"""
        self.averages_enabled(True)

    def averages_off(self) -> None:
        """"""
        Turn off trace averaging
        """"""
        self.averages_enabled(False)

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.power.vals = Numbers(min_value=min_power,
                                  max_value=max_power)
        for port in self.ports:
            port._set_power_limits(min_power, max_power)


class PNAxBase(PNABase):
    def _enable_fom(self) -> None:
        '''
        PNA-x units with two sources have an enormous list of functions &
        configurations. In practice, most of this will be set up manually on
        the unit, with power and frequency varied in a sweep.
        '''
        self.add_parameter('aux_frequency',
                           label='Aux Frequency',
                           get_cmd='SENS:FOM:RANG4:FREQ:CW?',
                           get_parser=float,
                           set_cmd='SENS:FOM:RANG4:FREQ:CW {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=self.min_freq,
                                        max_value=self.max_freq))
"
33,https://www.alazartech.com/en/download/product/9064/300/ats9373-datasheet-and-specifications/1-6n/,https://en.wikipedia.org/wiki/Analog-to-digital_converter,"[OrderedDict([('id', 'att14GxiD8DuYiJSe'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2otoO1bIZ5_7Uxn9_yIJyQ/W7OZxNaoaw05LXWXBi3qgttudUId2LLnJPGyJ2a1pAVSsHW3OJ_pPe9fbVWg4gJj-utifwWaXDWDQ5uLVbbj4zOjX7sOgUNBn2lrN6GL94Y/J7dJq6hJQpn6yzNaON1V8aWR-Ohr5-gsx8tBBZDXo-4'), ('filename', 'ATS9373.jpg'), ('size', 499073), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Z3Mfuc7eNNTOwEuKOSSjmw/HvKCwl448YlmjZGiEfHDWCpu794f7_F8mOuP6rKbzZvLpTLDVwb2osT3NycZ1CoUTLz7bsZEdg4psgeeH-fCqA/Cnl4QAsgTFqLCaqrFm1IUV3W8WAzM8F50zehJvNDoMM'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N5YO4JeX-Ge1tDKjLNVpTQ/w05Rk1-zxlZIKPyoNx_iCLwDshF3EcpzOmdSgt8bxFNOLNjYWep4jnzWuBLVzkT4mi6zIDrDzHKF4UfSBJHh-g/KjnYIqf1nTm3p0Ow5Eeln6g6gP-uhhDgShkPhAfKJ_w'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ceg6kxETrBQnezpd1r5sRA/b-oqgiZ6H6P1sE83692c2rhUfZRMMYoavfVXT43oUkmVVKffdmQUYRLgQ-pziV5HOveXiuMumXnlBD0JJ4TNMQ/J-Ws6Ke5goBf477ac3kRYjqOD-kEfI5c9sxHBre7RjA'), ('width', 3000), ('height', 3000)]))]))])]",4.0,CANADA - QC,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692117216/Instruments/Vendor%20Logos/Alazartech.png,ATS9373 is a 12-bit waveform digitizer board that can sample one analog input at rates up to 4 GS/s or two inputs at 2 GS/s.,https://www.alazartech.com/en/product/ats9373/2/,ATS 9373,63.0,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AlazarTech/ATS9373.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AlazarTech.html#qcodes.instrument_drivers.AlazarTech.AlazarTechATS9373,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qAKVZnWakj3BsqaWIGBWRQ/ZrX_1_RMjBiSZrv9vP_57uXX3nVYvTG1M9yX0X0AbV2ABAwNqnlZ9ph2VxPWUntz57MfzGIcVtzwp_xIT4ogdpEUOSJkRSVjiQ9SdRaAR8Y/iqBF0wweZWGzh_PoUEPAoR1OMbJQ4ahE5SQ20efnW3w'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/c4okM_mAktf0nM5a4ujUcw/ojbZu24hQ3OsnpsLBQXtdSWuTk3Iklxwh_8h6Gu6nI-N-cZTED09W58zGdsdkzX784cjIMgM0mnM_Z10HE0DWw/-nQKXfI9UrjNxpUl6HPlw0VxPf0bhIFJu_puq3PBLH4'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wLU644oqMwyGp0nvbNsxWg/zc4O5FXXDWFC_3eWYDbTDhZ-8RKh4CywL6uxn3m30ZG4fRuCONJ6Iogf6ftQ_O_Q8qSa8Eq3C__L1bpo6Vc0tQ/tV1Jc99vngeTFMSvJRsKPiMPSZq261WWlEYFw6eF4dU'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pkhaW6W4s4X9DwUXiC5Qnw/twaNCkfaOpFsDIxJR3erWLY6uTRf-2naFC2FMhp_b49XItnrDMobUqWla3Gd6BRrhtn7cJNMypgCsWLD8PhzCw/_jkIrQ_2tQiU0GB3OhyCLuO6UO3JEk_1njNMezltdd4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782448/Instruments/DAQ%20boards/ATS9373---12-bit%2C-4-GS-s/ATS9373---12-bit_-4-GS-s.jpg,"ATS9373 - 12 bit, 4 GS/s","Write a Python script that uses Qcodes to connect to a ATS9373 - 12 bit, 4 GS/s DAQ boards",,"
",,,"from typing import Any

import numpy as np
from packaging import version

from qcodes import validators
from qcodes.instrument_drivers.AlazarTech.ATS import AlazarTech_ATS
from qcodes.instrument_drivers.AlazarTech.utils import TraceParameter


class AlazarTechATS9373(AlazarTech_ATS):
    """"""
    This class is the driver for the ATS9373 board.

    Note that this board is very similar to ATS9360. Refer to
    ATS SDK for details.

    Note that channels of this board have 12-bit resolution
    (see `IDN()['bits_per_sample']`) which means that the
    raw data that is returned by the card should be converted to
    uint16 type with a bit shift by 4 bits. Refer to ATS SDK
    for more infromation.
    """"""
    samples_divisor = 128
    _trigger_holdoff_min_fw_version = '30.04'

    def __init__(self, name: str,
                 dll_path: str = 'C:\\WINDOWS\\System32\\ATSApi.dll',
                 **kwargs: Any):
        super().__init__(name, dll_path=dll_path, **kwargs)

        # add parameters

        # ----- Parameters for the configuration of the board -----
        self.add_parameter(name='clock_source',
                           parameter_class=TraceParameter,
                           label='Clock Source',
                           unit=None,
                           initial_value='INTERNAL_CLOCK',
                           val_mapping={'INTERNAL_CLOCK': 1,
                                        'FAST_EXTERNAL_CLOCK': 2,
                                        'EXTERNAL_CLOCK_10MHz_REF': 7})
        self.add_parameter(name='external_sample_rate',
                           parameter_class=TraceParameter,
                           label='External Sample Rate',
                           unit='S/s',
                           vals=validators.MultiType(validators.Ints(300000000, 2000000000),
                                                     validators.Enum('UNDEFINED')),
                           initial_value='UNDEFINED')
        self.add_parameter(name='sample_rate',
                           parameter_class=TraceParameter,
                           label='Internal Sample Rate',
                           unit='S/s',
                           initial_value='UNDEFINED',
                           val_mapping={1_000: 1,
                                        2_000: 2,
                                        5_000: 4,
                                       10_000: 8,
                                       20_000: 10,
                                       50_000: 12,
                                      100_000: 14,
                                      200_000: 16,
                                      500_000: 18,
                                    1_000_000: 20,
                                    2_000_000: 24,
                                    5_000_000: 26,
                                   10_000_000: 28,
                                   20_000_000: 30,
                                   25_000_000: 33,
                                   50_000_000: 34,
                                  100_000_000: 36,
                                  125_000_000: 37,
                                  160_000_000: 38,
                                  180_000_000: 39,
                                  200_000_000: 40,
                                  250_000_000: 43,
                                  500_000_000: 48,
                                  800_000_000: 50,
                                1_000_000_000: 53,
                                1_200_000_000: 55,
                                1_500_000_000: 58,
                                1_800_000_000: 61,
                                2_000_000_000: 63,
                                2_400_000_000: 106,
                                3_000_000_000: 117,
                                3_600_000_000: 123,
                                4_000_000_000: 128,
                             'EXTERNAL_CLOCK': 64,
                                  'UNDEFINED': 'UNDEFINED'})
        self.add_parameter(name='clock_edge',
                           parameter_class=TraceParameter,
                           label='Clock Edge',
                           unit=None,
                           initial_value='CLOCK_EDGE_RISING',
                           val_mapping={'CLOCK_EDGE_RISING': 0,
                                        'CLOCK_EDGE_FALLING': 1})
        self.add_parameter(name='decimation',
                           parameter_class=TraceParameter,
                           label='Decimation',
                           unit=None,
                           initial_value=1,
                           vals=validators.Ints(0, 100000))

        for i in range(1, self.channels+1):
            self.add_parameter(name=f'coupling{i}',
                               parameter_class=TraceParameter,
                               label=f'Coupling channel {i}',
                               unit=None,
                               initial_value='DC',
                               val_mapping={'AC': 1, 'DC': 2})
            self.add_parameter(name=f'channel_range{i}',
                               parameter_class=TraceParameter,
                               label=f'Range channel {i}',
                               unit='V',
                               initial_value=0.4,
                               val_mapping={0.4: 7})
            self.add_parameter(name=f'impedance{i}',
                               parameter_class=TraceParameter,
                               label=f'Impedance channel {i}',
                               unit='Ohm',
                               initial_value=50,
                               val_mapping={50: 2})

            self.add_parameter(name=f'bwlimit{i}',
                               parameter_class=TraceParameter,
                               label=f'Bandwidth limit channel {i}',
                               unit=None,
                               initial_value='DISABLED',
                               val_mapping={'DISABLED': 0,
                                            'ENABLED': 1})

        self.add_parameter(name='trigger_operation',
                           parameter_class=TraceParameter,
                           label='Trigger Operation',
                           unit=None,
                           initial_value='TRIG_ENGINE_OP_J',
                           val_mapping={'TRIG_ENGINE_OP_J': 0,
                                        'TRIG_ENGINE_OP_K': 1,
                                        'TRIG_ENGINE_OP_J_OR_K': 2,
                                        'TRIG_ENGINE_OP_J_AND_K': 3,
                                        'TRIG_ENGINE_OP_J_XOR_K': 4,
                                        'TRIG_ENGINE_OP_J_AND_NOT_K': 5,
                                        'TRIG_ENGINE_OP_NOT_J_AND_K': 6})
        n_trigger_engines = 2

        for i in range(1, n_trigger_engines+1):
            self.add_parameter(name=f'trigger_engine{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Engine {i}',
                               unit=None,
                               initial_value='TRIG_ENGINE_' + ('J' if i == 1 else 'K'),
                               val_mapping={'TRIG_ENGINE_J': 0,
                                            'TRIG_ENGINE_K': 1})
            self.add_parameter(name=f'trigger_source{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Source {i}',
                               unit=None,
                               initial_value='EXTERNAL',
                               val_mapping={'CHANNEL_A': 0,
                                            'CHANNEL_B': 1,
                                            'EXTERNAL': 2,
                                            'DISABLE': 3})
            self.add_parameter(name=f'trigger_slope{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Slope {i}',
                               unit=None,
                               initial_value='TRIG_SLOPE_POSITIVE',
                               val_mapping={'TRIG_SLOPE_POSITIVE': 1,
                                            'TRIG_SLOPE_NEGATIVE': 2})
            self.add_parameter(name=f'trigger_level{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Level {i}',
                               unit=None,
                               initial_value=140,
                               vals=validators.Ints(0, 255))

        self.add_parameter(name='external_trigger_coupling',
                           parameter_class=TraceParameter,
                           label='External Trigger Coupling',
                           unit=None,
                           initial_value='DC',
                           val_mapping={'AC': 1, 'DC': 2})
        self.add_parameter(name='external_trigger_range',
                           parameter_class=TraceParameter,
                           label='External Trigger Range',
                           unit=None,
                           initial_value='ETR_2V5',
                           val_mapping={'ETR_TTL': 2, 'ETR_2V5': 3})
        self.add_parameter(name='trigger_delay',
                           parameter_class=TraceParameter,
                           label='Trigger Delay',
                           unit='Sample clock cycles',
                           initial_value=0,
                           vals=validators.Multiples(divisor=8, min_value=0))
        # See Table 3 - Trigger Delay Alignment
        # TODO: this is either 8 or 16 dependent on the  number of channels in use

        # NOTE: The board will wait for a for this amount of time for a
        # trigger event.  If a trigger event does not arrive, then the
        # board will automatically trigger. Set the trigger timeout value
        # to 0 to force the board to wait forever for a trigger event.
        #
        # IMPORTANT: The trigger timeout value should be set to zero after
        # appropriate trigger parameters have been determined, otherwise
        # the board may trigger if the timeout interval expires before a
        # hardware trigger event arrives.
        self.add_parameter(name='timeout_ticks',
                           parameter_class=TraceParameter,
                           label='Timeout Ticks',
                           unit='10 us',
                           initial_value=0,
                           vals=validators.Ints(min_value=0))

        self.add_parameter(name='aux_io_mode',
                           parameter_class=TraceParameter,
                           label='AUX I/O Mode',
                           unit=None,
                           initial_value='AUX_IN_AUXILIARY',
                           val_mapping={'AUX_OUT_TRIGGER': 0,
                                        'AUX_IN_TRIGGER_ENABLE': 1,
                                        'AUX_IN_AUXILIARY': 13})
        self.add_parameter(name='aux_io_param',
                           parameter_class=TraceParameter,
                           label='AUX I/O Param',
                           unit=None,
                           initial_value='NONE',
                           val_mapping={'NONE': 0,
                                        'TRIG_SLOPE_POSITIVE': 1,
                                        'TRIG_SLOPE_NEGATIVE': 2})

        # ----- Parameters for the acquire function -----
        self.add_parameter(name='mode',
                           label='Acquisition mode',
                           unit=None,
                           initial_value='NPT',
                           set_cmd=None,
                           val_mapping={'NPT': 0x200, 'TS': 0x400})
        self.add_parameter(name='samples_per_record',
                           label='Samples per Record',
                           unit=None,
                           initial_value=1024,
                           set_cmd=None,
                           vals=validators.Multiples(
                                divisor=self.samples_divisor, min_value=256))
        self.add_parameter(name='records_per_buffer',
                           label='Records per Buffer',
                           unit=None,
                           initial_value=10,
                           set_cmd=None,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffers_per_acquisition',
                           label='Buffers per Acquisition',
                           unit=None,
                           set_cmd=None,
                           initial_value=10,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='channel_selection',
                           label='Channel Selection',
                           unit=None,
                           set_cmd=None,
                           initial_value='AB',
                           val_mapping={'A': 1, 'B': 2, 'AB': 3})
        self.add_parameter(name='transfer_offset',
                           label='Transfer Offset',
                           unit='Samples',
                           set_cmd=None,
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='external_startcapture',
                           label='External Startcapture',
                           unit=None,
                           set_cmd=None,
                           initial_value='ENABLED',
                           val_mapping={'DISABLED': 0X0,
                                        'ENABLED': 0x1})
        self.add_parameter(name='enable_record_headers',
                           label='Enable Record Headers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x8})
        self.add_parameter(name='alloc_buffers',
                           label='Alloc Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x20})
        self.add_parameter(name='fifo_only_streaming',
                           label='Fifo Only Streaming',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x800})
        self.add_parameter(name='interleave_samples',
                           label='Interleave Samples',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x1000})
        self.add_parameter(name='get_processed_data',
                           label='Get Processed Data',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x2000})
        self.add_parameter(name='allocated_buffers',
                           label='Allocated Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value=4,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffer_timeout',
                           label='Buffer Timeout',
                           unit='ms',
                           set_cmd=None,
                           initial_value=1000,
                           vals=validators.Ints(min_value=0))

        self.add_parameter(name='trigger_holdoff',
                           label='Trigger Holdoff',
                           docstring=f'If enabled Alazar will '
                                     f'ignore any additional triggers '
                                     f'while capturing a record. If disabled '
                                     f'this will result in corrupt data. '
                                     f'Support for this requires at least '
                                     f'firmware version '
                                     f'{self._trigger_holdoff_min_fw_version}',
                           vals=validators.Bool(),
                           get_cmd=self._get_trigger_holdoff,
                           set_cmd=self._set_trigger_holdoff)

        model = self.get_idn()['model']
        if model != 'ATS9373':
            raise Exception(f""The Alazar board kind is not 'ATS9373',""
                            f"" found '{str(model)}' instead."")

    def _get_trigger_holdoff(self) -> bool:
        fwversion = self.get_idn()[""firmware""]
        if not isinstance(fwversion, str) or version.parse(fwversion) < version.parse(
            self._trigger_holdoff_min_fw_version
        ):
            return False

        # we want to check if the 26h bit (zero indexed) is high or not
        output = np.uint32(self._read_register(58))
        # the two first two chars in the bit string is the sign and a 'b'
        # remove those to only get the bit pattern
        bitmask = bin(output)[2:]
        # all prefixed zeros are ignored in the bit conversion so the
        # bit mask may be shorter than what we expect. in that case
        # the bit we care about is zero so we return False
        if len(bitmask) < 27:
            return False

        return bool(bin(output)[-27])

    def _set_trigger_holdoff(self, value: bool) -> None:
        fwversion = self.get_idn()[""firmware""]
        if not isinstance(fwversion, str) or version.parse(fwversion) < version.parse(
            self._trigger_holdoff_min_fw_version
        ):
            raise RuntimeError(
                f""Alazar 9373 requires at least firmware ""
                f""version {self._trigger_holdoff_min_fw_version}""
                f"" for trigger holdoff support. ""
                f""You have version {fwversion}""
            )
        current_value = self._read_register(58)

        if value is True:
            # to enable trigger hold off we want to flip the
            # 26th bit to 1. We do that by making a bitwise or
            # with a number that has a 1 on the 26th place and zero
            # otherwise. We use numpy.unit32 instead of python numbers
            # to have unsigned ints of the right size
            enable_mask = np.uint32(1 << 26)
            new_value = current_value | enable_mask
        else:
            # to disable trigger hold off we want to flip the
            # 26th bit to 0. We do that by making a bitwise and
            # with a number that has a 0 on the 26th place and 1
            # otherwise
            disable_mask = ~np.uint32(1 << 26)
            new_value = current_value & disable_mask
        self._write_register(58, int(new_value))


class AlazarTech_ATS9373(AlazarTechATS9373):
    """"""
    Alias for backwards compatibility. Will eventually be deprecated and removed
    """"""

    pass
"
37,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/service_support_30/RTO_dat-sw_en_5214-5155-22_v2800.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attVQtWBQ73ZpqeVq'), ('width', 2880), ('height', 1620), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hg8cb0YanIRwjZSOfvsw4A/GPxMOpBRvbhQk5_JziEzv1qk91Ji-vdsXiZda7i2uiCaJgRMzHu5SDiNI8CEwIogvFqd8PSsti1ljCw2Tp9qFf2PefAbjxyhvKW5JsLCYJ4yTQ70mE4WDsC3dxCQZXGPsTkcZ3GAFnv5230IVuswbCiplAaP7ZJNhFJf_2Y3guxLWJLAriBLYlbl3ZlUEIVU/VucPUx4d_yifDsIagba7sVL5pXUUDEe4oaldedhPgII'), ('filename', 'rto1000-digital-oscilloscope-front-view-rohde-schwarz_200_13475_2880_1620_3.jpg'), ('size', 535832), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mGhFpDxmNEyCcfw--yzDgQ/TeCDj-h0weH8Te-9rMpCSrgPCqRahK527iIfer02aEywlTCMo1MUnQ5-i_BS46kJzyQTXu2O6qpUSVtNuE0jSw/geTBAO0e-UiI-eY_qWBdW0yX7Yw4ll4fBSXc8HGlfUM'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QDVdWWkGAH-pZkcMOQKJvg/M6luTYpzDkdJi-Bzsj2k1HEEund9IcR2NkGPdmoKkEuGfCghNJQheuhO-WsS1fGgVmXBIsNrc7ii6SJvuPu9Hw/pPB7B2iAoYAF8IeeDD87FGHoshP4LSBovCReyEQVxCc'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ur1Ro6sDE9ZjAibLIE0yg/AePXOEruvuMUp8uU5_J7U0C8eatMLrIdcozTs3qZLS6VKJGjbTyX6jxL0htdBeVqliM1Bz7peDIiZPdwgLe8CA/p_ok658xrdFDjDaH75pPpsRxe61SYytJVnho4G8DlTo'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116717/Instruments/Vendor%20Logos/RohdeSchwarz.png,"With an acquisition memory of 400 Mpts per channel simultaneously for all four channels, the oscilloscope offers up to 100 times the memory depth of comparable devices as standard.

The R&S MXO 4 oscilloscopes offer the world's highest update rate of 4.5 million waveforms per second.","https://www.batronix.com/shop/rohde-schwarz/RTE1000.html#:~:text=RTE1000%20Oscilloscopes&text=With%20an%20acquisition%20memory%20of,4.5%20million%20waveforms%20per%20second.",RTO 1000,464.0,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/RTO1000.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzRTO1000,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XHBiQ9oxXm-n-HvM6LnRsA/zCF7wkTRkwfOTCAuwmibY3O7w00r82Jr-e9BArEz2wuEOw-7rLpTsqnPaLuh9W23W58Qwn9JURC-40I0_-4JxPkfgmT1CSF7VPctZxztnV4/I5ofu9MkvIeeFWHtoXZm_t6fUCujFLfj-JFESMUqIgk'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rp7cS3TGPqAHuTUKlrNiDg/VQ8_PlSktrAEUSma3ec9casPyXqUCiOYTta1bFMCr-JbFojx11fj4PsFxxQcQkgk5T0s4eilsQBFkmKe1f5C4A/plUaF2hmxk-9dn7wzOx_UZSUTlLGORdKrjwdpcJGgiM'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ouYl2k3tZan1Mqr3gFZ4XQ/eznvJmkOWcALsfmYE2FWZIIuDkvhPsL5ha4wYwX2hkGiFmGNwyYpsS2lgvAprhPlVCGH-c59BKm4kM4jMvjwlA/h8aBHQcCEhxqGNo05zJPlPwJ7fdGYthLjdrl6yX_uaY'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6WMk-uFRvLMFJ3F3nCseOQ/Ssto5hgGHjq8Q9vjrgnj3D0-Fay9y9tubFUbdbvK9IeGUYn2K3euoW1jshe65viP4uybZmkDEuVY84MH5n021w/_2LXQNPKEtc9MtuRG0jFWn1Hay_SQ8m2sSYN4caNxpw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,,R&S RTO1000,Write a Python script that uses Qcodes to connect to a R&S RTO1000 Oscilloscopes,,,True,,"# All manual references are to R&S RTO Digital Oscilloscope User Manual
# for firmware 3.65, 2017

import logging
import time
import warnings
from typing import Any, Optional

import numpy as np
from packaging import version

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, create_on_off_val_mapping

log = logging.getLogger(__name__)


class ScopeTrace(ArrayParameter):
    def __init__(
        self, name: str, instrument: InstrumentChannel, channum: int, **kwargs: Any
    ) -> None:
        """"""
        The ScopeTrace parameter is attached to a channel of the oscilloscope.

        For now, we only support reading out the entire trace.
        """"""
        super().__init__(
            name=name,
            shape=(1,),
            label=""Voltage"",  # TODO: Is this sometimes dbm?
            unit=""V"",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""Holds scope trace"",
            snapshot_value=False,
            instrument=instrument,
            **kwargs,
        )

        self.channel = instrument
        self.channum = channum
        self._trace_ready = False

    def prepare_trace(self) -> None:
        """"""
        Prepare the scope for returning data, calculate the setpoints
        """"""
        assert self.root_instrument is not None

        # We always use 16 bit integers for the data format
        self.root_instrument.dataformat(""INT,16"")
        # ensure little-endianess
        self.root_instrument.write(""FORMat:BORder LSBFirst"")
        # only export y-values
        self.root_instrument.write(""EXPort:WAVeform:INCXvalues OFF"")
        # only export one channel
        self.root_instrument.write(""EXPort:WAVeform:MULTichannel OFF"")

        # now get setpoints

        hdr = self.root_instrument.ask(f""CHANnel{self.channum}:"" ""DATA:HEADER?"")
        hdr_vals = list(map(float, hdr.split("","")))
        t_start = hdr_vals[0]
        t_stop = hdr_vals[1]
        no_samples = int(hdr_vals[2])
        values_per_sample = hdr_vals[3]

        # NOTE (WilliamHPNielsen):
        # If samples are multi-valued, we need a `MultiParameter`
        # instead of an `ArrayParameter`.
        if values_per_sample > 1:
            raise NotImplementedError('There are several values per sample '
                                      'in this trace (are you using envelope'
                                      ' or peak detect?). We currently do '
                                      'not support saving such a trace.')

        self.shape = (no_samples,)
        self.setpoints = (tuple(np.linspace(t_start, t_stop, no_samples)),)

        self._trace_ready = True
        # we must ensure that all this took effect before proceeding
        self.root_instrument.ask(""*OPC?"")

    def get_raw(self) -> np.ndarray:
        """"""
        Returns a trace
        """"""

        instr = self.root_instrument
        assert instr is not None

        if not self._trace_ready:
            raise ValueError('Trace not ready! Please call '
                             'prepare_trace().')

        if instr.run_mode() == 'RUN Nx SINGLE':
            total_acquisitions = instr.num_acquisitions()
            completed_acquisitions = instr.completed_acquisitions()
            log.info(f'Acquiring {total_acquisitions} traces.')
            while completed_acquisitions < total_acquisitions:
                log.info(f'Acquired {completed_acquisitions}:'
                         f'{total_acquisitions}')
                time.sleep(0.25)
                completed_acquisitions = instr.completed_acquisitions()

        log.info('Acquisition completed. Polling trace from instrument.')
        vh = instr.visa_handle
        vh.write(f'CHANnel{self.channum}:DATA?')
        raw_vals = vh.read_raw()

        num_length = int(raw_vals[1:2])
        no_points = int(raw_vals[2:2+num_length])

        # cut of the header and the trailing '\n'
        raw_vals = raw_vals[2+num_length:-1]

        dataformat = instr.dataformat.get_latest()

        if dataformat == 'INT,8':
            int_vals = np.frombuffer(raw_vals, dtype=np.int8, count=no_points)
        else:
            int_vals = np.frombuffer(raw_vals, dtype=np.int16, count=no_points // 2)

        # now the integer values must be converted to physical
        # values

        scale = self.channel.scale()
        no_divs = 10  # TODO: Is this ever NOT 10?

        # we always export as 16 bit integers
        quant_levels = 253*256
        conv_factor = scale*no_divs/quant_levels
        output = conv_factor*int_vals + self.channel.offset()

        return output


class RohdeSchwarzRTO1000ScopeMeasurement(InstrumentChannel):
    """"""
    Class to hold a measurement of the scope.
    """"""

    def __init__(self, parent: Instrument, name: str, meas_nr: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached
            name: The name of the measurement
            meas_nr: The number of the measurement in question. Must match the
                actual number as used by the instrument (1..8)
        """"""

        if meas_nr not in range(1, 9):
            raise ValueError('Invalid measurement number; Min: 1, max 8')

        self.meas_nr = meas_nr
        super().__init__(parent, name)

        self.sources = vals.Enum('C1W1', 'C1W2', 'C1W3',
                                 'C2W1', 'C2W2', 'C2W3',
                                 'C3W1', 'C3W2', 'C3W3',
                                 'C4W1', 'C4W2', 'C4W3',
                                 'M1', 'M2', 'M3', 'M4',
                                 'R1', 'R2', 'R3',  'R4',
                                 'SBUS1', 'SBUS2', 'SBUS3', 'SBUS4',
                                 'D0', 'D1', 'D2', 'D3',
                                 'D4', 'D5', 'D6', 'D7',
                                 'D8', 'D9', 'D10', 'D11',
                                 'D12', 'D13', 'D14', 'D15',
                                 'TRK1', 'TRK2', 'TRK3', 'TRK4',
                                 'TRK5', 'TRK6', 'TRK7', 'TRK8',
                                 'SG1TL1', 'SG1TL2',
                                 'SG2TL1', 'SG2TL2',
                                 'SG3TL1', 'SG3TL2',
                                 'SG4TL1', 'SG4TL2',
                                 'Z1V1', 'Z1V2', 'Z1V3', 'Z1V4',
                                 'Z1I1', 'Z1I2', 'Z1I3', 'Z1I4',
                                 'Z2V1', 'Z2V2', 'Z2V3',  'Z2V4',
                                 'Z2I1', 'Z2I2', 'Z2I3', 'Z2I4')

        self.categories = vals.Enum('AMPTime', 'JITTer', 'EYEJitter',
                                    'SPECtrum', 'HISTogram', 'PROTocol')

        self.meas_type = vals.Enum(
                        # Amplitude/time measurements
                        'HIGH', 'LOW', 'AMPLitude',
                        'MAXimum', 'MINimum', 'PDELta',
                        'MEAN', 'RMS', 'STDDev',
                        'POVershoot', 'NOVershoot', 'AREA',
                        'RTIMe', 'FTIMe', 'PPULse',
                        'NPULse', 'PERiod', 'FREQuency',
                        'PDCYcle', 'NDCYcle', 'CYCarea',
                        'CYCMean', 'CYCRms', 'CYCStddev',
                        'PULCnt', 'DELay', 'PHASe',
                        'BWIDth', 'PSWitching', 'NSWitching',
                        'PULSetrain', 'EDGecount', 'SHT',
                        'SHR', 'DTOTrigger', 'PROBemeter',
                        'SLERising', 'SLEFalling',
                        # Jitter measurements
                        'CCJitter', 'NCJitter', 'CCWidth',
                        'CCDutycycle', 'TIE', 'UINTerval',
                        'DRATe', 'SKWDelay', 'SKWPhase',
                        # Eye diagram measurements
                        'ERPercent', 'ERDB', 'EHEight',
                        'EWIDth', 'ETOP', 'EBASe',
                        'QFACtor', 'RMSNoise', 'SNRatio',
                        'DCDistortion', 'ERTime', 'EFTime',
                        'EBRate', 'EAMPlitude', 'PPJitter',
                        'STDJitter', 'RMSJitter',
                        # Spectrum measurements
                        'CPOWer', 'OBWidth', 'SBWidth',
                        'THD', 'THDPCT', 'THDA',
                        'THDU', 'THDR', 'HAR',
                        'PLISt',
                        # Histogram measurements
                        'WCOunt', 'WSAMples', 'HSAMples',
                        'HPEak', 'PEAK', 'UPEakvalue',
                        'LPEakvalue', 'HMAXimum', 'HMINimum',
                        'MEDian', 'MAXMin', 'HMEan',
                        'HSTDdev', 'M1STddev', 'M2STddev',
                        'M3STddev', 'MKPositive', 'MKNegative'
                        )

        self.add_parameter('enable',
                           label=f'Measurement {meas_nr} enable',
                           set_cmd=f'MEASurement{meas_nr}:ENABle {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the measurement on or off.')

        self.add_parameter('source',
                           label=f'Measurement {meas_nr} source',
                           set_cmd=f'MEASurement{meas_nr}:SOURce {{}}',
                           vals=self.sources,
                           docstring='Set the source of a measurement if the '
                                     'measurement only needs one source.')

        self.add_parameter('source_first',
                           label=f'Measurement {meas_nr} first source',
                           set_cmd=f'MEASurement{meas_nr}:FSRC {{}}',
                           vals=self.sources,
                           docstring='Set the first source of a measurement'
                                     ' if the measurement only needs multiple'
                                     ' sources.')

        self.add_parameter('source_second',
                           label=f'Measurement {meas_nr} second source',
                           set_cmd=f'MEASurement{meas_nr}:SSRC {{}}',
                           vals=self.sources,
                           docstring='Set the second source of a measurement'
                                     ' if the measurement only needs multiple'
                                     ' sources.')

        self.add_parameter('category',
                           label=f'Measurement {meas_nr} category',
                           set_cmd=f'MEASurement{meas_nr}:CATegory {{}}',
                           vals=self.categories,
                           docstring='Set the category of a measurement.')

        self.add_parameter('main',
                           label=f'Measurement {meas_nr} main',
                           set_cmd=f'MEASurement{meas_nr}:MAIN {{}}',
                           vals=self.meas_type,
                           docstring='Set the main of a measurement.')

        self.add_parameter('statistics_enable',
                           label=f'Measurement {meas_nr} enable statistics',
                           set_cmd=f'MEASurement{meas_nr}:STATistics:ENABle'
                                   f' {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the measurement on or off.')

        self.add_parameter('clear',
                           label=f'Measurement {meas_nr} clear statistics',
                           set_cmd=f'MEASurement{meas_nr}:CLEar',
                           docstring='Clears/reset measurement.')

        self.add_parameter('event_count',
                           label=f'Measurement {meas_nr} number of events',
                           get_cmd=f'MEASurement{meas_nr}:RESult:EVTCount?',
                           get_parser=int,
                           docstring='Number of measurement results in the'
                                     ' long-term measurement.')

        self.add_parameter('result_avg',
                           label=f'Measurement {meas_nr} averages',
                           get_cmd=f'MEASurement{meas_nr}:RESult:AVG?',
                           get_parser=float,
                           docstring='Average of the long-term measurement'
                                     ' results.')


ScopeMeasurement = RohdeSchwarzRTO1000ScopeMeasurement


class RohdeSchwarzRTO1000ScopeChannel(InstrumentChannel):
    """"""
    Class to hold an input channel of the scope.

    Exposes: state, coupling, ground, scale, range, position, offset,
    invert, bandwidth, impedance, overload.
    """"""

    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached
            name: The name of the channel
            channum: The number of the channel in question. Must match the
                actual number as used by the instrument (1..4)
        """"""

        if channum not in [1, 2, 3, 4]:
            raise ValueError('Invalid channel number! Must be 1, 2, 3, or 4.')

        self.channum = channum

        super().__init__(parent, name)

        self.add_parameter('state',
                           label=f'Channel {channum} state',
                           get_cmd=f'CHANnel{channum}:STATe?',
                           set_cmd=f'CHANnel{channum}:STATE {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the channel on or off')

        self.add_parameter('coupling',
                           label=f'Channel {channum} coupling',
                           get_cmd=f'CHANnel{channum}:COUPling?',
                           set_cmd=f'CHANnel{channum}:COUPling {{}}',
                           vals=vals.Enum('DC', 'DCLimit', 'AC'),
                           docstring=('Selects the connection of the channel'
                                      'signal. DC: 50 Ohm, DCLimit 1 MOhm, '
                                      'AC: Con. through DC capacitor'))

        self.add_parameter('ground',
                           label=f'Channel {channum} ground',
                           get_cmd=f'CHANnel{channum}:GND?',
                           set_cmd=f'CHANnel{channum}:GND {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=('Connects/disconnects the signal to/from'
                                      'the ground.'))

        # NB (WilliamHPNielsen): This parameter depends on other parameters and
        # should be dynamically updated accordingly. Cf. p 1178 of the manual
        self.add_parameter('scale',
                           label=f'Channel {channum} Y scale',
                           unit='V/div',
                           get_cmd=f'CHANnel{channum}:SCALe?',
                           set_cmd=self._set_scale,
                           get_parser=float,
                           )

        self.add_parameter('range',
                           label=f'Channel {channum} Y range',
                           unit='V',
                           get_cmd=f'CHANnel{channum}:RANGe?',
                           set_cmd=self._set_range,
                           get_parser=float
                           )

        # TODO (WilliamHPNielsen): would it be better to recast this in terms
        # of Volts?
        self.add_parameter('position',
                           label=f'Channel {channum} vert. pos.',
                           unit='div',
                           get_cmd=f'CHANnel{channum}:POSition?',
                           set_cmd=f'CHANnel{channum}:POSition {{}}',
                           get_parser=float,
                           vals=vals.Numbers(-5, 5),
                           docstring=('Positive values move the waveform up,'
                                      ' negative values move it down.'))

        self.add_parameter('offset',
                           label=f'Channel {channum} offset',
                           unit='V',
                           get_cmd=f'CHANnel{channum}:OFFSet?',
                           set_cmd=f'CHANnel{channum}:OFFSet {{}}',
                           get_parser=float,
                           )

        self.add_parameter('invert',
                           label=f'Channel {channum} inverted',
                           get_cmd=f'CHANnel{channum}:INVert?',
                           set_cmd=f'CHANnel{channum}:INVert {{}}',
                           vals=vals.Enum('ON', 'OFF'))

        # TODO (WilliamHPNielsen): This parameter should be dynamically
        # validated since 800 MHz BW is only available for 50 Ohm coupling
        self.add_parameter('bandwidth',
                           label=f'Channel {channum} bandwidth',
                           get_cmd=f'CHANnel{channum}:BANDwidth?',
                           set_cmd=f'CHANnel{channum}:BANDwidth {{}}',
                           vals=vals.Enum('FULL', 'B800', 'B200', 'B20')
                           )

        self.add_parameter('impedance',
                           label=f'Channel {channum} impedance',
                           unit='Ohm',
                           get_cmd=f'CHANnel{channum}:IMPedance?',
                           set_cmd=f'CHANnel{channum}:IMPedance {{}}',
                           vals=vals.Ints(1, 100000),
                           docstring=('Sets the impedance of the channel '
                                      'for power calculations and '
                                      'measurements.'))

        self.add_parameter('overload',
                           label=f'Channel {channum} overload',
                           get_cmd=f'CHANnel{channum}:OVERload?')

        self.add_parameter('arithmetics',
                           label=f'Channel {channum} arithmetics',
                           set_cmd=f'CHANnel{channum}:ARIThmetics {{}}',
                           get_cmd=f'CHANnel{channum}:ARIThmetics?',
                           val_mapping={'AVERAGE': 'AVER',
                                        'OFF': 'OFF',
                                        'ENVELOPE': 'ENV'}
                           )

        self.add_parameter('trace',
                           channum=self.channum,
                           parameter_class=ScopeTrace)

        self._trace_ready = False

    # Specialised/interlinked set/getters
    def _set_range(self, value: float) -> None:
        self.scale.cache.set(value/10)

        self._parent.write(f'CHANnel{self.channum}:RANGe {value}')

    def _set_scale(self, value: float) -> None:
        self.range.cache.set(value*10)

        self._parent.write(f'CHANnel{self.channum}:SCALe {value}')


ScopeChannel = RohdeSchwarzRTO1000ScopeChannel


class RohdeSchwarzRTO1000(VisaInstrument):
    """"""
    QCoDeS Instrument driver for the
    Rohde-Schwarz RTO1000 series oscilloscopes.

    """"""

    def __init__(self, name: str, address: str,
                 model: Optional[str] = None, timeout: float = 5.,
                 HD: bool = True,
                 terminator: str = '\n',
                 **kwargs: Any) -> None:
        """"""
        Args:
            name: name of the instrument
            address: VISA resource address
            model: The instrument model. For newer firmware versions,
                this can be auto-detected
            timeout: The VISA query timeout
            HD: Does the unit have the High Definition Option (allowing
                16 bit vertical resolution)
            terminator: Command termination character to strip from VISA
                commands.
        """"""
        super().__init__(name=name, address=address, timeout=timeout,
                         terminator=terminator, **kwargs)

        # With firmware versions earlier than 3.65, it seems that the
        # model number can NOT be queried from the instrument
        # (at least fails with RTO1024, fw 2.52.1.1), so in that case
        # the user must provide the model manually.
        firmware_version_str = self.get_idn()[""firmware""]
        if firmware_version_str is None:
            raise RuntimeError(""Could not determine firmware version of RTO1000."")
        firmware_version = version.parse(firmware_version_str)

        if firmware_version < version.parse(""3""):
            log.warning(
                ""Old firmware version detected. This driver may ""
                ""not be compatible. Please upgrade your firmware.""
            )

        if firmware_version >= version.parse(""3.65""):
            # strip just in case there is a newline character at the end
            self.model = self.ask('DIAGnostic:SERVice:WFAModel?').strip()
            if model is not None and model != self.model:
                warnings.warn(""The model number provided by the user ""
                              ""does not match the instrument's response.""
                              "" I am going to assume that this oscilloscope ""
                              f""is a model {self.model}"")
        else:
            if model is None:
                raise ValueError('No model number provided. Please provide '
                                 'a model number (eg. ""RTO1024"").')
            else:
                self.model = model

        self.HD = HD

        # Now assign model-specific values
        self.num_chans = int(self.model[-1])
        self.num_meas = 8

        self._horisontal_divs = int(self.ask('TIMebase:DIVisions?'))

        self.add_parameter('display',
                           label='Display state',
                           set_cmd='SYSTem:DISPlay:UPDate {}',
                           val_mapping={'remote': 0,
                                        'view': 1})

        # Triggering

        self.add_parameter('trigger_display',
                           label='Trigger display state',
                           set_cmd='DISPlay:TRIGger:LINes {}',
                           get_cmd='DISPlay:TRIGger:LINes?',
                           val_mapping={'ON': 1, 'OFF': 0})

        # TODO: (WilliamHPNielsen) There are more available trigger
        # settings than implemented here. See p. 1261 of the manual
        # here we just use trigger1, which is the A-trigger

        self.add_parameter('trigger_source',
                           label='Trigger source',
                           set_cmd='TRIGger1:SOURce {}',
                           get_cmd='TRIGger1:SOURce?',
                           val_mapping={'CH1': 'CHAN1',
                                        'CH2': 'CHAN2',
                                        'CH3': 'CHAN3',
                                        'CH4': 'CHAN4',
                                        'EXT': 'EXT'})

        self.add_parameter('trigger_mode',
                           label='Trigger mode',
                           set_cmd='TRIGger:MODE {}',
                           get_cmd='TRIGger1:SOURce?',
                           vals=vals.Enum('AUTO', 'NORMAL', 'FREERUN'),
                           docstring='Sets the trigger mode which determines'
                                     ' the behaviour of the instrument if no'
                                     ' trigger occurs.\n'
                                     'Options: AUTO, NORMAL, FREERUN.',
                           unit='none')

        self.add_parameter('trigger_type',
                           label='Trigger type',
                           set_cmd='TRIGger1:TYPE {}',
                           get_cmd='TRIGger1:TYPE?',
                           val_mapping={'EDGE': 'EDGE',
                                        'GLITCH': 'GLIT',
                                        'WIDTH': 'WIDT',
                                        'RUNT': 'RUNT',
                                        'WINDOW': 'WIND',
                                        'TIMEOUT': 'TIM',
                                        'INTERVAL': 'INT',
                                        'SLEWRATE': 'SLEW',
                                        'DATATOCLOCK': 'DAT',
                                        'STATE': 'STAT',
                                        'PATTERN': 'PATT',
                                        'ANEDGE': 'ANED',
                                        'SERPATTERN': 'SERP',
                                        'NFC': 'NFC',
                                        'TV': 'TV',
                                        'CDR': 'CDR'}
                           )
        # See manual p. 1262 for an explanation of trigger types

        self.add_parameter('trigger_level',
                           label='Trigger level',
                           set_cmd=self._set_trigger_level,
                           get_cmd=self._get_trigger_level)

        self.add_parameter('trigger_edge_slope',
                           label='Edge trigger slope',
                           set_cmd='TRIGger1:EDGE:SLOPe {}',
                           get_cmd='TRIGger1:EDGE:SLOPe?',
                           vals=vals.Enum('POS', 'NEG', 'EITH'))

        # Horizontal settings

        self.add_parameter('timebase_scale',
                           label='Timebase scale',
                           set_cmd=self._set_timebase_scale,
                           get_cmd='TIMebase:SCALe?',
                           unit='s/div',
                           get_parser=float,
                           vals=vals.Numbers(25e-12, 10000))

        self.add_parameter('timebase_range',
                           label='Timebase range',
                           set_cmd=self._set_timebase_range,
                           get_cmd='TIMebase:RANGe?',
                           unit='s',
                           get_parser=float,
                           vals=vals.Numbers(250e-12, 100e3))

        self.add_parameter('timebase_position',
                           label='Horizontal position',
                           set_cmd=self._set_timebase_position,
                           get_cmd='TIMEbase:HORizontal:POSition?',
                           get_parser=float,
                           unit='s',
                           vals=vals.Numbers(-100e24, 100e24))

        # Acquisition

        # I couldn't find a way to query the run mode, so we manually keep
        # track of it. It is very important when getting the trace to make
        # sense of completed_acquisitions.
        self.add_parameter('run_mode',
                           label='Run/acquisition mode of the scope',
                           get_cmd=None,
                           set_cmd=None)

        self.run_mode('RUN CONT')

        self.add_parameter('num_acquisitions',
                           label='Number of single acquisitions to perform',
                           get_cmd='ACQuire:COUNt?',
                           set_cmd='ACQuire:COUNt {}',
                           vals=vals.Ints(1, 16777215),
                           get_parser=int)

        self.add_parameter('completed_acquisitions',
                           label='Number of completed acquisitions',
                           get_cmd='ACQuire:CURRent?',
                           get_parser=int)

        self.add_parameter('sampling_rate',
                           label='Sample rate',
                           docstring='Number of averages for measuring '
                           'trace.',
                           unit='Sa/s',
                           get_cmd='ACQuire:POINts:ARATe' + '?',
                           get_parser=int)

        self.add_parameter('acquisition_sample_rate',
                           label='Acquisition sample rate',
                           unit='Sa/s',
                           docstring='recorded waveform samples per second',
                           get_cmd='ACQuire:SRATe'+'?',
                           set_cmd='ACQuire:SRATe ' + ' {:.2f}',
                           vals=vals.Numbers(2, 20e12),
                           get_parser=float)

        # Data

        self.add_parameter('dataformat',
                           label='Export data format',
                           set_cmd='FORMat:DATA {}',
                           get_cmd='FORMat:DATA?',
                           vals=vals.Enum('ASC,0', 'REAL,32',
                                          'INT,8', 'INT,16'))

        # High definition mode (might not be available on all instruments)

        if HD:
            self.add_parameter('high_definition_state',
                               label='High definition (16 bit) state',
                               set_cmd=self._set_hd_mode,
                               get_cmd='HDEFinition:STAte?',
                               val_mapping=create_on_off_val_mapping(on_val=1,
                                                                     off_val=0),
                               docstring='Sets the filter bandwidth for the'
                                         ' high definition mode.\n'
                                         'ON: high definition mode, up to 16'
                                         ' bit digital resolution\n'
                                         'Options: ON, OFF\n\n'
                                         'Warning/Bug: By opening the HD '
                                         'acquisition menu on the scope, '
                                         'this value will be set to ""ON"".')

            self.add_parameter('high_definition_bandwidth',
                               label='High definition mode bandwidth',
                               set_cmd='HDEFinition:BWIDth {}',
                               get_cmd='HDEFinition:BWIDth?',
                               unit='Hz',
                               get_parser=float,
                               vals=vals.Numbers(1e4, 1e9))

        self.add_parameter('error_count',
                           label='Number of errors in the error stack',
                           get_cmd='SYSTem:ERRor:COUNt?',
                           unit='#',
                           get_parser=int)

        self.add_parameter('error_next',
                           label='Next error from the error stack',
                           get_cmd='SYSTem:ERRor:NEXT?',
                           get_parser=str)

        # Add the channels to the instrument
        for ch in range(1, self.num_chans + 1):
            chan = RohdeSchwarzRTO1000ScopeChannel(self, f""channel{ch}"", ch)
            self.add_submodule(f""ch{ch}"", chan)

        for measId in range(1, self.num_meas + 1):
            measCh = RohdeSchwarzRTO1000ScopeMeasurement(
                self, f""measurement{measId}"", measId
            )
            self.add_submodule(f""meas{measId}"", measCh)

        self.add_function('stop', call_cmd='STOP')
        self.add_function('reset', call_cmd='*RST')
        self.add_parameter('opc', get_cmd='*OPC?')
        self.add_parameter('stop_opc', get_cmd='STOP;*OPC?')
        self.add_parameter('status_operation',
                           get_cmd='STATus:OPERation:CONDition?',
                           get_parser=int)
        self.add_function('run_continues', call_cmd='RUNContinous')
        # starts the shutdown of the system
        self.add_function('system_shutdown', call_cmd='SYSTem:EXIT')

        self.connect_message()

    def run_cont(self) -> None:
        """"""
        Set the instrument in 'RUN CONT' mode
        """"""
        self.write('RUN')
        self.run_mode.set('RUN CONT')

    def run_single(self) -> None:
        """"""
        Set the instrument in 'RUN Nx SINGLE' mode
        """"""
        self.write('SINGLE')
        self.run_mode.set('RUN Nx SINGLE')

    def is_triggered(self) -> bool:
        wait_trigger_mask = 0b01000
        return bool(self.status_operation() & wait_trigger_mask) is False

    def is_running(self) -> bool:
        measuring_mask = 0b10000
        return bool(self.status_operation() & measuring_mask)

    def is_acquiring(self) -> bool:
        return self.is_triggered() & self.is_running()

    # Specialised set/get functions

    def _set_hd_mode(self, value: int) -> None:
        """"""
        Set/unset the high def mode
        """"""
        self._make_traces_not_ready()
        self.write(f'HDEFinition:STAte {value}')

    def _set_timebase_range(self, value: float) -> None:
        """"""
        Set the full range of the timebase
        """"""
        self._make_traces_not_ready()
        self.timebase_scale.cache.set(value/self._horisontal_divs)

        self.write(f'TIMebase:RANGe {value}')

    def _set_timebase_scale(self, value: float) -> None:
        """"""
        Set the length of one horizontal division.
        """"""
        self._make_traces_not_ready()
        self.timebase_range.cache.set(value*self._horisontal_divs)

        self.write(f'TIMebase:SCALe {value}')

    def _set_timebase_position(self, value: float) -> None:
        """"""
        Set the horizontal position.
        """"""
        self._make_traces_not_ready()
        self.write(f'TIMEbase:HORizontal:POSition {value}')

    def _make_traces_not_ready(self) -> None:
        """"""
        Make the scope traces be not ready.
        """"""
        self.ch1.trace._trace_ready = False
        self.ch2.trace._trace_ready = False
        self.ch3.trace._trace_ready = False
        self.ch4.trace._trace_ready = False

    def _set_trigger_level(self, value: float) -> None:
        """"""
        Set the trigger level on the currently used trigger source
        channel.
        """"""
        trans = {'CH1': 1, 'CH2': 2, 'CH3': 3, 'CH4': 4, 'EXT': 5}
        # We use get and not get_latest because we don't trust users to
        # not touch the front panel of an oscilloscope.
        source = trans[self.trigger_source.get()]
        if source != 5:
            submodule = self.submodules[f'ch{source}']
            assert isinstance(submodule, InstrumentChannel)
            v_range = submodule.range()
            offset = submodule.offset()

            if (value < -v_range/2 + offset) or (value > v_range/2 + offset):
                raise ValueError('Trigger level outside channel range.')

        self.write(f'TRIGger1:LEVel{source} {value}')

    def _get_trigger_level(self) -> float:
        """"""
        Get the trigger level from the currently used trigger source
        """"""
        trans = {'CH1': 1, 'CH2': 2, 'CH3': 3, 'CH4': 4, 'EXT': 5}
        # we use get and not get_latest because we don't trust users to
        # not touch the front panel of an oscilloscope
        source = trans[self.trigger_source.get()]

        val = self.ask(f'TRIGger1:LEVel{source}?')

        return float(val.strip())


class RTO1000(RohdeSchwarzRTO1000):
    """"""
    Backwards compatibility alias for RohdeSchwarzRTO1000
    """"""

    pass
"
39,https://www.testequipmenthq.com/datasheets/KEITHLEY-2000-Datasheet.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attDkhYLQ6zcJU0mz'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZqPs4D-wYQOGMrvy9eEIow/VCQ67enTwY7GYeFodoCdH9Fc8ASt_qvjoPkVH_RezK4eicRf3ffrjJBUSs9P8Z93iAmnPDHhkvzDRVaytsejhjTd3tZEQqszmGGl6EaXocY/QDbpgOiON6UhyN_YzMX28ESO3eDJ6DF4OzAuUiscHvM'), ('filename', '2000.webp'), ('size', 6118), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/t1EIzJjrxWKCo43qrWRVPw/BLG9RUpdaTQOJS6VifKFaQ_ben_Tu7KqLxYqg_xmaPUv3bXvW6KpuIYcPYmr6w8nLJ1hsOS2F6F0htWFRV7AHACSnLdtF0nRYegh14dLPM0/jK63SYzHN65YjNTj79TjQx4Xw-7tU1bup5abG6QIX0E'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XyXmo_zZZkOo93PZw8pEtQ/TaZvQAzccwKyfH_74qBDypo7W22ms-ozwJ8UTHkH2NAXWb7EoKCyltYsB27VcbJUYZKm4RTGCN8m1FvWtShJ79th1rU13_be9MSVZPXthxY/yKCk0DJ40A58jUBawD7GOItgGHxMNeTiZ7H8J8_mWWE'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Qxjj80aQZOJ3Lwi5yFr8Ww/y7za9Mgp9PL4LOjgu4Z7ao_VF7IOutX6rRNglfNHgQN0AFCCRII0usm7FItzFo5l-Wtl_0Usg9m_sE7Rrcej9RO6dd5R7KPRWvKuYDHkvBs/DbRt9EV7y7UqJYlcElVW9jmE3gI30-ajKtEQiX_pmnA'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The Model 2000 6_-Digit Multimeter is part of Keithleys family of high performance DMMs. Based on the same high speed, low noise A/D converter technology as the Model 2001 and 2002, the 2000 is a fast, accurate, and highly stable instrument thats as easy to operate as it is to afford. It combines broad measurement ranges with superior accuracy specifications DC voltage from 100nV to 1kV (with 0.002% 90-day basic accuracy) and DC resistance from 100 to 100M (with 0.008% 90-day basic accuracy). Optional switch cards enable multiplexing up to 20 different input signals for multipoint measurement applications.",https://www.allaboutcircuits.com/test-measurement/multimeters/keithley-2000/,Keithley 2000,241.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2000.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2000,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782454/Instruments/Multimeters/Keithley-2000/Keithley-2000.webp,Keithley 2000,Write a Python script that uses Qcodes to connect to a {Device name} Multimeters,,,True,,"from functools import partial
from typing import Any, Callable, Union

from qcodes.instrument import VisaInstrument
from qcodes.validators import Bool, Enum, Ints, MultiType, Numbers


def _parse_output_string(s: str) -> str:
    """"""Parses and cleans string outputs of the Keithley""""""
    # Remove surrounding whitespace and newline characters
    s = s.strip()

    # Remove surrounding quotes
    if (s[0] == s[-1]) and s.startswith((""'"", '""')):
        s = s[1:-1]

    s = s.lower()

    # Convert some results to a better readable version
    conversions = {
        ""mov"": ""moving"",
        ""rep"": ""repeat"",
    }

    if s in conversions.keys():
        s = conversions[s]

    return s


def _parse_output_bool(value: str) -> bool:
    return True if int(value) == 1 else False


class Keithley2000(VisaInstrument):
    """"""
    Driver for the Keithley 2000 multimeter.
    """"""

    def __init__(self, name: str, address: str, reset: bool = False, **kwargs: Any):
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self._trigger_sent = False

        # Unfortunately the strings have to contain quotation marks and a
        # newline character, as this is how the instrument returns it.
        self._mode_map = {
            ""ac current"": '""CURR:AC""',
            ""dc current"": '""CURR:DC""',
            ""ac voltage"": '""VOLT:AC""',
            ""dc voltage"": '""VOLT:DC""',
            ""2w resistance"": '""RES""',
            ""4w resistance"": '""FRES""',
            ""temperature"": '""TEMP""',
            ""frequency"": '""FREQ""',
        }

        self.add_parameter(
            ""mode"",
            get_cmd=""SENS:FUNC?"",
            set_cmd=""SENS:FUNC {}"",
            val_mapping=self._mode_map,
        )

        # Mode specific parameters
        self.add_parameter(
            ""nplc"",
            get_cmd=partial(self._get_mode_param, ""NPLC"", float),
            set_cmd=partial(self._set_mode_param, ""NPLC""),
            vals=Numbers(min_value=0.01, max_value=10),
        )

        # TODO: validator, this one is more difficult since different modes
        # require different validation ranges
        self.add_parameter(
            ""range"",
            get_cmd=partial(self._get_mode_param, ""RANG"", float),
            set_cmd=partial(self._set_mode_param, ""RANG""),
            vals=Numbers(),
        )

        self.add_parameter(
            ""auto_range_enabled"",
            get_cmd=partial(self._get_mode_param, ""RANG:AUTO"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""RANG:AUTO""),
            vals=Bool(),
        )

        self.add_parameter(
            ""digits"",
            get_cmd=partial(self._get_mode_param, ""DIG"", int),
            set_cmd=partial(self._set_mode_param, ""DIG""),
            vals=Ints(min_value=4, max_value=7),
        )

        self.add_parameter(
            ""averaging_type"",
            get_cmd=partial(self._get_mode_param, ""AVER:TCON"", _parse_output_string),
            set_cmd=partial(self._set_mode_param, ""AVER:TCON""),
            vals=Enum(""moving"", ""repeat""),
        )

        self.add_parameter(
            ""averaging_count"",
            get_cmd=partial(self._get_mode_param, ""AVER:COUN"", int),
            set_cmd=partial(self._set_mode_param, ""AVER:COUN""),
            vals=Ints(min_value=1, max_value=100),
        )

        self.add_parameter(
            ""averaging_enabled"",
            get_cmd=partial(self._get_mode_param, ""AVER:STAT"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""AVER:STAT""),
            vals=Bool(),
        )

        # Global parameters
        self.add_parameter(
            ""display_enabled"",
            get_cmd=""DISP:ENAB?"",
            get_parser=_parse_output_bool,
            set_cmd=""DISP:ENAB {}"",
            set_parser=int,
            vals=Bool(),
        )

        self.add_parameter(
            ""trigger_continuous"",
            get_cmd=""INIT:CONT?"",
            get_parser=_parse_output_bool,
            set_cmd=""INIT:CONT {}"",
            set_parser=int,
            vals=Bool(),
        )

        self.add_parameter(
            ""trigger_count"",
            get_cmd=""TRIG:COUN?"",
            get_parser=int,
            set_cmd=""TRIG:COUN {}"",
            vals=MultiType(
                Ints(min_value=1, max_value=9999),
                Enum(""inf"", ""default"", ""minimum"", ""maximum""),
            ),
        )

        self.add_parameter(
            ""trigger_delay"",
            get_cmd=""TRIG:DEL?"",
            get_parser=float,
            set_cmd=""TRIG:DEL {}"",
            unit=""s"",
            vals=Numbers(min_value=0, max_value=999999.999),
        )

        self.add_parameter(
            ""trigger_source"",
            get_cmd=""TRIG:SOUR?"",
            set_cmd=""TRIG:SOUR {}"",
            val_mapping={
                ""immediate"": ""IMM"",
                ""timer"": ""TIM"",
                ""manual"": ""MAN"",
                ""bus"": ""BUS"",
                ""external"": ""EXT"",
            },
        )

        self.add_parameter(
            ""trigger_timer"",
            get_cmd=""TRIG:TIM?"",
            get_parser=float,
            set_cmd=""TRIG:TIM {}"",
            unit=""s"",
            vals=Numbers(min_value=0.001, max_value=999999.999),
        )

        self.add_parameter(""amplitude"", unit=""arb.unit"", get_cmd=self._read_next_value)

        self.add_function(""reset"", call_cmd=""*RST"")

        if reset:
            self.reset()

        # Set the data format to have only ascii data without units and channels
        self.write(""FORM:DATA ASCII"")
        self.write(""FORM:ELEM READ"")

        self.connect_message()

    def trigger(self) -> None:
        if not self.trigger_continuous():
            self.write(""INIT"")
            self._trigger_sent = True

    def _read_next_value(self) -> float:
        # Prevent a timeout when no trigger has been sent
        if not self.trigger_continuous() and not self._trigger_sent:
            return 0.0

        self._trigger_sent = False

        return float(self.ask(""SENSE:DATA:FRESH?""))

    def _get_mode_param(
        self, parameter: str, parser: Callable[[str], Any]
    ) -> Union[float, str, bool]:
        """"""Read the current Keithley mode and ask for a parameter""""""
        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter}?""

        return parser(self.ask(cmd))

    def _set_mode_param(self, parameter: str, value: Union[float, str, bool]) -> None:
        """"""Read the current Keithley mode and set a parameter""""""
        if isinstance(value, bool):
            value = int(value)

        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter} {value}""

        self.write(cmd)
"
47,https://www.mouser.com/pdfdocs/ug33210-90010.pdf,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'attw6E6O3rYWUQBU0'), ('width', 800), ('height', 444), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xwV3rnN3FG-s34JMe4-4fg/5zb2Mebja3Kt_cG5tcqeh4rcOPHchivGfhZmDxLrQG5PboTjFfS5aoSpMadjh-WKBBZn-jxQC70tWxlVQWPpZ62799I1d1Vh-0psOBRhaavFxkG3RfRdtfpBOef2LsA8/MjhSTHpRvZe5rhKJdzsUs-VjoFUoOLiZNqLUfNan8go'), ('filename', 'Keysight_Agilent_33210A.jpg'), ('size', 85448), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ccg3WPs5BfqvX-XnPq6Iig/u8k2uetK_PP3m9aa-pkoUAOm8dLy9K71TOWW-T_0bqlIB4qDaJBZ6j0AQF2Vh5OzcivHRSDm4otHC8KTp-NX6Q/ftDVfFyFhK6U5HSM-6jcdzkYQX0X43EA_eIuSmz1gSk'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ccGbg8e-xr2zXbDnX_vtig/Eb-KPJEVfurw3woxyjE_RG2Sz8FV0Vak_yVR2QZtpfKjas9hfAmKWm4Od9Ge8-Smdt1ScYYEsoU_EmWu0VPC9Q/9jC5VCLzf0i8q4K6F4aHyxYr6uCtxEKTLJOh0hyT6qc'), ('width', 800), ('height', 444)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BxgWITyQiBTrpB5ey6DxMg/Uk7-KDOIRR0tFUJfstRp_-gxWfdtnCgmgKPr1RZ1YGEb_783i_UXJFQKULykv1V_KG_X7awZjHGqT-h6Xo5Xkw/4yfcJwM-obMWjeJiJqc0CcNsr4eBE43gWQ-iUn00ByY'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight (formerly Agilent) 33210A is the latest function/arbitrary waveform generator from Keysight. It uses direct digital synthesis techniques to create a stable, accurate output signal having clean, low distortion sine waves. For user defined waveforms, option 002 provides 14-bit 8k point arbitrary waveform generation",https://www.amplicon.com/products/keysight-33210a/96092536-33210a/,Keysight 33210 A,294.0,['Function Generators'],"Function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33210A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782460/Instruments/Function%20Generators/Keysight-33210A/Keysight-33210A.jpg,Keysight 33210A,Write a Python script that uses Qcodes to connect to a Keysight 33210A Function Generators,,,,,"from functools import partial
import logging
from typing import Union, Any

from qcodes import VisaInstrument, validators as vals
from qcodes.instrument.channel import InstrumentChannel
from qcodes.instrument.base import Instrument
from qcodes.instrument_drivers.Keysight.private.error_handling import \
    KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class OutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a waveform generator
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


class SyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output. Has very few parameters for
    single channel instruments
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels+1):
            channel = OutputChannel(self, f'ch{i}', i)
            self.add_submodule(f'ch{i}', channel)

        sync = SyncChannel(self, 'sync')
        self.add_submodule('sync', sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
52,https://www.qdusa.com/siteDocs/productBrochures/1307-010.pdf,"https://www.uno.edu/amri/amri-facs/analysis/ppms#:~:text=PPMS%20is%20an%20open%20architecture,dc%20magnetometry%2C%20and%20thermal%20transport.","[OrderedDict([('id', 'attIdQjUH4YHswsZt'), ('width', 400), ('height', 368), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dkZWXDLET3KxuGFm6q7xsA/I0dDJqZApjJPjje1CT_kJhrDTXTrmYYsZLDIprHmVhTYoFYIOTk1F7EEmxpvXX3XdEDHr3simJvJg2BRP53JGIenSL0dDMGOCO6ZxOhOdpd9vLAw7M980icb-kG5Golk/uihUARTHJhczvQJfcZyhpRjNtNwSpCHaCf01Gxc1aqA'), ('filename', '139_ku_qd_PPMS-dyna-cool_frei.png'), ('size', 116211), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uic-0yeSK0h_in8pg8zXig/fcGubDCs3-yKhvQu_yPmOZWBGPsjsmOXD8GMkUBiD0ZW7h17CHvNxvjVADOXI6IufPOpHjcXZ1kpTTzi-PqXpw/S9uOhXeeeA_qAZfCGUpzaz-l6mIb-KFdC9pZyTzYqr4'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ECgZ5h5_3qNM3IYIjaysqg/Cet4QGHEirngwBHLVG50DV_f0xLtZCFJAv1O1yUwmXQcCq989CZeiCf49Gwpo2KW5TMiBFyNbzxSty4PdfDbBA/j6qVGWa2LegHxJs2_UTkH_rWbVqpdBO47_5TON2H7B4'), ('width', 400), ('height', 368)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/a2sgIR80CJiJC5s95oDWRw/CSO4CJi5ZV-jGFOYPsDPJeI_8bQhYTyjO0gR3aKpLx7zYKRLPrTrxAgLYYKv9F3eGAmaqyTvvbSeY7eDJYa6aw/d4XOZUHystbOGR4hW3JljmJLPGs8pTrX37wUptKCwPI'), ('width', 3000), ('height', 3000)]))]))])]",41.5,"San Diego, California",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116720/Instruments/Vendor%20Logos/QuantumDesign.png,"Quantum Design's DynaCool™ PPMS® performs electrical, thermal and magnetic measurements while controlling the samples temperature and magnetic environment.The system uses a single two-stage pulse tube cooler to cool both the superconducting magnet and provide temperature control below 10K, resulting in a low vibration environment for sample measurements. At low temperatures a small amount of Helium-4 is condensed and used to cool the sample while the magnet is cooled through solid contact to a 4 K plate.",https://www.mrl.ucsb.edu/tempo-facility/instruments/dynacool-ppms,Dynacoolppms,426.0,"['Spectrometers', 'Temperature Controllers', 'Power Meters']","PPMS is an open architecture, variable temperature-field system, designed to perform a variety of automated measurements, including resistivity, heat capacity, ac/dc magnetometry, and thermal transport.","Quantum Design manufactures automated temperature and magnetic field testing platforms.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QuantumDesign/DynaCoolPPMS/DynaCool.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/QuantumDesign.html#qcodes.instrument_drivers.QuantumDesign.DynaCool,Quantum Design,"[OrderedDict([('id', 'attKqZzJWXKLTBY0y'), ('width', 330), ('height', 76), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/s-agj-EfU36eyVZdZ9Y9FQ/DBC-4CtTQ1qtJ0LDTts-6vooubsVebCfNDSVhL3jJ5Pb8YRzuHiM2EtcO25_LAWurKLuJWuhc54qtazjeoihfFLYIFL7DtkGmszvgOBuSXA/hKyNFBLU39HBRVtNpcLuE7TYNwXS4KmwnthWMdLq3m4'), ('filename', 'QD_logo.png'), ('size', 9920), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4ruTfdC_SCROB76WMgYLMA/kgD_bEKR0ISsr2yPznbp73eMH3aNuCqAmDrdMzbpWzRFayanB_jgm7dbHPGWmXllvd8zgjqJ194g59eEfWatjA/zM7dFxsm-PnO1v_D7kB15m0bHw4R0IZQSNNFDDYWbGs'), ('width', 156), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ovJfQ7xsalGFzB0KFjlcyQ/JNpBH4voBbiOImKCkzdPC8Z6BX4fq3W9_wGzwNd-D70tbP9xjEQtILBvegXCJydtG3APGpadMlNxVcMFgLcYUw/RvaM0aI8Su4bxYqDFyfTUTxv74-r7U6geeNDgNE9Bn8'), ('width', 330), ('height', 76)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RHEZFdiN7Qy4EdJ4gRaUzw/kcDWCdGs9GPgSnOgAZ-mqbUqoeHoqDOB-ZyDW9rrntJluql-bqAMQKaIbpQ-gZ5AZ_uHqnuee7ckMwVC7Lpkbg/-_5bpYY_a7UIGfpkQsN5Ut8vNN2LPp5BX6PRpQpkzKg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.qdusa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782464/Instruments/Spectrometers/PPMS-Dynacool/PPMS-Dynacool.png,PPMS Dynacool,"Write a Python script that uses Qcodes to connect to a PPMS Dynacool Spectrometers, Temperature Controllers, Power Meters",,,,,"import warnings
from functools import partial
from time import sleep
from typing import Any, Optional, Union, cast

import numpy as np
from pyvisa import VisaIOError

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument


class DynaCool(VisaInstrument):
    """"""
    Class to represent the DynaCoolPPMS

    Note that this driver assumes the server
    to be running on the DynaCool dedicated control PC.
    The server can be launched using `qcodes-dynacool-server.exe`
    or by executing server.py (from the 'private' folder)

    Args:
        name: The name used internally by QCoDeS for this driver
        address: The VISA resource name.
          E.g. 'TCPIP0::127.0.0.1::5000::SOCKET' with the appropriate IP
          address instead of 127.0.0.1. Note that the port number is
          hard-coded into the server.
    """"""

    # the ramp time resolution is in (s) and is used in the
    # _do_blocking_ramp method
    _ramp_time_resolution = 0.1

    temp_params = ['temperature_setpoint', 'temperature_rate',
                   'temperature_settling']
    field_params = ['field_target', 'field_rate', 'field_approach']

    _errors = {-2: lambda: warnings.warn('Unknown command'),
               1: lambda: None,
               0: lambda: None}

    def __init__(self, name: str,
                 address: str,
                 **kwargs: Any) -> None:
        super().__init__(name=name, address=address, terminator='\r\n',
                         **kwargs)

        self.add_parameter('temperature',
                           label='Temperature',
                           unit='K',
                           get_parser=partial(DynaCool._pick_one, 1, float),
                           get_cmd='TEMP?')

        # Note: from the Lyngby Materials Lab, we have been told that the
        # manual is wrong about the minimal temperature. The manual says
        # 1.8 K, but it is in fact 1.6 K
        self.add_parameter('temperature_setpoint',
                           label='Temperature setpoint',
                           unit='K',
                           vals=vals.Numbers(1.6, 400),
                           set_cmd=partial(self._temp_setter,
                                           'temperature_setpoint'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_setpoint'))

        self.add_parameter('temperature_rate',
                           label='Temperature settle rate',
                           unit='K/s',
                           vals=vals.Numbers(0.0002, 0.3),
                           set_parser=lambda x: x*60,  # conversion to K/min
                           get_parser=lambda x: x/60,  # conversion to K/s
                           set_cmd=partial(self._temp_setter,
                                           'temperature_rate'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_rate'))

        self.add_parameter('temperature_settling',
                           label='Temperature settling mode',
                           val_mapping={'fast settle': 0,
                                        'no overshoot': 1},
                           set_cmd=partial(self._temp_setter,
                                           'temperature_settling'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_settling'))

        self.add_parameter('temperature_state',
                           label='Temperature tracking state',
                           val_mapping={""tracking"": 2,
                                        'stable': 1,
                                        'near': 5,
                                        'chasing': 6,
                                        'pot operation': 7,
                                        'standby': 10,
                                        'diagnostic': 13,
                                        'impedance control error': 14,
                                        'failure': 15},
                           get_parser=partial(DynaCool._pick_one, 2, int),
                           get_cmd='TEMP?')

        self.add_parameter('field_measured',
                           label='Field',
                           unit='T',
                           get_cmd=self._measured_field_getter)

        self.add_parameter('field_target',
                           label='Field target',
                           unit='T',
                           get_cmd=None,
                           set_cmd=None,
                           vals=vals.Numbers(-14, 14))

        self.add_parameter('field_ramp',
                           label='Field [ramp]',
                           unit='T',
                           get_cmd=None,
                           set_cmd=self._field_ramp_setter,
                           vals=vals.Numbers(-14, 14))

        self.add_parameter('field_rate',
                           label='Field rate',
                           unit='T/s',
                           get_parser=lambda x: x*1e-4,  # Oe to T
                           set_parser=lambda x: x*1e4,  # T to Oe
                           set_cmd=None,
                           get_cmd=None,
                           initial_value=0,
                           vals=vals.Numbers(0, 1))

        self.add_parameter('field_approach',
                           label='Field ramp approach',
                           val_mapping={'linear': 0,
                                        'no overshoot': 1,
                                        'oscillate': 2},
                           set_cmd=None,
                           get_cmd=None,
                           initial_value='linear')

        self.add_parameter('magnet_state',
                           label='Magnet state',
                           val_mapping={'unknown': 0,
                                        'stable': 1,
                                        'switch warming': 2,
                                        'switch cool': 3,
                                        'holding': 4,
                                        'iterate': 5,
                                        'ramping': 6,
                                        'ramping ': 7,  # map must have inverse
                                        'resetting': 8,
                                        'current error': 9,
                                        'switch error': 10,
                                        'quenching': 11,
                                        'charging error': 12,
                                        'power supply error': 14,
                                        'failure': 15},
                           get_parser=partial(DynaCool._pick_one, 2, int),
                           get_cmd='FELD?')

        self.add_parameter('chamber_temperature',
                           label='Chamber Temperature',
                           unit='K',
                           get_parser=partial(DynaCool._pick_one, 1, float),
                           get_cmd='CHAT?')

        self.add_parameter('chamber_state',
                           label='Chamber vacuum state',
                           val_mapping={'purged and sealed': 1,
                                        'vented and sealed': 2,
                                        'sealed': 3,
                                        'performing purge/seal': 4,
                                        'performing vent/seal': 5,
                                        'pre-high vacuum': 6,
                                        'high vacuum': 7,
                                        'pumping continuously': 8,
                                        'flooding continuously': 9},
                           get_parser=partial(DynaCool._pick_one, 1, int),
                           get_cmd='CHAM?')

        self.add_parameter('field_tolerance',
                           label=""Field Tolerance"",
                           unit='T',
                           get_cmd=None,
                           set_cmd=None,
                           vals=vals.Numbers(0, 1e-2),
                           set_parser=float,
                           docstring=""The tolerance below which fields are ""
                                     ""considered identical in a ""
                                     ""blocking ramp."",
                           initial_value=5e-4)

        # The error code of the latest command
        self._error_code = 0

        # we must know all parameter values because of interlinked parameters
        self.snapshot(update=True)

        # it is a safe default to set the target to the current value
        self.field_target(self.field_measured())

        self.connect_message()

    @property
    def error_code(self) -> int:
        return self._error_code

    @staticmethod
    def _pick_one(which_one: int, parser: type, resp: str) -> Any:
        """"""
        Since most of the API calls return several values in a comma-separated
        string, here's a convenience function to pick out the substring of
        interest
        """"""
        return parser(resp.split(', ')[which_one])

    def get_idn(self) -> dict[str, Optional[str]]:
        response = self.ask('*IDN?')
        # just clip out the error code
        id_parts = response[2:].split(', ')

        return dict(zip(('vendor', 'model', 'serial', 'firmware'), id_parts))

    def ramp(self, mode: str = ""blocking"") -> None:
        """"""
        Ramp the field to the value given by the `field_target` parameter

        Args:
            mode: how to ramp, either ""blocking"" or ""non-blocking"". In
                ""blocking"" mode, this function does not return until the
                target field has been reached. In ""non-blocking"" mode, this
                function immediately returns.
        """"""
        if mode not in ['blocking', 'non-blocking']:
            raise ValueError('Invalid ramp mode received. Ramp mode must be '
                             'either ""blocking"" or ""non-blocking"", received '
                             f'""{mode}""')

        target_in_tesla = self.field_target()
        # the target must be converted from T to Oersted
        target_in_oe = target_in_tesla*1e4

        start_field = self.field_measured()
        ramp_range = np.abs(start_field - target_in_tesla)
        # as the second argument is zero relative tolerance has no effect.
        if np.allclose([ramp_range], 0, rtol=0, atol=self.field_tolerance()):
            return

        if mode == ""blocking"":
            self._do_blocking_ramp(target_in_tesla, start_field)
        else:
            self._field_setter(param='field_target',
                               value=target_in_oe)

    def _do_blocking_ramp(self, target_in_tesla: float,
                          start_field_in_tesla: float) -> None:
        """"""
        Perform a blocking ramp. Only call this function from withing the
        `ramp` method.

        This method is slow; it waits for the magnet to settle. The waiting is
        done in two steps, since users have reported that the magnet state does
        not immediately change to 'ramping' when asked to ramp.
        """"""

        target_in_oe = target_in_tesla*1e4
        ramp_range = np.abs(target_in_tesla - start_field_in_tesla)

        self._field_setter(param='field_target', value=target_in_oe)

        # step 1: wait for the magnet to actually start ramping
        # NB: depending on the `field_approach`, we may reach the target
        # several times before the ramp is over (oscillations around target)
        while np.abs(self.field_measured() - start_field_in_tesla) \
                < ramp_range * 0.5:
            sleep(self._ramp_time_resolution)

        # step 2: wait for the magnet to report that is has reached the
        # setpoint

        while self.magnet_state() != 'holding':
            sleep(self._ramp_time_resolution)

    def _field_ramp_setter(self, target: float) -> None:
        """"""
        set_cmd for the field_ramp parameter
        """"""
        self.field_target(target)
        self.ramp(mode='blocking')

    def _measured_field_getter(self) -> float:
        resp = self.ask('FELD?')
        number_in_oersted = cast(float, DynaCool._pick_one(1, float, resp))
        number_in_tesla = number_in_oersted*1e-4
        return number_in_tesla

    def _field_getter(self, param_name: str) -> Union[int, float]:
        """"""
        The combined get function for the three field parameters,
        field_setpoint, field_rate, and field_approach
        """"""
        raw_response = self.ask('GLFS?')
        sp = self._pick_one(1, float, raw_response)
        rate = self._pick_one(2, float, raw_response)
        approach = self._pick_one(3, int, raw_response)

        return dict(zip(self.field_params, [sp, rate, approach]))[param_name]

    def _field_setter(self, param: str, value: float) -> None:
        """"""
        The combined set function for the three field parameters,
        field_setpoint, field_rate, and field_approach
        """"""
        temporary_values = list(self.parameters[p].raw_value
                                for p in self.field_params)
        values = cast(list[Union[int, float]], temporary_values)
        values[self.field_params.index(param)] = value

        self.write(f'FELD {values[0]}, {values[1]}, {values[2]}, 0')

    def _temp_getter(self, param_name: str) -> Union[int, float]:
        """"""
        This function queries the last temperature setpoint (w. rate and mode)
        from the instrument.
        """"""
        raw_response = self.ask('GLTS?')
        sp = DynaCool._pick_one(1, float, raw_response)
        rate = DynaCool._pick_one(2, float, raw_response)
        mode = DynaCool._pick_one(3, int, raw_response)

        return dict(zip(self.temp_params, [sp, rate, mode]))[param_name]

    def _temp_setter(self, param: str, value: float) -> None:
        """"""
        The setter function for the temperature parameters. All three are set
        with the same call to the instrument API
        """"""
        temp_values = list(self.parameters[par].raw_value
                           for par in self.temp_params)
        values = cast(list[Union[int, float]], temp_values)
        values[self.temp_params.index(param)] = value

        self.write(f'TEMP {values[0]}, {values[1]}, {values[2]}')

    def write(self, cmd: str) -> None:
        """"""
        Since the error code is always returned, we must read it back
        """"""
        super().write(cmd)
        self._error_code = int(self.visa_handle.read())
        self._errors[self._error_code]()
        self.visa_log.debug(f'Error code: {self._error_code}')

    def ask(self, cmd: str) -> str:
        """"""
        Since the error code is always returned, we must read it back
        """"""
        response = super().ask(cmd)
        self._error_code = DynaCool._pick_one(0, int, response)
        self._errors[self._error_code]()
        return response

    def close(self) -> None:
        """"""
        Make sure to nicely close the server connection
        """"""
        try:
            self.log.debug('Closing server connection.')
            self.write('CLOSE')
        except VisaIOError as e:
            self.log.info('Could not close connection to server, perhaps the '
                          'server is down?')
            self.log.info(f'Got the following error from PyVISA: '
                          f'{e.abbreviation}: {e.description}')
        super().close()
"
57,https://www.keysight.com/us/en/assets/7018-01211/data-sheets/5989-0698.pdf,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,"[OrderedDict([('id', 'attrnzDM8pYxmEe19'), ('width', 2000), ('height', 837), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/p0gUp_HWQKToAeys4BxH4Q/08jNn6-rQjjABRH99lXTkv15OZnhq3G1n1mgL_oMyncTBsoLf3Rj9noPgWfZwjvaRMzAP_Jq2JIAIyyAPzz3KvY6Q6lFRjLMuf3RNPATbuY/qDMJRMF-xXduCK9kx_6_eF5HiLtBDneTkRYf9l1eCVE'), ('filename', 'Keysight-E8257D.jpg'), ('size', 1664333), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ir_r9dK71wR6wao4G7mN0g/JbDqSLrzwLLzPvAozHz4TuYHPdlMNG6e0lSO6XeZ5VfMj4mmlnyxOv40aZCGcrEiPxYFNfkk_q2dUlwINXX8IQ/5Ai6cMvfNhSu3Vhm_OomZVdnD81wBCMRQCNB4gpzb1g'), ('width', 86), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/TtMDMMHdZmurSpTlndOL5Q/KC0NK9J8diFwvbZ97dzzIP5fl_fKevnv_fqYbIvEAbWEs34Y-324J-EBX_vu0RRszRzs0uPhheyM0t-MYfbOcA/DzlTCgYj1tZjblaRZIi4Emh_wJZnWQYX6_m4zDTa8Ms'), ('width', 1223), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rzjIgfT24HXmm4JewY38Ww/fSLw5qRVRHvXNLKFOWGvC7nqjc2ZQfbY6XG9OmyhqWeFmczvFCAnkE1G3z_rneH7i-aaZI-s10aih8OC0vBEJg/ZS-tJHrwdxFRR_kMznCivR3Um6o7OoGcKZK6K06Z4JE'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"Metrology-grade analog signal generator offering industry-leading output power, level accuracy, and phase noise, with frequency coverage from 100 kHz to 67 GHz (extendable to 500 GHz) for testing advanced RF and microwave radar",https://www.keysight.com/us/en/product/E8257D/psg-analog-signal-generator-100-khz-67-ghz.html,Agilent E 8257 D,25.0,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.

","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/agilent/Agilent_E8257D.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.AgilentE8257D,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iBkD5hWEdE9VzBFEnSeOfA/NjWxUxjJA8yGPExBiN-PkZNjv4VfBExywq89pMu9c9Ra2W7et-Aw64QgEaSQebRctQuA2kL2PnwYRmggAnp4lSGJ5zznVS6ye7vLZh646iQ/Kl7uXhhhwfiGUId4CxlN-USzNex2x6CGk7CVIvfLvQ4'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f6t0-WbC6cKqyn0DT117iA/QPT0gpK6FG2qsOLK-bt0IxmOydbb6-9Pxg2hNGQF0mxWHfXPYXFiZagCw1Yj9qkKeKEbN-OQzc1R1_lDDq3DCa-N0BRerbz5SnzZQJlzbJ8/iuupeOUi0pSC13qOqrqjRHiA-gwJTseDKR1IenXqWtY'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cFs4Pvz6m9YFSFnAUBP9Jw/NgiAU7UcTKsj4PX6Lzw6SkhLC1rCN7-KpOyUy0E3yh7QLAbmpKXYyYKq1x_OkoLZAlEY7R20W5zF_Vo0-E3cUyiYsxgXKf9_RTswNy3Wd7w/GhCXNKTSYmUF5vw3ifd6HKHmQkYlHKJQaWCVYa06Xqg'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pxy_7pX_47hdW9iN2Gvi7A/4LRl2aDd8IoPIwJ53KRuFtJ4dEG8aRW8frebU514v4lYFkRRLyyF7Kcfv4Q3zGQT19g9Bs1hNet5CN1YxdFcjM9hQIBoBBiixzvExLQHvMM/RhEKW_l5u-Xiv303cIU5H_n4SPQvKttNDyTSjmqpWkI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782469/Instruments/RF%20Signal%20Generator/Keysight-E8257D/Keysight-E8257D.png,Keysight E8257D,Write a Python script that uses Qcodes to connect to a Keysight E8257D RF Signal Generator,48000.0,"
",,,"import warnings
from typing import Any, Optional, Union

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class AgilentE8257D(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Agilent E8257D signal generator.
    This driver will most likely work for multiple Agilent sources.
    This driver does not contain all commands available for the E8257D but
    only the ones most commonly used.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        step_attenuator: Optional[bool] = None,
        terminator: str = ""\n"",
        **kwargs: Any
    ) -> None:
        super().__init__(name, address, terminator=terminator, **kwargs)

        if step_attenuator is not None:
            warnings.warn(
                ""step_attenuator argument to E8257D is deprecated ""
                ""and has no effect. It will be removed in the ""
                ""future.""
            )

        # Query installed options
        self._options = self.ask_raw(""DIAG:CPU:INFO:OPT:DET?"")

        # Determine installed frequency option
        frequency_option = None
        for f_option in [""513"", ""520"", ""521"", ""532"", ""540"", ""550"", ""567""]:
            if f_option in self._options:
                frequency_option = f_option
        if frequency_option is None:
            raise RuntimeError(""Could not determine the frequency option"")

        # convert installed frequency option to frequency ranges, based on:
        # https://www.keysight.com/us/en/assets/7018-01233/configuration-guides
        # /5989-1325.pdf
        # the frequency range here is the max range and not the specified
        # (calibrated) one
        f_options_dict = {
            ""513"": (100e3, 13e9),
            ""520"": (100e3, 20e9),
            ""521"": (10e6, 20e9),
            ""532"": (100e3, 31.8e9),
            ""540"": (100e3, 40e9),
            ""550"": (100e3, 50e9),
            ""567"": (100e3, 70e9),
        }

        # assign min and max frequencies
        self._min_freq: float
        self._max_freq: float
        self._min_freq, self._max_freq = f_options_dict[frequency_option]

        # Based on installed frequency option and presence/absence of step
        # attenuator (option '1E1') determine power range based on:
        # https://www.keysight.com/us/en/assets/7018-01211/data-sheets
        # /5989-0698.pdf

        # assign min and max powers
        self._min_power: float
        self._max_power: float

        if ""1E1"" in self._options:
            if frequency_option in [""513"", ""520"", ""521"", ""532"", ""540""]:
                self._min_power = -135
                self._max_power = 10
            else:
                self._min_power = -110
                self._max_power = 5
        else:
            # default minimal power is -20 dBm
            if frequency_option in [""513"", ""520"", ""521"", ""532"", ""540""]:
                self._min_power = -20
                self._max_power = 10
            else:
                self._min_power = -20
                self._max_power = 5

        self.add_parameter(
            name=""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=""FREQ:CW?"",
            set_cmd=""FREQ:CW"" + "" {:.4f}"",
            get_parser=float,
            set_parser=float,
            vals=vals.Numbers(self._min_freq, self._max_freq),
        )

        self.add_parameter(
            name=""phase"",
            label=""Phase"",
            unit=""deg"",
            get_cmd=""PHASE?"",
            set_cmd=""PHASE"" + "" {:.8f}"",
            get_parser=self.rad_to_deg,
            set_parser=self.deg_to_rad,
            vals=vals.Numbers(-180, 180),
        )

        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=""POW:AMPL?"",
            set_cmd=""POW:AMPL"" + "" {:.4f}"",
            get_parser=float,
            set_parser=float,
            vals=vals.Numbers(self._min_power, self._max_power),
        )

        self.add_parameter(
            ""output_enabled"",
            get_cmd="":OUTP?"",
            set_cmd=""OUTP {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.connect_message()

    def on(self) -> None:
        self.set(""status"", ""on"")

    def off(self) -> None:
        self.set(""status"", ""off"")

    # functions to convert between rad and deg
    @staticmethod
    def deg_to_rad(
        angle_deg: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.deg2rad(float(angle_deg))

    @staticmethod
    def rad_to_deg(
        angle_rad: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.rad2deg(float(angle_rad))
"
59,https://www.lakeshore.com/docs/default-source/product-downloads/lstc_335_l.pdf?sfvrsn=becadb1e_3,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attWM9BrNjEOhwMP4'), ('width', 500), ('height', 283), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CsEaOJprjhQIa6jdYKL2Fg/25OnLsMubwWBv88uIyhU_qZPEsCRQGJgsSgYs5juFFA2AnkxWxSYjWx-XXmHBZA8Ao0fu7JMte3kvNCQQrVhJg/0mVgzhhOKFUBKcZ2LKxCC_LwDuRB1EOD0OmqEPxjR2k'), ('filename', '335.png'), ('size', 160368), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Yk6S1EOlxwjE5RI5YvE89g/kx6by-QkC6g0zwrrnhKxMgXL6zGC8EoH83KkahWhPQOStlI3MNlejjlgawGFW9-B4RS0O1qDtGrSur_bmS8mWQ/z3Kq81QW16lKdeOSIC8E4CDThS__vMz2z2obA-k_uK0'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hXms3Jkgxni5OySMVnzmKw/oPWdEmnhMudaKaIryNAwpvqD1LW03BAHN-RUkhyT_ueMrQMEWhj75Y9YEGtbLPUEL1tDdSePIG8BhblQWErNLg/LySlMx2wFmPfElDBn_VjA3luA9E_ixty6YdxNdCDWDo'), ('width', 500), ('height', 283)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OE7n-4qWW4fc8oj8m7W1Ng/tQZOSnCcm3hV3V0SwyDz6v5qecPl-0uBcmd9hLGWbSYfO0FEL0q_1wISDbGjtzsJtlo16Mvn1XN-o9l3VSl5iQ/Hb4k_wa20N-IudtVawmJv0P3L_CtrUpFyrN5jMQhqK8'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 335 supports the industry's most advanced line of cryogenic temperature sensors as manufactured by Lake Shore, including diodes, resistance temperature detectors (RTDs), and thermocouples. The controller's zone tuning feature allows you to measure and control temperatures seamlessly from 300 mK to over 1,500 K. This feature automatically switches temperature sensor inputs when your temperature range goes beyond the usable range of a given sensor.",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-335-cryogenic-temperature-controller,Lakeshore Model 335,362.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/_lakeshore_model_335.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel335,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782471/Instruments/Temperature%20Controllers/Lakeshore-Model-335/Lakeshore-Model-335.png,Lakeshore Model 335,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,4181.0,,,,"from typing import Any, ClassVar

import pyvisa.constants
import pyvisa.resources

import qcodes.validators as vals
from qcodes.parameters import Group, GroupParameter

from .lakeshore_base import BaseOutput, BaseSensorChannel, LakeshoreBase

# There are 2 sensors channels (a.k.a. measurement inputs) in Model 335.
# Unlike other Lakeshore models, Model 335 refers to the channels using
# letters, and not numbers
_channel_name_to_command_map: dict[str, str] = {""A"": ""A"", ""B"": ""B""}

# OUTMODE command of this model refers to the outputs via integer numbers,
# while everywhere else within this model letters are used. This map is
# created in order to preserve uniformity of referencing to sensor channels
# within this driver.
_channel_name_to_outmode_command_map: dict[str, int] = {
    ch_name: num_for_cmd + 1
    for num_for_cmd, ch_name in enumerate(_channel_name_to_command_map.keys())
}


class LakeshoreModel335Channel(BaseSensorChannel):
    """"""
    An InstrumentChannel representing a single sensor on a Lakeshore Model 335.

    """"""

    SENSOR_STATUSES = {
        0: ""OK"",
        1: ""Invalid Reading"",
        16: ""Temp Underrange"",
        32: ""Temp Overrange"",
        64: ""Sensor Units Zero"",
        128: ""Sensor Units Overrange"",
    }

    def __init__(self, parent: ""LakeshoreModel335"", name: str, channel: str):
        super().__init__(parent, name, channel)

        # Parameters related to Input Type Parameter Command (INTYPE)
        self.add_parameter(
            ""sensor_type"",
            label=""Input sensor type"",
            docstring=""Specifies input sensor type"",
            val_mapping={""disabled"": 0, ""diode"": 1, ""platinum_rtd"": 2, ""ntc_rtd"": 3},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""auto_range_enabled"",
            label=""Autoranging"",
            docstring=""Specifies if autoranging is enabled. ""
            ""Does not apply for diode sensor type"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""range"",
            label=""Range"",
            docstring=""Specifies input range when autorange is ""
            ""not enabled. If autorange is on, the ""
            ""returned value corresponds to the ""
            ""currently auto-selected range. The list ""
            ""of available ranges depends on the ""
            ""chosen sensor type: diode 0-1, platinum ""
            ""RTD 0-6, NTC RTD 0-8. Refer to the page ""
            ""136 of the manual for the lookup table"",
            vals=vals.Numbers(0, 8),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""compensation_enabled"",
            label=""Compensation enabled"",
            docstring=""Specifies input compensation. Reversal ""
            ""for thermal EMF compensation if input ""
            ""is resistive, room compensation if ""
            ""input is thermocouple. Always 0 if input ""
            ""is a diode"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""units"",
            label=""Preferred units"",
            docstring=""Specifies the preferred units parameter ""
            ""for sensor readings and for the control ""
            ""setpoint (kelvin, celsius, or sensor)"",
            val_mapping={""kelvin"": 1, ""celsius"": 2, ""sensor"": 3},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.sensor_type,
                self.auto_range_enabled,
                self.range,
                self.compensation_enabled,
                self.units,
            ],
            set_cmd=f""INTYPE {self._channel}, ""
            f""{{sensor_type}}, ""
            f""{{auto_range_enabled}}, {{range}}, ""
            f""{{compensation_enabled}}, ""
            f""{{units}}"",
            get_cmd=f""INTYPE? {self._channel}"",
        )


class LakeshoreModel335CurrentSource(BaseOutput):
    """"""
    InstrumentChannel for current sources on Lakeshore Model 335.

    Class for control outputs 1 and 2 of Lakeshore Model 335 that are variable DC current
    sources referenced to chassis ground.
    """"""

    MODES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""closed_loop"": 1,
        ""zone"": 2,
        ""open_loop"": 3,
    }

    RANGES: ClassVar[dict[str, int]] = {""off"": 0, ""low"": 1, ""medium"": 2, ""high"": 3}

    _input_channel_parameter_kwargs = {
        ""val_mapping"": _channel_name_to_outmode_command_map
    }

    def __init__(
        self, parent: ""LakeshoreModel335"", output_name: str, output_index: int
    ):
        super().__init__(parent, output_name, output_index, has_pid=True)

        self.P.vals = vals.Numbers(0.1, 1000)
        self.I.vals = vals.Numbers(0.1, 1000)
        self.D.vals = vals.Numbers(0, 200)


class LakeshoreModel335(LakeshoreBase):
    """"""
    Lakeshore Model 335 Temperature Controller Driver
    """"""

    channel_name_command: dict[str, str] = _channel_name_to_command_map

    CHANNEL_CLASS = LakeshoreModel335Channel

    input_channel_parameter_values_to_channel_name_on_instrument = (
        _channel_name_to_command_map
    )

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, print_connect_message=False, **kwargs)

        if isinstance(self.visa_handle, pyvisa.resources.serial.SerialInstrument):
            self.visa_handle.baud_rate = 57600
            self.visa_handle.data_bits = 7
            self.visa_handle.parity = pyvisa.constants.Parity(1)

        self.output_1 = LakeshoreModel335CurrentSource(self, ""output_1"", 1)
        self.output_2 = LakeshoreModel335CurrentSource(self, ""output_2"", 2)

        self.connect_message()
"
64,https://www.keysight.com/us/en/assets/9018-04392/technical-specifications/9018-04392.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'atti4AL2ETsCbVK4I'), ('width', 500), ('height', 308), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q41ujaxsQe6wBAGshTTWug/QDjQ5-mbsdWYPX_yo5b8eQ-524AFWyjVAXVzraJLYb7O3WUi1DqX6w09rSjcn66aPIKr7ti4Mp7mRmrDJZ3qjzLJu2awPfoPJoodLoI7NMA/d2V3IHfWI6cmGk20f_YHB_LBDN798Vpep8YPWNWriu0'), ('filename', 'N5232B.2.jpg'), ('size', 38845), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q0r2XgDArM6YkQXd3xZRPQ/RpNsyq0iWxBovMdcIq3fqJ_UC13Ng7uo0r9oxd5WiAVHusiEgxQLr7CjNbMCRye2ekxqA3MM0dPNqIOSi5sfbA/oKZ83ag2B_T2BpLNKX9jix6SHIyrur4zIiyWKaQJPL0'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rvZ8qmW3KtApHEY8wCFU4g/hGHPh9HrJ4Moxrf8RyTNtwC2BKEvcP3HIrEMFOeM_Arfmf3-axrPgcSeShDxJ9X8kKnYgxwVRo-wJ81insuVQw/-6rHpFermJZ3mVg_3R99mo6l1VrVqqzqvQpKHs7hz_4'), ('width', 500), ('height', 308)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/E_Gpw85TOeThjLtQF6-8gg/Zc8CtuIS9ygF9kGjgNNFHKtWYcNfWxPhkVNVYVYMJSAUHH2S_j675Ok9NsiTf9VpX5IyCwVwws3ilzB5eBHI6w/2a9cLcT-xJM_0zx7Cu4bvYfm9hB3gnU-GZvI_Uag1XU'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight N5232B PNA-L series network analyzer is designed for S-parameter and simple nonlinear testing of passive components, amplifiers, and frequency converters. With the same core firmware as the PNA, the PNA-L offers the perfect balance of value and performance. The PNA-L provides efficiency and flexibility in both manufacturing and R&D applications, for industries ranging from mobile-telecomm and wireless-LAN component production to aerospace and defense. ",https://www.axiomtest.com/Network-Analyzers/More-than-6-GHz%2C-up-to-20-GHz/Keysight-..-Agilent/N5232B/PNA_L-Network-Analyzer%2C-300-kHz-_-20-GHz%2C-2-or-4_ports/,Keysight N 5232 B,342.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N52xx.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5232B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782475/Instruments/Network%20Analyzer/Keysight-N5232B/Keysight-N5232B.jpg,Keysight N5232B,Write a Python script that uses Qcodes to connect to a Keysight N5232B Network Analyzer,,,,,"from typing import Sequence, Union, Any
import time
import re
import logging

import numpy as np
from pyvisa import VisaIOError, errors
from qcodes import (VisaInstrument, InstrumentChannel, ArrayParameter,
                    ChannelList)
from qcodes.utils.validators import Ints, Numbers, Enum, Bool

logger = logging.getLogger()

class PNASweep(ArrayParameter):
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 **kwargs: Any) -> None:

        super().__init__(name,
                         instrument=instrument,
                         shape=(0,),
                         setpoints=((0,),),
                         **kwargs)

    @property  # type: ignore[override]
    def shape(self) -> Sequence[int]:  # type: ignore[override]
        if self._instrument is None:
            return (0,)
        return (self._instrument.root_instrument.points(),)

    @shape.setter
    def shape(self, val: Sequence[int]) -> None:
        pass

    @property  # type: ignore[override]
    def setpoints(self) -> Sequence[np.ndarray]:  # type: ignore[override]
        if self._instrument is None:
            raise RuntimeError(""Cannot return setpoints if not attached ""
                               ""to instrument"")
        start = self._instrument.root_instrument.start()
        stop = self._instrument.root_instrument.stop()
        return (np.linspace(start, stop, self.shape[0]),)

    @setpoints.setter
    def setpoints(self, val: Sequence[int]) -> None:
        pass


class FormattedSweep(PNASweep):
    """"""
    Mag will run a sweep, including averaging, before returning data.
    As such, wait time in a loop is not needed.
    """"""
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 sweep_format: str,
                 label: str,
                 unit: str,
                 memory: bool = False) -> None:
        super().__init__(name,
                         instrument=instrument,
                         label=label,
                         unit=unit,
                         setpoint_names=('frequency',),
                         setpoint_labels=('Frequency',),
                         setpoint_units=('Hz',)
                         )
        self.sweep_format = sweep_format
        self.memory = memory

    def get_raw(self) -> Sequence[float]:
        if self._instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr = self._instrument.root_instrument
        # Check if we should run a new sweep
        if root_instr.auto_sweep():
            prev_mode = self._instrument.run_sweep()
        # Ask for data, setting the format to the requested form
        self._instrument.format(self.sweep_format)
        data = root_instr.visa_handle.query_binary_values('CALC:DATA? FDATA',
                                                          datatype='f',
                                                          is_big_endian=True)
        data = np.array(data)
        # Restore previous state if it was changed
        if root_instr.auto_sweep():
            root_instr.sweep_mode(prev_mode)

        return data


class PNAPort(InstrumentChannel):
    """"""
    Allow operations on individual PNA ports.
    Note: This can be expanded to include a large number of extra parameters...
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 port: int,
                 min_power: Union[int, float],
                 max_power: Union[int, float]) -> None:
        super().__init__(parent, name)

        self.port = int(port)
        if self.port < 1 or self.port > 4:
            raise ValueError(""Port must be between 1 and 4."")

        pow_cmd = f""SOUR:POW{self.port}""
        self.add_parameter(""source_power"",
                           label=""power"",
                           unit=""dBm"",
                           get_cmd=f""{pow_cmd}?"",
                           set_cmd=f""{pow_cmd} {{}}"",
                           get_parser=float,
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.source_power.vals = Numbers(min_value=min_power,
                                         max_value=max_power)


class PNATrace(InstrumentChannel):
    """"""
    Allow operations on individual PNA traces.
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 trace_name: str,
                 trace_num: int) -> None:
        super().__init__(parent, name)
        self.trace_name = trace_name
        self.trace_num = trace_num

        # Name of parameter (i.e. S11, S21 ...)
        self.add_parameter('trace',
                           label='Trace',
                           get_cmd=self._Sparam,
                           set_cmd=self._set_Sparam)
        # Format
        # Note: Currently parameters that return complex values are not
        # supported as there isn't really a good way of saving them into the
        # dataset
        self.add_parameter('format',
                           label='Format',
                           get_cmd='CALC:FORM?',
                           set_cmd='CALC:FORM {}',
                           vals=Enum('MLIN', 'MLOG', 'PHAS',
                                     'UPH', 'IMAG', 'REAL'))

        # And a list of individual formats
        self.add_parameter('magnitude',
                           sweep_format='MLOG',
                           label='Magnitude',
                           unit='dB',
                           parameter_class=FormattedSweep)
        self.add_parameter('linear_magnitude',
                           sweep_format='MLIN',
                           label='Magnitude',
                           unit='ratio',
                           parameter_class=FormattedSweep)
        self.add_parameter('phase',
                           sweep_format='PHAS',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter('unwrapped_phase',
                           sweep_format='UPH',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter(""group_delay"",
                           sweep_format='GDEL',
                           label='Group Delay',
                           unit='s',
                           parameter_class=FormattedSweep)
        self.add_parameter('real',
                           sweep_format='REAL',
                           label='Real',
                           unit='LinMag',
                           parameter_class=FormattedSweep)
        self.add_parameter('imaginary',
                           sweep_format='IMAG',
                           label='Imaginary',
                           unit='LinMag',
                           parameter_class=FormattedSweep)

    def run_sweep(self) -> str:
        """"""
        Run a set of sweeps on the network analyzer.
        Note that this will run all traces on the current channel.
        """"""
        root_instr = self.root_instrument
        # Store previous mode
        prev_mode = root_instr.sweep_mode()
        # Take instrument out of continuous mode, and send triggers equal to
        # the number of averages
        if root_instr.averages_enabled():
            avg = root_instr.averages()
            root_instr.reset_averages()
            root_instr.group_trigger_count(avg)
            root_instr.sweep_mode('GRO')
        else:
            root_instr.sweep_mode('SING')

        # Once the sweep mode is in hold, we know we're done
        try:
            while root_instr.sweep_mode() != 'HOLD':
                time.sleep(0.1)
        except KeyboardInterrupt:
            # If the user aborts because (s)he is stuck in the infinite loop
            # mentioned above, provide a hint of what can be wrong.
            msg = ""User abort detected. ""
            source = root_instr.trigger_source()
            if source == ""MAN"":
                msg += ""The trigger source is manual. Are you sure this is "" \
                       ""correct? Please set the correct source with the "" \
                       ""'trigger_source' parameter""
            elif source == ""EXT"":
                msg += ""The trigger source is external. Is the trigger "" \
                       ""source functional?""
            logger.warning(msg)

        # Return previous mode, incase we want to restore this
        return prev_mode

    def write(self, cmd: str) -> None:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        super().write(cmd)

    def ask(self, cmd: str) -> str:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        return super().ask(cmd)

    def _Sparam(self) -> str:
        """"""
        Extrace S_parameter from returned PNA format
        """"""
        paramspec = self.root_instrument.get_trace_catalog()
        specs = paramspec.split(',')
        for spec_ind in range(len(specs)//2):
            name, param = specs[spec_ind*2:(spec_ind+1)*2]
            if name == self.trace_name:
                return param
        raise RuntimeError(""Can't find selected trace on the PNA"")

    def _set_Sparam(self, val: str) -> None:
        """"""
        Set an S-parameter, in the format S<a><b>, where a and b
        can range from 1-4
        """"""
        if not re.match(""S[1-4][1-4]"", val):
            raise ValueError(""Invalid S parameter spec"")
        self.write(f""CALC:PAR:MOD:EXT \""{val}\"""")


class PNABase(VisaInstrument):
    """"""
    Base qcodes driver for Agilent/Keysight series PNAs
    http://na.support.keysight.com/pna/help/latest/Programming/GP-IB_Command_Finder/SCPI_Command_Tree.htm

    Note: Currently this driver only expects a single channel on the PNA. We
          can handle multiple traces, but using traces across multiple channels
          may have unexpected results.
    """"""

    def __init__(self,
                 name: str,
                 address: str,
                 # Set frequency ranges
                 min_freq: Union[int, float], max_freq: Union[int, float],
                 # Set power ranges
                 min_power: Union[int, float], max_power: Union[int, float],
                 nports: int, # Number of ports on the PNA
                 **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.min_freq = min_freq
        self.max_freq = max_freq

        #Ports
        ports = ChannelList(self, ""PNAPorts"", PNAPort)
        for port_num in range(1, nports+1):
            port = PNAPort(self, f""port{port_num}"", port_num,
                           min_power, max_power)
            ports.append(port)
            self.add_submodule(f""port{port_num}"", port)
        ports.lock()
        self.add_submodule(""ports"", ports)

        # Drive power
        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

        # IF bandwidth
        self.add_parameter('if_bandwidth',
                           label='IF Bandwidth',
                           get_cmd='SENS:BAND?',
                           get_parser=float,
                           set_cmd='SENS:BAND {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=1, max_value=15e6))

        # Number of averages (also resets averages)
        self.add_parameter('averages_enabled',
                           label='Averages Enabled',
                           get_cmd=""SENS:AVER?"",
                           set_cmd=""SENS:AVER {}"",
                           val_mapping={True: '1', False: '0'})
        self.add_parameter('averages',
                           label='Averages',
                           get_cmd='SENS:AVER:COUN?',
                           get_parser=int,
                           set_cmd='SENS:AVER:COUN {:d}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=65536))

        # Setting frequency range
        self.add_parameter('start',
                           label='Start Frequency',
                           get_cmd='SENS:FREQ:STAR?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STAR {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('stop',
                           label='Stop Frequency',
                           get_cmd='SENS:FREQ:STOP?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STOP {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('center',
                           label='Center Frequency',
                           get_cmd='SENS:FREQ:CENT?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:CENT {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('span',
                           label='Frequency Span',
                           get_cmd='SENS:FREQ:SPAN?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:SPAN {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))

        # Number of points in a sweep
        self.add_parameter('points',
                           label='Points',
                           get_cmd='SENS:SWE:POIN?',
                           get_parser=int,
                           set_cmd='SENS:SWE:POIN {}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=100001))

        # Electrical delay
        self.add_parameter('electrical_delay',
                           label='Electrical Delay',
                           get_cmd='CALC:CORR:EDEL:TIME?',
                           get_parser=float,
                           set_cmd='CALC:CORR:EDEL:TIME {:.6e}',
                           unit='s',
                           vals=Numbers(min_value=0, max_value=100000))

        # Sweep Time
        self.add_parameter('sweep_time',
                           label='Time',
                           get_cmd='SENS:SWE:TIME?',
                           get_parser=float,
                           unit='s',
                           vals=Numbers(0, 1e6))
        # Sweep Mode
        self.add_parameter('sweep_mode',
                           label='Mode',
                           get_cmd='SENS:SWE:MODE?',
                           set_cmd='SENS:SWE:MODE {}',
                           vals=Enum(""HOLD"", ""CONT"", ""GRO"", ""SING""))
        # Group trigger count
        self.add_parameter('group_trigger_count',
                           get_cmd=""SENS:SWE:GRO:COUN?"",
                           get_parser=int,
                           set_cmd=""SENS:SWE:GRO:COUN {}"",
                           vals=Ints(1, 2000000))
        # Trigger Source
        self.add_parameter('trigger_source',
                           get_cmd=""TRIG:SOUR?"",
                           set_cmd=""TRIG:SOUR {}"",
                           vals=Enum(""EXT"", ""IMM"", ""MAN""))

        # Traces
        self.add_parameter('active_trace',
                           label='Active Trace',
                           get_cmd=""CALC:PAR:MNUM?"",
                           get_parser=int,
                           set_cmd=""CALC:PAR:MNUM {}"",
                           vals=Numbers(min_value=1, max_value=24))
        # Note: Traces will be accessed through the traces property which
        # updates the channellist to include only active trace numbers
        self._traces = ChannelList(self, ""PNATraces"", PNATrace)
        self.add_submodule(""traces"", self._traces)
        # Add shortcuts to first trace
        trace1 = self.traces[0]
        params = trace1.parameters
        if not isinstance(params, dict):
            raise RuntimeError(f""Expected trace.parameters to be a dict got ""
                               f""{type(params)}"")
        for param in params.values():
            self.parameters[param.name] = param
        # And also add a link to run sweep
        self.run_sweep = trace1.run_sweep
        # Set this trace to be the default (it's possible to end up in a
        # situation where no traces are selected, causing parameter snapshots
        # to fail)
        self.active_trace(trace1.trace_num)

        # Set auto_sweep parameter
        # If we want to return multiple traces per setpoint without sweeping
        # multiple times, we should set this to false
        self.add_parameter('auto_sweep',
                           label='Auto Sweep',
                           set_cmd=None,
                           get_cmd=None,
                           vals=Bool(),
                           initial_value=True)

        # A default output format on initialisation
        self.write('FORM REAL,32')
        self.write('FORM:BORD NORM')

        self.connect_message()

    @property
    def traces(self) -> ChannelList:
        """"""
        Update channel list with active traces and return the new list
        """"""
        # Keep track of which trace was active before. This command may fail
        # if no traces were selected.
        try:
            active_trace = self.active_trace()
        except VisaIOError as e:
            if e.error_code == errors.StatusCode.error_timeout:
                active_trace = None
            else:
                raise

        # Get a list of traces from the instrument and fill in the traces list
        parlist = self.get_trace_catalog().split("","")
        self._traces.clear()
        for trace_name in parlist[::2]:
            trace_num = self.select_trace_by_name(trace_name)
            pna_trace = PNATrace(self, f""tr{trace_num}"",
                                 trace_name, trace_num)
            self._traces.append(pna_trace)

        # Restore the active trace if there was one
        if active_trace:
            self.active_trace(active_trace)

        # Return the list of traces on the instrument
        return self._traces

    def get_options(self) -> Sequence[str]:
        # Query the instrument for what options are installed
        return self.ask('*OPT?').strip('""').split(',')

    def get_trace_catalog(self) -> str:
        """"""
        Get the trace catalog, that is a list of trace and sweep types
        from the PNA.

        The format of the returned trace is:
            trace_name,trace_type,trace_name,trace_type...
        """"""
        return self.ask(""CALC:PAR:CAT:EXT?"").strip('""')

    def select_trace_by_name(self, trace_name: str) -> int:
        """"""
        Select a trace on the PNA by name.

        Returns:
            The trace number of the selected trace
        """"""
        self.write(f""CALC:PAR:SEL '{trace_name}'"")
        return self.active_trace()

    def reset_averages(self) -> None:
        """"""
        Reset averaging
        """"""
        self.write(""SENS:AVER:CLE"")

    def averages_on(self) -> None:
        """"""
        Turn on trace averaging
        """"""
        self.averages_enabled(True)

    def averages_off(self) -> None:
        """"""
        Turn off trace averaging
        """"""
        self.averages_enabled(False)

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.power.vals = Numbers(min_value=min_power,
                                  max_value=max_power)
        for port in self.ports:
            port._set_power_limits(min_power, max_power)


class PNAxBase(PNABase):
    def _enable_fom(self) -> None:
        '''
        PNA-x units with two sources have an enormous list of functions &
        configurations. In practice, most of this will be set up manually on
        the unit, with power and frequency varied in a sweep.
        '''
        self.add_parameter('aux_frequency',
                           label='Aux Frequency',
                           get_cmd='SENS:FOM:RANG4:FREQ:CW?',
                           get_parser=float,
                           set_cmd='SENS:FOM:RANG4:FREQ:CW {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=self.min_freq,
                                        max_value=self.max_freq))
"
65,https://www.keysight.com/us/en/assets/9018-40537/user-manuals/9018-40537.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'atthgLOInyyT7kYQx'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VMSv644CSra7Dxd2GdMXVA/09czrAx3MIIHEwwRj4gc2ah4umIJcuH9aRFP8xz7_JGQjmgPqyyI88tC9PsO_SsevSJyPkhPhfYCDsIVgwoRtbqSpWOT8zbi93yVr5tlnuM/F6Zaa46yG12b6Y7WFh96c_y4z8cZp_bjCU0hLnkHv9c'), ('filename', 'HP8753.webp'), ('size', 9110), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PAZ4O9DMPTHHAp_f6xYqpA/stmFM-2uY9jj8ibJZaJ4NEAGe0UbM8-hYpm9MPsabHLtXH16_pVtbSmieZSCktjlK_kzLaxK3h9OWeIYnKq7q6HZX6IU33-X8dOSxHAIZnw/0D4m9TPMAwtOGodmiCWT2HRJcWbxUEAhfTxhXYObINQ'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-4qCTLugpxsJwTmy6Xhxbw/isJxefQPCnJXgKjJT1wV47omDeh2ZwPNr53U3pT79U33TdLmbetn4BvVlA6JP5zn2mb4QxTZ_pycpQhBG5G9wxG8gUWKD0BvRHZjmkKyDKk/SMEnBhu1ZJoDO60Ps5ZK3uhY4dNdq_r6QannAJUxcLI'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tknbEsW74MPdEM0iKWTKnQ/XMzp-q0HhMYuIYcHr2xBPo2KywiR8fnJm7meNlAN3X1EX3q7ym_hP0REQME1jFsy9hwsqI_KCPOylO2bLQk21a2l5u2rQApZGkflHxd52so/xNdRf48ScK_e-aJa52R8hdqi6a6UQEL_BTXWCjSbP4w'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116715/Instruments/Vendor%20Logos/HP.png,"8753D Network Analyzer, 30 kHz to 3 GHz",https://www.keysight.com/us/en/product/8753D/network-analyzer-30-khz-to-3-ghz.html,HP 8753 D,174.0,['Network Analyzer'],A network analyzer is an instrument that measures the network parameters of electrical networks.,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/HP/HP_8753D.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/HP.html#qcodes.instrument_drivers.HP.HP8753D,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KLdW4e0aCMvuXtiF41lm5Q/tsULR905frVMXXpSBwX--GGG9pd67YfJfVqUbiphB7yi1YiZaesAKIc0H5OSMeujmzTnzL_TYJFKsYOLX2M-HuYgDDy464YMgOwWmAd540U/CQIhv7AHEyD7_1uuRrDXD-cM5HYvTXSunU9vcixsAug'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hlmdofa38jYloahcVSLpNw/3p9k2-zlW4PdZXOINyi5WevKuox8MEkgKxpfU8qhRNpuf6uCOaEc-SiDI8AOTUAw7YWp8NRCdU2dgc1P7EdU6HAyjmQbiEO3Hp3vcYlrIOY/Q6c584Zg-Ge5NIW7DvdQ-5bvCuyqJrmDmg6PDWARSL4'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dR-u6vcQ_qWkh_hzfJEdxQ/CqsqK2EnfYs5VLISQZ0OFYxQu_f9UQE_4pV_CakymtxZEGedpRn5KZvpsUnaybslmwwnrzvwiTZYPMP4emI5NC_nZxdGIx1ebsyYeKzRvnI/_oVf9TubhrO_RGOizCZPQfUHwNRQejxeIB_SREKXPHo'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SUaU78ZSlXE2XNRXeJAbJA/6bdGaHs7U5UbkXguW0uCC_jxHbNmi66L6y9XdaPyQYZhXOjcQsnb5Vx_VObVUE-pJ0UAWtZ88P0_zZN1TD3orExVUQe-wN3ukqEB7ShXXFw/tZAWl3xpv2JxN3HZABBPT7KYR938lcxPG87n9cnzOC0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782476/Instruments/Network%20Analyzer/Keysight-8753D/Keysight-8753D.webp,Keysight 8753D,Write a Python script that uses Qcodes to connect to a Keysight 8753D Network Analyzer,,,True,,"import logging
from functools import partial
from typing import Any, Union

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import ArrayParameter, ParamRawDataType

log = logging.getLogger(__name__)

_unit_map = {
    ""Log mag"": ""dB"",
    ""Phase"": ""degree"",
    ""Delay"": """",
    ""Smith chart"": ""dim. less"",
    ""Polar"": ""dim. less"",
    ""Lin mag"": ""dim. less"",
    ""Real"": """",
    ""Imaginary"": """",
    ""SWR"": ""dim. less"",
}


def HPIntParser(value: str) -> int:
    """"""
    Small custom parser for ints

    Args:
        value: the VISA return string using exponential notation
    """"""
    return int(float(value))


class TraceNotReady(Exception):
    pass


class HP8753DTrace(ArrayParameter):
    """"""
    Class to hold a trace from the HP8753D

    Although the trace can have two values per frequency, this
    class only returns the first value
    """"""

    def __init__(self, name: str, instrument: ""HP8753D""):
        super().__init__(
            name=name,
            shape=(1,),  # is overwritten by prepare_trace
            label="""",  # is overwritten by prepare_trace
            unit="""",  # is overwritten by prepare_trace
            setpoint_names=(""Frequency"",),
            setpoint_labels=(""Frequency"",),
            setpoint_units=(""Hz"",),
            snapshot_get=False,
            instrument=instrument,
        )

    def prepare_trace(self) -> None:
        """"""
        Update setpoints, units and labels
        """"""

        # we don't trust users to keep their fingers off the front panel,
        # so we query the instrument for all values
        assert isinstance(self.instrument, HP8753D)
        fstart = self.instrument.start_freq()
        fstop = self.instrument.stop_freq()
        npts = self.instrument.trace_points()

        sps = np.linspace(fstart, fstop, npts)
        self.setpoints = (tuple(sps),)
        self.shape = (len(sps),)

        self.label = self.instrument.s_parameter()
        self.unit = _unit_map[self.instrument.display_format()]

        self.instrument._traceready = True

    def get_raw(self) -> ParamRawDataType:
        """"""
        Return the trace
        """"""

        inst = self.instrument
        assert isinstance(inst, HP8753D)
        if not inst._traceready:
            raise TraceNotReady(""Trace not ready. Please run prepare_trace."")

        inst.write(""FORM2"")  # 32-bit floating point numbers
        inst.write(""OUTPFORM"")
        inst.visa_handle.read_termination = """"
        raw_resp = inst.visa_handle.read_raw()
        inst.visa_handle.read_termination = ""\n""

        first_points = b""""
        # 4 bytes header, 4 bytes per point, value1's and value2's
        # are intertwined like: val1_001, val2_001, val1_002, val2_002...
        for n in range((len(raw_resp) - 4) // 4):
            first_points += raw_resp[4:][2 * n * 4 : (2 * n + 1) * 4]

        dt = np.dtype("">f"")
        trace1 = np.frombuffer(first_points, dtype=dt)

        return trace1


class HP8753D(VisaInstrument):
    """"""
    QCoDeS driver for the Hewlett Packard 8753D Network Analyzer.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_parameter(
            ""start_freq"",
            label=""Sweep start frequency"",
            unit=""Hz"",
            set_cmd=partial(self.invalidate_trace, ""STAR {} HZ""),
            get_cmd=""STAR?"",
            get_parser=float,
            vals=vals.Numbers(30000, 6000000000),
        )

        self.add_parameter(
            ""stop_freq"",
            label=""Sweep stop frequency"",
            unit=""Hz"",
            set_cmd=partial(self.invalidate_trace, ""STOP {} HZ""),
            get_cmd=""STOP?"",
            get_parser=float,
            vals=vals.Numbers(30000, 6000000000),
        )

        self.add_parameter(
            ""averaging"",
            label=""Averaging state"",
            set_cmd=""AVERO{}"",
            get_cmd=""AVERO?"",
            val_mapping={""ON"": 1, ""OFF"": 0},
        )

        self.add_parameter(
            ""number_of_averages"",
            label=""Number of averages"",
            set_cmd=""AVERFACT{}"",
            get_cmd=""AVERFACT?"",
            get_parser=HPIntParser,
            vals=vals.Ints(0, 999),
        )

        self.add_parameter(
            ""trace_points"",
            label=""Number of points in trace"",
            set_cmd=partial(self.invalidate_trace, ""POIN{}""),
            get_cmd=""POIN?"",
            get_parser=HPIntParser,
            vals=vals.Enum(3, 11, 26, 51, 101, 201, 401, 801, 1601),
        )

        self.add_parameter(
            ""sweep_time"",
            label=""Sweep time"",
            set_cmd=""SWET{}"",
            get_cmd=""SWET?"",
            unit=""s"",
            get_parser=float,
            vals=vals.Numbers(0.01, 86400),
        )

        self.add_parameter(
            ""output_power"",
            label=""Output power"",
            unit=""dBm"",
            set_cmd=""POWE{}"",
            get_cmd=""POWE?"",
            get_parser=float,
            vals=vals.Numbers(-85, 20),
        )

        self.add_parameter(
            ""s_parameter"",
            label=""S-parameter"",
            set_cmd=self._s_parameter_setter,
            get_cmd=self._s_parameter_getter,
        )

        # DISPLAY / Y SCALE PARAMETERS
        self.add_parameter(
            ""display_format"",
            label=""Display format"",
            set_cmd=self._display_format_setter,
            get_cmd=self._display_format_getter,
        )

        # TODO: update this on startup and via display format
        self.add_parameter(
            ""display_reference"",
            label=""Display reference level"",
            unit=None,  # will be set by display_format
            get_cmd=""REFV?"",
            set_cmd=""REFV{}"",
            get_parser=float,
            vals=vals.Numbers(-500, 500),
        )

        self.add_parameter(
            ""display_scale"",
            label=""Display scale"",
            unit=None,  # will be set by display_format
            get_cmd=""SCAL?"",
            set_cmd=""SCAL{}"",
            get_parser=float,
            vals=vals.Numbers(-500, 500),
        )

        self.add_parameter(name=""trace"", parameter_class=HP8753DTrace)

        # Startup
        self.startup()
        self.connect_message()

    def reset(self) -> None:
        """"""
        Resets the instrument to factory default state
        """"""
        # use OPC to make sure we wait for operation to finish
        self.ask(""OPC?;PRES"")

    def run_continously(self) -> None:
        """"""
        Set the instrument in run continously mode
        """"""
        self.write(""CONT"")

    def run_N_times(self, N: int) -> None:
        """"""
        Run N sweeps and then hold. We wait for a response before returning
        """"""

        st = self.sweep_time.get_latest()

        if N not in range(1, 1000):
            raise ValueError(
                f""Can not run {N} times."" + "" please select a number from 1-999.""
            )

        # set a longer timeout, to not timeout during the sweep
        new_timeout = st * N + 2

        with self.timeout.set_to(new_timeout):
            log.debug(
                f""Making {N} blocking sweeps.""
                + f"" Setting VISA timeout to {new_timeout} s.""
            )

            self.ask(f""OPC?;NUMG{N}"")

    def invalidate_trace(self, cmd: str, value: Union[float, int, str]) -> None:
        """"""
        Wrapper for set_cmds that make the trace not ready
        """"""
        self._traceready = False
        self.write(cmd.format(value))

    def startup(self) -> None:
        self._traceready = False
        self.display_format(self.display_format())

    def _s_parameter_setter(self, param: str) -> None:
        """"""
        set_cmd for the s_parameter parameter
        """"""
        if param not in [""S11"", ""S12"", ""S21"", ""S22""]:
            raise ValueError(""Cannot set s-parameter to {}"")

        # the trace labels changes
        self._traceready = False

        self.write(param)

    def _s_parameter_getter(self) -> str:
        """"""
        get_cmd for the s_parameter parameter
        """"""
        cmd = """"
        for cmd in [""S11?"", ""S12?"", ""S21?"", ""S22?""]:
            resp = self.ask(cmd)
            if resp in [""1"", ""1\n""]:
                break

        return cmd.replace(""?"", """")

    def _display_format_setter(self, fmt: str) -> None:
        """"""
        set_cmd for the display_format parameter
        """"""
        val_mapping = {
            ""Log mag"": ""LOGM"",
            ""Phase"": ""PHAS"",
            ""Delay"": ""DELA"",
            ""Smith chart"": ""SMIC"",
            ""Polar"": ""POLA"",
            ""Lin mag"": ""LINM"",
            ""Real"": ""REAL"",
            ""Imaginary"": ""IMAG"",
            ""SWR"": ""SWR"",
        }

        if fmt not in val_mapping.keys():
            raise ValueError(f""Cannot set display_format to {fmt}."")

        self._traceready = False
        self.display_reference.unit = _unit_map[fmt]
        self.display_scale.unit = _unit_map[fmt]

        self.write(val_mapping[fmt])

    def _display_format_getter(self) -> str:
        """"""
        get_cmd for the display_format parameter
        """"""
        val_mapping = {
            ""LOGM"": ""Log mag"",
            ""PHAS"": ""Phase"",
            ""DELA"": ""Delay"",
            ""SMIC"": ""Smith chart"",
            ""POLA"": ""Polar"",
            ""LINM"": ""Lin mag"",
            ""REAL"": ""Real"",
            ""IMAG"": ""Imaginary"",
            ""SWR"": ""SWR"",
        }

        cmd = """"
        # keep asking until we find the currently used format
        for cmd in val_mapping.keys():
            resp = self.ask(f""{cmd}?"")
            if resp in [""1"", ""1\n""]:
                break

        return val_mapping[cmd]
"
67,https://www.farnell.com/datasheets/2619879.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attka6V7nbvKPV5eZ'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PMPyNZ22udwUydSluVVo0A/Vc7h4yWr_pTMqef3D_ELdWn7C6U3FBWBCi5yY0PL9b8Yu21gd2gXzWYNajet5cKfmMtUb4aqRt94Ix7fIMraXq5EBdpLKJAtBqpHH5gbOFk/DkkjOKnzC3veUZRyaj__uzKOFtWW92VINi-o5dmziwU'), ('filename', '2635b.webp'), ('size', 5770), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9b0HJSPffisuT0rVOxF1vQ/9CUv_rlf_-NKaytNDMNAnvuW4KxJTTo4WarldZ8nRONs2uhKS-wMZ2o_Yg8gy2CzLpTE-Ehm3i3ZQjGdrz7SiqmUwQeY-2W2wU4iFQyUUc4/CPVGuyn7sF-TTZoJVx62b3vrpChwL_9FrTzaU9lN1H0'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6zK4ua2I2hoGRScEfeQOww/VJbBxY3e6yk2uXA64zPGYBNTMd2jeDfpg9Ohgz2d3is2eZO66I1gOSchsvMw8s_v40gy6viXeylpm8FuYmUcq0oU4orx_FiyIkJ9AzvHZfo/WnytcacZVv_9BtrYeyWsnTVv7CCsU-4etJDbK1Ne1Ac'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zi00LZfntOVc1nDfrBz_9A/fJpO4Ccd-WxjJDPaF3tmRJHuaPDMSid5V9OcnGhPjJnpzGb5g9r2sOKK1NXzvUKlYOrLRE4x1zdB-hnVd4tsY9mVby76iIue1i5qSwwcZSw/ZxzPnf754Vb8d8AoHmr6-OSOGYutzqFs1w1sLjG5ABk'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2635B SourceMeter SMU instrument, is a new and improved one-channel SMU instrument with a tightly integrated four-quadrant design that allows it to simultaneously source and measure both voltage and current to boost productivity in applications ranging from R&D to automated production test. The wide range of 1.5A DC, 10A pulse, 200V output and 0.1fA measurement resolution makes it ideal to test a wide range of lower current devices and materials. In addition to retaining all the features of the Model 2635A, the Model 2635B has 6½-digit resolution, USB 2.0 connectivity, and software command emulation of the Model 2400 SourceMeter SMU Instrument to enable easy migration of legacy test code. The Model 2635B is equipped with Keithley's high speed TSP technology (over 190% faster than traditional PC-to-instrument communication techniques,) which dramatically improves the system-level speed to lower the cost of test.",https://canada.newark.com/keithley/2635b/source-meter-voltage-current-30/dp/44W8040,Keithley 2635 B,266.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2635B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782477/Instruments/Power%20Supplies/Keithley-2635B/Keithley-2635B.webp,Keithley 2635B,Write a Python script that uses Qcodes to connect to a Keithley 2635B Power Supplies,22379.0,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
73,https://www.farnell.com/datasheets/2607096.pdf?_ga=2.134065926.922366921.1579493884-611634051.1579231713,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attptYwWAOrQzTAZz'), ('width', 320), ('height', 169), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BRpWg3UuuwlQCIvt_0ohtA/UOBuHxuvCpVSpyZ_yc5U6gLE1j2qxbFTKd8o_yoSMQvPF3mHmsWAhaxmlVh22P-6Vme9DviQ59axG5Fj8ONn8hHu4MD80TDsfkLBe3jwDpk/6LkzTz2QKov2ylXSjVuqLOU3BUv5ELZkeJffvsgCcN4'), ('filename', '6500.webp'), ('size', 7262), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hBu4VLkqG3G3MfOudtPMdg/FDEdx3gEuRbGLMLtYJ4TVewqmI6hSJLNDHjAZbhz2aamAKK288IWZQUZpoZl6P3tJqZJs4w-ehbLaRK9TWeBQqII8IbxqpgKOdk-yqjdHWQ/WHs_q_tV1M7NfR_1bXvcAB93ufveThQ3RAyrLpNQY9w'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i_xY0EZqJGdJ-Jybl6JFIA/3JOy7rI6dho5CJzo5Hps9ORPMlF9PayogHOUIy6Pvfwhx6jbvuwW__M_UKXpm54yz2ipbgoVUDkrkYMQNFYQGUQw6HrZbK6TCOV-FcBtvQQ/YiUv8f4guVQSU4dD4uBpKxMKv3HCJ40vIbKXMcM8J6I'), ('width', 320), ('height', 169)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dvVWwjTjACYKTT2HUfZSqA/0ydIK-IaVqnH9T62f4STQ3GuipRG1SozJO0IhFHUOp9kACGVmGaZYCtNJJfLDJZopGOeOtuFefHNodbXtxVYwFWPTHYE3i-rxbpuQogyA1Y/zkEXMwUUWS-eNAklOQv6glG4sMe8RYb6JTMQPgBokUY'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"6½ digit bench/system digital multimeter with large 5"" (12.7cm) multi touch capacitive touchscreen and graphical display. It supports SCPI, TSP® scripting, Keithley 2000 SCPI emulation and Keysight 34401A SCPI emulation language modes.",https://www.tek.com/en/products/keithley/digital-multimeter/dmm6500,Keithley 6500,211.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_6500.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley6500,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782483/Instruments/Multimeters/DMM6500-Keithley/DMM6500-Keithley.webp,DMM6500 Keithley,Write a Python script that uses Qcodes to connect to a DMM6500 Keithley Multimeters,2160.0,,,,"from functools import partial
from typing import Any, Callable, TypeVar, Union

from qcodes.instrument import VisaInstrument
from qcodes.validators import Bool, Enum, Ints, MultiType, Numbers

T = TypeVar(""T"")


def _parse_output_string(string_value: str) -> str:
    """"""Parses and cleans string output of the multimeter. Removes the surrounding
        whitespace, newline characters and quotes from the parsed data. Some results
        are converted for readablitity (e.g. mov changes to moving).

    Args:
        string_value: The data returned from the multimeter reading commands.

    Returns:
        The cleaned-up output of the multimeter.
    """"""
    s = string_value.strip().lower()
    if (s[0] == s[-1]) and s.startswith((""'"", '""')):
        s = s[1:-1]

    conversions = {""mov"": ""moving"", ""rep"": ""repeat""}
    if s in conversions.keys():
        s = conversions[s]
    return s


def _parse_output_bool(numeric_value: Union[float, str]) -> bool:
    """"""Parses and converts the value to boolean type. True is 1.

    Args:
        numeric_value: The numerical value to convert.

    Returns:
        The boolean representation of the numeric value.
    """"""
    return bool(numeric_value)


class Keithley6500CommandSetError(Exception):
    pass


class Keithley6500(VisaInstrument):
    def __init__(
        self, name: str, address: str, reset_device: bool = False, **kwargs: Any
    ):
        """"""Driver for the Keithley 6500 multimeter. Based on the Keithley 2000 driver,
            commands have been adapted for the Keithley 6500. This driver does not contain
            all commands available, but only the ones most commonly used.

            Status: beta-version.

        Args:
            name (str): The name used internally by QCoDeS in the DataSet.
            address (str): The VISA device address.
            reset_device (bool): Reset the device on startup if true.
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        command_set = self.ask(""*LANG?"")
        if command_set != ""SCPI"":
            error_msg = (
                ""This driver only compatible with the 'SCPI' command ""
                ""set, not '{}' set"".format(command_set)
            )
            raise Keithley6500CommandSetError(error_msg)

        self._trigger_sent = False

        self._mode_map = {
            ""ac current"": ""CURR:AC"",
            ""dc current"": ""CURR:DC"",
            ""ac voltage"": ""VOLT:AC"",
            ""dc voltage"": ""VOLT:DC"",
            ""2w resistance"": ""RES"",
            ""4w resistance"": ""FRES"",
            ""temperature"": ""TEMP"",
            ""frequency"": ""FREQ"",
        }

        self.add_parameter(
            ""mode"",
            get_cmd=""SENS:FUNC?"",
            set_cmd=""SENS:FUNC '{}'"",
            val_mapping=self._mode_map,
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=partial(self._get_mode_param, ""NPLC"", float),
            set_cmd=partial(self._set_mode_param, ""NPLC""),
            vals=Numbers(min_value=0.01, max_value=10),
        )

        #  TODO: validator, this one is more difficult since different modes
        #  require different validation ranges.
        self.add_parameter(
            ""range"",
            get_cmd=partial(self._get_mode_param, ""RANG"", float),
            set_cmd=partial(self._set_mode_param, ""RANG""),
            vals=Numbers(),
        )

        self.add_parameter(
            ""auto_range_enabled"",
            get_cmd=partial(self._get_mode_param, ""RANG:AUTO"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""RANG:AUTO""),
            vals=Bool(),
        )

        self.add_parameter(
            ""digits"",
            get_cmd=""DISP:VOLT:DC:DIG?"",
            get_parser=int,
            set_cmd=""DISP:VOLT:DC:DIG? {}"",
            vals=Ints(min_value=4, max_value=7),
        )

        self.add_parameter(
            ""averaging_type"",
            get_cmd=partial(self._get_mode_param, ""AVER:TCON"", _parse_output_string),
            set_cmd=partial(self._set_mode_param, ""AVER:TCON""),
            vals=Enum(""moving"", ""repeat""),
        )

        self.add_parameter(
            ""averaging_count"",
            get_cmd=partial(self._get_mode_param, ""AVER:COUN"", int),
            set_cmd=partial(self._set_mode_param, ""AVER:COUN""),
            vals=Ints(min_value=1, max_value=100),
        )

        self.add_parameter(
            ""averaging_enabled"",
            get_cmd=partial(self._get_mode_param, ""AVER:STAT"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""AVER:STAT""),
            vals=Bool(),
        )

        # Global parameters
        self.add_parameter(
            ""display_backlight"",
            docstring=""Control the brightness of the display ""
            ""backligt. Off turns the display off and""
            ""Blackout also turns off indicators and ""
            ""key lights on the device."",
            get_cmd=""DISP:LIGH:STAT?"",
            set_cmd=""DISP:LIGH:STAT {}"",
            val_mapping={
                ""On 100"": ""ON100"",
                ""On 75"": ""ON75"",
                ""On 50"": ""ON50"",
                ""On 25"": ""ON25"",
                ""Off"": ""OFF"",
                ""Blackout"": ""BLACkout"",
            },
        )

        self.add_parameter(
            ""trigger_count"",
            get_parser=int,
            get_cmd=""ROUT:SCAN:COUN:SCAN?"",
            set_cmd=""ROUT:SCAN:COUN:SCAN {}"",
            vals=MultiType(
                Ints(min_value=1, max_value=9999),
                Enum(""inf"", ""default"", ""minimum"", ""maximum""),
            ),
        )

        for trigger in range(1, 5):
            self.add_parameter(
                ""trigger%i_delay"" % trigger,
                docstring=""Set and read trigger delay for "" ""timer %i."" % trigger,
                get_parser=float,
                get_cmd=""TRIG:TIM%i:DEL?"" % trigger,
                set_cmd=""TRIG:TIM%i:DEL {}"" % trigger,
                unit=""s"",
                vals=Numbers(min_value=0, max_value=999999.999),
            )

            self.add_parameter(
                ""trigger%i_source"" % trigger,
                docstring=""Set the trigger source for "" ""timer %i."" % trigger,
                get_cmd=""TRIG:TIM%i:STAR:STIM?"" % trigger,
                set_cmd=""TRIG:TIM%i:STAR:STIM {}"" % trigger,
                val_mapping={
                    ""immediate"": ""NONE"",
                    ""timer1"": ""TIM1"",
                    ""timer2"": ""TIM2"",
                    ""timer3"": ""TIM3"",
                    ""timer4"": ""TIM4"",
                    ""notify1"": ""NOT1"",
                    ""notify2"": ""NOT2"",
                    ""notify3"": ""NOT3"",
                    ""front-panel"": ""DISP"",
                    ""bus"": ""COMM"",
                    ""external"": ""EXT"",
                },
            )

        # Control interval between scans; the default value from the instrument is 0,
        # hence 0 is included in the validator's range of this parameter.
        self.add_parameter(
            ""trigger_timer"",
            get_parser=float,
            get_cmd=""ROUT:SCAN:INT?"",
            set_cmd=""ROUT:SCAN:INT {}"",
            unit=""s"",
            vals=Numbers(min_value=0, max_value=999999.999),
        )

        self.add_parameter(
            ""amplitude"", get_cmd=self._read_next_value, set_cmd=False, unit=""a.u.""
        )

        if reset_device:
            self.reset()
        self.write(""FORM:DATA ASCII"")
        self.connect_message()

    def reset(self) -> None:
        """"""Reset the device""""""
        self.write(""*RST"")

    def _read_next_value(self) -> float:
        return float(self.ask(""READ?""))

    def _get_mode_param(self, parameter: str, parser: Callable[[str], T]) -> T:
        """"""Reads the current mode of the multimeter and ask for the given parameter.

        Args:
            parameter: The asked parameter after getting the current mode.
            parser: A function that parses the input buffer read.

        Returns:
            Any: the parsed ask command. The parser determines the return data-type.
        """"""
        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter}?""
        return parser(self.ask(cmd))

    def _set_mode_param(self, parameter: str, value: Union[str, float, bool]) -> None:
        """"""Gets the current mode of the multimeter and sets the given parameter.

        Args:
            parameter: The set parameter after getting the current mode.
            value: Value to set
        """"""
        if isinstance(value, bool):
            value = int(value)

        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter} {value}""
        self.write(cmd)
"
75,https://download.tek.com/datasheet/MSO5000-DPO5000-Mixed-Signal-Oscilloscope-Datasheet-9.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attbSlGCqWoVTZaSj'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WZ06KM3AA4lTRh8os7w5jw/nEbIC5vTmA_fIh4t9MmzwtbhQ5s9-iUtBtmk2qzyD6hz7din0W4gxQmkZyujGh29ObI3HeE0XJeySj8upAgdMyyo-NqRH2ext9dHQ81FHkg/YUqfdZMayYOlCFLU9T4Pu_m-5hA4C0NayJcKS9wU5wQ'), ('filename', 'mso5000-front-view (1).webp'), ('size', 109264), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/30V-7j-q0PLxPDaNqOKTUA/USssyG-QBKgn_1uxYuQ29G2iIoOwqXMAr2cLNZxVjKvz9Jr7TGQ1R-Hds49Iz7lBkOzgMswER7VvTLfEyZn4gtC35iWbDiEK7q1KywIbAps/S-olXTdZf5FpB98UefgzBJD1-Ah-Yf9FcVjq_2v_FxU'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/H2V07cZBP_44D8-gB4eGhg/kMxqYncbMmxmdtqCw353_QIHULEmz8WMSo9vGizZTytCY7AiZTpL0PaYj8IKrATMW2AtESENr8pUqFHTLuReWT0Pg4GZBeIolmgz-4_J1mE/t8Hoaqh9iXsPjr7AIA3STunzOgLdAhgcDAsw_G-JTV0'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZEIoRLIL9xTvSh6Qemk7aw/bBkiPuMu32u_FTtuEO8OPW373Qf71c94wZm1WbImzCiKhs4W8n-dJKPp3477FJ4y3r9ktP9CPgxCa5TcJrn7Yn2jUuMvUfn2Kt7d1gnESqk/AnKEI00bpFAvVS3BblKoCJktDizSISoER8RuluX1-8I'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The MSO/DPO5000 Series offers the industry's most complete visualization of signals, providing fast insight into the real operation of your device. Tektronix proprietary FastAcq™ technology delivers a fast waveform capture – greater than 250,000 waveforms per second – that enables you to see glitches and other infrequent transients within seconds, revealing the true nature of device faults. A digital phosphor display with color intensity grading shows the history of a signal's activity by using color to identify areas of the signal that occur more frequently, providing a visual display of just how often anomalies occur.",https://www.tek.com/en/products/oscilloscopes/mso5000-dpo5000,Tektronix DPO 5000,570.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO5000,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782485/Instruments/Oscilloscopes/DPO5000/DPO5000.webp,DPO5000,Write a Python script that uses Qcodes to connect to a DPO5000 Oscilloscopes,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
82,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'attpAsShHG4lQXH7N'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QU6zIYi3Le7avNLk0dG9dg/zWbML2JDImbiG_SO3zIbc3VS4Fpxr8GdGb0eMWWec_yiIXtBZ-n_vhukhZaKcSXhtdl3_BszRv3IJCnryA5L51LVH0qxfPRkGlUevd_z-nU/D_xFwkiywOT1v3M5GAHskU4Wwt2nrUp0H84R5CEW070'), ('filename', 'PL068P-1000px.jpg'), ('size', 161046), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/s6KE-W4uuFrM8xWrHAoS0Q/PeLFYYZjUzBc5G3aCmNEj-lGZpvt_Qkcwf6tvPEpW0FmLk1aJj0xmjbuwyLVE-My5fmvhJvMlTi9pMRypwOLjg/UqL_yB3HB9KUIk5gFlo2rd4aCqR4x0BbQ0fUdlqVbFA'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GTY5P2UALSYe_uJ8eN3p6A/L_mlTBPFX7BRtFI20iSQ2FuQaPegNmMoYfl3vKYKUbM9Sg1lVKBRaSfgTkUY9t3uAJqsqqGJSQftESQz31tX1A/Nw8Ade3kIo0Eor9416VAavOkP2_8JjrptCdnD0yG_js'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FujvKl32sxvmEogi5D-5DQ/8u87JCdLrj14vj3O7on4kIXYFUw_9LMmWA_uKcg77SXUeina7PFkVGPPBdkdgOZJWZWTfFVZwGMP_o8v_TLjbw/if0eRH95ugajC2IBmSxmeHgxrA7Y-Qh4G915DtOtBu4'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Single Output, 6V/8A, USB, RS232, LAN(LXI) and Analogue interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 068 P,54.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL068P,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782490/Instruments/Power%20Supplies/PL068-P/PL068-P.jpg,PL068-P,Write a Python script that uses Qcodes to connect to a PL068-P Power Supplies,700.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
84,https://download.tek.com/datasheet/1KW-2798-4_2400_SourceMeter_SMU_Datasheet_061622.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attFCwQhJ4waLZGsg'), ('width', 327), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gOgqh65kftz2RwTvc9AS-w/7D-pyKhALIof6pOYCkW3o_lEcxg2d0nNUThSeT3KOMLXg-XFz_z_a8aHcSBy-lamVDlNoRlOaaYeSilHMUye2uxkH7oH1qJ5TpHaU7tEp9Q/6a_UdpEcLk_PdfewoWcG3-oE2cRh6pmFulqhIQW_sAU'), ('filename', '2400.webp'), ('size', 10742), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5k3Gl6Jja4LVWszQ93RiPA/GxxwFwKhHOCZEH_Ha6SXHhL2grwLypfRAGdx3S9FWhgfJ7QkdzbkR2-BcZavK99SY9ENu8d0kAb3vumvODZjEEQCDG3pAm4beVIzqP-yt8Q/OtaG27H4an1YZLtUdmXdpn48-xCxH2kUQoGObVFQmtI'), ('width', 38), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rXE1QagGx0y5sXqb38s7lw/bu5QlPb8O1HyyH1kgfzbECSVJTJZxSDryr3NdlwSDsVeGPzYrOEpZ24mapWM3nlkzz9qhIBzKJn6Ja1QnpFpMLuFEDnYglVpvhJeu526zVE/FTWyumSg4eU9LwJ1D28KQZPnjPm9XoG6Ivs1E8Aksz4'), ('width', 327), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9Lo6hrAhNhx_oPTDjaXiDg/qAUzhZ-2Xp5xwdd0LnSE1-geidubwCCfFiYhwbB0xgh281aoCeZgwQEGm6zxA6DOvIx9oN9-dZ2XYIVsC25HrkvnxE_kB6xksvMboU3xJas/7u0lVvMzO7pIF4ZAmDeWAlQ8hXEUmI7IXpzrXWxKQ6g'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"Keithley’s Standard Series 2400 Source Measure Unit (SMU) Instruments offer four-quadrant precision voltage and current source/load coupled with measurement. Each SMU instrument is both a highly stable DC power source and a true instrument-grade 6½-digit multimeter. The power source characteristics include low noise, precision, and readback. The multimeter capabilities include high repeatability and low noise.",https://www.tek.com/en/products/keithley/source-measure-units/2400-standard-series-sourcemeter,Keithley 2400,242.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2400.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2400,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782492/Instruments/Power%20Supplies/Keithley-2400/Keithley-2400.webp,Keithley 2400,Write a Python script that uses Qcodes to connect to a {Device name} Power Supplies,13000.0,,,,"from typing import Any

from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping
from qcodes.validators import Enum, Strings


class Keithley2400(VisaInstrument):
    """"""
    QCoDeS driver for the Keithley 2400 voltage source.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_parameter(
            ""rangev"",
            get_cmd=""SENS:VOLT:RANG?"",
            get_parser=float,
            set_cmd=""SOUR:VOLT:RANG {:f}"",
            label=""Voltage range"",
        )

        self.add_parameter(
            ""rangei"",
            get_cmd=""SENS:CURR:RANG?"",
            get_parser=float,
            set_cmd=""SOUR:CURR:RANG {:f}"",
            label=""Current range"",
        )

        self.add_parameter(
            ""compliancev"",
            get_cmd=""SENS:VOLT:PROT?"",
            get_parser=float,
            set_cmd=""SENS:VOLT:PROT {:f}"",
            label=""Voltage Compliance"",
        )

        self.add_parameter(
            ""compliancei"",
            get_cmd=""SENS:CURR:PROT?"",
            get_parser=float,
            set_cmd=""SENS:CURR:PROT {:f}"",
            label=""Current Compliance"",
        )

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._volt_parser,
            set_cmd="":SOUR:VOLT:LEV {:.8f}"",
            label=""Voltage"",
            unit=""V"",
            docstring=""Sets voltage in 'VOLT' mode. ""
            ""Get returns measured voltage if ""
            ""sensing 'VOLT' otherwise it returns ""
            ""setpoint value. ""
            ""Note that it is an error to read voltage with ""
            ""output off"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._curr_parser,
            set_cmd="":SOUR:CURR:LEV {:.8f}"",
            label=""Current"",
            unit=""A"",
            docstring=""Sets current in 'CURR' mode. ""
            ""Get returns measured current if ""
            ""sensing 'CURR' otherwise it returns ""
            ""setpoint value. ""
            ""Note that it is an error to read current with ""
            ""output off"",
        )

        self.add_parameter(
            ""mode"",
            vals=Enum(""VOLT"", ""CURR""),
            get_cmd="":SOUR:FUNC?"",
            set_cmd=self._set_mode_and_sense,
            label=""Mode"",
        )

        self.add_parameter(
            ""sense"",
            vals=Strings(),
            get_cmd="":SENS:FUNC?"",
            set_cmd=':SENS:FUNC ""{:s}""',
            label=""Sense mode"",
        )

        self.add_parameter(
            ""output"",
            set_cmd="":OUTP:STAT {}"",
            get_cmd="":OUTP:STAT?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""nplcv"",
            get_cmd=""SENS:VOLT:NPLC?"",
            get_parser=float,
            set_cmd=""SENS:VOLT:NPLC {:f}"",
            label=""Voltage integration time"",
        )

        self.add_parameter(
            ""nplci"",
            get_cmd=""SENS:CURR:NPLC?"",
            get_parser=float,
            set_cmd=""SENS:CURR:NPLC {:f}"",
            label=""Current integration time"",
        )

        self.add_parameter(
            ""resistance"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._resistance_parser,
            label=""Resistance"",
            unit=""Ohm"",
            docstring=""Measure resistance from current and voltage ""
            ""Note that it is an error to read current ""
            ""and voltage with output off"",
        )

        self.write("":TRIG:COUN 1;:FORM:ELEM VOLT,CURR"")
        # This line sends 2 commands to the instrument:
        # "":TRIG:COUN 1"" sets the trigger count to 1 so that each READ? returns
        # only 1 measurement result.
        # "":FORM:ELEM VOLT,CURR"" sets the output string formatting of the the
        # Keithley 2400 to return ""{voltage}, {current}"".
        # Default value on instrument reset is ""VOLT, CURR, RES, TIME, STATUS"";
        # however, resistance, status, and time are unused in this driver and
        # so are omitted.
        # These commands do not reset the instrument but do the minimal amount
        # to ensure that voltage and current parameters can be read from the
        # instrument, in the event that output formatting of the instrument was
        # previously changed to some other unknown state.
        self.connect_message()

    def _get_read_output_protected(self) -> str:
        """"""
        This wrapper function around "":READ?"" exists because calling
        "":READ?"" on an instrument with output disabled is an error.
        So first we check that output is on and if not we return
        nan for volt, curr etc.
        """"""
        output = self.output.get_latest()
        if output is None:
            # if get_latest returns None we have
            # to ask the instrument for the status of output
            output = self.output.get()

        if output == 1:
            msg = self.ask("":READ?"")
        else:
            raise RuntimeError(""Cannot perform read with output off"")
        return msg

    def _set_mode_and_sense(self, msg: str) -> None:
        # This helps set the correct read out curr/volt
        if msg == ""VOLT"":
            self.sense(""CURR"")
        elif msg == ""CURR"":
            self.sense(""VOLT"")
        else:
            raise AttributeError(""Mode does not exist"")
        self.write(f"":SOUR:FUNC {msg:s}"")

    def reset(self) -> None:
        """"""
        Reset the instrument. When the instrument is reset, it performs the
        following actions.

            Returns the SourceMeter to the GPIB default conditions.

            Cancels all pending commands.

            Cancels all previously send `*OPC` and `*OPC?`
        """"""
        self.write("":*RST"")

    def _volt_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        return fields[0]

    def _curr_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        return fields[1]

    def _resistance_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        res = fields[0] / fields[1]
        return res
"
85,,https://www.keysight.com/us/en/products/source-measure-units-smu.html,"[OrderedDict([('id', 'attYFiY8awycga5u9'), ('width', 1600), ('height', 1067), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tvhqWomyOfwjaHNUTO3HdA/BTViCx8jZmgNyCK7KFWh8uXiFDzFp4gmPf1Fnq07mEU53MQHc5fKRinULa4iJAYnmlUVYBmI5PYVidZ38eCHrCzGXs1DCerWC3Bu9PmgNkk/Fg5dJJ3-b5nt2qyGHz4QUaNfLK6Mk2HzfOZJPoqwZHs'), ('filename', 'PROD-3075050-01.png'), ('size', 1143931), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oE_3vuEF1lZsvjWtfKuQAQ/GUanQWhTXnaTNspZcVrV3NYUm1sOMOE5MlEvVHLkeuELq2l_7CbRXxRhoGZ4V9UlFb3Pr1YBlXfJLIiXh8icSg/OG0ngSaqgV8pQ5-WOYkanfqi8JZvdA1w8Aw81zUq3pM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Z4dAZTObazDtZpjXTt00xQ/0mVd-xeFbxo70xtycR2VLemIW4ktLLhWt4bhBvKy88sxlI3ZmR9om4KMciC4aguSx-UXy6a1rwQv5c0p2H4bTA/9bnijPunTELGmXW3nrrwckKryRgH9930ILLqUU8ayXQ'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bnqD-PDeoEcQ9-u8FIMi8w/NsbW-0VxkN7OgXKd7RoD61rNW0UdFAE8_NZKM5raO-qUhKfJNFmZBUxozrA1XQVIF3C3eJZclAuRfxQxhYg38w/k7wSHXTCJ-Ia_CLm9QfKUVQ1XF8JpRqCzFXW2-c1eLk'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"PXI source/measure units are the source and measurement resources of voltage and current for test applications requiring high accuracy, high resolution, and measurement flexibility

",https://www.keysight.com/us/en/products/source-measure-units-smu/pxi-source-measure-units.html,KTM 960 X,329.0,"['Power Meters', 'Power Supplies']","Keysight provides a wide range of source measure units (SMU) from precision, application-specific, general-purpose, to basic instruments. Keysight SMUs precisely force and simultaneously measure voltage and/or current.

","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtM960x.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightM960x,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782494/Instruments/Power%20Supplies/Keysight-M960XA-Series/Keysight-M960XA-Series.png,Keysight M960XA-Series,"Write a Python script that uses Qcodes to connect to a Keysight M960XA-Series Power Meters, Power Supplies",,,,,"import ctypes
from functools import partial
from typing import Any, Optional

import qcodes.validators as vals
from qcodes.instrument import Instrument
from qcodes.parameters import (
    MultiParameter,
    ParamRawDataType,
    create_on_off_val_mapping,
)

from .KtM960xDefs import *  # noqa F403


class Measure(MultiParameter):
    def __init__(self, name: str, instrument: ""KeysightM960x"") -> None:
        super().__init__(name=name,
                         names=(""voltage"", ""current"", ""resistance"", ""status"",
                                ""timestamp"", ""source""),
                         shapes=((), (), (), (), (), ()),
                         units=(""V"", ""A"", ""Ohm"", """", """", """"),
                         instrument=instrument,
                         labels=""Measurement Data"",
                         docstring=""param that returns measurement values"")
        self.instrument: ""KeysightM960x""

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        return self.instrument._measure()


class KeysightM960x(Instrument):
    """"""
    Provide a wrapper for the Keysight KtM960x DAC. This driver provides an
    interface into the IVI-C driver provided by Keysight. The .dll is installed
    by default into C:\\Program Files\\IVI Foundation\\IVI\\Bin\\KtM960x_64.dll
    but a different path can be supplied to the constructor
    """"""

    _default_buf_size = 256

    def __init__(self,
                 name: str,
                 address: str,
                 options: str = """",
                 dll_path: str = r""C:\Program Files\IVI ""
                                 r""Foundation\IVI\Bin\KtM960x_64.dll"",
                 **kwargs: Any) -> None:
        super().__init__(name, **kwargs)

        self._address = bytes(address, ""ascii"")
        self._options = bytes(options, ""ascii"")
        self._session = ctypes.c_int(0)
        self._dll_loc = dll_path
        self._dll = ctypes.cdll.LoadLibrary(self._dll_loc)

        self.add_parameter('output',
                           label=""Source Output Enable"",
                           get_cmd=partial(self._get_vi_bool,
                                           KTM960X_ATTR_OUTPUT_ENABLED),
                           set_cmd=partial(self._set_vi_bool,
                                           KTM960X_ATTR_OUTPUT_ENABLED),
                           val_mapping=create_on_off_val_mapping(on_val=True,
                                                                 off_val=False)
                           )

        self.add_parameter('voltage_level',
                           label=""Source Voltage Level"",
                           unit=""Volt"",
                           get_cmd=partial(self._get_vi_real64,
                                           KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL),
                           set_cmd=partial(self._set_vi_real64,
                                           KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL),
                           vals=vals.Numbers(-210, 210))

        self.add_parameter(""current_range"",
                           label=""Output Current Range"",
                           unit=""Amp"",
                           vals=vals.Numbers(1e-9, 300e-3),
                           get_cmd=partial(self._get_vi_real64,
                                           KTM960X_ATTR_OUTPUT_CURRENT_RANGE),
                           set_cmd=partial(self._set_vi_real64,
                                           KTM960X_ATTR_OUTPUT_CURRENT_RANGE)
                           )

        self.add_parameter(""measure_current_range"",
                           label=""Current Measurement Range"",
                           unit=""Amp"",
                           get_cmd=partial(
                               self._get_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE),
                           set_cmd=partial(
                               self._set_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE),
                           vals=vals.Numbers(1e-9, 300e-3),
                           )

        self.add_parameter(""measure_current_time"",
                           label=""Current Measurement Integration Time"",
                           unit=""Seconds"",
                           get_cmd=partial(
                               self._get_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE),
                           set_cmd=partial(
                               self._set_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE),
                           vals=vals.Numbers(800e-9, 2)
                           )

        self.add_parameter(""measure_data"",
                           parameter_class=Measure)

        self._get_driver_desc = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_DESCRIPTION)
        self._get_driver_prefix = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_PREFIX)
        self._get_driver_revision = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_REVISION)
        self._get_firmware_revision = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_FIRMWARE_REVISION)
        self._get_model = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_MODEL)
        self._get_serial_number = partial(
            self._get_vi_string, KTM960X_ATTR_MODULE_SERIAL_NUMBER)
        self._get_manufacturer = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_MANUFACTURER)

        self._connect()

        self.connect_message()

    def _connect(self) -> None:
        status = self._dll.KtM960x_InitWithOptions(self._address,
                                                   1,
                                                   1,
                                                   self._options,
                                                   ctypes.byref(self._session))
        if status:
            raise SystemError(f""connection to device failed! error: {status}"")

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""generates the ``*IDN`` dictionary for qcodes""""""

        id_dict: dict[str, Optional[str]] = {
            'firmware': self._get_firmware_revision(),
            'model': self._get_model(),
            'serial': self._get_serial_number(),
            'vendor': self._get_manufacturer(),
            'driver desc': self._get_driver_desc(),
            'driver prefix': self._get_driver_prefix(),
            'driver revision': self._get_driver_revision()
        }
        return id_dict

    def _measure(self) -> tuple[ParamRawDataType, ...]:

        # Setup the output
        self._set_vi_int(KTM960X_ATTR_OUTPUT_PRIORITY_MODE,
                         KTM960X_VAL_PRIORITY_MODE_VOLTAGE)
        self._set_vi_int(KTM960X_ATTR_OUTPUT_OPERATION_MODE,
                         KTM960X_VAL_OUTPUT_OPERATION_MODE_STANDARD)
        self._set_vi_int(KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE,
                         KTM960X_VAL_ACQUISITION_MODE_NORMAL)

        ch_num_buf = (ctypes.c_int32 * 1)()
        val_buf = (ctypes.c_double * 1024)()
        actual_size = ctypes.c_int32(0)
        ch_num_buf[0] = 1
        status = self._dll.KtM960x_MeasurementMeasure(
            self._session,
            KTM960X_VAL_MEASUREMENT_TYPE_ALL,
            1,
            ch_num_buf,
            1024,
            val_buf,
            ctypes.byref(actual_size)
        )

        if status:
            raise ValueError(f""Driver error: {status}"")
        # This might be a bit slow?
        # Returned as [voltage, current, resistance, status,
        #                                               timestamp, and source]
        v = list(val_buf)[0:actual_size.value]

        # 'voltage': v[0], 'current': v[1], 'resistance': v[2], 'status': v[3],
        # 'timestamp': v[4], 'source': v[5]
        return v[0], v[1], v[2], v[3], v[4], v[5]

    # Query the driver for errors
    def get_errors(self) -> dict[int, str]:
        error_code = ctypes.c_int(-1)
        error_message = ctypes.create_string_buffer(256)
        error_dict = dict()
        while error_code.value != 0:
            status = self._dll.KtM960x_error_query(
                self._session, ctypes.byref(error_code), error_message)
            assert(status == 0)
            error_dict[error_code.value] = error_message.value.decode('utf-8')

        return error_dict

    # Generic functions for reading/writing different attributes
    def _get_vi_string(self, attr: int) -> str:
        s = ctypes.create_string_buffer(self._default_buf_size)
        status = self._dll.KtM960x_GetAttributeViString(self._session,
                                                        b"""",
                                                        attr,
                                                        self._default_buf_size,
                                                        s)
        if status:
            raise ValueError(f""Driver error: {status}"")
        return s.value.decode('utf-8')

    def _get_vi_bool(self, attr: int) -> bool:
        s = ctypes.c_uint16(0)
        status = self._dll.KtM960x_GetAttributeViBoolean(self._session, b"""",
                                                         attr, ctypes.byref(s))
        if status:
            raise ValueError(f""Driver error: {status}"")
        return bool(s)

    def _set_vi_bool(self, attr: int, value: bool) -> None:
        v = ctypes.c_uint16(1) if value else ctypes.c_uint16(0)
        status = self._dll.KtM960x_SetAttributeViBoolean(self._session, b"""",
                                                         attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_real64(self, attr: int) -> float:
        s = ctypes.c_double(0)
        status = self._dll.KtM960x_GetAttributeViReal64(self._session, b"""",
                                                        attr, ctypes.byref(s))

        if status:
            raise ValueError(f""Driver error: {status}"")
        return float(s.value)

    def _set_vi_real64(self, attr: int, value: float) -> None:
        v = ctypes.c_double(value)
        status = self._dll.KtM960x_SetAttributeViReal64(self._session, b"""",
                                                        attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _set_vi_int(self, attr: int, value: int) -> None:
        v = ctypes.c_int32(value)
        status = self._dll.KtM960x_SetAttributeViInt32(self._session, b"""",
                                                       attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_int(self, attr: int) -> int:
        v = ctypes.c_int32(0)
        status = self._dll.KtM960x_GetAttributeViInt32(self._session, b"""",
                                                       attr, ctypes.byref(v))
        if status:
            raise ValueError(f""Driver error: {status}"")
        return int(v.value)

    def close(self) -> None:
        self._dll.KtM960x_close(self._session)
        super().close()


KtM960x = KeysightM960x
""Alias for backwards compatibility""
"
86,https://www.keysight.com/us/en/assets/7018-05093/data-sheets/5992-1317.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attaE3LeIhFoN0BuG'), ('width', 500), ('height', 242), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qZIcrVjkYt1Jfdg16ckg7Q/Q3n6L0YDv8MBdMxbXJjrBLkHtaVfphonFnQViD2vWSMuW8lgQC9qvsSgw7vpWk9OVdn6HknKqIn754jL4pMyE7K-dCaHOWu5ci-ft0B6mDs/H5AgEVNqpgNNKERD5wujyBA1H_I-7M5-7dthHgC8tkI'), ('filename', 'N9030B.2.jpg'), ('size', 27618), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VySNY7_Q48TgaXr_6zzEXw/LrnAp-hN43mDEOzdw_EP34CjkJuDZk8VVLq7xBIVPtN4imh7_uqLMqBtSvFBHFfjh6sALgUYtfaRrI7Ej4khOA/6P29jHh_0TVlKqMiJoOFiuIiBuTiJmzw09VvzF4YM3A'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DP9-kwTj4a_rO8ueQveZGg/YGTe5ZOaoun7aLc4IxXWwbRf5Y-GtL2zi1MNzaAkzqN72XdL0WwiiQbME1Wvgb8kCSelktgOkJTJ2VkihRw7XA/pTkJWd4eC93EZQb4kY8C747IBraFt-byHePEzgiMNzA'), ('width', 500), ('height', 242)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6mRxdwq_LSb_k-5ZBXGbsQ/scRrQ7pdI6UnbZqU6LywOi0V4tO603zxm0SsVr2WnUHtLshVBGri9KLCNKNGSW9Gdsn9_1LidOhSTw-P8yddXQ/A_pPVKRy0xmP5kdYZWhg3t-m67Guolh-T46H23boX0g'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"PXA signal analyzers are ideally suited for high-performance research and development (R&D) applications in aerospace/defense and commercial wireless communications. The PXA analyzes signals over wider bandwidths, reduces measurement uncertainty, and reveals previously hidden signals with noise floor extension (NFE). Unravel complex signals through the PXA’s broad set of measurement applications and demodulation capabilities or add real-time spectrum analysis capabilities with an upgradeable option.",https://www.keysight.com/us/en/product/N9030B/pxa-signal-analyzer-multi-touch-2-hz-50-ghz.html,Keysight N 9030 B,282.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_N9030B.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN9030B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782495/Instruments/RF%20Signal%20Generator/Keysight-N9030B-PXA/Keysight-N9030B-PXA.jpg,Keysight N9030B PXA,Write a Python script that uses Qcodes to connect to a Keysight N9030B PXA RF Signal Generator,,,,,"from __future__ import annotations

from typing import Any

import numpy as np

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Numbers


class FrequencyAxis(Parameter):
    def __init__(
        self,
        start: Parameter,
        stop: Parameter,
        npts: Parameter,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        super().__init__(*args, **kwargs)
        self._start: Parameter = start
        self._stop: Parameter = stop
        self._npts: Parameter = npts

    def get_raw(self) -> ParamRawDataType:
        start_val = self._start()
        stop_val = self._stop()
        npts_val = self._npts()
        assert start_val is not None
        assert stop_val is not None
        assert npts_val is not None
        return np.linspace(start_val, stop_val, npts_val)


class Trace(ParameterWithSetpoints):
    def __init__(self, number: int, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.instrument: (
            KeysightN9030BSpectrumAnalyzerMode | KeysightN9030BPhaseNoiseMode
        )
        self.root_instrument: KeysightN9030B

        self.number = number

    def get_raw(self) -> ParamRawDataType:
        return self.instrument._get_data(trace_num=self.number)


class KeysightN9030BSpectrumAnalyzerMode(InstrumentChannel):
    """"""
    Spectrum Analyzer Mode for Keysight N9030B instrument.
    """"""

    def __init__(self, parent: KeysightN9030B, name: str, *arg: Any, **kwargs: Any):
        super().__init__(parent, name, *arg, **kwargs)

        self._min_freq = -8e7
        self._valid_max_freq: dict[str, float] = {
            ""503"": 3.7e9,
            ""508"": 8.5e9,
            ""513"": 13.8e9,
            ""526"": 27e9,
            ""544"": 44.5e9,
        }
        opt: str | None = None
        for hw_opt_for_max_freq in self._valid_max_freq.keys():
            if hw_opt_for_max_freq in self.root_instrument._options():
                opt = hw_opt_for_max_freq
        assert opt is not None
        self._max_freq = self._valid_max_freq[opt]

        self.add_parameter(
            name=""start"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:STARt?"",
            set_cmd=self._set_start,
            get_parser=float,
            vals=Numbers(self._min_freq, self._max_freq - 10),
            docstring=""start frequency for the sweep"",
        )

        self.add_parameter(
            name=""stop"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:STOP?"",
            set_cmd=self._set_stop,
            get_parser=float,
            vals=Numbers(self._min_freq + 10, self._max_freq),
            docstring=""stop frequency for the sweep"",
        )

        self.add_parameter(
            name=""center"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:CENTer?"",
            set_cmd=self._set_center,
            get_parser=float,
            vals=Numbers(self._min_freq + 5, self._max_freq - 5),
            docstring=""Sets and gets center frequency"",
        )

        self.add_parameter(
            name=""span"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:SPAN?"",
            set_cmd=self._set_span,
            get_parser=float,
            vals=Numbers(10, self._max_freq - self._min_freq),
            docstring=""Changes span of frequency"",
        )

        self.add_parameter(
            name=""npts"",
            get_cmd="":SENSe:SWEep:POINts?"",
            set_cmd=self._set_npts,
            get_parser=int,
            vals=Ints(1, 20001),
            docstring=""Number of points for the sweep"",
        )

        self.add_parameter(
            name=""sweep_time"",
            label=""Sweep time"",
            get_cmd="":SENSe:SWEep:TIME?"",
            set_cmd="":SENSe:SWEep:TIME {}"",
            get_parser=float,
            unit=""s"",
            docstring=""gets sweep time"",
        )

        self.add_parameter(
            name=""auto_sweep_time_enabled"",
            get_cmd="":SENSe:SWEep:TIME:AUTO?"",
            set_cmd=self._enable_auto_sweep_time,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""enables auto sweep time"",
        )

        self.add_parameter(
            name=""auto_sweep_type_enabled"",
            get_cmd="":SENSe:SWEep:TYPE:AUTO?"",
            set_cmd=self._enable_auto_sweep_type,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""enables auto sweep type"",
        )

        self.add_parameter(
            name=""sweep_type"",
            get_cmd="":SENSe:SWEep:TYPE?"",
            set_cmd=self._set_sweep_type,
            val_mapping={
                ""fft"": ""FFT"",
                ""sweep"": ""SWE"",
            },
            docstring=""Sets up sweep type. Possible options are 'fft' and 'sweep'."",
        )

        self.add_parameter(
            name=""freq_axis"",
            label=""Frequency"",
            unit=""Hz"",
            start=self.start,
            stop=self.stop,
            npts=self.npts,
            vals=Arrays(shape=(self.npts.get_latest,)),
            parameter_class=FrequencyAxis,
            docstring=""Creates frequency axis for the sweep from start, ""
            ""stop and npts values."",
        )

        self.add_parameter(
            name=""trace"",
            label=""Trace"",
            unit=""dB"",
            number=1,
            vals=Arrays(shape=(self.npts.get_latest,)),
            setpoints=(self.freq_axis,),
            parameter_class=Trace,
            docstring=""Gets trace data."",
        )

    def _set_start(self, val: float) -> None:
        """"""
        Sets start frequency
        """"""
        stop = self.stop()
        if val >= stop:
            raise ValueError(
                f""Start frequency must be smaller than stop ""
                f""frequency. Provided start freq is: {val} Hz and ""
                f""set stop freq is: {stop} Hz""
            )

        self.write(f"":SENSe:FREQuency:STARt {val}"")

        start = self.start()
        if abs(val - start) >= 1:
            self.log.warning(f""Could not set start to {val} setting it to {start}"")

    def _set_stop(self, val: float) -> None:
        """"""
        Sets stop frequency
        """"""
        start = self.start()
        if val <= start:
            raise ValueError(
                f""Stop frequency must be larger than start ""
                f""frequency. Provided stop freq is: {val} Hz and ""
                f""set start freq is: {start} Hz""
            )

        self.write(f"":SENSe:FREQuency:STOP {val}"")

        stop = self.stop()
        if abs(val - stop) >= 1:
            self.log.warning(f""Could not set stop to {val} setting it to {stop}"")

    def _set_center(self, val: float) -> None:
        """"""
        Sets center frequency and updates start and stop frequencies if they
        change.
        """"""
        self.write(f"":SENSe:FREQuency:CENTer {val}"")
        self.update_trace()

    def _set_span(self, val: float) -> None:
        """"""
        Sets frequency span and updates start and stop frequencies if they
        change.
        """"""
        self.write(f"":SENSe:FREQuency:SPAN {val}"")
        self.update_trace()

    def _set_npts(self, val: int) -> None:
        """"""
        Sets number of points for sweep
        """"""
        self.write(f"":SENSe:SWEep:POINts {val}"")

    def _enable_auto_sweep_time(self, val: str) -> None:
        """"""
        Enables auto sweep time
        """"""
        self.write(f"":SENSe:SWEep:TIME:AUTO {val}"")

    def _enable_auto_sweep_type(self, val: str) -> None:
        """"""
        Enables auto sweep type
        """"""
        self.write(f"":SENSe:SWEep:TYPE:AUTO {val}"")

    def _set_sweep_type(self, val: str) -> None:
        """"""
        Sets sweep type
        """"""
        self.write(f"":SENSe:SWEep:TYPE {val}"")

    def _get_data(self, trace_num: int) -> ParamRawDataType:
        """"""
        Gets data from the measurement.
        """"""
        try:
            timeout = self.sweep_time() + self.root_instrument._additional_wait
            with self.root_instrument.timeout.set_to(timeout):
                data_str = self.ask(
                    f"":READ:"" f""{self.root_instrument.measurement()}"" f""{trace_num}?""
                )
                data = np.array(data_str.rstrip().split("","")).astype(""float64"")
        except TimeoutError as e:
            raise TimeoutError(""Couldn't receive any data. Command timed out."") from e

        trace_data = data[1::2]
        return trace_data

    def update_trace(self) -> None:
        """"""
        Updates start and stop frequencies whenever span of/or center frequency
        is updated.
        """"""
        self.start()
        self.stop()

    def setup_swept_sa_sweep(self, start: float, stop: float, npts: int) -> None:
        """"""
        Sets up the Swept SA measurement sweep for Spectrum Analyzer Mode.
        """"""
        self.root_instrument.mode(""SA"")
        if ""SAN"" in self.root_instrument._available_meas():
            self.root_instrument.measurement(""SAN"")
        else:
            raise RuntimeError(
                ""Swept SA measurement is not available on your ""
                ""Keysight N9030B instrument with Spectrum ""
                ""Analyzer mode.""
            )
        self.start(start)
        self.stop(stop)
        self.npts(npts)

    def autotune(self) -> None:
        """"""
        Autotune quickly get to the most likely signal of interest, and
        position it optimally on the display.
        """"""
        self.write("":SENS:FREQuency:TUNE:IMMediate"")
        self.center()


class KeysightN9030BPhaseNoiseMode(InstrumentChannel):
    """"""
    Phase Noise Mode for Keysight N9030B instrument.
    """"""

    def __init__(self, parent: KeysightN9030B, name: str, *arg: Any, **kwargs: Any):
        super().__init__(parent, name, *arg, **kwargs)

        self._min_freq = 1
        self._valid_max_freq: dict[str, float] = {
            ""503"": 3699999995,
            ""508"": 8499999995,
            ""513"": 13799999995,
            ""526"": 26999999995,
            ""544"": 44499999995,
        }
        opt: str | None = None
        for hw_opt_for_max_freq in self._valid_max_freq.keys():
            if hw_opt_for_max_freq in self.root_instrument._options():
                opt = hw_opt_for_max_freq
        assert opt is not None
        self._max_freq = self._valid_max_freq[opt]

        self.add_parameter(
            name=""npts"",
            get_cmd="":SENSe:LPLot:SWEep:POINts?"",
            set_cmd="":SENSe:LPLot:SWEep:POINts {}"",
            get_parser=int,
            vals=Ints(601, 20001),
            docstring=""Number of points for the sweep"",
        )

        self.add_parameter(
            name=""start_offset"",
            unit=""Hz"",
            get_cmd="":SENSe:LPLot:FREQuency:OFFSet:STARt?"",
            set_cmd=self._set_start_offset,
            get_parser=float,
            vals=Numbers(self._min_freq, self._max_freq - 10),
            docstring=""start frequency offset for the plot"",
        )

        self.add_parameter(
            name=""stop_offset"",
            unit=""Hz"",
            get_cmd="":SENSe:LPLot:FREQuency:OFFSet:STOP?"",
            set_cmd=self._set_stop_offset,
            get_parser=float,
            vals=Numbers(self._min_freq + 99, self._max_freq),
            docstring=""stop frequency offset for the plot"",
        )

        self.add_parameter(
            name=""signal_tracking_enabled"",
            get_cmd="":SENSe:FREQuency:CARRier:TRACk?"",
            set_cmd="":SENSe:FREQuency:CARRier:TRACk {}"",
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Gets/Sets signal tracking. When signal tracking is ""
            ""enabled carrier signal is repeatedly realigned. Signal ""
            ""Tracking assumes the new acquisition occurs repeatedly ""
            ""without pause."",
        )

        self.add_parameter(
            name=""freq_axis"",
            label=""Frequency"",
            unit=""Hz"",
            start=self.start_offset,
            stop=self.stop_offset,
            npts=self.npts,
            vals=Arrays(shape=(self.npts.get_latest,)),
            parameter_class=FrequencyAxis,
            docstring=""Creates frequency axis for the sweep from ""
            ""start_offset, stop_offset and npts values."",
        )

        self.add_parameter(
            name=""trace"",
            label=""Trace"",
            unit=""dB"",
            number=3,
            vals=Arrays(shape=(self.npts.get_latest,)),
            setpoints=(self.freq_axis,),
            parameter_class=Trace,
            docstring=""Gets trace data."",
        )

    def _set_start_offset(self, val: float) -> None:
        """"""
        Sets start offset for frequency in the plot
        """"""
        stop_offset = self.stop_offset()
        self.write(f"":SENSe:LPLot:FREQuency:OFFSet:STARt {val}"")
        start_offset = self.start_offset()

        if abs(val - start_offset) >= 1:
            self.log.warning(
                f""Could not set start offset to {val} setting it to "" f""{start_offset}""
            )
        if val >= stop_offset or abs(val - stop_offset) < 10:
            self.log.warning(
                f""Provided start frequency offset {val} Hz was ""
                f""greater than preset stop frequency offset ""
                f""{stop_offset} Hz. Provided start frequency ""
                f""offset {val} Hz is set and new stop freq offset""
                f"" is: {self.stop_offset()} Hz.""
            )

    def _set_stop_offset(self, val: float) -> None:
        """"""
        Sets stop offset for frequency in the plot
        """"""
        start_offset = self.start_offset()
        self.write(f"":SENSe:LPLot:FREQuency:OFFSet:STOP {val}"")
        stop_offset = self.stop_offset()

        if abs(val - stop_offset) >= 1:
            self.log.warning(
                f""Could not set stop offset to {val} setting it to "" f""{stop_offset}""
            )

        if val <= start_offset or abs(val - start_offset) < 10:
            self.log.warning(
                f""Provided stop frequency offset {val} Hz was ""
                f""less than preset start frequency offset ""
                f""{start_offset} Hz. Provided stop frequency ""
                f""offset {val} Hz is set and new start freq offset""
                f"" is: {self.start_offset()} Hz.""
            )

    def _get_data(self, trace_num: int) -> ParamRawDataType:
        """"""
        Gets data from the measurement.
        """"""
        raw_data = self.ask(f"":READ:{self.root_instrument.measurement()}{1}?"")
        trace_res_details = np.array(raw_data.rstrip().split("","")).astype(""float64"")

        if len(trace_res_details) != 7 or (
            len(trace_res_details) >= 1 and trace_res_details[0] < -50
        ):
            self.log.warning(""Carrier(s) Incorrect or Missing!"")
            return -1 * np.ones(self.npts())

        try:
            data_str = self.ask(
                f"":READ:{self.root_instrument.measurement()}"" f""{trace_num}?""
            )
            data = np.array(data_str.rstrip().split("","")).astype(""float64"")
        except TimeoutError as e:
            raise TimeoutError(""Couldn't receive any data. Command timed out."") from e

        trace_data = data[1::2]
        return trace_data

    def setup_log_plot_sweep(
        self, start_offset: float, stop_offset: float, npts: int
    ) -> None:
        """"""
        Sets up the Log Plot measurement sweep for Phase Noise Mode.
        """"""
        self.root_instrument.mode(""PNOISE"")
        if ""LPL"" in self.root_instrument._available_meas():
            self.root_instrument.measurement(""LPL"")
        else:
            raise RuntimeError(
                ""Log Plot measurement is not available on your ""
                ""Keysight N9030B instrument with Phase Noise ""
                ""mode.""
            )

        self.start_offset(start_offset)
        self.stop_offset(stop_offset)
        self.npts(npts)

    def autotune(self) -> None:
        """"""
        On autotune, the measurement automatically searches for and tunes to
        the strongest signal in the full span of the analyzer.
        """"""
        self.write("":SENSe:FREQuency:CARRier:SEARch"")
        self.start_offset()
        self.stop_offset()


class KeysightN9030B(VisaInstrument):
    """"""
    Driver for Keysight N9030B PXA signal analyzer. Keysight N9030B PXA
    signal analyzer is part of Keysight X-Series Multi-touch Signal
    Analyzers.
    This driver allows Swept SA measurements in Spectrum Analyzer mode and
    Log Plot measurements in Phase Noise mode of the instrument.

    Args:
        name
        address
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self._min_freq: float
        self._max_freq: float
        self._additional_wait: float = 1

        self.add_parameter(
            name=""mode"",
            get_cmd="":INSTrument:SELect?"",
            set_cmd="":INSTrument:SELect {}"",
            vals=Enum(*self._available_modes()),
            docstring=""Allows setting of different modes present and licensed ""
            ""for the instrument."",
        )

        self.add_parameter(
            name=""measurement"",
            get_cmd="":CONFigure?"",
            set_cmd="":CONFigure:{}"",
            vals=Enum(""SAN"", ""LPL""),
            docstring=""Sets measurement type from among the available ""
            ""measurement types."",
        )

        self.add_parameter(
            name=""cont_meas"",
            initial_value=False,
            get_cmd="":INITiate:CONTinuous?"",
            set_cmd=self._enable_cont_meas,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Enables or disables continuous measurement."",
        )

        self.add_parameter(
            name=""format"",
            get_cmd="":FORMat:TRACe:DATA?"",
            set_cmd="":FORMat:TRACe:DATA {}"",
            val_mapping={
                ""ascii"": ""ASCii"",
                ""int32"": ""INTeger,32"",
                ""real32"": ""REAL,32"",
                ""real64"": ""REAL,64"",
            },
            docstring=""Sets up format of data received"",
        )

        if ""SA"" in self._available_modes():
            sa_mode = KeysightN9030BSpectrumAnalyzerMode(self, name=""sa"")
            self.add_submodule(""sa"", sa_mode)
        else:
            self.log.info(""Spectrum Analyzer mode is not available on this instrument."")

        if ""PNOISE"" in self._available_modes():
            pnoise_mode = KeysightN9030BPhaseNoiseMode(self, name=""pn"")
            self.add_submodule(""pn"", pnoise_mode)
        else:
            self.log.info(""Phase Noise mode is not available on this instrument."")
        self.connect_message()

    def _available_modes(self) -> tuple[str, ...]:
        """"""
        Returns present and licensed modes for the instrument.
        """"""
        available_modes = self.ask("":INSTrument:CATalog?"")
        av_modes = available_modes[1:-1].split("","")
        modes: tuple[str, ...] = ()
        for i, mode in enumerate(av_modes):
            if i == 0:
                modes = modes + (mode.split("" "")[0],)
            else:
                modes = modes + (mode.split("" "")[1],)
        return modes

    def _available_meas(self) -> tuple[str, ...]:
        """"""
        Gives available measurement with a given mode for the instrument
        """"""
        available_meas = self.ask("":CONFigure:CATalog?"")
        av_meas = available_meas[1:-1].split("","")
        measurements: tuple[str, ...] = ()
        for i, meas in enumerate(av_meas):
            if i == 0:
                measurements = measurements + (meas,)
            else:
                measurements = measurements + (meas[1:],)
        return measurements

    def _enable_cont_meas(self, val: str) -> None:
        """"""
        Sets continuous measurement to ON or OFF.
        """"""
        self.write(f"":INITiate:CONTinuous {val}"")

    def _options(self) -> tuple[str, ...]:
        """"""
        Returns installed options numbers.
        """"""
        options_raw = self.ask(""*OPT?"")
        return tuple(options_raw[1:-1].split("",""))

    def reset(self) -> None:
        """"""
        Reset the instrument by sending the RST command
        """"""
        self.write(""*RST"")

    def abort(self) -> None:
        """"""
        Aborts the measurement
        """"""
        self.write("":ABORt"")
"
90,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'atts4XZWkT4pxuTR4'), ('width', 300), ('height', 166), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jVK0kONjvPbmZ0uoDHGT2A/l4fgBfocf9h_si2AzEyzLKfnjr4rm3_SlocriAkQYqTl2s-Rd-m1oiMlQhLcUimL3jBfLayOaCCui2qy-9EgGavSqiNQ7ccnYm_VyyFXpfM/5b1hh451hLUhf7P5GrvpNEI6chnNOb_KS_FWnw8E8GE'), ('filename', 'PROD-2917039-01.jpeg'), ('size', 7332), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/in8_ns24U8UjvvzSk1q1-Q/weQPMyhwP8N4AFqtB5-98sTdQ__ncNLIZbI8S55MwVRyTBed-nWBr1cmHGBeAOjBwda8YQlw3MaxAE9GRZBN_g/5oIrAjpQqFJxEuNizCCWk4rcLhy0oU70cAhU1EaEc3M'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_09enE9ZSUqP_dkm212aWg/X6IyzXiM6X-WoPgH1x_M_0wvXDrLtNriucUCncouFcbwpT5fQ-Eh7HCE9wm_CvgF9TLpKSupssMDg_3ylUEnCQ/9Crpr4QZ--6Yd2pyz4miVc1oZgUG7kgzjBk3p-tu3Q0'), ('width', 300), ('height', 166)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rAf80vpQgQb0-GUenKqqDA/eS8th8WwffsxfdKxs705Md4dclc3VebKRXDW7zLcHqBd7n8UbmwFUtNRsrfQP_13b3XvlVLMLWmdMIGtRSR5CQ/iCGD2IUvflWgLKFaw6LkbJ_Qb2apnCYnL-1zddoK7kA'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,,,Ktmawgdefs,286.0,['RF Signal Generator'],"An arbitrary waveform generator (AWG or ARB) is a sophisticated signal generator that generates arbitrary waveforms within published limits of frequency range, accuracy, and output level. Unlike a function generator that produces a small set of specific waveforms, an AWG allows the user to specify a source waveform in a variety of different ways.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtMAwgDefs.py,Qcodes,https://github.com/QCoDeS/Qcodes/tree/master/docs,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782497/Instruments/RF%20Signal%20Generator/Keysight-MAwgDef/Keysight-MAwgDef.jpg,Keysight MAwgDef,Write a Python script that uses Qcodes to connect to a Keysight MAwgDef RF Signal Generator,,,,,"# ***************************************************************************
# *---------------------------- Attribute Defines ---------------------------*
# ***************************************************************************

IVI_ATTR_BASE = 1000000


IVI_INHERENT_ATTR_BASE = (
    IVI_ATTR_BASE + 50000
)  # base for inherent capability attributes

# base for IVI-defined class attributes
IVI_CLASS_ATTR_BASE = IVI_ATTR_BASE + 250000

# base for IviLxiSync attributes
IVI_LXISYNC_ATTR_BASE = IVI_ATTR_BASE + 950000


IVI_SPECIFIC_ATTR_BASE = (
    IVI_ATTR_BASE + 150000
)  # base for attributes of specific drivers


# ===== IVI Inherent Instrument Attributes ===========

# - Driver Identification

KTMAWG_ATTR_SPECIFIC_DRIVER_DESCRIPTION = (
    IVI_INHERENT_ATTR_BASE + 514
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_PREFIX = IVI_INHERENT_ATTR_BASE + 302
# ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_VENDOR = IVI_INHERENT_ATTR_BASE + 513
KTMAWG_ATTR_SPECIFIC_DRIVER_REVISION = (
    IVI_INHERENT_ATTR_BASE + 551
)  # ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MAJOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 515
)  # ViInt32, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MINOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 516
)  # ViInt32, read-only

# - User Options
# ViBoolean, read-write
KTMAWG_ATTR_RANGE_CHECK = IVI_INHERENT_ATTR_BASE + 2
KTMAWG_ATTR_QUERY_INSTRUMENT_STATUS = (
    IVI_INHERENT_ATTR_BASE + 3
)  # ViBoolean, read-write
# ViBoolean, read-write
KTMAWG_ATTR_CACHE = IVI_INHERENT_ATTR_BASE + 4
# ViBoolean, read-write
KTMAWG_ATTR_SIMULATE = IVI_INHERENT_ATTR_BASE + 5
# ViBoolean, read-write
KTMAWG_ATTR_RECORD_COERCIONS = IVI_INHERENT_ATTR_BASE + 6
# ViBoolean, read-write
KTMAWG_ATTR_INTERCHANGE_CHECK = IVI_INHERENT_ATTR_BASE + 21

# - Advanced Session Information
# ViString, read-only
KTMAWG_ATTR_LOGICAL_NAME = IVI_INHERENT_ATTR_BASE + 305
# ViString, read-only
KTMAWG_ATTR_IO_RESOURCE_DESCRIPTOR = IVI_INHERENT_ATTR_BASE + 304
# ViString, read-only
KTMAWG_ATTR_DRIVER_SETUP = IVI_INHERENT_ATTR_BASE + 7

# - Driver Capabilities
# ViString, read-only
KTMAWG_ATTR_GROUP_CAPABILITIES = IVI_INHERENT_ATTR_BASE + 401
KTMAWG_ATTR_SUPPORTED_INSTRUMENT_MODELS = (
    IVI_INHERENT_ATTR_BASE + 327
)  # ViString, read-only

# - Instrument Identification

KTMAWG_ATTR_INSTRUMENT_FIRMWARE_REVISION = (
    IVI_INHERENT_ATTR_BASE + 510
)  # ViString, read-only
KTMAWG_ATTR_INSTRUMENT_MANUFACTURER = (
    IVI_INHERENT_ATTR_BASE + 511
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_INSTRUMENT_MODEL = IVI_INHERENT_ATTR_BASE + 512


# ===== Instrument-Specific Attributes =====================================

# - Instrument Specific

KTMAWG_ATTR_GENERATION_SETTINGS_RESTRICTIONS = (
    IVI_SPECIFIC_ATTR_BASE + 101
)  # ViBoolean, read-only

# - System
# ViString, read-only
KTMAWG_ATTR_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 3
# ViString, read-only
KTMAWG_ATTR_SYSTEM_ABOUT = IVI_SPECIFIC_ATTR_BASE + 4
KTMAWG_ATTR_SYSTEM_GC_TIMING_OPTIMIZATION_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 5
)  # ViBoolean, read-write
KTMAWG_ATTR_SYSTEM_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 6
)  # ViBoolean, read-write
# ViInt32, read-only
KTMAWG_ATTR_SYSTEM_INSTANCE_ID = IVI_SPECIFIC_ATTR_BASE + 7
# ViString, read-only
KTMAWG_ATTR_SYSTEM_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 8
# ViInt32, read-write
KTMAWG_ATTR_SYSTEM_TIMEOUT = IVI_SPECIFIC_ATTR_BASE + 9

# - Licensing

KTMAWG_ATTR_LICENSING_HOST_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 11
)  # ViString, read-only
KTMAWG_ATTR_LICENSING_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 12
)  # ViString, read-only

# - Calibration

KTMAWG_ATTR_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 16
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_CALIBRATION_DUE_DATE = IVI_SPECIFIC_ATTR_BASE + 17
KTMAWG_ATTR_CALIBRATION_INSTRUMENT_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 18
)  # ViString, read-only
# ViInt32, read-only
KTMAWG_ATTR_CALIBRATION_STATUS = IVI_SPECIFIC_ATTR_BASE + 19
KTMAWG_ATTR_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 20
)  # ViString, read-only

# - Module
# ViInt32, read-only
KTMAWG_ATTR_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 23
KTMAWG_ATTR_MODULE_INSTRUMENT_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 24
)  # ViString, read-only
KTMAWG_ATTR_MODULE_MAXIMUM_RECORDED_TEMPERATURE = (
    IVI_SPECIFIC_ATTR_BASE + 25
)  # ViInt32, read-only
# ViString, read-only
KTMAWG_ATTR_MODULE_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 26
# ViString, read-only
KTMAWG_ATTR_MODULE_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 27
# ViInt32, read-only
KTMAWG_ATTR_MODULE_SLOT = IVI_SPECIFIC_ATTR_BASE + 28
# ViReal64, read-only
KTMAWG_ATTR_MODULE_TEMPERATURE = IVI_SPECIFIC_ATTR_BASE + 29

# - Calibration

KTMAWG_ATTR_MODULE_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 30
)  # ViString, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_DUE_DATE = (
    IVI_SPECIFIC_ATTR_BASE + 31
)  # ViString, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_STATUS = (
    IVI_SPECIFIC_ATTR_BASE + 32
)  # ViInt32, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 33
)  # ViString, read-only

# - Nonvolatile

KTMAWG_ATTR_NONVOLATILE_ASSET_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 34
)  # ViString, read-write
KTMAWG_ATTR_NONVOLATILE_CAL_DUE_REMINDER = (
    IVI_SPECIFIC_ATTR_BASE + 35
)  # ViInt32, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_INSTRUMENT_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 36
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_MODULE_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 37
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_PERIODIC_CAL = (
    IVI_SPECIFIC_ATTR_BASE + 38
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_INSTRUMENT_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 39
)  # ViInt32, read-write
KTMAWG_ATTR_NONVOLATILE_MODULE_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 40
)  # ViInt32, read-write
# ViString, read-write
KTMAWG_ATTR_NONVOLATILE_PASSPHRASE = IVI_SPECIFIC_ATTR_BASE + 41
KTMAWG_ATTR_NONVOLATILE_SYSTEM_IDENTIFICATION = (
    IVI_SPECIFIC_ATTR_BASE + 42
)  # ViString, read-write

# - AssetChannel
# ViInt32, read-only
KTMAWG_ATTR_ASSETCHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 60

# - PeerToPeerPort
# ViInt32, read-only
KTMAWG_ATTR_PEERTOPEERPORT_COUNT = IVI_SPECIFIC_ATTR_BASE + 45
# ViString, read-write
KTMAWG_ATTR_ACTIVE_PEERTOPEERPORT = IVI_SPECIFIC_ATTR_BASE + 46

# - DeviceSync
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_CLOCK_RATE = IVI_SPECIFIC_ATTR_BASE + 88
KTMAWG_ATTR_DEVICE_SYNC_CLOCK_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 89
)  # ViString, read-write
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_GROUP_MASK = IVI_SPECIFIC_ATTR_BASE + 90
KTMAWG_ATTR_DEVICE_SYNC_GROUP_SIGNAL = (
    IVI_SPECIFIC_ATTR_BASE + 91
)  # ViInt32, read-write
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_ROLE = IVI_SPECIFIC_ATTR_BASE + 92
KTMAWG_ATTR_DEVICE_SYNC_SLAVE_SIGNAL = (
    IVI_SPECIFIC_ATTR_BASE + 93
)  # ViInt32, read-write
# ViInt32, read-only
KTMAWG_ATTR_DEVICE_SYNC_STATE = IVI_SPECIFIC_ATTR_BASE + 94
KTMAWG_ATTR_DEVICE_SYNC_IS_ALIGNMENT_VALID = (
    IVI_SPECIFIC_ATTR_BASE + 97
)  # ViBoolean, read-only
KTMAWG_ATTR_DEVICE_SYNC_SYNC_CHANNELS = (
    IVI_SPECIFIC_ATTR_BASE + 100
)  # ViString, read-write

# - Waveform
# ViInt32, read-only
KTMAWG_ATTR_ARB_NUMBER_WAVEFORMS = IVI_SPECIFIC_ATTR_BASE + 98

# - Sequence
# ViInt32, read-only
KTMAWG_ATTR_ARB_NUMBER_SEQUENCES = IVI_SPECIFIC_ATTR_BASE + 99

# - SequenceTriggers

KTMAWG_ATTR_SEQUENCETRIGGER_MAX_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 73
)  # ViInt32, read-only
# ViInt32, read-only
KTMAWG_ATTR_SEQUENCETRIGGER_COUNT = IVI_SPECIFIC_ATTR_BASE + 74

# - Marker
# ViInt32, read-only
KTMAWG_ATTR_MARKER_COUNT = IVI_SPECIFIC_ATTR_BASE + 75
# ViInt32, read-only
KTMAWG_ATTR_MARKER_MAX_COUNT = IVI_SPECIFIC_ATTR_BASE + 76

# - External
# ViInt32, read-only
KTMAWG_ATTR_EXTERNAL_COUNT = IVI_SPECIFIC_ATTR_BASE + 79
# ViInt32, read-write
KTMAWG_ATTR_EXTERNAL_INPUT_SLOPE = IVI_SPECIFIC_ATTR_BASE + 83
KTMAWG_ATTR_EXTERNAL_OUTPUT_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 84
)  # ViInt32, read-write
# ViReal64, read-write
KTMAWG_ATTR_EXTERNAL_THRESHOLD = IVI_SPECIFIC_ATTR_BASE + 85
# ViReal64, read-write

# - TriggerBusLine
# ViInt32, read-only
KTMAWG_ATTR_TRIGGER_BUS_LINE_COUNT = IVI_SPECIFIC_ATTR_BASE + 80
KTMAWG_ATTR_TRIGGER_BUS_LINE_INPUT_SLOPE = (
    IVI_SPECIFIC_ATTR_BASE + 81
)  # ViInt32, read-write
KTMAWG_ATTR_TRIGGER_BUS_LINE_OUTPUT_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 82
)  # ViInt32, read-write
KTMAWG_ATTR_TRIGGER_BUS_LINE_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 86
)  # ViInt32, read-only

# - ReferenceClock

KTMAWG_ATTR_REF_CLOCK_IS_PHASE_LOCKED = (
    IVI_SPECIFIC_ATTR_BASE + 96
)  # ViBoolean, read-only

# - Arbitrary
# ViReal64, read-write
KTMAWG_ATTR_ARB_GAIN = IVI_CLASS_ATTR_BASE + 202
# ViReal64, read-write
KTMAWG_ATTR_ARB_OFFSET = IVI_CLASS_ATTR_BASE + 203
# ViReal64, read-write
KTMAWG_ATTR_ARB_SAMPLE_RATE = IVI_CLASS_ATTR_BASE + 204

# - Waveform
# ViInt32, read-write
KTMAWG_ATTR_ARB_WAVEFORM_HANDLE = IVI_CLASS_ATTR_BASE + 201
# ViInt32, read-only
KTMAWG_ATTR_MAX_NUM_WAVEFORMS = IVI_CLASS_ATTR_BASE + 205
# ViInt32, read-only
KTMAWG_ATTR_WAVEFORM_QUANTUM = IVI_CLASS_ATTR_BASE + 206
# ViInt32, read-only
KTMAWG_ATTR_MAX_WAVEFORM_SIZE = IVI_CLASS_ATTR_BASE + 208
# ViInt64, read-only
KTMAWG_ATTR_MAX_WAVEFORM_SIZE64 = IVI_CLASS_ATTR_BASE + 222
# ViInt32, read-only
KTMAWG_ATTR_MIN_WAVEFORM_SIZE = IVI_CLASS_ATTR_BASE + 207
# ViInt64, read-only
KTMAWG_ATTR_MIN_WAVEFORM_SIZE64 = IVI_CLASS_ATTR_BASE + 221
# ViInt32, read-only
KTMAWG_ATTR_BINARY_ALIGNMENT = IVI_CLASS_ATTR_BASE + 241
# ViInt32, read-only
KTMAWG_ATTR_SAMPLE_BIT_RESOLUTION = IVI_CLASS_ATTR_BASE + 242
# ViInt32, read-only
KTMAWG_ATTR_OUTPUT_DATA_MASK = IVI_CLASS_ATTR_BASE + 261

# - Sequence
# ViInt32, read-write
KTMAWG_ATTR_ARB_SEQUENCE_HANDLE = IVI_CLASS_ATTR_BASE + 211
# ViInt32, read-only
KTMAWG_ATTR_MAX_SEQUENCE_LENGTH = IVI_CLASS_ATTR_BASE + 214
# ViInt32, read-only
KTMAWG_ATTR_MIN_SEQUENCE_LENGTH = IVI_CLASS_ATTR_BASE + 213
# ViInt32, read-only
KTMAWG_ATTR_MAX_LOOP_COUNT = IVI_CLASS_ATTR_BASE + 215
# ViInt32, read-only
KTMAWG_ATTR_MAX_NUM_SEQUENCES = IVI_CLASS_ATTR_BASE + 212
# ViInt32, read-only
KTMAWG_ATTR_MAX_SEQUENCE_DEPTH = IVI_CLASS_ATTR_BASE + 281

# - Output

# ViInt32, read-only
KTMAWG_ATTR_CHANNEL_COUNT = IVI_INHERENT_ATTR_BASE + 203
# ViBoolean, read-write
KTMAWG_ATTR_OUTPUT_ENABLED = IVI_CLASS_ATTR_BASE + 3
# ViReal64, read-write
KTMAWG_ATTR_OUTPUT_IMPEDANCE = IVI_CLASS_ATTR_BASE + 4
# ViInt32, read-write
KTMAWG_ATTR_OPERATION_MODE = IVI_CLASS_ATTR_BASE + 5
# ViInt32, read-write
KTMAWG_ATTR_OUTPUT_MODE = IVI_CLASS_ATTR_BASE + 1
# ViInt32, read-write
KTMAWG_ATTR_REF_CLOCK_SOURCE = IVI_CLASS_ATTR_BASE + 2
# ViInt32, read-write
KTMAWG_ATTR_TERMINAL_CONFIGURATION = IVI_CLASS_ATTR_BASE + 31

# - Trigger

# ViInt32, read-write
KTMAWG_ATTR_BURST_COUNT = IVI_CLASS_ATTR_BASE + 350
# ViInt32, read-write
KTMAWG_ATTR_TRIGGER_SOURCE = IVI_CLASS_ATTR_BASE + 302

# - Start Trigger

# ViReal64, read-write
KTMAWG_ATTR_START_TRIGGER_DELAY = IVI_CLASS_ATTR_BASE + 320
# ViInt32, read-write
KTMAWG_ATTR_START_TRIGGER_SLOPE = IVI_CLASS_ATTR_BASE + 321
# ViString, read-write
KTMAWG_ATTR_START_TRIGGER_SOURCE = IVI_CLASS_ATTR_BASE + 322
# ViReal64, read-write
KTMAWG_ATTR_START_TRIGGER_THRESHOLD = IVI_CLASS_ATTR_BASE + 323


# ***************************************************************************

# *------------------------ Attribute Value Defines -------------------------*
# ***************************************************************************

# - Defined values for

KTMAWG_VAL_STATUS_BYTE_FLAGS_USER0 = 1
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER1 = 2
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER2 = 4
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER3 = 8
KTMAWG_VAL_STATUS_BYTE_FLAGS_MESSAGE_AVAILABLE = 16
KTMAWG_VAL_STATUS_BYTE_FLAGS_EVENT_STATUS_REGISTER = 32
KTMAWG_VAL_STATUS_BYTE_FLAGS_REQUESTING_SERVICE = 64
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER7 = 128

# - Defined values for

KTMAWG_VAL_UPDATE_STATUS_IN_PROGRESS = 0
KTMAWG_VAL_UPDATE_STATUS_SUCCESS = 1
KTMAWG_VAL_UPDATE_STATUS_RESTART_REQUIRED = 2
KTMAWG_VAL_UPDATE_STATUS_POWER_CYCLE_REQUIRED = 3
KTMAWG_VAL_UPDATE_STATUS_FAILED = 4

# - Defined values for
#  attribute KTMAWG_ATTR_CALIBRATION_STATUS
#  attribute KTMAWG_ATTR_MODULE_CALIBRATION_STATUS

KTMAWG_VAL_CALIBRATION_STATUS_DUE = 1
KTMAWG_VAL_CALIBRATION_STATUS_EXPIRED = 2
KTMAWG_VAL_CALIBRATION_STATUS_INSTRUMENT_CALIBRATED = 0
KTMAWG_VAL_CALIBRATION_STATUS_MODULES_CALIBRATED = 5
KTMAWG_VAL_CALIBRATION_STATUS_NOT_CALIBRATED = 3
KTMAWG_VAL_CALIBRATION_STATUS_NOT_SUBJECT_TO_CALIBRATION = 4

# - Defined values for
#   parameter Mask in function KtMAwg_StatusClearEvent
#   parameter Mask in function KtMAwg_StatusGetEventState
#   parameter Mask in function KtMAwg_StatusSetEvent

KTMAWG_VAL_STATUS_EVENT_ALL = 0
KTMAWG_VAL_STATUS_EVENT_ERROR_IN_QUEUE = 1
KTMAWG_VAL_STATUS_EVENT_THERMAL_SHUTDOWN = 14
KTMAWG_VAL_STATUS_EVENT_THERMAL_WARNING = 15
KTMAWG_VAL_STATUS_EVENT_USER_DEFINED = 2

# - Defined values for

KTMAWG_VAL_MODULE_EVENT_ALL = 0
KTMAWG_VAL_MODULE_EVENT_TIMER1 = 201
KTMAWG_VAL_MODULE_EVENT_TIMER2 = 202
KTMAWG_VAL_MODULE_EVENT_TIMER3 = 203
KTMAWG_VAL_MODULE_EVENT_TIMER4 = 204
KTMAWG_VAL_MODULE_EVENT_TRIGGER1 = 1
KTMAWG_VAL_MODULE_EVENT_TRIGGER10 = 10
KTMAWG_VAL_MODULE_EVENT_TRIGGER2 = 2
KTMAWG_VAL_MODULE_EVENT_TRIGGER3 = 3
KTMAWG_VAL_MODULE_EVENT_TRIGGER4 = 4
KTMAWG_VAL_MODULE_EVENT_TRIGGER5 = 5
KTMAWG_VAL_MODULE_EVENT_TRIGGER6 = 6
KTMAWG_VAL_MODULE_EVENT_TRIGGER7 = 7
KTMAWG_VAL_MODULE_EVENT_TRIGGER8 = 8
KTMAWG_VAL_MODULE_EVENT_TRIGGER9 = 9
KTMAWG_VAL_MODULE_EVENT_USER1 = 101
KTMAWG_VAL_MODULE_EVENT_USER2 = 102
KTMAWG_VAL_MODULE_EVENT_USER3 = 103
KTMAWG_VAL_MODULE_EVENT_USER4 = 104

# - Defined values for

KTMAWG_VAL_SPI_MODE_LSB_FIRST_BYTE = 0
KTMAWG_VAL_SPI_MODE_LSB_FIRST_WORD = 1
KTMAWG_VAL_SPI_MODE_MSB_FIRST_BYTE = 2
KTMAWG_VAL_SPI_MODE_MSB_FIRST_WORD = 3

# - Defined values for

KTMAWG_VAL_TRIGGER_DIRECTION_INPUT = 0
KTMAWG_VAL_TRIGGER_DIRECTION_OUTPUT = 1

# - Defined values for

KTMAWG_VAL_TRIGGER_MODE_LEVEL = 1
KTMAWG_VAL_TRIGGER_MODE_PULSE = 0

# - Defined values for

KTMAWG_VAL_TRIGGER_POLARITY_NEGATIVE = 1
KTMAWG_VAL_TRIGGER_POLARITY_POSITIVE = 0

# - Defined values for

KTMAWG_VAL_TRIGGER_PXI_TRIGGER0 = 0
KTMAWG_VAL_TRIGGER_PXI_TRIGGER1 = 1
KTMAWG_VAL_TRIGGER_PXI_TRIGGER2 = 2
KTMAWG_VAL_TRIGGER_PXI_TRIGGER3 = 3
KTMAWG_VAL_TRIGGER_PXI_TRIGGER4 = 4
KTMAWG_VAL_TRIGGER_PXI_TRIGGER5 = 5
KTMAWG_VAL_TRIGGER_PXI_TRIGGER6 = 6
KTMAWG_VAL_TRIGGER_PXI_TRIGGER7 = 7

# - Defined values for

KTMAWG_VAL_TRIGGER_RESOURCE_NONE = -1
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER1 = 0
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER2 = 1
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER3 = 2
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER4 = 3
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER5 = 4
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER6 = 5
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER7 = 6
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER8 = 7
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER9 = 8
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER10 = 9

# - Defined values for

KTMAWG_VAL_TRIGGER_TERMINATION_HIGH_IMPEDANCE = 0
KTMAWG_VAL_TRIGGER_TERMINATION_LOW_IMPEDANCE = 1

# - Defined values for

KTMAWG_VAL_LTC3880_PHASE_BOTH_PHASES = 255
KTMAWG_VAL_LTC3880_PHASE_PHASE0 = 0
KTMAWG_VAL_LTC3880_PHASE_PHASE1 = 1

# - Defined values for

KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_MODE_COMMON_REFERENCE = 1
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_MODE_DIFFERENTIAL = 0

# - Defined values for

KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_0P64 = 5
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE1_0P24 = 1
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_1P28 = 4
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE2_0P48 = 7
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE2_4P576 = 0
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_2P56 = 3
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_5P12 = 2

# - Defined values for
#   parameter State in function KtMAwg_GetGenerationStateByChannel

KTMAWG_VAL_GENERATION_STATE_CONFIGURATION = 0
KTMAWG_VAL_GENERATION_STATE_OUTPUT_GENERATION = 1

# - Defined values for

KTMAWG_VAL_MEMORY_QUERY_MODE_TOTAL_SIZE = 0
KTMAWG_VAL_MEMORY_QUERY_MODE_FREE_SIZE = 1
KTMAWG_VAL_MEMORY_QUERY_MODE_ALLOCATED_SIZE = 2

# - Defined values for
#   parameter Mode in function KtMAwg_CorrectionsGetFilterMode
#   parameter Mode in function KtMAwg_CorrectionsSetFilterMode

KTMAWG_VAL_CORRECTION_FILTER_MODE_UNCALIBRATED = 1
KTMAWG_VAL_CORRECTION_FILTER_MODE_BYPASS = 2
KTMAWG_VAL_CORRECTION_FILTER_MODE_CALIBRATED = 0

# - Defined values for

KTMAWG_VAL_ATTRIBUTES_ARBITRARY_SAMPLE_RATE = 0
KTMAWG_VAL_ATTRIBUTES_OUTPUT_DELAY = 4
KTMAWG_VAL_ATTRIBUTES_MARKER_DELAY = 20
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_GAIN = 10
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_ANALOG_GAIN = 13
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_DIGITAL_GAIN = 14
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_OFFSET = 11
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_COMMON_MODE_OFFSET = 12
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_LOAD_IMPEDANCE = 8
KTMAWG_VAL_ATTRIBUTES_START_TRIGGER_DELAY = 16
KTMAWG_VAL_ATTRIBUTES_START_TRIGGER_SOURCE = 15
KTMAWG_VAL_ATTRIBUTES_MARKER_DESTINATION = 19
KTMAWG_VAL_ATTRIBUTES_MARKER_BIT_POSITION = 21
KTMAWG_VAL_ATTRIBUTES_SEQUENCE_TRIGGER_SOURCE = 17
KTMAWG_VAL_ATTRIBUTES_SEQUENCE_TRIGGER_DELAY = 18
KTMAWG_VAL_ATTRIBUTES_OUTPUT_OPERATION_MODE = 5
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_GAIN_CONTROL = 9
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_CHANNEL_MODE = 2
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_HANDLE = 1
KTMAWG_VAL_ATTRIBUTES_OUTPUT_ENABLED = 3
KTMAWG_VAL_ATTRIBUTES_OUTPUT_TERMINAL_CONFIGURATION = 7
KTMAWG_VAL_ATTRIBUTES_CORRECTION_FILTER_MODE = 22
KTMAWG_VAL_ATTRIBUTES_BURST_COUNT = 6
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_WAVEFORM_MODE = 30

# - Defined values for
#   parameter Control in function KtMAwg_ArbitrarySetGainControl
#   parameter Control in function KtMAwg_ArbitraryGetGainControl

KTMAWG_VAL_GAIN_CONTROL_COMPONENT = 1
KTMAWG_VAL_GAIN_CONTROL_COMPOSITE = 0

# - Defined values for
#   parameter Events in function KtMAwg_QueryGenerationEvents

KTMAWG_VAL_GENERATION_EVENTS_NONE = 0
KTMAWG_VAL_GENERATION_EVENTS_DIGITAL_GAIN_BLOCK_OVERFLOW = 1
KTMAWG_VAL_GENERATION_EVENTS_FIFO_UNDERRUN = 2
KTMAWG_VAL_GENERATION_EVENTS_RESAMPLER_OVERFLOW = 4
KTMAWG_VAL_GENERATION_EVENTS_CORRECTIONS_OVERFLOW = 8
KTMAWG_VAL_GENERATION_EVENTS_MARKER_QUEUE_OVERRUN = 16
KTMAWG_VAL_GENERATION_EVENTS_MARKER_IGNORED = 32
KTMAWG_VAL_GENERATION_EVENTS_STREAMING_DATA_UNDERRUN = 128

# - Defined values for
#   attribute KTMAWG_ATTR_OUTPUT_MODE
#   parameter OutputMode in function KtMAwg_ConfigureOutputMode

KTMAWG_VAL_OUTPUT_FUNC = 0
KTMAWG_VAL_OUTPUT_ARB = 1
KTMAWG_VAL_OUTPUT_SEQ = 2

# - Defined values for
#   attribute KTMAWG_ATTR_OPERATION_MODE
#   parameter OperationMode in function KtMAwg_ConfigureOperationMode

KTMAWG_VAL_OPERATE_CONTINUOUS = 0
KTMAWG_VAL_OPERATE_BURST = 1

# - Defined values for
#   attribute KTMAWG_ATTR_REF_CLOCK_SOURCE
#   parameter Source in function KtMAwg_ConfigureRefClockSource

KTMAWG_VAL_REF_CLOCK_INTERNAL = 0
KTMAWG_VAL_REF_CLOCK_EXTERNAL = 1
KTMAWG_VAL_REF_CLOCK_RTSI_CLOCK = 101

# - Defined values for
#   attribute KTMAWG_ATTR_TRIGGER_SOURCE
#   parameter Source in function KtMAwg_ConfigureTriggerSource

KTMAWG_VAL_EXTERNAL = 1
KTMAWG_VAL_SOFTWARE_TRIG = 2
KTMAWG_VAL_INTERNAL_TRIGGER = 3
KTMAWG_VAL_TTL0 = 111
KTMAWG_VAL_TTL1 = 112
KTMAWG_VAL_TTL2 = 113
KTMAWG_VAL_TTL3 = 114
KTMAWG_VAL_TTL4 = 115
KTMAWG_VAL_TTL5 = 116
KTMAWG_VAL_TTL6 = 117
KTMAWG_VAL_TTL7 = 118
KTMAWG_VAL_ECL0 = 119
KTMAWG_VAL_ECL1 = 120
KTMAWG_VAL_PXI_STAR = 131
KTMAWG_VAL_RTSI_0 = 141
KTMAWG_VAL_RTSI_1 = 142
KTMAWG_VAL_RTSI_2 = 143
KTMAWG_VAL_RTSI_3 = 144
KTMAWG_VAL_RTSI_4 = 145
KTMAWG_VAL_RTSI_5 = 146
KTMAWG_VAL_RTSI_6 = 147
KTMAWG_VAL_SOFTWARE0 = 1001
KTMAWG_VAL_SOFTWARE1 = 1002
KTMAWG_VAL_SOFTWARE2 = 1003
KTMAWG_VAL_SOFTWARE3 = 1004
KTMAWG_VAL_SOFTWARE4 = 1005
KTMAWG_VAL_SOFTWARE5 = 1006
KTMAWG_VAL_SOFTWARE6 = 1007
KTMAWG_VAL_SOFTWARE7 = 1008
KTMAWG_VAL_SOFTWARE9 = 1010
KTMAWG_VAL_SOFTWARE10 = 1011
KTMAWG_VAL_SOFTWARE11 = 1012
KTMAWG_VAL_SOFTWARE12 = 1013
KTMAWG_VAL_SOFTWARE13 = 1014
KTMAWG_VAL_SOFTWARE14 = 1015
KTMAWG_VAL_SOFTWARE15 = 1016
KTMAWG_VAL_SOFTWARE8 = 1009
KTMAWG_VAL_PXI_TRIG0 = 1017
KTMAWG_VAL_PXI_TRIG1 = 1018
KTMAWG_VAL_PXI_TRIG2 = 1019
KTMAWG_VAL_PXI_TRIG3 = 1020
KTMAWG_VAL_PXI_TRIG4 = 1021
KTMAWG_VAL_PXI_TRIG5 = 1022
KTMAWG_VAL_PXI_TRIG6 = 1023
KTMAWG_VAL_PXI_TRIG7 = 1024
KTMAWG_VAL_EXTERNAL1 = 1025
KTMAWG_VAL_EXTERNAL2 = 1026
KTMAWG_VAL_PXIE_DSTARB = 1027
KTMAWG_VAL_DIO_0 = 1028
KTMAWG_VAL_DIO_1 = 1029
KTMAWG_VAL_DIO_2 = 1030
KTMAWG_VAL_DIO_3 = 1031
KTMAWG_VAL_DIO_4 = 1032
KTMAWG_VAL_DIO_5 = 1033
KTMAWG_VAL_DIO_7 = 1035
KTMAWG_VAL_DIO_6 = 1034
KTMAWG_VAL_TRIG_IMMEDIATE = 1036
KTMAWG_VAL_DISABLED = 1037

# - Defined values for

KTMAWG_VAL_WFM_SINE = 1
KTMAWG_VAL_WFM_SQUARE = 2
KTMAWG_VAL_WFM_TRIANGLE = 3
KTMAWG_VAL_WFM_RAMP_UP = 4
KTMAWG_VAL_WFM_RAMP_DOWN = 5
KTMAWG_VAL_WFM_DC = 6

# - Defined values for

KTMAWG_VAL_AM_INTERNAL_SINE = 1
KTMAWG_VAL_AM_INTERNAL_SQUARE = 2
KTMAWG_VAL_AM_INTERNAL_TRIANGLE = 3
KTMAWG_VAL_AM_INTERNAL_RAMP_UP = 4
KTMAWG_VAL_AM_INTERNAL_RAMP_DOWN = 5

# - Defined values for

KTMAWG_VAL_AM_INTERNAL = 0
KTMAWG_VAL_AM_EXTERNAL = 1

# - Defined values for

KTMAWG_VAL_FM_INTERNAL_SINE = 1
KTMAWG_VAL_FM_INTERNAL_SQUARE = 2
KTMAWG_VAL_FM_INTERNAL_TRIANGLE = 3
KTMAWG_VAL_FM_INTERNAL_RAMP_UP = 4
KTMAWG_VAL_FM_INTERNAL_RAMP_DOWN = 5

# - Defined values for

KTMAWG_VAL_FM_INTERNAL = 0
KTMAWG_VAL_FM_EXTERNAL = 1

# - Defined values for
#   attribute KTMAWG_ATTR_START_TRIGGER_SLOPE
#   parameter Slope in function KtMAwg_ConfigureStartTrigger

KTMAWG_VAL_TRIGGER_POSITIVE = 0
KTMAWG_VAL_TRIGGER_NEGATIVE = 1
KTMAWG_VAL_TRIGGER_EITHER = 2

# - Defined values for
#   attribute KTMAWG_ATTR_TERMINAL_CONFIGURATION
#   parameter Configuration in function KtMAwg_OutputSetTerminalConfiguration

KTMAWG_VAL_TERMINAL_CONFIGURATION_SINGLE_ENDED = 0
KTMAWG_VAL_TERMINAL_CONFIGURATION_DIFFERENTIAL = 1

# - Defined values for

KTMAWG_VAL_SAMPLE_CLOCK_SOURCE_INTERNAL = 0
KTMAWG_VAL_SAMPLE_CLOCK_SOURCE_EXTERNAL = 1

# - Defined values for

KTMAWG_VAL_MARKER_POLARITY_ACTIVE_HIGH = 0
KTMAWG_VAL_MARKER_POLARITY_ACTIVE_LOW = 1

# - Defined values for
#   attribute KTMAWG_ATTR_BINARY_ALIGNMENT

KTMAWG_VAL_BINARY_ALIGNMENT_LEFT = 0
KTMAWG_VAL_BINARY_ALIGNMENT_RIGHT = 1

# - Defined values for
#   parameter Mode in function KtMAwg_GetChannelMode
#   parameter Mode in function KtMAwg_SetChannelMode

KTMAWG_VAL_CHANNEL_MODE_WAVEFORM = 0
KTMAWG_VAL_CHANNEL_MODE_MARKER = 1

# - Defined values for

KTMAWG_VAL_EXTERNAL_IMPEDANCE_OHM_1K = 0
KTMAWG_VAL_EXTERNAL_IMPEDANCE_OHM50 = 1

# - Defined values for

KTMAWG_VAL_EXTERNAL_ATTRIBUTES_THRESHOLD = 0

# - Defined values for
#   attribute KTMAWG_ATTR_EXTERNAL_INPUT_SLOPE
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_INPUT_SLOPE

KTMAWG_VAL_INPUT_SLOPE_POSITIVE = 0
KTMAWG_VAL_INPUT_SLOPE_NEGATIVE = 1

# - Defined values for
#   attribute KTMAWG_ATTR_EXTERNAL_OUTPUT_POLARITY
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_OUTPUT_POLARITY
#   parameter Val in function KtMAwg_GetChannelMarkerPolarity
#  parameter Polarity in function KtMAwg_SetChannelMarkerPolarity

KTMAWG_VAL_OUTPUT_POLARITY_POSITIVE = 0
KTMAWG_VAL_OUTPUT_POLARITY_NEGATIVE = 1

# - Defined values for
#   parameter Option in function KtMAwg_MemoryTest

KTMAWG_VAL_MEMORY_TEST_STANDARD = 1
KTMAWG_VAL_MEMORY_TEST_COMPREHENSIVE = 0

# - Defined values for
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_CAPABILITY

KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_INPUT = 1
KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_OUTPUT = 2
KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_BOTH = 3

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_GROUP_SIGNAL
#   attribute KTMAWG_ATTR_DEVICE_SYNC_SLAVE_SIGNAL
#   parameter GroupSignal in function KtMAwg_DeviceSyncConfigureMaster
#   parameter SlaveSignals in function KtMAwg_DeviceSyncConfigureMaster
#   parameter GroupSignal in function KtMAwg_DeviceSyncConfigureSlave
#   parameter SlaveSignal in function KtMAwg_DeviceSyncConfigureSlave
#   parameter Val in function KtMAwg_DeviceSyncGetGroupMask
#   parameter SlaveSignals in function KtMAwg_DeviceSyncSetGroupMask

KTMAWG_VAL_DEVICE_SYNC_RESOURCESFP_SYNC = 32768
KTMAWG_VAL_DEVICE_SYNC_RESOURCES_NONE = 0
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_LBL6 = 2048
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_LBR6 = 1024
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_STAR = 512
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG0 = 1
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG1 = 2
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG2 = 4
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG3 = 8
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG4 = 16
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG5 = 32
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG6 = 64
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG7 = 128
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARA = 4096
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARB = 8192
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARC = 16384

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_ROLE
#   parameter Role in function KtMAwg_DeviceSyncConfigureMaster

KTMAWG_VAL_DEVICE_SYNC_ROLE_GROUP_MASTER = 3
KTMAWG_VAL_DEVICE_SYNC_ROLE_LOCAL_MASTER = 5
KTMAWG_VAL_DEVICE_SYNC_ROLE_OFF = 0
KTMAWG_VAL_DEVICE_SYNC_ROLE_SLAVE = 2
KTMAWG_VAL_DEVICE_SYNC_ROLE_SANDBOX = 1
KTMAWG_VAL_DEVICE_SYNC_ROLE_SYSTEM_MASTER = 4

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_STATE

KTMAWG_VAL_DEVICE_SYNC_STATE_ARM = 1
KTMAWG_VAL_DEVICE_SYNC_STATE_IDLE = 0
KTMAWG_VAL_DEVICE_SYNC_STATE_RUN = 3
KTMAWG_VAL_DEVICE_SYNC_STATE_TRIGGER = 2
KTMAWG_VAL_DEVICE_SYNC_STATE_UNKNOWN = 4

# - Defined values for
#   parameter State in function KtMAwg_GetOutputGenerationState

KTMAWG_VAL_OUTPUT_GENERATION_STATE_IDLE = 0
KTMAWG_VAL_OUTPUT_GENERATION_STATE_ARM = 1
KTMAWG_VAL_OUTPUT_GENERATION_STATE_TRIGGER = 2
KTMAWG_VAL_OUTPUT_GENERATION_STATE_RUN = 3
KTMAWG_VAL_OUTPUT_GENERATION_STATE_UNKNOWN = 4

# - Defined values for
#   parameter Val in function KtMAwg_GetWaveformMode
#   parameter Mode in function KtMAwg_SetWaveformMode

KTMAWG_VAL_WAVEFORM_MODE_CATALOGED = 0
KTMAWG_VAL_WAVEFORM_MODE_STREAMING = 1


# ***************************************************************************
# *----------------- Instrument Error And Completion Codes ------------------*
# ***************************************************************************

IVIC_WARN_BASE = 0x3FFA0000
IVIC_CROSS_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x1000
IVIC_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x2000
IVIC_SPECIFIC_WARN_BASE = IVIC_WARN_BASE + 0x4000

IVIC_ERROR_BASE = 0xBFFA0000
IVIC_CROSS_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x1000
IVIC_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x2000
IVIC_SPECIFIC_ERROR_BASE = IVIC_ERROR_BASE + 0x4000
IVIC_LXISYNC_ERROR_BASE = IVIC_ERROR_BASE + 0x2000


KTMAWG_ERROR_CANNOT_RECOVER = IVIC_ERROR_BASE + 0x0000
KTMAWG_ERROR_INSTRUMENT_STATUS = IVIC_ERROR_BASE + 0x0001
KTMAWG_ERROR_CANNOT_OPEN_FILE = IVIC_ERROR_BASE + 0x0002
KTMAWG_ERROR_READING_FILE = IVIC_ERROR_BASE + 0x0003
KTMAWG_ERROR_WRITING_FILE = IVIC_ERROR_BASE + 0x0004
KTMAWG_ERROR_INVALID_PATHNAME = IVIC_ERROR_BASE + 0x000B
KTMAWG_ERROR_INVALID_ATTRIBUTE = IVIC_ERROR_BASE + 0x000C
KTMAWG_ERROR_IVI_ATTR_NOT_WRITABLE = IVIC_ERROR_BASE + 0x000D
KTMAWG_ERROR_IVI_ATTR_NOT_READABLE = IVIC_ERROR_BASE + 0x000E
KTMAWG_ERROR_INVALID_VALUE = IVIC_ERROR_BASE + 0x0010
KTMAWG_ERROR_FUNCTION_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0011
KTMAWG_ERROR_ATTRIBUTE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0012
KTMAWG_ERROR_VALUE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0013
KTMAWG_ERROR_TYPES_DO_NOT_MATCH = IVIC_ERROR_BASE + 0x0015
KTMAWG_ERROR_NOT_INITIALIZED = IVIC_ERROR_BASE + 0x001D
KTMAWG_ERROR_UNKNOWN_CHANNEL_NAME = IVIC_ERROR_BASE + 0x0020
KTMAWG_ERROR_TOO_MANY_OPEN_FILES = IVIC_ERROR_BASE + 0x0023
KTMAWG_ERROR_CHANNEL_NAME_REQUIRED = IVIC_ERROR_BASE + 0x0044
KTMAWG_ERROR_MISSING_OPTION_NAME = IVIC_ERROR_BASE + 0x0049
KTMAWG_ERROR_MISSING_OPTION_VALUE = IVIC_ERROR_BASE + 0x004A
KTMAWG_ERROR_BAD_OPTION_NAME = IVIC_ERROR_BASE + 0x004B
KTMAWG_ERROR_BAD_OPTION_VALUE = IVIC_ERROR_BASE + 0x004C
KTMAWG_ERROR_OUT_OF_MEMORY = IVIC_ERROR_BASE + 0x0056
KTMAWG_ERROR_OPERATION_PENDING = IVIC_ERROR_BASE + 0x0057
KTMAWG_ERROR_NULL_POINTER = IVIC_ERROR_BASE + 0x0058
KTMAWG_ERROR_UNEXPECTED_RESPONSE = IVIC_ERROR_BASE + 0x0059
KTMAWG_ERROR_FILE_NOT_FOUND = IVIC_ERROR_BASE + 0x005B
KTMAWG_ERROR_INVALID_FILE_FORMAT = IVIC_ERROR_BASE + 0x005C
KTMAWG_ERROR_STATUS_NOT_AVAILABLE = IVIC_ERROR_BASE + 0x005D
KTMAWG_ERROR_ID_QUERY_FAILED = IVIC_ERROR_BASE + 0x005E
KTMAWG_ERROR_RESET_FAILED = IVIC_ERROR_BASE + 0x005F
KTMAWG_ERROR_RESOURCE_UNKNOWN = IVIC_ERROR_BASE + 0x0060
KTMAWG_ERROR_ALREADY_INITIALIZED = IVIC_ERROR_BASE + 0x0061
KTMAWG_ERROR_CANNOT_CHANGE_SIMULATION_STATE = IVIC_ERROR_BASE + 0x0062
KTMAWG_ERROR_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR = IVIC_ERROR_BASE + 0x0063
KTMAWG_ERROR_INVALID_RANGE_IN_SELECTOR = IVIC_ERROR_BASE + 0x0064
KTMAWG_ERROR_UNKOWN_NAME_IN_SELECTOR = IVIC_ERROR_BASE + 0x0065
KTMAWG_ERROR_BADLY_FORMED_SELECTOR = IVIC_ERROR_BASE + 0x0066
KTMAWG_ERROR_UNKNOWN_PHYSICAL_IDENTIFIER = IVIC_ERROR_BASE + 0x0067
KTMAWG_ERROR_INVALID_SESSION_HANDLE = IVIC_ERROR_BASE + 0x1190


KTMAWG_SUCCESS = 0
KTMAWG_WARN_NSUP_ID_QUERY = IVIC_WARN_BASE + 0x0065
KTMAWG_WARN_NSUP_RESET = IVIC_WARN_BASE + 0x0066
KTMAWG_WARN_NSUP_SELF_TEST = IVIC_WARN_BASE + 0x0067
KTMAWG_WARN_NSUP_ERROR_QUERY = IVIC_WARN_BASE + 0x0068
KTMAWG_WARN_NSUP_REV_QUERY = IVIC_WARN_BASE + 0x0069


KTMAWG_ERROR_IO_GENERAL = IVIC_SPECIFIC_ERROR_BASE + 0x0214
KTMAWG_ERROR_IO_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0215
KTMAWG_ERROR_CALIBRATION_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0217
KTMAWG_ERROR_CHECK_ERROR_QUEUE = IVIC_SPECIFIC_ERROR_BASE + 0x0218
KTMAWG_ERROR_FILE_TYPE_NOT_RECOGNIZED = IVIC_SPECIFIC_ERROR_BASE + 0x0219
KTMAWG_ERROR_FIRMWARE_UPDATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021A
KTMAWG_ERROR_FIRMWARE_UPDATE_REQUIRED = IVIC_SPECIFIC_ERROR_BASE + 0x021B
KTMAWG_ERROR_FPGA_PROGRAMMING_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021C
KTMAWG_ERROR_HARDWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x021D
KTMAWG_ERROR_HW_RESOURCE_NOT_AVAILABLE = IVIC_SPECIFIC_ERROR_BASE + 0x021E
KTMAWG_ERROR_INCOMPATIBLE_SOFTWARE_VERSION_ERROR = \
    IVIC_SPECIFIC_ERROR_BASE + 0x021F
KTMAWG_ERROR_INSTRUMENT_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0220
KTMAWG_ERROR_INSTRUMENT_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x0221
KTMAWG_ERROR_INSTRUMENT_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x0222
KTMAWG_ERROR_INTERNAL_APPLICATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0223
KTMAWG_ERROR_LICENSE_SYSTEM_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0224
KTMAWG_ERROR_LICENSE_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0225
KTMAWG_ERROR_MAX_TIME_EXCEEDED = IVIC_SPECIFIC_ERROR_BASE + 0x0226
KTMAWG_ERROR_MISSING_CLOCK_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0227
KTMAWG_ERROR_MODEL_NOT_SUPPORTED = IVIC_SPECIFIC_ERROR_BASE + 0x0228
KTMAWG_ERROR_MODULE_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0229
KTMAWG_ERROR_MODULE_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x022A
KTMAWG_ERROR_MODULE_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x022B
KTMAWG_ERROR_MODULE_VALIDATE_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x022C
KTMAWG_ERROR_OPERATION_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x022D
KTMAWG_ERROR_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022E
KTMAWG_ERROR_OUT_OF_MEMORY_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022F
KTMAWG_ERROR_PARAMETER_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0230
KTMAWG_ERROR_PERSONALITY_NOT_ACTIVE = IVIC_SPECIFIC_ERROR_BASE + 0x0231
KTMAWG_ERROR_PERSONALITY_NOT_INSTALLED = IVIC_SPECIFIC_ERROR_BASE + 0x0232
KTMAWG_ERROR_PERSONALITY_NOT_LICENSED = IVIC_SPECIFIC_ERROR_BASE + 0x0233
KTMAWG_ERROR_SELFTEST_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x0234
KTMAWG_ERROR_SOFTWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0235
KTMAWG_ERROR_TEST_FAILED_INCORRECT_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0236
KTMAWG_ERROR_THERMAL_SHUTDOWN = IVIC_SPECIFIC_ERROR_BASE + 0x0237
KTMAWG_ERROR_THERMAL_WARNING = IVIC_SPECIFIC_ERROR_BASE + 0x0238
KTMAWG_ERROR_UNABLE_TO_INITIALIZE_HARDWARE = IVIC_SPECIFIC_ERROR_BASE + 0x0239
KTMAWG_ERROR_UNRECOGNIZED_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023A
KTMAWG_ERROR_UNSUPPORTED_FEATURE = IVIC_SPECIFIC_ERROR_BASE + 0x023B
KTMAWG_ERROR_UNSUPPORTED_PROPERTY = IVIC_SPECIFIC_ERROR_BASE + 0x023C
KTMAWG_ERROR_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023D
KTMAWG_ERROR_VERIFY_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023E
KTMAWG_ERROR_WAIT_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x023F
KTMAWG_ERROR_TRIGGER_NOT_SOFTWARE = IVIC_CLASS_ERROR_BASE + 0x0001
KTMAWG_ERROR_NO_WFMS_AVAILABLE = IVIC_CLASS_ERROR_BASE + 0x0004
KTMAWG_ERROR_WFM_IN_USE = IVIC_CLASS_ERROR_BASE + 0x0008
KTMAWG_ERROR_NO_SEQS_AVAILABLE = IVIC_CLASS_ERROR_BASE + 0x0009
KTMAWG_ERROR_SEQ_IN_USE = IVIC_CLASS_ERROR_BASE + 0x000D
KTMAWG_ERROR_INVALID_WFM_CHANNEL = IVIC_CLASS_ERROR_BASE + 0x000E
KTMAWG_ERROR_COMPILATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0240
KTMAWG_ERROR_HARDWARE_STATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0241
KTMAWG_ERROR_INCONSISTENT_MULTI_CHANNEL_PROPERTY = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0242
KTMAWG_ERROR_INVALID_PARAMETER = IVIC_SPECIFIC_ERROR_BASE + 0x0243
KTMAWG_ERROR_MODULE_OUT_OF_MEMORY = IVIC_SPECIFIC_ERROR_BASE + 0x0245
KTMAWG_ERROR_SETTINGS_CONFLICT = IVIC_SPECIFIC_ERROR_BASE + 0x0246


KTMAWG_WARN_VALIDATION_FAILED = IVIC_SPECIFIC_WARN_BASE + 0x012D
"
99,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attnu5wrzJ7ApCEEC'), ('width', 700), ('height', 405), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4knmbyCUFZvxoMfseGeBtg/GCAPjGGjs1o3bbbrNcrA1BcLa7ZYleV9uYvqyzdrYl86dzizPLgRfL3GtcLDtJvwYkVynFa5S-9_vN2QamhrhfiE7lrCfll7IcFXVqPYxeo/jzkAa-Cp0Qu2jANxKMyMj6EAWEXTIZb1j_FTX3-PQQk'), ('filename', 'KT-34411A.webp'), ('size', 101610), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KlW9cuTd0Yg0EJKWTahqDw/whG3ZmhUeyXsifPQgkWPW7h7_ZV3wQStcPhRWBf-GzvuIUZHIqDfbN44NBtnrppmPwxIRi3kmBRyPXQvyULrgSxWME6O8cocBv9tKyo98Vg/CuJg2IXstjRelhYYK3XmgVs4vfAnK1dt7EzWLU01zBk'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8e3oYH10Lxww4B_CpYVL5A/MOVwAYCs6m2iWGtosP5cvm8AypKISfKMM1aXfdHChpUE-RsNQklWIqJW_QkeIkRJp1duXukgJQyhij57TSmTmwclush0WfgwJkxVT5gvmdA/FnKJn4Y2v6AYeKm_KfJw3jNbVo11nKbEV4ECoxB08lU'), ('width', 700), ('height', 405)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/klYd-Q6R7WYgknSc_74icA/DbslPdC7yaE_Yr82ojUwlPgPc9tTBtbbEJt7vYIoEJ8xCVVh0U0GDXbv_vafF2Og3ncxEaY2Vx6ROVCttCrIjBWslzwHOTW8hxRMFwQthTg/aN4hzQJ2vGpng1gOAAigziUWdjyNJ_3nRN0BkHmff3s'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34410 A Submodules,281.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34410A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34410A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782505/Instruments/Multimeters/Keysight-34410A-Submodules/Keysight-34410A-Submodules.webp,Keysight 34410A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34410A Submodules Multimeters,,,True,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34410A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34410A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34410A(Keysight34410A):
    """"""
    Alias for backwards compatibility.
    """"""
"
101,https://www.keysight.com/us/en/assets/7018-03381/data-sheets/5991-0039.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attf5gbhPROoyxfYC'), ('width', 500), ('height', 136), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QRS_Wxhszj9fHq_aHXppog/R5bQiQcekzCvweADuKnU42A3pvnFc6AfckpvcHav8HaMCy2pFDu9CYeAaY5gVZj0xTlz6dljK41GkszdkZKXopkAQ45ctyeOcu8i8febOtY/UEfKb57UlrirzV1BnOdalfNuvtr-c-yWeLpWTUzwQqQ'), ('filename', 'N5171B.5.jpg'), ('size', 12719), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2Mc8lUa_4vAeFljc43GoLg/0BBl0N8XLI857YV6tMLHIQSifHRza1stkIgFAUVlVdOvSnfrpcJCMsX2TTerdm8UA4A_K45kOXseymxB9MT5qQ/_PPqMBd2890DyDcyPrT7_Rn5MOMRuWisupSouz_aGEI'), ('width', 132), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mULftF_8E_jY9r7UOt3GfQ/SYwoO52FJmWxGohTGXnscGnqfQcS_vn6L_jIifo2AArLTHDLoHhP1OufVvfFMrozUxLFikMe4pa3swcP63a1XQ/zCZTzd61pUIIHq3chSi7G7HWrn4_w0ZB5GETzYhlWeI'), ('width', 500), ('height', 136)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZbyBwAQ7SQnLfuRDCm5TvA/euLfAB4L-xVCioM40TorA1EGh5SwoeL99yW4ZtkHPrnvC2jJke7F9RjM57D7EA_jWSmKgZtOtxqS904koRPNeg/QqBfQuhFmY2Tk0w0lP6xtYdKIN6WN5E-Vq6MNZqDNck'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"N5171B EXG X-Series RF analog mid-performance signal generators offer 9 kHz to 6 GHz frequency coverage, optimized for manufacturing with faster throughput and greater uptime at the right price.

",https://www.keysight.com/us/en/product/N5171B/exg-x-series-rf-analog-signal-generator-9-khz-6-ghz.html,N 51 X 1,287.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/N51x1.py,Qcodes,https://github.com/QCoDeS/Qcodes/tree/master/docs,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782507/Instruments/RF%20Signal%20Generator/Keysight-N5171B-EXG/Keysight-N5171B-EXG.jpg,Keysight N5171B EXG,Write a Python script that uses Qcodes to connect to a Keysight N5171B EXG RF Signal Generator,13403.0,,,,"from typing import Any, Optional

from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping
from qcodes.validators import Numbers


class N51x1(VisaInstrument):
    """"""
    This is the qcodes driver for Keysight/Agilent scalar RF sources.
    It has been tested with N5171B, N5181A, N5173B, N5183B
    """"""

    def __init__(self, name: str, address: str, min_power: int = -144, max_power: int = 19, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        self._options = self.ask(""*OPT?"")
        # Determine installed frequency option
        freq_dict = {
            ""501"": 1e9,
            ""503"": 3e9,
            ""506"": 6e9,
            ""513"": 13e9,
            ""520"": 20e9,
            ""532"": 31.8e9,
            ""540"": 40e9,
        }

        frequency_option = None
        for f_option in freq_dict.keys():
            if f_option in self._options:
                frequency_option = f_option
        if frequency_option is None:
            raise RuntimeError(""Could not determine the frequency option"")

        max_freq = freq_dict[frequency_option]

        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,max_value=max_power))

        self.add_parameter(
            ""frequency"",
            label=""Frequency"",
            get_cmd=""SOUR:FREQ?"",
            get_parser=float,
            set_cmd=""SOUR:FREQ {:.2f}"",
            unit=""Hz"",
            vals=Numbers(min_value=9e3, max_value=max_freq),
        )

        self.add_parameter('phase_offset',
                           label='Phase Offset',
                           get_cmd='SOUR:PHAS?',
                           get_parser=float,
                           set_cmd='SOUR:PHAS {:.2f}',
                           unit='rad'
                           )

        self.add_parameter(
            ""auto_freq_ref"",
            get_cmd="":ROSC:SOUR:AUTO?"",
            set_cmd="":ROSC:SOUR:AUTO {}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""rf_output"",
            get_cmd=""OUTP:STAT?"",
            set_cmd=""OUTP:STAT {}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        if ""UNW"" in self._options:
            self.add_parameter(
                ""pulse_modulation"",
                get_cmd=""PULM:STAT?"",
                set_cmd=""PULM:STAT {}"",
                val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
            )

            self.add_parameter(
                ""pulse_modulation_source"",
                get_cmd=""PULM:SOUR?"",
                set_cmd=""PULM:SOUR {}"",
                val_mapping={""internal"": ""INT"", ""external"": ""EXT""},
            )

        self.connect_message()

    def get_idn(self) -> dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN
"
103,https://www.keysight.com/us/en/assets/7018-04261/data-sheets/5991-3904.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attpk53z3NJc7FFmK'), ('width', 1223), ('height', 966), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ThF1QELziTHTObosLNFy1A/QSRdrmrpl1zXXmeobTGrL89Mudz3dbdVy8np-8HRE5wDpiQhMzMiF_VyuI7YMdG5YJCUX4Pyi-j-rbI7lLrQ8UOpph4JorcapCggdhHceCELDT4lNqTfGtYRLCpnZ8Wt/h7kSd588kwo44WOB1s0xPRRY_iWpL8HqDHk7mz8Vn6o'), ('filename', 'Infiniium-oscilloscope-series.jpeg'), ('size', 154472), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8KSMUPxVUmmUbUmLagNoFQ/0i0_seYX5gtAyc1-8oVPBx2_VO6c9Vcryfzg9BYzFv9d9OFPnwUPnUMq-NNy8KHTxIwJOZ8ZhnBxcBeMty4B1g/tNjWmmpwRYQnWZ3Rkgw9C45Cx9nvKazg_7R2A7iCM9w'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Fp2ymotq4J_5UJZ8rdtGrw/MTx4QLBrspcZNVGEQMhXPJ3uhPQSZXnlyFXdCc9k6GPlYcYDXg5eKlH11nBuo5_TwDGOI0WPCztEJRBocUY_eA/lmVtAbjowTz4RknBMauwuVwnwfMmQDTEvApl9s6WVkQ'), ('width', 648), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ruj4HlPGh7yCaGnuhVH8_g/m6ypL-5Dgf3cBwdiMxn6ZqGuhp3AkbsFJ-CX0sBzJ-tLu4QL2cLm3rg6zjVyqRcb9htdRf22K1KEgCBPzCGpQg/uVrcXtkw6MRwqPJhwwDZiEf1rHO4D_Ty4lVxV8T2Bfk'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"Infiniium series oscilloscopes feature application-specific software that allows you to gain valuable insight into your design. Whether you are solving tough jitter or noise problems, removing loss due to cables or probes, or simply looking at protocol, this series has the software tools to help you realize your best design.
",https://www.keysight.com/us/en/products/oscilloscopes/infiniium-real-time-oscilloscopes.html,Infiniium,292.0,['Oscilloscopes'],"An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Infiniium.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightInfiniium,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782509/Instruments/Oscilloscopes/Infiniium-oscilloscopes-Series/Infiniium-oscilloscopes-Series.jpg,Infiniium oscilloscopes Series,Write a Python script that uses Qcodes to connect to a Infiniium oscilloscopes Series Oscilloscopes,,,,,"import re
from collections.abc import Sequence
from typing import Any, Literal, Optional, Union

import numpy as np
from pyvisa import VisaIOError
from pyvisa.constants import StatusCode

import qcodes.validators as vals
from qcodes.instrument import (
    ChannelList,
    InstrumentBase,
    InstrumentChannel,
    InstrumentModule,
    VisaInstrument,
)
from qcodes.parameters import (
    Parameter,
    ParameterBase,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.utils import deprecate


class DSOTimeAxisParam(Parameter):
    """"""
    Time axis parameter for the Infiniium series DSO.
    """"""

    def __init__(self, xorigin: float, xincrement: float, points: int, **kwargs: Any):
        """"""
        Initialize time axis. If values are unknown, they can be initialized to zero and
        filled in later.
        """"""
        super().__init__(**kwargs)

        self.xorigin = xorigin
        self.xincrement = xincrement
        self.points = points

    def get_raw(self) -> np.ndarray:
        """"""
        Return the array corresponding to this time axis.
        """"""
        return np.linspace(
            self.xorigin,
            self.xorigin + self.points * self.xincrement,
            self.points,
            endpoint=False,
        )


class DSOFrequencyAxisParam(Parameter):
    """"""
    Frequency axis parameter for the Infiniium series DSO.
    """"""

    def __init__(self, xorigin: float, xincrement: float, points: int, **kwargs: Any):
        """"""
        Initialize frequency axis. If values are unknown, they can be initialized
        to zero and filled in later.
        """"""
        super().__init__(**kwargs)

        self.xorigin = xorigin
        self.xincrement = xincrement
        self.points = points

    def get_raw(self) -> np.ndarray:
        """"""
        Return the array corresponding to this time axis.
        """"""
        return np.linspace(
            self.xorigin,
            self.xorigin + self.points * self.xincrement,
            self.points,
            endpoint=False,
        )


class DSOTraceParam(ParameterWithSetpoints):
    """"""
    Trace parameter for the Infiniium series DSO
    """"""

    UNIT_MAP = {0: ""UNKNOWN"", 1: ""V"", 2: ""s"", 3: ""''"", 4: ""A"", 5: ""dB""}

    def __init__(
        self,
        name: str,
        instrument: Union[""KeysightInfiniiumChannel"", ""KeysightInfiniiumFunction""],
        channel: str,
        **kwargs: Any,
    ):
        """"""
        Initialize DSOTraceParam bound to a specific channel.
        """"""
        self._ch_valid = False
        super().__init__(name, instrument=instrument, **kwargs)
        self._channel = channel
        # This parameter will be updated prior to being retrieved if
        # self.root_instrument.auto_digitize is true.
        self._points = 0
        self._yoffset = 0.0
        self._yincrement = 0.0
        self._unit = 0

    @property
    def setpoints(self) -> Sequence[ParameterBase]:
        """"""
        Overwrite setpoint parameter to update setpoints if auto_digitize is true
        """"""
        instrument = self.instrument
        if isinstance(instrument, KeysightInfiniiumChannel):
            root_instrument: ""KeysightInfiniium""
            root_instrument = self.root_instrument  # type: ignore[assignment]
            cache_setpoints = root_instrument.cache_setpoints()
            if not cache_setpoints:
                self.update_setpoints()
            return (instrument.time_axis,)
        elif isinstance(instrument, KeysightInfiniiumFunction):
            if instrument.function().startswith(""FFT""):
                self.update_fft_setpoints()
                return (instrument.frequency_axis,)
            else:
                self.update_setpoints()
                return (instrument.time_axis,)
        raise RuntimeError(""Invalid type for parent instrument."")

    @setpoints.setter
    def setpoints(self, val: Any) -> None:
        """"""
        Stub to allow initialization. Ignore any set attempts on setpoint as we
        figure it out on the fly.
        """"""
        return

    @property
    def unit(self) -> str:
        """"""
        Return the units for this measurement.
        """"""
        if self._ch_valid is False:
            return ""''""
        elif self._unit != 0:
            return self.UNIT_MAP[self._unit]
        elif self.instrument is not None:
            self.instrument.write(f"":WAV:SOUR {self._channel}"")
            return self.instrument.ask("":WAV:YUN?"")
        return ""''""

    @unit.setter
    def unit(self, val: Any) -> None:
        """"""
        Stub to allow initialization.
        """"""
        return

    @deprecate(""DSOTraceParam.update_setpoints"")
    def prepare_curvedata(self) -> None:
        """"""
        Deprecated method to update waveform parameters.
        """"""
        self.update_setpoints()

    def update_setpoints(self, preamble: Optional[Sequence[str]] = None) -> None:
        """"""
        Update waveform parameters. Must be called before data
        acquisition if instr.cache_setpoints is False
        """"""
        instrument: Union[KeysightInfiniiumChannel, KeysightInfiniiumFunction]
        instrument = self.instrument  # type: ignore[assignment]
        if preamble is None:
            instrument.write(f"":WAV:SOUR {self._channel}"")
            preamble = instrument.ask("":WAV:PRE?"").strip().split("","")
        self._points = int(preamble[2])
        self._yincrement = float(preamble[7])
        self._yoffset = float(preamble[8])
        self._unit = int(preamble[21])
        instrument.time_axis.points = int(preamble[2])
        instrument.time_axis.xorigin = float(preamble[5])
        instrument.time_axis.xincrement = float(preamble[4])
        self._ch_valid = True

    def update_fft_setpoints(self) -> None:
        """"""
        Update waveform parameters for an FFT.
        """"""
        instrument: KeysightInfiniiumFunction = self.instrument  # type: ignore[assignment]
        instrument.write(f"":WAV:SOUR {self._channel}"")
        preamble = instrument.ask("":WAV:PRE?"").strip().split("","")
        self.update_setpoints(preamble)
        instrument.frequency_axis.points = int(preamble[2])
        instrument.frequency_axis.xorigin = float(preamble[5])
        instrument.frequency_axis.xincrement = float(preamble[4])

    def get_raw(self) -> np.ndarray:
        """"""
        Get waveform data from scope
        """"""
        if self.instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr: ""KeysightInfiniium"" = self.root_instrument  # type: ignore[assignment]
        # Check if we can use cached trace parameters
        if not root_instr.cache_setpoints():
            self.update_setpoints()
        if not self._ch_valid:
            raise RuntimeError(
                ""Trace parameters are unknown. If cache_setpoints is True, ""
                ""you must manually call instr.chX.update_setpoints at least""
                ""once prior to measurement.""
            )

        # Check if we should run a new sweep
        if root_instr.auto_digitize():
            root_instr.digitize()
        # Ask for waveform data
        root_instr.write(f"":WAV:SOUR {self._channel}"")
        root_instr.write("":WAV:DATA?"")
        # Ignore first two bytes, which should be ""#0""
        _ = root_instr.visa_handle.read_bytes(2)
        data: np.ndarray
        data = root_instr.visa_handle.read_binary_values(  # type: ignore[assignment]
            ""h"",
            container=np.ndarray,
            header_fmt=""empty"",
            expect_termination=True,
            data_points=self._points,
        )
        data = data.astype(np.float64)
        data = (data * self._yincrement) + self._yoffset
        return data


class AbstractMeasurementSubsystem(InstrumentModule):
    """"""
    Submodule containing the measurement subsystem commands and associated
    parameters.

    Note: these commands are executed on the waveform in the scope buffer.
    If you need to ensure a fresh value, run dso.digitize() prior to reading
    the measurement value.
    """"""

    def __init__(self, parent: InstrumentBase, name: str, **kwargs: Any) -> None:
        """"""
        Add parameters to measurement subsystem. Note: This should not be initialized
        directly, rather initialize BoundMeasurementSubsystem
        or UnboundMeasurementSubsystem.
        """"""
        super().__init__(parent, name, **kwargs)

        ###################################
        # Voltage Parameters
        self.amplitude = Parameter(
            name=""amplitude"",
            instrument=self,
            label=""Voltage amplitude"",
            get_cmd=self._create_query(""VAMP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.average = Parameter(
            name=""average"",
            instrument=self,
            label=""Voltage average"",
            get_cmd=self._create_query(""VAV"", ""DISP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.base = Parameter(
            name=""base"",
            instrument=self,
            label=""Statistical base"",
            get_cmd=self._create_query(""VBAS""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Threshold Voltage Measurements - this measurement ignores overshoot
        # in the data
        self.vlow = Parameter(
            name=""vlow"",
            instrument=self,
            label=""Lower threshold voltage"",
            get_cmd=self._create_query(""VLOW""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vmid = Parameter(
            name=""vmid"",
            instrument=self,
            label=""Middle threshold voltage"",
            get_cmd=self._create_query(""VMID""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vup = Parameter(
            name=""vup"",
            instrument=self,
            label=""Upper threshold voltage"",
            get_cmd=self._create_query(""VUPP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Limit values - the minimum/maximum shown on screen
        self.vmin = Parameter(
            name=""vmin"",
            instrument=self,
            label=""Voltage minimum"",
            get_cmd=self._create_query(""VMIN""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vmax = Parameter(
            name=""vmax"",
            instrument=self,
            label=""Voltage maximum"",
            get_cmd=self._create_query(""VMAX""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Waveform Parameters
        self.overshoot = Parameter(
            name=""overshoot"",
            instrument=self,
            label=""Voltage overshoot"",
            get_cmd=self._create_query(""VOV""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vpp = Parameter(
            name=""vpp"",
            instrument=self,
            label=""Voltage peak-to-peak"",
            get_cmd=self._create_query(""VPP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vrms = Parameter(
            name=""vrms"",
            instrument=self,
            label=""Voltage RMS"",
            get_cmd=self._create_query(""VRMS"", ""CYCL,AC""),
            get_parser=float,
            unit=""V_rms"",
            snapshot_value=False,
        )
        self.vrms_dc = Parameter(
            name=""vrms_dc"",
            instrument=self,
            label=""Voltage RMS with DC Component"",
            get_cmd=self._create_query(""VRMS"", ""CYCL,DC""),
            get_parser=float,
            unit=""V_rms"",
            snapshot_value=False,
        )

        ###################################
        # Time Parameters
        self.rise_time = Parameter(
            name=""rise_time"",
            instrument=self,
            label=""Rise time"",
            get_cmd=self._create_query(""RIS""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.fall_time = Parameter(
            name=""fall_time"",
            instrument=self,
            label=""Fall time"",
            get_cmd=self._create_query(""FALL""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.duty_cycle = Parameter(
            name=""duty_cycle"",
            instrument=self,
            label=""Duty Cycle"",
            get_cmd=self._create_query(""DUTY""),
            get_parser=float,
            unit=""%"",
            snapshot_value=False,
        )
        self.period = Parameter(
            name=""period"",
            instrument=self,
            label=""Period"",
            get_cmd=self._create_query(""PER""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.frequency = Parameter(
            name=""frequency"",
            instrument=self,
            label=""Signal frequency"",
            get_cmd=self._create_query(""FREQ""),
            get_parser=float,
            unit=""Hz"",
            docstring=""""""
                                     measure the frequency of the first
                                     complete cycle on the screen using
                                     the mid-threshold levels of the waveform
                                     """""",
            snapshot_value=False,
        )
        self.slew_rate = Parameter(
            name=""slew_rate"",
            instrument=self,
            label=""Slew rate"",
            get_cmd=self._create_query(""SLEW""),
            get_parser=float,
            unit=""S"",
            snapshot_value=False,
        )

        ###################################
        # Deprecated parameter aliases
        self.rms = self.vrms_dc
        self.rms_no_dc = self.vrms
        self.min = self.vmin
        self.middle = self.vmid
        self.max = self.vmax
        self.lower = self.vlow

    def _create_query(self, cmd: str, pre_cmd: str = """", post_cmd: str = """") -> str:
        """"""
        Create a query string with the correct source included
        """"""
        chan_str = self._channel
        if chan_str:
            if pre_cmd:
                chan_str = f"",{chan_str}""
            if post_cmd:
                chan_str = f""{chan_str},""
        else:
            if pre_cmd and post_cmd:
                pre_cmd = f""{pre_cmd},""
        return f"":MEAS:{cmd}? {pre_cmd}{chan_str}{post_cmd}"".strip()


class KeysightInfiniiumBoundMeasurement(AbstractMeasurementSubsystem):
    def __init__(
        self,
        parent: Union[""KeysightInfiniiumChannel"", ""KeysightInfiniiumFunction""],
        name: str,
        **kwargs: Any,
    ):
        """"""
        Initialize measurement subsystem bound to a specific channel
        """"""
        # Bind the channel
        self._channel = parent.channel_name

        # Initialize measurement parameters
        super().__init__(parent, name, **kwargs)


BoundMeasurement = KeysightInfiniiumBoundMeasurement
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumUnboundMeasurement(AbstractMeasurementSubsystem):
    def __init__(self, parent: ""KeysightInfiniium"", name: str, **kwargs: Any):
        """"""
        Initialize measurement subsystem where target is set by the parameter `source`.
        """"""
        # Blank channel
        self._channel = """"

        # Initialize measurement parameters
        super().__init__(parent, name, **kwargs)

        self.source = Parameter(
            name=""source"",
            instrument=self,
            label=""Primary measurement source"",
            set_cmd=self._set_source,
            get_cmd=self._get_source,
            snapshot_value=False,
        )

    def _validate_source(self, source: str) -> str:
        """"""Validate and set the source.""""""
        valid_channels = f""CHAN[1-{self.root_instrument.no_channels}]""
        if re.fullmatch(valid_channels, source):
            if not int(self.ask(f""CHAN{source[-1]}:DISP?"")):
                raise ValueError(f""Channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""DIFF[1-2]"", source):
            diff_chan = (int(source[-1]) - 1) * 2 + 1
            if int(self.ask(f""CHAN{diff_chan}:DIFF?"")) != 1:
                raise ValueError(f""Differential channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""COMM[1-2]"", source):
            diff_chan = (int(source[-1]) - 1) * 2 + 1
            if int(self.ask(f""CHAN{diff_chan}:DIFF?"")) != 1:
                raise ValueError(f""Differential channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""WMEM[1-4]"", source):
            return source
        match = re.fullmatch(""FUNC([1-9]{1,2})"", source)
        if match:
            func_chan = int(match.groups()[0])
            if not (1 <= func_chan <= 16):
                raise ValueError(
                    f""Function number should be in the range 1-16. Got {func_chan}.""
                )
            if not int(self.ask(f""FUNC{func_chan}:DISP?"")):
                raise ValueError(f""Function {func_chan} is not enabled."")
            return f""FUNC{func_chan}""

        raise ValueError(
            f""Invalid measurement source {source}. Valid values are: (""
            ""CHAN[1-4], DIFF[1-2], COMM[1-2], WMEM[1-4], FUNC[1-16]).""
        )

    def _set_source(self, source: str) -> None:
        source = self._validate_source(source)
        self._channel = source

        # Then set the measurement source
        self.write(f"":MEAS:SOUR {self._channel}"")

    def _get_source(self) -> str:
        if self._channel == """":
            source = self.ask("":MEAS:SOUR?"")
            self._channel = source.strip().split("","")[0]
        return self._channel


UnboundMeasurement = KeysightInfiniiumUnboundMeasurement
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumFunction(InstrumentChannel):
    def __init__(
        self, parent: ""KeysightInfiniium"", name: str, channel: int, **kwargs: Any
    ):
        """"""
        Initialize an infiniium channel.
        """"""
        self._channel = channel
        super().__init__(parent, name, **kwargs)

        # display
        self.display = Parameter(
            name=""display"",
            instrument=self,
            label=f""Function {channel} display on/off"",
            set_cmd=f""FUNC{channel}:DISP {{}}"",
            get_cmd=f""FUNC{channel}:DISP?"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        # Retrieve basic settings of the function
        self.function = Parameter(
            name=""function"",
            instrument=self,
            label=f""Function {channel} function"",
            get_cmd=self._get_func,
            vals=vals.Strings(),
        )
        self.source = Parameter(
            name=""source"",
            instrument=self,
            label=f""Function {channel} source"",
            get_cmd=f""FUNC{channel}?"",
        )

        # Trace settings
        self.points = Parameter(
            name=""points"",
            instrument=self,
            label=f""Function {channel} points"",
            get_cmd=self._get_points,
        )
        self.frequency_axis = DSOFrequencyAxisParam(
            name=""frequency_axis"",
            instrument=self,
            label=""Frequency"",
            unit=""Hz"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )
        self.time_axis = DSOTimeAxisParam(
            name=""time_axis"",
            instrument=self,
            label=""Time"",
            unit=""s"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )
        self.trace = DSOTraceParam(
            name=""trace"",
            instrument=self,
            label=f""Function {channel} trace"",
            channel=self.channel_name,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )

        # Measurement subsystem
        self.add_submodule(
            ""measure"", KeysightInfiniiumBoundMeasurement(self, ""measure"")
        )

    @property
    def channel(self) -> int:
        return self._channel

    @property
    def channel_name(self) -> str:
        return f""FUNC{self._channel}""

    def _get_points(self) -> int:
        """"""
        Return the number of points in the current function. This may be
        different to the number of points in the source as often functions
        modify the number of points.
        """"""
        self.write(f"":WAV:SOUR {self.channel_name}"")
        return int(self.ask("":WAV:POIN?""))

    def _get_func(self) -> str:
        """"""
        Return the function applied to the sources for this function
        """"""
        try:
            self.write("":SYST:HEAD ON"")
            func, _ = self.ask(f"":{self.channel_name}?"").strip().split()
            match = re.fullmatch(f"":{self.channel_name}:([\\w]+)"", func)
            if match:
                return match.groups()[0]
            raise ValueError(
                f""Couldn't extract function for {self.channel_name}. Got {func}""
            )
        finally:
            self.write("":SYST:HEAD OFF"")


InfiniiumFunction = KeysightInfiniiumFunction
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumChannel(InstrumentChannel):
    def __init__(
        self, parent: ""KeysightInfiniium"", name: str, channel: int, **kwargs: Any
    ):
        """"""
        Initialize an infiniium channel.
        """"""
        self._channel = channel

        super().__init__(parent, name, **kwargs)
        # display
        self.display = Parameter(
            name=""display"",
            instrument=self,
            label=f""Channel {channel} display on/off"",
            set_cmd=f""CHAN{channel}:DISP {{}}"",
            get_cmd=f""CHAN{channel}:DISP?"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        # scaling
        self.offset = Parameter(
            name=""offset"",
            instrument=self,
            label=f""Channel {channel} offset"",
            set_cmd=f""CHAN{channel}:OFFS {{}}"",
            unit=""V"",
            get_cmd=f""CHAN{channel}:OFFS?"",
            get_parser=float,
        )
        self.range = Parameter(
            name=""range"",
            instrument=self,
            label=f""Channel {channel} range"",
            unit=""V"",
            set_cmd=f""CHAN{channel}:RANG {{}}"",
            get_cmd=f""CHAN{channel}:RANG?"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Trigger level
        self.trigger_level = Parameter(
            name=""trigger_level"",
            instrument=self,
            label=f""Channel {channel} trigger level"",
            unit=""V"",
            set_cmd=f"":TRIG:LEV CHAN{channel},{{}}"",
            get_cmd=f"":TRIG:LEV? CHAN{channel}"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Trace data
        self.time_axis = DSOTimeAxisParam(
            name=""time_axis"",
            instrument=self,
            label=""Time"",
            unit=""s"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.parent.acquire_points,)),
            snapshot_value=False,
        )
        self.trace = DSOTraceParam(
            name=""trace"",
            instrument=self,
            label=f""Channel {channel} trace"",
            unit=""V"",
            channel=self.channel_name,
            vals=vals.Arrays(shape=(self.parent.acquire_points,)),
            snapshot_value=False,
        )

        # Measurement subsystem
        self.add_submodule(
            ""measure"", KeysightInfiniiumBoundMeasurement(self, ""measure"")
        )

    @property
    def channel(self) -> int:
        return self._channel

    @property
    def channel_name(self) -> str:
        return f""CHAN{self._channel}""

    def update_setpoints(self) -> None:
        """"""
        Update time axis and offsets for this channel.
        Calling this function is required when instr.cache_setpoints is True
        whenever the scope parameters are changed.
        """"""
        self.trace.update_setpoints()


InfiniiumChannel = KeysightInfiniiumChannel
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniium(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Keysight Infiniium oscilloscopes
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        timeout: float = 20,
        channels: int = 4,
        silence_pyvisapy_warning: bool = False,
        **kwargs: Any,
    ):
        """"""
        Initialises the oscilloscope.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: Visa timeout, in secs.
            channels: The number of channels on the scope.
            silence_pyvisapy_warning: Don't warn about pyvisa-py at startup
        """"""
        super().__init__(name, address, timeout=timeout, terminator=""\n"", **kwargs)
        self.connect_message()

        # Check if we are using pyvisa-py as our visa lib and warn users that
        # this may cause long digitize operations to fail
        if (
            self.visa_handle.visalib.library_path == ""py""
            and not silence_pyvisapy_warning
        ):
            self.log.warning(
                ""Timeout not handled correctly in pyvisa_py. This may cause""
                "" long acquisitions to fail. Either use ni/keysight visalib""
                "" or set timeout to longer than longest expected acquisition""
                "" time.""
            )

        # switch the response header off else none of our parameters will work
        self.write("":SYSTem:HEADer OFF"")

        # Then set up the data format used to retrieve waveforms
        self.write("":WAVEFORM:FORMAT WORD"")
        self.write("":WAVEFORM:BYTEORDER LSBFirst"")
        self.write("":WAVEFORM:STREAMING ON"")

        # Query the oscilloscope parameters
        # Set sample rate, bandwidth and memory depth limits
        self._query_capabilities()
        # Number of channels can't be queried on most older scopes. Use a parameter
        # for now.
        self.no_channels = channels

        # Run state
        self.run_mode = Parameter(
            name=""run_mode"",
            instrument=self,
            label=""run mode"",
            get_cmd="":RST?"",
            vals=vals.Enum(""RUN"", ""STOP"", ""SING""),
        )

        # Timing Parameters
        self.timebase_range = Parameter(
            name=""timebase_range"",
            instrument=self,
            label=""Range of the time axis"",
            unit=""s"",
            get_cmd="":TIM:RANG?"",
            set_cmd="":TIM:RANG {}"",
            vals=vals.Numbers(5e-12, 20),
            get_parser=float,
        )
        self.timebase_position = Parameter(
            name=""timebase_position"",
            instrument=self,
            label=""Offset of the time axis"",
            unit=""s"",
            get_cmd="":TIM:POS?"",
            set_cmd="":TIM:POS {}"",
            vals=vals.Numbers(),
            get_parser=float,
        )
        self.timebase_roll_enabled = Parameter(
            name=""timebase_roll_enabled"",
            instrument=self,
            label=""Is rolling mode enabled"",
            get_cmd="":TIM:ROLL:ENABLE?"",
            set_cmd="":TIM:ROLL:ENABLE {}"",
            val_mapping={True: 1, False: 0},
        )

        # Trigger
        self.trigger_mode = Parameter(
            name=""trigger_mode"",
            instrument=self,
            label=""Trigger mode"",
            get_cmd="":TRIG:MODE?"",
        )
        self.trigger_sweep = Parameter(
            name=""trigger_sweep"",
            instrument=self,
            label=""Trigger sweep mode"",
            get_cmd="":TRIG:SWE?"",
            set_cmd="":TRIG:SWE {}"",
            vals=vals.Enum(""AUTO"", ""TRIG""),
        )
        self.trigger_state = Parameter(
            name=""trigger_state"",
            instrument=self,
            label=""Trigger state"",
            get_cmd="":AST?"",
            vals=vals.Enum(""ARM"", ""TRIG"", ""ATRIG"", ""ADONE""),
            snapshot_value=False,
        )

        # Edge trigger parameters
        # Note that for now we only support parameterized edge triggers - this may
        # be something worth expanding.
        # To set trigger level, use the ""trigger_level"" parameter in each channel
        self.trigger_edge_source = Parameter(
            name=""trigger_edge_source"",
            instrument=self,
            label=""Source channel for the edge trigger"",
            get_cmd="":TRIGger:EDGE:SOURce?"",
            set_cmd="":TRIGger:EDGE:SOURce {}"",
            vals=vals.Enum(
                *(
                    [f""CHAN{i}"" for i in range(1, 4 + 1)]
                    + [f""DIG{i}"" for i in range(16 + 1)]
                    + [""AUX"", ""LINE""]
                )
            ),
        )
        self.trigger_edge_slope = Parameter(
            name=""trigger_edge_slope"",
            instrument=self,
            label=""slope of the edge trigger"",
            get_cmd="":TRIGger:EDGE:SLOPe?"",
            set_cmd="":TRIGger:EDGE:SLOPe {}"",
            vals=vals.Enum(""POS"", ""POSITIVE"", ""NEG"", ""NEGATIVE"", ""EITH""),
        )
        self.trigger_level_aux = Parameter(
            name=""trigger_level_aux"",
            instrument=self,
            label=""Tirgger level AUX"",
            unit=""V"",
            get_cmd="":TRIGger:LEVel? AUX"",
            set_cmd="":TRIGger:LEVel AUX,{}"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Aquisition
        # If sample points, rate and timebase_scale are set in an
        # incomensurate way, the scope only displays part of the waveform
        self.acquire_points = Parameter(
            name=""acquire_points"",
            instrument=self,
            label=""sample points"",
            get_cmd="":ACQ:POIN?"",
            set_cmd="":ACQ:POIN {}"",
            get_parser=int,
            vals=vals.Numbers(min_value=self.min_pts, max_value=self.max_pts),
        )
        self.sample_rate = Parameter(
            name=""sample_rate"",
            instrument=self,
            label=""sample rate"",
            get_cmd="":ACQ:SRAT?"",
            set_cmd="":ACQ:SRAT {}"",
            unit=""Hz"",
            get_parser=float,
            vals=vals.Numbers(min_value=self.min_srat, max_value=self.max_srat),
        )
        # Note: newer scopes allow a per-channel bandwidth. This is not implemented yet.
        self.bandwidth = Parameter(
            name=""bandwidth"",
            instrument=self,
            label=""bandwidth"",
            get_cmd="":ACQ:BAND?"",
            set_cmd="":ACQ:BAND {}"",
            unit=""Hz"",
            get_parser=float,
            vals=vals.Numbers(min_value=self.min_bw, max_value=self.max_bw),
        )
        self.acquire_interpolate = Parameter(
            name=""acquire_interpolate"",
            instrument=self,
            get_cmd="":ACQ:INTerpolate?"",
            set_cmd="":ACQuire:INTerpolate {}"",
            vals=vals.Enum(0, 1, ""INT1"", ""INT2"", ""INT4"", ""INT8"", ""INT16"", ""INT32""),
        )
        self.acquire_mode = Parameter(
            name=""acquire_mode"",
            instrument=self,
            label=""Acquisition mode"",
            get_cmd=""ACQuire:MODE?"",
            set_cmd=""ACQuire:MODE {}"",
            vals=vals.Enum(
                ""ETIMe"",
                ""RTIMe"",
                ""PDETect"",
                ""HRESolution"",
                ""SEGMented"",
                ""SEGPdetect"",
                ""SEGHres"",
            ),
        )
        self.average = Parameter(
            name=""average"",
            instrument=self,
            label=""Averages"",
            get_cmd=self._get_avg,
            set_cmd=self._set_avg,
            vals=vals.Ints(min_value=1, max_value=10486575),
        )

        # Automatically digitize before acquiring a trace
        self.auto_digitize: Parameter = Parameter(
            name=""auto_digitize"",
            instrument=self,
            label=""Auto digitize"",
            set_cmd=None,
            get_cmd=None,
            val_mapping=create_on_off_val_mapping(),
            docstring=(
                ""Digitize before each waveform download. ""
                ""If you need to acquire from multiple channels simultaneously ""
                ""or you wish to acquire with the scope running freely, ""
                ""set this value to False.""
            ),
            initial_value=True,
        )
        self.cache_setpoints: Parameter = Parameter(
            name=""cache_setpoints"",
            instrument=self,
            label=""Cache setpoints"",
            set_cmd=None,
            get_cmd=None,
            val_mapping=create_on_off_val_mapping(),
            docstring=(
                ""Cache setpoints. If false, the preamble is queried before each""
                "" acquisition, which may add latency to measurements. If you""
                "" are taking repeated measurements, set this to True and update""
                "" setpoints manually by calling `instr.chX.update_setpoints()`.""
            ),
            initial_value=False,
        )

        # Channels
        _channels = ChannelList(
            self, ""channels"", KeysightInfiniiumChannel, snapshotable=False
        )
        for i in range(1, self.no_channels + 1):
            channel = KeysightInfiniiumChannel(self, f""chan{i}"", i)
            _channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)
        self.add_submodule(""channels"", _channels.to_channel_tuple())

        # Functions
        _functions = ChannelList(
            self, ""functions"", KeysightInfiniiumFunction, snapshotable=False
        )
        for i in range(1, 16 + 1):
            function = KeysightInfiniiumFunction(self, f""func{i}"", i)
            _functions.append(function)
            self.add_submodule(f""func{i}"", function)
        # Have to call channel list ""funcs"" here as functions is a
        # reserved name in Instrument.
        self.add_submodule(""funcs"", _functions.to_channel_tuple())

        # Submodules
        meassubsys = KeysightInfiniiumUnboundMeasurement(self, ""measure"")
        self.add_submodule(""measure"", meassubsys)

    def _query_capabilities(self) -> None:
        """"""
        Query scope capabilities (sample rate, bandwidth, memory depth)
        """"""
        try:
            # Bandwidth
            self.min_bw, self.max_bw = 0.0, 99.0e9  # Set default limits
            bw = self.ask("":ACQ:BAND:TESTLIMITS?"")
            match = re.fullmatch(
                r""1,<numeric>([0-9.]+E\+[0-9]+):([0-9.]+E\+[0-9]+)"", bw
            )
            if match:
                self.min_bw, self.max_bw = (float(f) for f in match.groups())
                self.log.info(f""Scope BW: {self.min_bw}-{self.max_bw}"")
                self._meta_attrs.extend((""min_bw"", ""max_bw""))
            else:
                self.log.warning(
                    f""Unable to query bandwidth limits (inv. format ({bw})). ""
                    f""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query bandwidth limits ({e}). Setting limits to default.""
            )

        # Memory depth
        try:
            self.min_pts, self.max_pts = 16, 1_000_000_000
            mem = self.ask("":ACQ:POIN:TESTLIMITS?"")
            match = re.match(""1,<numeric>([0-9]+):([0-9]+)"", mem)
            if match:
                self.min_pts, self.max_pts = (int(p) for p in match.groups())
                self.log.info(f""Scope memory: {self.min_pts}-{self.max_pts}"")
                self._meta_attrs.extend((""min_pts"", ""max_pts""))
            else:
                self.log.warning(
                    f""Unable to query memory depth (inv. format ({mem})). ""
                    ""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query memory depth ({e}). Setting limits to default.""
            )

        # Sample Rate
        try:
            # Set BW to auto in order to query this
            bw_set: Union[float, Literal[""AUTO""]] = float(self.ask("":ACQ:BAND?""))
            if np.isclose(bw_set, self.max_bw):
                # Auto returns max bandwidth
                bw_set = ""AUTO""
            self.write("":ACQ:BAND AUTO"")
            self.min_srat, self.max_srat = 10.0, 99.0e9  # Set large limits
            srat = self.ask("":ACQ:SRAT:TESTLIMITS?"")
            self.write(f"":ACQ:BAND {bw_set}"")
            match = re.fullmatch(
                r""1,<numeric>([0-9.]+E\+[0-9]+):([0-9.]+E\+[0-9]+)"", srat
            )
            if match:
                self.min_srat, self.max_srat = (float(f) for f in match.groups())
                self.log.info(f""Scope sample rate: {self.min_srat}-{self.max_srat}"")
                self._meta_attrs.extend((""min_srat"", ""max_srat""))
            else:
                self.log.warning(
                    f""Unable to query sample rate (inv. format ({srat})). ""
                    ""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query sample rate ({e}). Setting limits to default.""
            )

    def _get_avg(self) -> int:
        """"""
        Return the number of averages, or 1 if averaging is disabled.
        """"""
        enabled = int(self.ask("":ACQ:AVER?""))
        if not enabled:
            return 1
        else:
            return int(self.ask("":ACQ:AVER:COUN?""))

    def _set_avg(self, count: int) -> None:
        """"""
        Set the number of averages, or disable if 1.
        """"""
        if count == 1:
            self.write("":ACQ:AVER 0"")
        else:
            self.write(f"":ACQ:AVER:COUN {count}"")
            self.write("":ACQ:AVER 1"")

    # Simple oscilloscope commands
    def run(self) -> None:
        """"""
        Set the scope in run mode.
        """"""
        self.write("":RUN"")
        self.run_mode()

    def stop(self) -> None:
        """"""
        Set the scope in stop mode.
        """"""
        self.write("":STOP"")
        self.run_mode()

    def single(self) -> None:
        """"""
        Take a single acquisition
        """"""
        self.write("":SING"")
        self.run_mode()

    def update_all_setpoints(self) -> None:
        """"""
        Update the setpoints for all enabled channels.
        This method may be run at the beginning of a measurement rather
        than looping through each channel manually.
        """"""
        for channel in self.channels:
            if channel.display():
                channel.update_setpoints()

    def digitize(self, timeout: Optional[int] = None) -> None:
        """"""
        Digitize a full waveform and block until the acquisition is complete.

        Warning: If using pyvisa_py as your visa library, this will not work with
        acquisitions longer than a single timeout period. If you require long
        acquisitions either use Keysight/NI Visa or set timeout to be longer than
        the expected acquisition time.
        """"""
        old_timeout = self.visa_handle.timeout
        if timeout is not None:
            self.visa_handle.timeout = timeout  # 1 second timeout
        try:
            self.visa_handle.write("":DIGITIZE;*OPC?"")
            ret = None
            # Wait until we receive the ""complete"" reply
            while ret != ""1"":
                try:
                    ret = self.visa_handle.read()
                except VisaIOError as e:
                    # Ignore timeout errors - we could still be waiting for a trigger
                    # or taking a long acquisition
                    if e.error_code != StatusCode.error_timeout:
                        self.log.exception(
                            ""Unexpected VisaError while waiting for acquisition.""
                        )
                        raise  # Raise all other visa errors
        except KeyboardInterrupt:
            self.log.error(
                ""Keyboard interrupt while waiting to digitize. Check your trigger?""
            )
            raise  # Pass error upwards
        finally:
            # Clear the device to unblock any failed digitize
            self.device_clear()
            if timeout is not None:
                self.visa_handle.timeout = old_timeout


Infiniium = KeysightInfiniium
""""""
Alias for backwards compatibility
""""""
"
104,https://www.thinksrs.com/downloads/pdfs/catalog/SR560c.pdf,"https://en.wikipedia.org/wiki/Preamplifier#:~:text=A%20preamplifier%2C%20also%20known%20as,power%20amplifier%20and%20a%20loudspeaker.","[OrderedDict([('id', 'attATdjuiA6tfEmYQ'), ('width', 3163), ('height', 2157), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9H7bHSz_8EEFUbkCptNKuA/kTsjpdzelwUssCmB1bUNOxO-v0flW-A1Q4snyq3NJ6z4Bgr-haPzJNufWkrdyB1q7AlXdXs0ATe-lpB1bDRCExCqEkxJOXc9NPIdubYClA8/UCVAPJQFf_3eDN7vjw7HufBRJvA0sFxiyDh0cuhJ7MA'), ('filename', 'SR560 Wide.jpg'), ('size', 1372854), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kRXsAP6l9TFahQDuGk8R2w/d1NKUa3Np4DMTAh5TxMxcbzJqLHIEXXksVPl1oqY9TkCdYGz3ZPW391LlAvjkfz3nZiJAL_uPC43tINUFzrXRA/7FaIbtzVj5e8dTFkbDmRRFBM0ItJ2lJWxPeBBqdgFdo'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OnyqjKnM0elhpkKPXpWTog/NzBrMloTImGocOhOLndHbwAQ2JMk9YerJ-Mx4Q2Dp1efEbUC6rUYov5OwFaYZCCxqjz3YwYBixqqt0LB6INiDA/Fks4gE7TNXEXn6SR_Zo_jWZUcrD0Y6wjUgo6tfehXUY'), ('width', 751), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SQlbEr4J3-jAUplWufvj_Q/JzngJsyaekDK_S03srz1biBmsIQ3iq6DD2j3abQE5abMLhQwZA7IXZqfT9UAfG5IxQHERywkybOJR02kXE1tHw/jYdhTptS_jom3K51vBMiS4OPp3a1YHQCw6sw3cCHD7E'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,"The SR560 is a high-performance, low-noise preamplifier that is ideal for a wide variety of applications including low-temperature measurements, optical detection, and audio engineering.",https://www.thinksrs.com/products/sr560.html,SR 560,534.0,['Preamplifier'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker. Without this, the final signal would be noisy or distorted. They are typically used to amplify signals from analog sensors such as microphones and pickups. Because of this, the preamplifier is often placed close to the sensor to reduce the effects of noise and interference.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR560.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR560,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782510/Instruments/Preamplifier/SR-560/SR-560.jpg,SR 560,Write a Python script that uses Qcodes to connect to a {Device name} Preamplifier,2895.0,,,,"from typing import Any, Optional

from qcodes.instrument import Instrument
from qcodes.parameters import MultiParameter, Parameter, ParamRawDataType
from qcodes.validators import Bool, Enum


class VoltageParameter(MultiParameter):
    """"""
    Amplified voltage measurement via an SR560 preamp and a measured voltage.

    To be used when you feed a voltage into an SR560, send the SR560's
    output voltage to a lockin or other voltage amplifier, and you have
    the voltage reading from that amplifier as a qcodes parameter.

    ``VoltageParameter.get()`` returns ``(voltage_raw, voltage)``

    Args:
        measured_param: a gettable parameter returning the
            voltage read from the SR560 output.
        v_amp_ins: an SR560 instance where you manually
            maintain the present settings of the real SR560 amp.

            Note: it should be possible to use other voltage preamps, if they
            define parameters ``gain`` (V_out / V_in) and ``invert``
            (bool, output is inverted)

        name: the name of the current output. Default 'volt'.
            Also used as the name of the whole parameter.
    """"""
    def __init__(self,
                 measured_param: Parameter,
                 v_amp_ins: ""SR560"",
                 name: str = 'volt',
                 snapshot_value: bool = True):
        p_name = measured_param.name

        super().__init__(name=name,
                         names=(p_name+'_raw', name),
                         shapes=((), ()),
                         instrument=v_amp_ins)

        self._measured_param = measured_param

        p_label = getattr(measured_param, ""label"", """")
        p_unit = getattr(measured_param, ""unit"", """")

        self.labels = (p_label, 'Voltage')
        self.units = (p_unit, 'V')

    def get_raw(self) -> tuple[ParamRawDataType, ParamRawDataType]:
        volt = self._measured_param.get()
        assert isinstance(self.instrument, SR560)
        volt_amp = volt / self.instrument.gain.get()

        if self.instrument.invert.get():
            volt_amp *= -1

        value = (volt, volt_amp)
        return value


class SR560(Instrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SR560 Voltage-preamplifier.

    This is a virtual driver only and will not talk to your instrument.

    Note:

    - The ``cutoff_lo`` and ``cutoff_hi`` parameters will interact with
      each other on the instrument (hi cannot be <= lo) but this is not
      managed here, you must ensure yourself that both are correct whenever
      you change one of them.

    - ``gain`` has a vernier setting, which does not yield a well-defined
      output. We restrict this driver to only the predefined gain values.

    """"""
    def __init__(self, name: str, **kwargs: Any):
        super().__init__(name, **kwargs)

        cutoffs = ['DC', 0.03, 0.1, 0.3, 1, 3, 10, 30, 100, 300, 1000,
                   3000, 10000, 30000, 100000, 300000, 1000000]

        gains = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000,
                 10000, 20000, 50000]

        self.add_parameter('cutoff_lo',
                           get_cmd=None, set_cmd=None,
                           initial_value='DC',
                           label='High pass',
                           unit='Hz',
                           vals=Enum(*cutoffs))

        self.add_parameter('cutoff_hi',
                           get_cmd=None, set_cmd=None,
                           initial_value=1e6,
                           label='Low pass',
                           unit='Hz',
                           vals=Enum(*cutoffs))

        self.add_parameter('invert',
                           get_cmd=None, set_cmd=None,
                           initial_value=True,
                           label='Inverted output',
                           vals=Bool())

        self.add_parameter('gain',
                           get_cmd=None, set_cmd=None,
                           initial_value=10,
                           label='Gain',
                           unit=None,
                           vals=Enum(*gains))

    def get_idn(self) -> dict[str, Optional[str]]:
        vendor = 'Stanford Research Systems'
        model = 'SR560'
        serial = None
        firmware = None

        return {'vendor': vendor, 'model': model,
                'serial': serial, 'firmware': firmware}
"
106,https://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/centre-for-bio-inspired-technology/7291001.PDF,https://en.wikipedia.org/wiki/Source_measure_unit,,110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"Series 2600A System SourceMeter instruments are Keithley’s latest I-V source measurement unit
(SMU) instruments for use as either bench-top I-V characterization tools or as building block components of multi-channel I-V test systems. For bench-top use, Series 2600A instruments feature an
embedded TSP Express Software Tool that allows users to quickly and easily perform common I-V
tests without programming or installing software. For system level applications, the Series 2600A’s
Test Script Processor (TSP) architecture, along with other new capabilities such as parallel test execution and precision timing, provides the highest throughput in the industry, lowering the cost of test.
To simplify the testing, verification, and analysis of semiconductor components, the optional ACS
Basic Edition software is also available.",https://alltest.net/categories/products/2602A-Keithley,Keithley 2600,255.0,['Power Supplies'],"A source measure unit (SMU) is a type of electronic test equipment which, as the name indicates, is capable of both sourcing and measuring at the same time.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2600MeasurementStatus,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782732/Instruments/Power%20Supplies/Keithley-2600/Keithley-2600.jpg,Keithley 2600,Write a Python script that uses Qcodes to connect to a {Device name} Power Supplies,,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
115,https://docs.zhinst.com/pdf/ziHDAWG_UserManual.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attDrX4Vlwjak4Pks'), ('width', 1183), ('height', 549), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/18E9cdep1a0tqSeXJXflTg/d-Dm6EsWPhIBSbk7OvWonH3BdFZpXeu0dxsqmPDVBqghkeXA-IcQzWvzrFvlUyMyYC6lJkAl2aHbCSKaeOYXmhAHkj3ZhAx0qukEJLCTPulk8BvrmKhpr_qD8NZyFOzJ/qOUWHVqSJfTyFPL88EzxMBxJ90a8F9brxR5Xm_EMB3c'), ('filename', 'hdawg8_front_2560.jpg.webp'), ('size', 57176), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/F0KZK7DFX0VAZ-ZUyGXUvg/IMKvLUc5lKoWF0NBdTqxZnPfY9SiAcsAwlkaj18i304HEQKtBz4aHhRzzBWJgiJFm4vCsC-DxTfOwynFTLuRRZ-rjNjDORpvHclIlUrQzdM/OsrwioqTNDaWKVcKEVYIyMdR0QRUW26m5Jb8Na5rFMo'), ('width', 78), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-VB_Ww3ec1L3cp4W7QUThg/63EfZ0OgLnZgJR5AmVRHwAAJ2aGl9weFKONTuFuwjWhpZJC4RZtKs_zLquUPIOAzgYjziBmb52zaraiOMsDJaHUw2NSec7cco1FnmY7vT10/p7iapzqGqm7cbgnN1uR2TwRHGm68_cmw-5jtF3IlnIQ'), ('width', 1103), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mIy8afrbXFUhR9xLvyNQfA/0DwGppeVGZnWbFW3fxNNJu5ozUUKyuv-NpeiQJHaG-WTeKflwLpFSQ34GyDtnC3nC8L8z9EXSVh7cl_BruDksa5PmI0Ly9_aC5vlpE2Pb2k/syWMJXRV4xIaw2fHGvP1LwaWDpG4XZbDqHkazGdTldg'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments HDAWG multi-channel Arbitrary Waveform Generator has one of the highest channel densities available in its class and is designed for advanced signal generation up to 750 MHz bandwidth. The HDAWG comes with either 4 or 8 DC-coupled, single-ended analog output channels with 16-bit vertical resolution.",https://zhinst.com/americas/en/products/hdawg-arbitrary-waveform-generator,Hdawg,647.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/hdawg.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.device_creator.HDAWG.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782519/Instruments/RF%20Signal%20Generator/HDAWG/HDAWG.webp,HDAWG,Write a Python script that uses Qcodes to connect to a HDAWG RF Signal Generator,,,,,"""""""Autogenerated module for the HDAWG QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWG(ZINode):
    """"""AWG node.

    This class implements the basic functionality for the device specific
    arbitrary waveform generator.
    Besides the upload/compilation of sequences it offers the upload of
    waveforms and command tables.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        session: Underlying session.
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        device_type: Device type
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, f""awg_{index}"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)


class HDAWG(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments HDAWG.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.awgs:

            channel_list = ZIChannelList(
                self,
                ""awgs"",
                AWG,
                zi_node=self._tk_object.awgs.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.awgs):
                channel_list.append(
                    AWG(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.awgs[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""awgs"", channel_list)

    def enable_qccs_mode(self) -> None:
        """"""Configure the instrument to work with PQSC.

        This method sets the reference clock source to
        connect the instrument to the PQSC.

        Info:
            Use ``factory_reset`` to reset the changes if necessary
        """"""
        return self._tk_object.enable_qccs_mode()
"
119,,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,"[OrderedDict([('id', 'attMiPyIGeW8iWRJp'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lEAH7OhTVHPGZyuZhcMvYA/GUFdb3OiNWT6_sZZENdvB6va_8ARLWsAKaS2k45Zyx8YaS6LG3paDpFxO-Tg6_411XN4rwhj_AGNdLOWBVn8UxQwHLHylCE04kQuMN3WtNw/MAHVX2SjVCsvvv1PnKvTUDDKt0WAYslgAo1EbWWGT-4'), ('filename', 'E8267C.webp'), ('size', 20484), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dkriX66mJFn_zd-LtRS5Ig/zz3dAZfwsyxaxmqNvnUWn2cMeoh6kWAClgDr5F8le16imugrQ5RfCqPh5iDHGmC6hMGX6DVTfSon3tTBXsxRUfpM4CNLEA8Hzj9tolmOZDE/KgZrAFwn3L81oBNc6mMCRsYy7IgV7FezHjX-1KmyOYI'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G3nY4lqLQxIm-Goh60HpCg/cL8mND9qD4X_GkQBUDs5L64KVAy9RPw4Bigerq7wzLEbMPmkUbp0StFC4vrVCvxdhgmSZs4kKK_QzSN12aVgZMEonxiYoZHsk-AFhiwsZpk/3UozTVQl1rXaZYn7yLOp3OC4j7xeTWcD-TAdNDvVXso'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rGqAb1JDPU18WSb1YG71jw/u8SzUfb3twObOoggkT950GOO0eo9iDsDxwMCjmiL_eGwGCy02HdhlYTNg837JilB-HZyvLBQedHdfdI4aIKTba3oaDpEkLgBeBl6Ozm1xEY/8rXRfskUfYrTl1ep6SiFeyjYV9_UgPkKl0ovzQD38_s'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"E8267C PSG Vector Signal Generator, up to 20 GHz",https://www.keysight.com/us/en/product/E8267C/psg-vector-signal-generator.html,"Agilent E8267C
",,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/agilent/Agilent_E8267C.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.AgilentE8267C,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KLdW4e0aCMvuXtiF41lm5Q/tsULR905frVMXXpSBwX--GGG9pd67YfJfVqUbiphB7yi1YiZaesAKIc0H5OSMeujmzTnzL_TYJFKsYOLX2M-HuYgDDy464YMgOwWmAd540U/CQIhv7AHEyD7_1uuRrDXD-cM5HYvTXSunU9vcixsAug'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hlmdofa38jYloahcVSLpNw/3p9k2-zlW4PdZXOINyi5WevKuox8MEkgKxpfU8qhRNpuf6uCOaEc-SiDI8AOTUAw7YWp8NRCdU2dgc1P7EdU6HAyjmQbiEO3Hp3vcYlrIOY/Q6c584Zg-Ge5NIW7DvdQ-5bvCuyqJrmDmg6PDWARSL4'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dR-u6vcQ_qWkh_hzfJEdxQ/CqsqK2EnfYs5VLISQZ0OFYxQu_f9UQE_4pV_CakymtxZEGedpRn5KZvpsUnaybslmwwnrzvwiTZYPMP4emI5NC_nZxdGIx1ebsyYeKzRvnI/_oVf9TubhrO_RGOizCZPQfUHwNRQejxeIB_SREKXPHo'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SUaU78ZSlXE2XNRXeJAbJA/6bdGaHs7U5UbkXguW0uCC_jxHbNmi66L6y9XdaPyQYZhXOjcQsnb5Vx_VObVUE-pJ0UAWtZ88P0_zZN1TD3orExVUQe-wN3ukqEB7ShXXFw/tZAWl3xpv2JxN3HZABBPT7KYR938lcxPG87n9cnzOC0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782522/Instruments/RF%20Signal%20Generator/Keysight-E8267C/Keysight-E8267C.webp,Keysight E8267C,Write a Python script that uses Qcodes to connect to a Keysight E8267C RF Signal Generator,,"
",True,,"from typing import Any, Union

import numpy as np

from qcodes.instrument import VisaInstrument
from qcodes.validators import Enum, Numbers


class AgilentE8267C(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Agilent E8267C signal generator.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\n"", **kwargs)
        # general commands
        self.add_parameter(
            name=""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=""FREQ?"",
            set_cmd=""FREQ {}"",
            get_parser=float,
            vals=Numbers(min_value=100e3, max_value=40e9),
        )
        self.add_parameter(
            name=""freq_offset"",
            label=""Frequency offset"",
            unit=""Hz"",
            get_cmd=""FREQ:OFFS?"",
            set_cmd=""FREQ:OFFS {}"",
            get_parser=float,
            vals=Numbers(min_value=-200e9, max_value=200e9),
        )
        self.add_parameter(
            ""freq_mode"",
            label=""Frequency mode"",
            set_cmd=""FREQ:MODE {}"",
            get_cmd=""FREQ:MODE?"",
            vals=Enum(""FIX"", ""CW"", ""SWE"", ""LIST""),
        )
        self.add_parameter(
            ""pulse_width"",
            label=""Pulse width"",
            unit=""ns"",
            set_cmd=""PULM:INT:PWID {}"",
            get_cmd=""PULM:INT:PWID?"",
            vals=Numbers(min_value=10e-9, max_value=20e-9),
        )
        self.add_parameter(
            name=""phase"",
            label=""Phase"",
            unit=""deg"",
            get_cmd=""PHAS?"",
            set_cmd=""PHAS {}"",
            get_parser=self.rad_to_deg,
            set_parser=self.deg_to_rad,
            vals=Numbers(min_value=-180, max_value=179),
        )
        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=""POW?"",
            set_cmd=""POW {}"",
            get_parser=float,
            vals=Numbers(min_value=-135, max_value=25),
        )
        self.add_parameter(
            name=""power_offset"",
            label=""Power offset"",
            unit=""dBm"",
            get_cmd=""POW:OFFS?"",
            set_cmd=""POW:OFFS {}"",
            get_parser=float,
            vals=Numbers(min_value=-200, max_value=200),
        )
        self.add_parameter(
            name=""output_rf"",
            get_cmd=""OUTP?"",
            set_cmd=""OUTP {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        self.add_parameter(
            name=""modulation_rf"",
            get_cmd=""OUTP:MOD?"",
            set_cmd=""OUTP:MOD {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        # reset values after each reconnect
        self.power(0)
        self.power_offset(0)
        self.connect_message()
        self.add_function(""reset"", call_cmd=""*RST"")

    # functions to convert between rad and deg
    @staticmethod
    def deg_to_rad(
        angle_deg: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.deg2rad(float(angle_deg))

    @staticmethod
    def rad_to_deg(
        angle_rad: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.rad2deg(float(angle_rad))
"
122,,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attPvti3ysTXW2WG7'), ('width', 800), ('height', 560), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_kEtImMb7qcsewDZkVbKJQ/AOz6AAQ3dGI2qqwhHTxeTVJgaHSG2Wl3MSbgklY2aghfNKf5kxelcPhYxWjINOZgrtlgcrgaedTrxf4aJ9wwJwxTMrXmuZa9WMb3OXffZdk/zvLGi5PzhbxlaY9Z-kUVhcJ272dYEuF1NFJDYMHJucQ'), ('filename', 'B2961A_FS.2.jpg'), ('size', 53604), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ETF6Xx9f49uqAefKKS7jAg/PFrYVr-nRlhm3fKkdGfa9cZRX798EkvCTzQkwwfeMR0obsuACTQsAi8B_dwvGsUJk6a7TQgopxjEpLQoFbbOEQ/jDe1icESjcJFvWDHq00NLwirTQWWxovpCdf4c_cKR6o'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3H0s-Ov5iK75wMYLCkHc_w/Rr1F9mroVmOArahenseN5LcZulSamIk_u6-1vXebYeaeJpYz3Xngkrc_BzdJNYEy9eyF0XeLh4z39mc2ZswR0A/9Fd3_M6Fxem04NnaincWMwJGA4BS-0PDL6CBShVhHhs'), ('width', 731), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BqctaygD0aXH9GEoV0PU4g/K-ybifETegJJvZRoacxKIVbA6MMjLyuR7k0hrGh-t-s11PYJboF-9G-VwFlkGeingcy090vZxEuyV4P16j2RUw/QJDzqoS4WOlTJ7T9bnCLjGsmHHv1QFFo8YQjSm1wp4k'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight B2962A source / measure unit (SMU) is a 6.5-digit low noise power source that provides a power supply and source solution that meets the difficult measurement challenges researchers, designers, and developers face working on advanced components, circuits, and materials.

",https://www.keysight.com/us/en/product/B2962A/6-5-digit-low-noise-power-source-2-channels.html,Keysight B 2962 A,276.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_B2962A.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightB2962A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782524/Instruments/Power%20Supplies/Keysight-B2962A/Keysight-B2962A.jpg,Keysight B2962A,Write a Python script that uses Qcodes to connect to a Keysight B2962A Power Supplies,,,,,"from typing import Any, Optional

from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument


class KeysightB2962AChannel(InstrumentChannel):
    """"""

    """"""
    def __init__(self, parent: Instrument, name: str, chan: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached.
            name: The name of the channel
            chan: The number of the channel in question (1-2)
        """"""
        # Sanity Check inputs
        if name not in ['ch1', 'ch2']:
            raise ValueError(""Invalid Channel: {}, expected 'ch1' or 'ch2'""
                             .format(name))
        if chan not in [1, 2]:
            raise ValueError(""Invalid Channel: {}, expected '1' or '2'""
                             .format(chan))

        super().__init__(parent, name)

        self.add_parameter('source_voltage',
                           label=f""Channel {chan} Voltage"",
                           get_cmd=f'SOURCE{chan:d}:VOLT?',
                           get_parser=float,
                           set_cmd=f'SOURCE{chan:d}:VOLT {{:.8G}}',
                           unit='V')

        self.add_parameter('source_current',
                           label=f""Channel {chan} Current"",
                           get_cmd=f'SOURCE{chan:d}:CURR?',
                           get_parser=float,
                           set_cmd=f'SOURCE{chan:d}:CURR {{:.8G}}',
                           unit='A')

        self.add_parameter('voltage',
                           get_cmd=f'MEAS:VOLT? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Voltage',
                           unit='V')

        self.add_parameter('current',
                           get_cmd=f'MEAS:CURR? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Current',
                           unit='A')

        self.add_parameter('resistance',
                           get_cmd=f'MEAS:RES? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Resistance',
                           unit='ohm')

        self.add_parameter('voltage_limit',
                           get_cmd=f'SENS{chan:d}:VOLT:PROT?',
                           get_parser=float,
                           set_cmd=f'SENS{chan:d}:VOLT:PROT {{:.8G}}',
                           label=f'Channel {chan} Voltage Limit',
                           unit='V')

        self.add_parameter('current_limit',
                           get_cmd=f'SENS{chan:d}:CURR:PROT?',
                           get_parser=float,
                           set_cmd=f'SENS{chan:d}:CURR:PROT {{:.8G}}',
                           label='Channel {} Current Limit',
                           unit='A')

        self.add_parameter('enable',
                           get_cmd=f'OUTP{chan:d}?',
                           set_cmd=f'OUTP{chan:d} {{:d}}',
                           val_mapping={'on':  1, 'off': 0})

        self.add_parameter('source_mode',
                           get_cmd=f':SOUR{chan:d}:FUNC:MODE?',
                           set_cmd=f':SOUR{chan:d}:FUNC:MODE {{:s}}',
                           val_mapping={'current': 'CURR', 'voltage': 'VOLT'})

        self.channel = chan


B2962AChannel = KeysightB2962AChannel


class KeysightB2962A(VisaInstrument):
    """"""
    This is the qcodes driver for the Keysight B2962A 6.5 Digit Low Noise
    Power Source

    Status: alpha-version.
    TODO:
        - Implement any remaining parameters supported by the device
        - Similar drivers have special handlers to map return values of
          9.9e+37 to inf, is this needed?
    """"""
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        # The B2962A supports two channels
        for ch_num in [1, 2]:
            ch_name = f""ch{ch_num:d}""
            channel = KeysightB2962AChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)

        self.connect_message()

    def get_idn(self) -> dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN


class B2962A(KeysightB2962A):
    """"""
    Alias for backwards compatibility
    """"""
"
128,https://download.tek.com/datasheet/AWG70000A-Arbitrary-Waveform-Generator-Datasheet-76W283808.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attuN24ZB0RTqUVJh'), ('width', 294), ('height', 220), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UACXrvg-wTbBOXfRnztzUQ/Dsxr9qQrAapOkwQMOxg5tbZGeolEuLV_1Co2FOdJc3WS6QDppUeS5P2QZZjR5XCE1PdzkGuqiFc_WY1SBREmJSws3CQt3duE9gJMOzpPwueDGa7xy2QEZti2hYd_LOraT7CdGHy3LdJqPQDEDp1-Vg/HESlMMwp71DVbHL6u90ynsb-U8YNYWYCfc4aH9OiByQ'), ('filename', '02aadca4ffd655cc627bb76eb7983ba7_1490966598 (1).webp'), ('size', 4594), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/21Mcei9qY3-OicvI-M2jEw/XSl5yhOtdUI4hk30gi-fya2AHu3Qgm-YajqEKqCu7EkMVsG4udVrije0QZqXwxEGtvkjsl152o1n1iWJw6WPlFDW9be5B-ytYViMmjVVlEQ/nu59me89lchmVWQFWnKtVNsb9ZRuWmmGg55-42CSNlY'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BuXyYPonqHdGpeap_J5iOA/-gqA4zPgAgQ6BytTJ753Cr2TQppBZ1VQgshUtG9Fg94D0k2x_WTlwYq5h4JL-wePqtmBjDMm4FTRrFVQP-epvqiz4rwTu6ThMsP2RdPDfaY/UGK4j6WtA_pzfrzlPaNcTZkdfYyeOfd0gzaJdti7G9A'), ('width', 294), ('height', 220)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dHXgaaumkqQa_Zf9YCw4Ug/6MyU1prLguOkx2pxikKd_Kspp9N8Ld2SPUAoH4VZvmHpxeqNJ2ys_VnPqOY96SRgKtbpGZHSqkSHFWuvlRiE84u-DWCsKgbF_CokalULCJk/SN2hOe5teTM5PsBt03H1id2o2lHoCBAUkvWlnTtiRhg'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The industry-leading AWG70000A Series arbitrary waveform generator (AWG) provides you with unparalleled performance at the cutting edge for sample rate, signal fidelity, and waveform memory. In order to engineer the world's most complex data communications systems, the ability to create ideal, distorted and ""real life"" signals is essential. The AWG70000A Series of AWGs delivers this, giving you the industry's best signal stimulus solution for ever-increasing measurement challenges. With up to 50 GS/s and 10-bit vertical resolution, it offers easy generation of very complex signals and complete control over signal characteristics.",https://www.tek.com/en/datasheet/arbitrary-waveform-generators-1,AWG 70002 A,545.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70002A,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782530/Instruments/RF%20Signal%20Generator/AWG70002A/AWG70002A.webp,AWG70002A,Write a Python script that uses Qcodes to connect to a AWG70002A RF Signal Generator,74999.0,,True,Price from: https://www.transcat.com/tektronix-awg70001a-used-for-sale,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
129,https://thinksrs.com/downloads/pdfs/catalog/SR865Ac.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attLU55vwUTWxsQyF'), ('width', 4188), ('height', 2470), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bFoiOwm9xkAKZYIBvYiGKg/EXzctBLqVX-8lKS32wv9vp8miPFWS-mYWDXp8ZxdfIMFKW_iCEdnncZgw9_edbOVruf44YWs8JU-Cb96wDJbcP6qWfJmxENC9fV6TRdTTAI/q3-WljhcQnKgeqimYuu86Plf0QJtZDB4jCpjiHqP-yw'), ('filename', 'SR865A_Lt_Wide.jpg'), ('size', 2302119), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kRyXWTuV9CQKUAT2QmaBrw/qxd0hhPrCmGNN-qCHs_z8FI-lhWujV__3IE0GKHBUzm5HDJPju6gYk6CJi9Tx2QCDTpxRDD-ttX7Dna5znNlXA/cBa2F_ddvRrsoflZZSPJK2_or30ov1N5QAZhjIa9Iyk'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PqbFFQS0w2Q1V6mobNaOEQ/BOXlZecbh1SjWvahgJ4KNFdGR_ZzaPGnd1HAhM63UyutR_f2PSp3bphx2JV1H7WJgstgRyJ88pIHKoyWsPvJ_A/4vCDTnGDM8yoIskyY0UtAxMkZONbPMpF86jpo5kkizI'), ('width', 868), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i0lj7crhJqRy36ugY0rpRg/Y5rw7C87jC-9COTam9oBa5kKgm18wmDfEnP_w5mg1tz2oYhZ138EkY_KT7ze-2PqghTY6EpYFNACY2x_MeXHxA/JyjEOMGOVbXCYHMvRLlLYff6zaa_oqLm_GZa1Vvukyc'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,"The SR865A Lock-In Amplifier offers superb performance and outstanding value. With 4 MHz frequency range, time constants from 1 µs to 30 ks, very low noise front-end amplifiers, and a modern, intuitive user interface, the SR865A is the ideal choice for any synchronous detection application.",https://thinksrs.com/products/sr865a.htm,SR 865 A,536.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR86x.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR865A,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782530/Instruments/Lockin%20Amplifiers/SR-865-A/SR-865-A.jpg,SR 865 A,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,8150.0,,,,"import logging
from collections.abc import Sequence
from typing import Any, Callable, Optional

import numpy as np

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter
from qcodes.validators import ComplexNumbers, Enum, Ints, Numbers

log = logging.getLogger(__name__)


class SR86xBufferReadout(ArrayParameter):
    """"""
    The parameter array that holds read out data. We need this to be compatible
    with qcodes.Measure

    Args:
        name: Name of the parameter.
        instrument: The instrument to add this parameter to.
    """"""
    def __init__(self, name: str, instrument: 'SR86x', **kwargs: Any) -> None:

        unit = ""deg""
        if name in [""X"", ""Y"", ""R""]:
            unit = ""V""

        super().__init__(name,
                         shape=(1,),  # dummy initial shape
                         unit=unit,
                         setpoint_names=('Time',),
                         setpoint_labels=('Time',),
                         setpoint_units=('s',),
                         instrument=instrument,
                         docstring='Holds an acquired (part of the) data '
                                   'buffer of one channel.',
                         **kwargs)

        self._capture_data: Optional[np.ndarray] = None

    def prepare_readout(self, capture_data: np.ndarray) -> None:
        """"""
        Prepare this parameter for readout.

        Args:
            capture_data: The data to capture.
        """"""
        self._capture_data = capture_data

        data_len = len(capture_data)
        self.shape = (data_len,)
        self.setpoint_units = ('',)
        self.setpoint_names = ('sample_nr',)
        self.setpoint_labels = ('Sample number',)
        self.setpoints = (tuple(np.arange(0, data_len)),)

    def get_raw(self) -> np.ndarray:
        """"""
        Public method to access the capture data
        """"""
        if self._capture_data is None:
            raise ValueError(f""Cannot return data for parameter {self.name}. ""
                             f""Please prepare for readout by calling ""
                             f""'get_capture_data' with appropriate ""
                             f""configuration settings"")

        return self._capture_data


class SR86xBuffer(InstrumentChannel):
    """"""
    Buffer module for the SR86x drivers.

    This driver has been verified to work with the SR860 and SR865.
    For reference, please consult the SR860
    manual: http://thinksrs.com/downloads/PDFs/Manuals/SR860m.pdf
    """"""

    def __init__(self, parent: 'SR86x', name: str) -> None:
        super().__init__(parent, name)

        self.add_parameter(
            ""capture_length_in_kb"",
            label=""get/set capture length"",
            get_cmd=""CAPTURELEN?"",
            set_cmd=""CAPTURELEN {}"",
            set_parser=self._set_capture_len_parser,
            get_parser=int,
            unit=""kB""
        )
        self.bytes_per_sample = 4
        self.min_capture_length_in_kb = 1  # i.e. minimum buffer size
        self.max_capture_length_in_kb = 4096  # i.e. maximum buffer size
        # Maximum amount of kB that can be read per single CAPTUREGET command
        self.max_size_per_reading_in_kb = 64

        self.add_parameter(  # Configure which parameters we want to capture
            ""capture_config"",
            label=""capture configuration"",
            get_cmd=""CAPTURECFG?"",
            set_cmd=""CAPTURECFG {}"",
            val_mapping={""X"": ""0"", ""X,Y"": ""1"", ""R,T"": ""2"", ""X,Y,R,T"": ""3""}
        )

        self.add_parameter(
            ""capture_rate_max"",
            label=""capture rate maximum"",
            get_cmd=""CAPTURERATEMAX?"",
            get_parser=float
        )

        self.add_parameter(
            ""capture_rate"",
            label=""capture rate raw"",
            get_cmd=""CAPTURERATE?"",
            set_cmd=""CAPTURERATE {}"",
            get_parser=float,
            set_parser=self._set_capture_rate_parser
        )

        max_rate = self.capture_rate_max()
        self.available_frequencies = [max_rate / 2 ** i for i in range(20)]

        self.add_parameter(  # Are we capturing at the moment?
            ""capture_status"",
            label=""capture status"",
            get_cmd=""CAPTURESTAT?""
        )

        self.add_parameter(
            ""count_capture_bytes"",
            label=""captured bytes"",
            get_cmd=""CAPTUREBYTES?"",
            unit=""B"",
            get_parser=int,
            docstring=""Number of bytes captured so far in the buffer. Can be ""
                      ""used to track live progress.""
        )

        self.add_parameter(
            ""count_capture_kilobytes"",
            label=""captured kilobytes"",
            get_cmd=""CAPTUREPROG?"",
            unit=""kB"",
            docstring=""Number of kilobytes captured so far in the buffer, ""
                      ""rounded-up to 2 kilobyte chunks. Capture must be ""
                      ""stopped before requesting the value of this ""
                      ""parameter. If the acquisition wrapped during operating ""
                      ""in Continuous mode, then the returned value is ""
                      ""simply equal to the current capture length.""
        )

        for parameter_name in [""X"", ""Y"", ""R"", ""T""]:
            self.add_parameter(
                parameter_name,
                parameter_class=SR86xBufferReadout
            )

    def snapshot_base(
        self,
        update: Optional[bool] = False,
        params_to_skip_update: Optional[Sequence[str]] = None,
    ) -> dict[Any, Any]:
        if params_to_skip_update is None:
            params_to_skip_update = []
        # we omit count_capture_kilobytes from the snapshot because
        # it can only be read after a completed capture and will
        # timeout otherwise when the snapshot is updated, e.g. at
        # station creation time
        params_to_skip_update = list(params_to_skip_update)
        params_to_skip_update.append('count_capture_kilobytes')

        snapshot = super().snapshot_base(update, params_to_skip_update)
        return snapshot

    def _set_capture_len_parser(self, capture_length_in_kb: int) -> int:
        """"""
        Parse the capture length in kB according to the way buffer treats it
        (refer to the manual for details). The given value has to fit in the
        range and has to be even, otherwise this function raises exceptions.

        Args:
            capture_length_in_kb: The desired capture length in kB.

        Returns:
            capture_length_in_kb
        """"""
        if capture_length_in_kb % 2:
            raise ValueError(""The capture length should be an even number"")

        if not self.min_capture_length_in_kb \
                <= capture_length_in_kb \
                <= self.max_capture_length_in_kb:
            raise ValueError(f""The capture length should be between ""
                             f""{self.min_capture_length_in_kb} and ""
                             f""{self.max_capture_length_in_kb}"")

        return capture_length_in_kb

    def set_capture_rate_to_maximum(self) -> None:
        """"""
        Sets the capture rate to maximum. The maximum capture rate is
        retrieved from the device, and depends on the current value of the
        time constant.
        """"""
        self.capture_rate(self.capture_rate_max())

    def _set_capture_rate_parser(self, capture_rate_hz: float) -> int:
        """"""
        According to the manual, the capture rate query returns a value in
        Hz, but then setting this value it is expected to give a value n,
        where the capture rate in Hz is given by
        capture_rate_hz =  max_rate / 2 ** n. Please see page 136 of the
        manual. Here n is an integer in the range [0, 20].

        Args:
            capture_rate_hz: The desired capture rate in Hz. If the desired
                rate is more than 1 Hz from the nearest valid rate, a warning
                is issued and the nearest valid rate it used.

        Returns:
            n_round
        """"""
        max_rate = self.capture_rate_max()
        n = np.log2(max_rate / capture_rate_hz)
        n_round = int(round(n))

        if not 0 <= n_round <= 20:
            raise ValueError(f""The chosen frequency is invalid. Please ""
                             f""consult the SR860 manual at page 136. ""
                             f""The maximum capture rate is {max_rate}"")

        nearest_valid_rate = max_rate / 2 ** n_round
        if abs(capture_rate_hz - nearest_valid_rate) > 1:
            available_frequencies = "", "".join(
                str(f) for f in self.available_frequencies
            )
            log.warning(f""Warning: Setting capture rate to {nearest_valid_rate:.5} Hz"")
            log.warning(f""The available frequencies are: {available_frequencies}"")

        return n_round

    def start_capture(self, acquisition_mode: str, trigger_mode: str) -> None:
        """"""
        Start an acquisition. Please see page 137 of the manual for a detailed
        explanation.

        Args:
            acquisition_mode: ""ONE"" | ""CONT""
            trigger_mode: ""IMM"" | ""TRIG"" | ""SAMP""
        """"""

        if acquisition_mode not in [""ONE"", ""CONT""]:
            raise ValueError(
                ""The acquisition mode needs to be either 'ONE' or 'CONT'"")

        if trigger_mode not in [""IMM"", ""TRIG"", ""SAMP""]:
            raise ValueError(
                ""The trigger mode needs to be either 'IMM', 'TRIG' or 'SAMP'"")

        cmd_str = f""CAPTURESTART {acquisition_mode}, {trigger_mode}""
        self.write(cmd_str)

    def stop_capture(self) -> None:
        """"""Stop a capture""""""
        self.write(""CAPTURESTOP"")

    def _get_list_of_capture_variable_names(self) -> list[str]:
        """"""
        Retrieve the list of names of variables (readouts) that are
        set to be captured
        """"""
        return self.capture_config().split("","")

    def _get_number_of_capture_variables(self) -> int:
        """"""
        Retrieve the number of variables (readouts) that are
        set to be captured
        """"""
        capture_variables = self._get_list_of_capture_variable_names()
        n_variables = len(capture_variables)
        return n_variables

    def _calc_capture_size_in_kb(self, sample_count: int) -> int:
        """"""
        Given the number of samples to capture, calculate the capture length
        that the buffer needs to be set to in order to fit the requested
        number of samples. Note that the number of activated readouts is
        taken into account.
        """"""
        n_variables = self._get_number_of_capture_variables()
        total_size_in_kb = int(
            np.ceil(n_variables * sample_count * self.bytes_per_sample / 1024)
        )
        # Make sure that the total size in kb is an even number, as expected by
        # the instrument
        if total_size_in_kb % 2:
            total_size_in_kb += 1
        return total_size_in_kb

    def set_capture_length_to_fit_samples(self, sample_count: int) -> None:
        """"""
        Set the capture length of the buffer to fit the given number of
        samples.

        Args:
            sample_count: Number of samples that the buffer has to fit
        """"""
        total_size_in_kb = self._calc_capture_size_in_kb(sample_count)
        self.capture_length_in_kb(total_size_in_kb)

    def wait_until_samples_captured(self, sample_count: int) -> None:
        """"""
        Wait until the given number of samples is captured. This function
        is blocking and has to be used with caution because it does not have
        a timeout.

        Args:
            sample_count: Number of samples that needs to be captured
        """"""
        n_captured_bytes = 0
        n_variables = self._get_number_of_capture_variables()
        n_bytes_to_capture = sample_count * n_variables * self.bytes_per_sample
        while n_captured_bytes < n_bytes_to_capture:
            n_captured_bytes = self.count_capture_bytes()

    def get_capture_data(self, sample_count: int) -> dict[str, np.ndarray]:
        """"""
        Read the given number of samples of the capture data from the buffer.

        Args:
            sample_count: number of samples to read from the buffer

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        total_size_in_kb = self._calc_capture_size_in_kb(sample_count)
        capture_variables = self._get_list_of_capture_variable_names()
        n_variables = self._get_number_of_capture_variables()

        values = self._get_raw_capture_data(total_size_in_kb)

        # Remove zeros which mark the end part of the buffer that is not
        # filled with captured data
        values = values[values != 0]

        values = values.reshape((-1, n_variables)).T
        values = values[:, :sample_count]

        data = {k: v for k, v in zip(capture_variables, values)}

        for capture_variable in capture_variables:
            buffer_parameter = getattr(self, capture_variable)
            buffer_parameter.prepare_readout(data[capture_variable])

        return data

    def _get_raw_capture_data(self, size_in_kb: int) -> np.ndarray:
        """"""
        Read data from the buffer from its beginning avoiding the instrument
        limit of 64 kilobytes per reading.

        Args:
            size_in_kb :Size of the data that needs to be read; if it exceeds
                the capture length, an exception is raised.

        Returns:
            A one-dimensional numpy array of the requested data. Note that the
            returned array contains data for all the variables that are
            mentioned in the capture config.
        """"""
        current_capture_length = self.capture_length_in_kb()
        if size_in_kb > current_capture_length:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""is larger than current capture length of the ""
                             f""buffer ({current_capture_length}kB)."")

        values: np.ndarray = np.array([])
        data_size_to_read_in_kb = size_in_kb
        n_readings = 0

        while data_size_to_read_in_kb > 0:
            offset = n_readings * self.max_size_per_reading_in_kb

            if data_size_to_read_in_kb > self.max_size_per_reading_in_kb:
                size_of_this_reading = self.max_size_per_reading_in_kb
            else:
                size_of_this_reading = data_size_to_read_in_kb

            data_from_this_reading = self._get_raw_capture_data_block(
                size_of_this_reading,
                offset_in_kb=offset)
            values = np.append(values, data_from_this_reading)

            data_size_to_read_in_kb -= size_of_this_reading
            n_readings += 1

        return values

    def _get_raw_capture_data_block(self,
                                    size_in_kb: int,
                                    offset_in_kb: int = 0
                                    ) -> np.ndarray:
        """"""
        Read data from the buffer. The maximum amount of data that can be
        read with this function (size_in_kb) is 64kB (this limitation comes
        from the instrument). The offset argument can be used to navigate
        along the buffer.

        An exception will be raised if either size_in_kb or offset_in_kb are
        longer that the *current* capture length (number of kB of data that is
        captured so far rounded up to 2kB chunks). If (offset_in_kb +
        size_in_kb) is longer than the *current* capture length,
        the instrument returns the wrapped data.

        For more information, refer to the description of the ""CAPTUREGET""
        command in the manual.

        Args:
            size_in_kb: Amount of data in kB that is to be read from the buffer
            offset_in_kb: Offset within the buffer of where to read the data;
                for example, when 0 is specified, the data is read from the
                start of the buffer.

        Returns:
            A one-dimensional numpy array of the requested data. Note that the
            returned array contains data for all the variables that are
            mentioned in the capture config.
        """"""
        if size_in_kb > self.max_size_per_reading_in_kb:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""is larger than maximum size that can be read ""
                             f""at once ({self.max_size_per_reading_in_kb}kB)."")

        # Calculate the size of the data captured so far, in kB, rounded up
        # to 2kB chunks
        size_of_currently_captured_data = int(
            np.ceil(np.ceil(self.count_capture_bytes() / 1024) / 2) * 2
        )

        if size_in_kb > size_of_currently_captured_data:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""cannot be larger than the size of currently ""
                             f""captured data rounded up to 2kB chunks ""
                             f""({size_of_currently_captured_data}kB)"")

        if offset_in_kb > size_of_currently_captured_data:
            raise ValueError(f""The offset for reading the requested data ""
                             f""({offset_in_kb}kB) cannot be larger than the ""
                             f""size of currently captured data rounded up to ""
                             f""2kB chunks ""
                             f""({size_of_currently_captured_data}kB)"")

        values = self._parent.visa_handle.query_binary_values(
            f""CAPTUREGET? {offset_in_kb}, {size_in_kb}"",
            datatype='f',
            is_big_endian=False,
            expect_termination=False)
        # the sr86x does not include an extra termination char on binary
        # messages so we set expect_termination to False

        return np.array(values)

    def capture_one_sample_per_trigger(
            self,
            trigger_count: int,
            start_triggers_pulsetrain: Callable[..., Any]
    ) -> dict[str, np.ndarray]:
        """"""
        Capture one sample per each trigger, and return when the specified
        number of triggers has been received.

        Args:
            trigger_count: Number of triggers to capture samples for
            start_triggers_pulsetrain: By calling this *non-blocking*
                function, the train of trigger pulses should start

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(trigger_count)
        self.start_capture(""ONE"", ""SAMP"")
        start_triggers_pulsetrain()
        self.wait_until_samples_captured(trigger_count)
        self.stop_capture()
        return self.get_capture_data(trigger_count)

    def capture_samples_after_trigger(
        self, sample_count: int, send_trigger: Callable[..., Any]
    ) -> dict[str, np.ndarray]:
        """"""
        Capture a number of samples after a trigger has been received.
        Please refer to page 135 of the manual for details.

        Args:
            sample_count: Number of samples to capture
            send_trigger: By calling this *non-blocking* function, one trigger
                should be sent that will initiate the capture

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(sample_count)
        self.start_capture(""ONE"", ""TRIG"")
        send_trigger()
        self.wait_until_samples_captured(sample_count)
        self.stop_capture()
        return self.get_capture_data(sample_count)

    def capture_samples(self, sample_count: int) -> dict[str, np.ndarray]:
        """"""
        Capture a number of samples at a capture rate, starting immediately.
        Unlike the ""continuous"" capture mode, here the buffer does not get
        overwritten with the new data once the buffer is full.

        The function blocks until the required number of samples is acquired,
        and returns them.

        Args:
            sample_count: Number of samples to capture

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(sample_count)
        self.start_capture(""ONE"", ""IMM"")
        self.wait_until_samples_captured(sample_count)
        self.stop_capture()
        return self.get_capture_data(sample_count)


class SR86xDataChannel(InstrumentChannel):
    """"""
    Implements a data channel of SR86x lock-in amplifier. Parameters that are
    assigned to these channels get plotted on the display of the instrument.
    Moreover, there are commands that allow to conveniently retrieve the values
    of the parameters that are currently assigned to the data channels.

    This class relies on the available parameter names that should be
    mentioned in the lock-in amplifier class in `PARAMETER_NAMES` attribute.

    Args:
        parent: an instance of SR86x driver
        name: data channel name that is to be used to reference it from the
            parent
        cmd_id: this ID is used in VISA commands to refer to this data channel,
            usually is an integer number
        cmd_id_name: this name can also be used in VISA commands along with
            channel_id; it is not used in this implementation, but is added
            for reference
        color: every data channel is also referred to by the color with which it
            is being plotted on the instrument's screen; added here only for
            reference
    """"""
    def __init__(self, parent: 'SR86x', name: str, cmd_id: str,
                 cmd_id_name: Optional[str] = None,
                 color: Optional[str] = None) -> None:
        super().__init__(parent, name)

        self._cmd_id = cmd_id
        self._cmd_id_name = cmd_id_name
        self._color = color

        self.add_parameter(
            ""assigned_parameter"",
            label=f""Data channel {cmd_id} parameter"",
            docstring=f""Allows to set and get the ""
            f""parameter that is assigned to data ""
            f""channel {cmd_id}"",
            set_cmd=f""CDSP {cmd_id}, {{}}"",
            get_cmd=f""CDSP? {cmd_id}"",
            val_mapping=self.parent.PARAMETER_NAMES,
        )

    @property
    def cmd_id(self) -> str:
        return self._cmd_id

    @property
    def cmd_id_name(self) -> Optional[str]:
        return self._cmd_id_name

    @property
    def color(self) -> Optional[str]:
        return self._color


class SR86x(VisaInstrument):
    """"""
    This is the code for Stanford_SR865 Lock-in Amplifier
    """"""
    _VOLT_TO_N = {1: 0, 500e-3: 1, 200e-3: 2,
                  100e-3: 3, 50e-3: 4, 20e-3: 5,
                  10e-3: 6, 5e-3: 7, 2e-3: 8,
                  1e-3: 9, 500e-6: 10, 200e-6: 11,
                  100e-6: 12, 50e-6: 13, 20e-6: 14,
                  10e-6: 15, 5e-6: 16, 2e-6: 17,
                  1e-6: 18, 500e-9: 19, 200e-9: 20,
                  100e-9: 21, 50e-9: 22, 20e-9: 23,
                  10e-9: 24, 5e-9: 25, 2e-9: 26,
                  1e-9: 27}
    _N_TO_VOLT = {v: k for k, v in _VOLT_TO_N.items()}

    _CURR_TO_N = {1e-6: 0, 500e-9: 1, 200e-9: 2,
                  100e-9: 3, 50e-9: 4, 20e-9: 5,
                  10e-9: 6, 5e-9: 7, 2e-9: 8,
                  1e-9: 9, 500e-12: 10, 200e-12: 11,
                  100e-12: 12, 50e-12: 13, 20e-12: 14,
                  10e-12: 15, 5e-12: 16, 2e-12: 17,
                  1e-12: 18, 500e-15: 19, 200e-15: 20,
                  100e-15: 21, 50e-15: 22, 20e-15: 23,
                  10e-15: 24, 5e-15: 25, 2e-15: 26,
                  1e-15: 27}
    _N_TO_CURR = {v: k for k, v in _CURR_TO_N.items()}

    _VOLT_ENUM = Enum(*_VOLT_TO_N.keys())
    _CURR_ENUM = Enum(*_CURR_TO_N.keys())

    _INPUT_SIGNAL_TO_N = {
        'voltage': 0,
        'current': 1,
    }
    _N_TO_INPUT_SIGNAL = {v: k for k, v in _INPUT_SIGNAL_TO_N.items()}

    PARAMETER_NAMES = {
                'X': '0',   # X output, 'X'
                'Y': '1',   # Y output, 'Y'
                'R': '2',   # R output, 'R'
                'P': '3',   # theta output, 'THeta'
          'aux_in1': '4',   # Aux In 1, 'IN1'
          'aux_in2': '5',   # Aux In 2, 'IN2'
          'aux_in3': '6',   # Aux In 3, 'IN3'
          'aux_in4': '7',   # Aux In 4, 'IN4'
           'Xnoise': '8',   # X noise, 'XNOise'
           'Ynoise': '9',   # Y noise, 'YNOise'
         'aux_out1': '10',  # Aux Out 1, 'OUT1'
         'aux_out2': '11',  # Aux Out 2, 'OUT2'
            'phase': '12',  # Reference Phase, 'PHAse'
        'amplitude': '13',  # Sine Out Amplitude, 'SAMp'
       'sine_outdc': '14',  # DC Level, 'LEVel'
        'frequency': '15',  # Int. Ref. Frequency, 'FInt'
    'frequency_ext': '16',  # Ext. Ref. Frequency, 'FExt'
    }

    _N_DATA_CHANNELS = 4

    def __init__(
            self,
            name: str,
            address: str,
            max_frequency: float,
            reset: bool = False,
            **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)
        self._max_frequency = max_frequency
        # Reference commands
        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='FREQ?',
                           set_cmd='FREQ {}',
                           get_parser=float,
                           vals=Numbers(
                               min_value=1e-3,
                               max_value=self._max_frequency)
                           )
        self.add_parameter(name='sine_outdc',
                           label='Sine out dc level',
                           unit='V',
                           get_cmd='SOFF?',
                           set_cmd='SOFF {}',
                           get_parser=float,
                           vals=Numbers(min_value=-5, max_value=5))
        self.add_parameter(name='amplitude',
                           label='Amplitude',
                           unit='V',
                           get_cmd='SLVL?',
                           set_cmd='SLVL {}',
                           get_parser=float,
                           vals=Numbers(min_value=0, max_value=2))
        self.add_parameter(name='harmonic',
                           label='Harmonic',
                           get_cmd='HARM?',
                           get_parser=int,
                           set_cmd='HARM {:d}',
                           vals=Ints(min_value=1, max_value=99))
        self.add_parameter(name='phase',
                           label='Phase',
                           unit='deg',
                           get_cmd='PHAS?',
                           set_cmd='PHAS {}',
                           get_parser=float,
                           vals=Numbers(min_value=-3.6e5, max_value=3.6e5))
        # Signal commands
        self.add_parameter(name='sensitivity',
                           label='Sensitivity',
                           get_cmd='SCAL?',
                           set_cmd='SCAL {:d}',
                           get_parser=self._get_sensitivity,
                           set_parser=self._set_sensitivity
                           )
        self.add_parameter(name='filter_slope',
                           label='Filter slope',
                           unit='dB/oct',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           val_mapping={6: 0,
                                        12: 1,
                                        18: 2,
                                        24: 3})
        self.add_parameter(name='sync_filter',
                           label='Sync filter',
                           get_cmd='SYNC?',
                           set_cmd='SYNC {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='noise_bandwidth',
                           label='Noise bandwidth',
                           unit='Hz',
                           get_cmd='ENBW?',
                           get_parser=float)
        self.add_parameter(name='signal_strength',
                           label='Signal strength indicator',
                           get_cmd='ILVL?',
                           get_parser=int)
        self.add_parameter(name='signal_input',
                           label='Signal input',
                           get_cmd='IVMD?',
                           get_parser=self._get_input_config,
                           set_cmd='IVMD {}',
                           set_parser=self._set_input_config,
                           vals=Enum(*self._INPUT_SIGNAL_TO_N.keys()))
        self.add_parameter(name='input_range',
                           label='Input range',
                           unit='V',
                           get_cmd='IRNG?',
                           set_cmd='IRNG {}',
                           val_mapping={1: 0,
                                        300e-3: 1,
                                        100e-3: 2,
                                        30e-3: 3,
                                        10e-3: 4})
        self.add_parameter(name='input_config',
                           label='Input configuration',
                           get_cmd='ISRC?',
                           set_cmd='ISRC {}',
                           val_mapping={'a': 0,
                                        'a-b': 1})
        self.add_parameter(name='input_shield',
                           label='Input shield',
                           get_cmd='IGND?',
                           set_cmd='IGND {}',
                           val_mapping={'float': 0,
                                        'ground': 1})
        self.add_parameter(name='input_gain',
                           label='Input gain',
                           unit='ohm',
                           get_cmd='ICUR?',
                           set_cmd='ICUR {}',
                           val_mapping={1e6: 0,
                                        100e6: 1})
        self.add_parameter(name='adv_filter',
                           label='Advanced filter',
                           get_cmd='ADVFILT?',
                           set_cmd='ADVFILT {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='input_coupling',
                           label='Input coupling',
                           get_cmd='ICPL?',
                           set_cmd='ICPL {}',
                           val_mapping={'ac': 0, 'dc': 1})
        self.add_parameter(name='time_constant',
                           label='Time constant',
                           unit='s',
                           get_cmd='OFLT?',
                           set_cmd='OFLT {}',
                           val_mapping={1e-6: 0, 3e-6: 1,
                                        10e-6: 2, 30e-6: 3,
                                        100e-6: 4, 300e-6: 5,
                                        1e-3: 6, 3e-3: 7,
                                        10e-3: 8, 30e-3: 9,
                                        100e-3: 10, 300e-3: 11,
                                        1: 12, 3: 13,
                                        10: 14, 30: 15,
                                        100: 16, 300: 17,
                                        1e3: 18, 3e3: 19,
                                        10e3: 20, 30e3: 21})

        self.add_parameter(
            name=""external_reference_trigger"",
            label=""External reference trigger mode"",
            get_cmd=""RTRG?"",
            set_cmd=""RTRG {}"",
            val_mapping={
                ""SIN"": 0,
                ""POS"": 1,
                ""POSTTL"": 1,
                ""NEG"": 2,
                ""NEGTTL"": 2,
            },
            docstring=""The triggering mode for synchronization of the ""
                      ""internal reference signal with the externally provided ""
                      ""one""
        )

        self.add_parameter(
            name=""reference_source"",
            label=""Reference source"",
            get_cmd=""RSRC?"",
            set_cmd=""RSRC {}"",
            val_mapping={
                ""INT"": 0,
                ""EXT"": 1,
                ""DUAL"": 2,
                ""CHOP"": 3
            },
            docstring=""The source of the reference signal""
        )

        self.add_parameter(
            name=""external_reference_trigger_input_resistance"",
            label=""External reference trigger input resistance"",
            get_cmd=""REFZ?"",
            set_cmd=""REFZ {}"",
            val_mapping={
                ""50"": 0,
                ""50OHMS"": 0,
                0: 0,
                ""1M"": 1,
                ""1MEG"": 1,
                1: 1,
            },
            docstring=""Input resistance of the input for the external ""
                      ""reference signal""
        )

        # Auto functions
        self.add_function('auto_range', call_cmd='ARNG')
        self.add_function('auto_scale', call_cmd='ASCL')
        self.add_function('auto_phase', call_cmd='APHS')

        # Data transfer
        # first 4 parameters from a list of 16 below.
        self.add_parameter('X',
                           label='In-phase Magnitude',
                           get_cmd='OUTP? 0',
                           get_parser=float,
                           unit='V')
        self.add_parameter('Y',
                           label='Out-phase Magnitude',
                           get_cmd='OUTP? 1',
                           get_parser=float,
                           unit='V')
        self.add_parameter('R',
                           label='Magnitude',
                           get_cmd='OUTP? 2',
                           get_parser=float,
                           unit='V')
        self.add_parameter('P',
                           label='Phase',
                           get_cmd='OUTP? 3',
                           get_parser=float,
                           unit='deg')
        self.add_parameter('complex_voltage',
                           label='Voltage',
                           get_cmd=self._get_complex_voltage,
                           unit='V',
                           vals=ComplexNumbers())

        # CH1/CH2 Output Commands
        self.add_parameter('X_offset',
                           label='X offset ',
                           unit='%',
                           get_cmd='COFP? 0',
                           set_cmd='COFP 0, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('Y_offset',
                           label='Y offset',
                           unit='%',
                           get_cmd='COFP? 1',
                           set_cmd='COFP 1, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('R_offset',
                           label='R offset',
                           unit='%',
                           get_cmd='COFP? 2',
                           set_cmd='COFP 2, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('X_expand',
                           label='X expand multiplier',
                           get_cmd='CEXP? 0',
                           set_cmd='CEXP 0, {}',
                           val_mapping={'OFF': '0',
                                        'X10': '1',
                                        'X100': '2'})
        self.add_parameter('Y_expand',
                           label='Y expand multiplier',
                           get_cmd='CEXP? 1',
                           set_cmd='CEXP 1, {}',
                           val_mapping={'OFF': 0,
                                        'X10': 1,
                                        'X100': 2})
        self.add_parameter('R_expand',
                           label='R expand multiplier',
                           get_cmd='CEXP? 2',
                           set_cmd='CEXP 2, {}',
                           val_mapping={'OFF': 0,
                                        'X10': 1,
                                        'X100': 2})

        # Aux input/output
        for i in [0, 1, 2, 3]:
            self.add_parameter(f'aux_in{i}',
                               label=f'Aux input {i}',
                               get_cmd=f'OAUX? {i}',
                               get_parser=float,
                               unit='V')
            self.add_parameter(f'aux_out{i}',
                               label=f'Aux output {i}',
                               get_cmd=f'AUXV? {i}',
                               get_parser=float,
                               set_cmd=f'AUXV {i}, {{}}',
                               unit='V')

        # Data channels:
        # 'DAT1' (green), 'DAT2' (blue), 'DAT3' (yellow), 'DAT4' (orange)
        data_channels = ChannelList(self, ""data_channels"", SR86xDataChannel,
                                    snapshotable=False)
        for num, color in zip(range(self._N_DATA_CHANNELS),
                              ('green', 'blue', 'yellow', 'orange')):
            cmd_id = f""{num}""
            cmd_id_name = f""DAT{num + 1}""
            ch_name = f""data_channel_{num + 1}""

            data_channel = SR86xDataChannel(
                self, ch_name, cmd_id, cmd_id_name, color)

            data_channels.append(data_channel)
            self.add_submodule(ch_name, data_channel)

        self.add_submodule(""data_channels"", data_channels.to_channel_tuple())

        # Interface
        self.add_function('reset', call_cmd='*RST')

        self.add_function('disable_front_panel', call_cmd='OVRM 0')
        self.add_function('enable_front_panel', call_cmd='OVRM 1')

        buffer = SR86xBuffer(self, f""{self.name}_buffer"")
        self.add_submodule(""buffer"", buffer)

        self.input_config()
        self.connect_message()

    def _set_units(self, unit: str) -> None:
        for param in [self.X, self.Y, self.R, self.sensitivity]:
            param.unit = unit

    def _get_complex_voltage(self) -> complex:
        x, y = self.get_values('X', 'Y')
        return x + 1.0j*y

    def _get_input_config(self, s: int) -> str:
        mode = self._N_TO_INPUT_SIGNAL[int(s)]

        if mode == 'voltage':
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return mode

    def _set_input_config(self, s: str) -> int:
        if s == 'voltage':
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return self._INPUT_SIGNAL_TO_N[s]

    def _get_sensitivity(self, s: int) -> float:
        if self.signal_input() == 'voltage':
            return self._N_TO_VOLT[int(s)]
        else:
            return self._N_TO_CURR[int(s)]

    def _set_sensitivity(self, s: float) -> int:
        if self.signal_input() == 'voltage':
            return self._VOLT_TO_N[s]
        else:
            return self._CURR_TO_N[s]

    def get_values(self, *parameter_names: str) -> tuple[float, ...]:
        """"""
        Get values of 2 or 3 parameters that are measured by the lock-in
        amplifier. These values are guaranteed to come from the same
        measurement cycle as opposed to getting values of parameters one by
        one (for example, by calling `sr.X()`, and then `sr.Y()`.

        Args:
            *parameter_names: 2 or 3 names of parameters for which the values
                are requested; valid names can be found in `PARAMETER_NAMES`
                attribute of the driver class

        Returns:
            a tuple of 2 or 3 floating point values

        """"""
        if not 2 <= len(parameter_names) <= 3:
            raise KeyError(
                'It is only possible to request values of 2 or 3 parameters '
                'at a time.')

        for name in parameter_names:
            if name not in self.PARAMETER_NAMES:
                raise KeyError(f'{name} is not a valid parameter name. Refer '
                               f'to `PARAMETER_NAMES` for a list of valid '
                               f'parameter names')

        p_ids = [self.PARAMETER_NAMES[name] for name in parameter_names]
        output = self.ask(f'SNAP? {"","".join(p_ids)}')
        return tuple(float(val) for val in output.split(','))

    def get_data_channels_values(self) -> tuple[float, ...]:
        """"""
        Queries the current values of the data channels

        Returns:
            tuple of 4 values of the data channels
        """"""
        output = self.ask('SNAPD?')
        return tuple(float(val) for val in output.split(','))

    def get_data_channels_parameters(
        self, query_instrument: bool = True
    ) -> tuple[str, ...]:
        """"""
        Convenience method to query a list of parameters which the data
        channels are currently assigned to.

        Args:
            query_instrument: If set to False, the internally cashed names of
                the parameters will be returned; if True, then the names will
                be queried through the instrument

        Returns:
            a tuple of 4 strings of parameter names
        """"""
        if query_instrument:
            method_name = 'get'
        else:
            method_name = 'get_latest'

        return tuple(
            getattr(getattr(self.data_channels[i], 'assigned_parameter'),
                    method_name)()
            for i in range(self._N_DATA_CHANNELS)
        )

    def get_data_channels_dict(self, requery_names: bool = False) -> dict[str, float]:
        """"""
        Returns a dictionary where the keys are parameter names currently
        assigned to the data channels, and values are the values of those
        parameters.

        Args:
            requery_names: if False, the currently assigned parameter names
                will not be queries from the instrument in order to save time
                on communication, in this case the cached assigned parameter
                names will be used for the keys of the dicitonary; if True,
                the assigned parameter names will be queried from the
                instrument

        Returns:
            a dictionary where keys are names of parameters assigned to the
            data channels, and values are the values of those parameters
        """"""
        parameter_names = self.get_data_channels_parameters(requery_names)
        parameter_values = self.get_data_channels_values()
        return dict(zip(parameter_names, parameter_values))
"
131,https://docs.zhinst.com/pdf/ziMFLI_UserManual.pdf,https://en.wikipedia.org/wiki/Lock-in_amplifier,"[OrderedDict([('id', 'attAZLZ2m8DYsl4M9'), ('width', 1183), ('height', 699), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q2QVeT7SrWPW6dGwKYLqFA/DUYak6U8es4tNvXCn55FRDCZhQ72TiHbxSdf4sgZqMG66xpclqq2eeJ2lq00QZNzsXewf1ZIjbn1qq2DWiBtkPoYjP5uxxIa1ek34JCi038/rI8O3vKnGGtiKsKJIh56UbLujfoQ_hbYWSP8S4k28wg'), ('filename', 'mfli_persp.png.webp'), ('size', 49074), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-GvL_J6u3r4j1MXHu3uGjQ/29X0rgJUUh-I1LCdzI50jSmoMk_NQU9cjmAyIvFc1r4g7hpLmOeryI2lB4Nz-aL9HwbTzxPoP1f99rGKabk7ZMHIUKqDDck0_H26wYzfUpo/gSjPm5HZX6MF_EiNKjceZOMLVP2rVqhmlNwOr0Txa0k'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ztde5CgI6r9B2oRMhm_B9Q/MaTwEPtvYk-GlZxAXjfv6vMZMtc2r-rSV3mdIT-t-41cBe8ZLcuVfDcZ_GuCFVEVHtWHC7Nbo0S4uBIvg8jkBoFzju-rqAtxOsfuuDv94B0/kXouVUC4RsXZ3sfvihZkEbso7gAQoJzyha3NWK8K-yY'), ('width', 867), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Of82YHjT4sImLTdy6L234g/pvuNBLDuswKEQ2hojUPMqyEn48FN-nCIjuHi5JOzb8F6cVNgodoahoURqkslSMOzUwXDxro7AH25SFTQ0vgh8T3ENVNCB4vfYdSdStJaDDY/y-kjE5Q8UyzyWqaRU8xFWA-XGtB9DZmC6vaBXhpH1a0'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments MFLI is a digital lock-in amplifier that covers the frequency range from DC to 500 kHz (and up to 5 MHz when upgraded). Thanks to its embedded data and web servers, the MFLI can be used directly with any device running a web browser without further software installations",https://www.zhinst.com/americas/en/products/mfli-lock-in-amplifier,Mfli,645.0,['Lockin Amplifiers'],"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/zurich_instruments/mfli.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.device_creator.MFLI.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782534/Instruments/Lockin%20Amplifiers/MFLI/MFLI.webp,MFLI,Write a Python script that uses Qcodes to connect to a MFLI Lockin Amplifiers,,,,,"# Zurich Instrument MFLI stub
#
# For the real implementation, please look into the package zhinst-qcodes
# at https://github.com/zhinst/zhinst-qcodes


try:
    from zhinst.qcodes import MFLI
except ImportError:
    raise ImportError(
        """"""
        Could not find Zurich Instruments QCodes drivers.
        Please install package zhinst-qcodes.
        """"""
    )
__all__ = [""MFLI""]
"
135,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attkiI6pMAhAdYGGx'), ('width', 749), ('height', 302), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G18FOaHaBGdRzLg0GmPh9g/DydYu-r_v5uOUJCSH4_bbb-kUTJSKEIONYAtkS61y4djQkd5ATGX-c_yfrX3yxktFN8gUhcmjK6ShkmjRM2nILbOyeu5TN6m46ZXReusv2A/mYYVlCvx_e39Fxd22hCzSFPsuodqvueWKD0bRWN8Ank'), ('filename', 'Keysight-AWG70001A.jpg'), ('size', 94446), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iCvslzUoJJxoOmV9e-895Q/Pdorwx8h8ozawD_bBth9qFkPih9yEEriM-iRXR3KPkiIL07vI51ryoYROqNKumxZ53dM32LlqskNRoifEF6gFA/z0ohR5JliJ4r3W-H86geDp3txfx_IjyS98eNvfJ5XZY'), ('width', 89), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HGPAF9N3YtZ8PgsRxswXrQ/rN6V6_5l6IKz11EIJot3Rgafbn3VyV751y6BPFWEf2_mu5Se-9CXF2K89iVHP_ccH7r5fcyA2We2_dvBQacmFw/cRbLBpC8MseqOcfQr7rsD1gmvO6jkePfDkOzzzq7Xzo'), ('width', 749), ('height', 302)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MUIUcR0Z7m8k0Edzx2NMjg/XNI3rLJD4ydFbII4Z1UmLf1EsRIqS8nkfccdLRsvlR08Mazsnl9keRroS_37QggNqkJLgR0OQWylZAleR_b72w/on2aqG9iqo4kjX0Vqv8QqYBTRreZ2wEUg8omxC92Dmg'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The AWG70001A, with Option AC, provides you with an additional high output amplitude connector. Option AC adds a single-ended AC coupled Planar Crown connector to the front panel of the single channel AWG70001A Arbitrary Waveform Generator. User controls are added to allow switching the output path between the standard Direct output connectors or the AC output connector. When switched to the AC path, additional user controlled amplification and attenuation is added to the signal path.",https://www.tek.com/en/datasheet/awg70001a-arbitrary-waveform-generator-option-ac-datasheet,Tektronix 70001 A,559.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001A,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782537/Instruments/RF%20Signal%20Generator/AWG70001A/AWG70001A.jpg,AWG70001A,Write a Python script that uses Qcodes to connect to a AWG70001A RF Signal Generator,,,True,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
136,,https://www.keysight.com/us/en/products/source-measure-units-smu.html,"[OrderedDict([('id', 'attKdAoVXw7skVsyH'), ('width', 1600), ('height', 1067), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pUpbQOjDBXrhwp8XX00gtA/EcO1eEuKEUVmPXR0PXIT-wGxlkd3dWpEGSFM8ESEiwmdGEEd87niR2C42KByyWf-_GSG03aa8PqRgG1iijPp7afXtc6p1v8J8mIMfxBlH2U/HdN6HJKm1PkpKztqsA_wzrMDKnvpH-r2BQ9FjbpBsMs'), ('filename', 'PROD-3075050-01.png'), ('size', 1143931), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hy8Ryo64wZGXJyqyP7VEWw/fPXtVVsuagsx_gjtOkXQ49UOJxz_82a3_rMLMLIhndHzWG39HEmmGH2KKClVsfRJg5Mrgfj7Ov45xrf8VxSxTg/scFH-woehSvfUpsmKsbiefR5jL_FPn8hVpcEV8L19mg'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HZa4BdwupU9XO2jb6GP15g/x5Nvdz8G5rMxnFuoLxQqbKrNRIXdrPR3jlLPkHx7VHIv_GHJeWRtMQ1-YC9oSE8Kb9uMq-SOcdZ6OtEsjlmblw/VuyTeY661SAy8bi_tMyNhXOUxBfI_Ffxd5Ujj0TvPlM'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qAzFYwM_apUWd5PxYRLnmg/65POg1qx3L6vDlM9opOSa73CYb3sfQo1UNFltGbyuaj5l23k-ZYW5whPzUIJsPdavZKkApgs5gHdRo2rm0wgkg/Zam4J7tA67CzfjNAKKKfT0cYR-o4PB79D6xjomX0B3s'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"PXI source/measure units are the source and measurement resources of voltage and current for test applications requiring high accuracy, high resolution, and measurement flexibility

",https://www.keysight.com/us/en/products/source-measure-units-smu/pxi-source-measure-units.html,KTM 960 Xdefs,284.0,"['Power Meters', 'Power Supplies']","Keysight provides a wide range of source measure units (SMU) from precision, application-specific, general-purpose, to basic instruments. Keysight SMUs precisely force and simultaneously measure voltage and/or current.

","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtM960xDefs.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightM960x,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782538/Instruments/Power%20Supplies/Keysight-M960x-defs/Keysight-M960x-defs.png,Keysight M960x defs,"Write a Python script that uses Qcodes to connect to a Keysight M960x defs Power Meters, Power Supplies",,,,,"# KtM960x Definitions
#
#   These have been copy/pasted out of KtM960x.h provided by Keysite
#
IVI_ATTR_BASE = 1000000

IVI_INHERENT_ATTR_BASE = (
    IVI_ATTR_BASE + 50000
)  # base for inherent capability attributes

# base for IVI-defined class attributes
IVI_CLASS_ATTR_BASE = IVI_ATTR_BASE + 250000

# base for IviLxiSync attributes
IVI_LXISYNC_ATTR_BASE = IVI_ATTR_BASE + 950000

IVI_SPECIFIC_ATTR_BASE = (
    IVI_ATTR_BASE + 150000
)  # base for attributes of specific drivers


# #===== IVI Inherent Instrument Attributes ==============================

# - Driver Identification

KTM960X_ATTR_SPECIFIC_DRIVER_DESCRIPTION = (
    IVI_INHERENT_ATTR_BASE + 514
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_PREFIX = (
    IVI_INHERENT_ATTR_BASE + 302
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_VENDOR = (
    IVI_INHERENT_ATTR_BASE + 513
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_REVISION = (
    IVI_INHERENT_ATTR_BASE + 551
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MAJOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 515
)  # ViInt32, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MINOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 516
)  # ViInt32, read-only

# - User Options
# ViBoolean, read-write
KTM960X_ATTR_RANGE_CHECK = IVI_INHERENT_ATTR_BASE + 2
KTM960X_ATTR_QUERY_INSTRUMENT_STATUS = (
    IVI_INHERENT_ATTR_BASE + 3
)  # ViBoolean, read-write
# ViBoolean, read-write
KTM960X_ATTR_CACHE = IVI_INHERENT_ATTR_BASE + 4
# ViBoolean, read-write
KTM960X_ATTR_SIMULATE = IVI_INHERENT_ATTR_BASE + 5
# ViBoolean, read-write
KTM960X_ATTR_RECORD_COERCIONS = IVI_INHERENT_ATTR_BASE + 6
# ViBoolean, read-write
KTM960X_ATTR_INTERCHANGE_CHECK = IVI_INHERENT_ATTR_BASE + 21

# - Advanced Session Information
# ViString, read-only
KTM960X_ATTR_LOGICAL_NAME = IVI_INHERENT_ATTR_BASE + 305
KTM960X_ATTR_IO_RESOURCE_DESCRIPTOR = (
    IVI_INHERENT_ATTR_BASE + 304
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_DRIVER_SETUP = IVI_INHERENT_ATTR_BASE + 7

# - Driver Capabilities
# ViString, read-only
KTM960X_ATTR_GROUP_CAPABILITIES = IVI_INHERENT_ATTR_BASE + 401
KTM960X_ATTR_SUPPORTED_INSTRUMENT_MODELS = (
    IVI_INHERENT_ATTR_BASE + 327
)  # ViString, read-only

# - Instrument Identification

KTM960X_ATTR_INSTRUMENT_FIRMWARE_REVISION = (
    IVI_INHERENT_ATTR_BASE + 510
)  # ViString, read-only
KTM960X_ATTR_INSTRUMENT_MANUFACTURER = (
    IVI_INHERENT_ATTR_BASE + 511
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_INSTRUMENT_MODEL = IVI_INHERENT_ATTR_BASE + 512


# ===== Instrument-Specific Attributes ===========

# - System
# ViString, read-only
KTM960X_ATTR_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 3
# ViString, read-only
KTM960X_ATTR_SYSTEM_ABOUT = IVI_SPECIFIC_ATTR_BASE + 4
KTM960X_ATTR_SYSTEM_GC_TIMING_OPTIMIZATION_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 5
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 6
)  # ViBoolean, read-write
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_INSTANCE_ID = IVI_SPECIFIC_ATTR_BASE + 7
# ViString, read-only
KTM960X_ATTR_SYSTEM_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 8
KTM960X_ATTR_SYSTEM_AUTO_TIMER_RESET_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 435
)  # ViBoolean, read-write
# ViString, read-only
KTM960X_ATTR_SYSTEM_DATE = IVI_SPECIFIC_ATTR_BASE + 436
KTM960X_ATTR_SYSTEM_INTERLOCK_THRESHOLD_VOLTAGE = (
    IVI_SPECIFIC_ATTR_BASE + 437
)  # ViReal64, read-write
KTM960X_ATTR_SYSTEM_INTERLOCK_TRIPPED = (
    IVI_SPECIFIC_ATTR_BASE + 438
)  # ViBoolean, read-only
# ViInt32, read-write
KTM960X_ATTR_SYSTEM_LINE_FREQUENCY = IVI_SPECIFIC_ATTR_BASE + 439
# ViReal64, read-only
KTM960X_ATTR_SYSTEM_TIMER_COUNT = IVI_SPECIFIC_ATTR_BASE + 440
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_CHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 514
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 518

# - Licensing

KTM960X_ATTR_LICENSING_HOST_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 11
)  # ViString, read-only
KTM960X_ATTR_LICENSING_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 12
)  # ViString, read-only

# - SFP

KTM960X_ATTR_SYSTEM_SFP_CONTROLS_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 15
)  # ViBoolean, read-write

# - AutoRefresh

KTM960X_ATTR_SYSTEM_SFP_AUTOREFRESH_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 13
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_SFP_AUTOREFRESH_PERIOD = (
    IVI_SPECIFIC_ATTR_BASE + 14
)  # ViReal64, read-write

# - Group

KTM960X_ATTR_SYSTEM_GROUP_SYNC_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 515
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_GROUP_SYNC_MASTER_MODULE = (
    IVI_SPECIFIC_ATTR_BASE + 516
)  # ViInt32, read-write
KTM960X_ATTR_SYSTEM_GROUP_SYNC_TRIGGER_LINE = (
    IVI_SPECIFIC_ATTR_BASE + 517
)  # ViInt32, read-write

# - Module
# ViInt32, read-only
KTM960X_ATTR_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 23
KTM960X_ATTR_MODULE_INSTRUMENT_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 24
)  # ViString, read-only
KTM960X_ATTR_MODULE_MAXIMUM_RECORDED_TEMPERATURE = (
    IVI_SPECIFIC_ATTR_BASE + 25
)  # ViReal64, read-only
# ViString, read-only
KTM960X_ATTR_MODULE_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 26
# ViString, read-only
KTM960X_ATTR_MODULE_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 27
# ViInt32, read-only
KTM960X_ATTR_MODULE_SLOT = IVI_SPECIFIC_ATTR_BASE + 28
# ViReal64, read-only
KTM960X_ATTR_MODULE_TEMPERATURE = IVI_SPECIFIC_ATTR_BASE + 29
# ViInt32, read-only
KTM960X_ATTR_MODULE_CHASSIS_NUMBER = IVI_SPECIFIC_ATTR_BASE + 490
KTM960X_ATTR_MODULE_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 491
)  # ViBoolean, read-write
KTM960X_ATTR_MODULE_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 492
)  # ViString, read-only
KTM960X_ATTR_MODULE_MANUFACTURING_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 508
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_MODULE_MODEL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 509
# ViInt64, read-only
KTM960X_ATTR_MODULE_UPTIME = IVI_SPECIFIC_ATTR_BASE + 511
# ViInt32, read-only
KTM960X_ATTR_MODULE_CHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 526
# ViBoolean, read-write
KTM960X_ATTR_MODULE_POWER_STATE = IVI_SPECIFIC_ATTR_BASE + 527
# ViString, read-only
KTM960X_ATTR_MODULE_VENDOR = IVI_SPECIFIC_ATTR_BASE + 528
KTM960X_ATTR_MODULE_INTERLOCK_TRIPPED = (
    IVI_SPECIFIC_ATTR_BASE + 529
)  # ViBoolean, read-only

# - Calibration

KTM960X_ATTR_MODULE_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 30
)  # ViString, read-only
KTM960X_ATTR_MODULE_CALIBRATION_DUE_DATE = (
    IVI_SPECIFIC_ATTR_BASE + 31
)  # ViString, read-only
KTM960X_ATTR_MODULE_CALIBRATION_STATUS = (
    IVI_SPECIFIC_ATTR_BASE + 524
)  # ViInt32, read-only
KTM960X_ATTR_MODULE_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 525
)  # ViString, read-only

# - Nonvolatile

KTM960X_ATTR_NONVOLATILE_ASSET_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 34
)  # ViString, read-write
KTM960X_ATTR_NONVOLATILE_CAL_DUE_REMINDER = (
    IVI_SPECIFIC_ATTR_BASE + 35
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_INSTRUMENT_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 36
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_MODULE_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 37
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_PERIODIC_CAL = (
    IVI_SPECIFIC_ATTR_BASE + 38
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_INSTRUMENT_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 39
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_MODULE_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 40
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_PASSPHRASE = (
    IVI_SPECIFIC_ATTR_BASE + 41
)  # ViString, read-write
KTM960X_ATTR_NONVOLATILE_SYSTEM_IDENTIFICATION = (
    IVI_SPECIFIC_ATTR_BASE + 42
)  # ViString, read-write

# - External
# ViInt32, read-only
KTM960X_ATTR_EXTERNAL_COUNT = IVI_SPECIFIC_ATTR_BASE + 493
KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_POSITION = (
    IVI_SPECIFIC_ATTR_BASE + 496
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_WIDTH = (
    IVI_SPECIFIC_ATTR_BASE + 497
)  # ViReal64, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_FUNCTION = (
    IVI_SPECIFIC_ATTR_BASE + 498
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 499
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 500
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 501
)  # ViInt32, read-write

# - PXIe
# ViInt32, read-only
KTM960X_ATTR_PXIE_COUNT = IVI_SPECIFIC_ATTR_BASE + 495
KTM960X_ATTR_MODULE_IO_PXIE_EDGE_POSITION = (
    IVI_SPECIFIC_ATTR_BASE + 503
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_LEVEL = IVI_SPECIFIC_ATTR_BASE + 504
# ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_TYPE = IVI_SPECIFIC_ATTR_BASE + 505
KTM960X_ATTR_MODULE_IO_PXIE_EDGE_WIDTH = (
    IVI_SPECIFIC_ATTR_BASE + 506
)  # ViReal64, read-write
KTM960X_ATTR_MODULE_IO_PXIE_FUNCTION = (
    IVI_SPECIFIC_ATTR_BASE + 507
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 530
)  # ViInt32, read-write

# - Calibration

KTM960X_ATTR_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 480
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_CALIBRATION_DUE_DATE = IVI_SPECIFIC_ATTR_BASE + 481
KTM960X_ATTR_CALIBRATION_INSTRUMENT_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 482
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_CALIBRATION_LAST_DATE = IVI_SPECIFIC_ATTR_BASE + 483
# ViInt32, read-only
KTM960X_ATTR_CALIBRATION_STATUS = IVI_SPECIFIC_ATTR_BASE + 484
KTM960X_ATTR_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 485
)  # ViString, read-only

# - Measurement
# ViInt32, read-only
KTM960X_ATTR_MEASUREMENT_COUNT = IVI_SPECIFIC_ATTR_BASE + 327
KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 486
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 489
)  # ViBoolean, read-write

# - Arm

KTM960X_ATTR_MEASUREMENT_ARM_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 328
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_ARM_COUNT = IVI_SPECIFIC_ATTR_BASE + 329
KTM960X_ATTR_MEASUREMENT_ARM_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 330
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_ARM_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 331
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_ARM_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 332
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_ARM_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 333
)  # ViBoolean, read-write

# - Current

KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE = (
    IVI_SPECIFIC_ATTR_BASE + 334
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 335
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_IS_COMPLIANCE = (
    IVI_SPECIFIC_ATTR_BASE + 340
)  # ViBoolean, read-only
KTM960X_ATTR_MEASUREMENT_CURRENT_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 341
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NEGATIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 342
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NPLC = (
    IVI_SPECIFIC_ATTR_BASE + 343
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NPLC_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 344
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_POSITIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 345
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE = (
    IVI_SPECIFIC_ATTR_BASE + 346
)  # ViReal64, read-write

# - Function

KTM960X_ATTR_MEASUREMENT_FUNCTION_DISABLE_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 348
)  # ViInt32, read-only
KTM960X_ATTR_MEASUREMENT_FUNCTION_ENABLE_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 349
)  # ViInt32, read-only

# - Trigger

KTM960X_ATTR_MEASUREMENT_TRIGGER_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 366
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 367
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 368
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 369
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 370
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 371
)  # ViBoolean, read-write

# - Voltage

KTM960X_ATTR_MEASUREMENT_VOLTAGE_APERTURE = (
    IVI_SPECIFIC_ATTR_BASE + 372
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_APERTURE_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 373
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_IS_COMPLIANCE = (
    IVI_SPECIFIC_ATTR_BASE + 378
)  # ViBoolean, read-only
KTM960X_ATTR_MEASUREMENT_VOLTAGE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 379
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NEGATIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 380
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NPLC = (
    IVI_SPECIFIC_ATTR_BASE + 381
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NPLC_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 382
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_POSITIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 383
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_RANGE = (
    IVI_SPECIFIC_ATTR_BASE + 384
)  # ViReal64, read-write

# - WaitTime

KTM960X_ATTR_MEASUREMENT_WAIT_TIME_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 386
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 387
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_GAIN = (
    IVI_SPECIFIC_ATTR_BASE + 388
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_OFFSET = (
    IVI_SPECIFIC_ATTR_BASE + 389
)  # ViReal64, read-write

# - Sampling

KTM960X_ATTR_MEASUREMENT_SAMPLING_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 487
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_SAMPLING_TOTAL_TIME = (
    IVI_SPECIFIC_ATTR_BASE + 488
)  # ViReal64, read-write

# - Output
# ViInt32, read-only
KTM960X_ATTR_OUTPUT_COUNT = IVI_SPECIFIC_ATTR_BASE + 390
KTM960X_ATTR_OUTPUT_AUTO_OFF_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 391
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_AUTO_ON_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 392
)  # ViBoolean, read-write
# ViBoolean, read-write
KTM960X_ATTR_OUTPUT_ENABLED = IVI_SPECIFIC_ATTR_BASE + 403
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_OFF_CONDITION = IVI_SPECIFIC_ATTR_BASE + 410
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_PRIORITY_MODE = IVI_SPECIFIC_ATTR_BASE + 411
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_SHAPE = IVI_SPECIFIC_ATTR_BASE + 419
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_OPERATION_MODE = IVI_SPECIFIC_ATTR_BASE + 479

# - Current

KTM960X_ATTR_OUTPUT_CURRENT_AUTO_RANGE_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 393
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_CURRENT_BASE_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 394
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_BASE_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 395
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_LEVEL = IVI_SPECIFIC_ATTR_BASE + 396
KTM960X_ATTR_OUTPUT_CURRENT_POST_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 397
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_CURRENT_POST_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 398
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_POST_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 399
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_RANGE = IVI_SPECIFIC_ATTR_BASE + 400
KTM960X_ATTR_OUTPUT_CURRENT_RANGE_LOWER_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 401
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_TRIGGERED_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 402
)  # ViReal64, read-write

# - Filter

KTM960X_ATTR_OUTPUT_FILTER_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 404
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_FILTER_CUT_OFF_FREQUENCY = (
    IVI_SPECIFIC_ATTR_BASE + 405
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_FILTER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 406
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_FILTER_TIME_CONSTANT = (
    IVI_SPECIFIC_ATTR_BASE + 407
)  # ViReal64, read-write

# - Pulse

# ViReal64, read-write
KTM960X_ATTR_OUTPUT_PULSE_DELAY = IVI_SPECIFIC_ATTR_BASE + 413
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_PULSE_WIDTH = IVI_SPECIFIC_ATTR_BASE + 414

# - Voltage

KTM960X_ATTR_OUTPUT_VOLTAGE_AUTO_RANGE_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 420
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 421
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 422
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL = IVI_SPECIFIC_ATTR_BASE + 423
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 424
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 425
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 426
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_RANGE = IVI_SPECIFIC_ATTR_BASE + 427
KTM960X_ATTR_OUTPUT_VOLTAGE_RANGE_LOWER_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 428
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_TRIGGERED_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 429
)  # ViReal64, read-write

# - WaitTime

KTM960X_ATTR_OUTPUT_WAITTIME_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 430
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_WAITTIME_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 431
)  # ViBoolean, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_WAITTIME_GAIN = IVI_SPECIFIC_ATTR_BASE + 432
KTM960X_ATTR_OUTPUT_WAITTIME_OFFSET = (
    IVI_SPECIFIC_ATTR_BASE + 433
)  # ViReal64, read-write

# - Transient

# ViInt32, read-only
KTM960X_ATTR_TRANSIENT_COUNT = IVI_SPECIFIC_ATTR_BASE + 441
KTM960X_ATTR_TRANSIENT_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 521
)  # ViBoolean, read-write

# - Arm
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_BYPASS = IVI_SPECIFIC_ATTR_BASE + 442
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_COUNT = IVI_SPECIFIC_ATTR_BASE + 443
# ViReal64, read-write
KTM960X_ATTR_TRANSIENT_ARM_DELAY = IVI_SPECIFIC_ATTR_BASE + 444
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_SOURCE = IVI_SPECIFIC_ATTR_BASE + 445
# ViReal64, read-write
KTM960X_ATTR_TRANSIENT_ARM_TIMER = IVI_SPECIFIC_ATTR_BASE + 446
KTM960X_ATTR_TRANSIENT_ARM_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 447
)  # ViBoolean, read-write

# - Current

KTM960X_ATTR_TRANSIENT_CURRENT_CENTER = (
    IVI_SPECIFIC_ATTR_BASE + 448
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 449
)  # ViInt32, read-only
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_START_POINT = (
    IVI_SPECIFIC_ATTR_BASE + 450
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 451
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_SPAN = (
    IVI_SPECIFIC_ATTR_BASE + 452
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_START = (
    IVI_SPECIFIC_ATTR_BASE + 453
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_STEP = (
    IVI_SPECIFIC_ATTR_BASE + 454
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_STOP = (
    IVI_SPECIFIC_ATTR_BASE + 455
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_SWEEP_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 456
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_OUTPUT_TRIGGER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 519
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_TRIGGER_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 520
)  # ViInt32, read-only

# - Sweep

KTM960X_ATTR_TRANSIENT_SWEEP_DIRECTION = (
    IVI_SPECIFIC_ATTR_BASE + 457
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_SWEEP_MODE = IVI_SPECIFIC_ATTR_BASE + 458
KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_RANGING_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 459
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_SCALE = (
    IVI_SPECIFIC_ATTR_BASE + 460
)  # ViInt32, read-write

# - Trigger

KTM960X_ATTR_TRANSIENT_TRIGGER_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 461
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_CONTINUOUS_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 462
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 463
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 464
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 465
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 466
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 467
)  # ViBoolean, read-write

# - Voltage

KTM960X_ATTR_TRANSIENT_VOLTAGE_CENTER = (
    IVI_SPECIFIC_ATTR_BASE + 468
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 469
)  # ViInt32, read-only
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_START_POINT = (
    IVI_SPECIFIC_ATTR_BASE + 470
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 471
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_SPAN = (
    IVI_SPECIFIC_ATTR_BASE + 472
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_START = (
    IVI_SPECIFIC_ATTR_BASE + 473
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_STEP = (
    IVI_SPECIFIC_ATTR_BASE + 474
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_STOP = (
    IVI_SPECIFIC_ATTR_BASE + 475
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_SWEEP_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 476
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_OUTPUT_TRIGGER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 522
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_TRIGGER_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 523
)  # ViInt32, read-only


# *------------------------ Attribute Value Defines -------------------------*

# - Defined values for

KTM960X_VAL_STATUS_BYTE_FLAGS_USER0 = 1
KTM960X_VAL_STATUS_BYTE_FLAGS_USER1 = 2
KTM960X_VAL_STATUS_BYTE_FLAGS_USER2 = 4
KTM960X_VAL_STATUS_BYTE_FLAGS_USER3 = 8
KTM960X_VAL_STATUS_BYTE_FLAGS_MESSAGE_AVAILABLE = 16
KTM960X_VAL_STATUS_BYTE_FLAGS_EVENT_STATUS_REGISTER = 32
KTM960X_VAL_STATUS_BYTE_FLAGS_REQUESTING_SERVICE = 64
KTM960X_VAL_STATUS_BYTE_FLAGS_USER7 = 128

# - Defined values for
# 	parameter Buttons in function KtM960x_SystemSfpMessageBox

KTM960X_VAL_MESSAGE_BOX_BUTTONS_OK = 0
KTM960X_VAL_MESSAGE_BOX_BUTTONS_OK_CANCEL = 1
KTM960X_VAL_MESSAGE_BOX_BUTTONS_YES_NO = 2

# - Defined values for
# 	parameter Val in function KtM960x_SystemSfpMessageBox

KTM960X_VAL_MESSAGE_BOX_RESULTS_NONE = 0
KTM960X_VAL_MESSAGE_BOX_RESULTS_OK = 1
KTM960X_VAL_MESSAGE_BOX_RESULTS_CANCEL = 2
KTM960X_VAL_MESSAGE_BOX_RESULTS_YES = 3
KTM960X_VAL_MESSAGE_BOX_RESULTS_NO = 4

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_CALIBRATION_STATUS
# 	attribute KTM960X_ATTR_CALIBRATION_STATUS

KTM960X_VAL_CALIBRATION_STATUS_DUE = 1
KTM960X_VAL_CALIBRATION_STATUS_EXPIRED = 2
KTM960X_VAL_CALIBRATION_STATUS_INSTRUMENT_CALIBRATED = 0
KTM960X_VAL_CALIBRATION_STATUS_MODULES_CALIBRATED = 3
KTM960X_VAL_CALIBRATION_STATUS_NOT_CALIBRATED = 4
KTM960X_VAL_CALIBRATION_STATUS_NOT_SUBJECT_TO_CALIBRATION = 5

# - Defined values for

KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_MASTER_PRODUCER = 0
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_MASTER_CONSUMER = 1
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_SLAVE_PRODUCER = 2
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_SLAVE_CONSUMER = 3
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_MASTER_PRODUCER = 4
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_MASTER_CONSUMER = 5
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_SLAVE_PRODUCER = 6
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_SLAVE_CONSUMER = 7

# - Defined values for

KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_OPAQUE = 0
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I8 = 1
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I16 = 2
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I32 = 3
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_F32 = 4
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_F64 = 5
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_K_I32V1 = 101
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_K_I24M8 = 102

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_RESOURCES_FP_SYNC = 32768
KTM960X_VAL_DEVICE_SYNC_RESOURCES_NONE = 0
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_LBL6 = 2048
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_LBR6 = 1024
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_STAR = 512
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG0 = 1
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG1 = 2
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG2 = 4
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG3 = 8
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG4 = 16
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG5 = 32
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG6 = 64
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG7 = 128
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARA = 4096
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARB = 8192
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARC = 16384

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_STATE_ARM = 1
KTM960X_VAL_DEVICE_SYNC_STATE_IDLE = 0
KTM960X_VAL_DEVICE_SYNC_STATE_RUN = 3
KTM960X_VAL_DEVICE_SYNC_STATE_TRIGGER = 2
KTM960X_VAL_DEVICE_SYNC_STATE_UNKNOWN = 4

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_ROLE_GROUP_MASTER = 2
KTM960X_VAL_DEVICE_SYNC_ROLE_LOCAL_MASTER = 4
KTM960X_VAL_DEVICE_SYNC_ROLE_OFF = 0
KTM960X_VAL_DEVICE_SYNC_ROLE_SLAVE = 3
KTM960X_VAL_DEVICE_SYNC_ROLE_SYSTEM_MASTER = 1
KTM960X_VAL_DEVICE_SYNC_ROLE_NOT_SUPPORTED = -1

# - Defined values for

KTM960X_VAL_ODI_LANE_RATE_12R5G = 1
KTM960X_VAL_ODI_LANE_RATE_14R1G = 2

# - Defined values for

KTM960X_VAL_ODI_DIRECTIONALITY_BIDIRECTIONAL = 1
KTM960X_VAL_ODI_DIRECTIONALITY_PRODUCER = 2
KTM960X_VAL_ODI_DIRECTIONALITY_CONSUMER = 3
KTM960X_VAL_ODI_DIRECTIONALITY_DUAL_UNIDIRECTIONAL = 4

# - Defined values for

KTM960X_VAL_ODI_FLOW_CONTROL_NONE = 1
KTM960X_VAL_ODI_FLOW_CONTROL_INBAND = 2
KTM960X_VAL_ODI_FLOW_CONTROL_INBAND_PER_CHANNEL = 3
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_1WIRE = 4
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_0 = 100
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_1 = 101
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_2 = 102
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_3 = 103
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_4 = 104
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_5 = 105
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_6 = 106
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_7 = 107
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_8 = 108
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_9 = 109
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_10 = 110
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_11 = 111
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_12 = 112

# - Defined values for

KTM960X_VAL_ODI_PORT_STATUS_ACTIVE = 1
KTM960X_VAL_ODI_PORT_STATUS_TX_READY = 2
KTM960X_VAL_ODI_PORT_STATUS_RX_READY = 4
KTM960X_VAL_ODI_PORT_STATUS_RX_LANE_ERROR = 8
KTM960X_VAL_ODI_PORT_STATUS_RX_BURST_MAX_ERROR = 16
KTM960X_VAL_ODI_PORT_STATUS_RX_CRC_ERROR = 32
KTM960X_VAL_ODI_PORT_STATUS_RX_OVERRUN = 64
KTM960X_VAL_ODI_PORT_STATUS_RX_FC_STATUS = 65536
KTM960X_VAL_ODI_PORT_STATUS_RX_FC_STATUS_0 = 131072
KTM960X_VAL_ODI_PORT_STATUS_RX_SIGNAL_LOSS = 128
KTM960X_VAL_ODI_PORT_STATUS_RX_SYNC_PENDING = 256

# - Defined values for

KTM960X_VAL_ODI_PACKET_FORMAT_NO_HEADER = 1
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_DATA = 2
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_WITH_CONTEXT = 3
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_ONCE = 1001
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_EXTENSION = 4

# - Defined values for

KTM960X_VAL_ODI_TIMESTAMP_FORMAT_NO_TIMESTAMP = 1
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_GPS = 2
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_RELATIVE = 3
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_SAMPLE_COUNT = 4
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_UTC = 5

# - Defined values for

KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ24 = 10
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ32 = 2
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ64 = 3
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMAT_OPAQUE = 11

# - Defined values for

KTM960X_VAL_MARKER_ENUM_MARKER1 = 1
KTM960X_VAL_MARKER_ENUM_MARKER2 = 2
KTM960X_VAL_MARKER_ENUM_MARKER3 = 3
KTM960X_VAL_MARKER_ENUM_MARKER4 = 4
KTM960X_VAL_MARKER_ENUM_MARKER_NONE = 0

# - Defined values for

KTM960X_VAL_ARB_MEMORY_MODE_ENUM_ARB_MEMORY_MODE_AUTO = 0
KTM960X_VAL_ARB_MEMORY_MODE_ENUM_ARB_MEMORY_MODE_MANUAL = 1

# - Defined values for

KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_AUTO = 99
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBDP = 1
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBDP_PLUS_MARKERS = 0
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_KEYSIGHT = 4
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_SHORT = 3
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBSP = 2

# - Defined values for
# parameter FetchType in function KtM960x_MeasurementFetchArrayData
# parameter FetchType in function KtM960x_MeasurementFetchScalarData
# parameter FetchType in function KtM960x_MeasurementReadArrayData
# parameter FetchType in function KtM960x_MeasurementReadScalarData
# parameter FetchType in function KtM960x_MeasurementFetchLatestScalarData

KTM960X_VAL_MEASUREMENT_FETCH_TYPE_CURRENT = 2
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_RESISTANCE = 3
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_SOURCE = 6
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_STATUS = 4
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_TIME = 5
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_VOLTAGE = 1
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_ALL = 0

# - Defined values for
# attribute KTM960X_ATTR_MEASUREMENT_ARM_SOURCE
# attribute KTM960X_ATTR_MEASUREMENT_TRIGGER_SOURCE
# attribute KTM960X_ATTR_TRANSIENT_ARM_SOURCE
# attribute KTM960X_ATTR_TRANSIENT_TRIGGER_SOURCE

KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_AINT = 0
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_BUS = 1
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_TIMER = 2
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI0 = 3
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI1 = 4
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI2 = 5
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI3 = 6
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI4 = 7
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI5 = 8
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI6 = 9
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI7 = 10
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_EXTERNAL1 = 11
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_EXTERNAL2 = 12
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_INTERNAL1 = 13
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_INTERNAL2 = 14
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PEER1 = 15
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PEER2 = 16

# - Defined values for
# parameter MeasureType in function KtM960x_MeasurementMeasure
# parameter Val in function KtM960x_MeasurementFunctionGetDisabled
# parameter Val in function KtM960x_MeasurementFunctionGetEnabled
# parameter MeasureType in function KtM960x_MeasurementFunctionGetState
# parameter MeasureType in function KtM960x_MeasurementFunctionSetDisabled
# parameter MeasureType in function KtM960x_MeasurementFunctionSetEnabled

KTM960X_VAL_MEASUREMENT_TYPE_CURRENT = 2
KTM960X_VAL_MEASUREMENT_TYPE_RESISTANCE = 3
KTM960X_VAL_MEASUREMENT_TYPE_VOLTAGE = 1
KTM960X_VAL_MEASUREMENT_TYPE_ALL = 0

# - Defined values for
# parameter Val in function KtM960x_MeasurementGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementSetOutputTrigger
# parameter Val in function KtM960x_MeasurementArmGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementArmSetOutputTrigger
# parameter Val in function KtM960x_MeasurementTriggerGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementTriggerSetOutputTrigger
# parameter Val in function KtM960x_TransientGetOutputTrigger
# parameter Triggers in function KtM960x_TransientSetOutputTrigger
# parameter Val in function KtM960x_TransientArmGetOutputTrigger
# parameter Triggers in function KtM960x_TransientArmSetOutputTrigger
# parameter Val in function KtM960x_TransientCurrentGetListOutputTrigger
# parameter Triggers in function KtM960x_TransientCurrentSetListOutputTrigger
# parameter Val in function KtM960x_TransientTriggerGetOutputTrigger
# parameter Triggers in function KtM960x_TransientTriggerSetOutputTrigger
# parameter Val in function KtM960x_TransientVoltageGetListOutputTrigger
# parameter Triggers in function KtM960x_TransientVoltageSetListOutputTrigger

KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI0 = 0
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI1 = 1
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI2 = 2
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI3 = 3
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI4 = 4
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI5 = 5
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI6 = 6
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI7 = 7
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_EXTERNAL1 = 8
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_EXTERNAL2 = 9
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_INTERNAL1 = 10
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_INTERNAL2 = 11
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PEER1 = 12
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PEER2 = 13

# - Defined values for
# attribute KTM960X_ATTR_MEASUREMENT_ARM_BYPASS
# attribute KTM960X_ATTR_MEASUREMENT_TRIGGER_BYPASS
# attribute KTM960X_ATTR_TRANSIENT_ARM_BYPASS
# attribute KTM960X_ATTR_TRANSIENT_TRIGGER_BYPASS

KTM960X_VAL_BYPASS_OFF = 0
KTM960X_VAL_BYPASS_ONCE = 1

# - Defined values for

KTM960X_VAL_FORCE_RANGING_MODE_NORMAL = 0
KTM960X_VAL_FORCE_RANGING_MODE_SPEED = 1
KTM960X_VAL_FORCE_RANGING_MODE_RESOLUTION = 2

# - Defined values for

KTM960X_VAL_BUFFER_CONTROL_NEXT = 0
KTM960X_VAL_BUFFER_CONTROL_NEVER = 1

# - Defined values for

KTM960X_VAL_TRACE_OPERATION_MEAN = 0
KTM960X_VAL_TRACE_OPERATION_STANDARD_DEVIATION = 1
KTM960X_VAL_TRACE_OPERATION_MAXIMUM = 2
KTM960X_VAL_TRACE_OPERATION_MINIMUM = 3
KTM960X_VAL_TRACE_OPERATION_PEAK_TO_PEAK = 4

# - Defined values for

KTM960X_VAL_TIME_STAMP_FORMAT_ABSOLUTE = 0
KTM960X_VAL_TIME_STAMP_FORMAT_DELTA = 1

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_CURRENT_BASE_TYPE
# attribute KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_TYPE

KTM960X_VAL_OUTPUT_BASE_TYPE_MANUAL = 0
KTM960X_VAL_OUTPUT_BASE_TYPE_IMMEDIATE = 1
KTM960X_VAL_OUTPUT_BASE_TYPE_TRIGGERED = 2
KTM960X_VAL_OUTPUT_BASE_TYPE_START = 3
KTM960X_VAL_OUTPUT_BASE_TYPE_STOP = 4

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_CURRENT_POST_TYPE
# attribute KTM960X_ATTR_OUTPUT_VOLTAGE_POST_TYPE

KTM960X_VAL_OUTPUT_POST_TYPE_TRIGGERED = 0
KTM960X_VAL_OUTPUT_POST_TYPE_START = 1
KTM960X_VAL_OUTPUT_POST_TYPE_STOP = 2
KTM960X_VAL_OUTPUT_POST_TYPE_BASE = 3
KTM960X_VAL_OUTPUT_POST_TYPE_MANUAL = 4
KTM960X_VAL_OUTPUT_POST_TYPE_IMMEDIATE = 5

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_OFF_CONDITION

KTM960X_VAL_OFF_CONDITION_ZERO = 0
KTM960X_VAL_OFF_CONDITION_HIZ = 1
KTM960X_VAL_OFF_CONDITION_NORMAL = 2

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_PRIORITY_MODE

KTM960X_VAL_PRIORITY_MODE_VOLTAGE = 0
KTM960X_VAL_PRIORITY_MODE_CURRENT = 1

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_SHAPE

KTM960X_VAL_SHAPE_MODE_DC = 0
KTM960X_VAL_SHAPE_MODE_PULSE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_CURRENT_MODE
# 	attribute KTM960X_ATTR_TRANSIENT_VOLTAGE_MODE

KTM960X_VAL_OUTPUT_MODE_FIXED = 0
KTM960X_VAL_OUTPUT_MODE_LIST = 1
KTM960X_VAL_OUTPUT_MODE_SWEEP = 2

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_MODE

KTM960X_VAL_SWEEP_MODE_SINGLE = 0
KTM960X_VAL_SWEEP_MODE_DOUBLE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_RANGING_MODE

KTM960X_VAL_OUTPUT_RANGING_MODE_BEST = 0
KTM960X_VAL_OUTPUT_RANGING_MODE_FIXED = 2

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_SCALE

KTM960X_VAL_OUTPUT_SCALE_LINEAR = 0

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_DIRECTION
#
KTM960X_VAL_SWEEP_DIRECTION_UP = 0
KTM960X_VAL_SWEEP_DIRECTION_DOWN = 1

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_OPERATION_MODE
KTM960X_VAL_OUTPUT_OPERATION_MODE_STANDARD = 0
KTM960X_VAL_OUTPUT_OPERATION_MODE_POWER_SUPPLY = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE

KTM960X_VAL_ACQUISITION_MODE_NORMAL = 0
KTM960X_VAL_ACQUISITION_MODE_SAMPLING = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_POSITION
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_EDGE_POSITION

KTM960X_VAL_IO_EDGE_POSITION_BEFORE = 0
KTM960X_VAL_IO_EDGE_POSITION_AFTER = 1
KTM960X_VAL_IO_EDGE_POSITION_BOTH = 2

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_FUNCTION
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_FUNCTION

KTM960X_VAL_IO_FUNCTION_TRIGGER_OUTPUT = 0
KTM960X_VAL_IO_FUNCTION_TRIGGER_INPUT = 1
KTM960X_VAL_IO_FUNCTION_DIGITAL_OUTPUT = 2

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_LEVEL
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_LEVEL
# 	parameter Val in function KtM960x_ModuleIOExternalRead
# 	parameter Val in function KtM960x_ModuleIOPxieRead

KTM960X_VAL_IO_LEVEL_HIGH = 0
KTM960X_VAL_IO_LEVEL_LOW = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_POLARITY
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_POLARITY

KTM960X_VAL_IO_POLARITY_POSITIVE = 0
KTM960X_VAL_IO_POLARITY_NEGATIVE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_TYPE
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_TYPE

KTM960X_VAL_IO_TYPE_EDGE = 0
KTM960X_VAL_IO_TYPE_LEVEL = 1

# - Defined values for
# 	attribute KTM960X_ATTR_SYSTEM_GROUP_SYNC_TRIGGER_LINE

KTM960X_VAL_SYNC_TRIGGER_LINE_PXI0 = 0
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI1 = 1
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI2 = 2
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI3 = 3
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI4 = 4
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI5 = 5
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI6 = 6
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI7 = 7
KTM960X_VAL_SYNC_TRIGGER_LINE_EXTERNAL1 = 8
KTM960X_VAL_SYNC_TRIGGER_LINE_EXTERNAL2 = 9


# ***************************************************************************
# *---------------- Instrument Driver Function Declarations -----------------*
# ***************************************************************************

# ***************************************************************************
# *----------------- Instrument Error And Completion Codes ------------------*
# ***************************************************************************


IVIC_WARN_BASE = 0x3FFA0000
IVIC_CROSS_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x1000
IVIC_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x2000
IVIC_SPECIFIC_WARN_BASE = IVIC_WARN_BASE + 0x4000

IVIC_ERROR_BASE = 0xBFFA0000
IVIC_CROSS_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x1000
IVIC_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x2000
IVIC_SPECIFIC_ERROR_BASE = IVIC_ERROR_BASE + 0x4000
IVIC_LXISYNC_ERROR_BASE = IVIC_ERROR_BASE + 0x2000

KTM960X_ERROR_CANNOT_RECOVER = IVIC_ERROR_BASE + 0x0000
KTM960X_ERROR_INSTRUMENT_STATUS = IVIC_ERROR_BASE + 0x0001
KTM960X_ERROR_CANNOT_OPEN_FILE = IVIC_ERROR_BASE + 0x0002
KTM960X_ERROR_READING_FILE = IVIC_ERROR_BASE + 0x0003
KTM960X_ERROR_WRITING_FILE = IVIC_ERROR_BASE + 0x0004
KTM960X_ERROR_INVALID_PATHNAME = IVIC_ERROR_BASE + 0x000B
KTM960X_ERROR_INVALID_ATTRIBUTE = IVIC_ERROR_BASE + 0x000C
KTM960X_ERROR_IVI_ATTR_NOT_WRITABLE = IVIC_ERROR_BASE + 0x000D
KTM960X_ERROR_IVI_ATTR_NOT_READABLE = IVIC_ERROR_BASE + 0x000E
KTM960X_ERROR_INVALID_VALUE = IVIC_ERROR_BASE + 0x0010
KTM960X_ERROR_FUNCTION_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0011
KTM960X_ERROR_ATTRIBUTE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0012
KTM960X_ERROR_VALUE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0013
KTM960X_ERROR_TYPES_DO_NOT_MATCH = IVIC_ERROR_BASE + 0x0015
KTM960X_ERROR_NOT_INITIALIZED = IVIC_ERROR_BASE + 0x001D
KTM960X_ERROR_UNKNOWN_CHANNEL_NAME = IVIC_ERROR_BASE + 0x0020
KTM960X_ERROR_TOO_MANY_OPEN_FILES = IVIC_ERROR_BASE + 0x0023
KTM960X_ERROR_CHANNEL_NAME_REQUIRED = IVIC_ERROR_BASE + 0x0044
KTM960X_ERROR_MISSING_OPTION_NAME = IVIC_ERROR_BASE + 0x0049
KTM960X_ERROR_MISSING_OPTION_VALUE = IVIC_ERROR_BASE + 0x004A
KTM960X_ERROR_BAD_OPTION_NAME = IVIC_ERROR_BASE + 0x004B
KTM960X_ERROR_BAD_OPTION_VALUE = IVIC_ERROR_BASE + 0x004C
KTM960X_ERROR_OUT_OF_MEMORY = IVIC_ERROR_BASE + 0x0056
KTM960X_ERROR_OPERATION_PENDING = IVIC_ERROR_BASE + 0x0057
KTM960X_ERROR_NULL_POINTER = IVIC_ERROR_BASE + 0x0058
KTM960X_ERROR_UNEXPECTED_RESPONSE = IVIC_ERROR_BASE + 0x0059
KTM960X_ERROR_FILE_NOT_FOUND = IVIC_ERROR_BASE + 0x005B
KTM960X_ERROR_INVALID_FILE_FORMAT = IVIC_ERROR_BASE + 0x005C
KTM960X_ERROR_STATUS_NOT_AVAILABLE = IVIC_ERROR_BASE + 0x005D
KTM960X_ERROR_ID_QUERY_FAILED = IVIC_ERROR_BASE + 0x005E
KTM960X_ERROR_RESET_FAILED = IVIC_ERROR_BASE + 0x005F
KTM960X_ERROR_RESOURCE_UNKNOWN = IVIC_ERROR_BASE + 0x0060
KTM960X_ERROR_ALREADY_INITIALIZED = IVIC_ERROR_BASE + 0x0061
KTM960X_ERROR_CANNOT_CHANGE_SIMULATION_STATE = IVIC_ERROR_BASE + 0x0062
KTM960X_ERROR_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR = IVIC_ERROR_BASE + 0x0063
KTM960X_ERROR_INVALID_RANGE_IN_SELECTOR = IVIC_ERROR_BASE + 0x0064
KTM960X_ERROR_UNKOWN_NAME_IN_SELECTOR = IVIC_ERROR_BASE + 0x0065
KTM960X_ERROR_BADLY_FORMED_SELECTOR = IVIC_ERROR_BASE + 0x0066
KTM960X_ERROR_UNKNOWN_PHYSICAL_IDENTIFIER = IVIC_ERROR_BASE + 0x0067
KTM960X_ERROR_INVALID_SESSION_HANDLE = IVIC_ERROR_BASE + 0x1190


KTM960X_SUCCESS = 0
KTM960X_WARN_NSUP_ID_QUERY = IVIC_WARN_BASE + 0x0065
KTM960X_WARN_NSUP_RESET = IVIC_WARN_BASE + 0x0066
KTM960X_WARN_NSUP_SELF_TEST = IVIC_WARN_BASE + 0x0067
KTM960X_WARN_NSUP_ERROR_QUERY = IVIC_WARN_BASE + 0x0068
KTM960X_WARN_NSUP_REV_QUERY = IVIC_WARN_BASE + 0x0069


KTM960X_ERROR_IO_GENERAL = IVIC_SPECIFIC_ERROR_BASE + 0x0214
KTM960X_ERROR_IO_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0215
KTM960X_ERROR_CALIBRATION_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0217
KTM960X_ERROR_CHECK_ERROR_QUEUE = IVIC_SPECIFIC_ERROR_BASE + 0x0218
KTM960X_ERROR_FILE_TYPE_NOT_RECOGNIZED = IVIC_SPECIFIC_ERROR_BASE + 0x0219
KTM960X_ERROR_FIRMWARE_UPDATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021A
KTM960X_ERROR_FIRMWARE_UPDATE_REQUIRED = IVIC_SPECIFIC_ERROR_BASE + 0x021B
KTM960X_ERROR_FPGA_PROGRAMMING_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021C
KTM960X_ERROR_HARDWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x021D
KTM960X_ERROR_HW_RESOURCE_NOT_AVAILABLE = IVIC_SPECIFIC_ERROR_BASE + 0x021E
KTM960X_ERROR_INCOMPATIBLE_SOFTWARE_VERSION_ERROR = \
    IVIC_SPECIFIC_ERROR_BASE + 0x021F
KTM960X_ERROR_INSTRUMENT_CALIBRATION_DUE = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0220
KTM960X_ERROR_INSTRUMENT_CALIBRATION_EXPIRED = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0221
KTM960X_ERROR_INSTRUMENT_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x0222
KTM960X_ERROR_INTERNAL_APPLICATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0223
KTM960X_ERROR_LICENSE_SYSTEM_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0224
KTM960X_ERROR_LICENSE_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0225
KTM960X_ERROR_MAX_TIME_EXCEEDED = IVIC_SPECIFIC_ERROR_BASE + 0x0226
KTM960X_ERROR_MISSING_CLOCK_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0227
KTM960X_ERROR_MODEL_NOT_SUPPORTED = IVIC_SPECIFIC_ERROR_BASE + 0x0228
KTM960X_ERROR_MODULE_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0229
KTM960X_ERROR_MODULE_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x022A
KTM960X_ERROR_MODULE_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x022B
KTM960X_ERROR_MODULE_VALIDATE_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x022C
KTM960X_ERROR_OPERATION_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x022D
KTM960X_ERROR_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022E
KTM960X_ERROR_OUT_OF_MEMORY_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022F
KTM960X_ERROR_PARAMETER_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0230
KTM960X_ERROR_PERSONALITY_NOT_ACTIVE = IVIC_SPECIFIC_ERROR_BASE + 0x0231
KTM960X_ERROR_PERSONALITY_NOT_INSTALLED = IVIC_SPECIFIC_ERROR_BASE + 0x0232
KTM960X_ERROR_PERSONALITY_NOT_LICENSED = IVIC_SPECIFIC_ERROR_BASE + 0x0233
KTM960X_ERROR_SELFTEST_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x0234
KTM960X_ERROR_SOFTWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0235
KTM960X_ERROR_TEST_FAILED_INCORRECT_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0236
KTM960X_ERROR_THERMAL_SHUTDOWN = IVIC_SPECIFIC_ERROR_BASE + 0x0237
KTM960X_ERROR_THERMAL_WARNING = IVIC_SPECIFIC_ERROR_BASE + 0x0238
KTM960X_ERROR_UNABLE_TO_INITIALIZE_HARDWARE = IVIC_SPECIFIC_ERROR_BASE + 0x0239
KTM960X_ERROR_UNRECOGNIZED_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023A
KTM960X_ERROR_UNSUPPORTED_FEATURE = IVIC_SPECIFIC_ERROR_BASE + 0x023B
KTM960X_ERROR_UNSUPPORTED_PROPERTY = IVIC_SPECIFIC_ERROR_BASE + 0x023C
KTM960X_ERROR_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023D
KTM960X_ERROR_VERIFY_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023E
KTM960X_ERROR_WAIT_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x023F
KTM960X_ERROR_NOT_IMPLEMENTED = IVIC_SPECIFIC_ERROR_BASE + 0x0240
"
141,https://www.keysight.com/us/en/assets/7018-01210/data-sheets/5989-0697.pdf,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,"[OrderedDict([('id', 'attIhLiR2xjylECCP'), ('width', 1164), ('height', 494), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/epi6gi_puBp1qg5hYpt40g/x1sTnnyfrw18bXq8Z4mcs7rh_1GK7pM7SuA3x_QywgPkTMZKFwlDxg-B20BQrawOLDG-i6GR3gXn3B-XeOaR7X2OfFSn8EKPSe8mM07w7w4/GWWLZ2hbPxQgLSMOGhPoR1kJXHlOdFcg8cSQo8D5ls8'), ('filename', 'E8267D.png'), ('size', 407303), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2Hm9X00w-XtBV7TKFGlxXQ/KzCsyj3Oe2_9uEX9WqvnwWYVVNL3x4aFj-AtymKwbv5gxP_0rTp2dTPPgGFf8u1d8gWx4FOSpRuLYXB9bYbyZA/oj6q8kHpVhRfr4ElUwZvI0ExJn24XSMgSAXNDi4aFbM'), ('width', 85), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9s9kjNyGk1IShgRVOck_CQ/HB50yOXQAB3rog-oFcTQwTkO-FzGHUs_gt3tHQUINa8wD1FFechOaDjltwZpKSaSR6zXWiT6Z5ELcQ7RFuErDA/5K75-kVHlzB2R2Nl36WIdHEvuQSGD5xt_v28AuphZv0'), ('width', 1164), ('height', 494)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QhJQl4T26L3Mw8V_Bafxjw/ezarjfDt_T_JEDR4JiYoakBq9dc6zeb1N5qOjC_wCBeqq_d7fEgx1O43Wz-jf5CRSlrJEOLreoQ5OEiwpIaXUA/_hhxiwHOHbxuW5MX-NJUbhZGiPAOLnIOQQVup6WmlMI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"E8267D PSG Vector Signal Generator, 100 kHz to 44 GHz",https://www.keysight.com/us/en/product/E8267D/psg-vector-signal-generator-100-khz-44-ghz.html?cmpid=ASA-2105924&utm_source=paid-search&utm_medium=ASA&utm_campaign=307&cq_cmp=18159629993&cq_con=141372453995&cq_term=&cq_plac=&cq_net=g&cq_pos=&cq_plt=gp&utm_term=&utm_campaign=Functional+Campaign+Paid+Search+DSA+Product+Ads+-+AMO+-EN&utm_source=adwords&utm_medium=ppc&hsa_acc=1602317043&hsa_cam=18159629993&hsa_grp=141372453995&hsa_ad=646056505105&hsa_src=g&hsa_tgt=aud-1655518197572:dsa-1923700525192&hsa_kw=&hsa_mt=&hsa_net=adwords&hsa_ver=3&gclid=Cj0KCQjw7uSkBhDGARIsAMCZNJvZ0T4_E08SKRFuZKtqOH0R4yQLDgrh8OqeN3-EX9yDvi3kaEdGzrcaAjLIEALw_wcB,"Agilent E 8267 D
",26.0,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/agilent/Agilent_E8257D.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.AgilentE8257D,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/KLdW4e0aCMvuXtiF41lm5Q/tsULR905frVMXXpSBwX--GGG9pd67YfJfVqUbiphB7yi1YiZaesAKIc0H5OSMeujmzTnzL_TYJFKsYOLX2M-HuYgDDy464YMgOwWmAd540U/CQIhv7AHEyD7_1uuRrDXD-cM5HYvTXSunU9vcixsAug'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hlmdofa38jYloahcVSLpNw/3p9k2-zlW4PdZXOINyi5WevKuox8MEkgKxpfU8qhRNpuf6uCOaEc-SiDI8AOTUAw7YWp8NRCdU2dgc1P7EdU6HAyjmQbiEO3Hp3vcYlrIOY/Q6c584Zg-Ge5NIW7DvdQ-5bvCuyqJrmDmg6PDWARSL4'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dR-u6vcQ_qWkh_hzfJEdxQ/CqsqK2EnfYs5VLISQZ0OFYxQu_f9UQE_4pV_CakymtxZEGedpRn5KZvpsUnaybslmwwnrzvwiTZYPMP4emI5NC_nZxdGIx1ebsyYeKzRvnI/_oVf9TubhrO_RGOizCZPQfUHwNRQejxeIB_SREKXPHo'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SUaU78ZSlXE2XNRXeJAbJA/6bdGaHs7U5UbkXguW0uCC_jxHbNmi66L6y9XdaPyQYZhXOjcQsnb5Vx_VObVUE-pJ0UAWtZ88P0_zZN1TD3orExVUQe-wN3ukqEB7ShXXFw/tZAWl3xpv2JxN3HZABBPT7KYR938lcxPG87n9cnzOC0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782543/Instruments/RF%20Signal%20Generator/Keysight-E8267D/Keysight-E8267D.png,Keysight E8267D,Write a Python script that uses Qcodes to connect to a Keysight E8267D RF Signal Generator,100000.0,"
",,,"import warnings
from typing import Any, Optional, Union

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class AgilentE8257D(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Agilent E8257D signal generator.
    This driver will most likely work for multiple Agilent sources.
    This driver does not contain all commands available for the E8257D but
    only the ones most commonly used.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        step_attenuator: Optional[bool] = None,
        terminator: str = ""\n"",
        **kwargs: Any
    ) -> None:
        super().__init__(name, address, terminator=terminator, **kwargs)

        if step_attenuator is not None:
            warnings.warn(
                ""step_attenuator argument to E8257D is deprecated ""
                ""and has no effect. It will be removed in the ""
                ""future.""
            )

        # Query installed options
        self._options = self.ask_raw(""DIAG:CPU:INFO:OPT:DET?"")

        # Determine installed frequency option
        frequency_option = None
        for f_option in [""513"", ""520"", ""521"", ""532"", ""540"", ""550"", ""567""]:
            if f_option in self._options:
                frequency_option = f_option
        if frequency_option is None:
            raise RuntimeError(""Could not determine the frequency option"")

        # convert installed frequency option to frequency ranges, based on:
        # https://www.keysight.com/us/en/assets/7018-01233/configuration-guides
        # /5989-1325.pdf
        # the frequency range here is the max range and not the specified
        # (calibrated) one
        f_options_dict = {
            ""513"": (100e3, 13e9),
            ""520"": (100e3, 20e9),
            ""521"": (10e6, 20e9),
            ""532"": (100e3, 31.8e9),
            ""540"": (100e3, 40e9),
            ""550"": (100e3, 50e9),
            ""567"": (100e3, 70e9),
        }

        # assign min and max frequencies
        self._min_freq: float
        self._max_freq: float
        self._min_freq, self._max_freq = f_options_dict[frequency_option]

        # Based on installed frequency option and presence/absence of step
        # attenuator (option '1E1') determine power range based on:
        # https://www.keysight.com/us/en/assets/7018-01211/data-sheets
        # /5989-0698.pdf

        # assign min and max powers
        self._min_power: float
        self._max_power: float

        if ""1E1"" in self._options:
            if frequency_option in [""513"", ""520"", ""521"", ""532"", ""540""]:
                self._min_power = -135
                self._max_power = 10
            else:
                self._min_power = -110
                self._max_power = 5
        else:
            # default minimal power is -20 dBm
            if frequency_option in [""513"", ""520"", ""521"", ""532"", ""540""]:
                self._min_power = -20
                self._max_power = 10
            else:
                self._min_power = -20
                self._max_power = 5

        self.add_parameter(
            name=""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=""FREQ:CW?"",
            set_cmd=""FREQ:CW"" + "" {:.4f}"",
            get_parser=float,
            set_parser=float,
            vals=vals.Numbers(self._min_freq, self._max_freq),
        )

        self.add_parameter(
            name=""phase"",
            label=""Phase"",
            unit=""deg"",
            get_cmd=""PHASE?"",
            set_cmd=""PHASE"" + "" {:.8f}"",
            get_parser=self.rad_to_deg,
            set_parser=self.deg_to_rad,
            vals=vals.Numbers(-180, 180),
        )

        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=""POW:AMPL?"",
            set_cmd=""POW:AMPL"" + "" {:.4f}"",
            get_parser=float,
            set_parser=float,
            vals=vals.Numbers(self._min_power, self._max_power),
        )

        self.add_parameter(
            ""output_enabled"",
            get_cmd="":OUTP?"",
            set_cmd=""OUTP {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.connect_message()

    def on(self) -> None:
        self.set(""status"", ""on"")

    def off(self) -> None:
        self.set(""status"", ""off"")

    # functions to convert between rad and deg
    @staticmethod
    def deg_to_rad(
        angle_deg: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.deg2rad(float(angle_deg))

    @staticmethod
    def rad_to_deg(
        angle_rad: Union[float, str, np.floating, np.integer]
    ) -> ""np.floating[Any]"":
        return np.rad2deg(float(angle_rad))
"
144,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/ZNB_bro_en_3608-3278-12_v0301.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'atttzWdgNIQu62X2D'), ('width', 700), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CP4Vjz6TpD-vGfVBxrtbvA/5hMTBemKQ4Wy85YsPr9udEAyxElDfslWY60_oAhCuWEltxxsqSRrVOzw9DgvNZO-B6-VzsbEXczoMqPINYfSODucPdnkJNw0TGrGCkQaBx0/IdkXrmEIX7FNCUmIH3095lktyRRPbT_tUu526nO641g'), ('filename', 'RS-ZNB-4port.webp'), ('size', 167034), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qV9jvzFPhyLSwTOVq9aT7Q/v0dheNfsiBFWTovF_VULGDuV1ajgBOSNsinbvKsRQbMSqq4t6Bd5ZeuoRVnkLUq7JtxVV9X9yoNVyKwVc3gOXH5sQcovAvJ5nN2H8kSsetc/8iqRToO5qTrcQx5xbG83pGnW61z0oW0EChG33GsakEo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/r3gfA_EiJ-9BEQbkgJPVkw/UP7mE8Y4BHptvOnNkNwIvilUKKeezQ74_Ae4w9sPKIm_aXtGQUbJF3L1xlmNf_WPqSeqNDqM4u7m7Ks-VhohhL_AMN56J54ExvHv5NWTltk/Ab1HkKeN0V3zeWHnSY5IuHthg93K2znBMFqGWeCIb_E'), ('width', 700), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hqFQJWxZwqoqyhUJwGBcqg/QfQ5KrP6Nuu3_612THcwQGKZjaocQISGpv26-yneH_hgCmwCCYJUtyDFKY-5PbDSS98ZAaKfGvlymKYr6RX1bwEoWnrdH97CXaMGLves_30/IrmHLbWpYXiDVKQPMlxKjagK78wg57nUIqj1r8_gSs0'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116717/Instruments/Vendor%20Logos/RohdeSchwarz.png,"The R&S ZNB8 from Rohde & Schwarz is a Vector Network Analyzer with Frequency 9 kHz to 8.5 GHz, Measurement Speed 4 ms, Dynamic Range typ. 122 dB to 140 dB, Output Power typ. 12 dBm to 15 dBm, Power Sweep Range 98 dB. Tags: VNA with Screen. More details for R&S ZNB8 can be seen below.",https://www.everythingrf.com/products/vector-network-analyzers/rohde-schwarz/565-92-r-s-znb8,Rohde Schwarz ZNB 8,462.0,['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/Rohde_Schwarz_ZNB8.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNB8,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XHBiQ9oxXm-n-HvM6LnRsA/zCF7wkTRkwfOTCAuwmibY3O7w00r82Jr-e9BArEz2wuEOw-7rLpTsqnPaLuh9W23W58Qwn9JURC-40I0_-4JxPkfgmT1CSF7VPctZxztnV4/I5ofu9MkvIeeFWHtoXZm_t6fUCujFLfj-JFESMUqIgk'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rp7cS3TGPqAHuTUKlrNiDg/VQ8_PlSktrAEUSma3ec9casPyXqUCiOYTta1bFMCr-JbFojx11fj4PsFxxQcQkgk5T0s4eilsQBFkmKe1f5C4A/plUaF2hmxk-9dn7wzOx_UZSUTlLGORdKrjwdpcJGgiM'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ouYl2k3tZan1Mqr3gFZ4XQ/eznvJmkOWcALsfmYE2FWZIIuDkvhPsL5ha4wYwX2hkGiFmGNwyYpsS2lgvAprhPlVCGH-c59BKm4kM4jMvjwlA/h8aBHQcCEhxqGNo05zJPlPwJ7fdGYthLjdrl6yX_uaY'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6WMk-uFRvLMFJ3F3nCseOQ/Ssto5hgGHjq8Q9vjrgnj3D0-Fay9y9tubFUbdbvK9IeGUYn2K3euoW1jshe65viP4uybZmkDEuVY84MH5n021w/_2LXQNPKEtc9MtuRG0jFWn1Hay_SQ8m2sSYN4caNxpw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782546/Instruments/Network%20Analyzer/RS-ZNB8/RS-ZNB8.webp,R&S ZNB8,Write a Python script that uses Qcodes to connect to a R&S ZNB8 Network Analyzer,,,,,"# Ensuring backwards compatibility

from .ZNB import ZNB


class RohdeSchwarzZNB8(ZNB):
    """"""
    QCoDeS driver for Rohde & Schwarz ZNB8

    """"""

    pass
"
146,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attggHVukOXnjVx1E'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kHowMeJVphfVo6GgEY7f_g/xJyKFojjeE2r8Gi0teDeLYepveN2kD2G94vKFYX0Mrum4x9mSNLn5FCGr3lYFTnaOCNwLbv_If5azf38nhWNmwLHvIxKHliHfnHxQrU1Zl0/QV1Uf-RuX3JE4ohg9m-YxKTgv1A_Cr_c9mymHVb8T_o'), ('filename', 'SR830_FP_Wide1 (1).jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QtgNZvf18r75W2S4Xp4UHQ/5FTmiTh2Z_be0CHmZgOPzMevTq5ip8dbmCtLib8skFLQGdUx70aVFYc_dGqqu0iIK02iD7fbJEAtsQcrDoLBlg/wLrd9lNjNuRJWOmkh7wyvUP8spR7E_KY_f5L7qrCljQ'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/sKaYVl-9PorllcVLHlRdJQ/OObQ6ORBLw0hfGasFPYFtzjUvcq3tuKRD4M5nlRQ-tfRnyMasGBZnuzHghoMYskpTJBk02hS3pYRfbyDVUb3Tw/TJSQVIcVQSwZ1ZSJOY9zftRjhIR2G7AvnapTw84UsW4'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/plPFZMSZ2FaLyzM8Si7A7w/Og_2i4bK9gFv_8i0RS4CJmscbATX5noAgWlNe6GJxWiQRq_mxmpZJ9Zch54vLCF5m3T7zqU4VzbTvCs__cpTDQ/_4kuGQJJE8xUaOBrOTEUk0tz-Kpk-TLATEAccY-Ww-4'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,"SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,",https://www.thinksrs.com/products/sr810830.htm,SR 830,533.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR830.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR830,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782548/Instruments/Lockin%20Amplifiers/SR-830/SR-830.jpg,SR 830,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,4250.0,,,,"import time
from collections.abc import Iterable
from functools import partial
from typing import Any, Union

import numpy as np

from qcodes.instrument import VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
)
from qcodes.validators import Arrays, ComplexNumbers, Enum, Ints, Numbers, Strings


class ChannelTrace(ParameterWithSetpoints):
    """"""
    Parameter class for the two channel buffers
    """"""

    def __init__(self, name: str, channel: int, **kwargs: Any) -> None:
        """"""
        Args:
            name: The name of the parameter
            channel: The relevant channel (1 or 2). The name should
                match this.
        """"""
        super().__init__(name, **kwargs)

        self._valid_channels = (1, 2)

        if channel not in self._valid_channels:
            raise ValueError('Invalid channel specifier. SR830 only has '
                             'channels 1 and 2.')

        if not isinstance(self.root_instrument, SR830):
            raise ValueError('Invalid parent instrument. ChannelBuffer '
                             'can only live on an SR830.')

        self.channel = channel
        self.update_unit()

    def update_unit(self) -> None:
        assert isinstance(self.root_instrument, SR830)
        params = self.root_instrument.parameters
        if params[f'ch{self.channel}_ratio'].get() != 'none':
            self.unit = '%'
        else:
            disp = params[f'ch{self.channel}_display'].get()
            if disp == 'Phase':
                self.unit = 'deg'
            else:
                self.unit = 'V'
            self.label = disp

    def get_raw(self) -> ParamRawDataType:
        """"""
        Get command. Returns numpy array
        """"""
        assert isinstance(self.root_instrument, SR830)
        N = self.root_instrument.buffer_npts()
        if N == 0:
            raise ValueError('No points stored in SR830 data buffer.'
                             ' Can not poll anything.')

        # poll raw binary data
        self.root_instrument.write(f'TRCL ? {self.channel}, 0, {N}')
        rawdata = self.root_instrument.visa_handle.read_raw()

        # parse it
        realdata = np.frombuffer(rawdata, dtype=""<i2"")
        numbers = realdata[::2] * 2.0 ** (realdata[1::2] - 124)

        return numbers


class ChannelBuffer(ArrayParameter):
    """"""
    Parameter class for the two channel buffers

    Currently always returns the entire buffer
    TODO (WilliamHPNielsen): Make it possible to query parts of the buffer.
    The instrument natively supports this in its TRCL call.
    """"""

    def __init__(self, name: str, instrument: 'SR830', channel: int) -> None:
        """"""
        Args:
            name: The name of the parameter
            instrument: The parent instrument
            channel: The relevant channel (1 or 2). The name should
                should match this.
        """"""
        self._valid_channels = (1, 2)

        if channel not in self._valid_channels:
            raise ValueError('Invalid channel specifier. SR830 only has '
                             'channels 1 and 2.')

        if not isinstance(instrument, SR830):
            raise ValueError('Invalid parent instrument. ChannelBuffer '
                             'can only live on an SR830.')

        super().__init__(
            name,
            shape=(1,),  # dummy initial shape
            unit=""V"",  # dummy initial unit
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""Holds an acquired (part of the) data buffer of one channel."",
            instrument=instrument,
        )

        self.channel = channel

    def prepare_buffer_readout(self) -> None:
        """"""
        Function to generate the setpoints for the channel buffer and
        get the right units
        """"""
        assert isinstance(self.instrument, SR830)
        N = self.instrument.buffer_npts()  # problem if this is zero?
        # TODO (WilliamHPNielsen): what if SR was changed during acquisition?
        SR = self.instrument.buffer_SR()
        if SR == 'Trigger':
            self.setpoint_units = ('',)
            self.setpoint_names = ('trig_events',)
            self.setpoint_labels = ('Trigger event number',)
            self.setpoints = (tuple(np.arange(0, N)),)
        else:
            dt = 1/SR
            self.setpoint_units = ('s',)
            self.setpoint_names = ('Time',)
            self.setpoint_labels = ('Time',)
            self.setpoints = (tuple(np.linspace(0, N*dt, N)),)

        self.shape = (N,)

        params = self.instrument.parameters
        # YES, it should be: comparing to the string 'none' and not
        # the None literal
        if params[f'ch{self.channel}_ratio'].get() != 'none':
            self.unit = '%'
        else:
            disp = params[f'ch{self.channel}_display'].get()
            if disp == 'Phase':
                self.unit = 'deg'
            else:
                self.unit = 'V'

        if self.channel == 1:
            self.instrument._buffer1_ready = True
        else:
            self.instrument._buffer2_ready = True

    def get_raw(self) -> ParamRawDataType:
        """"""
        Get command. Returns numpy array
        """"""
        assert isinstance(self.instrument, SR830)
        if self.channel == 1:
            ready = self.instrument._buffer1_ready
        else:
            ready = self.instrument._buffer2_ready

        if not ready:
            raise RuntimeError('Buffer not ready. Please run '
                               'prepare_buffer_readout')
        N = self.instrument.buffer_npts()
        if N == 0:
            raise ValueError('No points stored in SR830 data buffer.'
                             ' Can not poll anything.')

        # poll raw binary data
        self.instrument.write(f""TRCL ? {self.channel}, 0, {N}"")
        rawdata = self.instrument.visa_handle.read_raw()

        # parse it
        realdata = np.frombuffer(rawdata, dtype=""<i2"")
        numbers = realdata[::2] * 2.0 ** (realdata[1::2] - 124)
        if self.shape[0] != N:
            raise RuntimeError(
                f""SR830 got {N} points in buffer expected {self.shape[0]}""
            )
        return numbers


class SR830(VisaInstrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SR830 Lock-in Amplifier.
    """"""

    _VOLT_TO_N = {2e-9:    0, 5e-9:    1, 10e-9:  2,
                  20e-9:   3, 50e-9:   4, 100e-9: 5,
                  200e-9:  6, 500e-9:  7, 1e-6:   8,
                  2e-6:    9, 5e-6:   10, 10e-6:  11,
                  20e-6:  12, 50e-6:  13, 100e-6: 14,
                  200e-6: 15, 500e-6: 16, 1e-3:   17,
                  2e-3:   18, 5e-3:   19, 10e-3:  20,
                  20e-3:  21, 50e-3:  22, 100e-3: 23,
                  200e-3: 24, 500e-3: 25, 1:      26}
    _N_TO_VOLT = {v: k for k, v in _VOLT_TO_N.items()}

    _CURR_TO_N = {2e-15:    0, 5e-15:    1, 10e-15:  2,
                  20e-15:   3, 50e-15:   4, 100e-15: 5,
                  200e-15:  6, 500e-15:  7, 1e-12:   8,
                  2e-12:    9, 5e-12:   10, 10e-12:  11,
                  20e-12:  12, 50e-12:  13, 100e-12: 14,
                  200e-12: 15, 500e-12: 16, 1e-9:    17,
                  2e-9:    18, 5e-9:    19, 10e-9:   20,
                  20e-9:   21, 50e-9:   22, 100e-9:  23,
                  200e-9:  24, 500e-9:  25, 1e-6:    26}
    _N_TO_CURR = {v: k for k, v in _CURR_TO_N.items()}

    _VOLT_ENUM = Enum(*_VOLT_TO_N.keys())
    _CURR_ENUM = Enum(*_CURR_TO_N.keys())

    _INPUT_CONFIG_TO_N = {
        'a': 0,
        'a-b': 1,
        'I 1M': 2,
        'I 100M': 3,
    }

    _N_TO_INPUT_CONFIG = {v: k for k, v in _INPUT_CONFIG_TO_N.items()}

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, **kwargs)

        # Reference and phase
        self.add_parameter('phase',
                           label='Phase',
                           get_cmd='PHAS?',
                           get_parser=float,
                           set_cmd='PHAS {:.2f}',
                           unit='deg',
                           vals=Numbers(min_value=-360, max_value=729.99))

        self.add_parameter('reference_source',
                           label='Reference source',
                           get_cmd='FMOD?',
                           set_cmd='FMOD {}',
                           val_mapping={
                               'external': 0,
                               'internal': 1,
                           },
                           vals=Enum('external', 'internal'))

        self.add_parameter('frequency',
                           label='Frequency',
                           get_cmd='FREQ?',
                           get_parser=float,
                           set_cmd='FREQ {:.4f}',
                           unit='Hz',
                           vals=Numbers(min_value=1e-3, max_value=102e3))

        self.add_parameter('ext_trigger',
                           label='External trigger',
                           get_cmd='RSLP?',
                           set_cmd='RSLP {}',
                           val_mapping={
                               'sine': 0,
                               'TTL rising': 1,
                               'TTL falling': 2,
                           })

        self.add_parameter('harmonic',
                           label='Harmonic',
                           get_cmd='HARM?',
                           get_parser=int,
                           set_cmd='HARM {:d}',
                           vals=Ints(min_value=1, max_value=19999))

        self.add_parameter('amplitude',
                           label='Amplitude',
                           get_cmd='SLVL?',
                           get_parser=float,
                           set_cmd='SLVL {:.3f}',
                           unit='V',
                           vals=Numbers(min_value=0.004, max_value=5.000))

        # Input and filter
        self.add_parameter('input_config',
                           label='Input configuration',
                           get_cmd='ISRC?',
                           get_parser=self._get_input_config,
                           set_cmd='ISRC {}',
                           set_parser=self._set_input_config,
                           vals=Enum(*self._INPUT_CONFIG_TO_N.keys()))

        self.add_parameter('input_shield',
                           label='Input shield',
                           get_cmd='IGND?',
                           set_cmd='IGND {}',
                           val_mapping={
                               'float': 0,
                               'ground': 1,
                           })

        self.add_parameter('input_coupling',
                           label='Input coupling',
                           get_cmd='ICPL?',
                           set_cmd='ICPL {}',
                           val_mapping={
                               'AC': 0,
                               'DC': 1,
                           })

        self.add_parameter('notch_filter',
                           label='Notch filter',
                           get_cmd='ILIN?',
                           set_cmd='ILIN {}',
                           val_mapping={
                               'off': 0,
                               'line in': 1,
                               '2x line in': 2,
                               'both': 3,
                           })

        # Gain and time constant
        self.add_parameter(name='sensitivity',
                           label='Sensitivity',
                           get_cmd='SENS?',
                           set_cmd='SENS {:d}',
                           get_parser=self._get_sensitivity,
                           set_parser=self._set_sensitivity
                           )

        self.add_parameter('reserve',
                           label='Reserve',
                           get_cmd='RMOD?',
                           set_cmd='RMOD {}',
                           val_mapping={
                               'high': 0,
                               'normal': 1,
                               'low noise': 2,
                           })

        self.add_parameter('time_constant',
                           label='Time constant',
                           get_cmd='OFLT?',
                           set_cmd='OFLT {}',
                           unit='s',
                           val_mapping={
                               10e-6:  0, 30e-6:  1,
                               100e-6: 2, 300e-6: 3,
                               1e-3:   4, 3e-3:   5,
                               10e-3:  6, 30e-3:  7,
                               100e-3: 8, 300e-3: 9,
                               1:     10, 3:     11,
                               10:    12, 30:    13,
                               100:   14, 300:   15,
                               1e3:   16, 3e3:   17,
                               10e3:  18, 30e3:  19,
                           })

        self.add_parameter('filter_slope',
                           label='Filter slope',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           unit='dB/oct',
                           val_mapping={
                               6: 0,
                               12: 1,
                               18: 2,
                               24: 3,
                           })

        self.add_parameter('sync_filter',
                           label='Sync filter',
                           get_cmd='SYNC?',
                           set_cmd='SYNC {}',
                           val_mapping={
                               'off': 0,
                               'on': 1,
                           })

        def parse_offset_get(s: str) -> tuple[float, int]:
            parts = s.split(',')

            return float(parts[0]), int(parts[1])

        # TODO: Parameters that can be set with multiple arguments
        # For the OEXP command for example two arguments are needed
        self.add_parameter('X_offset',
                           get_cmd='OEXP? 1',
                           get_parser=parse_offset_get)

        self.add_parameter('Y_offset',
                           get_cmd='OEXP? 2',
                           get_parser=parse_offset_get)

        self.add_parameter('R_offset',
                           get_cmd='OEXP? 3',
                           get_parser=parse_offset_get)

        # Aux input/output
        for i in [1, 2, 3, 4]:
            self.add_parameter(f'aux_in{i}',
                               label=f'Aux input {i}',
                               get_cmd=f'OAUX? {i}',
                               get_parser=float,
                               unit='V')

            self.add_parameter(f'aux_out{i}',
                               label=f'Aux output {i}',
                               get_cmd=f'AUXV? {i}',
                               get_parser=float,
                               set_cmd=f'AUXV {i}, {{}}',
                               unit='V')

        # Setup
        self.add_parameter('output_interface',
                           label='Output interface',
                           get_cmd='OUTX?',
                           set_cmd='OUTX {}',
                           val_mapping={
                               'RS232': '0\n',
                               'GPIB': '1\n',
                           })

        # Data transfer
        self.add_parameter('X',
                           get_cmd='OUTP? 1',
                           get_parser=float,
                           unit='V')

        self.add_parameter('Y',
                           get_cmd='OUTP? 2',
                           get_parser=float,
                           unit='V')

        self.add_parameter('R',
                           get_cmd='OUTP? 3',
                           get_parser=float,
                           unit='V')

        self.add_parameter('P',
                           get_cmd='OUTP? 4',
                           get_parser=float,
                           unit='deg')

        self.add_parameter(
            ""complex_voltage"",
            label=""Voltage"",
            get_cmd=self._get_complex_voltage,
            unit=""V"",
            docstring=""Complex voltage parameter ""
            ""calculated from X, Y phase using ""
            ""Z = X +j*Y"",
            vals=ComplexNumbers(),
        )

        # Data buffer settings
        self.add_parameter('buffer_SR',
                           label='Buffer sample rate',
                           get_cmd='SRAT ?',
                           set_cmd=self._set_buffer_SR,
                           unit='Hz',
                           val_mapping={62.5e-3: 0,
                                        0.125: 1,
                                        0.250: 2,
                                        0.5: 3,
                                        1: 4, 2: 5,
                                        4: 6, 8: 7,
                                        16: 8, 32: 9,
                                        64: 10, 128: 11,
                                        256: 12, 512: 13,
                                        'Trigger': 14},
                           get_parser=int
                           )

        self.add_parameter('buffer_acq_mode',
                           label='Buffer acquistion mode',
                           get_cmd='SEND ?',
                           set_cmd='SEND {}',
                           val_mapping={'single shot': 0,
                                        'loop': 1},
                           get_parser=int)

        self.add_parameter('buffer_trig_mode',
                           label='Buffer trigger start mode',
                           get_cmd='TSTR ?',
                           set_cmd='TSTR {}',
                           val_mapping={'ON': 1, 'OFF': 0},
                           get_parser=int)

        self.add_parameter('buffer_npts',
                           label='Buffer number of stored points',
                           get_cmd='SPTS ?',
                           get_parser=int)

        self.add_parameter('sweep_setpoints',
                           parameter_class=GeneratedSetPoints,
                           vals=Arrays(shape=(self.buffer_npts.get,)))

        # Channel setup
        for ch in range(1, 3):

            # detailed validation and mapping performed in set/get functions
            self.add_parameter(f'ch{ch}_ratio',
                               label=f'Channel {ch} ratio',
                               get_cmd=partial(self._get_ch_ratio, ch),
                               set_cmd=partial(self._set_ch_ratio, ch),
                               vals=Strings())
            self.add_parameter(f'ch{ch}_display',
                               label=f'Channel {ch} display',
                               get_cmd=partial(self._get_ch_display, ch),
                               set_cmd=partial(self._set_ch_display, ch),
                               vals=Strings())
            self.add_parameter(f'ch{ch}_databuffer',
                               channel=ch,
                               parameter_class=ChannelBuffer)
            self.add_parameter(f'ch{ch}_datatrace',
                               channel=ch,
                               vals=Arrays(shape=(self.buffer_npts.get,)),
                               setpoints=(self.sweep_setpoints,),
                               parameter_class=ChannelTrace)

        # Auto functions
        self.add_function('auto_gain', call_cmd='AGAN')
        self.add_function('auto_reserve', call_cmd='ARSV')
        self.add_function('auto_phase', call_cmd='APHS')
        self.add_function('auto_offset', call_cmd='AOFF {0}',
                          args=[Enum(1, 2, 3)])

        # Interface
        self.add_function('reset', call_cmd='*RST')

        self.add_function('disable_front_panel', call_cmd='OVRM 0')
        self.add_function('enable_front_panel', call_cmd='OVRM 1')

        self.add_function('send_trigger', call_cmd='TRIG',
                          docstring=(""Send a software trigger. ""
                                     ""This command has the same effect as a ""
                                     ""trigger at the rear panel trigger""
                                     "" input.""))

        self.add_function('buffer_start', call_cmd='STRT',
                          docstring=(""The buffer_start command starts or ""
                                     ""resumes data storage. buffer_start""
                                     "" is ignored if storage is already in""
                                     "" progress.""))

        self.add_function('buffer_pause', call_cmd='PAUS',
                          docstring=(""The buffer_pause command pauses data ""
                                     ""storage. If storage is already paused ""
                                     ""or reset then this command is ignored.""))

        self.add_function('buffer_reset', call_cmd='REST',
                          docstring=(""The buffer_reset command resets the data""
                                     "" buffers. The buffer_reset command can ""
                                     ""be sent at any time - any storage in ""
                                     ""progress, paused or not, will be reset.""
                                     "" This command will erase the data ""
                                     ""buffer.""))

        # Initialize the proper units of the outputs and sensitivities
        self.input_config()

        # start keeping track of buffer setpoints
        self._buffer1_ready = False
        self._buffer2_ready = False

        self.connect_message()


    SNAP_PARAMETERS = {
            'x': '1',
            'y': '2',
            'r': '3',
            'p': '4',
        'phase': '4',
            'θ': '4',
         'aux1': '5',
         'aux2': '6',
         'aux3': '7',
         'aux4': '8',
         'freq': '9',
          'ch1': '10',
          'ch2': '11'
    }

    def snap(self, *parameters: str) -> tuple[float, ...]:
        """"""
        Get between 2 and 6 parameters at a single instant. This provides a
        coherent snapshot of measured signals. Pick up to 6 from: X, Y, R, θ,
        the aux inputs 1-4, frequency, or what is currently displayed on
        channels 1 and 2.

        Reading X and Y (or R and θ) gives a coherent snapshot of the signal.
        Snap is important when the time constant is very short, a time constant
        less than 100 ms.

        Args:
            *parameters: From 2 to 6 strings of names of parameters for which
                the values are requested. including: 'x', 'y', 'r', 'p',
                'phase' or 'θ', 'aux1', 'aux2', 'aux3', 'aux4', 'freq',
                'ch1', and 'ch2'.

        Returns:
            A tuple of floating point values in the same order as requested.

        Examples:
            >>> lockin.snap('x','y') -> tuple(x,y)

            >>> lockin.snap('aux1','aux2','freq','phase')
            >>> -> tuple(aux1,aux2,freq,phase)

        Note:
            Volts for x, y, r, and aux 1-4
            Degrees for θ
            Hertz for freq
            Unknown for ch1 and ch2. It will depend on what was set.

             - If X,Y,R and θ are all read, then the values of X,Y are recorded
               approximately 10 µs apart from R,θ. Thus, the values of X and Y
               may not yield the exact values of R and θ from a single snap.
             - The values of the Aux Inputs may have an uncertainty of
               up to 32 µs.
             - The frequency is computed only every other period or 40 ms,
               whichever is longer.
        """"""
        if not 2 <= len(parameters) <= 6:
            raise KeyError(
                'It is only possible to request values of 2 to 6 parameters'
                ' at a time.')

        for name in parameters:
            if name.lower() not in self.SNAP_PARAMETERS:
                raise KeyError(f'{name} is an unknown parameter. Refer'
                               f' to `SNAP_PARAMETERS` for a list of valid'
                               f' parameter names')

        p_ids = [self.SNAP_PARAMETERS[name.lower()] for name in parameters]
        output = self.ask(f'SNAP? {"","".join(p_ids)}')

        return tuple(float(val) for val in output.split(','))

    def increment_sensitivity(self) -> bool:
        """"""
        Increment the sensitivity setting of the lock-in. This is equivalent
        to pushing the sensitivity up button on the front panel. This has no
        effect if the sensitivity is already at the maximum.

        Returns:
            Whether or not the sensitivity was actually changed.
        """"""
        return self._change_sensitivity(1)

    def decrement_sensitivity(self) -> bool:
        """"""
        Decrement the sensitivity setting of the lock-in. This is equivalent
        to pushing the sensitivity down button on the front panel. This has no
        effect if the sensitivity is already at the minimum.

        Returns:
            Whether or not the sensitivity was actually changed.
        """"""
        return self._change_sensitivity(-1)

    def _change_sensitivity(self, dn: int) -> bool:
        if self.input_config() in ['a', 'a-b']:
            n_to = self._N_TO_VOLT
            to_n = self._VOLT_TO_N
        else:
            n_to = self._N_TO_CURR
            to_n = self._CURR_TO_N

        n = to_n[self.sensitivity()]

        if n + dn > max(n_to.keys()) or n + dn < min(n_to.keys()):
            return False

        self.sensitivity.set(n_to[n + dn])
        return True

    def _set_buffer_SR(self, SR: int) -> None:
        self.write(f'SRAT {SR}')
        self._buffer1_ready = False
        self._buffer2_ready = False
        self.sweep_setpoints.update_units_if_constant_sample_rate()

    def _get_ch_ratio(self, channel: int) -> str:
        val_mapping = {1: {0: 'none',
                           1: 'Aux In 1',
                           2: 'Aux In 2'},
                       2: {0: 'none',
                           1: 'Aux In 3',
                           2: 'Aux In 4'}}
        resp = int(self.ask(f'DDEF ? {channel}').split(',')[1])

        return val_mapping[channel][resp]

    def _set_ch_ratio(self, channel: int, ratio: str) -> None:
        val_mapping = {1: {'none': 0,
                           'Aux In 1': 1,
                           'Aux In 2': 2},
                       2: {'none': 0,
                           'Aux In 3': 1,
                           'Aux In 4': 2}}
        vals = val_mapping[channel].keys()
        if ratio not in vals:
            raise ValueError(f'{ratio} not in {vals}')
        ratio_int = val_mapping[channel][ratio]
        disp_val = int(self.ask(f'DDEF ? {channel}').split(',')[0])
        self.write(f'DDEF {channel}, {disp_val}, {ratio_int}')
        self._buffer_ready = False

    def _get_ch_display(self, channel: int) -> str:
        val_mapping = {1: {0: 'X',
                           1: 'R',
                           2: 'X Noise',
                           3: 'Aux In 1',
                           4: 'Aux In 2'},
                       2: {0: 'Y',
                           1: 'Phase',
                           2: 'Y Noise',
                           3: 'Aux In 3',
                           4: 'Aux In 4'}}
        resp = int(self.ask(f'DDEF ? {channel}').split(',')[0])

        return val_mapping[channel][resp]

    def _set_ch_display(self, channel: int, disp: str) -> None:
        val_mapping = {1: {'X': 0,
                           'R': 1,
                           'X Noise': 2,
                           'Aux In 1': 3,
                           'Aux In 2': 4},
                       2: {'Y': 0,
                           'Phase': 1,
                           'Y Noise': 2,
                           'Aux In 3': 3,
                           'Aux In 4': 4}}
        vals = val_mapping[channel].keys()
        if disp not in vals:
            raise ValueError(f'{disp} not in {vals}')
        disp_int = val_mapping[channel][disp]
        # Since ratio AND display are set simultaneously,
        # we get and then re-set the current ratio value
        ratio_val = int(self.ask(f'DDEF ? {channel}').split(',')[1])
        self.write(f'DDEF {channel}, {disp_int}, {ratio_val}')
        self._buffer_ready = False
        # we update the unit of the datatrace
        # according to the choice of channel
        params = self.parameters
        dataparam = params[f'ch{channel}_datatrace']
        assert isinstance(dataparam, ChannelTrace)
        dataparam.update_unit()

    def _set_units(self, unit: str) -> None:
        # TODO:
        # make a public parameter function that allows to change the units
        for param in [self.X, self.Y, self.R, self.sensitivity]:
            param.unit = unit

    def _get_complex_voltage(self) -> complex:
        x, y = self.snap(""X"", ""Y"")
        return x + 1.0j * y

    def _get_input_config(self, s: int) -> str:
        mode = self._N_TO_INPUT_CONFIG[int(s)]

        if mode in ['a', 'a-b']:
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return mode

    def _set_input_config(self, s: str) -> int:
        if s in ['a', 'a-b']:
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return self._INPUT_CONFIG_TO_N[s]

    def _get_sensitivity(self, s: int) -> float:
        if self.input_config() in ['a', 'a-b']:
            return self._N_TO_VOLT[int(s)]
        else:
            return self._N_TO_CURR[int(s)]

    def _set_sensitivity(self, s: float) -> int:
        if self.input_config() in ['a', 'a-b']:
            return self._VOLT_TO_N[s]
        else:
            return self._CURR_TO_N[s]

    def autorange(self, max_changes: int = 1) -> None:
        """"""
        Automatically changes the sensitivity of the instrument according to
        the R value and defined max_changes.

        Args:
            max_changes: Maximum number of steps allowing the function to
                automatically change the sensitivity (default is 1). The actual
                number of steps needed to change to the optimal sensitivity may
                be more or less than this maximum.
        """"""
        def autorange_once() -> bool:
            r = self.R()
            sens = self.sensitivity()
            if r > 0.9 * sens:
                return self.increment_sensitivity()
            elif r < 0.1 * sens:
                return self.decrement_sensitivity()
            return False

        sets = 0
        while autorange_once() and sets < max_changes:
            sets += 1
            time.sleep(self.time_constant())

    def set_sweep_parameters(self,
                             sweep_param: Parameter,
                             start: float,
                             stop: float,
                             n_points: int = 10,
                             label: Union[str, None] = None) -> None:

        self.sweep_setpoints.sweep_array = np.linspace(start, stop, n_points)
        self.sweep_setpoints.unit = sweep_param.unit
        if label is not None:
            self.sweep_setpoints.label = label
        elif sweep_param.label is not None:
            self.sweep_setpoints.label = sweep_param.label


class GeneratedSetPoints(Parameter):
    """"""
    A parameter that generates a setpoint array from start, stop and num points
    parameters.
    """"""
    def __init__(self,
                 sweep_array: Iterable[Union[float, int]] = np.linspace(0, 1, 10),
                 *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.sweep_array = sweep_array
        self.update_units_if_constant_sample_rate()

    def update_units_if_constant_sample_rate(self) -> None:
        """"""
        If the buffer is filled at a constant sample rate,
        update the unit to ""s"" and label to ""Time"";
        otherwise do nothing
        """"""
        assert isinstance(self.root_instrument, SR830)
        SR = self.root_instrument.buffer_SR.get()
        if SR != 'Trigger':
            self.unit = 's'
            self.label = 'Time'

    def set_raw(self, value: Iterable[Union[float, int]]) -> None:
        self.sweep_array = value

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.root_instrument, SR830)
        SR = self.root_instrument.buffer_SR.get()
        if SR == 'Trigger':
            return self.sweep_array
        else:
            N = self.root_instrument.buffer_npts.get()
            dt = 1/SR

            return np.linspace(0, N*dt, N)
"
149,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,"[OrderedDict([('id', 'attep8JPM5PjAYEs7'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZMzsfPYcCDsLKkJEAH8JDw/PCFOvaOW9v2DIzUeoj9RKNCMq-BN5GIr-UYyVKcf1fAyEDBVmXZzzXdjVcA-hxvr7CW7TYAQs6fGDTBQScS8xY_4-PY7jLbzV1Q_1lG98xXmzPgcOD-yqbELXDKF5nCF/lno8WHNrQfzRJHtNxrCUdkk_mZ61SvHUUY_nX7fVg7A'), ('filename', '34980A-FRONT-TRANSP-01-20190415.png'), ('size', 891966), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WlYjEn1gTrmX7QxnU3YK5Q/E2XwDfyeQTN2oHThq0GlIOkc6R3j7tmQ62VF99TyK1uhGHCmF-ilbBVbiZDiaSrX38_MP8s0S2a8ECSUofkfKg/tKMGQDjqdedIz8JwO9Y5ltKUYkqM9ZZ6R0b0WFy8i4w'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lZLeaPe95yuZmegj4GrgDA/FzHryBk0ab5xyrtEhV3VtEMeZqXQmQJnI5I-dnN2bF1eHw9GGS4Gj866AoNiB_I71VHpylen8UTBxTgJDm-66A/p2y0OC_FmUlv-pSr6yjOpSLcRg6scZRUTut1Zjzfx5g'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9t9IEY1dFpyjcNJmIeMQ9A/km0ju1t_LX75aUiSGEymCfym47a3tRkTn6yD7VrRGiXXSoOXvAB2YwGyXScI34a5E0EGl8agWpx5KhWY-Ie7vw/My0UmN_611pcOpJXuwk6CthfjqHqyb0tIyk33xcm8PU'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight 34980A Multifunction Switch/Measure unit is designed for R&D and
manufacturing test engineers who are working in design verification, automated
test or data acquisition and are either looking to upgrade their existing systems or
are in need of a new, cost-effective alternative",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,Keysight 34980 A,339.0,"['DAQ boards', 'Multimeters']","With 19 different plug-in modules in low frequency, RF and microwave switching to
20GHz, digital I/O, D/A converters, and counter/totalizer functionality, the 34980A
has the core switch/measure functionality needed for most automated test and
data acquisition applications. The 34980A can accommodate up to 560 2-wire
MUX or 1024 2-wire matrix crosspoints in one mainframe.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34980a.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34980A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782551/Instruments/DAQ%20boards/Keysight-34980A/Keysight-34980A.png,Keysight 34980A,"Write a Python script that uses Qcodes to connect to a Keysight 34980A DAQ boards, Multimeters",4167.0,,,,"import logging
import warnings
import re
from functools import wraps
from typing import Any, TypeVar, Dict
from .keysight_34980a_submodules import KeysightSubModule
from .keysight_34934a import Keysight34934A
from qcodes.instrument.visa import VisaInstrument

from qcodes.utils import validators as vals
from typing import Callable, Optional

KEYSIGHT_MODELS = {'34934A': Keysight34934A}


T = TypeVar('T')


def post_execution_status_poll(func: Callable[..., T]) -> Callable[..., T]:
    """"""
    Generates a decorator that clears the instrument's status registers
    before executing the actual call and reads the status register after the
    function call to determine whether an error occurs.

    Args:
        func: function to wrap
    """"""
    @wraps(func)
    def wrapper(self: ""Keysight34980A"", *args: Any, **kwargs: Any) -> T:
        self.clear_status()
        retval = func(self, *args, **kwargs)

        stb = self.get_status()
        if stb:
            warnings.warn(f""Instrument status byte indicates an error occurred ""
                          f""(value of STB was: {stb})! Use `get_error` method ""
                          f""to poll error message."",
                          stacklevel=2)
        return retval

    return wrapper


class Keysight34980A(VisaInstrument):
    """"""
    QCodes driver for 34980A switch/measure unit
    """"""
    def __init__(self,
                 name: str,
                 address: str,
                 terminator: str = '\n',
                 **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address.
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self._total_slot = 8
        self._system_slots_info_dict: Optional[Dict[int, Dict[str, str]]] = None
        self.module = dict.fromkeys(self.system_slots_info.keys())
        self.scan_slots()
        self.connect_message()

    def get_status(self) -> int:
        """"""
        Queries status register

        Returns:
            0 if there is no error
        """"""
        msg = super().ask('*ESR?')
        nums = list(map(int, re.findall(r'\d+', msg)))
        return nums[0]

    def get_error(self) -> str:
        """"""
        Queries error queue

        Returns:
            error message, or '+0,""No error""' if there is no error
        """"""
        msg = super().ask(':SYST:ERR?')
        return msg

    def clear_status(self) -> None:
        """"""
        Clears status register and error queue of the instrument.
        """"""
        super().write('*CLS')

    def reset(self) -> None:
        """"""
        Performs an instrument reset.
        Does not reset error queue!
        """"""
        super().write('*RST')

    @post_execution_status_poll
    def ask(self, cmd: str) -> str:
        return super().ask(cmd)

    @post_execution_status_poll
    def write(self, cmd: str) -> None:
        return super().write(cmd)

    def scan_slots(self) -> None:
        """"""
        Scan the occupied slots and make an object for each switch matrix
        module installed
        """"""
        for slot in self.system_slots_info.keys():
            model_string = self.system_slots_info[slot]['model']
            for model in KEYSIGHT_MODELS:
                if model in model_string:
                    sub_module_name = f'slot_{slot}_{model}'
                    sub_module = KEYSIGHT_MODELS[model](self,
                                                        sub_module_name,
                                                        slot)
                    self.module[slot] = sub_module
                    self.add_submodule(sub_module_name, sub_module)
                    break
            if self.module[slot] is None:
                sub_module_name = f'slot_{slot}_{model_string}_no_driver'
                sub_module_no_driver = KeysightSubModule(self,
                                                         sub_module_name,
                                                         slot)
                self.module[slot] = sub_module_no_driver
                self.add_submodule(sub_module_name, sub_module_no_driver)
                logging.warning(f'can not find driver for {model_string}'
                                f'in slot {slot}')

    @property
    def system_slots_info(self) -> Dict[int, Dict[str, str]]:
        if self._system_slots_info_dict is None:
            self._system_slots_info_dict = self._system_slots_info()
        return self._system_slots_info_dict

    def _system_slots_info(self) -> Dict[int, Dict[str, str]]:
        """"""
        the command SYST:CTYP? returns the following:
        Agilent Technologies,<Model Number>,<Serial Number>,<Firmware Rev>
        where <Model Number> is '0' if there is no module connected to the
        given slot

        Returns:
            a dictionary, with slot numbers as the keys, and vendor/model/
            serial/firmware dictionaries as the values
        """"""
        slots_dict = {}
        keys = ['vendor', 'model', 'serial', 'firmware']
        for i in range(1, self._total_slot+1):
            identity = self.ask(f'SYST:CTYP? {i}').strip('""').split(',')
            if identity[1] != '0':
                slots_dict[i] = dict(zip(keys, identity))
        return slots_dict

    def disconnect_all(self, slot: Optional[int] = None) -> None:
        """"""
        to open/disconnect all connections on select module

        Args:
            slot: slot number, between 1 and 8 (self._total_slot),
                    default value is None, which means all slots
        """"""
        cmd = 'ROUT:OPEN:ALL'
        if slot is None:
            self.write(cmd)
        else:
            vals.Ints(min_value=1, max_value=self._total_slot).validate(slot)
            self.write(f'ROUT:OPEN:ALL {slot}')
"
152,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attzNqAqcbJaKQQP3'), ('width', 1324), ('height', 547), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gMU7eXEN3Tvdf88p1nI5Kg/V4Z8dXTqPz1Aa7lPeebs-HT-yG5YECd8NnyKPYfdHYXdLb9I0gBblk0LbQcOQ5lYsB_viiwt4TRBgxSzvxHCJg6_bmoGxg42_GAq-fvZHwI/-WJbtoWa10kxp24-NICm6M_YH5IRXvGsqR-QaizjTiM'), ('filename', 'Keysight-33510B-1.jpg'), ('size', 96828), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RwvRqUe3kY_UAfXN-RTtbA/Nc0Vv2mw9uib8igOkcHfAc6v-bMUkaMkoUKgaQTBfQaEBFYOjjEkoSDQNfBSiZsYIGBDPJkB2Yq7vy7da4AVfw/Pgp8gddy50ZzjEPAdCmMS00KP7sKB0Javzq0_uUONB8'), ('width', 87), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/S5C-4xIr8Me-mF2I3QDLsw/Jf5QpgYYUdRJzkwPPHWrIhTZUg8Euj4iFWDX3k1_WaeGsbZSjMYv6yNZX6iME15nfHN7JbdpbZ6NAma_XSiFqw/eyXsEcpUrhWC14_Zthi8cXd0y6qoXkt60_sL5BV4zyg'), ('width', 1239), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/E337iYY1UW_EUn_9nrxLOg/EMkRQUE3ie5WbsYlsu7bfA50pIRiInzdI0C_TmtlkGVJQIGw9mfc8IBn3JyJ6gQhwyVPu8Q1o5x_WGPmxr2hnA/RCzJ6tEXHRlbAZngJOpRfHgUUtsowUhi-gMlHxdQYrw'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 33510B waveform generator provides Keysight's exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements.
","https://www.keysight.com/us/en/product/33510B/waveform-generator-20-mhz-2-channel.html#:~:text=The%2033510B%20waveform%20generator%20provides,for%20your%20most%20demanding%20measurements.",Keysight 33510 B,296.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33xxxOutputChannel,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782555/Instruments/RF%20Signal%20Generator/Keysight-33510B/Keysight-33510B.jpg,Keysight 33510B,Write a Python script that uses Qcodes to connect to a Keysight 33510B RF Signal Generator,4503.0,,,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
154,https://www.testequipmenthq.com/datasheets/Rohde-Schwarz-ZNB20-Datasheet.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attZlJBeZpD31RwIP'), ('width', 1500), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IN6RisEjPRSSwB9fTuid_g/dvuCWEBeTrzCvAv5QS2HALGJCWzKp8IQWBFhN0TKulgHZDruG1uGtG4Vrp64Yfd5oY1AgPo0-I2qGZf1w8P_2fzaUGAoiKKp0kPg__VpQkC1F1NZcJ0UvwJiFKnBFBPN/syQU1i5nyF3Y281aLpSmvI9bOZp9YBVquSYA4lUUtsI'), ('filename', 'Rohde-and-Schwarz-ZNB.webp'), ('size', 117048), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IlYA4ncW-vA1XSRDlStCgg/8VzN7Ytk07mIPwuwVtfDB5o-e_hlGsNLnrP50irKwqAgA3vyzOtxvpD30WWPyQtgeVKIQbbD0SzNaC-KMUrDYhprLvITI88stNwd-kdeMi0/EpkihQTpEiV-cy_H6vIlsJZ3V6MLVQ9VXeH2ZpOJ9eQ'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FnL7vvuwRYsrRQrW0ZJ6Ew/BR1sY2f-j0nBX-m1KCOEZ3c_MOL3mlhWFCyL_fVnQ4HS3uqOX7dtKSiq4OUK2imtKRCgMO2RmFhhk5x9f9OKGl6YjuR8rTxXkzesUvlAolE/3ZWK-Heouatq5zlllnTd44Bmak2_Iwg_2FmOANjhLZM'), ('width', 960), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/znJCBgu_V_r29zb5OluStA/MqCjy0qaDnYcgbbGYnqlt5RMXg0h9cgLm5XplaYadYMiW4FtWU0iV3yKbtS-Sytnbn6-XtqYb5dVJDOEP5qUv9lsFiolX2N6lCyTE53CXWs/S6awj3heKtDERKG2gLAiXnmptlY0wZiy2M5xKvTDkXg'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116717/Instruments/Vendor%20Logos/RohdeSchwarz.png,The R&S ZNB20 from R&S is a mid range vector network analyzer with two or four test ports for the frequency range from 100 kHz to 20 GHz. It has a dynamic range of 135 dB which makes it possible to perform precise measurements on wideband DUTs or components whose behavior at low frequencies is especially important. The analyzer has a large 12.1 inches touch screen interface which makes it easy to control and review test results. The ports on the R&S 20 have 2.92 mm Male connectors.,https://www.everythingrf.com/products/vector-network-analyzers/rohde-schwarz/565-92-r-s-znb20,Rohde Schwarz ZNB 20,463.0,['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/ZNB20.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNB20,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XHBiQ9oxXm-n-HvM6LnRsA/zCF7wkTRkwfOTCAuwmibY3O7w00r82Jr-e9BArEz2wuEOw-7rLpTsqnPaLuh9W23W58Qwn9JURC-40I0_-4JxPkfgmT1CSF7VPctZxztnV4/I5ofu9MkvIeeFWHtoXZm_t6fUCujFLfj-JFESMUqIgk'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rp7cS3TGPqAHuTUKlrNiDg/VQ8_PlSktrAEUSma3ec9casPyXqUCiOYTta1bFMCr-JbFojx11fj4PsFxxQcQkgk5T0s4eilsQBFkmKe1f5C4A/plUaF2hmxk-9dn7wzOx_UZSUTlLGORdKrjwdpcJGgiM'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ouYl2k3tZan1Mqr3gFZ4XQ/eznvJmkOWcALsfmYE2FWZIIuDkvhPsL5ha4wYwX2hkGiFmGNwyYpsS2lgvAprhPlVCGH-c59BKm4kM4jMvjwlA/h8aBHQcCEhxqGNo05zJPlPwJ7fdGYthLjdrl6yX_uaY'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6WMk-uFRvLMFJ3F3nCseOQ/Ssto5hgGHjq8Q9vjrgnj3D0-Fay9y9tubFUbdbvK9IeGUYn2K3euoW1jshe65viP4uybZmkDEuVY84MH5n021w/_2LXQNPKEtc9MtuRG0jFWn1Hay_SQ8m2sSYN4caNxpw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782557/Instruments/Network%20Analyzer/RS-ZNB20/RS-ZNB20.webp,R&S ZNB20,Write a Python script that uses Qcodes to connect to a R&S ZNB20 Network Analyzer,,,,,"# Ensuring backwards compatibility

from .ZNB import ZNB

ZNB20 = ZNB
"
158,https://www.keysight.com/us/en/assets/7018-06693/data-sheets/5968-8807.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attLbrKQfZkBoUpSk'), ('width', 750), ('height', 407), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bi-4G9bNAx9ksY6t932AKA/rO1wVvoIobR9izXA0IUhQfdxcfTQEgxXn4QMcypKlMdOe7Ob2PW2FfoDrC3RqG0ewlYJdgS-MZ_gKs__qRP4eGPRZdXkoxRUC9XH0h40VqTeHwL5WDzz61ivlpeBqsYw/d8WeDgH2UomyNpk0E3dAG4je7fPAzgboc98VsJYZ0hI'), ('filename', 'Keysight_Agilent_33250A.jpg'), ('size', 85765), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EF_WDhIfE8ehXYLWWT9hZA/twJWJx71TCVe034eBp4eBFKqTHMqqiXIWkmvPp3rKPY6fzNsN9FbPviKkX7Ypqh6qNQ0VLupR4_rBQwZPNGyKw/m5S9Xo6sMV-MENKkw78G76AH2eZschzkBBeNa2iQDlI'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2wWiIC5sewG13OZAZq4jBg/hzrmb5RzWlAIPr7GaM9ac_Za7mqqmv3yXR0U0JTEFw8QvnfycM4gIVnrR3YkaFH5fujESBJCqiEn_NVns5TbWQ/VgPkvoWqGKpzVcMChaUHZl5HDCcSIvwHtLnXi9Qg24s'), ('width', 750), ('height', 407)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rsYiy_UkZQH1zZjzh6ZTyQ/IXnun2i0iiOAfMP2cgcmvA0T6VWyjujFJ5gIlqAYlTbwVSBtbPj6o8lbu5HTN9RQtkh4eEbelkgtURU3K5v0Eg/NB2AYClnvVIWixq9JTRvFki2z-ml0u6Ciyx59MvPz-M'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 33250A 80 MHz Function/Arbitrary Waveform Generator uses direct digital-synthesis techniques to create a stable, accurate output on all waveforms, down to 1 µHz frequency resolution. The benefits are apparent in every signal you produce, from the sine wave frequency accuracy to the fast rise/fall times of square waves, to the ramp linearity.

",https://www.bellnw.com/products/keysight-33250a,Keysight 33250 A,295.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33250A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782561/Instruments/RF%20Signal%20Generator/Keysight-33250A/Keysight-33250A.jpg,Keysight 33250A,Write a Python script that uses Qcodes to connect to a Keysight 33250A RF Signal Generator,,,True,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
162,https://download.tek.com/manual/SPEC-2612B_B_Feb_2014.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attcOxZWqsZHSMQ24'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HWLopUoILwepaeaQ2EaDuw/EismRBm5ORDNfTrWDSPNAGWNQk9g2kvuCKw__icHhjn9JfIWa7oFe_IU8xLBxfh-nn0SCFIlB8YI6DHgSmWBMHpvTa0K4ASUyQXVYh_Qugo/3FRB9GaKfLD5mT27NErIYUn7MALBY2ZauUjmPVgJWL0'), ('filename', '2611b.webp'), ('size', 5900), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Auu5lMz83r9noKbdGJhcBQ/locFewNWr3G93rVpVsTj4kjIws9aSjZIXED8svKl8ja4R0UMcWRS9D67-8amlIadbgxgiy9urFIu_b-1IRklDiwXKNxdsQDYKtNhO2DwI5Q/M6UHfI5BE95X9FGTfbS4SWaaK0GECv3G31h2R12A4ow'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UVX2ii7slNSpAog21mjz8Q/YIPhKfaXQaevElyKn_lRfrc7_0o0qwxDsvv1sB_t9Z4xYgp-xpbzS7PBbMr8lMgYWP87R8Zu2yFCu0iwp_I3ozO9gJvUYQsjeztXdCveXeE/Mdvh9GZ-1vrwE7fM5MBrwrPdi4PwNh6UDZXsKPKIGA8'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/96AnDk6VALOk-CKOAc3mzw/CAcq8xQsBpcZiP5O0OsgnHLqWOmg90ykVLYroFDkyiuSUZ-U7KiUXTRbmknVP5gGSD3I6woac1TcWQDM5XgCoR5rGIt7BHdZ39IVlEuALRo/LgjthOS1qcRdZ4xx7AdXN3fuQjiB8INzNskFjo3hOgg'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2611B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",https://canada.newark.com/keithley/2611b/source-meter-voltage-current-30/dp/44W8036,Keithley 2611 B,248.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2611B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782565/Instruments/Power%20Supplies/Keithley-2611B/Keithley-2611B.webp,Keithley 2611B,Write a Python script that uses Qcodes to connect to a Keithley 2611B Power Supplies,13260.6,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
167,,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'att4yOUVGera7NKLs'), ('width', 650), ('height', 357), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8we8mUd1Gw-wBdRbh8Aefw/ggm-liC2ze9zjb7nPukAD8KQBRHX91UBWbRjAC1nps4KkPkgMcCyI_8QyZAzt-R2VqmEW_jOT1j0DyGfJCkfAKIrIcAqRnOXdUIjQv99uKzJUHRBTYnHjd7198PJt3vDGvNwjN3VsKUfcY4AkcYk8n8X9Xwh1EzEgHOsvsdMiHH4i3JmctripSPch-0hZFlf/qQwRDEdLgAsgAWlEjvPXF7iFchUBSXSb02cswuyozQc'), ('filename', 'Mercury-IPS.6a83180954b94b7abf6b9b512e354df6.8256e15f23084cff158fe69544501291.png'), ('size', 210309), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Jjptu4pjZshBHN8f_D9S4w/CHWPRxEFSTSnUjdcwQDQ1ZaQu_SS5gns28raYgQpTMBUATEU_NvRP8Atxnc5Vz3Mbs39ZLt6MephUCPtYoMLBQ/KTBSePDTeKpxEFlT_nagLyCOzBYx6T50y-YuHt8ffxs'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UfFugU2b5hZYwhYlI9D2vQ/SU_j4LhcI1dTsO-uWL8H31AgDJ8qezQZdFdyJ0DD4hX_57hXJ67hwoZ9UtV33nx9s5MPBF7C6HzbmGyQmdYKLg/jXgbZE1uvh94fLFVT_EUUaDH3O9x-41R4g-U2KzJ8yw'), ('width', 650), ('height', 357)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GBarBFF7VAB4kTJ31Dh6uQ/Zi5kR22pU8K90B2pKqf-iICY0bfIbRtvpohyzxpcbCo_WMAA6Lck1PBTpdv6ljVHGniADKwoEvb0m2THhhxU-g/91p4XOFz8HL2BGoMXMtZO9h8Ax3abXn4nmIjhmIRjOI'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116704/Instruments/Vendor%20Logos/Oxford_Instruments.png,"Based on ±60 A modules with ±10 V compliance.
Can be configured in parallel, series and matrix modes from the basic ±60 A with ±10 V output up to ±600 A with ±10 V or ±300 A with ±20 V output configurations.
Communications support a full range of interface options (Ethernet, USB, RS232, and optional GPIB) with downloadable Mercury function library for LabVIEW.
Quench protection and auto-rundown. The MercuryiPS can be programmed to run the magnet down safely in the event of magnet temperature rise, low cryogen levels or if triggered by an external TTL signal.
The MercuryiPS has an on-board temperature sensor for diagnostic monitoring of the magnet temperature.",https://nanoscience.oxinst.com/accessories/mercuryips,Mercuryips Visa,397.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://qcodes.github.io/Qcodes/_modules/qcodes/instrument_drivers/oxford/MercuryiPS_VISA.html,Qcodes,https://qcodes.github.io/Qcodes/examples/driver_examples/Qcodes%20example%20with%20Oxford%20Mercury%20iPS.html,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ge6UBa_PxVIRzTWaSDRhWw/z1nIIHpByPxcMFrxqz4wGua6L37TPuzjwuecyLHCFzr-uz84QG2przENPF1hXhY8XoqufraDY0oOQ6SMKew6m8dr0TjAnZhETraeiUtpcEI/9z2Sye-RWq0CT52RGvMeiR8CoeXPWB3yYto48j5ieq8'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/huAYtj4AqjzWQwtFbrocBw/ObKFsL5lrDEKZIzYosPMMAHykYqLRJhZzGmq81EktzRrWlN1S0qoVcGN10kXdT_Lcl-YwpqbQ2uXXTE58cUAzQ/sS56sfdd-S0WOj9HXdamH5KqMh4t3BlzRGkZDN_4h8I'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3otB5nYeU1qyF_laf_uciQ/En9x8ndMr6huc_UqR3iTmKE7EyJOmI-pqJKGxD_1iQvmC27k0lNw207b0eeZSFnZxVvJgXyx4wB4_l_J2ViTZw/kpdiY6dHLy4RY1bNMbPeMG-6iXXcT4BwYVW_BNY0ze0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bAQ9fOdp4fpHrIZL81i94w/dMc4vF9YSwqzuMc-sTB3iNls2t10Mo2tTfN1WMu9NQVaU_lvrq0ZLAhHh3WITeRd-flcjLvDijuR9i3SR8DqpA/GATYdc8TgmKLFz9DOI7DBZrtskXNPyb33IysjQXKBrg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782570/Instruments/Power%20Supplies/MercuryiPS/MercuryiPS.png,MercuryiPS,Write a Python script that uses Qcodes to connect to a MercuryiPS Power Supplies,,,,,
173,https://www.thinksrs.com/downloads/pdfs/catalog/SG380c.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attzGZUu5AMOTH1Yg'), ('width', 2916), ('height', 2136), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/j77Wkn4h0LI7ZW8anEiJKw/L3bAcC3ivntRLLa2gSiu61Vv0SjqG8kq0yTNf_M1U-qj3Rb-lcZEZBDrTRlOUAX7o0wBN5-Me4d8Od-94snx8K5xS35-zzs-JiL5y_brLUU/hw_gQkQnvUe-y9GuTW72FO4SaV-3C9h1AfjOnTlabfg'), ('filename', 'SG382 ReflectR (1).jpg'), ('size', 1271602), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IE2jNPF0SvVXBilUSpdixg/u1sqcVbd7MRSHA6Br4KeRJK3qlgQ84QSAarfpaZZN_dmeha2B1Yersj6V5b6Ufvt7DXQVD_faBs6yNH1yKBDTQ/F59QLJ4eJKll4fPgrJzqtj1jieKj_PfFe6w6jF6S7Lk'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-FpJzCyqhU1_1t6zobVbDQ/Hg8sOunqyh5NRJCx91f2aAXKrBAu9XHiMGRGG38GaTRQZHIIs1LpQ-X2_Ww6ySRO-zuh8BSDkFOP4Xdryet3AA/MhZMlZrNSy34kt2OhLA2HKlZrEzEf6dFtTXfUEyFFls'), ('width', 699), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5SaADMmUCj3msfpkUPjpOg/_shGg-bbmPth0_Y9gLx6jg_UpBOrW2CDlnNewXNsT6X34mtdt4yZyJkMgAOmg1N-Pmy-R0tcf6FvSClaXK3x3w/IIXGmwL5_tSby9ySJH7qu3E-xBTvmMlG6Tu-8etp6AY'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,"The SG380 Series RF Signal Generators use a unique, innovative architecture (Rational Approximation Frequency Synthesis) to deliver ultra-high frequency resolution (1 µHz), excellent phase noise, and versatile modulation capabilities (AM, FM, ØM, pulse modulation and sweeps) at a fraction of the cost of competing designs. The standard models produce sine waves from DC to 2.025 GHz (SG382), 4.05 GHz (SG384) and 6.075 GHz (SG386).",https://www.thinksrs.com/products/sg380.html,SG 384,535.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SG384.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SG384,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782577/Instruments/RF%20Signal%20Generator/SG-384/SG-384.jpg,SG 384,Write a Python script that uses Qcodes to connect to a {Device name} RF Signal Generator,3900.0,,,,"from typing import Any

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument


class SG384(VisaInstrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SG384 RF Signal Generator.

    Status: beta version
    Includes the essential commands from the manual
    """"""
    def __init__(self, name: str, address: str,
                 reset: bool = False, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)
    # signal synthesis commands
        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='FREQ?',
                           set_cmd='FREQ {:.3f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=9.5e5,
                                             max_value=4.05e9))
        self.add_parameter(name='phase',
                           label='Carrier phase',
                           unit='deg',
                           get_cmd='PHAS?',
                           set_cmd='PHAS {:.1f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-360, max_value=360))
        self.add_parameter(name='amplitude_LF',
                           label='Power of BNC output',
                           unit='dBm',
                           get_cmd='AMPL?',
                           set_cmd='AMPL {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-47, max_value=13))
        self.add_parameter(name='amplitude_RF',
                           label='Power of type-N RF output',
                           unit='dBm',
                           get_cmd='AMPR?',
                           set_cmd='AMPR {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-110, max_value=16.5))
        self.add_parameter(name='amplitude_HF',
                           label='Power of RF doubler output',
                           unit='dBm',
                           get_cmd='AMPH?',
                           set_cmd='AMPH {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-10, max_value=13))
        self.add_parameter(name='amplitude_clock',
                           label='Rear clock output',
                           unit='Vpp',
                           get_cmd='AMPC?',
                           set_cmd='AMPC {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=0.4, max_value=1.00))
        self.add_parameter(name='noise_mode',
                           label='RF PLL loop filter mode',
                           get_cmd='NOIS?',
                           set_cmd='NOIS {}',
                           val_mapping={'Mode 1': 0,
                                        'Mode 2': 1})
        self.add_parameter(name='enable_RF',
                           label='Type-N RF output',
                           get_cmd='ENBR?',
                           set_cmd='ENBR {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_LF',
                           label='BNC output',
                           get_cmd='ENBL?',
                           set_cmd='ENBL {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_HF',
                           label='RF doubler output',
                           get_cmd='ENBH?',
                           set_cmd='ENBH {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_clock',
                           label='Rear clock output',
                           get_cmd='ENBC?',
                           set_cmd='ENBC {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='offset_clock',
                           label='Rear clock offset voltage',
                           unit='V',
                           get_cmd='OFSC?',
                           set_cmd='OFSC {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-2, max_value=2))
        self.add_parameter(name='offset_rearDC',
                           label='Rear DC offset voltage',
                           unit='V',
                           get_cmd='OFSD?',
                           set_cmd='OFSD {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-10, max_value=10))
        self.add_parameter(name='offset_bnc',
                           label='Low frequency BNC output',
                           unit='V',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-1.5, max_value=1.5))
    # Modulation commands
        self.add_parameter(name='modulation_coupling',
                           label='External modulation input coupling',
                           get_cmd='COUP?',
                           set_cmd='COUP {}',
                           val_mapping={'AC': 0,
                                        'DC': 1})
        self.add_parameter(name='FM_deviation',
                           label='Frequency modulation deviation',
                           unit='Hz',
                           get_cmd='FDEV?',
                           set_cmd='FDEV {:.1f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=0.1, max_value=32e6))
        self.add_parameter(name='modulation_function',
                           label='Modulation function for AM/FM/PhiM',
                           get_cmd='MFNC?',
                           set_cmd='MFNC {}',
                           val_mapping={'Sine': 0,
                                        'Ramp': 1,
                                        'Triangle': 2,
                                        'Square': 3,
                                        'Noise': 4,
                                        'External': 5})
        self.add_parameter(name='enable_modulation',
                           get_cmd='MODL?',
                           set_cmd='MODL {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='modulation_rate',
                           get_cmd='RATE?',
                           set_cmd='RATE {:.6f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=1e-6, max_value=50e3))
        self.add_parameter(name='modulation_type',
                           label='Current modulation type',
                           get_cmd='TYPE?',
                           set_cmd='TYPE {}',
                           val_mapping={'AM': 0,
                                        'FM': 1,
                                        'Phi': 2,
                                        'Sweep': 3,
                                        'Pulse': 4,
                                        'Blank': 5,
                                        'IQ': 6})
        self.connect_message()


class SRS_SG384(SG384):
    """"""
    Deprecated alternative name for backwards compatibility
    """"""

    pass
"
174,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attmm8viACrl42SmY'), ('width', 1200), ('height', 1024), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N2b4DSjQYLI4egGrRAzmRw/M8_wm-EVK-A153hNIDDmcXYuEbX3h8-CDqrhih2QoYJQuR4sNNyiYQd1dgSacumjHN8TAMG_4Ckd60KYuWHtmadVUGgHQ8Uuwcp4PnPTTmI/qfB0ziayw30ZBVQmX_Sqq3F_wjwDTf5EuBCyfrMRcqk'), ('filename', '0001724_AT_33522B.jpg'), ('size', 200919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9csgsEz2nLJlq_GijljxMw/ywIPfCaXaQw0ZgkdhupyaxZCb31xCi1Q0c0uBGSNahqP_U01LeRiYUYRf55tMKgZUBXvvXU7s6SEC2p3fnaUGw/TiXMBgCV3lMba4MCDz-oE7PxRCigkpGXIHyeD7_o1EM'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MHeC_VqQ1YPiGI7p9FGlEg/Efe5Xezx5NIPTF2r01Jy2tC7zbLr-hNFp7PdkSmoVSOftIdIHR01Ci-yH-7gtQbeL6ty7_-KW3ddi4MrgvILqw/vJVZdMZcL_3xN_pxUtjqVry0-f3ROhpFJrgU-jHJrZw'), ('width', 600), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yy3UGjk53LrUMdEqutqCJQ/fu2u6psTQrxfk0Ake0TzsTBe20LGmlNP264YRceqVm99e0f_BJJi-uDbTxLIZAuCTwgn2NmHebbTL3Qtpr8Rvg/SHrliupy-8Mj8nOOtmeZXGKkKPJj_ViGOldSJ4WjUKk'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"Keysight 33500B Series waveform generators with exclusive Trueform signal generation technology offer more capability, fidelity, and flexibility than previous generation DDS generators. Easily generate the full range of signals you need to your devices with confidence the signal generator is outputting the signals you expect.


",https://www.keysight.com/us/en/product/33522B/waveform-generator-30-mhz-2-channel-arb.html,Keysight 33522 B,300.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33522B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782578/Instruments/RF%20Signal%20Generator/Keysight-33522B/Keysight-33522B.jpg,Keysight 33522B,Write a Python script that uses Qcodes to connect to a Keysight 33522B RF Signal Generator,4607.0,,,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
175,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attpy8Ojl7AnwMBqV'), ('width', 750), ('height', 277), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Mng-yrR0AEtR423OK_0yXg/YFVTjLh-jdrKPjzRFLT4MIuGKyKVyfGM_Y1mtgRugo5qx9RTFrXx0Gleop4iYZ6-U9eEuIGuDJRjEKQ-Uqj5HpNrDKkHfCVgauUJfZnbrsU/Bg5ZKZspQaqYBPK7Mh5rrPqYeStQTznCUnUYHwx8FOI'), ('filename', 'Keysight-AWG70001B.jpg'), ('size', 166740), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/C-pIVemc0Sm2Qke4jPmj_g/9uN0Q5wfPQZtovaPhsX1Fd1Bh70BuiW8wpwQH5DYONUQx3hi5n8ZoKfzePHUUTkatB0m5JMLg12RREc0OXbOBQ/qijz8H392llPDPtOlRkm31YpDexBVWdnmo72wmKfbGI'), ('width', 97), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-pd5jfLLRoRfySkHkSv5rg/z2RA5WNgA1bbIva_cm3q64vOM8mwEVVuxB0PNJm-Ytj64UIMJbyUcSWZekfNJYk_o5JQhV4OaQxG8jE60BiWWQ/iYvG_UDsTRJX2ZSC6f5UCtQODXh3QCHeX9L4FO961zs'), ('width', 750), ('height', 277)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MRR53MtvF8Wv6WN50H9jgQ/FClU0YSiO92HozwbsNO-GP45my_Q__IfIg2_ASI8nYMsda9zdBSkMrKwSwwlYFoPfKGeD-jZAHq0EERKJJeDnA/HjKJ8_EAcxXWBii61CsL5vW_bFi-fdgEanAZK2px6cA'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The AWG70000B Series Arbitrary Waveform Generator represents the cutting edge in sample rate, signal fidelity and waveform memory, making it ideal for design, testing and operations of complex components, systems and experiments. With up to sample rate of 50 GS/s and 10-bit vertical resolution, it delivers the industry's best signal stimulus solution for easy generation of ideal, distorted and “real-life” signals.",https://www.tek.com/en/products/arbitrary-waveform-generators/awg70000,Tektronix 70001 B,558.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001B,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782579/Instruments/RF%20Signal%20Generator/AWG70001B/AWG70001B.png,AWG70001B,Write a Python script that uses Qcodes to connect to a AWG70001B RF Signal Generator,122000.0,,,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
179,,,"[OrderedDict([('id', 'attiS5lMuodASUMTJ'), ('width', 578), ('height', 324), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Y85RqO6lD2ghHiL7TGaNLg/Pcop_M04vbTsmi_pXiYV-lYxiDkMRykBBuc0XfKA8gxI4myylCluixYfVTwNXSiju_o-EO6unqrln0OrIjIdQdEW5A9AOTXDtxvfcR-ItpQ/Je6obCrD6tERF9rlcAePmZLIv_awCn7-NmDO9J2_QpY'), ('filename', 'B2200A.png'), ('size', 150584), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/p5uAVuqKze5MGUcIu1Hs-g/kvtdQZQYWKZ8AmvWwJHuEuVsmW_TWFvDITRzodYvDBEJlLC6N-b9bfDc5zwyefWMVSiCZJ6ng_131pHbrt4ruQ/MFfj3PmRGx4fK6_Zi6sjE8iqaF60ZO8GR5-lqGj_l20'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_4KPeq7aOS5h6Dl2LoL8GQ/BDUuDq16-LJTFgjPxZuXaZW7gW1wuO06hwIVbtH0cyAkTuHhzrAPc2VqXLjFpG1V3iEA7z7WjuTTZbhhuV9Qog/3sJVaYaPv8bFtbhqHx68vVh--Sf0wM9nlJqNlgc88Ds'), ('width', 578), ('height', 324)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BUI41ahgWxK70K45UB8tDQ/lsPm2Bu_BLqjkbUnBjAou6Zn7K-nzRZI8BXtxsOmXowhEbqmqDXNZaVQneWF-XwSKe4bZO6XW6Nwe18dNF7g2Q/xA99TR_acI5-W6n3seQul84z4Sg8p_sYsgvqOpg9roQ'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight B2200A fA leakage switch mainframe reduces the cost of test by enabling automatic characterization tests without compromising the measurement performance of the semiconductor parameter analyzer.
",https://www.keysight.com/ca/en/product/B2200A/fa-leakage-switch-mainframe.html,Keysight B 220 X,337.0,['Switch'],,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/keysight_b220x.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33250A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782582/Instruments/Switch/Keysight-B2200A/Keysight-B2200A.png,Keysight B2200A,Write a Python script that uses Qcodes to connect to a Keysight B2200A Switch,,,,,"import re
import warnings
from collections.abc import Sequence
from functools import wraps
from typing import Any, Callable, TypeVar

from qcodes.instrument import VisaInstrument
from qcodes.validators import Enum, Ints, Lists, MultiType

T = TypeVar('T')


def post_execution_status_poll(func: Callable[..., T]) -> Callable[..., T]:
    """"""
    Generates a decorator that clears the instrument's status registers
    before executing the actual call and reads the status register after the
    function call to determine whether an error occured.

    :param func: function to wrap
    """"""

    @wraps(func)
    def wrapper(self: ""KeysightB220X"", *args: Any, **kwargs: Any) -> T:
        self.clear_status()
        retval = func(self, *args, **kwargs)

        stb = self.get_status()
        if stb:
            warnings.warn(
                f""Instrument status byte indicates an error occurred ""
                f""(value of STB was: {stb})! Use `get_error` method ""
                f""to poll error message."",
                stacklevel=2,
            )
        return retval

    return wrapper


class KeysightB220X(VisaInstrument):
    """"""
    QCodes driver for B2200 / B2201 switch matrix

    Note: The B2200 consists of up to 4 modules and provides two channel
    configuration modes, *Normal* and
    *Auto*. The configuration mode defines whether multiple switch modules
    are treated as one (*Auto* mode), or separately (*Normal* mode). This
    driver only implements the *Auto* mode. Please read the manual section on
    *Channel Configuration Mode* for more info.
    """"""

    _available_input_ports = Ints(1, 14)
    _available_output_ports = Ints(1, 48)

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        self._card = 0

        self.add_parameter(name='get_status',
                           get_cmd='*ESR?',
                           get_parser=int,
                           docstring='Queries status register.')

        self.add_parameter(name='get_error',
                           get_cmd=':SYST:ERR?',
                           docstring='Queries error queue')

        self.add_parameter(name='connections',
                           get_cmd=f':CLOS:CARD? {self._card}',
                           get_parser=KeysightB220X.parse_channel_list,
                           docstring='queries currently active connections '
                                     'and returns a set of tuples {(input, '
                                     'output), ...}'
                           )

        self.add_parameter(name='connection_rule',
                           get_cmd=self._get_connection_rule,
                           set_cmd=self._set_connection_rule,
                           val_mapping={'free': 'FREE',
                                        'single': 'SROU'},
                           docstring=(""specifies connection rule. Parameter ""
                                      ""one of 'free' (default) or 'single'.\n\n""
                                      ""In 'free' mode\n""
                                      "" - each input port can be connected to ""
                                      ""multiple output ports\n""
                                      "" - and each output port can be ""
                                      ""connected to multiple input ports.\n""
                                      "" - Caution: If the Free connection rule ""
                                      ""has been specified, ensure multiple ""
                                      ""input ports are not connected to the ""
                                      ""same output port. Such configurations ""
                                      ""can cause damage\n\n""
                                      ""In single route mode:\n""
                                      "" - each input port can be connected to ""
                                      ""only one output port\n""
                                      "" - and each output port can be ""
                                      ""connected to only one input port.\n""
                                      "" - existing connection to a port will ""
                                      ""be disconnected when a new connection ""
                                      ""is made.\n""
                                      )
                           )

        self.add_parameter(name='connection_sequence',
                           get_cmd=f':CONN:SEQ? {self._card}',
                           set_cmd=f':CONN:SEQ {self._card},{{}}',
                           val_mapping={'none': 'NSEQ',
                                        'bbm': 'BBM',
                                        'mbb': 'MBBR'},
                           docstring=""One of 'none', 'bbm' (Break before ""
                                     ""make) or 'mbb' (make before break)""
                           )

        self.add_parameter(name='bias_input_port',
                           get_cmd=f':BIAS:PORT? {self._card}',
                           set_cmd=f':BIAS:PORT {self._card},{{}}',
                           vals=MultiType(KeysightB220X._available_input_ports,
                                          Enum(-1)),
                           get_parser=int,
                           docstring=""Selects the input that will be used as ""
                                     ""bias input port (default 10). The Bias ""
                                     ""input port cannot be used on subsequent ""
                                     ""`connect` or `disconnect` commands if ""
                                     ""Bias mode is ON""
                           )

        self.add_parameter(name='bias_mode',
                           get_cmd=f':BIAS? {self._card}',
                           set_cmd=f':BIAS {self._card},{{}}',
                           val_mapping={True: 1,
                                        False: 0},
                           docstring=""Param: True for ON, False for OFF""
                           )

        self.add_parameter(name='gnd_input_port',
                           get_cmd=f':AGND:PORT? {self._card}',
                           set_cmd=f':AGND:PORT {self._card},{{}}',
                           vals=MultiType(KeysightB220X._available_input_ports,
                                          Enum(-1)),
                           get_parser=int,
                           docstring=""Selects the input that will be used as ""
                                     ""GND input port (default 12). The GND ""
                                     ""input port cannot be used on subsequent ""
                                     ""`connect` or `disconnect` commands if ""
                                     ""GND mode is ON""
                           )

        self.add_parameter(name='gnd_mode',
                           get_cmd=f':AGND? {self._card}',
                           set_cmd=f':AGND {self._card},{{}}',
                           val_mapping={True: 1,
                                        False: 0}
                           )

        self.add_parameter(name='unused_inputs',
                           get_cmd=f':AGND:UNUSED? {self._card}',
                           set_cmd=f"":AGND:UNUSED {self._card},'{{}}'"",
                           get_parser=lambda response: [int(x) for x in
                                                        response.strip(
                                                            ""'"").split(',') if
                                                        x.strip().isdigit()],
                           set_parser=lambda value: str(value).strip('[]'),
                           vals=Lists(KeysightB220X._available_input_ports)
                           )

        self.add_parameter(name='couple_ports',
                           get_cmd=f':COUP:PORT? {self._card}',
                           set_cmd=f"":COUP:PORT {self._card},'{{}}'"",
                           set_parser=lambda value: str(value).strip('[]()'),
                           get_parser=lambda response: [int(x) for x in
                                                        response.strip(
                                                            ""'"").split(',') if
                                                        x.strip().isdigit()],
                           vals=Lists(Enum(1, 3, 5, 7, 9, 11, 13))
                           )

        self.add_parameter(name='couple_mode',
                           get_cmd=f':COUP? {self._card}',
                           set_cmd=f':COUP {self._card},{{}}',
                           val_mapping={True: 1,
                                        False: 0},
                           docstring=""Param: True for ON, False for OFF""
                           )

        self.connect_message()

    @post_execution_status_poll
    def connect(self, input_ch: int, output_ch: int) -> None:
        """"""Connect given input/output pair.

        :param input_ch: Input channel number 1-14
        :param output_ch: Output channel number 1-48
        """"""
        KeysightB220X._available_input_ports.validate(input_ch)
        KeysightB220X._available_output_ports.validate(output_ch)

        self.write(f"":CLOS (@{self._card:01d}{input_ch:02d}{output_ch:02d})"")

    @post_execution_status_poll
    def connect_paths(self, paths: Sequence[tuple[int, int]]) -> None:
        channel_list_str = self.to_channel_list(paths)
        self.write(f"":CLOS {channel_list_str}"")

    @post_execution_status_poll
    def disconnect_paths(self, paths: Sequence[tuple[int, int]]) -> None:
        channel_list_str = self.to_channel_list(paths)
        self.write(f"":OPEN {channel_list_str}"")

    @post_execution_status_poll
    def disconnect(self, input_ch: int, output_ch: int) -> None:
        """"""Disconnect given Input/Output pair.

        :param input_ch: Input channel number 1-14
        :param output_ch: Output channel number 1-48
        """"""
        KeysightB220X._available_input_ports.validate(input_ch)
        KeysightB220X._available_output_ports.validate(output_ch)

        self.write(f"":OPEN (@{self._card:01d}{input_ch:02d}{output_ch:02d})"")

    @post_execution_status_poll
    def disconnect_all(self) -> None:
        """"""
        opens all connections.

        If ground or bias mode is enabled it will connect all outputs to the
        GND or Bias Port
        """"""
        self.write(f':OPEN:CARD {self._card}')

    @post_execution_status_poll
    def bias_disable_all_outputs(self) -> None:
        """"""
        Removes all outputs from list of ports that will be connected to GND
        input if port is unused and bias mode is enabled.
        """"""
        self.write(f':BIAS:CHAN:DIS:CARD {self._card}')

    @post_execution_status_poll
    def bias_enable_all_outputs(self) -> None:
        """"""
        Adds all outputs to list of ports that will be connected to bias input
        if port is unused and bias mode is enabled.
        """"""
        self.write(f':BIAS:CHAN:ENAB:CARD {self._card}')

    @post_execution_status_poll
    def bias_enable_output(self, output: int) -> None:
        """"""
        Adds `output` to list of ports that will be connected to bias input
        if port is unused and bias mode is enabled.

        :param output: int 1-48
        """"""
        KeysightB220X._available_output_ports.validate(output)

        self.write(f':BIAS:CHAN:ENAB (@{self._card}01{output:02d})'
                   )

    @post_execution_status_poll
    def bias_disable_output(self, output: int) -> None:
        """"""
        Removes `output` from list of ports that will be connected to bias
        input if port is unused and bias mode is enabled.

        :param output: int 1-48
        """"""
        KeysightB220X._available_output_ports.validate(output)

        self.write(f':BIAS:CHAN:DIS (@{self._card}01{output:02d})')

    @post_execution_status_poll
    def gnd_enable_output(self, output: int) -> None:
        """"""
        Adds `output` to list of ports that will be connected to GND input
        if port is unused and bias mode is enabled.

        :param output: int 1-48
        """"""
        KeysightB220X._available_output_ports.validate(output)

        self.write(f':AGND:CHAN:ENAB (@{self._card}01{output:02d})')

    @post_execution_status_poll
    def gnd_disable_output(self, output: int) -> None:
        """"""
        Removes `output` from list of ports that will be connected to GND
        input if port is unused and bias mode is enabled.

        :param output: int 1-48
        """"""
        KeysightB220X._available_output_ports.validate(output)

        self.write(f':AGND:CHAN:DIS (@{self._card}01{output:02d})')

    @post_execution_status_poll
    def gnd_enable_all_outputs(self) -> None:
        """"""
        Adds all outputs to list of ports that will be connected to GND input
        if port is unused and bias mode is enabled.
        """"""
        self.write(f':AGND:CHAN:ENAB:CARD {self._card}')

    @post_execution_status_poll
    def gnd_disable_all_outputs(self) -> None:
        """"""
        Removes all outputs from list of ports that will be connected to GND
        input if port is unused and bias mode is enabled.
        """"""
        self.write(f':AGND:CHAN:DIS:CARD {self._card}')

    @post_execution_status_poll
    def couple_port_autodetect(self) -> None:
        """"""Autodetect Kelvin connections on Input ports

        This will detect Kelvin connections on the input ports and enable
        couple mode for found kelvin connections. Kelvin connections must use
        input pairs that can be couple-enabled in order to be autodetected.

        `{(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14)}`

        Also refer to the manual for more information.
        """"""
        self.write(':COUP:PORT:DET')

    def clear_status(self) -> None:
        """"""Clears status register and error queue of the instrument.""""""
        self.write('*CLS')

    def reset(self) -> None:
        """"""Performs an instrument reset.

        Does not reset error queue!
        """"""
        self.write('*RST')

    @post_execution_status_poll
    def _set_connection_rule(self, mode: str) -> None:
        if 'free' == self.connection_rule() and 'SROU' == mode:
            warnings.warn('When going from *free* to *single* mode existing '
                          'connections are not released.')

        self.write(f':CONN:RULE {self._card},{mode}')

    @post_execution_status_poll
    def _get_connection_rule(self) -> str:
        return self.ask(f':CONN:RULE? {self._card}')

    @staticmethod
    def parse_channel_list(channel_list: str) -> set[tuple[int, int]]:
        """"""Generate a set of (input, output) tuples from a SCPI channel
        list string.
        """"""
        pattern = (
            r""(?P<card>\d{0,1}?)(?P<input>\d{1,2})(?P<output>\d{2})(?=(?:[,\)\r\n]|$))""
        )
        return {
            (int(match[""input""]), int(match[""output""]))
            for match in re.finditer(pattern, channel_list)
        }

    def to_channel_list(self, paths: Sequence[tuple[int, int]]) -> str:
        chan = [f""{self._card:01d}{i:02d}{o:02d}"" for i, o in paths]
        channel_list = f""(@{','.join(chan)})""
        return channel_list


class KeysightB2200(KeysightB220X):
    """"""
    QCodes driver for B2200
    """"""


class KeysightB2201(KeysightB220X):
    """"""
    QCodes driver for B2201
    """"""
"
180,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Udku3Y9JFBObYmi4n3W7JQ/QJAqHSwjjjFvLUXfzABpHzi_6V3YDr86fntiF2OgnhWI6ORXYfczw2yNQtnydsg7mVF4uh9By5Y-zdNTUz3cfQ/bVtQTx9snzuNmwXb09fnel4fdeV-IlbHCATEk-ryJcc'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ubmQH0KIOaeUHS6kPuh1dg/0UoJ_44BTRenCAMLOrDywe6RDSFkrK3vHgdnBV7-E2rh_nlE5eBmQpwE4PoqDbF3waLqF6VxH0LG1Tsnwn95ug/UIb9_x8j7cD3MmPuXkY96U8P7P6IcbaZZNkMYAIEo3Q'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/l8jzW8o_r51j8yCYLIfPAg/e6OOR9gLNRm32el9BXdyE-ogifhOp60NkkEyOmdVg5JBA0QYJrPX64HdCvUrGUvn8E-a9WpiDYR7kxSev2g8tg/olJd2jC7XoFBgxIYqYPxLIXDvqMpLmiuaB_e_ttq_vE'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Uv7HiYdnep_wiKa1Pk1skQ/gQfT-bz8T-nv0MTn0_PvOQQLr9JRke_lKtFaRZuwpUnV-Pefsv_pGhHPXs4jdJ-lvEGcNldWVHRt-kvErWBVpw/vTfHPpp0-y_DmDuIGXXhFTAkAumU7LebX1CaanuRNFY'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,Keithley 2450,243.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2450.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2450,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782527/Instruments/Power%20Supplies/Keithley-2450/Keithley-2450.png,Keithley 2450,Write a Python script that uses Qcodes to connect to a Keithley 2450 Power Supplies,9549.3,,,,"from types import TracebackType
from typing import Any, Optional, Union, cast

import numpy as np
from typing_extensions import TypedDict

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ParameterWithSetpoints,
    create_on_off_val_mapping,
    invert_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Lists, Numbers


class _SweepDict(TypedDict):
    start: float
    stop: float
    step_count: int
    delay: float
    sweep_count: int
    range_mode: str
    fail_abort: str
    dual: str
    buffer_name: str


class ParameterWithSetpointsCustomized(ParameterWithSetpoints):
    """"""
    While the parent class ParameterWithSetpoints only support numerical data
    (in the format of ""Arrays""), the newly added ""_user_selected_data"" will
    include extra fields which may contain string type, in addition to the
    numerical values, which can be obtained by the get_cmd of the parent class.

    This customized class is used for the ""sweep"" parameter.
    """"""

    _user_selected_data: Optional[list[Any]] = None

    def get_selected(self) -> Optional[list[Any]]:
        return self._user_selected_data


class Keithley2450Buffer(InstrumentChannel):
    """"""
    Treat the reading buffer as a submodule, similar to Sense and Source
    """"""

    default_buffer = {""defbuffer1"", ""defbuffer2""}

    buffer_elements = {
        ""date"": ""DATE"",
        ""measurement_formatted"": ""FORMatted"",
        ""fractional_seconds"": ""FRACtional"",
        ""measurement"": ""READing"",
        ""relative_time"": ""RELative"",
        ""seconds"": ""SEConds"",
        ""source_value"": ""SOURce"",
        ""source_value_formatted"": ""SOURFORMatted"",
        ""source_value_status"": ""SOURSTATus"",
        ""source_value_unit"": ""SOURUNIT"",
        ""measurement_status"": ""STATus"",
        ""time"": ""TIME"",
        ""timestamp"": ""TSTamp"",
        ""measurement_unit"": ""UNIT"",
    }

    inverted_buffer_elements = invert_val_mapping(buffer_elements)

    def __init__(
        self,
        parent: ""Keithley2450"",
        name: str,
        size: Optional[int] = None,
        style: str = """",
    ) -> None:
        super().__init__(parent, name)
        self.buffer_name = name
        self._size = size
        self.style = style

        if self.buffer_name not in self.default_buffer:
            # when making a new buffer, the ""size"" parameter is required.
            if size is None:
                raise TypeError(
                    ""buffer() missing 1 required positional argument: 'size'""
                )
            self.write(f"":TRACe:MAKE '{self.buffer_name}', {self._size}, {self.style}"")
        else:
            # when referring to default buffer, ""size"" parameter is not needed.
            if size is not None:
                self.log.warning(
                    f""Please use method 'size()' to resize default buffer ""
                    f""{self.buffer_name} size to {self._size}.""
                )

        self.add_parameter(
            ""size"",
            get_cmd=f"":TRACe:POINts? '{self.buffer_name}'"",
            set_cmd=f"":TRACe:POINts {{}}, '{self.buffer_name}'"",
            get_parser=int,
            docstring=""The number of readings a buffer can store."",
        )

        self.add_parameter(
            ""number_of_readings"",
            get_cmd=f"":TRACe:ACTual? '{self.buffer_name}'"",
            get_parser=int,
            docstring=""To get the number of readings in the reading buffer."",
        )

        self.add_parameter(
            ""elements"",
            get_cmd=None,
            get_parser=self.from_scpi_to_name,
            set_cmd=None,
            set_parser=self.from_name_to_scpi,
            vals=Lists(Enum(*list(self.buffer_elements.keys()))),
            docstring=""List of buffer elements to read."",
        )

    def from_name_to_scpi(self, element_names: list[str]) -> list[str]:
        return [self.buffer_elements[element] for element in element_names]

    def from_scpi_to_name(self, element_scpis: list[str]) -> list[str]:
        if element_scpis is None:
            return []
        return [self.inverted_buffer_elements[element] for element in element_scpis]

    def __enter__(self) -> ""Keithley2450Buffer"":
        return self

    def __exit__(
        self,
        exception_type: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None:
        self.delete()

    @property
    def available_elements(self) -> set[str]:
        return set(self.buffer_elements.keys())

    def get_last_reading(self) -> str:
        """"""
        This method requests the latest reading from a reading buffer.

        """"""
        if not self.elements():
            return self.ask(f"":FETCh? '{self.buffer_name}'"")
        fetch_elements = [self.buffer_elements[element] for element in self.elements()]
        return self.ask(f"":FETCh? '{self.buffer_name}', {','.join(fetch_elements)}"")

    def get_data(
        self, start_idx: int, end_idx: int, readings_only: bool = False
    ) -> list[Any]:
        """"""
        This command returns specified data elements from reading buffer.

        Args:
            start_idx: beginning index of the buffer to return
            end_idx: ending index of the buffer to return
            readings_only: a flag to temporarily disable the elements and
                output only the numerical readings

        Returns:
            data elements from the reading buffer

        """"""
        if (not self.elements()) or readings_only:
            raw_data = self.ask(
                f"":TRACe:DATA? {start_idx}, {end_idx}, "" f""'{self.buffer_name}'""
            )
            return [float(i) for i in raw_data.split("","")]
        elements = [self.buffer_elements[element] for element in self.elements()]
        raw_data_with_extra = self.ask(
            f"":TRACe:DATA? {start_idx}, ""
            f""{end_idx}, ""
            f""'{self.buffer_name}', ""
            f""{','.join(elements)}""
        )
        return raw_data_with_extra.split("","")

    def clear_buffer(self) -> None:
        """"""
        Clear the data in the buffer
        """"""
        self.write(f"":TRACe:CLEar '{self.buffer_name}'"")

    def trigger_start(self) -> None:
        """"""
        This method makes readings using the active measure function and
        stores them in a reading buffer.
        """"""
        self.write(f"":TRACe:TRIGger '{self.buffer_name}'"")

    def delete(self) -> None:
        if self.buffer_name not in self.default_buffer:
            self.parent.submodules.pop(f""_buffer_{self.buffer_name}"")
            self.parent.buffer_name(""defbuffer1"")
            self.write(f"":TRACe:DELete '{self.buffer_name}'"")


class Keithley2450Sense(InstrumentChannel):
    """"""
    The sense module of the Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of either ""current"", ""voltage""
            or ""resistance"". All parameters and methods in this submodule
            should only be accessible to the user if
            self.parent.sense_function.get() == self._proper_function. We
            ensure this through the 'sense' property on the main driver class
            which returns the proper submodule for any given function mode
    """"""

    function_modes = {
        ""current"": {""name"": '""CURR:DC""', ""unit"": ""A"", ""range_vals"": Numbers(10e-9, 1)},
        ""resistance"": {
            ""name"": '""RES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(20, 200e6),
        },
        ""voltage"": {""name"": '""VOLT:DC""', ""unit"": ""V"", ""range_vals"": Numbers(0.02, 200)},
    }

    def __init__(self, parent: ""Keithley2450"", name: str, proper_function: str) -> None:
        super().__init__(parent, name)
        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.sense_function

        self.add_parameter(
            ""four_wire_measurement"",
            set_cmd=f"":SENSe:{self._proper_function}:RSENse {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RSENse?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""range"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe?"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""auto_range"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            get_parser=float,
            unit=unit,
            snapshot_value=False,
        )

        self.add_parameter(
            ""sweep"",
            label=self._proper_function,
            get_cmd=self._measure_sweep,
            unit=unit,
            vals=Arrays(shape=(self.parent.npts,)),
            parameter_class=ParameterWithSetpointsCustomized,
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=f"":SENSe:{self._proper_function}:NPLCycles?"",
            set_cmd=f"":SENSe:{self._proper_function}:NPLCycles {{}}"",
            vals=Numbers(0.001, 10),
        )

        self.add_parameter(""user_number"", get_cmd=None, set_cmd=None, vals=Ints(1, 5))

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            get_parser=float,
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(
            ""auto_zero_enabled"",
            get_cmd=f"":SENSe:{self._proper_function}:AZERo?"",
            set_cmd=f"":SENSe:{self._proper_function}:AZERo {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""This command enables or disables automatic updates to""
            ""the internal reference measurements (autozero) of the""
            ""instrument."",
        )

        self.add_parameter(
            ""count"",
            get_cmd="":SENSe:COUNt?"",
            set_cmd="":SENSe:COUNt {}"",
            docstring=""The number of measurements to make when a measurement ""
            ""is requested."",
        )

    def _measure(self) -> Union[float, str]:
        if not self.parent.output_enabled():
            raise RuntimeError(""Output needs to be on for a measurement"")
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure? '{buffer_name}'""))

    def _measure_sweep(self) -> np.ndarray:

        source = cast(Keithley2450Source, self.parent.source)
        source.sweep_start()
        buffer_name = self.parent.buffer_name()
        buffer = cast(
            Keithley2450Buffer, self.parent.submodules[f""_buffer_{buffer_name}""]
        )
        end_idx = self.parent.npts()
        raw_data = buffer.get_data(1, end_idx, readings_only=True)
        raw_data_with_extra = buffer.get_data(1, end_idx)
        self.parent.sense.sweep._user_selected_data = raw_data_with_extra
        # Clear the trace so we can be assured that a subsequent measurement
        # will not be contaminated with data from this run.
        buffer.clear_buffer()
        return np.array([float(i) for i in raw_data])

    def auto_zero_once(self) -> None:
        """"""
        This command causes the instrument to refresh the reference and zero
        measurements once.
        """"""
        self.write("":SENSe:AZERo:ONCE"")

    def clear_trace(self, buffer_name: str = ""defbuffer1"") -> None:
        """"""
        Clear the data buffer
        """"""
        self.write(f"":TRACe:CLEar '{buffer_name}'"")

    def _get_user_delay(self) -> str:
        get_cmd = f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return self.ask(get_cmd)

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()} {value}""
        )
        self.write(set_cmd)


class Keithley2450Source(InstrumentChannel):
    """"""
    The source module of the Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of either ""current"" or ""voltage""
            All parameters and methods in this submodule should only be
            accessible to the user if
            self.parent.source_function.get() == self._proper_function. We
            ensure this through the 'source' property on the main driver class
            which returns the proper submodule for any given function mode
    """"""

    function_modes = {
        ""current"": {""name"": ""CURR"", ""unit"": ""A"", ""range_vals"": Numbers(-1, 1)},
        ""voltage"": {""name"": ""VOLT"", ""unit"": ""V"", ""range_vals"": Numbers(-200, 200)},
    }

    def __init__(self, parent: ""Keithley2450"", name: str, proper_function: str) -> None:
        super().__init__(parent, name)
        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.source_function
        self._sweep_arguments: Optional[_SweepDict] = None

        self.add_parameter(
            ""range"",
            set_cmd=f"":SOUR:{self._proper_function}:RANGe {{}}"",
            get_cmd=f"":SOUR:{self._proper_function}:RANGe?"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""auto_range"",
            set_cmd=f"":SOURce:{self._proper_function}:RANGe:AUTO {{}}"",
            get_cmd=f"":SOURce:{self._proper_function}:RANGe:AUTO?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        limit_cmd = {""current"": ""VLIM"", ""voltage"": ""ILIM""}[self._proper_function]
        self.add_parameter(
            ""limit"",
            set_cmd=f""SOUR:{self._proper_function}:{limit_cmd} {{}}"",
            get_cmd=f""SOUR:{self._proper_function}:{limit_cmd}?"",
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""limit_tripped"",
            get_cmd=f"":SOUR:{self._proper_function}:{limit_cmd}:TRIPped?"",
            val_mapping={True: 1, False: 0},
        )

        self.add_parameter(
            self._proper_function,
            set_cmd=f""SOUR:{self._proper_function} {{}}"",
            get_cmd=f""SOUR:{self._proper_function}?"",
            get_parser=float,
            unit=unit,
            snapshot_value=False,
        )

        self.add_parameter(
            ""sweep_axis"",
            label=self._proper_function,
            get_cmd=self.get_sweep_axis,
            vals=Arrays(shape=(self.parent.npts,)),
            unit=unit,
        )

        self.add_parameter(
            ""delay"",
            get_cmd=f"":SOURce:{self._proper_function}:DELay?"",
            set_cmd=f"":SOURce:{self._proper_function}:DELay {{}}"",
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(""user_number"", get_cmd=None, set_cmd=None, vals=Ints(1, 5))

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(
            ""auto_delay"",
            get_cmd=f"":SOURce:{self._proper_function}:DELay:AUTO?"",
            set_cmd=f"":SOURce:{self._proper_function}:DELay:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""read_back_enabled"",
            get_cmd=f"":SOURce:{self._proper_function}:READ:BACK?"",
            set_cmd=f"":SOURce:{self._proper_function}:READ:BACK {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""This command determines if the instrument records the ""
            ""measured source value or the configured source value ""
            ""when making a measurement."",
        )

    def get_sweep_axis(self) -> np.ndarray:
        if self._sweep_arguments is None:
            raise ValueError(
                ""Please setup the sweep before getting values of this parameter""
            )
        return np.linspace(
            start=self._sweep_arguments[""start""],
            stop=self._sweep_arguments[""stop""],
            num=int(self._sweep_arguments[""step_count""]),
        )

    def sweep_setup(
        self,
        start: float,
        stop: float,
        step_count: int,
        delay: float = 0,
        sweep_count: int = 1,
        range_mode: str = ""AUTO"",
        fail_abort: str = ""ON"",
        dual: str = ""OFF"",
        buffer_name: str = ""defbuffer1"",
    ) -> None:

        self._sweep_arguments = _SweepDict(
            start=start,
            stop=stop,
            step_count=step_count,
            delay=delay,
            sweep_count=sweep_count,
            range_mode=range_mode,
            fail_abort=fail_abort,
            dual=dual,
            buffer_name=buffer_name,
        )

    def sweep_start(self) -> None:
        """"""
        Start a sweep and return when the sweep has finished.
        Note: This call is blocking
        """"""
        if self._sweep_arguments is None:
            raise ValueError(""Please call `sweep_setup` before starting a sweep."")
        cmd_args = dict(self._sweep_arguments)
        cmd_args[""function""] = self._proper_function

        cmd = (
            "":SOURce:SWEep:{function}:LINear {start},{stop},""
            ""{step_count},{delay},{sweep_count},{range_mode},""
            ""{fail_abort},{dual},'{buffer_name}'"".format(**cmd_args)
        )

        self.write(cmd)
        self.write("":INITiate"")
        self.write(""*WAI"")

    def sweep_reset(self) -> None:
        self._sweep_arguments = None

    def _get_user_delay(self) -> float:
        get_cmd = f"":SOURce:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return float(self.ask(get_cmd))

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SOURce:{self._proper_function}:DELay:USER""
            f""{self.user_number()} {value}""
        )
        self.write(set_cmd)


class Keithley2450(VisaInstrument):
    """"""
    The QCoDeS driver for the Keithley 2450 SMU
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        if not self._has_correct_language_mode():
            self.log.warning(
                ""The instrument is in an unsupported language mode. ""
                ""Please run `instrument.set_correct_language()` and try to ""
                ""initialize the driver again after an instrument power cycle. ""
                ""No parameters/sub modules will be available on this driver ""
                ""instance""
            )
            return

        self.add_parameter(
            ""source_function"",
            set_cmd=self._set_source_function,
            get_cmd="":SOUR:FUNC?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley2450Source.function_modes.items()
            },
        )

        self.add_parameter(
            ""sense_function"",
            set_cmd=self._set_sense_function,
            get_cmd="":SENS:FUNC?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley2450Sense.function_modes.items()
            },
        )

        self.add_parameter(
            ""terminals"",
            set_cmd=""ROUTe:TERMinals {}"",
            get_cmd=""ROUTe:TERMinals?"",
            vals=Enum(""rear"", ""front""),
        )

        self.add_parameter(
            ""output_enabled"",
            initial_value=""0"",
            set_cmd="":OUTP {}"",
            get_cmd="":OUTP?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""line_frequency"",
            get_cmd="":SYSTem:LFRequency?"",
            unit=""Hz"",
            docstring=""returns the power line frequency setting that is used ""
            ""for NPLC calculations"",
        )

        self.add_parameter(
            ""buffer_name"",
            get_cmd=None,
            set_cmd=None,
            docstring=""name of the reading buffer in using"",
        )

        # Make a source module for every source function ('current' and 'voltage')
        for proper_source_function in Keithley2450Source.function_modes:
            self.add_submodule(
                f""_source_{proper_source_function}"",
                Keithley2450Source(self, ""source"", proper_source_function),
            )

        # Make a sense module for every sense function ('current', voltage' and 'resistance')
        for proper_sense_function in Keithley2450Sense.function_modes:
            self.add_submodule(
                f""_sense_{proper_sense_function}"",
                Keithley2450Sense(self, ""sense"", proper_sense_function),
            )

        self.buffer_name(""defbuffer1"")
        self.buffer(name=self.buffer_name())
        self.connect_message()

    def _set_sense_function(self, value: str) -> None:
        """"""
        Change the sense function. The property 'sense' will return the
        sense module appropriate for this function setting.

        We need to ensure that the setpoints of the sweep parameter in the
        active sense module is correctly set. Normally we would do that
        with 'self.sense.sweep.setpoints = (self.source.sweep_axis,)'

        However, we cannot call the property 'self.sense', because that property
        will call `get_latest` on the parameter for which this function
        (that is '_set_sense_function') is the setter
        """"""
        self.write(
            f"":SENS:FUNC {value}"",
        )
        sense_function = self.sense_function.inverse_val_mapping[value]
        sense = self.submodules[f""_sense_{sense_function}""]
        if not isinstance(sense, Keithley2450Sense):
            raise RuntimeError(
                f""Expect Sense Module to be of type ""
                f""Keithley2450Sense got {type(sense)}""
            )
        sense.sweep.setpoints = (self.source.sweep_axis,)

    def _set_source_function(self, value: str) -> None:
        """"""
        Change the source function. The property 'source' will return the
        source module appropriate for this function setting.

        We need to ensure that the setpoints of the sweep parameter in the
        active sense module reflects the change in the source module.
        Normally we would do that with
        'self.sense.sweep.setpoints = (self.source.sweep_axis,)'

        However, we cannot call the property 'self.source', because that property
        will call `get_latest` on the parameter for which this function
        (that is '_set_source_function') is the setter
        """"""

        if self.sense_function() == ""resistance"":
            raise RuntimeError(
                ""Cannot change the source function while sense function is in 'resistance' mode""
            )

        self.write(f"":SOUR:FUNC {value}"")
        source_function = self.source_function.inverse_val_mapping[value]
        source = self.submodules[f""_source_{source_function}""]
        self.sense.sweep.setpoints = (source.sweep_axis,)
        if not isinstance(source, Keithley2450Source):
            raise RuntimeError(
                f""Expect Source Module to be of type ""
                f""Keithley2450Source got {type(source)}""
            )
        # Once the source function has changed,
        # we cannot trust the sweep setup anymore
        source.sweep_reset()

    @property
    def source(self) -> Keithley2450Source:
        """"""
        We have different source modules depending on the source function, which can be
        'current' or 'voltage'

        Return the correct source module based on the source function
        """"""
        source_function = self.source_function.get_latest() or self.source_function()
        submodule = self.submodules[f""_source_{source_function}""]
        return cast(Keithley2450Source, submodule)

    @property
    def sense(self) -> Keithley2450Sense:
        """"""
        We have different sense modules depending on the sense function, which can be
        'current', 'voltage' or 'resistance'

        Return the correct source module based on the sense function
        """"""
        sense_function = self.sense_function.get_latest() or self.sense_function()
        submodule = self.submodules[f""_sense_{sense_function}""]
        return cast(Keithley2450Sense, submodule)

    def buffer(
        self, name: str, size: Optional[int] = None, style: str = """"
    ) -> Keithley2450Buffer:
        self.buffer_name(name)
        if f""_buffer_{name}"" in self.submodules:
            return cast(Keithley2450Buffer, self.submodules[f""_buffer_{name}""])
        new_buffer = Keithley2450Buffer(parent=self, name=name, size=size, style=style)
        self.add_submodule(f""_buffer_{name}"", new_buffer)
        return new_buffer

    def npts(self) -> int:
        """"""
        Get the number of points in the sweep axis
        """"""
        return len(self.source.get_sweep_axis())

    def set_correct_language(self) -> None:
        """"""
        The correct communication protocol is SCPI, make sure this is set
        """"""
        self.write(""*LANG SCPI"")
        self.log.warning(
            ""Please power cycle the instrument to make the change take effect""
        )
        # We want the user to be able to instantiate a driver with the same name
        self.close()

    def _has_correct_language_mode(self) -> bool:
        """"""
        Query if we have the correct language mode
        """"""
        return self.ask(""*LANG?"") == ""SCPI""

    def abort(self) -> None:
        """"""
        This command stops all trigger model commands on the instrument.
        """"""
        self.write("":ABORt"")

    def initiate(self) -> None:
        """"""
        This command starts the trigger model.
        """"""
        self.write("":INITiate"")

    def wait(self) -> None:
        """"""
        This command postpones the execution of subsequent commands until all
        previous overlapped commands are finished.
        """"""
        self.write(""*WAI"")

    def clear_event_register(self) -> None:
        """"""
        This function clears event registers.
        """"""
        self.write("":STATus:CLEar"")

    def clear_event_log(self) -> None:
        """"""
        This command clears the event log.
        """"""
        self.write("":SYSTem:CLEar"")

    def reset(self) -> None:
        """"""
        Returns instrument to default settings, cancels all pending commands.
        """"""
        self.write(""*RST"")
"
182,https://www.testequipmenthq.com/datasheets/KEITHLEY-2602-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attxb5H87MVStHqHs'), ('width', 275), ('height', 183), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Vn0Fu54xudXeBIKMKpfuhA/w62o1-uAqm0JXMdAIhzIYSqjxDg1th1PsvxpvWlWkMZLHvEc9WisMU74-DYS2Sd165l8W4J5RC-7-Hh8AEyIZ-1S5QTrPm50wNNNQMp3VfQ/Fy-R7r1aBkD206XZo2Thds38xzFLVCpCEkOQtE24N7k'), ('filename', 'thd_Keithley_2602A.jpg'), ('size', 36918), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EWg-OB6NNlCn0rxcbXoIMw/FqLid18zVOT_xjtjtz8GiBkK8HW6W_43cxOdBP04cozGw6mhZ0KqpmQj8RApz-mnBZxEVwlbkHfB85tRHDY93g/tVoUhdv9-UhQtj-j7Ol1mbaNzsgWFuu_mc-eDy9yt5A'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/o0PItuVJ9KixBMcY93LHkg/AQ8NTYFEeilKBZjvF3zQsEJupDhK0Qo-oXsLoN_x9bBwV75es5zVWMOK33s4tq55V-qEELQJW9x40PiC1kE_wQ/Q0rRm8ld3ORQMHYgXLvX2jWMsn-i6XYQ_u0u689en9Y'), ('width', 275), ('height', 183)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rEqJqBa5NaGqMtgfoJHMKQ/VKrwWC1ibwoxg4s3KpJUnfMGBH3UEMhozQSg90m6a_dHeyyx9aFKVT1rGOEqk0ndZkspTRCE24yQLNTahhbQsg/XVks-y2Ujpik_16_jyFQNMqj3G4CiUw2_8wCSLOC5ZY'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The Keithley 2602A SourceMeter is used as either a bench-top I-V characterization tool or as a building block component of multi-channel I-V test systems. For bench-top use, the Keithley 2602A SourceMeter features an embedded TSP® Express Software Tool that allows users to quickly and easily perform common I-V tests without programming or installing software. For system level applications, the Keithley 2602A SourceMeter's Test Script Processor (TSP®) architecture along with new capabilities such as parallel test execution and precision timing provide the highest throughput in the industry to lower the cost of test.",https://www.axiomtest.com/Meters/SourceMeters/Keithley/2602A/SourceMeter%2C-3A-DC%2C-10A-Pulse-40W%2C-2-Ch./,Keithley 2602 A,245.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2602A,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782585/Instruments/Power%20Supplies/Keithley-2602A/Keithley-2602A.jpg,Keithley 2602A,Write a Python script that uses Qcodes to connect to a Keithley 2602A Power Supplies,,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
183,https://download.tek.com/document/55W-22447-9.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WsOWv-JV7GKaFSUmikElnA/FcE2F5kwbC0dzqe-VO-xxGIQCJmlulIzNnfzZypOHdnVxEl66Z9Iweqjumb81naKEWasCEM4NGZwyj0JDXI0g0v-xXmYW68-kFebXGLsa63OCBrZHqjw4gf7HwcYfPwEpTaatH0fva7J3tNudx5fsg/hG87vOaqGIL9d6DRm9Uyv_9s4a6YxEGPzRL6eUPJcxc'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G3Xe1UXf174GIRLewzm6BQ/FuPBbb4fUhU1fLrJOR9j1Odv-iOmwveeAbhSfK9kdqjePdinC9gdOfOrwPk-4wTiLoxtvJMYk8CB5sgjkZJq6q9y95O9FOp4OZiO7GTf15o/L9COYzFW4Cq3OOmUhSdLg3Nt32vpNzAewgCllwRUv_k'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IDWJqZT2JqdkvKYnCqljLg/h3HDNdNTlG7iymZ0SwPVXgKO0dyu5UyfioiXD1cxdN-XVzBW-qo1pA5i09ljVODVZO0Ba6kOz8EPus_YBn0d1Mpp-lokwwUFKU0laO1ciHM/Ry0cQ8w_ZnwfuKzQuGu3rt_q1WoGDaYTg_H5Z8Ez5aE'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PxxO2zEVzSVGNSsb0WoVzg/os-KcM5U58Vxh5oHKo6M_LujGceSAVD4hLgINBBluDlRZ16Z54YK_pHadcTJTE8dh3msKZCO7866ZWm-TP4Dxan-YDm288-vvPFPCPZ-55I/vxCUn8Gvs_cR2czq6DM4VFZRUReLTiHb-l-QcV-haS8'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,Tektronix MSO 70000,577.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixMSO70000,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782586/Instruments/Oscilloscopes/MSO70000/MSO70000.webp,MSO70000,Write a Python script that uses Qcodes to connect to a MSO70000 Oscilloscopes,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
192,https://www.testequipmenthq.com/datasheets/KEITHLEY-2636B-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attNXpMbxk28rQ43W'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7tzMhiciHplGBQTYEyfc0w/B17_7PXL3ucihRhiQNS2NhSkgSNf1INSa6k0f-h69Vi_fFFPjLwX2cJqluqcZUv8yDLl5-EgmvpKYrOrwXZU-RCWrLY-LJ1wp0LhTr_Kzb4/weiY2lesv9sl4hxvLiDgClRumyNVJ3oATtD1KA5LX3k'), ('filename', '2734b.webp'), ('size', 7242), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jhHlBJ1IbPwk5E4zf2Hvdw/Qm9UPiNbnzvw-rqSo8Jh2zNC7RxdveOKvtw5pA6EQ8bsrLYe7t6ovq-TKxy3SoGwMpP6CKc6HyzrLqJsMLY3vdpSL6RcrAEkeHxRfCXVuVU/kn2VM5HcfG8iXMTtz-pauOv5MwYtIQZnVmI_-55QsZs'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/a_eOPgkb28iwph8p0WJ0MQ/XvKBu49ob3ZM1uT4ZwgUUJ4zI46yJE9BqjYfOtAGmXvBnPBxysfemEYcCowAHJLWBzqKqxwPziMOrFq3rYIVmoKK8PXsIyxvsttHBtx1XA0/jA8QDxYi8b513JpCqP4vQLINA7o0FAABM-9DZ4SSJJE'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rVfsGkuWJESJSLHUnkmoBQ/HFNKn0KUPSHLMA_zcLxhsVW4fWrTlaWuy9pEq2XH2IHHBVNzcpqG9cXVRO41d0MjiP5-f7RV9lqFa_Q0o1b3KClKf-p5_1e_PwMHsOG0-rc/0P-49qOb40-RWHiH3ADRsnRrAj-dxGR0Ei-4uekrZ8k'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2634B SourceMeter SMU instrument is a new dual-channel SMU instrument with best-in-class value and performance. Its tightly-integrated, four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The wide range of 1.5A DC, 10A pulse, 200V output and 1fA measurement resolution makes it suitable to test a wide range of lower current devices and materials. The Model 2634B is equipped with Keithley's high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2634B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2636B SourceMeter SMU Instrument that includes digital I/O, TSP-Link technology, and contact check function.",https://canada.newark.com/keithley/2634b/source-meter-voltage-current-30/dp/44W8039,Keithley 2634 B,267.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2634B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782597/Instruments/Power%20Supplies/Keithley-2634B/Keithley-2634B.webp,Keithley 2634B,Write a Python script that uses Qcodes to connect to a Keithley 2634B Power Supplies,,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
195,https://download.tek.com/datasheet/MSO5000-DPO5000-Mixed-Signal-Oscilloscope-Datasheet-9.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attAo5PcYgEY4GCjq'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EzW-P5SmIJAMVP1vyLl7-A/bdYtTck0FLyWoJMt-MYa659syWJR2d_Gi05BjZZa_d4l5UAU75PanVB7Oom7Cy_bar0Ak3SDlrSt07WN7iWJBsfoJEKq5pPm5ZMen7mvdwM/uAzTZoXHHsOdij8zpday6F4fACo0FQcLmSwr14qn5f0'), ('filename', 'mso5000-front-view.webp'), ('size', 109264), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SqjUYtSoIQNLWXVVtlhxiw/rdooIvdcOiOii5KmvgnT2pm6vry5iBHlcSkgzuIkCPMOv0c7AL0pMlRB5ndFmk0SJB7pUROXp2KfJxpzau7PDluucUJzvzG4zBaE1I6qUAI/lBcY8uvikqh-Lu6GNFNbf_FVIL8Gx0_2INDqQKAaHR0'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ah9iLtn8LxBqo5dPZCTvow/BPpt7Sf08hWQsIE4_-5iGWNU1MAIZkB6X6mTTD5MP1lVH9mOktvDriNsh3oQ6am9OSsOjblIj_h4NtA9fY6bTw9QmeYjV3mOn3HhBDl0tCA/z09sRmCCMVCyCir4cxvgb1yrNQS5Ql1HfQQ3ix9en5M'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/M4MKKlsTyXqoDifzr-2qsw/LwmkhH9uZFIGa6GC8bgsO2bizb02mJfJ51O9NiZdpWMJLIGkX-yOXPs9k1r4yMXKw8h6igcgFFoFvNx888uqo-Imb_Y9nA-5YgOWQlxKSog/Np_IkGE6WVIXuotvzJkuR9owHUTlE4OPZsAVlgnWHIQ'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"With the MSO/DPO5000 Mixed Signal Oscilloscope Series, you can analyze up to 20 analog and digital signals with a single instrument to quickly find and diagnose problems in complex designs. Bandwidths up to 2 GHz and sample rates up to 10 GS/s ensure you have the performance you need to see fast-changing signal details. To capture long windows of signal activity while maintaining fine timing resolution, the MSO/DPO5000 Series offers a deep record length of up to 12.5 M points standard on all channels and an optional record length of up to 250 M points on two channels.",https://www.tek.com/en/datasheet/mso5000-dpo5000-series,Tektronix MSO 5000,574.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixMSO5000,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782600/Instruments/Oscilloscopes/MSO5000/MSO5000.webp,MSO5000,Write a Python script that uses Qcodes to connect to a MSO5000 Oscilloscopes,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
199,https://www.alazartech.com/en/download/product/9062/302/ats9870-datasheet-and-specifications/1-6l/,https://en.wikipedia.org/wiki/Analog-to-digital_converter,"[OrderedDict([('id', 'attgD9pcRFxAwBwvl'), ('width', 360), ('height', 288), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/j2T2JZ-lsM6sDp16v2oAMg/mHD4yPcgMEBmmD819PLI5hoHcoAXwI4L6aQeGo_CNGSZXusMp7V-gyV_sv6z_Nu9RNMe7XCYMAfdsb-XTgJ_-ta_OnV6DjQk3oQygr5ZkacSTfqlUnWcYzN-8zSRhpyasMhBFlrXAxRgL3Us7IfcYQ/d__id0uh4CkD-Rl04QrnoNPdNdBgm2LPvVf9nS-6PPM'), ('filename', '1857-Syncboard-wide-4x-360x288.500.400.jpg'), ('size', 16226), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f5y9IQPhU4Gk1plKlyMYHw/NL0gLastv1pTn1lSFuMYMQrRQHejAuEYeokAY86Vz5x3BjhzMM2MkJs6eUocnVoJ4GkxYvuOLDsWHXD9oz0YKQ/JoxavVnv45rPQxzc3jM2amPkk522Qg_wOp4aDJruYd0'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5RZUd6o_4puY0WD92AohsA/BECJasb41EnPr-uHmbNBgNWy7RW7GlZ979z28FULVfzhMzqsaP3PKFwTFJtvUeP6GBS4vhdEB65xYNkBITCbrw/9-XNEgdvlqbC6CeX46MEKIh8YijqjYTFqmERZwW8d3Q'), ('width', 360), ('height', 288)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wHu0XaT2SpfaKxZ9u1e6Mg/GHgeRgnfJFv0cRcKUXxKVF6PJ3FQarcZ0lKZd1ga2CaohalM1ZhTw81LPoNC0WzHD4c9_NMHQhm-4HC3cHsBTQ/6e2_-f2-0Jxtvnqv3IJsy-YiuM4Bp7fO31oKlEEVMNI'), ('width', 3000), ('height', 3000)]))]))])]",4.0,CANADA - QC,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692117216/Instruments/Vendor%20Logos/Alazartech.png,"ATS9870 is the world's first Giga-sample waveform digitizer based on the 8-lane PCI Express interface

",https://www.alazartech.com/en/product/ats9870/5/,ATS 9870,65.0,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AlazarTech/ATS9870.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AlazarTech.html#qcodes.instrument_drivers.AlazarTech.AlazarTechATS9870,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qAKVZnWakj3BsqaWIGBWRQ/ZrX_1_RMjBiSZrv9vP_57uXX3nVYvTG1M9yX0X0AbV2ABAwNqnlZ9ph2VxPWUntz57MfzGIcVtzwp_xIT4ogdpEUOSJkRSVjiQ9SdRaAR8Y/iqBF0wweZWGzh_PoUEPAoR1OMbJQ4ahE5SQ20efnW3w'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/c4okM_mAktf0nM5a4ujUcw/ojbZu24hQ3OsnpsLBQXtdSWuTk3Iklxwh_8h6Gu6nI-N-cZTED09W58zGdsdkzX784cjIMgM0mnM_Z10HE0DWw/-nQKXfI9UrjNxpUl6HPlw0VxPf0bhIFJu_puq3PBLH4'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wLU644oqMwyGp0nvbNsxWg/zc4O5FXXDWFC_3eWYDbTDhZ-8RKh4CywL6uxn3m30ZG4fRuCONJ6Iogf6ftQ_O_Q8qSa8Eq3C__L1bpo6Vc0tQ/tV1Jc99vngeTFMSvJRsKPiMPSZq261WWlEYFw6eF4dU'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pkhaW6W4s4X9DwUXiC5Qnw/twaNCkfaOpFsDIxJR3erWLY6uTRf-2naFC2FMhp_b49XItnrDMobUqWla3Gd6BRrhtn7cJNMypgCsWLD8PhzCw/_jkIrQ_2tQiU0GB3OhyCLuO6UO3JEk_1njNMezltdd4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782603/Instruments/DAQ%20boards/ATS9870---8-bit%2C-1-GS-s/ATS9870---8-bit_-1-GS-s.jpg,"ATS9870 - 8 bit, 1 GS/s","Write a Python script that uses Qcodes to connect to a ATS9870 - 8 bit, 1 GS/s DAQ boards",,"
",True,,"from typing import Any

from qcodes import validators

from .ATS import AlazarTech_ATS
from .utils import TraceParameter


class AlazarTechATS9870(AlazarTech_ATS):
    """"""
    This class is the driver for the ATS9870 board
    it inherits from the ATS base class

    It creates all necessary parameters for the Alazar card
    """"""
    def __init__(self, name: str,
                 dll_path: str = 'C:\\WINDOWS\\System32\\ATSApi.dll',
                 **kwargs: Any):
        super().__init__(name, dll_path=dll_path, **kwargs)
        # add parameters

        # ----- Parameters for the configuration of the board -----
        self.add_parameter(name='clock_source',
                           parameter_class=TraceParameter,
                           label='Clock Source',
                           unit=None,
                           initial_value='INTERNAL_CLOCK',
                           val_mapping={'INTERNAL_CLOCK': 1,
                                        'SLOW_EXTERNAL_CLOCK': 4,
                                        'EXTERNAL_CLOCK_AC': 5,
                                        'EXTERNAL_CLOCK_10MHz_REF': 7})

        self.add_parameter(name='external_sample_rate',
                           get_cmd=None,
                           parameter_class=TraceParameter,
                           label='External Sample Rate',
                           unit='S/s',
                           vals=validators.Enum(1_000_000_000),
                           initial_value=1_000_000_000)

        self.add_parameter(name='sample_rate',
                           parameter_class=TraceParameter,
                           label='Sample Rate',
                           unit='S/s',
                           initial_value=1000000000,
                           val_mapping={
                               1000: 0x1,
                               2000: 0x2,
                               5000: 0x4,
                               10000: 0x8,
                               20000: 0xA,
                               50000: 0xC,
                               100000: 0xE,
                               200000: 0x10,
                               500000: 0x12,
                               1000000: 0x14,
                               2000000: 0x18,
                               5000000: 0x1A,
                               10000000: 0x1C,
                               20000000: 0x1E,
                               50000000: 0x22,
                               100000000: 0x24,
                               250000000: 0x2B,
                               500000000: 0x30,
                               1000000000: 0x35,
                               'EXTERNAL_CLOCK': 0x40,
                               '1GHz_REFERENCE_CLOCK': 1000000000})

        self.add_parameter(name='clock_edge',
                           parameter_class=TraceParameter,
                           label='Clock Edge',
                           unit=None,
                           initial_value='CLOCK_EDGE_RISING',
                           val_mapping={'CLOCK_EDGE_RISING': 0,
                                        'CLOCK_EDGE_FALLING': 1})

        self.add_parameter(name='decimation',
                           parameter_class=TraceParameter,
                           label='Decimation',
                           unit=None,
                           initial_value=0,
                           vals=validators.Ints(0, 100000))

        for i in range(1, self.channels + 1):
            self.add_parameter(name=f'coupling{i}',
                               parameter_class=TraceParameter,
                               label=f'Coupling channel {i}',
                               unit=None,
                               initial_value='AC',
                               val_mapping={'AC': 1, 'DC': 2})
            self.add_parameter(name=f'channel_range{i}',
                               parameter_class=TraceParameter,
                               label=f'Range channel {i}',
                               unit='V',
                               initial_value=4,
                               val_mapping={0.04: 2,
                                            0.1: 5,
                                            0.2: 6,
                                            0.4: 7,
                                            1.0: 10,
                                            2.0: 11,
                                            4.0: 12})
            self.add_parameter(name=f'impedance{i}',
                               parameter_class=TraceParameter,
                               label=f'Impedance channel {i}',
                               unit='Ohm',
                               initial_value=50,
                               val_mapping={1000000: 1,
                                            50: 2})
            self.add_parameter(name=f'bwlimit{i}',
                               parameter_class=TraceParameter,
                               label=f'Bandwidth limit channel {i}',
                               unit=None,
                               initial_value='DISABLED',
                               val_mapping={'DISABLED': 0,
                                            'ENABLED': 1})

        self.add_parameter(name='trigger_operation',
                           parameter_class=TraceParameter,
                           label='Trigger Operation',
                           unit=None,
                           initial_value='TRIG_ENGINE_OP_J',
                           val_mapping={'TRIG_ENGINE_OP_J': 0,
                                        'TRIG_ENGINE_OP_K': 1,
                                        'TRIG_ENGINE_OP_J_OR_K': 2,
                                        'TRIG_ENGINE_OP_J_AND_K': 3,
                                        'TRIG_ENGINE_OP_J_XOR_K': 4,
                                        'TRIG_ENGINE_OP_J_AND_NOT_K': 5,
                                        'TRIG_ENGINE_OP_NOT_J_AND_K': 6})
        n_trigger_engines = 2
        for i in range(1, n_trigger_engines+1):
            self.add_parameter(name=f'trigger_engine{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Engine {i}',
                               unit=None,
                               initial_value='TRIG_ENGINE_' + ('J' if i == 1 else 'K'),
                               val_mapping={'TRIG_ENGINE_J': 0,
                                            'TRIG_ENGINE_K': 1})
            self.add_parameter(name=f'trigger_source{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Source {i}',
                               unit=None,
                               initial_value='DISABLE',
                               val_mapping={'CHANNEL_A': 0,
                                            'CHANNEL_B': 1,
                                            'EXTERNAL': 2,
                                            'DISABLE': 3})
            self.add_parameter(name=f'trigger_slope{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Slope {i}',
                               unit=None,
                               initial_value='TRIG_SLOPE_POSITIVE',
                               val_mapping={'TRIG_SLOPE_POSITIVE': 1,
                                            'TRIG_SLOPE_NEGATIVE': 2})
            self.add_parameter(name=f'trigger_level{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Level {i}',
                               unit=None,
                               initial_value=128,
                               vals=validators.Ints(0, 255))

        self.add_parameter(name='external_trigger_coupling',
                           parameter_class=TraceParameter,
                           label='External Trigger Coupling',
                           unit=None,
                           initial_value='DC',
                           val_mapping={'DC': 2})

        self.add_parameter(name='external_trigger_range',
                           parameter_class=TraceParameter,
                           label='External Trigger Range',
                           unit=None,
                           initial_value='ETR_5V',
                           val_mapping={'ETR_5V': 0,
                                        'ETR_1V': 1})
        self.add_parameter(name='trigger_delay',
                           parameter_class=TraceParameter,
                           label='Trigger Delay',
                           unit='Sample clock cycles',
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='timeout_ticks',
                           parameter_class=TraceParameter,
                           label='Timeout Ticks',
                           unit='10 us',
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='aux_io_mode',
                           parameter_class=TraceParameter,
                           label='AUX I/O Mode',
                           unit=None,
                           initial_value='AUX_IN_AUXILIARY',
                           val_mapping={'AUX_OUT_TRIGGER': 0,
                                        'AUX_IN_TRIGGER_ENABLE': 1,
                                        'AUX_IN_AUXILIARY': 13})

        self.add_parameter(name='aux_io_param',
                           parameter_class=TraceParameter,
                           label='AUX I/O Param',
                           unit=None,
                           initial_value='NONE',
                           val_mapping={'NONE': 0,
                                        'TRIG_SLOPE_POSITIVE': 1,
                                        'TRIG_SLOPE_NEGATIVE': 2})

        # ----- Parameters for the acquire function -----
        self.add_parameter(name='mode',
                           label='Acquisition mode',
                           unit=None,
                           initial_value='NPT',
                           set_cmd=None,
                           val_mapping={'NPT': 0x200, 'TS': 0x400})

        # samples_per_record must be a multiple of of some number (64 in the
        # case of ATS9870) and and has some minimum (256 in the case of ATS9870)
        # These values can be found in the ATS-SDK programmar's guide
        self.add_parameter(name='samples_per_record',
                           label='Samples per Record',
                           unit=None,
                           initial_value=96000,
                           set_cmd=None,
                           vals=validators.Multiples(
                                divisor=64, min_value=256))

        self.add_parameter(name='records_per_buffer',
                           label='Records per Buffer',
                           unit=None,
                           initial_value=1,
                           set_cmd=None,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffers_per_acquisition',
                           label='Buffers per Acquisition',
                           unit=None,
                           set_cmd=None,
                           initial_value=1,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='channel_selection',
                           label='Channel Selection',
                           unit=None,
                           set_cmd=None,
                           initial_value='AB',
                           val_mapping={'A': 1, 'B': 2, 'AB': 3})
        self.add_parameter(name='transfer_offset',
                           label='Transfer Offset',
                           unit='Samples',
                           set_cmd=None,
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='external_startcapture',
                           label='External Startcapture',
                           unit=None,
                           set_cmd=None,
                           initial_value='ENABLED',
                           val_mapping={'DISABLED': 0X0,
                                        'ENABLED': 0x1})
        self.add_parameter(name='enable_record_headers',
                           label='Enable Record Headers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x8})
        self.add_parameter(name='alloc_buffers',
                           label='Alloc Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x20})
        self.add_parameter(name='fifo_only_streaming',
                           label='Fifo Only Streaming',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x800})
        self.add_parameter(name='interleave_samples',
                           label='Interleave Samples',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x1000})
        self.add_parameter(name='get_processed_data',
                           label='Get Processed Data',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x2000})
        self.add_parameter(name='allocated_buffers',
                           label='Allocated Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value=1,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffer_timeout',
                           label='Buffer Timeout',
                           unit='ms',
                           set_cmd=None,
                           initial_value=1000,
                           vals=validators.Ints(min_value=0))

        model = self.get_idn()['model']
        if model != 'ATS9870':
            raise Exception(f""The Alazar board kind is not 'ATS9870',""
                            f"" found '{str(model)}' instead."")


class AlazarTech_ATS9870(AlazarTechATS9870):
    """"""
    Alias for backwards compatibility. Will eventually be deprecated and removed
    """"""

    pass
"
200,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,https://www.keysight.com/us/en/product/34934A/quad-4x32-reed-matrix.html,"[OrderedDict([('id', 'attYKE1Yada4OvZGT'), ('width', 300), ('height', 169), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9zvRqICU3sjBTJu-fCHAjw/dLIe8snj0fg-AKousYmCfpvzgSy8z2R4ssXZKhME43vqeneKYc5WHB8lxH9MUMjSm2j6c6kIyNr2OOS2IzbY4TsSLxPtClm8fROqqFvrQjVJBpUjul9ashn5qA58tsjn/ppijhxsuiF7E86Eue7htkbnzW3hoY6cEpFqxjavtIZc'), ('filename', '34934A-TRANSP-04_1600x900.jpeg'), ('size', 3295), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5CT92RCS0yggRGAC6xP4Vg/bOZI8nO9Gm3FEHb4KvZXhI482s8B6ggI4uPqr1uY_Dy7Xo-TI_GeY2tBTkfNaXBy4eRssJAzD3VED-85iHfjfw/SkloEIAlX0wOxJSznmIiV9dHuoxFDffPi90WSgf8ON4'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/S_qMRUpttF2iPHJMhFlHJA/C9CaaMWoYsoT4lYZikVbi4ulqzc46qal904ZG0hV5YltLAnBgrPOz2_7ODY1X_DPfxVTZemao0r1D-cV4dWQxQ/SjmasPwVgArLfCwvSk0lF7yruiTr0Ub4NzVyHOlJrb8'), ('width', 300), ('height', 169)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kv7sNDIqRbM0x7HlnYGvsA/bP1DREeWewlFpbbSKmaorhWn_a32UaA7mTgMnGkg_bOEAwwh-NtDG_KBLOyvfVl7AkaXnYDMUsITUQeq-BNCtA/g6fgsQkAo81iCsH4zHYYWjXVLsnbGxLH-ED1hMjRStI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight 34934A module for the 34980A Multifunction Switch/Measure Unit offers the highest density matrix for connecting paths between your device under test and your test equipment, allowing for multiple instrument connections to multiple points on your device under test at the same time.",https://www.keysight.com/us/en/product/34934A/quad-4x32-reed-matrix.html,Keysight 34934 A,341.0,['DAQ boards'],"The matrix modules can be expanded with the row expansion kit allowing for up to 4096 cross points in a single mainframe. And with the unique row disconnect feature, you don´t have to worry about the added capacitance when connecting multiple matrix modules.

","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34934a.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34934A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782604/Instruments/DAQ%20boards/Keysight-34934A/Keysight-34934A.jpg,Keysight 34934A,Write a Python script that uses Qcodes to connect to a Keysight 34934A DAQ boards,8250.0,,,,"import logging
import re
from qcodes import VisaInstrument, InstrumentChannel, validators
from typing import Union, List, Tuple, Optional, Callable
from .keysight_34980a_submodules import KeysightSwitchMatrixSubModule


class Keysight34934A(KeysightSwitchMatrixSubModule):
    """"""
    Create an instance for module 34933A.
    Args:
        parent: the system which the module is installed on
        name: user defined name for the module
        slot: the slot the module is installed
    """"""
    def __init__(
            self,
            parent: Union[VisaInstrument, InstrumentChannel],
            name: str,
            slot: int
    ) -> None:

        super().__init__(parent, name, slot)

        self.add_parameter(name='protection_mode',
                           get_cmd=self._get_relay_protection_mode,
                           set_cmd=self._set_relay_protection_mode,
                           vals=validators.Enum('AUTO100',
                                                 'AUTO0',
                                                 'FIX',
                                                 'ISO'),
                           docstring='get and set the relay protection mode.'
                                     'The fastest switching speeds for relays'
                                     'in a given signal path are achieved using'
                                     'the FIXed or ISOlated modes, followed'
                                     'by the AUTO100 and AUTO0 modes.'
                                     'There may be a maximum of 200 Ohm of'
                                     'resistance, which can only be bypassed'
                                     'by ""AUTO0"" mode. See manual and'
                                     'programmer''s reference for detail.')

        layout = self.ask(f'SYSTEM:MODule:TERMinal:TYPE? {self.slot}')
        self._is_locked = (layout == 'NONE')
        if self._is_locked:
            logging.warning(f'For slot {slot}, no configuration module'
                            f'connected, or safety interlock jumper removed. '
                            ""Making any connection is not allowed"")
            config = self.ask(f'SYST:CTYP? {slot}').strip('""').split(',')[1]
            layout = config.split('-')[1]
        self.row, self.column = [
            int(num) for num in re.findall(r'\d+', layout)
        ]

    def write(self, cmd: str) -> None:
        """"""
        When the module is safety interlocked, users can not make any
        connections. There will be no effect when try to connect any channels.
        """"""
        if self._is_locked:
            logging.warning(""Warning: no configuration module connected, ""
                            ""or safety interlock enabled. ""
                            ""Making any connection is not allowed"")
        return self.parent.write(cmd)

    def validate_value(self, row: int, column: int) -> None:
        """"""
        to check if the row and column number is within the range of the
        module layout.

        Args:
            row: row value
            column: column value
        """"""
        if (row > self.row) or (column > self.column):
            raise ValueError('row/column value out of range')

    def _get_relay_protection_mode(self) -> str:
        return self.ask(f'SYSTem:MODule:ROW:PROTection? {self.slot}')

    def _set_relay_protection_mode(self, mode: str) -> None:
        self.write(f'SYSTem:MODule:ROW:PROTection {self.slot}, {mode}')

    def to_channel_list(
            self,
            paths: List[Tuple[int, int]],
            wiring_config: Optional[str] = ''
    ) -> str:
        """"""
        convert the (row, column) pair to a 4-digit channel number 'sxxx', where
        s is the slot number, xxx is generated from the numbering function.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
            wiring_config: for 1-wire matrices, values are 'MH', 'ML';
                                 for 2-wire matrices, values are 'M1H', 'M2H',
                                 'M1L', 'M2L'

        Returns:
            in the format of '(@sxxx, sxxx, sxxx, sxxx)', where sxxx is a
            4-digit channel number
        """"""
        numbering_function = self.get_numbering_function(
            self.row,
            self.column,
            wiring_config
        )

        channels = []
        for row, column in paths:
            channel = f'{self.slot}{numbering_function(row, column)}'
            channels.append(channel)
        channel_list = f""(@{','.join(channels)})""
        return channel_list

    @staticmethod
    def get_numbering_function(
            rows: int,
            columns: int,
            wiring_config: Optional[str] = ''
    ) -> Callable[[int, int], str]:
        """"""
        to select the correct numbering function based on the matrix layout.
        On P168 of the user's guide for Agilent 34934A High Density Matrix
        Module:
        http://literature.cdn.keysight.com/litweb/pdf/34980-90034.pdf
        there are eleven equations. This function here simplifies them to one.

        Args:
            rows: the total row number of the matrix module
            columns: the total column number of the matrix module
            wiring_config: wiring configuration for 1 or 2 wired matrices

        Returns:
            The numbering function to convert row and column in to a 3-digit
            number
        """"""
        layout = f'{rows}x{columns}'
        available_layouts = {
            ""4x32"": [""M1H"", ""M2H"", ""M1L"", ""M2L""],
            ""4x64"": [""MH"", ""ML""],
            ""4x128"": [''],
            ""8x32"": [""MH"", ""ML""],
            ""8x64"": [''],
            ""16x32"": ['']
        }

        if layout not in available_layouts:
            raise ValueError(f""Unsupported layout: {layout}"")

        if wiring_config not in available_layouts[layout]:
            raise ValueError(
                f""Invalid wiring config '{wiring_config}' for layout {layout}""
            )

        offsets = {
            ""M1H"": 0,
            ""M2H"": 1,
            ""M1L"": 2,
            ""M2L"": 3,
            ""MH"": 0,
            ""ML"": 1
        }

        offset = 0
        if wiring_config != '':
            offset = offsets[wiring_config] * columns

        channels_per_row = 800 / rows
        offset += 100 - int(channels_per_row)

        def numbering_function(row: int, col: int) -> str:
            return str(int(channels_per_row * row + col + offset))

        return numbering_function
"
203,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'attiY3mADod6PkrWn'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GYQwlLvfs7vbYmYSMZ0gMA/8Su50n4GY2uGmq-rnoRrAYsvnXyJmLQjBlk6Zw8UFbf-ND5BjBxKQSEspdTyyMGhxMSyPS-KKxr6KE9YuNxeNPNmoE4G_YIQg1bfjYpPKik/3309nEJVgD0E0J6thAkYfpG2T_DvB_cfyIe5GJLyU3c'), ('filename', 'PL303P-1000px.jpg'), ('size', 159244), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N9b2iCarjwtBq7ndHTvIWg/08Ntf-KFl0o5mP1MNsCFR6DsG3nMBtMiMBApTw1Mx0OqBh9IoUXYa3Qsui2UTc_1rqLRs4IRlFn2XAeaf8larA/1InBR8ajGDbeh-vwR9p3TqSmfcGpR793vcXvbbQxvTE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lrQlbj__rDvX3nOPcAwLHQ/LhyVgLIojrocCiQLPRKYcFwLmBYCoEqoEusF_1TfD67KMYk1LzIcyyH4t41J-kjLKHQ2F12kcY2Kh6-5HXxFHA/aWp5uM9Rk5l4QH-SVuP3tWe0b3__vyIp37PWMS5Yk0k'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yPVDCUb6xkK1Pny51CwQow/uyrtNGNyd20CFZYvXdXBMYhco78C_1uXmdUPGFemquo6No-RR5weVMpeOToppCM0BX76p3Y3i_wYHrxuoU6q3A/KgROq3SS5FSR3jCLwJJiJ0mdq7F3WNg_prmkHmOl6cw'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Single Output, 30V/3A, USB, RS232, LAN(LXI) and Analogue Interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 303 P,47.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL303P,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782606/Instruments/Power%20Supplies/PL303-P/PL303-P.jpg,PL303-P,Write a Python script that uses Qcodes to connect to a PL303-P Power Supplies,700.0,,,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
206,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attTcyLVieBJhRxag'), ('width', 2048), ('height', 1393), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/u_6Emc51tD0NDv4ExahC0w/fgSDg1qwhUJxXi1aD4FRt20Xa9GuPUNZrmcgD_C-1RB9RiGyH63wAHJXcxRKuTLYf5c0JYjyS3LEi64o3PqbESO346MHavowezgBl6QJymk/nGZVGD6iSEgVEv4iv1cIMW8iYN9UOV6efp6fcDRutTs'), ('filename', '71pS35meVqL.jpg'), ('size', 248989), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/L0HRKNmsyZn75nunYz16aA/xrQFefK_5n2DVu4N91m5vmJ9FmYIPo6NF_8ihs6ua7pdG_uIgZRRgLDixI0CNqOPBMrdrf2P7yVkr4B5A0Gtjw/12c5Pc03Ft45JHowk5YfqvR_sfnXQ5QGUV4cfJoQbv8'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4Wgtu03hPrLv5fI7xW13gw/uznu95IQgJUnPXzc7FFRklFA4dYVWr7iYeD-8YemdYZen0xOcC14qU4SVR3e441sPpzZiX5hJaD8K9DqJX6Zaw/48btuIM34RtXyI2dfzKP9WgbTwrz2uSqAumB89xHnTY'), ('width', 753), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3WCXQ07FhMGK2I7G40dqSg/DrKIKc2bicK0p_o_880vCeQirJH_P6FsyjUVZOpO4NchqlV-y0tUGJhE7LeUfOBI9-YH5mm3qwkjhxfWkyAj1g/jEt7jsCSNyiDy4OyfTU9jtoKmyA8XgOmv9z9g_WA5ho'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"The Rigol DP831 features a relative large (8.9 cm / 3.5"") and easy to read TFT monochrome display. In addition to the normal digital displays for voltage, current, and power, these values can also be displayed as signal curves.

",https://www.batronix.com/shop/power-supplies/DP831.html,DP 831,448.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP831.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP831,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782610/Instruments/Power%20Supplies/Rigol-DP831/Rigol-DP831.jpg,Rigol DP831,Write a Python script that uses Qcodes to connect to a Rigol DP831 Power Supplies,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP831(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP831(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [(8.0, 5.0), (30.0, 2.0), (-30.0, 2.0)]

        ovp_ranges_std = [(0.01, 8.8), (0.01, 33.0), (-0.01, -33.0)]
        ocp_ranges_std = [(0.001, 5.5), (0.001, 2.2), (0.001, 2.2)]

        ovp_ranges_precision = [(0.001, 8.8), (0.001, 33.0), (-0.001, -33.0)]
        ocp_ranges_precision = [(0.0001, 5.5), (0.0001, 2.2), (0.0001, 2.2)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
209,https://www.keysight.com/us/en/assets/7018-01355/data-sheets/5989-4435.pdf,https://www.keysight.com/us/en/products/lcr-meters-impedance-measurement-products/bench-top-lcr-meters.html,"[OrderedDict([('id', 'attuZHiWXbmDgcXF9'), ('width', 1156), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UGAbcVEb2fSLz78farwCFQ/f9lZ6mhaTKCFLn71lB47Q1PyVtBw_1n7hMvk2SgYqsRCIwvRH7h3QCDNxcCoO0ayxLFuWKKQraW320IOUK3p0w/6WuG31BMKRBgnMLKVxzlwcOxPCEmQSm1atXpNbIxWm8'), ('filename', 'LCR.png'), ('size', 475849), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xjq2VPQLgNRUO03jy1GA2A/_XH3r7hnV3IhjUlL3peFgn4rNMzpyqSz3CU7MTpB9WtasIEuJCSjRgP48U6psZwkt3KeYHbuToHiFPHKsrnSXA/hp77kjocs5Z5u43NGNlW6hIXcQdp9i1Y__nCs-BpEEg'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EnCglQ09LRzo1vNTzUewRw/fn71T1F4_Wr5yy_pque0tUgoTRpQKyi3JvdlZifIDempmmLKyFwX9gTtrQjPqVRiCKnrEVa6VxTFUwgsANLyEQ/ZZIvuDzIaJ0U-QrKCZKa4geXDZ6JIfkoZV8_7dnQk7g'), ('width', 769), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ki5qLmgpv6Juu8W9uvGePA/jll7GCom8BidqIrr9W63b4onU3mk-NHZMaDrNBoRLYatqzoNGh48Wb2xs24zVJhBFZ8ypg-yCtMoa21KMGXdrA/4DwXhqip_2A3lRGh1NYeQSnrxnj4yp1h96CasZFCWhs'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The E4980A precision LCR meter provides the best combination of accuracy, speed, and versatility for a wide range of component measurements.",https://www.keysight.com/us/en/product/E4980A/precision-lcr-meter-20-hz-2-mhz.html,Keysight E 4980 A,335.0,['Multimeters'],"An LCR meter is a type of electronic test equipment used to measure the inductance (L), capacitance (C), and resistance (R) of an electronic component.[1]","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_e4980a.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightE4980A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782484/Instruments/Multimeters/Keysight-E4980A/Keysight-E4980A.png,Keysight E4980A,Write a Python script that uses Qcodes to connect to a Keysight E4980A Multimeters,24253.0,,,,"from typing import Tuple, Sequence, cast, Any, Union
from distutils.version import LooseVersion
from pyvisa.errors import VisaIOError

from qcodes import VisaInstrument, InstrumentChannel
from qcodes.instrument.parameter import (MultiParameter, ParamRawDataType,
                                         ManualParameter)
from qcodes.utils.helpers import create_on_off_val_mapping
from qcodes.utils.validators import Enum, Numbers, Bool, Ints
from qcodes.instrument.group_parameter import GroupParameter, Group


class MeasurementPair(MultiParameter):
    """"""
    Data class for E4980A measurement, which will always return two items
    at once.

    The two items are for two different parameters, depending on the measurement
    function. Hence, the names of the two attributes are created from the
    ""names"" tuple of the measurement functions.

    Examples:
        To create a measurement data with capacitance=1.2, and
        dissipation_factor=3.4.

        >>> data = MeasurementPair(name=""CPD"",
                                    names=(""capacitance"", ""dissipation_factor""),
                                    units=(""F"", """"))
        >>> data.set((1.2, 3.4))
        >>> data.get()
        (1.2, 3.4)
    """"""
    value: Tuple[float, float] = (0., 0.)

    def __init__(self,
                 name: str,
                 names: Sequence[str],
                 units: Sequence[str],
                 **kwargs: Any):
        super().__init__(name=name,
                         names=names,
                         shapes=((), ()),
                         units=units,
                         setpoints=((), ()),
                         **kwargs)
        self.__dict__.update(
            {names[0]: 0,
             names[1]: 0}
        )

    def set_raw(self, value: Tuple[float, float]) -> None:
        self.value = value
        setattr(self, self.names[0], value[0])
        setattr(self, self.names[1], value[1])

    def get_raw(self) -> Tuple[ParamRawDataType, ...]:
        return self.value


class E4980AMeasurements:
    """"""
    All the measurement function for E4980A LCR meter. See user's guide P353
    https://literature.cdn.keysight.com/litweb/pdf/E4980-90230.pdf?id=789356
    """"""
    CPD = MeasurementPair(
        ""CPD"", (""capacitance"", ""dissipation_factor""), (""F"", """")
    )
    CPQ = MeasurementPair(
        ""CPQ"", (""capacitance"", ""quality_factor""), (""F"", """")
    )
    CPG = MeasurementPair(
        ""CPG"", (""capacitance"", ""conductance""), (""F"", ""S"")
    )
    CPRP = MeasurementPair(
        ""CPRP"", (""capacitance"", ""resistance""), (""F"", ""Ohm"")
    )
    CSD = MeasurementPair(
        ""CSD"", (""capacitance"", ""dissipation_factor""), (""F"", """")
    )
    CSQ = MeasurementPair(
        'CSQ', (""capacitance"", ""quality_factor""), (""F"", """")
    )
    CSRS = MeasurementPair(
        ""CSRS"", (""capacitance"", ""resistance""), (""F"", ""Ohm"")
    )
    LPD = MeasurementPair(
        ""LPD"", (""inductance"", ""dissipation_factor""), (""H"", """")
    )
    LPQ = MeasurementPair(
        ""LPQ"", (""inductance"", ""quality_factor""), (""H"", """")
    )
    LPG = MeasurementPair(
        ""LPG"", (""inductance"", ""conductance""), (""H"", ""S"")
    )
    LPRP = MeasurementPair(
        ""LPRP"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    LSD = MeasurementPair(
        ""LSD"", (""inductance"", ""dissipation_factor""), (""H"", """")
    )
    LSQ = MeasurementPair(
        ""LSQ"", (""inductance"", ""quality_factor""), (""H"", """")
    )
    LSRS = MeasurementPair(
        ""LSRS"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    LSRD = MeasurementPair(
        ""LSRD"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    RX = MeasurementPair(
        ""RX"", (""resistance"", ""reactance""), (""Ohm"", ""Ohm"")
    )
    ZTD = MeasurementPair(
        ""ZTD"", (""impedance"", ""theta""), (""Ohm"", ""Degree"")
    )
    ZTR = MeasurementPair(
        ""ZTR"", (""impedance"", ""theta""), (""Ohm"", ""Radiant"")
    )
    GB = MeasurementPair(
        ""GB"", (""conductance"", ""susceptance""), (""S"", ""S"")
    )
    YTD = MeasurementPair(
        ""YTD"", (""admittance"", ""theta""), (""Y"", ""Degree"")
    )
    YTR = MeasurementPair(
        ""YTR"", (""admittance"", ""theta""), (""Y"", ""Radiant"")
    )
    VDID = MeasurementPair(
        ""VDID"", (""voltage"", ""current""), (""V"", ""A"")
    )


class Correction4980A(InstrumentChannel):
    """"""
    Module for correction settings.
    """"""
    def __init__(
            self,
            parent: VisaInstrument,
            name: str,
    ) -> None:
        super().__init__(parent, name)

        self.add_parameter(
            ""open"",
            set_cmd="":CORRection:OPEN"",
            docstring=""Executes OPEN correction based on all frequency points.""
        )

        self.add_parameter(
            ""open_state"",
            get_cmd="":CORRection:OPEN:STATe?"",
            set_cmd="":CORRection:OPEN:STATe {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enables or disable OPEN correction""
        )

        self.add_parameter(
            ""short"",
            set_cmd="":CORRection:SHORt"",
            docstring=""Executes SHORT correction based on all frequency points.""
        )

        self.add_parameter(
            ""short_state"",
            get_cmd="":CORRection:SHORt:STATe?"",
            set_cmd="":CORRection:SHORt:STATe {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enables or disable SHORT correction.""
        )


class KeysightE4980A(VisaInstrument):
    """"""
    QCodes driver for E4980A Precision LCR Meter
    """"""
    def __init__(self,
                 name: str,
                 address: str,
                 terminator: str = '\n',
                 **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address.
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        idn = self.IDN.get()

        self.has_firmware_a_02_10_or_above = (
                LooseVersion(idn[""firmware""]) >= LooseVersion(""A.02.10"")
        )

        self.has_option_001 = '001' in self._options()
        self._dc_bias_v_level_range: Union[Numbers, Enum]
        if self.has_option_001:
            self._v_level_range = Numbers(0, 20)
            self._i_level_range = Numbers(0, 0.1)
            self._imp_range = Enum(0.1, 1, 10, 100, 300, 1000, 3000, 10000,
                                   30000, 100000)
            self._dc_bias_v_level_range = Numbers(-40, 40)
        else:
            self._v_level_range = Numbers(0, 2)
            self._i_level_range = Numbers(0, 0.02)
            self._imp_range = Enum(1, 10, 100, 300, 1000, 3000, 10000, 30000,
                                   100000)
            self._dc_bias_v_level_range = Enum(0, 1.5, 2)

        self._measurement_pair = MeasurementPair(
            ""CPD"",
            (""capacitance"", ""dissipation_factor""),
            (""F"", """")
        )

        self.add_parameter(
            ""frequency"",
            get_cmd="":FREQuency?"",
            set_cmd="":FREQuency {}"",
            get_parser=float,
            unit=""Hz"",
            vals=Numbers(20, 2E6),
            docstring=""Gets and sets the frequency for normal measurement.""
        )

        self.add_parameter(
            ""current_level"",
            get_cmd=self._get_current_level,
            set_cmd=self._set_current_level,
            unit=""A"",
            vals=self._i_level_range,
            docstring=""Gets and sets the current level for measurement signal.""
        )

        self.add_parameter(
            ""voltage_level"",
            get_cmd=self._get_voltage_level,
            set_cmd=self._set_voltage_level,
            unit=""V"",
            vals=self._v_level_range,
            docstring=""Gets and sets the AC bias voltage level for measurement ""
                      ""signal.""
        )

        self.add_parameter(
            ""measurement_function"",
            get_cmd="":FUNCtion:IMPedance?"",
            set_cmd=self._set_measurement
        )

        self.add_parameter(
            ""range"",
            get_cmd="":FUNCtion:IMPedance:RANGe?"",
            set_cmd=self._set_range,
            unit='Ohm',
            vals=self._imp_range,
            docstring=""Selects the impedance measurement range, also turns ""
                      ""the auto range function OFF.""
        )

        self.add_parameter(
            ""imp_autorange_enabled"",
            get_cmd="":FUNCtion:IMPedance:RANGe:AUTO?"",
            set_cmd="":FUNCtion:IMPedance:RANGe:AUTO {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                  off_val=""0""),
            docstring=""Enables the auto-range for impedance measurement.""
        )

        self.add_parameter(
            ""dc_bias_enabled"",
            get_cmd="":BIAS:STATe?"",
            set_cmd="":BIAS:STATe {}"",
            vals=Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                  off_val=""0""),
            docstring=""Enables DC bias. DC bias is automatically turned ""
                      ""off after recalling the state from memory.""
        )

        self.add_parameter(
            ""dc_bias_voltage_level"",
            get_cmd="":BIAS:VOLTage:LEVel?"",
            set_cmd="":BIAS:VOLTage:LEVel {}"",
            get_parser=float,
            unit=""V"",
            vals=self._dc_bias_v_level_range,
            docstring=""Sets the DC bias voltage. Setting does not ""
                      ""implicitly turn the DC bias ON.""
        )

        self.add_parameter(
            ""meas_time_mode"",
            val_mapping={""short"": ""SHOR"", ""medium"": ""MED"", ""long"": ""LONG""},
            parameter_class=GroupParameter
        )

        self.add_parameter(
            ""averaging_rate"",
            vals=Ints(1, 256),
            parameter_class=GroupParameter,
            get_parser=int,
            docstring=""Averaging rate for the measurement.""
        )

        self._aperture_group = Group(
            [self.meas_time_mode,
             self.averaging_rate],
            set_cmd="":APERture {meas_time_mode},{averaging_rate}"",
            get_cmd="":APERture?""
        )

        if self.has_firmware_a_02_10_or_above:
            self.add_parameter(
                ""dc_bias_autorange_enabled"",
                get_cmd="":BIAS:RANGe:AUTO?"",
                set_cmd="":BIAS:RANGe:AUTO {}"",
                vals=Bool(),
                val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                      off_val=""0""),
                docstring=""Enables DC Bias range AUTO setting. When DC bias ""
                          ""range is fixed (not AUTO), '#' is displayed in ""
                          ""the BIAS field of the display.""
            )

        self.add_parameter(
            ""signal_mode"",
            initial_value=None,
            vals=Enum(""Voltage"", ""Current"", None),
            parameter_class=ManualParameter,
            docstring=""This parameter tracks the signal mode which is being ""
                      ""set.""
        )

        self.add_submodule(
            ""_correction"",
            Correction4980A(self, ""correction"")
        )
        self._set_signal_mode_on_driver_initialization()
        self.connect_message()

    @property
    def correction(self) -> Correction4980A:
        submodule = self.submodules['_correction']
        return cast(Correction4980A, submodule)

    @property
    def measure_impedance(self) -> MeasurementPair:
        return self._get_complex_impedance()

    @property
    def measurement(self) -> MeasurementPair:
        return self._measurement()

    def _set_range(self, val: str) -> None:
        self.write(f"":FUNCtion:IMPedance:RANGe {val}"")
        self.imp_autorange_enabled.get()

    def _get_complex_impedance(self) -> MeasurementPair:
        """"""
        Returns the impedance in the format of (R, X), where R is the
        resistance, and X is the reactance.
        """"""
        measurement = self.ask("":FETCH:IMPedance:CORRected?"")
        r, x = [float(n) for n in measurement.split("","")]
        measurement_pair = MeasurementPair(
            name=""RX"",
            names=(""resistance"", ""reactance""),
            units=(""Ohm"", ""Ohm"")
        )
        measurement_pair.set((r, x))
        return measurement_pair

    def _measurement(self) -> MeasurementPair:
        """"""
        Returns a measurement result with the selected measurement function.
        """"""
        measurement = self.ask("":FETCH:IMPedance:FORMatted?"")
        val1, val2, _ = [float(n) for n in measurement.split("","")]
        measurement_pair = MeasurementPair(
            name=self._measurement_pair.name,
            names=self._measurement_pair.names,
            units=self._measurement_pair.units
        )
        measurement_pair.set((val1, val2))
        return measurement_pair

    def _set_measurement(self,
                         measurement_pair: MeasurementPair) -> None:
        """"""
        Selects the measurement function.
        """"""
        self._measurement_pair = measurement_pair
        self.write(f"":FUNCtion:IMPedance {measurement_pair.name}"")

    def _get_voltage_level(self) -> float:
        """"""
        Gets voltage level if signal is set with voltage level parameter
        otherwise raises an error.
        """"""
        if self.signal_mode() == ""Current"":
            raise RuntimeError(""Cannot get voltage level as signal is set ""
                               ""with current level parameter."")

        v_level = self.ask("":VOLTage:LEVel?"")

        return float(v_level)

    def _set_voltage_level(self, val: str) -> None:
        """"""
        Sets voltage level
        """"""
        self.signal_mode(""Voltage"")
        self.voltage_level.snapshot_exclude = False
        self.current_level.snapshot_exclude = True

        self.write(f"":VOLTage:LEVel {val}"")

    def _set_current_level(self, val: str) -> None:
        """"""
        Sets current level
        """"""
        self.signal_mode(""Current"")
        self.voltage_level.snapshot_exclude = True
        self.current_level.snapshot_exclude = False

        self.write(f"":CURRent:LEVel {val}"")

    def _get_current_level(self) -> float:
        """"""
        Gets current level if signal is set with current level parameter
        otherwise raises an error.
        """"""
        if self.signal_mode() == ""Voltage"":
            raise RuntimeError(""Cannot get current level as signal is set ""
                               ""with voltage level parameter."")

        i_level = self.ask("":CURRent:LEVel?"")

        return float(i_level)

    def _is_signal_mode_voltage_on_driver_initialization(self) -> bool:
        """"""
        Checks if signal is set with voltage_level param at instrument driver
        initialization
        """"""
        assert self.signal_mode() is None
        try:
            self.voltage_level()
            return True
        except VisaIOError:
            return False

    def _set_signal_mode_on_driver_initialization(self) -> None:
        """"""
        Sets signal mode on driver initialization
        """"""
        if self._is_signal_mode_voltage_on_driver_initialization():
            self.signal_mode(""Voltage"")
            self.voltage_level.snapshot_exclude = False
            self.current_level.snapshot_exclude = True
        else:
            self.signal_mode(""Current"")
            self.voltage_level.snapshot_exclude = True
            self.current_level.snapshot_exclude = False

    def _options(self) -> Tuple[str, ...]:
        """"""
        Returns installed options numbers. Combinations of different installed
        options are possible. Two of the possible options are Power/DC Bias
        Enhance (option 001) and Bias Current Interface (option 002).
        """"""
        options_raw = self.ask('*OPT?')
        return tuple(options_raw.split(','))

    def system_errors(self) -> str:
        """"""
        Returns the oldest unread error message from the event log and removes
        it from the log.
        """"""
        return self.ask("":SYSTem:ERRor?"")

    def clear_status(self) -> None:
        """"""
        Clears the following:
            Error Queue
            Status Byte Register
            Standard Event Status Register
            Operation Status Event Register
            Questionable Status Event Register (No Query)
        """"""
        self.write('*CLS')

    def reset(self) -> None:
        """"""
        Resets the instrument settings.
        """"""
        self.write('*RST')
"
211,https://docs.zhinst.com/pdf/ziUHF_UserManual.pdf,https://en.wikipedia.org/wiki/Lock-in_amplifier,"[OrderedDict([('id', 'att081X3j2dpVqexI'), ('width', 1183), ('height', 387), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jvCyWBdWt84TKX_fjemZNg/RCIb9aJh7kJmmHMVy247ddVjY6P1nx49h02rAULlA_u757Xh2f6DQyD2hNwOl2tfr8o-fEJBT_B-vbmIvlJ75uEr7QtOQMdKobUrYIb23G0/FATCBrsPLTg7WW-Vo1hu_U8GvnBstErLIvjcLnBKLKw'), ('filename', 'UHFLI_persp_0.png.webp'), ('size', 23318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lCpn0XyzBEjeCPH1OBSeLw/Ls0P_rxUFAwzmF9TywSsxtSnHh3cfXBghVELgkLL64HXRjkv9eixq23qMaeabno1JIhBxMEQOZNzXV6gPiRBVD5At7yynuTMaUJRpSGr5Us/lmpx2KRv4-4v_jFQeDUz-Xtu8AOmCdbOmho79ss6Ots'), ('width', 110), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JXUCO1LOl-xjZ3vFNUo6jA/HiKEvq2xS7zje11RY2iWiZ_CVmI_Eff1uzCEa0x2oGsXmV3v4fBjZLtJ-0L-RiV-o3HxFtN-pt3CSSmMC37mdaxnowpUBFwfIizsBsceJ58/W-v-T87ZGVzqJGm366ysyEGwpFgN1kD-jWcvpYsqZuc'), ('width', 1183), ('height', 387)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nCABoY1Nt9tzfdhQXgGF_Q/zn4eeXXdqRxECAlF7MTezVv7u7kk34PTNEBSLEdMos6IoAEKpWOR5h0mBYuPN_9ly04s5DhrcyesFAs0cvHYWglQuCK8likjVRhldFz-P_c/QMWLiLmhCM2WUGYvUxr0BJXUZT-NKFR6wqj-RMk5-i0'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,The Zurich Instruments UHFLI is a digital lock-in amplifier that covers the frequency range from DC to 600 MHz. It offers a time constant of 30 ns for demodulation – resulting in a demodulation bandwidth that exceeds 5 MHz.,https://www.zhinst.com/americas/en/products/uhfli-lock-in-amplifier#introduction,Uhfli,648.0,['Lockin Amplifiers'],"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/uhfli.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.uhfli.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782615/Instruments/Lockin%20Amplifiers/UHFLI/UHFLI.webp,UHFLI,Write a Python script that uses Qcodes to connect to a UHFLI Lockin Amplifiers,,,,,"""""""Autogenerated module for the UHFLI QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWG(ZINode):
    """"""AWG node.

    This class implements the basic functionality for the device specific
    arbitrary waveform generator.
    Besides the upload/compilation of sequences it offers the upload of
    waveforms and command tables.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        session: Underlying session.
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        device_type: Device type
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, f""awg_{index}"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)


class UHFLI(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments UHFLI.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.awgs:

            channel_list = ZIChannelList(
                self,
                ""awgs"",
                AWG,
                zi_node=self._tk_object.awgs.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.awgs):
                channel_list.append(
                    AWG(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.awgs[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""awgs"", channel_list)
"
213,https://www.testequipmenthq.com/datasheets/KEITHLEY-2602-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attSsHSNBdjGWVb61'), ('width', 320), ('height', 145), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0rgZBISawtaxQ5XYMxMEcg/7beH_NLtM0juVky1ToscL8vCP0GzQjfU0ApwZYsdIpqac0mXiDGrWRYPqff_Ehv8v4qlzbh5DLBqt8xntSlLgAb9DtFUf-1y83Ue-vJiBrc/hhBhZG00tPxsxJKqdLwTbEenchuVnuQPme8FIBXUTsM'), ('filename', '2602b.webp'), ('size', 7334), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OuR3ecbmkhFOKmXxDEXncg/1ds3_lmWOl369hXGeznBJrAT6BvvnYrkUaj6yZU2wLFJaJf87EwG67HywvhaKxgjViaW-GdpmKNjmcoGv9QX_f-XWAznkccY3W_5LtOaZIY/D090bxOdwfLbofKlLQzz-6JQPsB9XbS2eBVVUoM9LlM'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6NixCqV2gd_9pcun_kFqAQ/t4NjHoJnGsyu2Jen2ouSrriKxJpO5H7F5ELVhaspVpH5pz-YsQewCOsPYbptPbvewvX9YWkY4Bb6iAuxazVqbsj1QZE5yfdzERl_HRpw-n8/g5Zd8rSLglo_P-Zrqd-e_xqjAiNwSnRIbxAQBa725vA'), ('width', 320), ('height', 145)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Tci_eDicHufcO0w6d9eXxg/6lNv4gNzW6lOCGGIDZ-XhC9fToqAR9WZk_PUqIIZpRngwiPzO24WfAsMwJNQqMsrJSRcEG7Q4cUXIeb_QAW1dvIfkvchAfmDesz88eeyNiA/BCilYYRvRI5YyrnfMUpfYmZmWpAzXksVfg6dnhrGjIg'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2602B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (3A DC, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",https://canada.newark.com/keithley/2602b/source-meter-voltage-current-40/dp/44W8034,Keithley 2602 B,246.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2602B.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2602B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782616/Instruments/Power%20Supplies/Keithley-2602B/Keithley-2602B.webp,Keithley 2602B,Write a Python script that uses Qcodes to connect to a Keithley 2602B Power Supplies,19738.0,,,,"from ._Keithley_2600 import Keithley2600


class Keithley2602B(Keithley2600):
    """"""
    QCoDeS driver for the Keithley 2602B Source-Meter
    """"""

    pass
"
218,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'att8A288bkAJo0O7a'), ('width', 600), ('height', 336), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qcN3qH3Flaw4P2wuZMyydw/92ncN3OrD81KBPI7q3Aq4C-ZMzmCVZZ6vPiRxxl_I3ZTWMoOalnNCFjlUYsd1DNgdWKB92m39z4S2LzpfinllcUM_SeHaNn4G1KU5uuuAcY/5mTPLVhxfJ4h5fECro6TunTnPcVCLBIDauoP3CeQnyE'), ('filename', 'agilent-34410a.jpg'), ('size', 171847), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hCqIS83Xbrs05ys8URTDtA/FfdBkFx-JFFWUzMb5htEbBvq7nNT6TWTu23lWxICUx6hGcVLCoGN75iAnMLII0u_oDdHp3iLUF4lhXM9b2xqTQ/m3qYQ9b7TudcjSdsWkBgf3DD7Ffz0-sK0iTNshYwH-U'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QJ3REfoN-ziAwUtpNpT-EA/cxxxwuFXPMPS5bkpMOauTu7wMZrFKEI_VRDnbL1OK6wI2vDxhuIqyFT3ax9LtLVjC1Sd6hcb1WvlXlOtY0ba5A/CutT75lnin-ZDt38rxGWgu7xEwy5z0uqvVM2Bf5hJsI'), ('width', 600), ('height', 336)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aoGncS7bk2zhs9IUUUfd8w/SJaxPghf4sCAA1EHwJbUCOWyZm29IvuP_x-uRj8GEVYw4Ibw0eNSDBtG77pkzVGy2jvcPoYFtHDRi9j_LKAWoQ/rRxWhmQ_kJgdNeSdYV9_tV6sk3M2UXpeXlXYGVnBq_E'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34411 A Submodules,271.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_34411A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34411A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782621/Instruments/Multimeters/Keysight-34411A-Submodules/Keysight-34411A-Submodules.jpg,Keysight 34411A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34411A Submodules Multimeters,,,True,,"from typing import Any
from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight_34411A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34411A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)
"
221,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'att0l8FCdLOBPIm2n'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EUTSK1Mp9x1-nu-A6pNUzQ/Ve9BaNfQ5nu2k2jWtscf1Qzz8VAFbMSQ2qvJtIPgCFKp2yMKveR-uNSgkmoR5I83v2WCQTsqsjTKMMNRzdEsQGySSWXIupo7rJmUdYhS7xk/XLp-7bfMowKMGZGiYH8xdDBRHOwpw6irl-aICgJsvfA'), ('filename', 'PL601P-1000px.jpg'), ('size', 159089), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PgkQrj93_ePy11YZx3iG7A/S_0JHn5xjdx4gddT11GVbo5-HWnhLT5uBaGNMULy9XgKcHcYZjdIYEy1OamTf5_xWHuX0IPtR8xyAIoNh92bdQ/tE6sv-eraG7ntq6znUTJyWpy6_8BjWbqJsDKeXPKB-Q'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2snjz7H8kFKMlTeVOOVbeA/IkR1UBBA1HXjGw2EsWVSklcHsyeQstosV8enXjfvrlxxW8NEv32POgqZe_AspWlImQC0BoTCOHqWRwyOj3y9Hw/W0P4OZZv-uCkzEAAUDmYor8iRd5zUZBq_DSS3BegGG4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9AC_5votHkLLtEBYYZo_Bw/4bwleEKNduBFmlhCHjWHTV3syZCKfg0Pqz_G7ARRjEB2mIvL0RjYxEfHZuqzhAPQzPxO42RhFgbyXHoiW2QNlQ/zxJ5EmuRS5xkIafaD06TLKbITI_fVYn14GFjVMCQkMY'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Single Output, 60V/1.5A, USB, RS232 & LAN Interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 601 P,46.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL601,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782624/Instruments/Power%20Supplies/PL601-P/PL601-P.jpg,PL601-P,Write a Python script that uses Qcodes to connect to a PL601-P Power Supplies,700.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
222,http://www.americanmagnetics.com/brochures/model430.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attSCyZigpnKCLrdu'), ('width', 495), ('height', 102), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CNkvGvyIMgI9jcaCx7Cbzw/98jIR6MkdgTibaHW36Kl_e1Gt-Y6rkE0DsWWJCQk9tYxRGohZAVlkCTgixiEPqdzCuCFyvThHrOpcKL_C2sUTR10jUQqFdyfYsgXuCmGKJA/2FubBmGT6ZHT0cNHHrqvuEa8Kamhr7tBi6qUJnOKBFM'), ('filename', 'AMi430.jpeg'), ('size', 10117), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZEG5rJ_Udc8fQ_WOE-AEBA/GS02ORo1NseAlnDvFTkFnyfcsaaDRtUcfVFM9Z8COGgK7NcOhHEx-6qDN9dQ4lyMQnxNhFgFkCulXb2oeVOBVg/oUVZPagXK1atMJarBKnh1G5tid_fG8mRvKblaHg_P58'), ('width', 175), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fZNMI5u29GyXmyX2Ph-P0w/mxz4zGi7ysoPTdu5H5LadY_GlSEoXipjQ2-HEyaLo_yB_i7r1fS4qiNBnOMQNhOqCqs5COA9dDEhW5CUjh-OlQ/B85k0v8zJGUk9mhVhCAp6TkvnlTe8IE5eo2A5KXOEXs'), ('width', 495), ('height', 102)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aBN0X9CMbHLJWtqnGV77Eg/IBLBwx3i6ZNuUQgwWLQUgr0j_VDZdraM1X1swF3kPVCegbBmDi_FnKwX-e5h79-VKVr304C8la0ELbYHAuB9rQ/sfVoyLpLENzD27N69r9sAlI2WZQ0C6_GZUgi9qqUuY0'), ('width', 3000), ('height', 3000)]))]))])]",13.0,US,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116694/Instruments/Vendor%20Logos/American_Magnetic.png,The AMI Model 430 Power Supply Programmer is a sophisticated digital power supply controller that allows an operator to manage a superconducting magnet system with unprecedented accuracy and ease.,http://www.americanmagnetics.com/brochures/model430.pdf,AMI 430,66.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. 
","American Magnetics - Excellence in Magnetics and Cryogenics, since 1968
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/american_magnetics/AMI430.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/American_magnetics.html#qcodes.instrument_drivers.american_magnetics.AMIModel430,American Magnetics,"[OrderedDict([('id', 'attDjjOcnpupvKnu5'), ('width', 561), ('height', 90), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Rjizxy1i7R46iBr_tx6O3w/bD5BiVhgrEOIDrNH6PQsy7243N5_d3qp-MKupjw979LlaH2lPjZhtqM-fYKyCsrpQhCYQg7W4QDUjtsF3Py0aA/y2WG3ui_1D5hZ4KeuN6ITkUXc-aJbXXPqVt-xtW6wvQ'), ('filename', 'AMi.jpeg'), ('size', 10167), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kniv8HVbsj5scho_M-BCNw/I7tgKDGYyDKtuk18nqmXIE-RR58dwbNB3L3UeZwD413YdDwdoeF10ZUQW9CUP1mDOv6XZfVzy2jhPaSGchLMzA/s8pw8YYzjnqVvWFsLA03p5JU_qivg94DaY5Y6BPRt58'), ('width', 224), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Xixa7RlvDrz9CMRTWPmFiA/lolCA5BGs0pcTq6mFvrLyjSTxIrdi-8qL-3i18g5kaPvnagDPf8R8s2CGAwqGGi15T7TaeTDeY0k6rBhHHFcYA/zIoQH9JScFxJe1CYOkG_OCupqcsfIkCaNVXobH1zl_8'), ('width', 561), ('height', 90)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/661Y6ARZqN42l1skKv_meg/16tBb939pkoc-l0RnY8qaLjjCbiogm6Rk3lBfyo3zOG9y3kxCS3xTavDKTWs6YmW82SbfWw80mGGry1u5kSzyQ/WWu2LP_K9a64ArmvPv9RXSwLimRDEY4RReW-Ueab40c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.americanmagnetics.com/index.php,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782624/Instruments/Power%20Supplies/AMI-430/AMI-430.jpg,AMI 430,Write a Python script that uses Qcodes to connect to a AMI 430 Power Supplies,,"
",,,"from __future__ import annotations

import collections.abc
import logging
import numbers
import time
import warnings
from collections import defaultdict
from collections.abc import Iterable, Sequence
from contextlib import ExitStack
from functools import partial
from typing import Any, Callable, TypeVar, cast

import numpy as np

from qcodes.instrument import Instrument, InstrumentChannel, IPInstrument
from qcodes.math_utils import FieldVector
from qcodes.parameters import Parameter
from qcodes.utils import QCoDeSDeprecationWarning
from qcodes.validators import Anything, Bool, Enum, Ints, Numbers

log = logging.getLogger(__name__)

CartesianFieldLimitFunction = Callable[[float, float, float], bool]

T = TypeVar('T')


class AMI430Exception(Exception):
    pass


class AMI430Warning(UserWarning):
    pass


class AMI430SwitchHeater(InstrumentChannel):
    class _Decorators:
        @classmethod
        def check_enabled(cls, f: Callable[..., T]) -> Callable[..., T]:
            def check_enabled_decorator(
                self: AMI430SwitchHeater, *args: Any, **kwargs: Any
            ) -> T:
                if not self.check_enabled():
                    raise AMI430Exception(""Switch not enabled"")
                return f(self, *args, **kwargs)
            return check_enabled_decorator

    def __init__(self, parent: AMI430) -> None:
        super().__init__(parent, ""SwitchHeater"")

        # Add state parameters
        self.add_parameter('enabled',
                           label='Switch Heater Enabled',
                           get_cmd=self.check_enabled,
                           set_cmd=lambda x: (self.enable() if x
                                              else self.disable()),
                           vals=Bool())
        self.add_parameter('state',
                           label='Switch Heater On',
                           get_cmd=self.check_state,
                           set_cmd=lambda x: (self.on() if x
                                              else self.off()),
                           vals=Bool())
        self.add_parameter('in_persistent_mode',
                           label='Persistent Mode',
                           get_cmd=""PERS?"",
                           val_mapping={True: 1, False: 0})

        # Configuration Parameters
        self.add_parameter('current',
                           label='Switch Heater Current',
                           unit='mA',
                           get_cmd='PS:CURR?',
                           get_parser=float,
                           set_cmd='CONF:PS:CURR {}',
                           vals=Numbers(0, 125))
        self.add_parameter('heat_time',
                           label='Heating Time',
                           unit='s',
                           get_cmd='PS:HTIME?',
                           get_parser=int,
                           set_cmd='CONF:PS:HTIME {}',
                           vals=Ints(5, 120))
        self.add_parameter('cool_time',
                           label='Cooling Time',
                           unit='s',
                           get_cmd='PS:CTIME?',
                           get_parser=int,
                           set_cmd='CONF:PS:CTIME {}',
                           vals=Ints(5, 3600))

    def disable(self) -> None:
        """"""Turn measurement off""""""
        self.write('CONF:PS 0')
        self._enabled = False

    def enable(self) -> None:
        """"""Turn measurement on""""""
        self.write('CONF:PS 1')
        self._enabled = True

    def check_enabled(self) -> bool:
        return bool(int(self.ask('PS:INST?').strip()))

    @_Decorators.check_enabled
    def on(self) -> None:
        self.write(""PS 1"")
        while self._parent.ramping_state() == ""heating switch"":
            self._parent._sleep(0.5)

    @_Decorators.check_enabled
    def off(self) -> None:
        self.write(""PS 0"")
        while self._parent.ramping_state() == ""cooling switch"":
            self._parent._sleep(0.5)

    @_Decorators.check_enabled
    def check_state(self) -> bool:
        return bool(int(self.ask(""PS?"").strip()))


class AMI430(IPInstrument):
    """"""
    Driver for the American Magnetics Model 430 magnet power supply programmer.

    This class controls a single magnet power supply. In order to use two or
    three magnets simultaneously to set field vectors, first instantiate the
    individual magnets using this class and then pass them as arguments to
    either the AMI430_2D or AMI430_3D virtual instrument classes.

    Args:
        name: a name for the instrument
        address: IP address of the power supply programmer
        current_ramp_limit: A current ramp limit, in units of A/s
    """"""
    _SHORT_UNITS = {'seconds': 's', 'minutes': 'min',
                    'tesla': 'T', 'kilogauss': 'kG'}
    _DEFAULT_CURRENT_RAMP_LIMIT = 0.06  # [A/s]

    def __init__(
        self,
        name: str,
        address: str,
        port: int | None = None,
        reset: bool = False,
        terminator: str = ""\r\n"",
        current_ramp_limit: float | None = None,
        **kwargs: Any,
    ):
        if ""has_current_rating"" in kwargs.keys():
            warnings.warn(
                ""'has_current_rating' kwarg to AMI430 ""
                ""is deprecated and has no effect"",
                category=QCoDeSDeprecationWarning)
            kwargs.pop(""has_current_rating"")

        super().__init__(name, address, port, terminator=terminator,
                         write_confirmation=False, **kwargs)
        self._parent_instrument = None

        # Add reset function
        self.add_function('reset', call_cmd='*RST')
        if reset:
            self.reset()

        # Add parameters setting instrument units
        self.add_parameter(""ramp_rate_units"",
                           get_cmd='RAMP:RATE:UNITS?',
                           set_cmd=(lambda units:
                                    self._update_units(ramp_rate_units=units)),
                           val_mapping={'seconds': 0,
                                        'minutes': 1})
        self.add_parameter('field_units',
                           get_cmd='FIELD:UNITS?',
                           set_cmd=(lambda units:
                                    self._update_units(field_units=units)),
                           val_mapping={'kilogauss': 0,
                                        'tesla': 1})

        # Set programmatic safety limits
        self.add_parameter('current_ramp_limit',
                           get_cmd=lambda: self._current_ramp_limit,
                           set_cmd=self._update_ramp_rate_limit,
                           unit=""A/s"")
        self.add_parameter('field_ramp_limit',
                           get_cmd=lambda: self.current_ramp_limit(),
                           set_cmd=lambda x: self.current_ramp_limit(x),
                           scale=1/float(self.ask(""COIL?"")),
                           unit=""T/s"")
        if current_ramp_limit is None:
            self._update_ramp_rate_limit(AMI430._DEFAULT_CURRENT_RAMP_LIMIT,
                                         update=False)
        else:
            self._update_ramp_rate_limit(current_ramp_limit, update=False)

        # Add solenoid parameters
        self.add_parameter('coil_constant',
                           get_cmd=self._update_coil_constant,
                           set_cmd=self._update_coil_constant,
                           vals=Numbers(0.001, 999.99999))

        self.add_parameter('current_limit',
                           unit=""A"",
                           set_cmd=""CONF:CURR:LIMIT {}"",
                           get_cmd='CURR:LIMIT?',
                           get_parser=float,
                           vals=Numbers(0, 80))  # what are good numbers here?

        self.add_parameter('field_limit',
                           set_cmd=self.current_limit.set,
                           get_cmd=self.current_limit.get,
                           scale=1/float(self.ask(""COIL?"")))

        # Add current solenoid parameters
        # Note that field is validated in set_field
        self.add_parameter('field',
                           get_cmd='FIELD:MAG?',
                           get_parser=float,
                           set_cmd=self.set_field)
        self.add_parameter('ramp_rate',
                           get_cmd=self._get_ramp_rate,
                           set_cmd=self._set_ramp_rate)
        self.add_parameter('setpoint',
                           get_cmd='FIELD:TARG?',
                           get_parser=float)
        self.add_parameter('is_quenched',
                           get_cmd='QU?',
                           val_mapping={True: 1, False: 0})
        self.add_function('reset_quench', call_cmd='QU 0')
        self.add_function('set_quenched', call_cmd='QU 1')
        self.add_parameter('ramping_state',
                           get_cmd='STATE?',
                           get_parser=int,
                           val_mapping={
                               'ramping': 1,
                               'holding': 2,
                               'paused': 3,
                               'manual up': 4,
                               'manual down': 5,
                               'zeroing current': 6,
                               'quench detected': 7,
                               'at zero current': 8,
                               'heating switch': 9,
                               'cooling switch': 10,
                           })
        self.add_parameter('ramping_state_check_interval',
                           initial_value=0.05,
                           unit=""s"",
                           vals=Numbers(0, 10),
                           set_cmd=None)

        # Add persistent switch
        switch_heater = AMI430SwitchHeater(self)
        self.add_submodule(""switch_heater"", switch_heater)

        # Add interaction functions
        self.add_function('get_error', call_cmd='SYST:ERR?')
        self.add_function('ramp', call_cmd='RAMP')
        self.add_function('pause', call_cmd='PAUSE')
        self.add_function('zero', call_cmd='ZERO')

        # Correctly assign all units
        self._update_units()

        self.connect_message()

    def _sleep(self, t: float) -> None:
        """"""
        Sleep for a number of seconds t. If we are or using
        the PyVISA 'sim' backend, omit this
        """"""

        simmode = getattr(self, 'visabackend', False) == 'sim'

        if simmode:
            return
        else:
            time.sleep(t)

    def _can_start_ramping(self) -> bool:
        """"""
        Check the current state of the magnet to see if we can start ramping
        """"""
        if self.is_quenched():
            logging.error(__name__ + ': Could not ramp because of quench')
            return False

        if self.switch_heater.in_persistent_mode():
            logging.error(__name__ + ': Could not ramp because persistent')
            return False

        state = self.ramping_state()
        if state == 'ramping':
            # If we don't have a persistent switch, or it's warm
            if not self.switch_heater.enabled():
                return True
            elif self.switch_heater.state():
                return True
        elif state in ['holding', 'paused', 'at zero current']:
            return True

        logging.error(__name__ + f': Could not ramp, state: {state}')
        return False

    def set_field(self,
                  value: float,
                  *,
                  block: bool = True,
                  perform_safety_check: bool = True) -> None:
        """"""
        Ramp to a certain field

        Args:
            value: Value to ramp to.
            block: Whether to wait unit the field has finished setting
            perform_safety_check: Whether to set the field via a parent
                driver (if present), which might perform additional safety
                checks.
        """"""
        # Check we aren't violating field limits
        field_lim = float(self.ask(""COIL?""))*self.current_limit()
        if np.abs(value) > field_lim:
            msg = 'Aborted _set_field; {} is higher than limit of {}'
            raise ValueError(msg.format(value, field_lim))

        # If part of a parent driver, set the value using that driver
        if self._parent_instrument is not None and perform_safety_check:
            self._parent_instrument._request_field_change(self, value)
            return

        # Check we can ramp
        if not self._can_start_ramping():
            raise AMI430Exception(f""Cannot ramp in current state: ""
                                  f""state is {self.ramping_state()}"")

        # Then, do the actual ramp
        self.pause()
        # Set the ramp target
        self.write(f'CONF:FIELD:TARG {value}')

        # If we have a persistent switch, make sure it is resistive
        if self.switch_heater.enabled():
            if not self.switch_heater.state():
                raise AMI430Exception(""Switch heater is not on"")
        self.ramp()

        # Check if we want to block
        if not block:
            return

        # Otherwise, wait until no longer ramping
        self.log.debug(f'Starting blocking ramp of {self.name} to {value}')
        exit_state = self.wait_while_ramping()
        self.log.debug(""Finished blocking ramp"")
        # If we are now holding, it was successful
        if exit_state != 'holding':
            msg = '_set_field({}) failed with state: {}'
            raise AMI430Exception(msg.format(value, exit_state))

    def wait_while_ramping(self) -> str:

        while self.ramping_state() == 'ramping':
            self._sleep(self.ramping_state_check_interval())

        return self.ramping_state()

    def _get_ramp_rate(self) -> float:
        """""" Return the ramp rate of the first segment in Tesla per second """"""
        results = self.ask('RAMP:RATE:FIELD:1?').split(',')
        return float(results[0])

    def _set_ramp_rate(self, rate: float) -> None:
        """""" Set the ramp rate of the first segment in Tesla per second """"""
        if rate > self.field_ramp_limit():
            raise ValueError(f""{rate} {self.ramp_rate.unit} ""
                             f""is above the ramp rate limit of ""
                             f""{self.field_ramp_limit()} ""
                             f""{self.field_ramp_limit()}"")
        self.write('CONF:RAMP:RATE:SEG 1')
        self.write(f'CONF:RAMP:RATE:FIELD 1,{rate},0')

    def _connect(self) -> None:
        """"""
        Append the IPInstrument connect to flush the welcome message of the AMI
        430 programmer
        :return: None
        """"""
        super()._connect()
        self.flush_connection()

    def _update_ramp_rate_limit(self,
                                new_current_rate_limit: float,
                                update: bool = True) -> None:
        """"""
        Update the maximum current ramp rate
        The value passed here is scaled by the units set in
        self.ramp_rate_units
        """"""
        # Update ramp limit
        self._current_ramp_limit = new_current_rate_limit
        # And update instrument limits
        if update:
            field_ramp_limit = self.field_ramp_limit()
            if self.ramp_rate() > field_ramp_limit:
                self.ramp_rate(field_ramp_limit)

    def _update_coil_constant(self, new_coil_constant: float | None = None) -> float:
        """"""
        Update the coil constant and relevant scaling factors.
        If new_coil_constant is none, query the coil constant from the
        instrument
        """"""
        # Query coil constant from instrument
        if new_coil_constant is None:
            new_coil_constant = float(self.ask(""COIL?""))
        else:
            self.write(f""CONF:COIL {new_coil_constant}"")

        # Update scaling factors
        self.field_ramp_limit.scale = 1/new_coil_constant
        self.field_limit.scale = 1/new_coil_constant

        # Return new coil constant
        return new_coil_constant

    def _update_units(
        self, ramp_rate_units: int | None = None, field_units: int | None = None
    ) -> None:
        # Get or set units on device
        if ramp_rate_units is None:
            ramp_rate_units_int: str = self.ramp_rate_units()
        else:
            self.write(f""CONF:RAMP:RATE:UNITS {ramp_rate_units}"")
            ramp_rate_units_int = self.ramp_rate_units.\
                inverse_val_mapping[ramp_rate_units]
        if field_units is None:
            field_units_int: str = self.field_units()
        else:
            self.write(f""CONF:FIELD:UNITS {field_units}"")
            field_units_int = self.field_units.inverse_val_mapping[field_units]

        # Map to shortened unit names
        ramp_rate_units_short = AMI430._SHORT_UNITS[ramp_rate_units_int]
        field_units_short = AMI430._SHORT_UNITS[field_units_int]

        # And update all units
        self.coil_constant.unit = f""{field_units_short}/A""
        self.field_limit.unit = f""{field_units_short}""
        self.field.unit = f""{field_units_short}""
        self.setpoint.unit = f""{field_units_short}""
        self.ramp_rate.unit = f""{field_units_short}/{ramp_rate_units_short}""
        self.current_ramp_limit.unit = f""A/{ramp_rate_units_short}""
        self.field_ramp_limit.unit = f""{field_units_short}/{ramp_rate_units_short}""

        # And update scaling factors
        # Note: we don't update field_ramp_limit scale as it redirects
        #       to ramp_rate_limit; we don't update ramp_rate units as
        #       the instrument stores changed units
        if ramp_rate_units_short == ""min"":
            self.current_ramp_limit.scale = 1/60
        else:
            self.current_ramp_limit.scale = 1

        # If the field units change, the value of the coil constant also
        # changes, hence we read the new value of the coil constant from the
        # instrument via the `coil_constant` parameter (which in turn also
        # updates settings of some parameters due to the fact that the coil
        # constant changes)
        self.coil_constant()


class AMI430_3D(Instrument):
    def __init__(
        self,
        name: str,
        instrument_x: AMI430 | str,
        instrument_y: AMI430 | str,
        instrument_z: AMI430 | str,
        field_limit: float | Iterable[CartesianFieldLimitFunction],
        **kwargs: Any,
    ):
        """"""
        Driver for controlling three American Magnetics Model 430 magnet power
        supplies simultaneously for setting magnetic field vectors.

        The individual magnet power supplies can be passed in as either
        instances of AMI430 driver or as names of existing AMI430 instances.
        In the latter case, the instances will be found via the passed names.

        Args:
            name: a name for the instrument
            instrument_x: AMI430 instance or a names of existing AMI430
                instance for controlling the X axis of magnetic field
            instrument_y: AMI430 instance or a names of existing AMI430
                instance for controlling the Y axis of magnetic field
            instrument_z: AMI430 instance or a names of existing AMI430
                instance for controlling the Z axis of magnetic field
            field_limit: a number for maximum allows magnetic field or an
                iterable of callable field limit functions that define
                region(s) of allowed values in 3D magnetic field space
        """"""
        super().__init__(name, **kwargs)

        if not isinstance(name, str):
            raise ValueError(""Name should be a string"")

        for instrument, arg_name in zip(
                (instrument_x, instrument_y, instrument_z),
                (""instrument_x"", ""instrument_y"", ""instrument_z""),
        ):
            if not isinstance(instrument, (AMI430, str)):
                raise ValueError(
                    f""Instruments need to be instances of the class AMI430 ""
                    f""or be valid names of already instantiated instances ""
                    f""of AMI430 class; {arg_name} argument is ""
                    f""neither of those""
                )

        def find_ami430_with_name(ami430_name: str) -> AMI430:
            found_ami430 = AMI430.find_instrument(
                name=ami430_name, instrument_class=AMI430
            )
            return found_ami430

        self._instrument_x = (
            instrument_x if isinstance(instrument_x, AMI430)
            else find_ami430_with_name(instrument_x)
        )
        self._instrument_y = (
            instrument_y if isinstance(instrument_y, AMI430)
            else find_ami430_with_name(instrument_y)
        )
        self._instrument_z = (
            instrument_z if isinstance(instrument_z, AMI430)
            else find_ami430_with_name(instrument_z)
        )

        self._field_limit: float | Iterable[CartesianFieldLimitFunction]
        if isinstance(field_limit, collections.abc.Iterable):
            self._field_limit = field_limit
        elif isinstance(field_limit, numbers.Real):
            # Conversion to float makes related driver logic simpler
            self._field_limit = float(field_limit)
        else:
            raise ValueError(""field limit should either be a number or ""
                             ""an iterable of callable field limit functions."")

        self._set_point = FieldVector(
            x=self._instrument_x.field(),
            y=self._instrument_y.field(),
            z=self._instrument_z.field()
        )

        # Get-only parameters that return a measured value
        self.add_parameter(
            'cartesian_measured',
            get_cmd=partial(self._get_measured, 'x', 'y', 'z'),
            unit='T'
        )

        self.add_parameter(
            'x_measured',
            get_cmd=partial(self._get_measured, 'x'),
            unit='T'
        )

        self.add_parameter(
            'y_measured',
            get_cmd=partial(self._get_measured, 'y'),
            unit='T'
        )

        self.add_parameter(
            'z_measured',
            get_cmd=partial(self._get_measured, 'z'),
            unit='T'
        )

        self.add_parameter(
            'spherical_measured',
            get_cmd=partial(
                self._get_measured,
                'r',
                'theta',
                'phi'
            ),
            unit='T'
        )

        self.add_parameter(
            'phi_measured',
            get_cmd=partial(self._get_measured, 'phi'),
            unit='deg'
        )

        self.add_parameter(
            'theta_measured',
            get_cmd=partial(self._get_measured, 'theta'),
            unit='deg'
        )

        self.add_parameter(
            'field_measured',
            get_cmd=partial(self._get_measured, 'r'),
            unit='T')

        self.add_parameter(
            'cylindrical_measured',
            get_cmd=partial(self._get_measured,
                            'rho',
                            'phi',
                            'z'),
            unit='T')

        self.add_parameter(
            'rho_measured',
            get_cmd=partial(self._get_measured, 'rho'),
            unit='T'
        )

        # Get and set parameters for the set points of the coordinates
        self.add_parameter(
            'cartesian',
            get_cmd=partial(self._get_setpoints, ('x', 'y', 'z')),
            set_cmd=partial(self._set_setpoints, ('x', 'y', 'z')),
            unit='T',
            vals=Anything()
        )

        self.add_parameter(
            'x',
            get_cmd=partial(self._get_setpoints, ('x',)),
            set_cmd=partial(self._set_setpoints, ('x',)),
            unit='T',
            vals=Numbers()
        )

        self.add_parameter(
            'y',
            get_cmd=partial(self._get_setpoints, ('y',)),
            set_cmd=partial(self._set_setpoints, ('y',)),
            unit='T',
            vals=Numbers()
        )

        self.add_parameter(
            'z',
            get_cmd=partial(self._get_setpoints, ('z',)),
            set_cmd=partial(self._set_setpoints, ('z',)),
            unit='T',
            vals=Numbers()
        )

        self.add_parameter(
            'spherical',
            get_cmd=partial(
                self._get_setpoints, ('r', 'theta', 'phi')
            ),
            set_cmd=partial(
                self._set_setpoints, ('r', 'theta', 'phi')
            ),
            unit='tuple?',
            vals=Anything()
        )

        self.add_parameter(
            'phi',
            get_cmd=partial(self._get_setpoints, ('phi',)),
            set_cmd=partial(self._set_setpoints, ('phi',)),
            unit='deg',
            vals=Numbers()
        )

        self.add_parameter(
            'theta',
            get_cmd=partial(self._get_setpoints, ('theta',)),
            set_cmd=partial(self._set_setpoints, ('theta',)),
            unit='deg',
            vals=Numbers()
        )

        self.add_parameter(
            'field',
            get_cmd=partial(self._get_setpoints, ('r',)),
            set_cmd=partial(self._set_setpoints, ('r',)),
            unit='T',
            vals=Numbers()
        )

        self.add_parameter(
            'cylindrical',
            get_cmd=partial(
                self._get_setpoints, ('rho', 'phi', 'z')
            ),
            set_cmd=partial(
                self._set_setpoints, ('rho', 'phi', 'z')
            ),
            unit='tuple?',
            vals=Anything()
        )

        self.add_parameter(
            'rho',
            get_cmd=partial(self._get_setpoints, ('rho',)),
            set_cmd=partial(self._set_setpoints, ('rho',)),
            unit='T',
            vals=Numbers()
        )

        self.add_parameter(
            'block_during_ramp',
            set_cmd=None,
            initial_value=True,
            unit='',
            vals=Bool()
        )

        self.ramp_mode = Parameter(
            name=""ramp_mode"",
            instrument=self,
            get_cmd=None,
            set_cmd=None,
            vals=Enum(""default"", ""simultaneous""),
            initial_value=""default"",
        )

        self.ramping_state_check_interval = Parameter(
            name=""ramping_state_check_interval"",
            instrument=self,
            initial_value=0.05,
            unit=""s"",
            vals=Numbers(0, 10),
            set_cmd=None,
            get_cmd=None,
        )

        self.vector_ramp_rate = Parameter(
            name=""vector_ramp_rate"",
            instrument=self,
            unit=""T/s"",
            vals=Numbers(min_value=0.0),
            set_cmd=None,
            get_cmd=None,
            set_parser=self._set_vector_ramp_rate_units,
            docstring=""Ramp rate along a line (vector) in 3D space. Only active""
                      "" if `ramp_mode='simultaneous'`.""
        )
        """"""Ramp rate along a line (vector) in 3D field space""""""

        self._exit_stack = ExitStack()

    def get_idn(self) -> dict[str, str | None]:
        idparts = [""American Magnetics"", self.name, None, None]
        return dict(zip((""vendor"", ""model"", ""serial"", ""firmware""), idparts))

    def _set_vector_ramp_rate_units(self, val: float) -> float:
        _, common_ramp_rate_units = self._raise_if_not_same_field_and_ramp_rate_units()
        self.vector_ramp_rate.unit = common_ramp_rate_units
        return val

    def ramp_simultaneously(self, setpoint: FieldVector, duration: float) -> None:
        """"""
        Ramp all axes simultaneously to the given setpoint and in the given time

        The method calculates and sets the required ramp rates per magnet
        axis, and then initiates a ramp simultaneously on all the axes. The
        trajectory of the tip of the magnetic field vector is thus linear in
        3D space, from the current field value to the setpoint.

        If ``block_during_ramp`` parameter is ``True``, the method will block
        until all axes finished ramping.

        If ``block_during_ramp`` parameter is ``True``, the ramp rates of
        individual magnet axes will be restored after the end of the
        ramp to their original values before the call of this method. If
        ``block_during_ramp`` parameter is ``False``, call the
        ``wait_while_all_axes_ramping`` method when needed to restore the
        ramp rates of the individual magnet axes.

        It is required for all axis instruments to have the same units for
        ramp rate and field, otherwise an exception is raised. The given
        setpoint and time are assumed to be in those common units.

        Args:
            setpoint: ``FieldVector`` setpoint
            duration: time in which the setpoint field has to be reached on all axes

        """"""
        (
            common_field_units,
            common_ramp_rate_units,
        ) = self._raise_if_not_same_field_and_ramp_rate_units()

        self.log.debug(
            f""Simultaneous ramp: setpoint {setpoint.repr_cartesian()} ""
            f""{common_field_units} in {duration} {common_ramp_rate_units}""
        )

        # Get starting field value

        start_field = self._get_measured_field_vector()
        self.log.debug(
            f""Simultaneous ramp: start {start_field.repr_cartesian()} ""
            f""{common_field_units}""
        )
        self.log.debug(
            f""Simultaneous ramp: delta {(setpoint - start_field).repr_cartesian()} ""
            f""{common_field_units}""
        )

        # Calculate new vector ramp rate based on time and setpoint

        vector_ramp_rate = self.calculate_vector_ramp_rate_from_duration(
            start=start_field, setpoint=setpoint, duration=duration
        )
        self.vector_ramp_rate(vector_ramp_rate)
        self.log.debug(
            f""Simultaneous ramp: new vector ramp rate for {self.full_name} ""
            f""is {vector_ramp_rate} {common_ramp_rate_units}""
        )

        # Launch the simultaneous ramp

        self.ramp_mode(""simultaneous"")
        self.cartesian(setpoint.get_components(""x"", ""y"", ""z""))

    @staticmethod
    def calculate_axes_ramp_rates_for(
        start: FieldVector, setpoint: FieldVector, duration: float
    ) -> tuple[float, float, float]:
        """"""
        Given starting and setpoint fields and expected ramp time calculates
        required ramp rates for x, y, z axes (in this order) where axes are
        ramped simultaneously.
        """"""
        vector_ramp_rate = AMI430_3D.calculate_vector_ramp_rate_from_duration(
            start, setpoint, duration
        )
        return AMI430_3D.calculate_axes_ramp_rates_from_vector_ramp_rate(
            start, setpoint, vector_ramp_rate
        )

    @staticmethod
    def calculate_vector_ramp_rate_from_duration(
        start: FieldVector, setpoint: FieldVector, duration: float
    ) -> float:
        return setpoint.distance(start) / duration

    @staticmethod
    def calculate_axes_ramp_rates_from_vector_ramp_rate(
        start: FieldVector, setpoint: FieldVector, vector_ramp_rate: float
    ) -> tuple[float, float, float]:
        delta_field = setpoint - start
        ramp_rate_3d = delta_field / delta_field.norm() * vector_ramp_rate
        return abs(ramp_rate_3d[""x""]), abs(ramp_rate_3d[""y""]), abs(ramp_rate_3d[""z""])

    def _raise_if_not_same_field_and_ramp_rate_units(self) -> tuple[str, str]:
        instruments = (self._instrument_x, self._instrument_y, self._instrument_z)

        field_units_of_instruments: defaultdict[str, set[str]] = defaultdict(set)
        ramp_rate_units_of_instruments: defaultdict[str, set[str]] = defaultdict(set)

        for instrument in instruments:
            ramp_rate_units_of_instruments[instrument.ramp_rate_units.cache.get()].add(
                instrument.full_name
            )
            field_units_of_instruments[instrument.field_units.cache.get()].add(
                instrument.full_name
            )

        if len(field_units_of_instruments) != 1:
            raise ValueError(
                f""Magnet axes instruments should have the same ""
                f""`field_units`, instead they have: ""
                f""{field_units_of_instruments}""
            )

        if len(ramp_rate_units_of_instruments) != 1:
            raise ValueError(
                f""Magnet axes instruments should have the same ""
                f""`ramp_rate_units`, instead they have: ""
                f""{ramp_rate_units_of_instruments}""
            )

        common_field_units = tuple(field_units_of_instruments.keys())[0]
        common_ramp_rate_units = tuple(ramp_rate_units_of_instruments.keys())[0]

        return common_field_units, common_ramp_rate_units

    def _verify_safe_setpoint(
        self, setpoint_values: tuple[float, float, float]
    ) -> bool:
        if isinstance(self._field_limit, (int, float)):
            return bool(np.linalg.norm(setpoint_values) < self._field_limit)

        answer = any([limit_function(*setpoint_values) for
                      limit_function in self._field_limit])

        return answer

    def _adjust_child_instruments(self, values: tuple[float, float, float]) -> None:
        """"""
        Set the fields of the x/y/z magnets. This function is called
        whenever the field is changed and performs several safety checks
        to make sure no limits are exceeded.

        Args:
            values: a tuple of cartesian coordinates (x, y, z).
        """"""
        self.log.debug(""Checking whether fields can be set"")

        # Check if exceeding the global field limit
        if not self._verify_safe_setpoint(values):
            raise ValueError(""_set_fields aborted; field would exceed limit"")

        # Check if the individual instruments are ready
        for name, value in zip([""x"", ""y"", ""z""], values):

            instrument = getattr(self, f""_instrument_{name}"")
            if instrument.ramping_state() == ""ramping"":
                msg = '_set_fields aborted; magnet {} is already ramping'
                raise AMI430Exception(msg.format(instrument))

        # Now that we know we can proceed, call the individual instruments

        self.log.debug(""Field values OK, proceeding"")

        if self.ramp_mode() == ""simultaneous"":
            self._perform_simultaneous_ramp(values)
        else:
            self._perform_default_ramp(values)

    def _update_individual_axes_ramp_rates(
        self, values: tuple[float, float, float]
    ) -> None:
        if self.vector_ramp_rate() is None or self.vector_ramp_rate() == 0:
            raise ValueError('The value of the `vector_ramp_rate` Parameter is '
                             'currently None or 0. Set it to an appropriate '
                             'value to use the simultaneous ramping feature.')

        new_axes_ramp_rates = self.calculate_axes_ramp_rates_from_vector_ramp_rate(
            start=self._get_measured_field_vector(),
            setpoint=FieldVector(x=values[0], y=values[1], z=values[2]),
            vector_ramp_rate=self.vector_ramp_rate.get(),
        )
        instruments = (self._instrument_x, self._instrument_y, self._instrument_z)
        for instrument, new_axis_ramp_rate in zip(instruments, new_axes_ramp_rates):
            instrument.ramp_rate.set(new_axis_ramp_rate)
            self.log.debug(
                f""Simultaneous ramp: new rate for {instrument.full_name} ""
                f""is {new_axis_ramp_rate} {instrument.ramp_rate.unit}""
            )

    def _perform_simultaneous_ramp(self, values: tuple[float, float, float]) -> None:
        self._prepare_to_restore_individual_axes_ramp_rates()

        self._update_individual_axes_ramp_rates(values)

        axes = (self._instrument_x, self._instrument_y, self._instrument_z)

        for axis_instrument, value in zip(axes, values):
            current_actual = axis_instrument.field()

            # If the new set point is practically equal to the
            # current one then do nothing
            if np.isclose(value, current_actual, rtol=0, atol=1e-8):
                self.log.debug(
                    f""Simultaneous ramp: {axis_instrument.short_name} is ""
                    f""already at target field {value} ""
                    f""{axis_instrument.field.unit} ""
                    f""({current_actual} exactly)""
                )
                continue

            self.log.debug(
                f""Simultaneous ramp: setting {axis_instrument.short_name} ""
                f""target field to {value} {axis_instrument.field.unit}""
            )
            axis_instrument.set_field(value, perform_safety_check=False, block=False)

        if self.block_during_ramp() is True:
            self.log.debug(""Simultaneous ramp: blocking until ramp is finished"")
            self.wait_while_all_axes_ramping()
        else:
            self.log.debug(""Simultaneous ramp: not blocking until ramp is finished"")

        self.log.debug(""Simultaneous ramp: returning from the ramp call"")

    def _perform_default_ramp(self, values: tuple[float, float, float]) -> None:
        operators: tuple[Callable[[Any, Any], bool], ...] = (np.less, np.greater)
        for operator in operators:
            # First ramp the coils that are decreasing in field strength.
            # This will ensure that we are always in a safe region as
            # far as the quenching of the magnets is concerned
            for name, value in zip([""x"", ""y"", ""z""], values):

                instrument = getattr(self, f""_instrument_{name}"")
                current_actual = instrument.field()

                # If the new set point is practically equal to the
                # current one then do nothing
                if np.isclose(value, current_actual, rtol=0, atol=1e-8):
                    continue
                # evaluate if the new set point is smaller or larger
                # than the current value
                if not operator(abs(value), abs(current_actual)):
                    continue

                instrument.set_field(value, perform_safety_check=False,
                                     block=self.block_during_ramp.get())

    def _prepare_to_restore_individual_axes_ramp_rates(self) -> None:
        for instrument in (self._instrument_x, self._instrument_y, self._instrument_z):
            self._exit_stack.enter_context(instrument.ramp_rate.restore_at_exit())
        self._exit_stack.callback(
            self.log.debug,
            ""Restoring individual axes ramp rates"",
        )

    def wait_while_all_axes_ramping(self) -> None:
        """"""
        Wait and blocks as long as any magnet axis is ramping. After the
        ramping is finished, also resets the individual ramp rates of the
        magnet axes if those were made to be restored, e.g. by using
        ``simultaneous`` ramp mode.
        """"""
        while self.any_axis_is_ramping():
            self._instrument_x._sleep(self.ramping_state_check_interval.get())

        self._exit_stack.close()

    def any_axis_is_ramping(self) -> bool:
        """"""
        Returns True if any of the magnet axes are currently ramping, or False
        if none of the axes are ramping.
        """"""
        return any(
            axis_instrument.ramping_state() == ""ramping""
            for axis_instrument in (
                self._instrument_x,
                self._instrument_y,
                self._instrument_z,
            )
        )

    def pause(self) -> None:
        """""" Pause all magnet axes. """"""
        for axis_instrument in (self._instrument_x, self._instrument_y, self._instrument_z):
            axis_instrument.pause()

    def _request_field_change(self, instrument: AMI430, value: float) -> None:
        """"""
        This method is called by the child x/y/z magnets if they are set
        individually. It results in additional safety checks being
        performed by this 3D driver.
        """"""
        if instrument is self._instrument_x:
            self._set_x(value)
        elif instrument is self._instrument_y:
            self._set_y(value)
        elif instrument is self._instrument_z:
            self._set_z(value)
        else:
            msg = 'This magnet doesnt belong to its specified parent {}'
            raise NameError(msg.format(self))

    def _get_measured_field_vector(self) -> FieldVector:
        return FieldVector(
            x=self._instrument_x.field(),
            y=self._instrument_y.field(),
            z=self._instrument_z.field(),
        )

    def _get_measured(self, *names: str) -> float | list[float]:
        measured_field_vector = self._get_measured_field_vector()

        measured_values = measured_field_vector.get_components(*names)

        # Convert angles from radians to degrees
        d = dict(zip(names, measured_values))

        # Do not do ""return list(d.values())"", because then there is
        # no guaranty that the order in which the values are returned
        # is the same as the original intention
        value_list = [d[name] for name in names]

        if len(names) == 1:
            return_value: list[float] | float = value_list[0]
        else:
            return_value = value_list

        return return_value

    def _get_setpoints(self, names: Sequence[str]) -> float | list[float]:
        measured_values = self._set_point.get_components(*names)

        # Convert angles from radians to degrees
        d = dict(zip(names, measured_values))
        value_list = [d[name] for name in names]
        # Do not do ""return list(d.values())"", because then there is
        # no guarantee that the order in which the values are returned
        # is the same as the original intention

        if len(names) == 1:
            return_value: list[float] | float = value_list[0]
        else:
            return_value = value_list

        return return_value

    def _set_setpoints(
            self,
            names: Sequence[str],
            values: Sequence[float]
    ) -> None:

        kwargs = dict(zip(names, np.atleast_1d(values)))

        set_point = FieldVector()
        set_point.copy(self._set_point)
        if len(kwargs) == 3:
            set_point.set_vector(**kwargs)
        else:
            set_point.set_component(**kwargs)

        setpoint_values = cast(
            tuple[float, float, float], set_point.get_components(""x"", ""y"", ""z"")
        )
        self._adjust_child_instruments(setpoint_values)

        self._set_point = set_point
"
231,https://docs.zhinst.com/pdf/ziSHFQA_UserManual.pdf,https://www.zhinst.com/americas/en/products/shfqa-quantum-analyzer,"[OrderedDict([('id', 'att7OJNJrUZgJN1xR'), ('width', 1183), ('height', 425), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/m-7wGmty9_XVa92wZzfjtw/k7I_QH-h6XxjoLCfgHcFKdcNCUopYY2FXM2irwqtU5YOzehCh2I3Qa8kMJDSNVjYaOSHDMG2eGG21TtoD_DAr08j8ZLbEjL6TUcP-0YByQ9oLwooY-JzH6ml1gzrA6EJ/kLp2oa5uJbPtZf_0b0FLx2pkw-aJ5Y1ouk9QC3fACpc'), ('filename', 'SHFQA_schraeg_2800.jpg.webp'), ('size', 36126), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XsM_2SFQDahtHwtEe4ASFA/1Uk2R8d-INHS4AoBMz9Xghd-vmZCAGck-xakVjCKqDvikasExGEY5uEOks45wJcb9cdR1t40Wh2LzizYTtzRTH0StgQIrCWbEYT6r--Xzwk/5-fKSvPfNHPh6gqTElpEtqRmyUOSTQNh73cuV4fjEe8'), ('width', 100), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0hCFoOdltT_ifr6uPY4OYg/xC6yXH0qvyBmk9X-12RI6Ohw0_Cf9yFkP1xbn5_CRLhLQHbunvHQ7sISWbWdvWCVbc9d4GOJfXn62SHnU-R2y0wYgFMaaZ9jjQum2NBlFzo/4BuVARC0n3s6TdyNTHpbdTgD7RWa7wnphzJY8ua7ncE'), ('width', 1183), ('height', 425)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cbhwtWwB9If0_RMyq6SUaw/6oSE2v7VZe8BAmFBOsZFDdz1IG56-shMRmw1n0r_xd_wYfA6HWwyIq1xAh1inqBXdFFGKrLzMBe2ZCbyNtKlFq3srRSWb28I0sTLgji4KUw/ALMI-apTa0MkkqmvUiQwgcvDTPu8Y7DX9DynSorbrxs'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments SHFQA Quantum Analyzer integrates in a single instrument a full real-time readout setup for up to 64 superconducting and spin qubits. The SHFQA operates in a frequency range from 0.5 to 8.5 GHz with a clean analysis bandwidth of 1 GHz and without the need for mixer calibration. Each of its 2 or 4 readout channels can analyze up to 16 qubits, 8 qutrits or 5 ququads",https://www.zhinst.com/americas/en/products/shfqa-quantum-analyzer,Shfqa,644.0,['Quantum Analyzer'],"The SHFQA enables multi-state discrimination with optimal signal-to-noise ratio and minimal latency thanks to its advanced sequencer and its low-latency signal processing chain with matched filters and result correlation. The data are transmitted in real-time to other instruments for active qubit reset or global error correction protocols. Controlled through the LabOne software suite comprising the user interface, several APIs and LabOne Q, the SHFQA supports quantum computing projects with sizes ranging from a few to several hundreds of qubits.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqa.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfqa.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782631/Instruments/Quantum%20Analyzer/SHFQA/SHFQA.webp,SHFQA,Write a Python script that uses Qcodes to connect to a SHFQA Quantum Analyzer,,,,,"""""""Autogenerated module for the SHFQA QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import Sequence, Waveforms
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQA(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQA.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
232,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attTDYiHi8Rpe5jnV'), ('width', 3375), ('height', 1654), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PA42G-xQgkV9aI0I5t2u7A/9gO5H8IiZy22R-sYj0vIIku_1xjlbnFKhk7LNbbbXuNriGVYkxtKA4zDDf7RG0eXcjSMPB5UrErcXMRS-hWfVRcshJNLBkXYr9k26tZHauM/O9vdS9Ezkdb8iO17noKvrmz43V61tgiazzdGZBv082U'), ('filename', '5122197.jpg'), ('size', 372225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6tpJH2POUST4phifZWcjtg/GGOnuDEL-ZxPkEotl_aJ29639QFS8BomPQVvfaOCrZJiAYRfoIzSS2Zt87EEuvhMTKTM2vZ91ksv9Mvz57Vpkg/G_4OFI9qvuR0_K8nQlcjeCEGkc3bPRrmUyXSXURg2aQ'), ('width', 73), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/buFR8ltJy8Ukw2s0cns3HA/2cKR5CYY5mnO2PlBsYiglnqkd2sJkXDGDlA0M_4e8Yv8uMbi2QObiEjWgWkbRzliL6MuvOLtz9UzMAQA3w3dJQ/JnK26ltBbRoeI1H7-BnP9KQUG-bdNUWYbpjc0SWgvdE'), ('width', 1045), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_QaALiCZsHwQP4_LhzomQQ/bV1aQ10T7oBlwo3MM7w17QZesGg1a1CrRCPk5bAT5Ne1elkEraHBKrSwFQSX1qdR0MKFJLKV6njFNm38vYSl9A/olVRSvnYn6tvU-tiK2Nj5HFrgD9lTtUNHvCB6gQ4Kac'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34460 A Submodules,272.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_34411A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34460A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782632/Instruments/Multimeters/Keysight-34460A-Submodules/Keysight-34460A-Submodules.jpg,Keysight 34460A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34460A Submodules Multimeters,,,,,"from typing import Any
from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight_34411A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34411A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)
"
234,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attsXnQPDRocpX3ki'), ('width', 306), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JNFiUHJd2JVV8ZfgLuKL1w/BEHa5p4C_xukgz5ekTmmIELCtfWYn_A2nZzJaqbGTjogw0Pt3zPSLQ4yR0WVbbvW2kdFAmVigZfbC2POIx28pzYswALrQOTm0L0HtIZtjS0/gbLJEfHvYLm6rusvVGnK0JErb0FlgEpdw2gQ4DCUrSg'), ('filename', 'PH-DP821.jpg'), ('size', 32141), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/r99Zy5PNIDkYL0G0z8xwKw/XZ_TNWHYBptrFjwKh9uRri-wE7TG6tyoClpfK4gZK2bHg2cDR4x6lrJNLyH80lGLgqhS03Q5ahHgkZ0gheFHlw/-jYKoWXyVgByo5p7FDKfsBtc1ws20Mlqd-Lk0TCdKLA'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WL1ykDB8NkAr3p88EGHttw/PJGKSdlfnkWllQJIVK-9lN81J_iPceY3Hf_UJJstMyq7VZr5ZcDq9wDnTON4p_cevgsMLj2MvRc1Lq76PC1R3w/DlN6a20Lt9_9MJJW7BMZoZLlMXEH5VB58RJLN_nCSdo'), ('width', 306), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/skvpIQ37J99VVRwRKvKG2w/6in2QNAEfpcMkV-jzSrJPBIMTUXNR81vocGijv-U0g4BtNvyli1MZCrtb5KGwOt_t_A8ScmfS7YfaC5PSMVdVg/WyLbtewOGm9j6dwuGIgr3qtAaq6JPalSPZhhMkjiZxg'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"The Rigol DP821 is a dual channel, remote sense programmable DC Power Supply. It has excellent performance, including various analysis functions and has USB Host and Device with LXI option. All of this makes it suitable to meet a wide range of testing requirements.",https://www.lambdaphoto.co.uk/dp821-140w-dc-power-supply.html,DP 821,447.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP821.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP821,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782634/Instruments/Power%20Supplies/Rigol-DP821/Rigol-DP821.jpg,Rigol DP821,Write a Python script that uses Qcodes to connect to a Rigol DP821 Power Supplies,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP821(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP821(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [
            (60.0, 1.0),
            (8.0, 10.0),
        ]

        ovp_ranges_std = [(0.01, 66.0), (0.01, 8.8)]
        ocp_ranges_std = [(0.01, 1.1), (0.01, 11)]

        ovp_ranges_precision = [(0.001, 66.0), (0.001, 8.8)]
        ocp_ranges_precision = [(0.001, 1.1), (0.001, 11)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
236,https://www.keysight.com/us/en/assets/7018-04097/data-sheets/5991-3132.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attcBHJrJvHu6fqnl'), ('width', 800), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EYMwOX-Af5WsQr97tLgyiQ/_p4RWy5iaUQA16h2VPetRgGjKOxpJlAfnez-8DwRuvBjGKQfic464XVZcyWnjw8n0-xVgDvwVQSBRk5mCj0urcOj4eZ4hC15EilvVsStOjXlG--vH4vuirjabIAKpFV-sal-RhWv9rfQU0XStUUUonAd8eAqDA0FLW_FCus5KoC6NcoAhfZd1OmfQctKKBeH/g6HIXLbdkEO_xhLQIRNzKSC0zAEO1nVv9GFT96YEDCM'), ('filename', '0005557_keysight-n5173b-exg-x-series-microwave-analog-signal-generator.png'), ('size', 160786), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/slefxUP7yNIMjvPKOPIKsw/fz12smZNmlM0uXO1obHjyWRxTqZ5ZbW4v5FxXQIsx12ClXnlCMOlSNM1uDy6U79RntuhGFoYZndFUIM1gWkdqA/E8ZLTNyW5SzN56CT-oUjw83T0AlD1yTuBWZSXFx8UzE'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZZORyTxmZO3IQ11LIlVnHg/ftlDZcN627L3-yz0zFW_yi_EucniLD1-uAn6CHvFAdam-DRgsBgfAX-hQ8sVMvXrSShyo9uYIKLo4KNhiAjJmg/DBlZJqCPqeWCpIURbQK2fcxP8RY5fhHbAthKiUM_xHE'), ('width', 800), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/560vaupymKWmR7cwKmEesQ/-OW7hbQfmNCF51YOks1nx1-RwJNiIVyNKQPqTO3YmQ-zxnkr-d120_ZNrdO1gIoEE1VVzPUMqoPOQM0v-IrMpg/pvxOOk8tKW8bH5wmBL-xhpvArxoP_Jk7lUsOcoINN-A'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight N5173B EXG microwave analog signal generator is the cost-effective choice when you need to balance budget and performance. It provides the essential signals that address parametric testing of broadband filters, amplifiers, receivers, and more. Perform basic LO upconversion or CW blocking with low-cost coverage to 13, 20, 31.8, or 40 GHz. Characterize broadband microwave components such as filters and amplifiers with the best combination of output power (+20 dBm at 20 GHz), low harmonics (≤ –55 dBc), and full step attenuation. Use as a high-stability system reference with standard high-performance OCXO at an aging rate of less than ± 5 parts per billion per day.",https://www.keysight.com/us/en/product/N5173B/exg-x-series-microwave-analog-signal-generator-9-khz-40-ghz.html,Keysight N 5173 B,277.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N51x1.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5173B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782636/Instruments/RF%20Signal%20Generator/Keysight-N5173B-EXG/Keysight-N5173B-EXG.png,Keysight N5173B EXG,Write a Python script that uses Qcodes to connect to a Keysight N5173B EXG RF Signal Generator,37065.0,,,,"from typing import Any, Dict, Optional

from qcodes import VisaInstrument
from qcodes.utils.validators import Numbers


class N51x1(VisaInstrument):
    """"""
    This is the qcodes driver for Keysight/Agilent scalar RF sources.
    It has been tested with N5171B, N5181A, N5171B, N5183B
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=-144,max_value=19))

        # Query the instrument to see what frequency range was purchased
        freq_dict = {'501':1e9, '503':3e9, '505':6e9, '520':20e9}

        max_freq = freq_dict[self.ask('*OPT?')]
        self.add_parameter('frequency',
                           label='Frequency',
                           get_cmd='SOUR:FREQ?',
                           get_parser=float,
                           set_cmd='SOUR:FREQ {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=9e3,max_value=max_freq))

        self.add_parameter('phase_offset',
                           label='Phase Offset',
                           get_cmd='SOUR:PHAS?',
                           get_parser=float,
                           set_cmd='SOUR:PHAS {:.2f}',
                           unit='rad'
                           )

        self.add_parameter('rf_output',
                           get_cmd='OUTP:STAT?',
                           set_cmd='OUTP:STAT {}',
                           val_mapping={'on': 1, 'off': 0})

        self.connect_message()

    def get_idn(self) -> Dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: Dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN
"
237,https://www.keysight.com/us/en/assets/7018-06033/data-sheets/5992-2765.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attSzJiFgDoctjaFu'), ('width', 2000), ('height', 1072), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jlwh8WR6norLnXFAzmZqbg/wdUEaViG5r6XuGV2QKLiyloWB8UF70MOOnTICF6zKtEpSsRsWUb_5kUXpFMeWA8gqHJWpweWtoLZqdF-8TyccsDVXsIjfwT7fEYj33G40p8/3fTJQilTGyAWXQShj3zsxNMd55Ytkd7X_qikae_ytSo'), ('filename', 'P9374A.jpeg'), ('size', 208353), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zhQAO12QJ5IQI_XuTf1RVg/wk_x6UIVxw5lGnDRhaoeVht9YFEmFEUGP7qJrDfvBppImATaniXfeszKAkqzQ9Z5ZissxnezJmiJNJU55uWzHQ/Ue3_wH6R7EB5wlVoBZFfSPygbqkqYr8_Ewk-u1HhWms'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wVTrQNWwIFkf1psAuspUVw/4iGj-uNlahA5wO6Q4tZTxqjV1RDadxqCkqi_MTswBPykQDTfHTeSpjgOPABYlPWdMg2EZOUk4BMr--pZEV_ILw/K_aoSHgSzxMB9mK7bwtW9IVWWJb-BsPdziUPJHtC0HA'), ('width', 955), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4HWm1iCFd2dTfHWQeQT8Sg/Vuj2ZLzoB9TscWHAmGMWevCwna2JWxfXo9nC9IHo0T4ta4uYbvnWS2zvvGM8AWEA3gbu9TibzDMqzhOvoRkDRQ/ejkTmyZuAoNkqnqdAomJWlOl53swnVZF_WZht6WLRsQ'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"P9374A Keysight Streamline USB Vector Network Analyzer, 20 GHz. Compact, faceless, USB vector network analyzer (VNA). Affordable full two-port VNA which dramatically reduces your size of test. Up to 20 GHz.","https://www.keysight.com/us/en/product/P9374A/streamline-usb-vector-network-analyzer-20-ghz.html#:~:text=P9374A%20Keysight%20Streamline%20USB%20Vector%20Network%20Analyzer%2C%2020%20GHz,-Use%20%2B%20and%20%2D%20keys&text=Compact%2C%20faceless%2C%20USB%20vector%20network,Up%20to%2020%20GHz.",Keysight P 9374 A,338.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_P9374A.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightP9374A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782637/Instruments/Network%20Analyzer/Keysight-P9374A/Keysight-P9374A.jpg,Keysight P9374A,Write a Python script that uses Qcodes to connect to a Keysight P9374A Network Analyzer,33150.0,,,,"from typing import Any

from . import N52xx

#  This is not the same class of Keysight devices but seems to work well...


class KeysightP9374A(N52xx.PNAxBase):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(
            name,
            address,
            min_freq=300e6,
            max_freq=20e9,
            min_power=-43,
            max_power=20,
            nports=2,
            **kwargs
        )

        self.get_options()
"
244,,https://en.wikipedia.org/wiki/Electric_generator,"[OrderedDict([('id', 'attTi6f3UhfE6DEiY'), ('width', 1024), ('height', 670), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ol25XpAbia5PrGDS8FC_3A/VS9nifexhnFiCaDGRpCWw7EhLa0rjnl3Fcsv3ewQGET1lR6nBbnpPEyl4PnanvRlSyG2IDxNjoNjW9HpqgF0Eg/m-PbDHIgb0-TnoyLOEem3mHN-hv2gQez31ziwEwGqzk'), ('filename', 'QDAC.png'), ('size', 142257), ('type', 'image/png')])]",2.0,"COPENHAGEN, DENMARK",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116688/Instruments/Vendor%20Logos/QDevils.png,"The original and popular QDAC from QDevil is a high-precision low-noise computer-controlled voltage generator designed for DC and low-frequency control of high impedance devices, such as gates in quantum electronics and quantum computer qubits. It also comes in a “high-current” version which can source up to 10 mA, for example for flux biasing of superconducting qubits. In addition to precise and stable voltage output, the QDAC can measure output currents, for example, to detect leaking gates or shorted bonding wires. The QDAC originates from the laboratories of the Center for Quantum Devices at the University of Copenhagen, where it is used for quantum computing research. The QDAC has 24 channels and offers a cost-effective way of getting many high-quality D/A converter channels.",https://qdevil.com/qdac/,Qdevil Qdac,422.0,"['Power Supplies', 'Digital-Analog Converter']","In electricity generation, a generator[1] is a device that converts motive power (mechanical energy) or fuel-based power (chemical energy) into electric power for use in an external circuit. Sources of mechanical energy include steam turbines, gas turbines, water turbines, internal combustion engines, wind turbines and even hand cranks. The first electromagnetic generator, the Faraday disk, was invented in 1831 by British scientist Michael Faraday. Generators provide nearly all of the power for electric power grids.","Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QDevil/QDevil_QDAC.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/QDev.html#qcodes.instrument_drivers.QDev.QDevQDac,Qdevil,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZipqRJHx1ZoZu3cghu7vBA/z9H-ZQBq2_I8zCC8dELRC06dUey_nswlbMuiYzEmycqDr8vhnXPF0FBCmXK4wC7kG-jirKCZzJoZX5FXEOL_aZH0awwU4pCaQjWQ9lmundE/m1xO3FphqjdTL2OvdcYibXA5xq2kBXku5jFFSbaE8m0'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_kPkmkp924cYOpBfwTdyRQ/6cwrD_J2gPXVt-4M1mUBTSIIWE-hsbkpM_9AGlgsmak6TyY_f-4iSK54jJhcnISchqqCuBivciv7wIromX99QQ_s6mdvUGEfbghSg5iIUeg/FqDUbUx5DPXHJ6hMeaZnrAmnuuBhJlx8vsMzdsdJC5M'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vv8Vb8suhbaQ0iYaWaZKMg/KSlmragEXUUzsRLsI6qD88v1EKTJ4gj8pssnhSStMUT69KrN7Q0hz2JLcfFYKvYk-nHLB8WFlHZLRfigCqFgUhecEVCWK04FmYxOhFWjvi4/W_nPBfzjSJkSeffoFXkes8ukvDD7flirUIYQti29HgY'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h7ewz4-RmYdXWrd-8yIIKg/db9bliGbjLIx49CcrSG-cT5AKuIC2afryQV_vMaEB3E1lUpsqSDprVTnuWANwTJIOK9uszt--wAUBM8uezGAQHlibS3nutwEuf4-J2XDFrg/22-M_b5ipZoxmJW1slGpryiJNTjrKn_fEjpJrsj9qtc'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782644/Instruments/Digital-Analog%20Converter/QDAC/QDAC.png,QDAC,"Write a Python script that uses Qcodes to connect to a QDAC Power Supplies, Digital-Analog Converter",,,,,"# QCoDeS driver for the QDevil QDAC using channels
# Adapted by QDevil from ""qdev\QDac_channels.py"" in
# the instrument drivers package
# Version 2.1 QDevil 2020-02-10

import logging
import time
from collections import namedtuple
from collections.abc import Sequence
from enum import Enum
from functools import partial
from typing import Any, Optional, Union

import pyvisa
import pyvisa.constants
from pyvisa.resources.serial import SerialInstrument

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import MultiChannelInstrumentParameter, ParamRawDataType
from qcodes.utils import deprecate

LOG = logging.getLogger(__name__)


_ModeTuple = namedtuple('_ModeTuple', 'v i')


class Mode(Enum):
    """"""
    Enum type use as the mode parameter for channels
    defining the combined voltage and current range.

    get_label() returns a text representation of the mode.
    """"""
    vhigh_ihigh = _ModeTuple(v=0, i=1)
    vhigh_ilow = _ModeTuple(v=0, i=0)
    vlow_ilow = _ModeTuple(v=1, i=0)

    def get_label(self) -> str:
        _MODE_LABELS = {
                ""vhigh_ihigh"": ""V range high / I range high"",
                ""vhigh_ilow"": ""V range high / I range low"",
                ""vlow_ilow"": ""V range low / I range low""}
        return _MODE_LABELS[self.name]


class Waveform:
    # Enum-like class defining the built-in waveform types
    sine = 1
    square = 2
    triangle = 3
    staircase = 4
    all_waveforms = [sine, square, triangle, staircase]


class Generator:
    #  Class used in the internal book keeping of generators
    def __init__(self, generator_number: int):
        self.fg = generator_number
        self.t_end = 9.9e9


class QDacChannel(InstrumentChannel):
    """"""
    A single output channel of the QDac.

    Exposes chan.v, chan.i, chan.mode, chan.slope,
    chan.sync, chan.sync_delay, chan.sync_duration.\n
    NB: Set v to zero before changing mode if the
    mode_force lfag is False (default).
    """"""

    def __init__(self, parent: ""QDac"", name: str, channum: int):
        """"""
        Args:
            parent: The instrument to which the channel belongs.
            name: The name of the channel
            channum: The number of the channel (1-24 or 1-48)
        """"""
        super().__init__(parent, name)

        # Add the parameters
        self.add_parameter(name='v',
                           label=f'Channel {channum} voltage',
                           unit='V',
                           set_cmd=partial(self._parent._set_voltage, channum),
                           get_cmd=f'set {channum}',
                           get_parser=float,
                           # Initial range. Updated on init and during
                           # operation:
                           vals=vals.Numbers(-9.99, 9.99)
                           )

        self.add_parameter(name='mode',
                           label=f'Channel {channum} mode.',
                           set_cmd=partial(self._parent._set_mode, channum),
                           get_cmd=None,
                           vals=vals.Enum(*list(Mode))
                           )

        self.add_parameter(name='i',
                           label=f'Channel {channum} current',
                           get_cmd=f'get {channum}',
                           unit='A',
                           get_parser=self._parent._current_parser
                           )

        self.add_parameter(name='slope',
                           label=f'Channel {channum} slope',
                           unit='V/s',
                           set_cmd=partial(self._parent._setslope, channum),
                           get_cmd=partial(self._parent._getslope, channum),
                           vals=vals.MultiType(vals.Enum('Inf'),
                                               vals.Numbers(1e-3, 10000))
                           )

        self.add_parameter(name='sync',
                           label=f'Channel {channum} sync output',
                           set_cmd=partial(self._parent._setsync, channum),
                           get_cmd=partial(self._parent._getsync, channum),
                           vals=vals.Ints(0, 4)  # Updated at qdac init
                           )

        self.add_parameter(name='sync_delay',
                           label=f'Channel {channum} sync pulse delay',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Numbers(0, 10000),
                           initial_value=0
                           )

        self.add_parameter(
                        name='sync_duration',
                        label=f'Channel {channum} sync pulse duration',
                        unit='s',
                        get_cmd=None, set_cmd=None,
                        vals=vals.Numbers(0.001, 10000),
                        initial_value=0.01
                        )

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._parent._update_currents and update
        if update and not self._parent._get_status_performed:
            self._parent._update_cache(update_currents=update_currents)
        # call update_cache rather than getting the status individually for
        # each parameter. This is only done if _get_status_performed is False
        # this is used to signal that the parent has already called it and
        # no need to repeat.
        if params_to_skip_update is None:
            params_to_skip_update = ('v', 'i', 'mode')
        snap = super().snapshot_base(
                            update=update,
                            params_to_skip_update=params_to_skip_update)
        return snap


class QDacMultiChannelParameter(MultiChannelInstrumentParameter):
    """"""
    The class to be returned by __getattr__ of the ChannelList. Here customised
    for fast multi-readout of voltages.
    """"""
    def __init__(self, channels: Sequence[InstrumentChannel],
                 param_name: str,
                 *args: Any,
                 **kwargs: Any):
        super().__init__(channels, param_name, *args, **kwargs)

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        """"""
        Return a tuple containing the data from each of the channels in the
        list.
        """"""
        # For voltages, we can do something slightly faster than the naive
        # approach by asking the instrument for a channel overview.

        if self._param_name == 'v':
            qdac = self._channels[0]._parent
            qdac._update_cache(update_currents=False)
            output = tuple(chan.parameters[self._param_name].cache()
                           for chan in self._channels)
        else:
            output = tuple(chan.parameters[self._param_name].get()
                           for chan in self._channels)

        return output


@deprecate(alternative=""QDevil QDAC 1 driver in qcodes_contrib_drivers."")
class QDac(VisaInstrument):
    """"""
    Channelised driver for the QDevil QDAC voltage source.

    Exposes channels, temperature sensors and calibration output,
    and 'ramp_voltages' + 'ramp_voltages_2d' for multi channel ramping.

    In addition a 'mode_force' flag (default False) is exposed.
    'mode_force' (=True) is used to enable voltage range switching, via
    the channel 'mode' parameter, even at non-zero output voltages.

    Tested with Firmware Version: 1.07

    The driver assumes that the instrument is ALWAYS in verbose mode OFF
    and sets this as part of the initialization, so please do not change this.
    """"""

    # set nonzero value (seconds) to accept older status when reading settings
    max_status_age = 1

    def __init__(self,
                 name: str,
                 address: str,
                 update_currents: bool = False,
                 **kwargs: Any):
        """"""
        Instantiates the instrument.

        Args:
            name: The instrument name used by qcodes
            address: The VISA name of the resource
            update_currents: Whether to query all channels for their
                current sensor value on startup, which takes about 0.5 sec
                per channel. Default: False.

        Returns:
            QDac object
        """"""

        super().__init__(name, address, **kwargs)
        handle = self.visa_handle
        self._get_status_performed = False

        assert isinstance(handle, SerialInstrument)
        # Communication setup + firmware check
        handle.baud_rate = 460800
        handle.parity = pyvisa.constants.Parity(0)
        handle.data_bits = 8
        self.set_terminator('\n')
        handle.write_termination = '\n'
        self._write_response = ''
        firmware_version = self._get_firmware_version()
        if firmware_version < 1.07:
            LOG.warning(f""Firmware version: {firmware_version}"")
            raise RuntimeError('''
                No QDevil QDAC detected or the firmware version is obsolete.
                This driver only supports version 1.07 or newer. Please
                contact info@qdevil.com for a firmware update.
                ''')

        # Initialse basic information and internal book keeping
        self.num_chans = self._get_number_of_channels()
        num_boards = int(self.num_chans/8)
        self._output_n_lines = self.num_chans + 2
        self._chan_range = range(1, 1 + self.num_chans)
        self.channel_validator = vals.Ints(1, self.num_chans)
        self._reset_bookkeeping()

        # Add channels (and channel parameters)
        channels = ChannelList(self, ""Channels"", QDacChannel,
                               snapshotable=False,
                               multichan_paramclass=QDacMultiChannelParameter)

        for i in self._chan_range:
            channel = QDacChannel(self, f'chan{i:02}', i)
            channels.append(channel)
            self.add_submodule(f""ch{i:02}"", channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        # Updatechannel  sync port validator according to number of boards
        self._num_syns = max(num_boards-1, 1)
        for chan in self._chan_range:
            self.channels[chan-1].sync.vals = vals.Ints(0, self._num_syns)

        # Add non-channel parameters
        for board in range(num_boards):
            for sensor in range(3):
                label = f'Board {board}, Temperature {sensor}'
                self.add_parameter(name=f'temp{board}_{sensor}',
                                   label=label,
                                   unit='C',
                                   get_cmd=f'tem {board} {sensor}',
                                   get_parser=self._num_verbose)

        self.add_parameter(name='cal',
                           set_cmd='cal {}',
                           vals=vals.Ints(0, self.num_chans))

        self.add_parameter(name='mode_force',
                           label='Mode force',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Bool(),
                           initial_value=False)

        # Due to a firmware bug in 1.07 voltage ranges are always reported
        # vebosely. So for future compatibility we set verbose True
        self.write('ver 1')
        self._update_voltage_ranges()
        # The driver require verbose mode off except for the above command
        self.write('ver 0')
        self._verbose = False  # Just so that the code can check the state
        self.connect_message()
        LOG.info('[*] Querying all channels for voltages and currents...')
        self._update_cache(update_currents=update_currents)
        self._update_currents = update_currents
        self._load_state()
        LOG.info('[+] Done')

    def _reset_bookkeeping(self) -> None:
        """"""
        Resets all internal variables used for ramping and
        synchronization outputs.
        """"""
        # Assigned slopes. Entries will eventually be {chan: slope}
        self._slopes: dict[int, Union[str, float]] = {}
        # Function generators and triggers (used in ramping)
        self._fgs = set(range(1, 9))
        self._assigned_fgs: dict[int, Generator] = {}  # {chan: fg}
        self._trigs = set(range(1, 10))
        self._assigned_triggers: dict[int, int] = {}  # {fg: trigger}
        # Sync channels
        self._syncoutputs: dict[int, int] = {}  # {chan: syncoutput}

    def _load_state(self) -> None:
        """"""
        Used as part of initiaisation. DON'T use _load_state() separately.\n
        Updates internal book keeping of running function generators.
        used triggers and active sync outputs.\n
        Slopes can not be read/updated as it is not possible to
        say if a generator is running because a slope has been assigned
        or because it is being ramped direcly (by e.g. ramp_voltages_2d()).
        """"""
        # Assumes that all variables and virtual
        # parameters have been initialised (and read)

        self.write('ver 0')  # Just to be on the safe side

        self._reset_bookkeeping()
        for ch_idx in range(self.num_chans):
            chan = ch_idx + 1
            # Check if the channels are being ramped
            # It is not possible to find out if it has a slope assigned
            # as it may be ramped explicitely by the user
            # We assume that generators are running, but we cannot know
            self.write(f'wav {chan}')
            fg_str, amplitude_str, offset_str = self._write_response.split(',')
            amplitude = float(amplitude_str)
            offset = float(offset_str)
            fg = int(fg_str)
            if fg in range(1, 9):
                voltage = self.channels[ch_idx].v.get()
                time_now = time.time()
                self.write(f'fun {fg}')
                response = self._write_response.split(',')
                waveform = int(response[0])
                # Probably this driver is involved if a stair case is assigned
                if waveform == Waveform.staircase:
                    if len(response) == 6:
                        step_length_ms, no_steps, rep, rep_remain_str, trigger \
                            = response[1:6]
                        rep_remain = int(rep_remain_str)
                    else:
                        step_length_ms, no_steps, rep, trigger = response[1:5]
                        rep_remain = int(rep)
                    ramp_time = 0.001 * float(step_length_ms) * int(no_steps)
                    ramp_remain = 0
                    if (amplitude != 0):
                        ramp_remain = (amplitude+offset-voltage)/amplitude
                    if int(rep) == -1:
                        time_end = time_now + 315360000
                    else:
                        time_end = (ramp_remain + max(0, rep_remain-1)) \
                                   * ramp_time + time_now + 0.001
                else:
                    if waveform == Waveform.sine:
                        period_ms, rep, rep_remain_str, trigger = response[1:5]
                    else:
                        period_ms, _, rep, rep_remain_str, trigger = response[1:6]
                    if int(rep) == -1:
                        time_end = time_now + 315360000  # 10 years from now
                    else:  # +1 is just a safe guard
                        time_end = time_now + 0.001 \
                                   * (int(rep_remain_str)+1) * float(period_ms)

                self._assigned_fgs[chan] = Generator(fg)
                self._assigned_fgs[chan].t_end = time_end
                if int(trigger) != 0:
                    self._assigned_triggers[fg] = int(trigger)
                for syn in range(1, self._num_syns+1):
                    self.write(f'syn {syn}')
                    syn_fg, delay_ms, duration_ms = \
                        self._write_response.split(',')
                    if int(syn_fg) == fg:
                        self.channels[ch_idx].sync.cache.set(syn)
                        self.channels[ch_idx].sync_delay(float(delay_ms)/1000)
                        self.channels[ch_idx].sync_duration(
                            float(duration_ms)/1000)

    def reset(self, update_currents: bool = False) -> None:
        """"""
        Resets the instrument setting all channels to zero output voltage
        and all parameters to their default values, including removing any
        assigned sync putputs, function generators, triggers etc.
        """"""
        # In case the QDAC has been switched off/on
        # clear the io buffer and set verbose False
        self.device_clear()
        self.write('ver 0')

        self.cal(0)
        # Resetting all slopes first will cause v.set() disconnect generators
        self.channels[0:self.num_chans].slope('Inf')
        self.channels[0:self.num_chans].v(0)
        self.channels[0:self.num_chans].mode(Mode.vhigh_ihigh)
        self.channels[0:self.num_chans].sync(0)
        self.channels[0:self.num_chans].sync_delay(0)
        self.channels[0:self.num_chans].sync_duration(0.01)

        if update_currents:
            self.channels[0:self.num_chans].i.get()
        self.mode_force(False)
        self._reset_bookkeeping()

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._update_currents and update is True
        if update:
            self._update_cache(update_currents=update_currents)
            self._get_status_performed = True
        # call _update_cache rather than getting the status individually for
        # each parameter. We set _get_status_performed to True
        # to indicate that each update channel does not need to call this
        # function as opposed to when snapshot is called on an individual
        # channel
        snap = super().snapshot_base(
                                update=update,
                                params_to_skip_update=params_to_skip_update)
        self._get_status_performed = False
        return snap

    #########################
    # Channel gets/sets
    #########################

    def _set_voltage(self, chan: int, v_set: float) -> None:
        """"""
        set_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
            v_set: The target voltage

        If a finite slope has been assigned, a function generator will
        ramp the voltage.
        """"""

        slope = self._slopes.get(chan, None)
        if slope:
            # We need .get and not cache/get_latest in case a ramp
            # was interrupted
            v_start = self.channels[chan-1].v.get()
            duration = abs(v_set-v_start)/slope
            LOG.info(f'Slope: {slope}, time: {duration}')
            # SYNCing happens inside ramp_voltages
            self.ramp_voltages([chan], [v_start], [v_set], duration)
        else:  # Should not be necessary to wav here.
            self.write('wav {ch} 0 0 0;set {ch} {voltage:.6f}'
                       .format(ch=chan, voltage=v_set))

    def _set_mode(self, chan: int, new_mode: Mode) -> None:
        """"""
        set_cmd for the QDAC's mode (combined voltage and current sense range).
        It is not possible to switch from voltage range without setting the
        the volage to zero first or set the global mode_force parameter True.
        """"""
        def _clipto(value: float, min_: float, max_: float) -> float:
            errmsg = (""Voltage is outside the bounds of the new voltage range""
                      "" and is therefore clipped."")
            if value > max_:
                LOG.warning(errmsg)
                return max_
            elif value < min_:
                LOG.warning(errmsg)
                return min_
            else:
                return value

        # It is not possible ot say if the channel is connected to
        # a generator, so we need to ask.
        def wav_or_set_msg(chan: int, new_voltage: float) -> str:
            self.write(f'wav {chan}')
            fw_str = self._write_response
            gen, _, _ = fw_str.split(',')
            if int(gen) > 0:
                # The amplitude must be set to zero to avoid potential overflow
                # Assuming that voltage range is not changed during a ramp
                return 'wav {} {} {:.6f} {:.6f}'\
                        .format(chan, int(gen), 0, new_voltage)
            else:
                return f'set {chan} {new_voltage:.6f}'

        old_mode = self.channels[chan-1].mode.cache()
        new_vrange = new_mode.value.v
        old_vrange = old_mode.value.v
        new_irange = new_mode.value.i
        old_irange = old_mode.value.i
        message = ''
        max_zero_voltage = {0: 20e-6, 1: 3e-6}
        NON_ZERO_VOLTAGE_MSG = (
                'Please set the voltage to zero before changing the voltage'
                ' range in order to avoid jumps or spikes.'
                ' Or set mode_force=True to allow voltage range change for'
                ' non-zero voltages.')

        if old_mode == new_mode:
            return

        # If the voltage range is going to change we have to take care of
        # setting the voltage after the switch, and therefore read it first
        # We also need to make sure than only one of the voltage/current
        # relays is on at a time (otherwise the firmware will enforce it).

        if (new_irange != old_irange) and (new_vrange == old_vrange == 0):
            # Only the current sensor relay has to switch:
            message += f'cur {chan} {new_irange}'
        # The voltage relay (also) has to switch:
        else:
            # Current sensor relay on->off before voltage relay off->on:
            if new_irange < old_irange and new_vrange > old_vrange:
                message += f'cur {chan} {new_irange};'
            old_voltage = self.channels[chan-1].v.get()
            # Check if voltage is non-zero and mode_force is off
            if ((self.mode_force() is False) and
                    (abs(old_voltage) > max_zero_voltage[old_vrange])):
                raise ValueError(NON_ZERO_VOLTAGE_MSG)
            new_voltage = _clipto(
                    old_voltage, self.vranges[chan][new_vrange]['Min'],
                    self.vranges[chan][new_vrange]['Max'])
            message += f'vol {chan} {new_vrange};'
            message += wav_or_set_msg(chan, new_voltage)
            # Current sensor relay off->on after voltage relay on->off:
            if new_irange > old_irange and new_vrange < old_vrange:
                message += f';cur {chan} {new_irange}'
            self.channels[chan-1].v.vals = self._v_vals(chan, new_vrange)
            self.channels[chan-1].v.cache.set(new_voltage)

        self.write(message)

    def _v_vals(self, chan: int, vrange_int: int) -> vals.Numbers:
        """"""
        Returns the validator for the specified voltage range.
        """"""
        return vals.Numbers(self.vranges[chan][vrange_int]['Min'],
                            self.vranges[chan][vrange_int]['Max'])

    def _update_v_validators(self) -> None:
        """"""
        Command for setting all 'v' limits ('vals') of all channels to the
        actual calibrated output limits for the range each individual channel
        is currently in.
        """"""
        for chan in range(1, self.num_chans+1):
            vrange = self.channels[chan-1].mode.value.v
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange)

    def _num_verbose(self, s: str) -> float:
        """"""
        Turns a return value from the QDac into a number.
        If the QDac is in verbose mode, this involves stripping off the
        value descriptor.
        """"""
        if self._verbose:
            s = s.split(': ')[-1]
        return float(s)

    def _current_parser(self, s: str) -> float:
        """"""
        Parser for chXX_i parameter (converts from uA to A)
        """"""
        return 1e-6*self._num_verbose(s)

    def _update_cache(self, update_currents: bool = False) -> None:
        """"""
        Function to query the instrument and get the status of all channels.
        Takes a while to finish.

        The `status` call generates 27 or 51 lines of output. Send the command
        and read the first one, which is the software version line
        the full output looks like:
        Software Version: 1.07\r\n
        Channel\tOut V\t\tVoltage range\tCurrent range\n
        \n
        8\t  0.000000\t\tX 1\t\tpA\n
        7\t  0.000000\t\tX 1\t\tpA\n
        ... (all 24/48 channels like this)
        (no termination afterward besides the \n ending the last channel)
        """"""
        irange_trans = {'hi cur': 1, 'lo cur': 0}
        vrange_trans = {'X 1': 0, 'X 0.1': 1}

        # Status call, check the
        version_line = self.ask('status')
        if version_line.startswith('Software Version: '):
            self.version = version_line.strip().split(': ')[1]
        else:
            self._wait_and_clear()
            raise ValueError('unrecognized version line: ' + version_line)

        # Check header line
        header_line = self.read()
        headers = header_line.lower().strip('\r\n').split('\t')
        expected_headers = ['channel', 'out v', '', 'voltage range',
                            'current range']
        if headers != expected_headers:
            raise ValueError('unrecognized header line: ' + header_line)

        chans_left = set(self._chan_range)
        while chans_left:
            line = self.read().strip()
            if not line:
                continue
            chanstr, v, _, vrange, _, irange = line.split('\t')
            chan = int(chanstr)
            vrange_int = int(vrange_trans[vrange.strip()])
            irange_int = int(irange_trans[irange.strip()])
            mode = Mode((vrange_int, irange_int))
            self.channels[chan-1].mode.cache.set(mode)
            self.channels[chan-1].v.cache.set(float(v))
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange_int)
            chans_left.remove(chan)

        if update_currents:
            for chan in self._chan_range:
                self.channels[chan-1].i.get()

    def _setsync(self, chan: int, sync: int) -> None:
        """"""
        set_cmd for the chXX_sync parameter.

        Args:
            chan: The channel number (1-48 or 1-24)
            sync: The associated sync output (1-3 on 24 ch units
            or 1-5 on 48 ch units). 0 means 'unassign'
        """"""

        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                    f'Channel number must be 1-{self.num_chans}.')

        if sync == 0:
            oldsync = self.channels[chan-1].sync.cache()
            # try to remove the sync from internal bookkeeping
            self._syncoutputs.pop(chan, None)
            # free the previously assigned sync
            if oldsync is not None:
                self.write(f'syn {oldsync} 0 0 0')
            return

        # Make sure to clear hardware an _syncoutpus appropriately
        if chan in self._syncoutputs:
            # Changing SYNC port for a channel
            oldsync = self.channels[chan-1].sync.cache()
            if sync != oldsync:
                self.write(f'syn {oldsync} 0 0 0')
        elif sync in self._syncoutputs.values():
            # Assigning an already used SYNC port to a different channel
            oldchan = [ch for ch, sy in self._syncoutputs.items()
                       if sy == sync]
            self._syncoutputs.pop(oldchan[0], None)
            self.write(f'syn {sync} 0 0 0')

        self._syncoutputs[chan] = sync
        return

    def _getsync(self, chan: int) -> int:
        """"""
        get_cmd of the chXX_sync parameter
        """"""
        return self._syncoutputs.get(chan, 0)

    def print_syncs(self) -> None:
        """"""
        Print assigned SYNC ports, sorted by channel number
        """"""
        for chan, sync in sorted(self._syncoutputs.items()):
            print(f'Channel {chan}, SYNC: {sync} (V/s)')

    def _setslope(self, chan: int, slope: Union[float, str]) -> None:
        """"""
        set_cmd for the chXX_slope parameter, the maximum slope of a channel.
        With a finite slope the channel will be ramped using a generator.

        Args:
            chan: The channel number (1-24 or 1-48)
            slope: The slope in V/s.
            Write 'Inf' to release the channelas slope channel and to release
            the associated function generator. The output rise time will now
            only depend on the analog electronics.
        """"""
        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')

        if slope == 'Inf':
            # Set the channel in DC mode
            v_set = self.channels[chan-1].v.get()
            self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                       .format(ch=chan, voltage=v_set))

            # Now release the function generator and fg trigger (if possible)
            try:
                fg = self._assigned_fgs[chan]
                self._assigned_fgs[chan].t_end = 0
                self._assigned_triggers.pop(fg.fg)
            except KeyError:
                pass

            # Remove a sync output, if one was assigned
            if chan in self._syncoutputs:
                self.channels[chan-1].sync.set(0)
            # Now clear the assigned slope
            self._slopes.pop(chan, None)
        else:
            self._slopes[chan] = slope

    def _getslope(self, chan: int) -> Union[str, float]:
        """"""
        get_cmd of the chXX_slope parameter
        """"""
        return self._slopes.get(chan, 'Inf')

    def print_slopes(self) -> None:
        """"""
        Print the finite slopes assigned to channels, sorted by channel number
        """"""
        for chan, slope in sorted(self._slopes.items()):
            print(f'Channel {chan}, slope: {slope} (V/s)')

    def _get_minmax_outputvoltage(
        self, channel: int, vrange_int: int
    ) -> dict[str, float]:
        """"""
        Returns a dictionary of the calibrated Min and Max output
        voltages of 'channel' for the voltage given range (0,1) given by
        'vrange_int'
        """"""
        # For firmware 1.07 verbose mode and nn verbose mode give verbose
        # result, So this is designed for verbose mode
        if channel not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
        if vrange_int not in range(0, 2):
            raise ValueError('Range must be 0 or 1.')

        self.write(f'rang {channel} {vrange_int}')
        fw_str = self._write_response
        return {'Min': float(fw_str.split('MIN:')[1].split('MAX')[0].strip()),
                'Max': float(fw_str.split('MAX:')[1].strip())}

    def _update_voltage_ranges(self) -> None:
        # Get all calibrated min/max output values, requires verbose on
        # in firmware version 1.07
        self.write('ver 1')
        self.vranges = {}
        for chan in self._chan_range:
            self.vranges.update(
                {chan: {0: self._get_minmax_outputvoltage(chan, 0),
                        1: self._get_minmax_outputvoltage(chan, 1)}})
        self.write('ver 0')

    def write(self, cmd: str) -> None:
        """"""
        QDac always returns something even from set commands, even when
        verbose mode is off, so we'll override write to take this out
        if you want to use this response, we put it in self._write_response
        (but only for the very last write call)

        In this method we expect to read one termination char per command. As
        commands are concatenated by `;` we count the number of concatenated
        commands as count(';') + 1 e.g. 'wav 1 1 1 0;fun 2 1 100 1 1' is two
        commands. Note that only the response of the last command will be
        available in `_write_response`
        """"""

        LOG.debug(f""Writing to instrument {self.name}: {cmd}"")
        self.visa_handle.write(cmd)
        for _ in range(cmd.count(';')+1):
            self._write_response = self.visa_handle.read()

    def read(self) -> str:
        return self.visa_handle.read()

    def _wait_and_clear(self, delay: float = 0.5) -> None:
        time.sleep(delay)
        self.visa_handle.clear()

    def connect_message(self,
                        idn_param: str = 'IDN',
                        begin_time: Optional[float] = None) -> None:
        """"""
        Override of the standard Instrument class connect_message.
        Usually, the response to `*IDN?` is printed. Here, the
        software version is printed.
        """"""
        self.visa_handle.write('version')
        LOG.info('Connected to QDAC on {}, {}'.format(
                                    self._address, self.visa_handle.read()))

    def _get_firmware_version(self) -> float:
        """"""
        Check if the ""version"" command reponds. If so we probbaly have a QDevil
        QDAC, and the version number is returned. Otherwise 0.0 is returned.
        """"""
        self.write('version')
        fw_str = self._write_response
        if (""Unrecognized command"" not in fw_str) and (""Software Version: "" in fw_str):
            fw_version = float(self._write_response.replace(""Software Version: "", """"))
        else:
            fw_version = 0.0
        return fw_version

    def _get_number_of_channels(self) -> int:
        """"""
        Returns the number of channels for the instrument
        """"""
        self.write('boardNum')
        fw_str = self._write_response
        return 8*int(fw_str.strip(""numberOfBoards:""))

    def print_overview(self, update_currents: bool =  False) -> None:
        """"""
        Pretty-prints the status of the QDac
        """"""

        self._update_cache(update_currents=update_currents)

        for ii in range(self.num_chans):
            line = f""Channel {ii+1} \n""
            line += ""    Voltage: {} ({}).\n"".format(
                self.channels[ii].v.cache(), self.channels[ii].v.unit
            )
            line += ""    Current: {} ({}).\n"".format(
                self.channels[ii].i.cache.get(get_if_invalid=False),
                self.channels[ii].i.unit,
            )
            line += f""    Mode: {self.channels[ii].mode.cache().get_label()}.\n""
            line += ""    Slope: {} ({}).\n"".format(
                self.channels[ii].slope.cache(), self.channels[ii].slope.unit
            )
            if self.channels[ii].sync.cache() > 0:
                line += '    Sync Out: {}, Delay: {} ({}), '\
                        'Duration: {} ({}).\n'.format(
                            self.channels[ii].sync.cache(),
                            self.channels[ii].sync_delay.cache(),
                            self.channels[ii].sync_delay.unit,
                            self.channels[ii].sync_duration.cache(),
                            self.channels[ii].sync_duration.unit,
                        )

            print(line)

    def _get_functiongenerator(self, chan: int) -> int:
        """"""
        Function for getting a free generator (of 8 available) for a channel.
        Used as helper function for ramp_voltages, but may also be used if the
        user wants to use a function generator for something else.
        If there are no free generators this function will wait for up to
        fgs_timeout for one to be ready.

        To mark a function generator as available for others set
        self._assigned_fgs[chan].t_end = 0

        Args:
            chan: (1..24/48) the channel for which a function generator is
                  requested.
        """"""
        fgs_timeout = 2  # Max time to wait for next available generator

        if len(self._assigned_fgs) < 8:
            fg = min(self._fgs.difference(
                        {g.fg for g in self._assigned_fgs.values()}))
            self._assigned_fgs[chan] = Generator(fg)
        else:
            # If no available fgs, see if one is soon to be ready
            # Nte, this does not handle if teh user has assigned the
            # same fg to multiple channels cheating the driver
            time_now = time.time()
            available_fgs_chans = []
            fgs_t_end_ok = [g.t_end for chan, g
                            in self._assigned_fgs.items()
                            if g.t_end < time_now+fgs_timeout]
            if len(fgs_t_end_ok) > 0:
                first_ready_t = min(fgs_t_end_ok)
                available_fgs_chans = [chan for chan, g
                                       in self._assigned_fgs.items()
                                       if g.t_end == first_ready_t]
                if first_ready_t > time_now:
                    LOG.warning('''
                    Trying to ramp more channels than there are generators.\n
                    Waiting for ramp generator to be released''')
                    time.sleep(first_ready_t - time_now)

            if len(available_fgs_chans) > 0:
                oldchan = available_fgs_chans[0]
                fg = self._assigned_fgs[oldchan].fg
                self._assigned_fgs.pop(oldchan)
                self._assigned_fgs[chan] = Generator(fg)
                # Set the old channel in DC mode
                v_set = self.channels[oldchan-1].v.cache()
                self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                           .format(ch=oldchan, voltage=v_set))
            else:
                raise RuntimeError('''
                Trying to ramp more channels than there are generators
                available. Please insert delays allowing channels to finish
                ramping before trying to ramp other channels, or reduce the
                number of ramped channels. Or increase fgs_timeout.''')
        return fg

    def ramp_voltages(
            self,
            channellist: Sequence[int],
            v_startlist: Sequence[float],
            v_endlist: Sequence[float],
            ramptime: float) -> float:
        """"""
        Function for smoothly ramping one channel or more channels
        simultaneously (max. 8). This is a shallow interface to
        ramp_voltages_2d. Function generators and triggers are
        are assigned automatically.

        Args:
            channellist:    List (int) of channels to be ramped (1 indexed)\n
            v_startlist:    List (int) of voltages to ramp from.
                            MAY BE EMPTY. But if provided, time is saved by
                            NOT reading the present values from the instrument.

            v_endlist:      List (int) of voltages to ramp to.\n
            ramptime:       Total ramp time in seconds (min. 0.002). Has
                            to be an integer number of 0.001 secs).\n
        Returns:
            Estimated time of the excecution of the 2D scan.

        NOTE: This function returns as the ramps are started. So you need
        to wait for 'ramptime' until measuring....
        """"""

        if ramptime < 0.002:
            LOG.warning('Ramp time too short: {:.3f} s. Ramp time set to 2 ms.'
                        .format(ramptime))
            ramptime = 0.002
        steps = int(ramptime*1000)
        return self.ramp_voltages_2d(
                            slow_chans=[], slow_vstart=[], slow_vend=[],
                            fast_chans=channellist, fast_vstart=v_startlist,
                            fast_vend=v_endlist, step_length=0.001,
                            slow_steps=1, fast_steps=steps)

    def ramp_voltages_2d(
            self,
            slow_chans: Sequence[int],
            slow_vstart: Sequence[float],
            slow_vend: Sequence[float],
            fast_chans: Sequence[int],
            fast_vstart: Sequence[float],
            fast_vend: Sequence[float],
            step_length: float,
            slow_steps: int,
            fast_steps: int) -> float:
        """"""
        Function for smoothly ramping two channel groups simultaneously with
        one slow (x) and one fast (y) group. used by 'ramp_voltages' where x is
        empty. Function generators and triggers are assigned automatically.

        Args:
            slow_chans:   List of channels to be ramped (1 indexed) in
                          the slow-group\n
            slow_vstart:  List of voltages to ramp from in the
                          slow-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            slow_vend:    list of voltages to ramp to in the slow-group.

            fast_chans:   List of channels to be ramped (1 indexed) in
                          the fast-group.\n
            fast_vstart:  List of voltages to ramp from in the
                          fast-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            fast_vend:    list of voltages to ramp to in the fast-group.

            step_length:  Time spent at each step in seconds
                          (min. 0.001) multiple of 1 ms.\n
            slow_steps:   number of steps in the slow direction.\n
            fast_steps:   number of steps in the fast direction.\n

        Returns:
            Estimated time of the excecution of the 2D scan.\n
        NOTE: This function returns as the ramps are started.
        """"""
        channellist = [*slow_chans, *fast_chans]
        v_endlist = [*slow_vend, *fast_vend]
        v_startlist = [*slow_vstart, *fast_vstart]
        step_length_ms = int(step_length*1000)

        if step_length < 0.001:
            LOG.warning('step_length too short: {:.3f} s. \nstep_length set to'
                        .format(step_length_ms) + ' minimum (1ms).')
            step_length_ms = 1

        if any([ch in fast_chans for ch in slow_chans]):
            raise ValueError(
                    'Channel cannot be in both slow_chans and fast_chans!')

        no_channels = len(channellist)
        if no_channels != len(v_endlist):
            raise ValueError(
                    'Number of channels and number of voltages inconsistent!')

        for chan in channellist:
            if chan not in range(1, self.num_chans+1):
                raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
            if chan not in self._assigned_fgs:
                self._get_functiongenerator(chan)

        # Voltage validation
        for i in range(no_channels):
            self.channels[channellist[i]-1].v.validate(v_endlist[i])
        if v_startlist:
            for i in range(no_channels):
                self.channels[channellist[i]-1].v.validate(v_startlist[i])

        # Get start voltages if not provided
        if not slow_vstart:
            slow_vstart = [self.channels[ch-1].v.get() for ch in slow_chans]
        if not fast_vstart:
            fast_vstart = [self.channels[ch-1].v.get() for ch in fast_chans]

        v_startlist = [*slow_vstart, *fast_vstart]
        if no_channels != len(v_startlist):
            raise ValueError(
                'Number of start voltages do not match number of channels!')

        # Find trigger not aleady uses (avoid starting other
        # channels/function generators)
        if no_channels == 1:
            trigger = 0
        else:
            trigger = int(min(self._trigs.difference(
                                    set(self._assigned_triggers.values()))))

        # Make sure any sync outputs are configured
        for chan in channellist:
            if chan in self._syncoutputs:
                sync = self._syncoutputs[chan]
                sync_duration = int(
                                1000*self.channels[chan-1].sync_duration.get())
                sync_delay = int(1000*self.channels[chan-1].sync_delay.get())
                self.write('syn {} {} {} {}'.format(
                                            sync, self._assigned_fgs[chan].fg,
                                            sync_delay, sync_duration))

        # Now program the channel amplitudes and function generators
        msg = ''
        for i in range(no_channels):
            amplitude = v_endlist[i]-v_startlist[i]
            ch = channellist[i]
            fg = self._assigned_fgs[ch].fg
            if trigger > 0:  # Trigger 0 is not a trigger
                self._assigned_triggers[fg] = trigger
            msg += f""wav {ch} {fg} {amplitude} {v_startlist[i]}""
            # using staircase = function 4
            nsteps = slow_steps if ch in slow_chans else fast_steps
            repetitions = slow_steps if ch in fast_chans else 1

            delay = step_length_ms \
                if ch in fast_chans else fast_steps*step_length_ms
            msg += ';fun {} {} {} {} {} {};'.format(
                        fg, Waveform.staircase, delay, int(nsteps),
                        repetitions, trigger)
            # Update latest values to ramp end values
            # (actually not necessary when called from _set_voltage)
            self.channels[ch-1].v.cache.set(v_endlist[i])
        self.write(msg[:-1])  # last semicolon is stripped

        # Fire trigger to start generators simultaneously, saving communication
        # time by not using triggers for single channel ramping
        if trigger > 0:
            self.write(f'trig {trigger}')

        # Update fgs dict so that we know when the ramp is supposed to end
        time_ramp = slow_steps * fast_steps * step_length_ms / 1000
        time_end = time_ramp + time.time()
        for chan in channellist:
            self._assigned_fgs[chan].t_end = time_end
        return time_ramp
"
246,https://www.testequipmenthq.com/datasheets/KEITHLEY-2612B-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attZwqOigLxiH7ADe'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/D_fweTQaWe9k1a-kGneU9g/GxV4-mTk5pjjK70rbdacSWSAgNH9SaV1s9A5alZFybQOM0PN3XYLAJ01yMLZm09zYqxrQEwuRreYDC4CwwzZzgUVHEfwAVfYWSpNvtpZAZs/r0zXp5iHuHPaP8DftQe4xG6wQ_yL5OrH6JrFnY_Ynmw'), ('filename', '2612b.webp'), ('size', 7496), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4AaStLZcxMGS-49HQCfB6Q/2MCYFPLxsHNnZIOc2D08-GXEFGw_-CSHY6ebrGaSbencEVWWQYfpMJdhzDDjRfRAtEaZPphuHX7U_NeFDhB1OajHhuGdZmz39Q5I6SA2MBw/NXCtXMfYMOo7EUMCegsMa1IYMoFHhbx1z1obigKCR8s'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ST2WMV8EoUFbKrNoZG4e8g/p3wJxorrYPYavlnfT4tBBrgLrzamNd3ow_89M7IDWMaJwrI_teUj4Uy6YAVkyqgpbRSVeq7kpF0WabGmGMTsHi9xK8Ag5cfZaPgBjMAYfWY/OliugZ1FZsZZhjW5HFMdO8qtfldMkkfepozjglrehOE'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rnpAeEejO5nWRpCIhj3mrg/euCmkNkM4piB6gTqISzWTmBbdM2I4DHNpnRERKJ0g7JBFAVxmbwPULQFeeflsonX8htgG5lT8MwMU9-qYMg1xFctfFB29H_sawbUXEtskec/Gp_eRWfiDzRV4LbpyP-xv8av7rGWamOYwvHlGS_Xds4'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2612B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",https://canada.newark.com/keithley/2612b/source-meter-voltage-current-30/dp/44W8037,Keithley 2612 B,249.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2612B.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2612B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782646/Instruments/Power%20Supplies/Keithley-2612B/Keithley-2612B.webp,Keithley 2612B,Write a Python script that uses Qcodes to connect to a Keithley 2612B Power Supplies,20155.0,,,,"from ._Keithley_2600 import Keithley2600


class Keithley2612B(Keithley2600):
    """"""
    QCoDeS driver for the Keithley 2612B Source-Meter
    """"""

    pass
"
251,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'attPKDhoPPKd5xfBs'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bKXi5fklSlMbwARtgMhpFg/jzvsbv9j0zn34TJH997EQYM-gXE53bLV3fwq1LMWLudhEz-jfQexP5eMBtklPKXRsx7RwlCHBkiem043h1qoEg4YBXYqntAIK_wp5JP0LIc/7nS_R2P6BejyBnM_Binx07KuhDkf-rE14CB2fRtVPew'), ('filename', 'PL303QMT-1000px.jpg'), ('size', 160347), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-0sf0niZ8RZKUefYgldW4A/uMn-N6BR_WVk3bO75am-E-2X5-__G1FJyMrDUmvo7IeFd9dXhVu6PlZSihB6y6V3ZFjH4WnJxLeBCZFAzeQBeA/v9Hx_Olq2bakGUhnKvEAPTTrTQr9UGh4xvBSvrClUBs'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9rwCDX-gs6NqUSyFbJSbUg/xpPQjSw6vdJLMCyIOCysQfxTIRk4VxDI_mjBWLtJP5vEeWCuv4yro2avbRWMpqPdFARxX-WbyAKqjPlOboFHrA/hC8WU-fMjncbAzYU3kjjYX91gFsiEDUDsdhjnd0LxI0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oN-J-F65FwkrWsPhogH1EA/DlZxh9NlLfCbRPZCc1AZXiwN8ne_SIZmo_wMtrBIqSpSZIgjot0ayRTtyn0l-CglsnMNKuWL0NbXv72o6RNSbA/EIfmbzh5zDs2c69Aitfnz1FUDHGS-RU4QKHqkShZjzs'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Triple Ouput, 2 x 30V/3A plus 6V/6A, USB, RS232 & LAN Interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 303 QMT P,48.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL303QMTP,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782432/Instruments/Power%20Supplies/PL303QMD-P/PL303QMD-P.jpg,PL303QMT-P,Write a Python script that uses Qcodes to connect to a PL303QMT-P Power Supplies,1500.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
252,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,"[OrderedDict([('id', 'attroLUrhGS6YTlPy'), ('width', 400), ('height', 280), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Q5p5KrPvTTNHXi3i9wyvgQ/5qzzGd_SB5so1bdixwgDqdEZqgyi7NSQ-Gno1ziLvKnK604_lmVDCEA0MBg_0exVWli5GXNbkVFjvM8OXLyswwIVYg025bdBpHOuJYEUDNw/SPrUovEIUohe_tafHGvKLfcV0b9LiZpWHKhOV6oX_nc'), ('filename', 'Keysight_34411A_FS.jpg'), ('size', 12611), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Q2TwdjfPlpfX8Aa0GqUsPw/0RVrg6SgNUjgdmH6VeotRxkQL1rQC6jw3tnJOuAJ2RrotCwyjdsXRS-C9_HpJ892sPZ40_d2lAf2oYmw2muVuQ/mVVJt9K39D3k0nWHJv8tI3XWt9gC1Jfb5c7P2BvZ1Q4'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pZZ8gQ3dHhz7WaGTgOcIVA/HoYbxhISznSfG4YI90D8--CT9S6_X8dEUaNhW7c0LrvVKtk0WnX6VVfKScJr1OmEbEzDvNkTCbYEbY73NJ3whQ/PMH3odAxjRP8HB1V2_p1M9qcZaKu-Idi0IbqX-vCCFk'), ('width', 400), ('height', 280)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CWrl_lwEyp1XqkY5sZD8RA/Ydxg1TfLPdhgls2fOADuoPmbp9F3U-2DMP_FeRKCmn6-KZbq3_Od730j3smANHVrepn2l6t06-ALYXyo3aeHtQ/R2WPGnL2MR6FT0It7vXUkg3F0fAW0DZQoE___lU6onI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"The Keysight Technologies, Inc. 34411A multimeter gives you the performance you need for fast, accurate bench and system testing. The 34411A provides a combination of resolution, accuracy and speed that rivals DMMs costing many times more. 6½ digits of resolution",https://www.keysight.com/us/en/product/34411A/digital-multimeter-6-digit.html,Agilent 34411 A,29.0,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.Agilent34411A,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iBkD5hWEdE9VzBFEnSeOfA/NjWxUxjJA8yGPExBiN-PkZNjv4VfBExywq89pMu9c9Ra2W7et-Aw64QgEaSQebRctQuA2kL2PnwYRmggAnp4lSGJ5zznVS6ye7vLZh646iQ/Kl7uXhhhwfiGUId4CxlN-USzNex2x6CGk7CVIvfLvQ4'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f6t0-WbC6cKqyn0DT117iA/QPT0gpK6FG2qsOLK-bt0IxmOydbb6-9Pxg2hNGQF0mxWHfXPYXFiZagCw1Yj9qkKeKEbN-OQzc1R1_lDDq3DCa-N0BRerbz5SnzZQJlzbJ8/iuupeOUi0pSC13qOqrqjRHiA-gwJTseDKR1IenXqWtY'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cFs4Pvz6m9YFSFnAUBP9Jw/NgiAU7UcTKsj4PX6Lzw6SkhLC1rCN7-KpOyUy0E3yh7QLAbmpKXYyYKq1x_OkoLZAlEY7R20W5zF_Vo0-E3cUyiYsxgXKf9_RTswNy3Wd7w/GhCXNKTSYmUF5vw3ifd6HKHmQkYlHKJQaWCVYa06Xqg'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pxy_7pX_47hdW9iN2Gvi7A/4LRl2aDd8IoPIwJ53KRuFtJ4dEG8aRW8frebU514v4lYFkRRLyyF7Kcfv4Q3zGQT19g9Bs1hNet5CN1YxdFcjM9hQIBoBBiixzvExLQHvMM/RhEKW_l5u-Xiv303cIU5H_n4SPQvKttNDyTSjmqpWkI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782650/Instruments/Multimeters/Keysight-34411A/Keysight-34411A.jpg,Keysight 34411A,Write a Python script that uses Qcodes to connect to a Keysight 34411A Multimeters,,"
",True,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
254,https://www.alazartech.com/en/download/product/9057/307/ats9440-datasheet-and-specifications/1-4k/,https://en.wikipedia.org/wiki/Analog-to-digital_converter,"[OrderedDict([('id', 'attrPtY0K7DINPWdi'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xAglRZJYkWYhtW0Sjvhzmw/ypHzXgbqshSr5E4eAmMEXgMHO1leXrIAfjXxngAsHFaLtPDkauUjOL-HELSKKA9MChxsGHdIoFk3YotpQ--bUUmFvcemr9l92IDYCmylQM0/3fUik3FoqeLzToe-LUQxXogxsn00nrzYIkhB7rI2Fn0'), ('filename', 'ATS9440.jpg'), ('size', 572486), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/r8pXPWcZChjUcvJg02RDdQ/TnRj4l07zBTzZc5O5KCK0eGjy3N3V7027vTnywJ3wIxZO6_Qf5vRGUmSTojjF7PoN-hxN62KiV2A3tywMub5Tw/fHbm724C2JvkQ5uuzvoZBuJl_URG_ZkFAw-ZSC6JBXw'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aXVHPscQTSvxGhgnh6lISg/EnDyHwc-7EgU7b-d3_ZfGE67SIDWgOL-kJvmI-kQX1e8afTLkfQxzNzh4xc-_inZs_dn8ayll_EO7bxH-AmpeA/NCJIiMWeZfUvGuVnXT1hsLsJTG49SygN0w2GCICxEL0'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tt602G105A8jzC7aBebWiw/q1b8zFuRTbt9j8F7jhHo0BtPE5rdGicI1RRmCtcC6aVdXPlBGwz5Tmkdrk0abb8IhUBvbz6oH9z57P8dxg-C-w/p0o_tMTBlUKK34jWK-BE6fiR-EwItNxtHDdJlXenYxA'), ('width', 3000), ('height', 3000)]))]))])]",4.0,CANADA - QC,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692117216/Instruments/Vendor%20Logos/Alazartech.png,"ATS9440 is a 4-channel, 14-bit, 125 MS/s waveform digitizer based on the 8-lane PCI Express interface

",https://www.alazartech.com/en/product/ats9440/16/,ATS 9440,64.0,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AlazarTech/ATS9440.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AlazarTech.html#qcodes.instrument_drivers.AlazarTech.AlazarTechATS9440,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qAKVZnWakj3BsqaWIGBWRQ/ZrX_1_RMjBiSZrv9vP_57uXX3nVYvTG1M9yX0X0AbV2ABAwNqnlZ9ph2VxPWUntz57MfzGIcVtzwp_xIT4ogdpEUOSJkRSVjiQ9SdRaAR8Y/iqBF0wweZWGzh_PoUEPAoR1OMbJQ4ahE5SQ20efnW3w'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/c4okM_mAktf0nM5a4ujUcw/ojbZu24hQ3OsnpsLBQXtdSWuTk3Iklxwh_8h6Gu6nI-N-cZTED09W58zGdsdkzX784cjIMgM0mnM_Z10HE0DWw/-nQKXfI9UrjNxpUl6HPlw0VxPf0bhIFJu_puq3PBLH4'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wLU644oqMwyGp0nvbNsxWg/zc4O5FXXDWFC_3eWYDbTDhZ-8RKh4CywL6uxn3m30ZG4fRuCONJ6Iogf6ftQ_O_Q8qSa8Eq3C__L1bpo6Vc0tQ/tV1Jc99vngeTFMSvJRsKPiMPSZq261WWlEYFw6eF4dU'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pkhaW6W4s4X9DwUXiC5Qnw/twaNCkfaOpFsDIxJR3erWLY6uTRf-2naFC2FMhp_b49XItnrDMobUqWla3Gd6BRrhtn7cJNMypgCsWLD8PhzCw/_jkIrQ_2tQiU0GB3OhyCLuO6UO3JEk_1njNMezltdd4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782652/Instruments/DAQ%20boards/ATS9440---14-bit%2C-125-MS-s%2C-4-ch/ATS9440---14-bit_-125-MS-s_-4-ch.jpg,"ATS9440 - 14 bit, 125 MS/s, 4 ch","Write a Python script that uses Qcodes to connect to a ATS9440 - 14 bit, 125 MS/s, 4 ch DAQ boards",,"
",,,"from typing import Any

from qcodes import validators

from .ATS import AlazarTech_ATS
from .utils import TraceParameter


class AlazarTechATS9440(AlazarTech_ATS):
    """"""
    This class is the driver for the ATS9440 board
    it inherits from the ATS base class
    """"""
    samples_divisor = 32
    channels = 4

    def __init__(self, name: str,
                 dll_path: str = 'C:\\WINDOWS\\System32\\ATSApi.dll',
                 **kwargs: Any):
        super().__init__(name, dll_path=dll_path, **kwargs)

        # add parameters

        # ----- Parameters for the configuration of the board -----
        self.add_parameter(name='clock_source',
                           parameter_class=TraceParameter,
                           label='Clock Source',
                           unit=None,
                           initial_value='INTERNAL_CLOCK',
                           val_mapping={'INTERNAL_CLOCK': 1,
                                        'FAST_EXTERNAL_CLOCK': 2,
                                        'SLOW_EXTERNAL_CLOCK': 4,
                                        'EXTERNAL_CLOCK_10MHz_REF': 7})
        self.add_parameter(name='external_sample_rate',
                           parameter_class=TraceParameter,
                           label='External Sample Rate',
                           unit='S/s',
                           vals=validators.MultiType(validators.Ints(1000000, 125000000),
                                                     validators.Enum('UNDEFINED')),
                           initial_value='UNDEFINED')
        self.add_parameter(name='sample_rate',
                           parameter_class=TraceParameter,
                           label='Internal Sample Rate',
                           unit='S/s',
                           initial_value=100000000,
                           val_mapping={1_000: 1,
                                        2_000: 2,
                                        5_000: 4,
                                       10_000: 8,
                                       20_000: 10,
                                       50_000: 12,
                                      100_000: 14,
                                      200_000: 16,
                                      500_000: 18,
                                    1_000_000: 20,
                                    2_000_000: 24,
                                    5_000_000: 26,
                                   10_000_000: 28,
                                   20_000_000: 30,
                                   50_000_000: 34,
                                  100_000_000: 36,
                                  125_000_000: 38,
                             'EXTERNAL_CLOCK': 64,
                                  'UNDEFINED': 'UNDEFINED'})
        self.add_parameter(name='clock_edge',
                           parameter_class=TraceParameter,
                           label='Clock Edge',
                           unit=None,
                           initial_value='CLOCK_EDGE_RISING',
                           val_mapping={'CLOCK_EDGE_RISING': 0,
                                        'CLOCK_EDGE_FALLING': 1})
        self.add_parameter(name='decimation',
                           parameter_class=TraceParameter,
                           label='Decimation',
                           unit=None,
                           initial_value=1,
                           vals=validators.Ints(1, 100000))
        for i in range(1, self.channels+1):
            self.add_parameter(name=f'coupling{i}',
                               parameter_class=TraceParameter,
                               label=f'Coupling channel {i}',
                               unit=None,
                               initial_value='DC',
                               val_mapping={'AC': 1, 'DC': 2})
            self.add_parameter(name=f'channel_range{i}',
                               parameter_class=TraceParameter,
                               label=f'Range channel {i}',
                               unit='V',
                               initial_value=0.1,
                               val_mapping={0.1: 5,
                                            0.2: 6,
                                            0.4: 7,
                                            1: 10,
                                            2: 11,
                                            4: 12})
            self.add_parameter(name=f'impedance{i}',
                               parameter_class=TraceParameter,
                               label=f'Impedance channel {i}',
                               unit='Ohm',
                               initial_value=50,
                               val_mapping={50: 2})

            self.add_parameter(name=f'bwlimit{i}',
                               parameter_class=TraceParameter,
                               label=f'Bandwidth limit channel {i}',
                               unit=None,
                               initial_value='DISABLED',
                               val_mapping={'DISABLED': 0,
                                            'ENABLED': 1})
        self.add_parameter(name='trigger_operation',
                           parameter_class=TraceParameter,
                           label='Trigger Operation',
                           unit=None,
                           initial_value='TRIG_ENGINE_OP_J',
                           val_mapping={'TRIG_ENGINE_OP_J': 0,
                                        'TRIG_ENGINE_OP_K': 1,
                                        'TRIG_ENGINE_OP_J_OR_K': 2,
                                        'TRIG_ENGINE_OP_J_AND_K': 3,
                                        'TRIG_ENGINE_OP_J_XOR_K': 4,
                                        'TRIG_ENGINE_OP_J_AND_NOT_K': 5,
                                        'TRIG_ENGINE_OP_NOT_J_AND_K': 6})
        n_trigger_engines = 2

        for i in range(1, n_trigger_engines+1):
            self.add_parameter(name=f'trigger_engine{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Engine {i}',
                               unit=None,
                               initial_value='TRIG_ENGINE_' + ('J' if i == 1 else 'K'),
                               val_mapping={'TRIG_ENGINE_J': 0,
                                            'TRIG_ENGINE_K': 1})
            self.add_parameter(name=f'trigger_source{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Source {i}',
                               unit=None,
                               initial_value='EXTERNAL',
                               val_mapping={'CHANNEL_A': 0,
                                            'CHANNEL_B': 1,
                                            'EXTERNAL': 2,
                                            'DISABLE': 3,
                                            'CHANNEL_C': 4,
                                            'CHANNEL_D': 5})
            self.add_parameter(name=f'trigger_slope{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Slope {i}',
                               unit=None,
                               initial_value='TRIG_SLOPE_POSITIVE',
                               val_mapping={'TRIG_SLOPE_POSITIVE': 1,
                                            'TRIG_SLOPE_NEGATIVE': 2})
            self.add_parameter(name=f'trigger_level{i}',
                               parameter_class=TraceParameter,
                               label=f'Trigger Level {i}',
                               unit=None,
                               initial_value=140,
                               vals=validators.Ints(0, 255))
        self.add_parameter(name='external_trigger_coupling',
                           parameter_class=TraceParameter,
                           label='External Trigger Coupling',
                           unit=None,
                           initial_value='DC',
                           val_mapping={'AC': 1, 'DC': 2})
        self.add_parameter(name='external_trigger_range',
                           parameter_class=TraceParameter,
                           label='External Trigger Range',
                           unit=None,
                           initial_value='ETR_5V',
                           val_mapping={'ETR_5V': 0, 'ETR_TTL': 2})
        self.add_parameter(name='trigger_delay',
                           parameter_class=TraceParameter,
                           label='Trigger Delay',
                           unit='Sample clock cycles',
                           initial_value=0,
                           vals=validators.Multiples(divisor=8, min_value=0))
        self.add_parameter(name='timeout_ticks',
                           parameter_class=TraceParameter,
                           label='Timeout Ticks',
                           unit='10 us',
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        #  The card has two AUX I/O ports, which only AUX 2 is controlled by
        #  the software (AUX 1 is controlled by the firmware). The user should
        #  use AUX 2 for controlling the AUX via aux_io_mode and aux_io_param.
        self.add_parameter(name='aux_io_mode',
                           parameter_class=TraceParameter,
                           label='AUX I/O Mode',
                           unit=None,
                           initial_value='AUX_OUT_TRIGGER',
                           val_mapping={'AUX_OUT_TRIGGER': 0,
                                        'AUX_IN_TRIGGER_ENABLE': 1,
                                        'AUX_IN_AUXILIARY': 13})
        self.add_parameter(name='aux_io_param',
                           parameter_class=TraceParameter,
                           label='AUX I/O Param',
                           unit=None,
                           initial_value='NONE',
                           val_mapping={'NONE': 0,
                                        'TRIG_SLOPE_POSITIVE': 1,
                                        'TRIG_SLOPE_NEGATIVE': 2})

        #  The above parameters are important for preparing the card.
        self.add_parameter(name='mode',
                           label='Acquisition mode',
                           unit=None,
                           initial_value='NPT',
                           set_cmd=None,
                           val_mapping={'NPT': 0x200,
                                        'TS': 0x400})
        self.add_parameter(name='samples_per_record',
                           label='Samples per Record',
                           unit=None,
                           initial_value=1024,
                           set_cmd=None,
                           vals=validators.Multiples(
                                divisor=self.samples_divisor, min_value=256))
        self.add_parameter(name='records_per_buffer',
                           label='Records per Buffer',
                           unit=None,
                           initial_value=10,
                           set_cmd=None,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffers_per_acquisition',
                           label='Buffers per Acquisition',
                           unit=None,
                           set_cmd=None,
                           initial_value=10,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='channel_selection',
                           label='Channel Selection',
                           unit=None,
                           set_cmd=None,
                           initial_value='AB',
                           val_mapping={'A': 1,
                                        'B': 2,
                                        'AB': 3,
                                        'C': 4,
                                        'AC': 5,
                                        'BC': 6,
                                        'D': 8,
                                        'AD': 9,
                                        'BD': 10,
                                        'CD': 12,
                                        'ABCD': 15})
        self.add_parameter(name='transfer_offset',
                           label='Transfer Offset',
                           unit='Samples',
                           set_cmd=None,
                           initial_value=0,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='external_startcapture',
                           label='External Startcapture',
                           unit=None,
                           set_cmd=None,
                           initial_value='ENABLED',
                           val_mapping={'DISABLED': 0X0,
                                        'ENABLED': 0x1})
        self.add_parameter(name='enable_record_headers',
                           label='Enable Record Headers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x8})
        self.add_parameter(name='alloc_buffers',
                           label='Alloc Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x20})
        self.add_parameter(name='fifo_only_streaming',
                           label='Fifo Only Streaming',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x800})
        self.add_parameter(name='interleave_samples',
                           label='Interleave Samples',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x1000})
        self.add_parameter(name='get_processed_data',
                           label='Get Processed Data',
                           unit=None,
                           set_cmd=None,
                           initial_value='DISABLED',
                           val_mapping={'DISABLED': 0x0,
                                        'ENABLED': 0x2000})
        self.add_parameter(name='allocated_buffers',
                           label='Allocated Buffers',
                           unit=None,
                           set_cmd=None,
                           initial_value=4,
                           vals=validators.Ints(min_value=0))
        self.add_parameter(name='buffer_timeout',
                           label='Buffer Timeout',
                           unit='ms',
                           set_cmd=None,
                           initial_value=1000,
                           vals=validators.Ints(min_value=0))


class AlazarTech_ATS9440(AlazarTechATS9440):
    """"""
    Alias for backwards compatibility. Will eventually be deprecated and removed
    """"""

    pass
"
256,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attKNoonyjcAjx8df'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3SXdF9KyMy6G5ADN-tZOYA/BWMD2o5MHSUZw9RBHtbwBQU83zgNtRoixwILAXg0dN2qO8xs_BZqiXB-GJnVMUGcqUVjC7KgaZJNHg-0BTegxBD4MDm-FbjM04-zVz-C8qpBGMwjbo2mFsm7WWBLFRyz/QxRvSJBmhKJBoWEhT6DSvIO7-65mBku1XCqCxKp8L1c'), ('filename', '34465A-TRANSP-01_1600x900.png'), ('size', 1368787), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/royewhR4K3MjS73Oc95iYA/qqypblvd22V2CUn7v-Hd6QjOiekjwerZVcZoIERMDwzpw6hvIpCa1-Srand5viUB_QlomyAFtJ22Jegk8zIbFg/N8fTBv4FA5XfNe7z_IeyaC2TExOmX9du2gwJKQLhA5k'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0wGOhxK3JZnshrU3nyTrWg/8bJZrXnrJzwbgf5rncCE_Jvibhc00SjlXgAvSZjetWzsUjiFCvYTYo9nEwEsrQZSzkCYI23SGTwD_H1174zvgw/QYVOuAWAnYoNVS3vDcnJ38gh_-7YNm2g6Du6z87oANs'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LqwN6K_LG52qwSU5tNlZZg/0zj-nvFIB9xmV8fDb6pb1cuAqCiiHkBdOhfsnMZAF2lt6CJhul_a_2qF8IGhkYAvRpYXRIvRHsItmyiZVLm2aA/EZxPRirHl8cBYf_tz_qROKs47ylHAzL0DwkMWyhbYxg'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34465 A Submodules,274.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34465A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34465A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782654/Instruments/Multimeters/Keysight-34465A-Submodules/Keysight-34465A-Submodules.png,Keysight 34465A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34465A Submodules Multimeters,1863.0,,True,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34465A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34465A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34465A(Keysight34465A):
    """"""
    Alias for backwards compatibility.
    """"""
"
257,,https://en.wikipedia.org/wiki/Dilution_refrigerator,"[OrderedDict([('id', 'attDgFc8ZjdWhfvIa'), ('width', 1500), ('height', 1500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DZQpLjqAsB8SY_1Pa2xUgA/jkcqBLnNtluOgWdWJIhNWLDbbaVUHneAQ6-fY9mdfBNUbCXRoBsU8UIOKpWJ3_ZNXwDqDnDFgzmtqQVJzsd5a4rzH3jf-X4t6odgeVpqi1c/BKKp8IPpTvVJZC-gACCKwBZTho6IaxUu4t8MK34QvKk'), ('filename', 'triton.jpeg'), ('size', 84454), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ze2jRM_uzS4sv-W4ekj7IQ/LskzWPLBfMd3WQa9SQD_x6B1cg0gPRj8uc6JtlHGD7ihDnDntT3oys9arwU5XcWOSxhnxAsB1v4KXk1HFDqZfQ/ZVlWh7BEf2D_gIKop8mq62kyYbvlplaAiJD5jXC6-wU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Wi5vjW1yWL0HvOmYuXh8XA/ynm4p3OlG9aqaMh3U_cumir-MafTeHe2Y4iXHQQ00wlS6XPo9ImrXYsaYzcoBVl3GMNM2nXng1-Wp9tj1yspUw/RvnhEUIXozHS2pgQeGmQSnxx3oTOss-sxSOP9MLVEaA'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kUHwqh3W8rVbki2jOHQSdw/B_rF2Izohs0ssP4b6OmGN6YvCDLWogmZokmVEk8KdQHVrJQiTJDIWxYfSkxjN_boqXKv1r3JHys7ruLFHeCiqw/m23zkLoKbRM955R9mfU-d6ksrw7dKV56StQSdiBtfVs'), ('width', 3000), ('height', 3000)]))]))])]",367.3,"Abingdon, United Kingdom",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116704/Instruments/Vendor%20Logos/Oxford_Instruments.png,"The Triton family of cryogen free dilution refrigerators has led
the way in ultra-low temperature experiment-readiness with its
leading-edge superconducting magnet integration, sample loading
mechanisms and sample wiring options.
With over 300 systems installed worldwide, Triton is used in worldleading science across quantum technology, spintronics, optics and
many other cutting-edge applications of condensed matter physics.",https://nanoscience.oxinst.com/assets/uploads/products/nanoscience/documents/4640_NS_Triton_Brochure.pdf,Triton,403.0,['Dilution Refrigerator'],"A 3He/4He dilution refrigerator is a cryogenic device that provides continuous cooling to temperatures as low as 2 mK, with no moving parts in the low-temperature region.[1][2] The cooling power is provided by the heat of mixing of the helium-3 and helium-4 isotopes.

The dilution refrigerator was first proposed by Heinz London in the early 1950s, and was experimentally realized in 1964 in the Kamerlingh Onnes Laboratorium at Leiden University.[3] The field of dilution refrigeration is reviewed by Zu et al.","Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",https://qcodes.github.io/Qcodes_contrib_drivers/_modules/qcodes_contrib_drivers/drivers/Oxford/Triton.html,Qcodes,https://qcodes.github.io/Qcodes_contrib_drivers/api/generated/qcodes_contrib_drivers.drivers.Oxford.html#qcodes_contrib_drivers.drivers.Oxford.Triton.Triton,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ge6UBa_PxVIRzTWaSDRhWw/z1nIIHpByPxcMFrxqz4wGua6L37TPuzjwuecyLHCFzr-uz84QG2przENPF1hXhY8XoqufraDY0oOQ6SMKew6m8dr0TjAnZhETraeiUtpcEI/9z2Sye-RWq0CT52RGvMeiR8CoeXPWB3yYto48j5ieq8'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/huAYtj4AqjzWQwtFbrocBw/ObKFsL5lrDEKZIzYosPMMAHykYqLRJhZzGmq81EktzRrWlN1S0qoVcGN10kXdT_Lcl-YwpqbQ2uXXTE58cUAzQ/sS56sfdd-S0WOj9HXdamH5KqMh4t3BlzRGkZDN_4h8I'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3otB5nYeU1qyF_laf_uciQ/En9x8ndMr6huc_UqR3iTmKE7EyJOmI-pqJKGxD_1iQvmC27k0lNw207b0eeZSFnZxVvJgXyx4wB4_l_J2ViTZw/kpdiY6dHLy4RY1bNMbPeMG-6iXXcT4BwYVW_BNY0ze0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/bAQ9fOdp4fpHrIZL81i94w/dMc4vF9YSwqzuMc-sTB3iNls2t10Mo2tTfN1WMu9NQVaU_lvrq0ZLAhHh3WITeRd-flcjLvDijuR9i3SR8DqpA/GATYdc8TgmKLFz9DOI7DBZrtskXNPyb33IysjQXKBrg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782655/Instruments/Dilution%20Refrigerator/Triton/Triton.jpg,Triton,Write a Python script that uses Qcodes to connect to a {Device name} Dilution Refrigerator,,,,,
259,https://download.tek.com/document/55W-22447-9.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WsOWv-JV7GKaFSUmikElnA/FcE2F5kwbC0dzqe-VO-xxGIQCJmlulIzNnfzZypOHdnVxEl66Z9Iweqjumb81naKEWasCEM4NGZwyj0JDXI0g0v-xXmYW68-kFebXGLsa63OCBrZHqjw4gf7HwcYfPwEpTaatH0fva7J3tNudx5fsg/hG87vOaqGIL9d6DRm9Uyv_9s4a6YxEGPzRL6eUPJcxc'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/G3Xe1UXf174GIRLewzm6BQ/FuPBbb4fUhU1fLrJOR9j1Odv-iOmwveeAbhSfK9kdqjePdinC9gdOfOrwPk-4wTiLoxtvJMYk8CB5sgjkZJq6q9y95O9FOp4OZiO7GTf15o/L9COYzFW4Cq3OOmUhSdLg3Nt32vpNzAewgCllwRUv_k'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IDWJqZT2JqdkvKYnCqljLg/h3HDNdNTlG7iymZ0SwPVXgKO0dyu5UyfioiXD1cxdN-XVzBW-qo1pA5i09ljVODVZO0Ba6kOz8EPus_YBn0d1Mpp-lokwwUFKU0laO1ciHM/Ry0cQ8w_ZnwfuKzQuGu3rt_q1WoGDaYTg_H5Z8Ez5aE'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PxxO2zEVzSVGNSsb0WoVzg/os-KcM5U58Vxh5oHKo6M_LujGceSAVD4hLgINBBluDlRZ16Z54YK_pHadcTJTE8dh3msKZCO7866ZWm-TP4Dxan-YDm288-vvPFPCPZ-55I/vxCUn8Gvs_cR2czq6DM4VFZRUReLTiHb-l-QcV-haS8'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,Tektronix DPO 70000,582.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO70000,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782501/Instruments/Oscilloscopes/DPO70000/DPO70000.webp,DPO70000,Write a Python script that uses Qcodes to connect to a DPO70000 Oscilloscopes,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
265,https://download.tek.com/datasheet/AWG70000A-Arbitrary-Waveform-Generator-Datasheet-76W283808.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attjBjCeEspyu9dpX'), ('width', 294), ('height', 220), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/83pRQB1C96v5KVs6-ubsLg/bKx1THicRj2EQ3vcWzq-lbbqsp6CA81Sa5ATjngn4x2gha4bOxSveorcntYOJFI8ICRPpGlcyChLVVZGi8fXzSrqgWpVEhRV4jqqAfgmGDnWGYua69F4h_AdwfXTTKKVTMeO37lXn8FlFUYiD5NYKg/yc-LlB89SEfEjfHdmXPqm5c9fqGdN1CGOyg6lt-cIFY'), ('filename', '02aadca4ffd655cc627bb76eb7983ba7_1490966598.webp'), ('size', 4594), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/R5b9rPzlaWWD8Cn9cdFfsA/se1G5_Etx4cr36bqVoWgCy_4VOnOPO26vjwzTnBTqoj3INrfdP5o6Jl6cHQ1_s2p9it-vn_Yr8Zhpm1bNj82uYECCAolacD19dszIgcJkdo/a3zSPX1k2G2V7WjVqJHS7CcpC8D15-letW7I_JRBfKQ'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2A9af5CbJYMvlC93dd1doQ/kZPxDg7_jQ2A46LtMQJDJOhWnEVYbD3HLoEm5fcDL-GDVLzWcPpvGyPvaWoH_VRUDnJZslzd7arj77h6u6sSBXLKm47BOsE7M0sHMcevC0E/-KSZaZsUNpv3GFlRfxLoZLiHAZYgTedqaMT3FvlkGyY'), ('width', 294), ('height', 220)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VK4-uuPGBTJe-14IKSQpyw/JV_Gn26QjBuDucXR1L7G1dkpU6MfiwBRn_s-3fXZwTM06Y-qHzTI7Qjj1KOZS-_d5hzD9k2NxoDpBOjAbdxREJcNO1OUydnj9qvruISQsIY/bZLktCC59aFTgDdd5IHyv_ZxrPvtHuq-XhpvJHe8-uU'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The industry-leading AWG70000A Series arbitrary waveform generator (AWG) provides you with unparalleled performance at the cutting edge for sample rate, signal fidelity, and waveform memory. In order to engineer the world's most complex data communications systems, the ability to create ideal, distorted and ""real life"" signals is essential. The AWG70000A Series of AWGs delivers this, giving you the industry's best signal stimulus solution for ever-increasing measurement challenges. With up to 50 GS/s and 10-bit vertical resolution, it offers easy generation of very complex signals and complete control over signal characteristics",https://www.tek.com/en/datasheet/arbitrary-waveform-generators-1,AWG 70000 A,572.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001A,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782662/Instruments/RF%20Signal%20Generator/AWG70000A/AWG70000A.webp,AWG70000A,Write a Python script that uses Qcodes to connect to a AWG70000A RF Signal Generator,,,True,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
271,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,https://en.wikipedia.org/wiki/Arbitrary_waveform_generator,"[OrderedDict([('id', 'attpW6fjxWdbx7J2i'), ('width', 1418), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/prBq38USJpKeR9wmgo_UfA/khqg5xX1ggU5U7nAoUBXohzbV_4FWpRY7YPcolp-g4T_n8FCur64BPL2YC--5u8Ez6dYTSyAtmPqdz49kjkmasxvuiHQmM5QH0vXbe0NHXA/rou4SW4Ltopmt-s8oJLEATMycPgQkFzO-RcMUa1wEpU'), ('filename', '94T6987-40.jpg'), ('size', 99871), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IHn--6VHwFmfPjnydio2Bg/0SlgCqHCOrSUGFXHWfogNP1DDmQAum0BOs5bAwpDaRcyglMImHm_X3Hcuthf8k7XCnuC0MDIT-Cu907ikChAUw/E2Oyu16qcAlOlZ2f74FoQZNOgZlv03Czh6ImIFW7-_E'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hCdyRiIGsnUwUuWEOQ-69g/gE1MpBCdJJg5l4VaHRuJi5IyUiVs9STYLKoG8LOwcwU0crxVKoefqRt6VQo1uG2XxJT6UpCY_GHYaMRFq4NCQg/nbWScJL2RZDnVmfBv19x4Yu_BPC8BclRctkkiRbzwJ0'), ('width', 980), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uc0eu4i0ofmYBS1hzXFYHQ/jzCArbZU3ntSxSsAnuQdI8M7XqsLYIsphEgh_BF_eG6dBzw5Vi6ssr3BS0DNjIIRLNuHcckw-QZQA3r1PjFyqQ/Eq7TLtaQfhSolEeNyP1JtwOYuFJO-7weDnw2QqZQpk4'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 33512B provides Keysight’s exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements. The 33512B can be easily upgraded to 30 MHz as your needs change.

",https://www.keysight.com/us/en/product/33512B/waveform-generator-20-mhz-2-channel-arb.html,Keysight 33512 B,291.0,['RF Signal Generator'],An arbitrary waveform generator (AWG) is a piece of electronic test equipment used to generate electrical waveforms. These waveforms can be either repetitive or single-shot (once only) in which case some kind of triggering source is required (internal or external).,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33512B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782667/Instruments/RF%20Signal%20Generator/Keysight-33512B/Keysight-33512B.jpg,Keysight 33512B,Write a Python script that uses Qcodes to connect to a Keysight 33512B RF Signal Generator,4187.0,,,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
274,https://www.testequipmenthq.com/datasheets/KEITHLEY-2601-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'att4qoFB6Y2hcqftg'), ('width', 800), ('height', 428), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-aiAJmkl6AfMccX3LCreng/xa4Ku8GuOIY-1VZZ7Xc5BsV_p8P0QAQu3_cJAn6x9OMNg_PnpHpQNeWpQRV4lXWaWGJYKQ7DatkMFVTPPJaWvFo1hKOwKEvIgt-bxZFVItA/vwptyerfKDJoa5gqp6GGTpviK-_JOMU-W-FmbOJB9Nc'), ('filename', '2601b.webp'), ('size', 29670), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DHRLfV9k3cxF-uJcuRL8BQ/2GptLWZmIfofnw3R1U6j6ze3rNmOSS5g-mleT6-5T1_PRGEVwVhvwGiu3NPAji90bQN7sVS59bwgYpRk-O2-w_fK5vWR4iRA1bjDpanZgo0/KoqhrzzonPIagSrzGC01l6DfwZVpIKYoo92Qc1T_qiQ'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RLSLEyRZLHw2J8XyB8Z9YA/fP_1RJbU3d2xncG6rl4jXa0INX_LYWqQam0YtCT5XV3fKUnlk9kjls-5csao1Tk_aFLgC9nZlGYOaahlooOZuBjBdnUIc2jCfcSCY7pwOOs/LSQBZdTSbaBV12lKsS0Z_P5DcwI0_gzTqYjgi6gNhwg'), ('width', 800), ('height', 428)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/2BJgyEBdBMp6u6fT-PYmEg/8ec-csbcU5hGiBf36h1rKfpOFBVTevBx-S8xSVV-DAl0cIhQB61sf3DJuUIkCHlvtm9fdluZOnGCfLv8VOBX-WqqJ71a25iEz7GWiEr-LKw/x8a2_XkFQ9j4pZRas3tIq7sQtclXk-U-mc6i_bfRe4M'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The Model 2601B SourceMeter SMU instrument, is a new and improved one channel SMU instrument with a tightly integrated four-quadrant design that allows it to simultaneously source and measure both voltage and current to boost productivity in applications ranging from R&D to automated production test. In addition to retaining all the features of the Model 2601A, the Model 2601B has 6½-digit resolution, USB 2.0 connectivity, and software command emulation of the Model 2400 SourceMeter SMU Instrument that enables easy migration of legacy test code. The Model 2601B model is equipped with Keithley's high speed TSP technology (over 190% faster than traditional PC-to-instrument communication techniques,) which dramatically improves the system-level speed to lower the cost of test.",https://canada.newark.com/keithley/2601b/source-meter-voltage-current-40/dp/44W8033,Keithley 2601 B,244.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2601B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782670/Instruments/Power%20Supplies/Keithley-2601B/Keithley-2601B.webp,Keithley 2601B,Write a Python script that uses Qcodes to connect to a Keithley 2601B Power Supplies,20700.0,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
276,https://docs.zhinst.com/pdf/ziPQSC_UserManual.pdf,https://www.zhinst.com/americas/en/quantum-computing-systems/qccs,"[OrderedDict([('id', 'att6goJYKFtx2hmvC'), ('width', 1183), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZE-Z-loD3SNOUqb4-WIHjA/DfzHqyqqhUbP9N3npi1bK4KLHTr9L_dY4DDQns4OnO1bNJsyeTpA-bzty-lkBrFUI5K9-dUodVvdHlWhRR5uPmNhM6dx-5xT1IN_bZXgXlNk6XWngdJeRZ2bt792C2Xu/c-EOmRMBiRQaWbfcagElAUslYYZ5VUjqSHOl2Uii73o'), ('filename', 'PQSC_front_rackmounts_1800.png.webp'), ('size', 20698), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eQNP_v5uTXn8X2yBGVU9EA/DmwsjCnt4sICL6vJZJg_GMrzQQBijBQaocK-pi33wud-yQ92q3u1HhFh-wpOwjC3_vcvQdUeneRt05AhbBMNlC6HGQQh6ExCzifXR4J5oyU/hhGZebiDGBR-OV70Ah7uf3Z5W8t_3Asv3PTe0w3ZHWY'), ('width', 138), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9tgaOyJkf5n_P7p24Sz8SA/VLYh1oZ_UJhlE-Cx9ljruxR5do9oZenkCAHLdrlZl5NCem9EIifb0M3r7WWddlaAU5_CUVCoiMM0V_jWkbriMUtgmFRCADzv2anxoBHh76E/8Jcu_LK1gZ9s82YzvLQjr8ZOIKNguMF9lJfg_izRFIk'), ('width', 1183), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Or4g_UWmFriGjzrcCOXjWw/dIllSgFyx37wNzmT6qLaa74hUOSQOuOgN0dbdscCFvK08KehfmJ0xcsQrccla9G5wxClTA-n98XMyf5wHhQY6_ObKVkmFMbMTXRb5mKDTtI/qBf1C0utqC3KknbNApzHsXbQl75KW83a7K4lhv7cFEA'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments PQSC Programmable Quantum System Controller brings together the instrumentation required for quantum computers with up to 100 qubits. Its ZSync low-latency, real-time communication links are designed specifically for quantum computing: the PQSC overcomes the practical limitations of traditional control methods, making automated and rapid qubit calibration routines a reality. Programming access to the powerful Xilinx UltraScale+ FPGA is the basis for developing new and optimized processing solutions for rapid tune-up and error correction adapted to the specific algorithm and computer architecture in use.",https://www.zhinst.com/americas/en/products/pqsc-programmable-quantum-system-controller,Pqsc,642.0,['Quantum Computing Control System'],"A Quantum Computing Control System (QCCS) is designed to control more than 100 superconducting and spin qubits. Each component of the QCCS is conceived to play a specific role in qubit control, readout and feedback, and operates in a fully synchronized manner with the other parts of the system.","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/pqsc.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.pqsc.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782671/Instruments/Quantum%20Computing%20Control%20System/PQSC/PQSC.webp,PQSC,Write a Python script that uses Qcodes to connect to a PQSC Quantum Computing Control System,,,,,"""""""Autogenerated module for the PQSC QCoDeS driver.""""""
from typing import List, Union
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument


class PQSC(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments PQSC.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""

    def arm(self, *, deep=True, repetitions: int = None, holdoff: float = None) -> None:
        """"""Prepare PQSC for triggering the instruments.

        This method configures the execution engine of the PQSC and
        clears the register bank. Optionally, the *number of triggers*
        and *hold-off time* can be set when specified as keyword
        arguments. If they are not specified, they are not changed.

        Note that the PQSC is disabled at the end of the hold-off time
        after sending out the last trigger. Therefore, the hold-off time
        should be long enough such that the PQSC is still enabled when
        the feedback arrives. Otherwise, the feedback cannot be processed.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after stopping the PQSC and clearing the
                register bank (default: True).
            repetitions: If specified, the number of triggers sent
                over ZSync ports will be set (default: None).
            holdoff: If specified, the time between repeated
                triggers sent over ZSync ports will be set. It has a
                minimum value and a granularity of 100 ns
                (default: None).

        """"""
        return self._tk_object.arm(deep=deep, repetitions=repetitions, holdoff=holdoff)

    def run(self, *, deep: bool = True) -> None:
        """"""Start sending out triggers.

        This method activates the trigger generation to trigger all
        connected instruments over ZSync ports.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after enabling the PQSC (default: True).

        """"""
        return self._tk_object.run(deep=deep)

    def arm_and_run(self, *, repetitions: int = None, holdoff: float = None) -> None:
        """"""Arm the PQSC and start sending out triggers.

        Simply combines the methods arm and run. A synchronization
        is performed between the device and the data server after
        arming and running the PQSC.

        Args:
            repetitions: If specified, the number of triggers sent
                over ZSync ports will be set (default: None).
            holdoff: If specified, the time between repeated
                triggers sent over ZSync ports will be set. It has a
                minimum value and a granularity of 100 ns
                (default: None).

        """"""
        return self._tk_object.arm_and_run(repetitions=repetitions, holdoff=holdoff)

    def stop(self, *, deep: bool = True) -> None:
        """"""Stop the trigger generation.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after disabling the PQSC (default: True).

        """"""
        return self._tk_object.stop(deep=deep)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until trigger generation and feedback processing is done.

        Args:
            timeout: The maximum waiting time in seconds for the
                PQSC (default: 10).
            sleep_time: Time in seconds to wait between
                requesting PQSC state

        Raises:
            TimeoutError: If the PQSC is not done sending out all
                triggers and processing feedback before the timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def check_ref_clock(self, *, timeout: int = 30, sleep_time: int = 1) -> bool:
        """"""Check if reference clock is locked successfully.

        Args:
            timeout: Maximum time in seconds the program waits
                (default: 30).
            sleep_time: Time in seconds to wait between
                requesting the reference clock status (default: 1)

        Raises:
            TimeoutError: If the process of locking to the reference clock
                exceeds the specified timeout.
        """"""
        return self._tk_object.check_ref_clock(timeout=timeout, sleep_time=sleep_time)

    def check_zsync_connection(
        self,
        ports: Union[List[int], int] = 0,
        *,
        timeout: int = 30,
        sleep_time: int = 1,
    ) -> Union[List[bool], bool]:
        """"""Check if the ZSync connection on the given port(s) is established.

        This function checks the current status of the instrument connected to
        the given ports.

        Args:
            ports: The port numbers to check the ZSync connection for.
                It can either be a single port number given as integer or a list
                of several port numbers. (default: 0)
            timeout: Maximum time in seconds the program waits (default: 30).
            sleep_time: Time in seconds to wait between requesting the reference
                clock status (default: 1)

        Raises:
            TimeoutError: If the process of establishing a ZSync connection on
                one of the specified ports exceeds the specified timeout.
        """"""
        return self._tk_object.check_zsync_connection(
            ports=ports, timeout=timeout, sleep_time=sleep_time
        )

    def find_zsync_worker_port(self, device: ZIBaseInstrument) -> int:
        """"""Find the ID of the PQSC ZSync port connected to a given device.

        Args:
            pqsc: PQSC device over whose ports the research shall be done.
            device: device for which the connected ZSync port shall be found.

        Returns:
            Integer value represent the ID of the searched PQSC Zsync port.

        Raises:
            ToolkitError: If the given device doesn't appear to be connected
                to the PQSC via ZSync.

        .. versionadded:: 0.5.1
        """"""
        return self._tk_object.find_zsync_worker_port(device=device._tk_object)
"
278,,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'atts4XZWkT4pxuTR4'), ('width', 300), ('height', 166), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jVK0kONjvPbmZ0uoDHGT2A/l4fgBfocf9h_si2AzEyzLKfnjr4rm3_SlocriAkQYqTl2s-Rd-m1oiMlQhLcUimL3jBfLayOaCCui2qy-9EgGavSqiNQ7ccnYm_VyyFXpfM/5b1hh451hLUhf7P5GrvpNEI6chnNOb_KS_FWnw8E8GE'), ('filename', 'PROD-2917039-01.jpeg'), ('size', 7332), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/in8_ns24U8UjvvzSk1q1-Q/weQPMyhwP8N4AFqtB5-98sTdQ__ncNLIZbI8S55MwVRyTBed-nWBr1cmHGBeAOjBwda8YQlw3MaxAE9GRZBN_g/5oIrAjpQqFJxEuNizCCWk4rcLhy0oU70cAhU1EaEc3M'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_09enE9ZSUqP_dkm212aWg/X6IyzXiM6X-WoPgH1x_M_0wvXDrLtNriucUCncouFcbwpT5fQ-Eh7HCE9wm_CvgF9TLpKSupssMDg_3ylUEnCQ/9Crpr4QZ--6Yd2pyz4miVc1oZgUG7kgzjBk3p-tu3Q0'), ('width', 300), ('height', 166)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rAf80vpQgQb0-GUenKqqDA/eS8th8WwffsxfdKxs705Md4dclc3VebKRXDW7zLcHqBd7n8UbmwFUtNRsrfQP_13b3XvlVLMLWmdMIGtRSR5CQ/iCGD2IUvflWgLKFaw6LkbJ_Qb2apnCYnL-1zddoK7kA'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,,,"Ktmawg
",285.0,['RF Signal Generator'],"An arbitrary waveform generator (AWG or ARB) is a sophisticated signal generator that generates arbitrary waveforms within published limits of frequency range, accuracy, and output level. Unlike a function generator that produces a small set of specific waveforms, an AWG allows the user to specify a source waveform in a variety of different ways.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KtMAwg.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightM9336AAWGChannel,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782673/Instruments/RF%20Signal%20Generator/KtMAwg-IVI-C/KtMAwg-IVI-C.jpg,KtMAwg IVI-C,Write a Python script that uses Qcodes to connect to a KtMAwg IVI-C RF Signal Generator,,,,,"from .KtMAwgDefs import *

import ctypes
from functools import partial
from typing import Dict, Optional, Any

from qcodes.instrument.base import Instrument
from qcodes.instrument.channel import InstrumentChannel
from qcodes.utils.validators import Numbers
from qcodes.utils.helpers import create_on_off_val_mapping


class KtMAWGChannel(InstrumentChannel):
    """"""
    Represent the three channels of the Keysight KTM Awg driver.
    The channels can be independently controlled and programmed with
    seperate waveforms.
    """"""

    def __init__(self, parent: 'KtMAwg', name: str, chan: int) -> None:

        # Sanity Check inputs
        if name not in [""ch1"", ""ch2"", ""ch3""]:
            raise ValueError(f""Invalid channel: {name}, expecting ch1:ch3"")
        if chan not in [1, 2, 3]:
            raise ValueError(f""Invalid channel: {chan}, expecting ch1:ch3"")

        super().__init__(parent, name)
        self._channel = ctypes.create_string_buffer(
            f""Channel{chan}"".encode(""ascii"")
        )

        # Used to access waveforms loaded into the driver
        self._awg_handle: Optional[ctypes.c_int32] = None

        self._catch_error = self.root_instrument._catch_error

        self.add_parameter(
            ""output_term_config"",
            label=""Output Terminal Configuration"",
            get_cmd=partial(
                self.root_instrument._get_vi_int,
                KTMAWG_ATTR_TERMINAL_CONFIGURATION,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_int,
                KTMAWG_ATTR_TERMINAL_CONFIGURATION,
                ch=self._channel
            ),
            val_mapping={
                ""differential"": KTMAWG_VAL_TERMINAL_CONFIGURATION_DIFFERENTIAL,
                ""single"": KTMAWG_VAL_TERMINAL_CONFIGURATION_SINGLE_ENDED,
            },
        )

        self.add_parameter(
            ""operation"",
            label=""Operating Mode"",
            get_cmd=partial(
                self.root_instrument._get_vi_int,
                KTMAWG_ATTR_OPERATION_MODE,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_int,
                KTMAWG_ATTR_OPERATION_MODE,
                ch=self._channel
            ),
            val_mapping={
                ""continuous"": KTMAWG_VAL_OPERATE_CONTINUOUS,
                ""burst"": KTMAWG_VAL_OPERATE_BURST,
            },
        )

        self.add_parameter(
            ""output"",
            label=""Output Enable"",
            get_cmd=partial(
                self.root_instrument._get_vi_bool,
                KTMAWG_ATTR_OUTPUT_ENABLED,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_bool,
                KTMAWG_ATTR_OUTPUT_ENABLED,
                ch=self._channel
            ),
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""gain_config"",
            label=""AWG Gain Control Mode"",
            set_cmd=self._set_gain_control,
            get_cmd=self._get_gain_control,
            val_mapping={
                ""composite"": KTMAWG_VAL_GAIN_CONTROL_COMPOSITE,
                ""component"": KTMAWG_VAL_GAIN_CONTROL_COMPONENT,
            },
        )
        self.add_parameter(""gain"",
                           label=""Composite Output Gain"",
                           set_cmd=self._set_gain,
                           vals=Numbers(0, 0.7999),
                           get_cmd=None)

        self.add_parameter(
            ""analog_gain"",
            label=""Analog Output Gain"",
            vals=Numbers(0, 1.32),
            set_cmd=self._set_analog_gain,
            get_cmd=self._get_analog_gain,
        )

        self.add_parameter(
            ""digital_gain"",
            label=""Digital Output Gain"",
            vals=Numbers(0, 1.0),
            set_cmd=self._set_digital_gain,
            get_cmd=self._get_digital_gain,
        )

    def load_waveform(self, filename: str) -> None:
        path = ctypes.create_string_buffer(filename.encode(""ascii""))
        self._awg_handle = ctypes.c_int32(-1)
        status = self.root_instrument._dll.\
            KtMAwg_WaveformCreateChannelWaveformFromFile(
                self.root_instrument._session,
                self._channel,
                b""SineWaveform"",
                0, path,
                ctypes.byref(self._awg_handle),
            )
        self.root_instrument._catch_error(status)

    def clear_waveform(self) -> None:
        if self._awg_handle is not None:
            status = self.root_instrument._dll.KtMAwg_ClearArbWaveform(
                self.root_instrument._session, self._awg_handle
            )
            self._catch_error(status)
            self._awg_handle = None

    def play_waveform(self) -> None:
        if self._awg_handle is None:
            raise ValueError(""Waveform has not been loaded!"")

        status = self.root_instrument._dll.KtMAwg_ArbitrarySetHandle(
            self.root_instrument._session, self._channel, self._awg_handle
        )

        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_Resolve(
            self.root_instrument._session
        )
        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_Apply(
            self.root_instrument._session
        )
        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_InitiateGenerationByChannel(
            self.root_instrument._session, self._channel
        )
        self._catch_error(status)

    def stop_waveform(self) -> None:
        status = self.root_instrument._dll.KtMAwg_AbortGenerationByChannel(
            self.root_instrument._session, self._channel
        )
        self._catch_error(status)

    def _set_gain_control(self, val: int) -> None:
        self.root_instrument._dll.KtMAwg_ArbitrarySetGainControl(
            self.root_instrument._session, self._channel, val
        )

    def _get_gain_control(self) -> int:
        res = ctypes.c_int32(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetGainControl(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_analog_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetAnalogGain(
            self.root_instrument._session, self._channel, v
        )

    def _get_analog_gain(self) -> float:
        res = ctypes.c_double(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetAnalogGain(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_digital_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetDigitalGain(
            self.root_instrument._session, self._channel, v
        )

    def _get_digital_gain(self) -> float:
        res = ctypes.c_double(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetDigitalGain(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetGain(
            self.root_instrument._session, self._channel, v
        )


class KtMAwg(Instrument):
    """"""
    AWG Driver for the Keysight M9336A PXIe I/Q Arbitrary Waveform
    Generator. This driver provides a simple wrapper around the
    IVI-C drivers from Keysight. The output configuration, gain
    can be controlled and a waveform can be loaded from a file.
    """"""
    _default_buf_size = 256

    def __init__(self,
                 name: str,
                 address: str,
                 options: str = """",
                 dll_path: str = r""C:\Program Files\IVI ""
                                 r""Foundation\IVI\Bin\KtMAwg_64.dll"",
                 **kwargs: Any) -> None:
        super().__init__(name, **kwargs)

        self._address = bytes(address, ""ascii"")
        self._options = bytes(options, ""ascii"")
        self._session = ctypes.c_int(0)
        self._dll_loc = dll_path
        self._dll = ctypes.cdll.LoadLibrary(self._dll_loc)
        self._channel = ctypes.create_string_buffer(b""Channel1"")

        for ch_num in [1, 2, 3]:
            ch_name = f""ch{ch_num}""
            channel = KtMAWGChannel(
                self,
                ch_name,
                ch_num,
            )
            self.add_submodule(ch_name, channel)

        self._get_driver_desc = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_DESCRIPTION
        )
        self._get_driver_prefix = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_PREFIX
        )
        self._get_driver_revision = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_REVISION
        )
        self._get_firmware_revision = partial(
            self._get_vi_string, KTMAWG_ATTR_INSTRUMENT_FIRMWARE_REVISION
        )
        self._get_model = partial(self._get_vi_string,
                                  KTMAWG_ATTR_INSTRUMENT_MODEL)
        self._get_serial_number = partial(
            self._get_vi_string, KTMAWG_ATTR_MODULE_SERIAL_NUMBER
        )
        self._get_manufacturer = partial(
            self._get_vi_string, KTMAWG_ATTR_INSTRUMENT_MANUFACTURER
        )

        self._connect()

        self.connect_message()

    def _connect(self) -> None:
        status = self._dll.KtMAwg_InitWithOptions(
            self._address, 1, 1, self._options, ctypes.byref(self._session)
        )
        if status:
            raise SystemError(f""connection to device failed! error: {status}"")

    def get_idn(self) -> Dict[str, Optional[str]]:
        """"""generates the ``*IDN`` dictionary for qcodes""""""

        id_dict: Dict[str, Optional[str]] = {
            ""firmware"": self._get_firmware_revision(),
            ""model"": self._get_model(),
            ""serial"": self._get_serial_number(),
            ""vendor"": self._get_manufacturer(),
            ""driver desc"": self._get_driver_desc(),
            ""driver prefix"": self._get_driver_prefix(),
            ""driver revision"": self._get_driver_revision()
        }
        return id_dict

    def _catch_error(self, status: int) -> None:
        if status == 0:
            # No error
            return

        err = ctypes.c_int32(0)
        err_msg = ctypes.create_string_buffer(256)

        self._dll.KtMAwg_GetError(self._session,
                                  ctypes.byref(err),
                                  255,
                                  err_msg)

        raise ValueError(f""Got dll error num {err.value}""
                         f""msg {err_msg.value.decode('ascii')}"")

    # Query the driver for errors

    def get_errors(self) -> Dict[int, str]:
        error_code = ctypes.c_int(-1)
        error_message = ctypes.create_string_buffer(256)
        error_dict = dict()
        while error_code.value != 0:
            status = self._dll.KtMAwg_error_query(
                self._session, ctypes.byref(error_code), error_message
            )
            assert status == 0
            error_dict[error_code.value] = error_message.value.decode('utf-8')

        return error_dict

    # Generic functions for reading/writing different attributes
    def _get_vi_string(self, attr: int, ch: bytes = b"""") -> str:
        s = ctypes.create_string_buffer(self._default_buf_size)
        status = self._dll.KtMAwg_GetAttributeViString(
            self._session, ch, attr, self._default_buf_size, s
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return s.value.decode(""utf-8"")

    def _get_vi_bool(self, attr: int, ch: bytes = b"""") -> bool:
        s = ctypes.c_uint16(0)
        status = self._dll.KtMAwg_GetAttributeViBoolean(
            self._session, ch, attr, ctypes.byref(s)
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return bool(s)

    def _set_vi_bool(self, attr: int, value: bool, ch: bytes = b"""") -> None:
        v = ctypes.c_uint16(1) if value else ctypes.c_uint16(0)
        status = self._dll.KtMAwg_SetAttributeViBoolean(self._session,
                                                        ch,
                                                        attr,
                                                        v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_real64(self, attr: int, ch: bytes = b"""") -> float:
        s = ctypes.c_double(0)
        status = self._dll.KtMAwg_GetAttributeViReal64(
            self._session, ch, attr, ctypes.byref(s)
        )

        if status:
            raise ValueError(f""Driver error: {status}"")
        return float(s.value)

    def _set_vi_real64(self, attr: int, value: float, ch: bytes = b"""") -> None:
        v = ctypes.c_double(value)
        status = self._dll.KtMAwg_SetAttributeViReal64(self._session,
                                                       ch,
                                                       attr,
                                                       v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _set_vi_int(self, attr: int, value: int, ch: bytes = b"""") -> None:
        v = ctypes.c_int32(value)
        status = self._dll.KtMAwg_SetAttributeViInt32(self._session,
                                                      ch,
                                                      attr,
                                                      v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_int(self, attr: int, ch: bytes = b"""") -> int:
        v = ctypes.c_int32(0)
        status = self._dll.KtMAwg_GetAttributeViInt32(
            self._session, ch, attr, ctypes.byref(v)
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return int(v.value)

    def close(self) -> None:
        self._dll.KtMAwg_close(self._session)
        super().close()
"
283,https://www.lakeshore.com/docs/default-source/product-downloads/336_manual0ebc9b06cbbb456491c65cf1337983e4.pdf?sfvrsn=2e8633a3_1,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attwqg6J12YoieGX3'), ('width', 505), ('height', 147), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6h9EWmkXS5-ZQfxZt3k44g/FcbDzuL0Ar5MMEIw0SH7Rs7gD4g4Imcjc2Br9VQjifWP9simIr0-4IjFYE84awFRq7wLDiBED9RlSByFfsE1ZQ/R9gsfyZpy-Crb-z-1r-o_5imsWzo8WU7GRhQN1TkPeA'), ('filename', '336.png'), ('size', 105341), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DV4Ai74BhV__dmINIT-nFQ/jUvodbIWto-1n_ePRf0IfGorHn0z02NA0HszAvyDHJTai-2qh8VbkPgieDlctziCuHA3AZewNnwwUSr5vx1MWw/ty1r1IUbkYVC3tu5OJWITSYA5m0VeqjlH6wid7UNuAQ'), ('width', 124), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5-FMilz8MxgkbHqtybPvGw/6yLVyiMBPQDwjv4fYOeM7QF2vG-Lyr2dw1JKYGqLePby3g7QdjQSkjU44Z-RVrKCYp8V8fb8YuKheqa1ASZnfQ/wNyg8LnYn6lMbR2Cs0-IcGQbVc8nA_fku9_xEgSkJdc'), ('width', 505), ('height', 147)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8iKCu0E_SO__C2aoBR_Tnw/nwI6c2Lr8jFPWIMwLpXKvdYVR9rt7TmhkJ5rSr8agsGn_s31BKIDJ8lKSv0qVx-_zdB2knq9X4DjwWrBWQ0VMQ/jGOt3_KmqhgARXD2doFDVkF6JNk6mg_3i3NkQGoNgbE'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 336 supports the industry’s most advanced line of cryogenic temperature sensors as manufactured by Lake Shore, including diodes, resistance temperature detectors (RTDs), and thermocouples. The controller’s zone tuning feature allows you to measure and control temperatures seamlessly from 300 mK to over 1,500 K by automatically switching temperature sensor inputs when your temperature range goes beyond the usable range of a given sensor. ",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-336-cryogenic-temperature-controller,Lakeshore Model 336,357.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_325.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel325,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782677/Instruments/Temperature%20Controllers/Lakeshore-Model-336/Lakeshore-Model-336.png,Lakeshore Model 336,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,5188.0,,,,"from collections.abc import Iterable
from enum import IntFlag
from itertools import takewhile
from typing import Any, Optional, TextIO, cast

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import Group, GroupParameter
from qcodes.validators import Enum, Numbers


def _read_curve_file(curve_file: TextIO) -> dict[Any, Any]:
    """"""
    Read a curve file with extension .330
    The file format of this file is shown in test_lakeshore_file_parser.py
    in the test module

    The output is a dictionary with keys: ""metadata"" and ""data"".
    The metadata dictionary contains the first n lines of the curve file which
    are in the format ""item: value"". The data dictionary contains the actual
    curve data.
    """"""

    def split_data_line(line: str, parser: type = str) -> list[Any]:
        return [parser(i) for i in line.split(""  "") if i != """"]

    def strip(strings: Iterable[str]) -> tuple[str, ...]:
        return tuple(s.strip() for s in strings)

    lines = iter(curve_file.readlines())
    # Meta data lines contain a colon
    metadata_lines = takewhile(lambda s: "":"" in s, lines)
    # Data from the file is collected in the following dict
    file_data: dict[str, dict[str, Any]] = dict()
    # Capture meta data
    parsed_lines = [strip(line.split("":"")) for line in metadata_lines]
    file_data[""metadata""] = {key: value for key, value in parsed_lines}
    # After meta data we have a data header
    header_items = strip(split_data_line(next(lines)))
    # After that we have the curve data
    data: list[list[float]] = [
        split_data_line(line, parser=float) for line in lines if line.strip() != """"
    ]
    file_data[""data""] = dict(zip(header_items, zip(*data)))

    return file_data


def _get_sanitize_data(file_data: dict[Any, Any]) -> dict[Any, Any]:
    """"""
    Data as found in the curve files are slightly different from
    the dictionary as expected by the 'upload_curve' method of the
    driver
    """"""
    data_dict = dict(file_data[""data""])
    # We do not need the index column
    del data_dict[""No.""]
    # Rename the 'Units' column to the appropriate name
    # Look up under the 'Data Format' entry to find what units we have
    data_format = file_data[""metadata""][""Data Format""]
    # This is a string in the form '4      (Log Ohms/Kelvin)'
    data_format_int = int(data_format.split()[0])
    correct_name = LakeshoreModel325Curve.valid_sensor_units[data_format_int - 1]
    # Rename the column
    data_dict[correct_name] = data_dict[""Units""]
    del data_dict[""Units""]

    return data_dict


class LakeshoreModel325Status(IntFlag):
    """"""
    IntFlag that defines status codes for Lakeshore Model 325
    """"""
    sensor_units_overrang = 128
    sensor_units_zero = 64
    temp_overrange = 32
    temp_underrange = 16
    invalid_reading = 1


class LakeshoreModel325Curve(InstrumentChannel):
    """"""
    An InstrumentChannel representing a curve on a Lakeshore Model 325
    """"""

    valid_sensor_units = [""mV"", ""V"", ""Ohm"", ""log Ohm""]
    temperature_key = ""Temperature (K)""

    def __init__(self, parent: ""LakeshoreModel325"", index: int) -> None:

        self._index = index
        name = f""curve_{index}""
        super().__init__(parent, name)

        self.add_parameter(""serial_number"", parameter_class=GroupParameter)

        self.add_parameter(
            ""format"",
            val_mapping={
                f""{unt}/K"": i + 1 for i, unt in enumerate(self.valid_sensor_units)
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(""limit_value"", parameter_class=GroupParameter)

        self.add_parameter(
            ""coefficient"",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )

        self.add_parameter(""curve_name"", parameter_class=GroupParameter)

        Group(
            [
                self.curve_name,
                self.serial_number,
                self.format,
                self.limit_value,
                self.coefficient,
            ],
            set_cmd=f""CRVHDR {self._index}, {{curve_name}}, ""
            f""{{serial_number}}, {{format}}, {{limit_value}}, ""
            f""{{coefficient}}"",
            get_cmd=f""CRVHDR? {self._index}"",
        )

    def get_data(self) -> dict[Any, Any]:
        curve = [
            float(a)
            for point_index in range(1, 200)
            for a in self.ask(f""CRVPT? {self._index}, {point_index}"").split("","")
        ]

        d = {self.temperature_key: curve[1::2]}
        sensor_unit = self.format().split(""/"")[0]
        d[sensor_unit] = curve[::2]

        return d

    @classmethod
    def validate_datadict(cls, data_dict: dict[Any, Any]) -> str:
        """"""
        A data dict has two keys, one of which is 'Temperature (K)'. The other
        contains the units in which the curve is defined and must be one of:
        'mV', 'V', 'Ohm' or 'log Ohm'

        This method validates this and returns the sensor unit encountered in
        the data dict
        """"""
        if cls.temperature_key not in data_dict:
            raise ValueError(
                f""At least {cls.temperature_key} needed in the "" f""data dictionary""
            )

        sensor_units = [i for i in data_dict.keys() if i != cls.temperature_key]

        if len(sensor_units) != 1:
            raise ValueError(
                ""Data dictionary should have one other key, other then ""
                ""'Temperature (K)'""
            )

        sensor_unit = sensor_units[0]

        if sensor_unit not in cls.valid_sensor_units:
            raise ValueError(
                f""Sensor unit {sensor_unit} invalid. This needs to be one of ""
                f""{', '.join(cls.valid_sensor_units)}""
            )

        data_size = len(data_dict[cls.temperature_key])
        if data_size != len(data_dict[sensor_unit]) or data_size > 200:
            raise ValueError(
                ""The length of the temperature axis should be ""
                ""the same as the length of the sensor axis and ""
                ""should not exceed 200 in size""
            )

        return sensor_unit

    def set_data(
        self, data_dict: dict[Any, Any], sensor_unit: Optional[str] = None
    ) -> None:
        """"""
        Set the curve data according to the values found the the dictionary.

        Args:
            data_dict (dict): See `validate_datadict` to see the format of this
                                dictionary
            sensor_unit (str): If None, the data dict is validated and the
                                units are extracted.
        """"""
        if sensor_unit is None:
            sensor_unit = self.validate_datadict(data_dict)

        temperature_values = data_dict[self.temperature_key]
        sensor_values = data_dict[sensor_unit]

        for value_index, (temperature_value, sensor_value) in enumerate(
            zip(temperature_values, sensor_values)
        ):

            cmd_str = (
                f""CRVPT {self._index}, {value_index + 1}, ""
                f""{sensor_value:3.3f}, {temperature_value:3.3f}""
            )

            self.write(cmd_str)


class LakeshoreModel325Sensor(InstrumentChannel):
    """"""
    InstrumentChannel for a single sensor of a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        inp (str): Either ""A"" or ""B""
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, inp: str) -> None:

        if inp not in [""A"", ""B""]:
            raise ValueError(""Please either specify input 'A' or 'B'"")

        super().__init__(parent, name)
        self._input = inp

        self.add_parameter(
            ""temperature"",
            get_cmd=f""KRDG? {self._input}"",
            get_parser=float,
            label=""Temperature"",
            unit=""K"",
        )

        self.add_parameter(
            ""status"",
            get_cmd=f""RDGST? {self._input}"",
            get_parser=lambda status: self.decode_sensor_status(int(status)),
            label=""Sensor_Status"",
        )

        self.add_parameter(
            ""type"",
            val_mapping={
                ""Silicon diode"": 0,
                ""GaAlAs diode"": 1,
                ""100 Ohm platinum/250"": 2,
                ""100 Ohm platinum/500"": 3,
                ""1000 Ohm platinum"": 4,
                ""NTC RTD"": 5,
                ""Thermocouple 25mV"": 6,
                ""Thermocouple 50 mV"": 7,
                ""2.5 V, 1 mA"": 8,
                ""7.5 V, 1 mA"": 9,
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""compensation"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        Group(
            [self.type, self.compensation],
            set_cmd=f""INTYPE {self._input}, {{type}}, {{compensation}}"",
            get_cmd=f""INTYPE? {self._input}"",
        )

        self.add_parameter(
            ""curve_index"",
            set_cmd=f""INCRV {self._input}, {{}}"",
            get_cmd=f""INCRV? {self._input}"",
            get_parser=int,
            vals=Numbers(min_value=1, max_value=35),
        )

    @staticmethod
    def decode_sensor_status(sum_of_codes: int) -> str:
        total_status = LakeshoreModel325Status(sum_of_codes)
        if sum_of_codes == 0:
            return ""OK""
        status_messages = [
            st.name.replace(""_"", "" "")
            for st in LakeshoreModel325Status
            if st in total_status and st.name is not None
        ]
        return "", "".join(status_messages)

    @property
    def curve(self) -> LakeshoreModel325Curve:
        parent = cast(LakeshoreModel325, self.parent)
        return LakeshoreModel325Curve(parent, self.curve_index())


class LakeshoreModel325Heater(InstrumentChannel):
    """"""
    InstrumentChannel for heater control on a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        loop (int): Either 1 or 2
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, loop: int) -> None:

        if loop not in [1, 2]:
            raise ValueError(""Please either specify loop 1 or 2"")

        super().__init__(parent, name)
        self._loop = loop

        self.add_parameter(
            ""control_mode"",
            get_cmd=f""CMODE? {self._loop}"",
            set_cmd=f""CMODE {self._loop},{{}}"",
            val_mapping={
                ""Manual PID"": ""1"",
                ""Zone"": ""2"",
                ""Open Loop"": ""3"",
                ""AutoTune PID"": ""4"",
                ""AutoTune PI"": ""5"",
                ""AutoTune P"": ""6"",
            },
        )

        self.add_parameter(
            ""input_channel"", vals=Enum(""A"", ""B""), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""unit"",
            val_mapping={""Kelvin"": ""1"", ""Celsius"": ""2"", ""Sensor Units"": ""3""},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""powerup_enable"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""output_metric"",
            val_mapping={
                ""current"": ""1"",
                ""power"": ""2"",
            },
            parameter_class=GroupParameter,
        )

        Group(
            [self.input_channel, self.unit, self.powerup_enable, self.output_metric],
            set_cmd=f""CSET {self._loop}, {{input_channel}}, {{unit}}, ""
            f""{{powerup_enable}}, {{output_metric}}"",
            get_cmd=f""CSET? {self._loop}"",
        )

        self.add_parameter(
            ""P"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""I"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""D"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        Group(
            [self.P, self.I, self.D],
            set_cmd=f""PID {self._loop}, {{P}}, {{I}}, {{D}}"",
            get_cmd=f""PID? {self._loop}"",
        )

        if self._loop == 1:
            valid_output_ranges = Enum(0, 1, 2)
        else:
            valid_output_ranges = Enum(0, 1)

        self.add_parameter(
            ""output_range"",
            vals=valid_output_ranges,
            set_cmd=f""RANGE {self._loop}, {{}}"",
            get_cmd=f""RANGE? {self._loop}"",
            val_mapping={""Off"": ""0"", ""Low (2.5W)"": ""1"", ""High (25W)"": ""2""},
        )

        self.add_parameter(
            ""setpoint"",
            vals=Numbers(0, 400),
            get_parser=float,
            set_cmd=f""SETP {self._loop}, {{}}"",
            get_cmd=f""SETP? {self._loop}"",
        )

        self.add_parameter(
            ""ramp_state"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""ramp_rate"",
            vals=Numbers(0, 100 / 60 * 1e3),
            unit=""mK/s"",
            parameter_class=GroupParameter,
            get_parser=lambda v: float(v) / 60 * 1e3,  # We get values in K/min,
            set_parser=lambda v: v * 60 * 1e-3,  # Convert to K/min
        )

        Group(
            [self.ramp_state, self.ramp_rate],
            set_cmd=f""RAMP {self._loop}, {{ramp_state}}, {{ramp_rate}}"",
            get_cmd=f""RAMP? {self._loop}"",
        )

        self.add_parameter(""is_ramping"", get_cmd=f""RAMPST? {self._loop}"")

        self.add_parameter(
            ""resistance"",
            get_cmd=f""HTRRES? {self._loop}"",
            set_cmd=f""HTRRES {self._loop}, {{}}"",
            val_mapping={
                25: 1,
                50: 2,
            },
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""heater_output"",
            get_cmd=f""HTR? {self._loop}"",
            get_parser=float,
            label=""Heater Output"",
            unit=""%"",
        )


class LakeshoreModel325(VisaInstrument):
    """"""
    QCoDeS driver for Lakeshore Model 325 Temperature Controller.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\r\n"", **kwargs)

        sensors = ChannelList(
            self, ""sensor"", LakeshoreModel325Sensor, snapshotable=False
        )

        for inp in [""A"", ""B""]:
            sensor = LakeshoreModel325Sensor(self, f""sensor_{inp}"", inp)
            sensors.append(sensor)
            self.add_submodule(f""sensor_{inp}"", sensor)

        self.add_submodule(""sensor"", sensors.to_channel_tuple())

        heaters = ChannelList(
            self, ""heater"", LakeshoreModel325Heater, snapshotable=False
        )

        for loop in [1, 2]:
            heater = LakeshoreModel325Heater(self, f""heater_{loop}"", loop)
            heaters.append(heater)
            self.add_submodule(f""heater_{loop}"", heater)

        self.add_submodule(""heater"", heaters.to_channel_tuple())

        curves = ChannelList(self, ""curve"", LakeshoreModel325Curve, snapshotable=False)

        for curve_index in range(1, 35):
            curve = LakeshoreModel325Curve(self, curve_index)
            curves.append(curve)

        self.add_submodule(""curve"", curves)

        self.connect_message()

    def upload_curve(
        self, index: int, name: str, serial_number: str, data_dict: dict[Any, Any]
    ) -> None:
        """"""
        Upload a curve to the given index

        Args:
             index: The index to upload the curve to. We can only use
                            indices reserved for user defined curves, 21-35
             name
             serial_number
             data_dict: A dictionary containing the curve data
        """"""
        if index not in range(21, 36):
            raise ValueError(""index value should be between 21 and 35"")

        sensor_unit = LakeshoreModel325Curve.validate_datadict(data_dict)

        curve = self.curve[index - 1]
        curve.curve_name(name)
        curve.serial_number(serial_number)
        curve.format(f""{sensor_unit}/K"")
        curve.set_data(data_dict, sensor_unit=sensor_unit)

    def upload_curve_from_file(self, index: int, file_path: str) -> None:
        """"""
        Upload a curve from a curve file. Note that we only support
        curve files with extension .330
        """"""
        if not file_path.endswith("".330""):
            raise ValueError(""Only curve files with extension .330 are supported"")

        with open(file_path) as curve_file:
            file_data = _read_curve_file(curve_file)

        data_dict = _get_sanitize_data(file_data)
        name = file_data[""metadata""][""Sensor Model""]
        serial_number = file_data[""metadata""][""Serial Number""]

        self.upload_curve(index, name, serial_number, data_dict)
"
285,https://docs.zhinst.com/pdf/ziSHFSG_UserManual.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attH2Nr7uLKfb0QK7'), ('width', 1183), ('height', 401), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YKPCP636LVTZweii9bRWkw/Kvem-Pu_OzDdMCnQEpvo9nhVifTQkiP6KJrtXfa2784RuFTyA2OO2iJl8AO_GurK9dSLgK5PMgZmLAR-yKi3tpZF0YPALThohIMBiZsrJc8Hsdmit7RX0R0XXxIpcwvi/D0WfhSTNSv31u4fKHa4oYhNslOWWRl8sc3pDMBTLag4'), ('filename', 'SHFSG_8_schraeg_cropped_website.jpg.webp'), ('size', 37700), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kssiE-uxWuKBi70_Pd2chg/isTjv7AF93l2ZuJTLxpZSUL9RcE1IYDkH_oM0mb028-s_g_EeYoa7Hu-tnzw87VFG-tI9pjS53dFwxEyY7KjlHaaF3oUndygq68itf1u_8g/hXb16FhB90xP-BZ7MWxDw2g4JyV2BtVuPI2X5mMTTQ4'), ('width', 106), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/l8fECm2SiHIMtkt95LHghw/anjKvm40iDnLKcOvDNfnZoE1rH2zMTk1CmvWDxvc_M5VOsHvHb-i2aYkmLX1n7XwvIeixZP5du4wjLHWWrQI1QvDuOVOHadtJGeVuM5jGV4/aC6vrK22HZXumwpI7Slxy6OmkyWecvu1s-RgwjqBVbQ'), ('width', 1183), ('height', 401)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/N8hpki0KhNN2NEggRJpkyg/j0Fqmhw5GKdEgeqv_GAY4LdRep2dP0ydeVjJE0wcq2Z71ENtD6HU2B9HpHMafoEhxBbx4cSYS-pRuaEJ0hrJ6MbaLWxWwvvBzUNtilFUymo/WsyQPnz8wztKVblXfA8u31Hocm1uYtJznvLmPy9-7Pg'), ('width', 3000), ('height', 3000)]))]))])]",38.0,Switzerland,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Zurich_Instruments.png,"The Zurich Instruments SHFSG Signal Generator produces qubit control signals in the frequency range from DC to 8.5 GHz with a spurious-free modulation bandwidth of 1 GHz. The SHFSG uses a double superheterodyne technique for frequency up-conversion, which eliminates the need for mixer calibration and saves time on system tune-up. Each SHFSG comes with 4 or 8 analog output channels with 14-bit vertical resolution. Controlled by LabOne, its APIs or the LabOne Q Software, the SHFSG supports quantum computing projects with sizes ranging from a few to several hundred qubits.",https://www.zhinst.com/americas/en/products/shfsg-signal-generator,Shfsg,643.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfsg.py,Qcodes,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfsg.html,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-ALtwfp4oY-APNRJE_SQA/A3jcJepg-ngGT_9O6_e5usfG0Mo2MMuL3925RMmpUlbbgLYlR6-vcz0m6lKndrEHmtpj0ir9Y9jPk1gli-HJ1b4-ujiJYASg7vZf1HHaCOSFXua0JQsLDQ30GggKU9OG/tnyVdV6-ZvZk7x3qFzVeY9fwXp-mJggI1OQbAIFWgpg'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Cq8daLeJJu5sRIhjvuBWSQ/gyjIkCQzfk1o-oT9SDej8X981sgYxsVuSCBqup-8ZtmWjZN_emAHt8axA8Ar8UeZ2YGzCYCFALLcWYrq99XP-Q/3yq1mDhggWlf2E08z5_brXbVo9Altil66Ns16NN0ItQ'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/k7mC96YpMAmnfsr0iZLyKQ/uIDb8OmfzjX3frbwULdsDBrshWH5wMhRj47XlR91j9d55W3luiCkFXeGaySPG1WdDwTx88OT-czL5gng5s3BaQ/YKnWN_CDaXjQa_l70OHmZLEzmHQYXGVRE9so_qYZO90'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/laYbr1TrpIy32ubR6zN1AQ/JgV7w1naZObVMA9fNNTGf4E9KFIh-eS84Vmo-hDHQkvZ1s7w4Q_efDoFtUgqvY3aTUI3zIdDNOPJx7WnGd7gUw/iysiD46ZE7d6IQ5zZA3G1EWiWXcOmwqzIg-XvhcXPUY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782679/Instruments/RF%20Signal%20Generator/SHFSG/SHFSG.webp,SHFSG,Write a Python script that uses Qcodes to connect to a SHFSG RF Signal Generator,,,,,"""""""Autogenerated module for the SHFSG QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWGCore(ZINode):
    """"""AWG Core Node.""""""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""awg"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)

    def configure_marker_and_trigger(
        self, *, trigger_in_source: str, trigger_in_slope: str, marker_out_source: str
    ) -> None:
        """"""Configures the trigger inputs and marker outputs of the AWG.

        Args:
            trigger_in_source: Alias for the trigger input used by the
                sequencer. For a list of available values use:
                `available_trigger_inputs`
            trigger_in_slope: Alias for the slope of the input trigger
                used by sequencer. For a list of available values use
                `available_trigger_inputs`
            marker_out_source: Alias for the marker output source used by
                the sequencer. For a list of available values use
                `available_trigger_slopes`
        """"""
        return self._tk_object.configure_marker_and_trigger(
            trigger_in_source=trigger_in_source,
            trigger_in_slope=trigger_in_slope,
            marker_out_source=marker_out_source,
        )

    @property
    def available_trigger_inputs(self) -> List:
        """"""List the available trigger sources for the sequencer.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_trigger_slopes(self) -> List:
        """"""List the available trigger slopes for the sequencer.""""""
        return self._tk_object.available_trigger_slopes

    @property
    def available_marker_outputs(self) -> List:
        """"""List the available trigger marker outputs for the sequencer.""""""
        return self._tk_object.available_marker_outputs


class SGChannel(ZINode):
    """"""Signal Generator Channel for the SHFSG.

    :class:`SGChannel` implements basic functionality to configure SGChannel
    settings of the :class:`SHFSG` instrument.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""sgchannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.awg:

            self.add_submodule(
                ""awg"",
                AWGCore(
                    self,
                    self._tk_object.awg,
                    zi_node=self._tk_object.awg.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self, *, enable: bool, output_range: int, center_frequency: float, rf_path: bool
    ) -> None:
        """"""Configures the RF input and output.

        Args:
            enable: Flag if the signal output should be enabled.
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency before modulation
            rf_path: Flag if the RF(True) or LF(False) path should be
                configured.
        """"""
        return self._tk_object.configure_channel(
            enable=enable,
            output_range=output_range,
            center_frequency=center_frequency,
            rf_path=rf_path,
        )

    def configure_pulse_modulation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        global_amp: float = 0.5,
        gains: tuple = (1.0, -1.0, 1.0, 1.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configure the pulse modulation.

        Configures the sine generator to digitally modulate the AWG output, for
        generating single sideband AWG signals

        Args:
            enable: Flag if the modulation should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used to modulate the AWG
                outputs. (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            global_amp: Global scale factor for the AWG outputs. (default = 0.5)
            gains: Sets the four amplitudes used for single sideband generation.
                Default values correspond to upper sideband with a positive
                oscillator frequency. (default = (1.0, -1.0, 1.0, 1.0))
            sine_generator_index: Selects which sine generator to use on a
                given channel.
        """"""
        return self._tk_object.configure_pulse_modulation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            global_amp=global_amp,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    def configure_sine_generation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        gains: tuple = (0.0, 1.0, 1.0, 0.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configures the sine generator output.

        Configures the sine generator output of a specified channel for generating
        continuous wave signals without the AWG.

        Args:
            enable: Flag if the sine generator output should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used by the sine generator
                (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            gains: Sets the four amplitudes used for single sideband
                generation. Default values correspond to upper sideband with a
                positive oscillator frequency.
                Gains are set in the following order I/sin, I/cos, Q/sin, Q/cos.
                (default = (0.0, 1.0, 1.0, 0.0))
            sine_generator_index: Selects which sine generator to use on a given
                channel
        """"""
        return self._tk_object.configure_sine_generation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    @property
    def awg_modulation_freq(self) -> float:
        """"""Modulation frequency of the AWG.

        Depends on the selected oscillator.
        """"""
        return self._tk_object.awg_modulation_freq


class SHFSG(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFSG.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.sgchannels:

            channel_list = ZIChannelList(
                self,
                ""sgchannels"",
                SGChannel,
                zi_node=self._tk_object.sgchannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.sgchannels):
                channel_list.append(
                    SGChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.sgchannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""sgchannels"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)
"
286,https://www.spectrumcontrol.com/globalassets/documents/i--w/wmod8320_8321_8331.pdf,https://en.wikipedia.org/wiki/Attenuator_(electronics),"[OrderedDict([('id', 'attaUaltZwl9fwiPf'), ('width', 1600), ('height', 1067), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/TuD2EP7MNS1yXbEBhirqvg/thevRnElQCvQZQYiVrSPUe-1gvyCEFOARvHNlUh2ixH2txNLLnztuHeU5QymnY-kX-_ZyJB-SZsSda70ut5QOjNToI2uoCXjF98p_N2XrQ0/ZXnERSx9DT52eUoQrdjupflNr3q6QBHxO2MeAGSRaIE'), ('filename', 's-l1600 (1).jpg'), ('size', 70181), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dmifn0vXFpMsyhkivOCUcg/ozo1_XOcd-RlWByvz5_TikDNe-jt0npbiPmZPGW7pEeIEGRcp3JUmFwXmnnu8-zcmZidsVUUjETsnvcWCujOcQ/bITxnAvGrxQZbQrV_kvkuGM01fJasHGcHIfWZpU5gDE'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oKoJiDKdlvlgushohCb1wA/uWd0FrarlL0NQuubHeqcYKBEkExHk-vutQLZZaG2OAFMFL8Nz5hDy1OA2apswUaXtcc6If4khkY63H6ExUfyiA/61n1kmYHukJmHGVb2SpA79F6jqXSuoWFjIO0eqgwp4E'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iXsCnRuhxWFjrJK3oHcjmw/wg0vpdWwFNtOquFd6U3IjG0T9UxH8bwrpFb_kZL_fN2mgEyYFj8kb4747K6sQJYSc8dPLIBLJguX0aPKHVckvg/ZkNcBK3Zb3k-DAPWnxP33NIkZRlaJyqXVyPDr8GGMU4'), ('width', 3000), ('height', 3000)]))]))])]",6.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116670/Instruments/Vendor%20Logos/Weinschel.png,"Spectrum Control's Weinschel brand Model 8320 Series Multi-channel Programmable Attenuator systems allow for multiple attenuator channels to be controlled across a variety of interfaces, or via a front panel.",https://www.spectrumcontrol.com/products/subsystems/rf-distribution/programmable-switches--attenuators/attenuator-subsystems/8320-multi-atten-system/,Weinschel 8320,630.0,['Digital Attenuator'],"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Weinschel Associates designs and manufactures high-quality Broadband RF and Microwave products for commercial and military markets domestically and internationally. Core technologies originated by founder Bruno Weinschel are leveraged using modern design, production, delivery, and service techniques to provide the best product at the best price to our customers.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/weinschel/Weinschel_8320.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Weinschel.html,Weinschel,"[OrderedDict([('id', 'atts7Cn0Ro6caXagZ'), ('width', 375), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JWZpZz6CHQMAob-8IB_uTw/VXFalMmD8SkOAG6xq6QtWdwbnmiumyODtSciobihRL_jqJb7OI4BramB9iy20DNQeJOHakn7CpIeOqtFtX5z8EbwUQmFw2xVGCOr5u-KrqY/9fn_EqdJ-CoDX-IjT6H9pD77pFYf_cgQbBFFL7eTsxI'), ('filename', 'weinschel.png'), ('size', 27908), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZqgVr6Ms_S1lRD9qdIRFg/RekhYPbRgxN3XWbpmg__obiJ0d3Ahaf1x2WBTpSoEV3VK24HboJENq2T4yLWlzz3zDOJ_hVizb8lnVrzt46f4w/FLmdJObWCFac-q921uC9IFH0q5S0UchamS73TnSoTeQ'), ('width', 113), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JBf25ySQhRNDX0zQMkuaUw/fYbYlcos2ARsFOHxZkTJEu00LgftZgeI1C3VPwxK78AJ8q2Z7VkwyTf7Ye5g7K2cM0QBoJGQyXFg21meK8JKlg/Mtaj3Ro1XELCkJnAPm-y0b9MU22SLXIBvn1Pu0hZGYs'), ('width', 375), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xnFXb6x9EGENpvb3FwC4QA/OCtnxKzEDf8PhkDxvqU9aksHZ2m4jwDG6iL639fYx8rEOjZVFvbMCg5C24dtPWOaGFjVoAcWW4d0ntr1esh8ig/SMwk-AaCZS4j0KLMx9huZ10lLmQxyMheMUPnrhKpq90'), ('width', 3000), ('height', 3000)]))]))])]",https://www.weinschelassociates.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782679/Instruments/Digital%20Attenuator/Weinschel-8320/Weinschel-8320.jpg,Weinschel 8320,Write a Python script that uses Qcodes to connect to a {Device name} Digital Attenuator,809.99,,,,"from typing import Any

import numpy as np

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import Parameter


class Weinschel8320(VisaInstrument):
    """"""
    QCodes driver for the Weinschel 8320 stepped attenuator.

    Weinschel is formerly known as Aeroflex/Weinschel
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\r', **kwargs)
        self.attenuation = Parameter(
            ""attenuation"",
            unit=""dB"",
            set_cmd=""ATTN ALL {0:0=2d}"",
            get_cmd=""ATTN? 1"",
            vals=vals.Enum(*np.arange(0, 60.1, 2).tolist()),
            instrument=self,
            get_parser=float,
        )
        """"""Control the attenuation""""""

        self.connect_message()


class Weinschel_8320(Weinschel8320):
    """"""
    Alias for Weinschel8320 will eventually be deprecated and removed.
    """"""
"
290,https://xdevs.com/doc/HP_Agilent_Keysight/N5245-90001%20Service%20Guide%2C%20N5244A%20and%20N5245A%202-Port%20and%204-Port%20PNA-X%20Microwave%20Network%20Analyzers%20%5B456%5D.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attStMPoe9umMRnBo'), ('width', 539), ('height', 340), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4gfBWLVk-O2J6bGszSeTow/NP5xDAnGVyLsIuj6JLIPjap0o241bYauESpOE2dkw-25F3LMTV9kP1KxYIHMN7O5LlnQkRyJZkh08AV9UG5UflKQtv4uitCpvu4E-oEcZTc/MzctamfGECsIJ17jHQAYHBdeioNWun7QvC0O4FSziyg'), ('filename', 'N5245A.webp'), ('size', 160074), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/F4psostEqOUnw1YN0SrhyQ/AVkN4YWdLqEZOh3ur_zpMOIX-674afcLtS8nR2-NeS2iaVuobrsz1yjBftXy9y31XobRkCDXXUlYNFHElUFT20nElvJH629gWelRmoaBJvE/NDTllzUmiH0GSJvHIXTMJan1aCPPufDQoUvNSbNEdnY'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RKGyVFmKv9-Ll-HBs-ZIFg/MbOJvctm5vvzoRRkKoKZ3PWMH0P7MdApqcqsQK9aKrtMLgL1l1DQKBrnG8fRC7HhDB-NIVSmEoVK_9YSF6ZvorwMpl44DuWIjjWBsIKWK8I/uDHibnWE6tdod-n2LBL3IdkcpKzgb1m-0uM_4WBosdM'), ('width', 539), ('height', 340)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9__-G4JjkxsA8NIGoP7QjQ/oemRMIY9dmOhega8iALJvJv3JdRu3gsfaymErIgOpi9KxMuXj3S8-g6YouGh7H-zXAeF5hyfo-m-7gZLgBrT-9jc6UNVU_R6BB2HeRlqZJo/Qh_VJmpAsgT_gaTqjbL5yeP0oA6mYIW9ytmwcudPpeI'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight N5245A Network Analyzer provides a wide range of measurement applications for amplifiers, converters, antennas, or mixers with a single connection.","https://www.axiomtest.com/Network-Analyzers/More-than-40-GHz/Keysight-..-Agilent/N5245A/PNA_X-Network-Analyzer,-10-MHz-to-50-GHz/#:~:text=The%20Keysight%20N5245A%20Network%20Analyzer,mixers%20with%20a%20single%20connection.",Keysight n 5245 a,280.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_N5245A.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5245A,Keysight,"[OrderedDict([('id', 'attr6ueXCjaoUkuEr'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/otB_YFJfdBGIrx2iCo46ZA/bbMJz66j0e_05pBUH6HECXhfj-4l1iujy6XHpeZv6tcecoS-o-_MZxdqkcQYy3cdKr4TCyLMOzLwVb5QcLpl6809tt50i69jWu4Q7dxSaKs/RA1QvDBA-eCQXkUNyJrqtGakvD-OdDUd3Rrs9vI39oo'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UL7fjyDQhQ9soD0wGuiBvg/VqOvDxpHzATex2QhR4gxDAnw-Nfg5RsHeRf5CnfGH6jLN6mtJHMYVKhqHzBj8JQZd1FidZFLQhdrDt9j1Rm5aGYQwkzVrkuwZXihvkJSi6A/QgSaXWsfKXOQraA1lSl5-uxDY_E7atHsXI6W6jEr2uo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Hn0fdhQM3M5qOP5-8-H-lQ/oms5UCuQLsLORuRTKw0bDI4FJTW3vjV-JBXQgGl_s9aqdebL5eOhJli6NukxKMWlBeKVNskH25z23cmLHHzjmh_9BT6E3x01FmKUN59j8pI/yl1DetnzKowNCrvGUXHJfCQhcCEbYGoM1GQWvLG6kw0'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mCSC8MlxyP9f7R7lvDRMNg/PMfY3UtEMXa8PqG-9LnGROrcvQ5jQhjSO_fPp4V0Zv-5oz2WyzAdKODdokBg-qNzQoV6N1UviJEtBWodn407ZIBoqC0Elf3UnwFrBBwaiE8/hYokA4g8FCUfPqOm8HcaanoMRlu_M5oyJkMHFD91J0M'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782682/Instruments/Network%20Analyzer/Keysight-N5245A/Keysight-N5245A.webp,Keysight N5245A,Write a Python script that uses Qcodes to connect to a Keysight N5245A Network Analyzer,,,,,"from typing import Any

from . import N52xx


class KeysightN5245A(N52xx.PNAxBase):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(
            name,
            address,
            min_freq=10e6,
            max_freq=50e9,
            min_power=-30,
            max_power=13,
            nports=4,
            **kwargs
        )

        attenuators_options = {""219"", ""419""}
        options = set(self.get_options())
        if attenuators_options.intersection(options):
            self._set_power_limits(min_power=-90, max_power=13)
        if ""080"" in options:
            self._enable_fom()
"
291,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attPCVdBSDuDWmdDl'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3decAzZpBdCoErtM9QErtA/p-RuBYoESHdiijaYF7delmuuxnCwJnuXK7dDjb3SbJcBfLRag7qS5gzJAOl7hPuL5XQ0rREQnw3Pa6CftFJ7pJfr1uGsoLiotqc-pWiZJjqugagq6iMeDyO46yTVNX05/i5jVwhA9EdQXbiJV2HesOejH3h6s7kThW8-G0ogK6aQ'), ('filename', 'ds1074z-plus-front-1200x735-White-b.jpg'), ('size', 134546), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zdQLTV9Ndt_IciNQMU1Hdw/3r_748Oiodoua3xJKmXf2u7k6Hq4YMHGV0noI3SkgRSPjK3R0m03Wtc_JxvGkWw8ta_KmBdJ5h5--hfVH0BldA/SVCEGATqnpgBCKjNur-Ktz_QqKkDTm7dMvGY5FQLHPs'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/oC7DHd78A2w_qSJyX_P_-A/zAZQWQkKRRhGshhJDUakxN_KXkyGRdLlyuofq-GZaVfY7L55AMBBkQPUhCmVq3RQHnRk0IXnSHRj3ipXXyrRHw/zyYfUpDmBlTLNDe6eAYUW8DnK9Wx2W_qD59BqRPPYnc'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/i_lK7IqDOyB-YIJ46Lda0g/5P9n_Pjc1sxpk4up5eocoKTZMv64_BrOqUChv4Wg-VLpqNT0hz6YkKgwp4OOfj3qP-D-mMOxXRUfdTn4b2wYcA/cuuDdWLCoA2sP5OOQf0tUr9Y_JCy2AWr6vi7idPOMns'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"4 analog channels, Upgradable to 16 digital channels (requires optional RPL1116 logic probe to operate)
Built in 2 channel 25MHz waveform generator
",https://www.batronix.com/shop/oscilloscopes/Rigol-DS1074Z.html,Rigol DS 1074 Z,459.0,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DS1074Z.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDS1074Z,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782683/Instruments/Oscilloscopes/Rigol-DS1074Z/Rigol-DS1074Z.jpg,Rigol DS1074Z,Write a Python script that uses Qcodes to connect to a Rigol DS1074Z Oscilloscopes,,,,,"from typing import Any

import numpy as np

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ParameterWithSetpoints
from qcodes.validators import Arrays, Enum, Numbers


class RigolDS1074ZChannel(InstrumentChannel):
    """"""
    Contains methods and attributes specific to the Rigol
    oscilloscope channels.

    The output trace from each channel of the oscilloscope
    can be obtained using 'trace' parameter.
    """"""

    def __init__(self, parent: ""RigolDS1074Z"", name: str, channel: int):
        super().__init__(parent, name)
        self.channel = channel

        self.add_parameter(
            ""vertical_scale"",
            get_cmd=f"":CHANnel{channel}:SCALe?"",
            set_cmd="":CHANnel{}:SCALe {}"".format(channel, ""{}""),
            get_parser=float,
        )

        self.add_parameter(
            ""trace"",
            get_cmd=self._get_full_trace,
            vals=Arrays(shape=(self.parent.waveform_npoints,)),
            setpoints=(self.parent.time_axis,),
            unit=""V"",
            parameter_class=ParameterWithSetpoints,
            snapshot_value=False,
        )

    def _get_full_trace(self) -> np.ndarray:
        y_ori = self.root_instrument.waveform_yorigin()
        y_increm = self.root_instrument.waveform_yincrem()
        y_ref = self.root_instrument.waveform_yref()
        y_raw = self._get_raw_trace()
        y_raw_shifted = y_raw - y_ori - y_ref
        full_data = np.multiply(y_raw_shifted, y_increm)
        return full_data

    def _get_raw_trace(self) -> np.ndarray:
        # set the out type from oscilloscope channels to WORD
        self.root_instrument.write("":WAVeform:FORMat WORD"")

        # set the channel from where data will be obtained
        self.root_instrument.data_source(f""ch{self.channel}"")

        # Obtain the trace
        raw_trace_val = self.root_instrument.visa_handle.query_binary_values(
            ""WAV:DATA?"", datatype=""h"", is_big_endian=False, expect_termination=False
        )
        return np.array(raw_trace_val)


class RigolDS1074Z(VisaInstrument):
    """"""
    The QCoDeS drivers for Oscilloscope Rigol DS1074Z.

    Args:
        name: name of the instrument.
        address: VISA address of the instrument.
        timeout: Seconds to allow for responses.
        terminator: terminator for SCPI commands.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        terminator: str = ""\n"",
        timeout: float = 5,
        **kwargs: Any,
    ):
        super().__init__(
            name, address, terminator=terminator, timeout=timeout, **kwargs
        )

        self.add_parameter(
            ""waveform_xorigin"", get_cmd=""WAVeform:XORigin?"", unit=""s"", get_parser=float
        )

        self.add_parameter(
            ""waveform_xincrem"",
            get_cmd="":WAVeform:XINCrement?"",
            unit=""s"",
            get_parser=float,
        )

        self.add_parameter(
            ""waveform_npoints"",
            get_cmd=""WAV:POIN?"",
            set_cmd=""WAV:POIN {}"",
            unit=""s"",
            get_parser=int,
        )

        self.add_parameter(
            ""waveform_yorigin"", get_cmd=""WAVeform:YORigin?"", unit=""V"", get_parser=float
        )

        self.add_parameter(
            ""waveform_yincrem"",
            get_cmd="":WAVeform:YINCrement?"",
            unit=""V"",
            get_parser=float,
        )

        self.add_parameter(
            ""waveform_yref"", get_cmd="":WAVeform:YREFerence?"", unit=""V"", get_parser=float
        )

        self.add_parameter(
            ""trigger_mode"",
            get_cmd="":TRIGger:MODE?"",
            set_cmd="":TRIGger:MODE {}"",
            unit=""V"",
            vals=Enum(""edge"", ""pulse"", ""video"", ""pattern""),
            get_parser=str,
        )

        # trigger source
        self.add_parameter(
            ""trigger_level"",
            unit=""V"",
            get_cmd=self._get_trigger_level,
            set_cmd=self._set_trigger_level,
            vals=Numbers(),
        )

        self.add_parameter(
            ""trigger_edge_source"",
            label=""Source channel for the edge trigger"",
            get_cmd="":TRIGger:EDGE:SOURce?"",
            set_cmd="":TRIGger:EDGE:SOURce {}"",
            val_mapping={
                ""ch1"": ""CHAN1"",
                ""ch2"": ""CHAN2"",
                ""ch3"": ""CHAN3"",
                ""ch4"": ""CHAN4"",
            },
        )

        self.add_parameter(
            ""trigger_edge_slope"",
            label=""Slope of the edge trigger"",
            get_cmd="":TRIGger:EDGE:SLOPe?"",
            set_cmd="":TRIGger:EDGE:SLOPe {}"",
            vals=Enum(""positive"", ""negative"", ""neither""),
        )

        self.add_parameter(
            ""data_source"",
            label=""Waveform Data source"",
            get_cmd="":WAVeform:SOURce?"",
            set_cmd="":WAVeform:SOURce {}"",
            val_mapping={
                ""ch1"": ""CHAN1"",
                ""ch2"": ""CHAN2"",
                ""ch3"": ""CHAN3"",
                ""ch4"": ""CHAN4"",
            },
        )

        self.add_parameter(
            ""time_axis"",
            unit=""s"",
            label=""Time"",
            set_cmd=False,
            get_cmd=self._get_time_axis,
            vals=Arrays(shape=(self.waveform_npoints,)),
            snapshot_value=False,
        )

        channels = ChannelList(
            self, ""channels"", RigolDS1074ZChannel, snapshotable=False
        )

        for channel_number in range(1, 5):
            channel = RigolDS1074ZChannel(self, f""ch{channel_number}"", channel_number)
            channels.append(channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())

        self.connect_message()

    def _get_time_axis(self) -> np.ndarray:
        xorigin = self.waveform_xorigin()
        xincrem = self.waveform_xincrem()
        npts = self.waveform_npoints()
        xdata = np.linspace(xorigin, npts * xincrem + xorigin, npts)
        return xdata

    def _get_trigger_level(self) -> str:
        trigger_level = self.root_instrument.ask(
            f"":TRIGger:{self.trigger_mode()}:LEVel?""
        )
        return trigger_level

    def _set_trigger_level(self, value: str) -> None:
        self.root_instrument.write(f"":TRIGger:{self.trigger_mode()}:LEVel {value}"")
"
292,https://resources.aimtti.com/datasheets/AIM-QL_series_II_DC_power_supplies_data_sheet-Iss3.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-qlseries,"[OrderedDict([('id', 'attYuTwh3uVeGqHgQ'), ('width', 330), ('height', 226), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UcQSKpl6njSWOodC9vhkSw/ljfpnm_Xx9pE1RBeFqku0uEYnRMTouvdRdxGpWKs7Z5THqLN1ZqcaHT7hpuK6kEQdIOw31vFl6TPTWYuXPiosDlTX1PYSIv0yS6Ahoej6v0/wddarLQpBG7JumBVf6kLvNKbVdYhSE9qcpKUgIAWMtc'), ('filename', 'AIM-QL355TP.jpeg'), ('size', 42776), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/q_UkI4CKx-15h7VZm8rVzA/2fswq688aMmlr-4Uq9__4SKRQ-fYeZEkbFE_Ep8cF7jeEoi8gpEiP5ZxkR473kPnU-QYjEINLUyaK7KXoWhFUA/SqgxrStg1K8-4C5bLpAaUTDJ7EAdjPgpX2hylw2GLZM'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/R0E9PPySC6QL9oaUxRc0Fw/TKocyhyzE4kZ4DzIN5J31u96i7BSrJ1fLcv-dQ5aFgP8jrYWyG-Cq6lXcKFNvpBZ9RCb9P4XDxtM6agK7RHqJQ/BfRkuOSuWjL2lAQvRaeptSXU5GgErNldmPk9p4mbblA'), ('width', 330), ('height', 226)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dpQSRW_g_15EdxliJTSl1w/u8F2nypzgjAMWcDlzlOty6bjCfFPBvzRFfHK7PqTPrfwCnJYgyvyGgz24BYrzl_tY2G3MSLa36yHUsO1OBgoAQ/bfuP5or7fR4myOnqnhMHM9sPWkyNDpj17O68UXqkydk'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Precision Linear Regulated DC Power Supply 35V/3A or 15V/5A, USB/RS232/GPIB/LAN
",https://www.aimtti.com/product-category/dc-power-supplies/aim-qlseries,AIMTTI QL 355 TP,45.0,['Power Supplies'],"Bench/System Precision Linear Regulated DC Power Supply with digital control, single or triple Outputs, 105 to 242 watts, with/without Remote Interfaces","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiQL355TP,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782684/Instruments/Power%20Supplies/QL335-P/QL335-P.jpg,QL335-P,Write a Python script that uses Qcodes to connect to a QL335-P Power Supplies,900.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
300,https://www.keysight.com/us/en/assets/7018-01522/data-sheets/5989-6319.pdf,https://en.wikipedia.org/wiki/Electrometer,"[OrderedDict([('id', 'attzWwgS4ZMZ5tns8'), ('width', 600), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/BjJC6NcRFqZfXJ0KB7lhwg/CE74rQhH333LwcEqYGZDUnaTOQHJ8z_XP7-gC4c8hb1lYHFcxXI_X5TLSmLkgX_6BN6typgEm4t2RTAHUv7BK8MFZJiUEzlEwxMU-ZsTDzM/Eq1kMYZG4XUTtAek5-Y3grx0m15wfgR4BPByEBxAD48'), ('filename', 'N6705B.png'), ('size', 511219), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/M8zvcfCcF1novkkXj5Hyow/xood4d4IJRDrPB2F6CrJgyMbIlcGik3PL5B-05HkzvuVRZCYgmEP9Evx54vkwKz3mzWP0k4BX7y42OtUlHaH0Q/_nfLlGG9G61Go7g-VEDWeJ2YA3U7IvWGY_S3NtwR7P0'), ('width', 85), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CCHQDwSzS0GwUFgG2Ir53Q/Muknc3wTbeOFTx-0NKEc3yrOWUqIaNzcWoBfP8qoLw0WHdL9LWE29daYcz6M7YgBBPF5HFIeawCxMAktB1iZQQ/bs1lPHB0pPw6RYsgVwEIHFgku9TxfIY3qEoKlroCY3I'), ('width', 600), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Jl-2r-eaqbpotlVY1Au5LA/DpUgkdQ1_S5WuLIa5pW2MqOLBYPpPypiJuX6Fg516SLwD7CcHQ4KiJUEpniwhZ_Z6rQf1xdpzezTVkEAnI-21w/I0gxf0Gl2TaA9w5b3FNQvhvpOXR_uOKEcKcgrF-zCeM'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The N6705B is a 4-slot mainframe that accepts up to 4 DC Power Modules, and up to 600 W total DC Power Module output power. The modules are ordered separately. 

N6705B accepts the same modules as N6700 Modular Power System, with over 30 modules to choose from","https://www.keysight.com/us/en/product/N6705B/dc-power-analyzer-modular-600-w-4-slots.html#:~:text=The%20N6705B%20is%20a%204,30%20modules%20to%20choose%20from.",Keysightn 6705b,279.0,"['Power Supplies', 'Multimeters', 'Oscilloscopes', 'RF Signal Generator']","An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_N6705B.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN6705B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782689/Instruments/Power%20Supplies/Keysight-N6705B/Keysight-N6705B.png,Keysight N6705B,"Write a Python script that uses Qcodes to connect to a Keysight N6705B Power Supplies, Multimeters, Oscilloscopes, RF Signal Generator",,,True,,"from typing import Any

from qcodes import VisaInstrument
from qcodes import Instrument
from qcodes.instrument.channel import InstrumentChannel
from typing import List, Dict, Optional


class N6705BChannel(InstrumentChannel):
    def __init__(self, parent: Instrument, name: str, chan: int) -> None:
        if chan not in [1, 2, 3, 4]:
            raise ValueError('Invalid channel specified')

        super().__init__(parent, name)

        self.add_parameter('source_voltage',
                           label=f""Channel {chan} Voltage"",
                           get_cmd=f'SOURCE:VOLT? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOURCE:VOLT {{:.8G}}, (@{chan})',
                           unit='V')

        self.add_parameter('source_current',
                           label=f""Channel {chan} Current"",
                           get_cmd=f'SOURCE:CURR? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOURCE:CURR {{:.8G}}, (@{chan})',
                           unit='A')

        self.add_parameter('voltage_limit',
                           get_cmd=f'SOUR:VOLT:PROT? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOUR:VOLT:PROT {{:.8G}}, @({chan})',
                           label=f'Channel {chan} Voltage Limit',
                           unit='V')

        self.add_parameter('voltage',
                           get_cmd=f'MEAS:VOLT? (@{chan})',
                           get_parser=float,
                           label=f'Channel {chan} Voltage',
                           unit='V')

        self.add_parameter('current',
                           get_cmd=f'MEAS:CURR? (@{chan})',
                           get_parser=float,
                           label=f'Channel {chan} Current',
                           unit='A')

        self.add_parameter('enable',
                           get_cmd=f'OUTP:STAT? (@{chan})',
                           set_cmd=f'OUTP:STAT {{:d}}, (@{chan})',
                           val_mapping={'on':  1, 'off': 0})

        self.add_parameter('source_mode',
                           get_cmd=f':OUTP:PMOD? (@{chan})',
                           set_cmd=f':OUTP:PMOD {{:s}}, (@{chan})',
                           val_mapping={'current': 'CURR', 'voltage': 'VOLT'})

        self.channel = chan
        self.ch_name = name


class N6705B(VisaInstrument):
    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.channels:  List[N6705BChannel] = []
        for ch_num in [1, 2, 3, 4]:
            ch_name = f""ch{ch_num}""
            channel = N6705BChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        self.connect_message()

    def get_idn(self) -> Dict[str, Optional[str]]:
        IDNstr = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDNstr.split(','))
        IDN: Dict[str, Optional[str]] = {'vendor': vendor, 'model': model,
                                         'serial': serial, 'firmware': firmware}
        return IDN
"
302,https://download.tek.com/datasheet/DPO7000C-Oscilloscope-Datasheet-48W2654321.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attwmBix2AQZwu6pL'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kmcAdeU7fzqexG1uN6X1jA/u8LeOQEt_y4ZJnFnzvYEUAcHr8m2A0Ie-QMf3CUDtegLn8EDlSI6IUJCfmOx58n8W0jTsT23nY9poCEgQ1lbpGcOqoeTw7v3thcwbHk7cLs/cip6vm8ymqOFBQf_114L16C9w4AwW8GJTy05sRhQkEs'), ('filename', 'DPO7000C-Series-1.jpg'), ('size', 37983), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7mT8pcAfVgRre9CsqdKZNA/GDsVq82Mp7W9FlgjQg_2Gp73s0Io3L5OuJkH6hGrEY6q9iFeG8GFWkb_OHf_sK9cmdMI2DYRMaPXdfDhwp6xnw/pdyefhPV7LPhHNGcCP2DmDMryoksCTX4fkaTqQEYNxQ'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zd0r_Oq76Xf9uBKbreeChw/jv3tH_spc5OZyCy6h3O4KbpNHitG6L17Eo4wH_ZyCz8lgiaAm9DddR3TgpSQsET1etBRvLT686tkaq6oByK-JQ/tl0FFS9oxs_daFt5YNnkdUb7EEWMqW831RxhT8uWMx0'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xY_EDDzImD4kgorLhnc5Lg/qZv6gzx8txBlxZ_g0j7gnXP98ZRMgnlee7wSRT2Lo2q9_P56G92r7BE1HF-jb0gb5fYYi77nr01miMgErFE6hA/OjGlsLenC2LBlByYx8rnj7SfmI8YCWfjJBg-kTr-1QA'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"Bandwidths up to 3.5 GHz and sampling rates up to 40 GS/s make the DPO7000C Series a natural choice for analyzing critical, high-speed signals. Over 30 analysis packages provide in-depth measurements for communications standards, jitter analysis, memory bus standards, vector analysis and more. Plus, the Windows operating system lets you run your own analysis software right on the instruments.",https://www.tek.com/en/products/oscilloscopes/dpo7000-digital-phosphor-oscilloscope,Tektronix DPO 7000,571.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO7000,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782722/Instruments/Oscilloscopes/DPO7000/DPO7000.jpg,DPO7000,Write a Python script that uses Qcodes to connect to a DPO7000 Oscilloscopes,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
303,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,https://en.wikipedia.org/wiki/Function_generator#Function_generator,"[OrderedDict([('id', 'attChmw20anhGegZx'), ('width', 1492), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JZ6SV-T3VcSOUTnUP_3blw/Mjcv53lTO1l6YQXIbxESBHDir_wGYzvskceMfw9Ymt-SIMsV3CSqoNChD028PGnE6JpLm4UUjvMfM3AceqfzKaeLAVXWU-zk4T3u-UmIVkw/opd6E2UDSzxgPcvhFsjQ0Y1Hyn8kc9nj2n_XlJAGh-I'), ('filename', '29X7419-40.jpg'), ('size', 120092), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/x6TtsJPbyxXzYIge-bb0zg/Q0UcKMjnUrKjzRWxhb36nBaZMpV62cxvlNVJuJGa2IlTT33rkX0JzQKHd8Lh_71ULdYAqkDZ1IopL5JoTGK9sg/ttaCL9o7TOgAgAHv5huptm5SvMRRXJy0YFP4VcAkTcw'), ('width', 70), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qnZPgzDP4J5YA8s3FbTgmQ/Jq8QWcyZlWnJ2HrmbtjIgRnTbPd-UxdWjkwbhiSYedZcnDv-CqazmptRRR0rdlS3uAMcR14Cqy0Fm_s0Makh2g/cR3OF03Ygd--tuXvBmX-uI_QCnG4ifBOLhLJkvhbqMw'), ('width', 992), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dEEMXjST1mtrmEB45xgS1Q/-W5YC0iOeqg9tBRxD5gl1NQIXDfywXyc0gaTPybw4DolUci6sAreLYnq5_daufjB_UXU0An_5TcOAzupEEUjVw/PJw7hv68Pn-GsO6IEEhE08FMeJFNdZjsR3j6AvgL4tk'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight 33622A function/arbitrary waveform generators offer the standard signals and features you expect, such as modulation, sweep, and burst. However, it also provides features that give you the capabilities and flexibility you need to get your job done quickly, no matter how complex. An intuitive front-panel user interface, for example, can be quickly and easily relearned when your attention has been focused elsewhere.","https://www.batronix.com/shop/waveform-generator/Keysight-33622A.html#:~:text=2%20channel%20function%20%2F%20arbitrary%20waveform,cm%20(4.3%E2%80%9D)%20display.",Keysight 33622A,289.0,['Function Generators'],"A function generator is electronic test equipment that generates standard waveforms, such as sine, square, ramp, or sawtooth waves, to a device under test (DUT).","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33622A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782694/Instruments/Function%20Generators/Keysight-33622A/Keysight-33622A.jpg,Keysight 33622A,Write a Python script that uses Qcodes to connect to a Keysight 33622A Function Generators,12412.7,,,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
306,https://download.tek.com/datasheet/76W-20381-3.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attGNiWvU4zCyvSrE'), ('width', 1200), ('height', 1024), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fCLW38r9Rz6ztsciYLQzDg/zuU3V2h8EczfSriznavRyaxjiyS7rLvPiRIUG5PdwT6rW_CjOr8hobRkn-6yHsdHQLQuAv1UvbV4IGJq8D2xQmfHX62kCylPywGM-eg-uio/EozWkCxhRK-jUzhiMxmBwVf2FpWKTTSKF9Ac2IPbeGk'), ('filename', '0002359_TEK_AWG5014.jpg'), ('size', 205214), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OlAZI08xMAfWUP0C9r36Gg/27_3Lx3N6SHGn9a1SBydRb3EXyY6L-OfQf0E648bLpmpf-cghIydgur4WlI8fADnCLX94a46HehnJGLy-wXS-w/euZALAqp7JmmVMsqmOIqlr39GtZKnOzOL1tmseNl9Wo'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/64G4PfbQ23scFahHWR1isQ/1-22woS3FrZ7joQRTl4Ad8eF8l-Hsq6pcf7V2PuBGex0CQmQJjGP9Uj2bo7tjTPIYa9Bhe1KSeHjWgIv1Vdu7g/itbo1xIOlB36uu3ofv5vyFeZtTwOfG3lGIaFvhUDMrs'), ('width', 600), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/fONof25OEwjbZ53LNqtqKg/NSbTIX51nwKBmJYDNFBLv_gZQNUDA47cJMdnOfOzTzobaBcagb2j7KHz1rtiaN8PXJ9Rx-WB--aX4wvFK3ecTw/WVtmvOElkEtoqd1Q2gqiS2YVpYoByJ5XgBR9wLQR8jE'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"AWG5000 Series models, with a 14
bits DA converter based sample rate
from 600 MS/s to 1.2 GS/s, two to four output channels, synchronized four to eight digital marker outputs, and 28-channels of digital data outputs, easilysolve the toughest measurement challenges in wireless base band I/Q communications, digital consumer product design such as imaging devices, data conversion equipment and semiconductor design and test",https://www.tek.com/en/datasheet/awg5000-series,AWG 5014,556.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG5014.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG5014,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782696/Instruments/RF%20Signal%20Generator/AWG5014/AWG5014.jpg,AWG5014,Write a Python script that uses Qcodes to connect to a AWG5014 RF Signal Generator,,,True,,"import array as arr
import logging
import re
import struct
from collections import abc
from collections.abc import Sequence
from io import BytesIO
from time import localtime, sleep
from typing import Any, Literal, NamedTuple, Optional, Union, cast

import numpy as np
from pyvisa.errors import VisaIOError

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument

log = logging.getLogger(__name__)


class _MarkerDescriptor(NamedTuple):
    marker: int
    channel: int


def parsestr(v: str) -> str:
    return v.strip().strip('""')


class TektronixAWG5014(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Tektronix AWG5014
    Arbitrary Waveform Generator.

    The driver makes some assumptions on the settings of the instrument:

        - The output channels are always in Amplitude/Offset mode
        - The output markers are always in High/Low mode

    TODO:
        - Implement support for cable transfer function compensation
        - Implement more instrument functionality in the driver
        - Remove double functionality
        - Remove inconsistensies between the name of a parameter and
          the name of the same variable in the tektronix manual

    In the future, we should consider the following:

        * Removing test_send??
        * That sequence element (SQEL) parameter functions exist but no
          corresponding parameters.

    """"""
    AWG_FILE_FORMAT_HEAD = {
        'SAMPLING_RATE': 'd',    # d
        'REPETITION_RATE': 'd',    # # NAME?
        'HOLD_REPETITION_RATE': 'h',    # True | False
        'CLOCK_SOURCE': 'h',    # Internal | External
        'REFERENCE_SOURCE': 'h',    # Internal | External
        'EXTERNAL_REFERENCE_TYPE': 'h',    # Fixed | Variable
        'REFERENCE_CLOCK_FREQUENCY_SELECTION': 'h',
        'REFERENCE_MULTIPLIER_RATE': 'h',    #
        'DIVIDER_RATE': 'h',   # 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256
        'TRIGGER_SOURCE': 'h',    # Internal | External
        'INTERNAL_TRIGGER_RATE': 'd',    #
        'TRIGGER_INPUT_IMPEDANCE': 'h',    # 50 ohm | 1 kohm
        'TRIGGER_INPUT_SLOPE': 'h',    # Positive | Negative
        'TRIGGER_INPUT_POLARITY': 'h',    # Positive | Negative
        'TRIGGER_INPUT_THRESHOLD': 'd',    #
        'EVENT_INPUT_IMPEDANCE': 'h',    # 50 ohm | 1 kohm
        'EVENT_INPUT_POLARITY': 'h',    # Positive | Negative
        'EVENT_INPUT_THRESHOLD': 'd',
        'JUMP_TIMING': 'h',    # Sync | Async
        'INTERLEAVE': 'h',    # On |  This setting is stronger than .
        'ZEROING': 'h',    # On | Off
        'COUPLING': 'h',    # The Off | Pair | All setting is weaker than .
        'RUN_MODE': 'h',    # Continuous | Triggered | Gated | Sequence
        'WAIT_VALUE': 'h',    # First | Last
        'RUN_STATE': 'h',    # On | Off
        'INTERLEAVE_ADJ_PHASE': 'd',
        'INTERLEAVE_ADJ_AMPLITUDE': 'd',
    }
    AWG_FILE_FORMAT_CHANNEL = {
        # Include NULL.(Output Waveform Name for Non-Sequence mode)
        'OUTPUT_WAVEFORM_NAME_N': 's',
        'CHANNEL_STATE_N': 'h',  # On | Off
        'ANALOG_DIRECT_OUTPUT_N': 'h',  # On | Off
        'ANALOG_FILTER_N': 'h',  # Enum type.
        'ANALOG_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'ANALOG_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'ANALOG_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'ANALOG_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'ANALOG_LOW_N': 'd',
        'MARKER1_SKEW_N': 'd',
        'MARKER1_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'MARKER1_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'MARKER1_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER1_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER1_LOW_N': 'd',
        'MARKER2_SKEW_N': 'd',
        'MARKER2_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'MARKER2_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'MARKER2_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER2_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER2_LOW_N': 'd',
        'DIGITAL_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'DIGITAL_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'DIGITAL_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'DIGITAL_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'DIGITAL_LOW_N': 'd',
        'EXTERNAL_ADD_N': 'h',  # AWG5000 only
        'PHASE_DELAY_INPUT_METHOD_N':   'h',  # Phase/DelayInme/DelayInints
        'PHASE_N': 'd',  # When the Input Method is not Phase, it is skipped.
        # When the Input Method is not DelayInTime, it is skipped.
        'DELAY_IN_TIME_N': 'd',
        # When the Input Method is not DelayInPoint, it is skipped.
        'DELAY_IN_POINTS_N': 'd',
        'CHANNEL_SKEW_N': 'd',
        'DC_OUTPUT_LEVEL_N': 'd',  # V
    }

    def __init__(
            self,
            name: str,
            address: str,
            timeout: int = 180,
            num_channels: int = 4,
            **kwargs: Any):
        """"""
        Initializes the AWG5014.

        Args:
            name: name of the instrument
            address: GPIB or ethernet address as used by VISA
            timeout: visa timeout, in secs. long default (180)
                to accommodate large waveforms
            num_channels: number of channels on the device

        """"""
        super().__init__(name, address, timeout=timeout, **kwargs)

        self._address = address
        self.num_channels = num_channels

        self._values: dict[
            str, dict[str, dict[str, Union[np.ndarray, float, None]]]
        ] = {}
        self._values[""files""] = {}

        self.add_function('reset', call_cmd='*RST')

        self.add_parameter('state',
                           get_cmd=self.get_state)
        self.add_parameter('run_mode',
                           get_cmd='AWGControl:RMODe?',
                           set_cmd='AWGControl:RMODe ' + '{}',
                           vals=vals.Enum('CONT', 'TRIG', 'SEQ', 'GAT'),
                           get_parser=self.newlinestripper
                           )
        self.add_parameter('clock_source',
                           label='Clock source',
                           get_cmd='AWGControl:CLOCk:SOURce?',
                           set_cmd='AWGControl:CLOCk:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        self.add_parameter('ref_source',
                           label='Reference source',
                           get_cmd='SOURce1:ROSCillator:SOURce?',
                           set_cmd='SOURce1:ROSCillator:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        self.add_parameter('DC_output',
                           label='DC Output (ON/OFF)',
                           get_cmd='AWGControl:DC:STATe?',
                           set_cmd='AWGControl:DC:STATe {}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        # sequence parameter(s)
        self.add_parameter('sequence_length',
                           label='Sequence length',
                           get_cmd='SEQuence:LENGth?',
                           set_cmd='SEQuence:LENGth ' + '{}',
                           get_parser=int,
                           vals=vals.Ints(0, 8000),
                           docstring=(
                               """"""
                               This command sets the sequence length.
                               Use this command to create an
                               uninitialized sequence. You can also
                               use the command to clear all sequence
                               elements in a single action by passing
                               0 as the parameter. However, this
                               action cannot be undone so exercise
                               necessary caution. Also note that
                               passing a value less than the
                               sequence’s current length will cause
                               some sequence elements to be deleted at
                               the end of the sequence. For example if
                               self.get_sq_length returns 200 and you
                               subsequently set sequence_length to 21,
                               all sequence elements except the first
                               20 will be deleted.
                               """""")
                           )

        self.add_parameter('sequence_pos',
                           label='Sequence position',
                           get_cmd='AWGControl:SEQuencer:POSition?',
                           set_cmd='SEQuence:JUMP:IMMediate {}',
                           vals=vals.PermissiveInts(1),
                           set_parser=lambda x: int(round(x))
                           )

        # Trigger parameters #
        # Warning: `trigger_mode` is the same as `run_mode`, do not use! exists
        # solely for legacy purposes
        self.add_parameter('trigger_mode',
                           get_cmd='AWGControl:RMODe?',
                           set_cmd='AWGControl:RMODe ' + '{}',
                           vals=vals.Enum('CONT', 'TRIG', 'SEQ', 'GAT'),
                           get_parser=self.newlinestripper)
        self.add_parameter('trigger_impedance',
                           label='Trigger impedance',
                           unit='Ohm',
                           get_cmd='TRIGger:IMPedance?',
                           set_cmd='TRIGger:IMPedance ' + '{}',
                           vals=vals.Enum(50, 1000),
                           get_parser=float)
        self.add_parameter('trigger_level',
                           unit='V',
                           label='Trigger level',
                           get_cmd='TRIGger:LEVel?',
                           set_cmd='TRIGger:LEVel ' + '{:.3f}',
                           vals=vals.Numbers(-5, 5),
                           get_parser=float)
        self.add_parameter('trigger_slope',
                           get_cmd='TRIGger:SLOPe?',
                           set_cmd='TRIGger:SLOPe ' + '{}',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=self.newlinestripper)

        self.add_parameter('trigger_source',
                           get_cmd='TRIGger:SOURce?',
                           set_cmd='TRIGger:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        # Event parameters
        self.add_parameter('event_polarity',
                           get_cmd='EVENt:POL?',
                           set_cmd='EVENt:POL ' + '{}',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=self.newlinestripper)
        self.add_parameter('event_impedance',
                           label='Event impedance',
                           unit='Ohm',
                           get_cmd='EVENt:IMPedance?',
                           set_cmd='EVENt:IMPedance ' + '{}',
                           vals=vals.Enum(50, 1000),
                           get_parser=float)
        self.add_parameter('event_level',
                           label='Event level',
                           unit='V',
                           get_cmd='EVENt:LEVel?',
                           set_cmd='EVENt:LEVel ' + '{:.3f}',
                           vals=vals.Numbers(-5, 5),
                           get_parser=float)
        self.add_parameter('event_jump_timing',
                           get_cmd='EVENt:JTIMing?',
                           set_cmd='EVENt:JTIMing {}',
                           vals=vals.Enum('SYNC', 'ASYNC'),
                           get_parser=self.newlinestripper)

        self.add_parameter('clock_freq',
                           label='Clock frequency',
                           unit='Hz',
                           get_cmd='SOURce:FREQuency?',
                           set_cmd='SOURce:FREQuency ' + '{}',
                           vals=vals.Numbers(1e6, 1.2e9),
                           get_parser=float)

        self.add_parameter('setup_filename',
                           get_cmd='AWGControl:SNAMe?')

        # Channel parameters #
        for i in range(1, self.num_channels+1):
            amp_cmd = f'SOURce{i}:VOLTage:LEVel:IMMediate:AMPLitude'
            offset_cmd = f'SOURce{i}:VOLTage:LEVel:IMMediate:OFFS'
            state_cmd = f'OUTPUT{i}:STATE'
            waveform_cmd = f'SOURce{i}:WAVeform'
            directoutput_cmd = f'AWGControl:DOUTput{i}:STATE'
            filter_cmd = f'OUTPut{i}:FILTer:FREQuency'
            add_input_cmd = f'SOURce{i}:COMBine:FEED'
            dc_out_cmd = f'AWGControl:DC{i}:VOLTage:OFFSet'

            # Set channel first to ensure sensible sorting of pars
            self.add_parameter(f'ch{i}_state',
                               label=f'Status channel {i}',
                               get_cmd=state_cmd + '?',
                               set_cmd=state_cmd + ' {}',
                               vals=vals.Ints(0, 1),
                               get_parser=int)
            self.add_parameter(f'ch{i}_amp',
                               label=f'Amplitude channel {i}',
                               unit='Vpp',
                               get_cmd=amp_cmd + '?',
                               set_cmd=amp_cmd + ' {:.6f}',
                               vals=vals.Numbers(0.02, 4.5),
                               get_parser=float)
            self.add_parameter(f'ch{i}_offset',
                               label=f'Offset channel {i}',
                               unit='V',
                               get_cmd=offset_cmd + '?',
                               set_cmd=offset_cmd + ' {:.3f}',
                               vals=vals.Numbers(-2.25, 2.25),
                               get_parser=float)
            self.add_parameter(f'ch{i}_waveform',
                               label=f'Waveform channel {i}',
                               get_cmd=waveform_cmd + '?',
                               set_cmd=waveform_cmd + ' ""{}""',
                               vals=vals.Strings(),
                               get_parser=parsestr)
            self.add_parameter(f'ch{i}_direct_output',
                               label=f'Direct output channel {i}',
                               get_cmd=directoutput_cmd + '?',
                               set_cmd=directoutput_cmd + ' {}',
                               vals=vals.Ints(0, 1))
            self.add_parameter(f'ch{i}_add_input',
                               label='Add input channel {}',
                               get_cmd=add_input_cmd + '?',
                               set_cmd=add_input_cmd + ' {}',
                               vals=vals.Enum('""ESIG""', '""ESIGnal""', '""""'),
                               get_parser=self.newlinestripper)
            self.add_parameter(f'ch{i}_filter',
                               label=f'Low pass filter channel {i}',
                               unit='Hz',
                               get_cmd=filter_cmd + '?',
                               set_cmd=filter_cmd + ' {}',
                               vals=vals.Enum(20e6, 100e6,
                                              float('inf'),
                                              'INF', 'INFinity'),
                               get_parser=self._tek_outofrange_get_parser)
            self.add_parameter(f'ch{i}_DC_out',
                               label=f'DC output level channel {i}',
                               unit='V',
                               get_cmd=dc_out_cmd + '?',
                               set_cmd=dc_out_cmd + ' {}',
                               vals=vals.Numbers(-3, 5),
                               get_parser=float)

            # Marker channels
            for j in range(1, 3):
                m_del_cmd = f'SOURce{i}:MARKer{j}:DELay'
                m_high_cmd = ('SOURce{}:MARKer{}:VOLTage:' +
                              'LEVel:IMMediate:HIGH').format(i, j)
                m_low_cmd = ('SOURce{}:MARKer{}:VOLTage:' +
                             'LEVel:IMMediate:LOW').format(i, j)

                self.add_parameter(
                    f'ch{i}_m{j}_del',
                    label=f'Channel {i} Marker {j} delay',
                    unit='ns',
                    get_cmd=m_del_cmd + '?',
                    set_cmd=m_del_cmd + ' {:.3f}e-9',
                    vals=vals.Numbers(0, 1),
                    get_parser=float)
                self.add_parameter(
                    f'ch{i}_m{j}_high',
                    label=f'Channel {i} Marker {j} high level',
                    unit='V',
                    get_cmd=m_high_cmd + '?',
                    set_cmd=m_high_cmd + ' {:.3f}',
                    vals=vals.Numbers(-0.9, 2.7),
                    get_parser=float)
                self.add_parameter(
                    f'ch{i}_m{j}_low',
                    label=f'Channel {i} Marker {j} low level',
                    unit='V',
                    get_cmd=m_low_cmd + '?',
                    set_cmd=m_low_cmd + ' {:.3f}',
                    vals=vals.Numbers(-1.0, 2.6),
                    get_parser=float)

        self.set('trigger_impedance', 50)
        if self.get('clock_freq') != 1e9:
            log.info('AWG clock freq not set to 1GHz')

        self.connect_message()

    # Convenience parser
    def newlinestripper(self, string: str) -> str:
        if string.endswith('\n'):
            return string[:-1]
        else:
            return string

    def _tek_outofrange_get_parser(self, string: str) -> float:
        val = float(string)
        # note that 9.9e37 is used as a generic out of range value
        # in tektronix instruments
        if val >= 9.9e37:
            val = float('INF')
        return val

    # Functions
    def get_state(self) -> Literal['Idle', 'Waiting for trigger', 'Running']:
        """"""
        This query returns the run state of the arbitrary waveform
        generator or the sequencer.

        Returns:
            Either 'Idle', 'Waiting for trigger', or 'Running'.

        Raises:
            ValueError: if none of the three states above apply.
        """"""
        state = self.ask('AWGControl:RSTATe?')
        if state.startswith('0'):
            return 'Idle'
        elif state.startswith('1'):
            return 'Waiting for trigger'
        elif state.startswith('2'):
            return 'Running'
        else:
            raise ValueError(__name__ + (' : AWG in undefined ' +
                                         'state ""{}""').format(state))

    def start(self) -> str:
        """"""Convenience function, identical to self.run()""""""
        return self.run()

    def run(self) -> str:
        """"""
        This command initiates the output of a waveform or a sequence.
        This is equivalent to pressing Run/Stop button on the front panel.
        The instrument can be put in the run state only when output waveforms
        are assigned to channels.

        Returns:
            The output of self.get_state()
        """"""
        self.write('AWGControl:RUN')
        return self.get_state()

    def stop(self) -> None:
        """"""This command stops the output of a waveform or a sequence.""""""
        self.write('AWGControl:STOP')

    def force_trigger(self) -> None:
        """"""
        This command generates a trigger event. This is equivalent to
        pressing the Force Trigger button on front panel.
        """"""
        self.write('*TRG')

    def get_folder_contents(self, print_contents: bool = True) -> str:
        """"""
        This query returns the current contents and state of the mass storage
        media (on the AWG Windows machine).

        Args:
            print_contents: If True, the folder name and the query
                output are printed. Default: True.

        Returns:
            str: A comma-seperated string of the folder contents.
        """"""
        contents = self.ask('MMEMory:CATalog?')
        if print_contents:
            print('Current folder:', self.get_current_folder_name())
            print(contents
                  .replace(',""$', '\n$').replace('"",""', '\n')
                  .replace(',', '\t'))
        return contents

    def get_current_folder_name(self) -> str:
        """"""
        This query returns the current directory of the file system on the
        arbitrary waveform generator. The current directory for the
        programmatic interface is different from the currently selected
        directory in the Windows Explorer on the instrument.

        Returns:
            A string with the full path of the current folder.
        """"""
        return self.ask('MMEMory:CDIRectory?')

    def set_current_folder_name(self, file_path: str) -> int:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator. The current directory for the programmatic
        interface is different from the currently selected directory in the
        Windows Explorer on the instrument.

        Args:
            file_path: The full path.

        Returns:
            The number of bytes written to instrument
        """"""
        writecmd = 'MMEMory:CDIRectory ""{}""'
        return self.visa_handle.write(writecmd.format(file_path))

    def change_folder(self, folder: str) -> int:
        """"""Duplicate of self.set_current_folder_name""""""
        writecmd = r'MMEMory:CDIRectory ""{}""'
        return self.visa_handle.write(writecmd.format(folder))

    def goto_root(self) -> None:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator to C: (the 'root' location in Windows).
        """"""
        self.write('MMEMory:CDIRectory ""c:\\..""')

    def create_and_goto_dir(self, folder: str) -> str:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator. Creates the directory if if doesn't exist.
        Queries the resulting folder for its contents.

        Args:
            folder: The path of the directory to set as current.
                Note: this function expects only root level directories.

        Returns:
            A comma-seperated string of the folder contents.
        """"""

        dircheck = '%s, DIR' % folder
        if dircheck in self.get_folder_contents():
            self.change_folder(folder)
            log.debug('Directory already exists')
            log.warning(('Directory already exists, ' +
                         'changed path to {}').format(folder))
            log.info('Contents of folder is ' +
                     '{}'.format(self.ask('MMEMory:cat?')))
        elif self.get_current_folder_name() == f'""\\{folder}""':
            log.info('Directory already set to ' +
                     f'{folder}')
        else:
            self.write('MMEMory:MDIRectory ""%s""' % folder)
            self.write('MMEMory:CDIRectory ""%s""' % folder)

        return self.get_folder_contents()

    def all_channels_on(self) -> None:
        """"""
        Set the state of all channels to be ON. Note: only channels with
        defined waveforms can be ON.
        """"""
        for i in range(1, self.num_channels+1):
            self.set(f'ch{i}_state', 1)

    def all_channels_off(self) -> None:
        """"""Set the state of all channels to be OFF.""""""
        for i in range(1, self.num_channels+1):
            self.set(f'ch{i}_state', 0)

    #####################
    # Sequences section #
    #####################

    def force_trigger_event(self) -> None:
        """"""
        This command generates a trigger event. Equivalent to
        self.force_trigger.
        """"""
        self.write('TRIGger:IMMediate')

    def force_event(self) -> None:
        """"""
        This command generates a forced event. This is used to generate the
        event when the sequence is waiting for an event jump. This is
        equivalent to pressing the Force Event button on the front panel of the
        instrument.
        """"""
        self.write('EVENt:IMMediate')

    def set_sqel_event_target_index(self, element_no: int, index: int) -> None:
        """"""
        This command sets the target index for
        the sequencer’s event jump operation. Note that this will take
        effect only when the event jump target type is set to
        INDEX.

        Args:
            element_no: The sequence element number
            index: The index to set the target to
        """"""
        self.write('SEQuence:' +
                   f'ELEMent{element_no}:JTARGet:INDex {index}')

    def set_sqel_goto_target_index(
            self,
            element_no: int,
            goto_to_index_no: int
    ) -> None:
        """"""
        This command sets the target index for the GOTO command of the
        sequencer.  After generating the waveform specified in a
        sequence element, the sequencer jumps to the element specified
        as GOTO target. This is an unconditional jump. If GOTO target
        is not specified, the sequencer simply moves on to the next
        element. If the Loop Count is Infinite, the GOTO target which
        is specified in the element is not used. For this command to
        work, the goto state of the squencer must be ON and the
        sequence element must exist.
        Note that the first element of a sequence is taken to be 1 not 0.


        Args:
            element_no: The sequence element number
            goto_to_index_no: The target index number

        """"""
        self.write('SEQuence:' +
                   'ELEMent{}:GOTO:INDex {}'.format(element_no,
                                                    goto_to_index_no))

    def set_sqel_goto_state(self, element_no: int, goto_state: int) -> None:
        """"""
        This command sets the GOTO state of the sequencer for the specified
        sequence element.

        Args:
            element_no: The sequence element number
            goto_state: The GOTO state of the sequencer. Must be either
                0 (OFF) or 1 (ON).
        """"""
        allowed_states = [0, 1]
        if goto_state not in allowed_states:
            log.warning(('{} not recognized as a valid goto' +
                         ' state. Setting to 0 (OFF).').format(goto_state))
            goto_state = 0
        self.write('SEQuence:ELEMent{}:GOTO:STATe {}'.format(element_no,
                                                             int(goto_state)))

    def set_sqel_loopcnt_to_inf(self,
                                element_no: int,
                                state: int = 1) -> None:
        """"""
        This command sets the infinite looping state for a sequence
        element. When an infinite loop is set on an element, the
        sequencer continuously executes that element. To break the
        infinite loop, issue self.stop()

        Args:
            element_no (int): The sequence element number
            state (int): The infinite loop state. Must be either 0 (OFF) or
                1 (ON).
        """"""
        allowed_states = [0, 1]
        if state not in allowed_states:
            log.warning(('{} not recognized as a valid loop' +
                         '  state. Setting to 0 (OFF).').format(state))
            state = 0

        self.write('SEQuence:ELEMent{}:LOOP:INFinite {}'.format(element_no,
                                                                int(state)))

    def get_sqel_loopcnt(self, element_no: int = 1) -> str:
        """"""
        This query returns the loop count (number of repetitions) of a
        sequence element. Loop count setting for an element is ignored
        if the infinite looping state is set to ON.

        Args:
            element_no: The sequence element number. Default: 1.
        """"""
        return self.ask(f'SEQuence:ELEMent{element_no}:LOOP:COUNt?')

    def set_sqel_loopcnt(self, loopcount: int, element_no: int = 1) -> None:
        """"""
        This command sets the loop count. Loop count setting for an
        element is ignored if the infinite looping state is set to ON.

        Args:
            loopcount: The number of times the sequence is being output.
                The maximal possible number is 65536, beyond that: infinity.
            element_no: The sequence element number. Default: 1.
        """"""
        self.write('SEQuence:ELEMent{}:LOOP:COUNt {}'.format(element_no,
                                                             loopcount))

    def set_sqel_waveform(
            self,
            waveform_name: str,
            channel: int,
            element_no: int = 1
    ) -> None:
        """"""
        This command sets the waveform for a sequence element on the specified
        channel.

        Args:
            waveform_name: Name of the waveform. Must be in the waveform
                list (either User Defined or Predefined).
            channel: The output channel (1-4)
            element_no: The sequence element number. Default: 1.
        """"""
        self.write('SEQuence:ELEMent{}:WAVeform{} ""{}""'.format(element_no,
                                                               channel,
                                                               waveform_name))

    def get_sqel_waveform(
            self,
            channel: int,
            element_no: int = 1
    ) -> str:
        """"""
        This query returns the waveform for a sequence element on the
        specified channel.

        Args:
            channel: The output channel (1-4)
            element_no: The sequence element number. Default: 1.

        Returns:
            The name of the waveform.
        """"""
        return self.ask('SEQuence:ELEMent{}:WAVeform{}?'.format(element_no,
                                                                channel))

    def set_sqel_trigger_wait(
            self,
            element_no: int,
            state: int = 1) -> str:
        """"""
        This command sets the wait trigger state for an element. Send
        a trigger signal in one of the following ways:

          * By using an external trigger signal.
          * By pressing the “Force Trigger” button on the front panel
          * By using self.force_trigger or self.force_trigger_event

        Args:
            element_no: The sequence element number.
            state: The wait trigger state. Must be either 0 (OFF)
                or 1 (ON). Default: 1.

        Returns:
            The current state (after setting it).

        """"""
        self.write(f'SEQuence:ELEMent{element_no}:TWAit {state}')
        return self.get_sqel_trigger_wait(element_no)

    def get_sqel_trigger_wait(self, element_no: int) -> str:
        """"""
        This query returns the wait trigger state for an element. Send
        a trigger signal in one of the following ways:

          * By using an external trigger signal.
          * By pressing the “Force Trigger” button on the front panel
          * By using self.force_trigger or self.force_trigger_event

        Args:
            element_no: The sequence element number.

        Returns:
            The current state. Example: '1'.
        """"""
        return self.ask(f'SEQuence:ELEMent{element_no}:TWAit?')

    def set_sqel_event_jump_target_index(self,
                                         element_no: int,
                                         jtar_index_no: int) -> None:
        """"""Duplicate of set_sqel_event_target_index""""""
        self.write('SEQuence:ELEMent{}:JTARget:INDex {}'.format(element_no,
                                                                jtar_index_no))

    def set_sqel_event_jump_type(
            self,
            element_no: int,
            jtar_state: str
    ) -> None:
        """"""
        This command sets the event jump target type for the jump for
        the specified sequence element.  Generate an event in one of
        the following ways:

        * By connecting an external cable to instrument rear panel
          for external event.
        * By pressing the Force Event button on the
          front panel.
        * By using self.force_event

        Args:
            element_no: The sequence element number
            jtar_state: The jump target type. Must be either 'INDEX',
                'NEXT', or 'OFF'.
        """"""
        self.write('SEQuence:ELEMent{}:JTARget:TYPE {}'.format(element_no,
                                                               jtar_state))

    def get_sq_mode(self) -> str:
        """"""
        This query returns the type of the arbitrary waveform
        generator's sequencer. The sequence is executed by the
        hardware sequencer whenever possible.

        Returns:
            str: Either 'HARD' or 'SOFT' indicating that the instrument is in\
              either hardware or software sequencer mode.
        """"""
        return self.ask('AWGControl:SEQuence:TYPE?')

    ######################
    # AWG file functions #
    ######################

    def _pack_record(
            self,
            name: str,
            value: Union[float, str, Sequence[Any], np.ndarray],
            dtype: str
    ) -> bytes:
        """"""
        packs awg_file record into a struct in the folowing way:
            struct.pack(fmtstring, namesize, datasize, name, data)
        where fmtstring = '<IIs""dtype""'

        The file record format is as follows:
        Record Name Size:        (32-bit unsigned integer)
        Record Data Size:        (32-bit unsigned integer)
        Record Name:             (ASCII) (Include NULL.)
        Record Data
        For details see ""File and Record Format"" in the AWG help

        < denotes little-endian encoding, I and other dtypes are format
        characters denoted in the documentation of the struct package

        Args:
            name: Name of the record (Example: 'MAGIC' or 'SAMPLING_RATE')
            value: The value of that record.
            dtype: String specifying the data type of the record.
                Allowed values: 'h', 'd', 's'.
        """"""
        if len(dtype) == 1:
            record_data = struct.pack('<' + dtype, value)
        else:
            if dtype[-1] == 's':
                assert isinstance(value, str)
                record_data = value.encode('ASCII')
            else:
                assert isinstance(value, (abc.Sequence, np.ndarray))
                if dtype[-1] == 'H' and isinstance(value, np.ndarray):
                    # numpy conversion is fast
                    record_data = value.astype('<u2').tobytes()
                else:
                    # argument unpacking is slow
                    record_data = struct.pack('<' + dtype, *value)

        # the zero byte at the end the record name is the ""(Include NULL.)""
        record_name = name.encode('ASCII') + b'\x00'
        record_name_size = len(record_name)
        record_data_size = len(record_data)
        size_struct = struct.pack('<II', record_name_size, record_data_size)
        packed_record = size_struct + record_name + record_data

        return packed_record

    def generate_sequence_cfg(self) -> dict[str, float]:
        """"""
        This function is used to generate a config file, that is used when
        generating sequence files, from existing settings in the awg.
        Querying the AWG for these settings takes ~0.7 seconds
        """"""
        log.info('Generating sequence_cfg')

        AWG_sequence_cfg = {
            'SAMPLING_RATE': self.get('clock_freq'),
            'CLOCK_SOURCE': (1 if self.clock_source().startswith('INT')
                             else 2),  # Internal | External
            'REFERENCE_SOURCE': (1 if self.ref_source().startswith('INT')
                                 else 2),  # Internal | External
            'EXTERNAL_REFERENCE_TYPE':   1,  # Fixed | Variable
            'REFERENCE_CLOCK_FREQUENCY_SELECTION': 1,
            # 10 MHz | 20 MHz | 100 MHz
            'TRIGGER_SOURCE':   1 if
            self.get('trigger_source').startswith('EXT') else 2,
            # External | Internal
            'TRIGGER_INPUT_IMPEDANCE': (1 if self.get('trigger_impedance') ==
                                        50. else 2),  # 50 ohm | 1 kohm
            'TRIGGER_INPUT_SLOPE': (1 if self.get('trigger_slope').startswith(
                                    'POS') else 2),  # Positive | Negative
            'TRIGGER_INPUT_POLARITY': (1 if self.ask('TRIGger:' +
                                                     'POLarity?').startswith(
                                       'POS') else 2),  # Positive | Negative
            'TRIGGER_INPUT_THRESHOLD':  self.get('trigger_level'),  # V
            'EVENT_INPUT_IMPEDANCE':   (1 if self.get('event_impedance') ==
                                        50. else 2),  # 50 ohm | 1 kohm
            'EVENT_INPUT_POLARITY':  (1 if self.get('event_polarity').startswith(
                                      'POS') else 2),  # Positive | Negative
            'EVENT_INPUT_THRESHOLD':   self.get('event_level'),  # V
            'JUMP_TIMING':   (1 if
                              self.get('event_jump_timing').startswith('SYNC')
                              else 2),  # Sync | Async
            'RUN_MODE':   4,  # Continuous | Triggered | Gated | Sequence
            'RUN_STATE':  0,  # On | Off
        }
        return AWG_sequence_cfg

    def generate_channel_cfg(self) -> dict[str, Optional[float]]:
        """"""
        Function to query if the current channel settings that have
        been changed from their default value and put them in a
        dictionary that can easily be written into an awg file, so as
        to prevent said awg file from falling back to default values.
        (See :meth:`~make_awg_file` and :meth:`~AWG_FILE_FORMAT_CHANNEL`)
        NOTE: This only works for settings changed via the corresponding
        QCoDeS parameter.

        Returns:
            A dict with the current setting for each entry in
            AWG_FILE_FORMAT_HEAD iff this entry applies to the
            AWG5014 AND has been changed from its default value.
        """"""
        log.info('Getting channel configurations.')

        dirouts = [self.ch1_direct_output.get_latest(),
                   self.ch2_direct_output.get_latest(),
                   self.ch3_direct_output.get_latest(),
                   self.ch4_direct_output.get_latest()]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        filtertrans = {20e6: 1, 100e6: 3, 9.9e37: 10,
                       'INF': 10, 'INFinity': 10,
                       float('inf'): 10, None: None}
        filters = [filtertrans[self.ch1_filter.get_latest()],
                   filtertrans[self.ch2_filter.get_latest()],
                   filtertrans[self.ch3_filter.get_latest()],
                   filtertrans[self.ch4_filter.get_latest()]]

        amps = [self.ch1_amp.get_latest(),
                self.ch2_amp.get_latest(),
                self.ch3_amp.get_latest(),
                self.ch4_amp.get_latest()]

        offsets = [self.ch1_offset.get_latest(),
                   self.ch2_offset.get_latest(),
                   self.ch3_offset.get_latest(),
                   self.ch4_offset.get_latest()]

        mrk1highs = [self.ch1_m1_high.get_latest(),
                     self.ch2_m1_high.get_latest(),
                     self.ch3_m1_high.get_latest(),
                     self.ch4_m1_high.get_latest()]

        mrk1lows = [self.ch1_m1_low.get_latest(),
                    self.ch2_m1_low.get_latest(),
                    self.ch3_m1_low.get_latest(),
                    self.ch4_m1_low.get_latest()]

        mrk2highs = [self.ch1_m2_high.get_latest(),
                     self.ch2_m2_high.get_latest(),
                     self.ch3_m2_high.get_latest(),
                     self.ch4_m2_high.get_latest()]

        mrk2lows = [self.ch1_m2_low.get_latest(),
                    self.ch2_m2_low.get_latest(),
                    self.ch3_m2_low.get_latest(),
                    self.ch4_m2_low.get_latest()]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        addinptrans = {'""ESIG""': 1, '""""': 0, None: None}
        addinputs = [addinptrans[self.ch1_add_input.get_latest()],
                     addinptrans[self.ch2_add_input.get_latest()],
                     addinptrans[self.ch3_add_input.get_latest()],
                     addinptrans[self.ch4_add_input.get_latest()]]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        def mrkdeltrans(x: Optional[float]) -> Optional[float]:
            if x is None:
                return None
            else:
                return x * 1e-9
        mrk1delays = [mrkdeltrans(self.ch1_m1_del.get_latest()),
                      mrkdeltrans(self.ch2_m1_del.get_latest()),
                      mrkdeltrans(self.ch3_m1_del.get_latest()),
                      mrkdeltrans(self.ch4_m1_del.get_latest())]
        mrk2delays = [mrkdeltrans(self.ch1_m2_del.get_latest()),
                      mrkdeltrans(self.ch2_m2_del.get_latest()),
                      mrkdeltrans(self.ch3_m2_del.get_latest()),
                      mrkdeltrans(self.ch4_m2_del.get_latest())]

        AWG_channel_cfg: dict[str, Optional[float]] = {}

        for chan in range(1, self.num_channels+1):
            if dirouts[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_DIRECT_OUTPUT_{chan}':
                                        int(dirouts[chan - 1])})
            if filters[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_FILTER_{chan}':
                                        filters[chan - 1]})
            if amps[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_AMPLITUDE_{chan}':
                                        amps[chan - 1]})
            if offsets[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_OFFSET_{chan}':
                                        offsets[chan - 1]})
            if mrk1highs[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_HIGH_{chan}':
                                        mrk1highs[chan - 1]})
            if mrk1lows[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_LOW_{chan}':
                                        mrk1lows[chan - 1]})
            if mrk2highs[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_HIGH_{chan}':
                                        mrk2highs[chan - 1]})
            if mrk2lows[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_LOW_{chan}':
                                        mrk2lows[chan - 1]})
            if mrk1delays[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_SKEW_{chan}':
                                        mrk1delays[chan - 1]})
            if mrk2delays[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_SKEW_{chan}':
                                        mrk2delays[chan - 1]})
            if addinputs[chan - 1] is not None:
                AWG_channel_cfg.update({f'EXTERNAL_ADD_{chan}':
                                        addinputs[chan - 1]})

        return AWG_channel_cfg

    @staticmethod
    def parse_marker_channel_name(name: str) -> _MarkerDescriptor:
        """"""
        returns from the channel index and marker index from a marker
        descriptor string e.g. '1M1'->(1,1)
        """"""
        res = re.match(r'^(?P<channel>\d+)M(?P<marker>\d+)$',
                       name)
        assert res is not None

        return _MarkerDescriptor(marker=int(res.group('marker')),
                                 channel=int(res.group('channel')))

    def _generate_awg_file(
        self,
        packed_waveforms: dict[str, np.ndarray],
        wfname_l: np.ndarray,
        nrep: Sequence[int],
        trig_wait: Sequence[int],
        goto_state: Sequence[int],
        jump_to: Sequence[int],
        channel_cfg: dict[str, Any],
        sequence_cfg: Optional[dict[str, float]] = None,
        preservechannelsettings: bool = False,
    ) -> bytes:
        """"""
        This function generates an .awg-file for uploading to the AWG.
        The .awg-file contains a waveform list, full sequencing information
        and instrument configuration settings.

        Args:
            packed_waveforms: dictionary containing packed waveforms
                with keys wfname_l

            wfname_l: array of waveform names, e.g.
                array([[segm1_ch1,segm2_ch1..], [segm1_ch2,segm2_ch2..],...])

            nrep: list of len(segments) of integers specifying the
                no. of repetions per sequence element.
                Allowed values: 1 to 65536.

            trig_wait: list of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_state: list of len(segments) of integers specifying the
                goto state of each sequence element. Allowed values: 0 to 65536
                (0 means next)

            jump_to: list of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channel_cfg: dictionary of valid channel configuration
                records. See self.AWG_FILE_FORMAT_CHANNEL for a complete
                overview of valid configuration parameters.

            preservechannelsettings: If True, the current channel
                settings are queried from the instrument and added to
                channel_cfg (does not overwrite). Default: False.

            sequence_cfg: dictionary of valid head configuration records
                     (see self.AWG_FILE_FORMAT_HEAD)
                     When an awg file is uploaded these settings will be set
                     onto the AWG, any parameter not specified will be set to
                     its default value (even overwriting current settings)

        for info on filestructure and valid record names, see AWG Help,
        File and Record Format (Under 'Record Name List' in Help)
        """"""
        if preservechannelsettings:
            channel_settings = self.generate_channel_cfg()
            for setting in channel_settings:
                if setting not in channel_cfg:
                    channel_cfg.update({setting: channel_settings[setting]})

        timetuple = tuple(np.array(localtime())[[0, 1, 8, 2, 3, 4, 5, 6, 7]])

        # general settings
        head_str = BytesIO()
        bytes_to_write = (self._pack_record('MAGIC', 5000, 'h') +
                          self._pack_record('VERSION', 1, 'h'))
        head_str.write(bytes_to_write)
        # head_str.write(string(bytes_to_write))

        if sequence_cfg is None:
            sequence_cfg = self.generate_sequence_cfg()

        for k in list(sequence_cfg.keys()):
            if k in self.AWG_FILE_FORMAT_HEAD:
                head_str.write(self._pack_record(k, sequence_cfg[k],
                                                 self.AWG_FILE_FORMAT_HEAD[k]))
            else:
                log.warning('AWG: ' + k +
                            ' not recognized as valid AWG setting')
        # channel settings
        ch_record_str = BytesIO()
        for k in list(channel_cfg.keys()):
            ch_k = k[:-1] + 'N'
            if ch_k in self.AWG_FILE_FORMAT_CHANNEL:
                pack = self._pack_record(k, channel_cfg[k],
                                         self.AWG_FILE_FORMAT_CHANNEL[ch_k])
                ch_record_str.write(pack)

            else:
                log.warning('AWG: ' + k +
                            ' not recognized as valid AWG channel setting')

        # waveforms
        ii = 21

        wf_record_str = BytesIO()
        wlist = list(packed_waveforms.keys())
        wlist.sort()
        for wf in wlist:
            wfdat = packed_waveforms[wf]
            lenwfdat = len(wfdat)

            wf_record_str.write(
                self._pack_record(f'WAVEFORM_NAME_{ii}', wf + '\x00',
                                  '{}s'.format(len(wf + '\x00'))) +
                self._pack_record(f'WAVEFORM_TYPE_{ii}', 1, 'h') +
                self._pack_record(f'WAVEFORM_LENGTH_{ii}',
                                  lenwfdat, 'l') +
                self._pack_record(f'WAVEFORM_TIMESTAMP_{ii}',
                                  timetuple[:-1], '8H') +
                self._pack_record(f'WAVEFORM_DATA_{ii}', wfdat,
                                  f'{lenwfdat}H'))
            ii += 1

        # sequence
        kk = 1
        seq_record_str = BytesIO()

        for segment in wfname_l.transpose():

            seq_record_str.write(
                self._pack_record(f'SEQUENCE_WAIT_{kk}',
                                  trig_wait[kk - 1], 'h') +
                self._pack_record(f'SEQUENCE_LOOP_{kk}',
                                  int(nrep[kk - 1]), 'l') +
                self._pack_record(f'SEQUENCE_JUMP_{kk}',
                                  jump_to[kk - 1], 'h') +
                self._pack_record(f'SEQUENCE_GOTO_{kk}',
                                  goto_state[kk - 1], 'h'))
            for wfname in segment:
                if wfname is not None:
                    # TODO (WilliamHPNielsen): maybe infer ch automatically
                    # from the data size?
                    ch = wfname[-1]
                    seq_record_str.write(
                        self._pack_record('SEQUENCE_WAVEFORM_NAME_CH_' + ch
                                          + f'_{kk}', wfname + '\x00',
                                          '{}s'.format(len(wfname + '\x00')))
                    )
            kk += 1

        awg_file = (head_str.getvalue() + ch_record_str.getvalue() +
                    wf_record_str.getvalue() + seq_record_str.getvalue())
        return awg_file

    def send_awg_file(
            self,
            filename: str,
            awg_file: bytes,
            verbose: bool = False) -> None:
        """"""
        Writes an .awg-file onto the disk of the AWG.
        Overwrites existing files.

        Args:
            filename: The name that the file will get on
                the AWG.
            awg_file: A byte sequence containing the awg_file.
                Usually the output of self.make_awg_file.
            verbose: A boolean to allow/suppress printing of messages
                about the status of the filw writing. Default: False.
        """"""
        if verbose:
            print('Writing to:',
                  self.ask('MMEMory:CDIRectory?').replace('\n', '\\ '),
                  filename)
        # Header indicating the name and size of the file being send
        name_str = f'MMEMory:DATA ""{filename}"",'.encode('ASCII')
        size_str = ('#' + str(len(str(len(awg_file)))) +
                    str(len(awg_file))).encode('ASCII')
        mes = name_str + size_str + awg_file
        self.visa_handle.write_raw(mes)

    def load_awg_file(self, filename: str) -> None:
        """"""
        Loads an .awg-file from the disc of the AWG into the AWG memory.
        This may overwrite all instrument settings, the waveform list, and the
        sequence in the sequencer.

        Args:
            filename: The filename of the .awg-file to load.
        """"""
        s = f'AWGControl:SREStore ""{filename}""'
        b = s.encode(encoding=""ASCII"")
        log.debug(f'Loading awg file using {s}')
        self.visa_handle.write_raw(b)
        # we must update the appropriate parameter(s) for the sequence
        self.sequence_length.set(self.sequence_length.get())

    def make_awg_file(
            self,
            waveforms: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            m1s: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            m2s: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            nreps: Sequence[int],
            trig_waits: Sequence[int],
            goto_states: Sequence[int],
            jump_tos: Sequence[int],
            channels: Optional[Sequence[int]] = None,
            preservechannelsettings: bool = True) -> bytes:
        """"""
        Args:
            waveforms: A list of the waveforms to be packed. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetitions per sequence element.  Allowed values: 0 to
                65536. O corresponds to Infinite repetitions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels (list): List of channels to send the waveforms to.
                Example: [1, 3, 2]

            preservechannelsettings (bool): If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are not written in the
                file and will be reset to factory default when the file is
                loaded. Default: True.
            """"""
        packed_wfs = {}
        waveform_names = []
        if not isinstance(waveforms[0], abc.Sequence):
            waveforms_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], waveforms)]
            m1s_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], m1s)]
            m2s_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], m2s)]
        else:
            waveforms_int = cast(Sequence[Sequence[np.ndarray]], waveforms)
            m1s_int = cast(Sequence[Sequence[np.ndarray]], m1s)
            m2s_int = cast(Sequence[Sequence[np.ndarray]], m2s)

        for ii in range(len(waveforms_int)):
            namelist = []
            for jj in range(len(waveforms_int[ii])):
                if channels is None:
                    thisname = f""wfm{jj + 1:03d}ch{ii + 1}""
                else:
                    thisname = f""wfm{jj + 1:03d}ch{channels[ii]}""
                namelist.append(thisname)

                package = self._pack_waveform(waveforms_int[ii][jj],
                                              m1s_int[ii][jj],
                                              m2s_int[ii][jj])

                packed_wfs[thisname] = package
            waveform_names.append(namelist)

        wavenamearray = np.array(waveform_names, dtype='str')

        channel_cfg: dict[str, Any] = {}

        return self._generate_awg_file(
            packed_wfs, wavenamearray, nreps, trig_waits, goto_states,
            jump_tos, channel_cfg,
            preservechannelsettings=preservechannelsettings)

    def make_send_and_load_awg_file(
            self,
            waveforms: Sequence[Sequence[np.ndarray]],
            m1s: Sequence[Sequence[np.ndarray]],
            m2s: Sequence[Sequence[np.ndarray]],
            nreps: Sequence[int],
            trig_waits: Sequence[int],
            goto_states: Sequence[int],
            jump_tos: Sequence[int],
            channels: Optional[Sequence[int]] = None,
            filename: str = 'customawgfile.awg',
            preservechannelsettings: bool = True
    ) -> None:
        """"""
        Makes an .awg-file, sends it to the AWG and loads it. The .awg-file
        is uploaded to C:\\\\Users\\\\OEM\\\\Documents. The waveforms appear in
        the user defined waveform list with names wfm001ch1, wfm002ch1, ...

        Args:
            waveforms: A list of the waveforms to upload. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetions per sequence element.  Allowed values: 0 to
                65536. 0 corresponds to Infinite repetions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels: List of channels to send the waveforms to.
                Example: [1, 3, 2]

            filename: The name of the .awg-file. Should end with the .awg
                extension. Default: 'customawgfile.awg'

            preservechannelsettings: If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are reset to the factory
                default values. Default: True.
        """"""

        # waveform names and the dictionary of packed waveforms
        awg_file = self.make_awg_file(
            waveforms, m1s, m2s, nreps, trig_waits,
            goto_states, jump_tos, channels=channels,
            preservechannelsettings=preservechannelsettings)

        # by default, an unusable directory is targeted on the AWG
        self.visa_handle.write('MMEMory:CDIRectory ' +
                               '""C:\\Users\\OEM\\Documents""')

        self.send_awg_file(filename, awg_file)
        currentdir = self.visa_handle.query('MMEMory:CDIRectory?')
        currentdir = currentdir.replace('""', '')
        currentdir = currentdir.replace('\n', '\\')
        loadfrom = f'{currentdir}{filename}'
        self.load_awg_file(loadfrom)

    def make_and_save_awg_file(self,
                               waveforms: Sequence[Sequence[np.ndarray]],
                               m1s: Sequence[Sequence[np.ndarray]],
                               m2s: Sequence[Sequence[np.ndarray]],
                               nreps: Sequence[int],
                               trig_waits: Sequence[int],
                               goto_states: Sequence[int],
                               jump_tos: Sequence[int],
                               channels: Optional[Sequence[int]] = None,
                               filename: str = 'customawgfile.awg',
                               preservechannelsettings: bool = True) -> None:
        """"""
        Makes an .awg-file and saves it locally.

        Args:
            waveforms: A list of the waveforms to upload. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetions per sequence element.  Allowed values: 0 to
                65536. O corresponds to Infinite repetions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels: List of channels to send the waveforms to.
                Example: [1, 3, 2]

            preservechannelsettings: If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are not written in the
                file and will be reset to factory default when the file is
                loaded. Default: True.

            filename: The full path of the .awg-file. Should end with the
                .awg extension. Default: 'customawgfile.awg'
        """"""
        awg_file = self.make_awg_file(
            waveforms, m1s, m2s, nreps, trig_waits,
            goto_states, jump_tos, channels=channels,
            preservechannelsettings=preservechannelsettings)
        with open(filename, 'wb') as fid:
            fid.write(awg_file)

    def get_error(self) -> str:
        """"""
        This function retrieves and returns data from the error and
        event queues.

        Returns:
            String containing the error/event number, the error/event
            description.
        """"""
        return self.ask('SYSTEM:ERRor:NEXT?')

    def _pack_waveform(
            self,
            wf: np.ndarray,
            m1: np.ndarray,
            m2: np.ndarray
    ) -> np.ndarray:
        """"""
        Converts/packs a waveform and two markers into a 16-bit format
        according to the AWG Integer format specification.
        The waveform occupies 14 bits and the markers one bit each.
        See Table 2-25 in the Programmer's manual for more information

        Since markers can only be in one of two states, the marker input
        arrays should consist only of 0's and 1's.

        Args:
            wf: A numpy array containing the waveform. The
                data type of wf is unimportant.
            m1: A numpy array containing the first marker.
            m2: A numpy array containing the second marker.

        Returns:
            An array of unsigned 16 bit integers.

        Raises:
            Exception: if the lengths of w, m1, and m2 don't match
            TypeError: if the waveform contains values outside (-1, 1)
            TypeError: if the markers contain values that are not 0 or 1
        """"""

        # Input validation
        if (not((len(wf) == len(m1)) and (len(m1) == len(m2)))):
            raise Exception('error: sizes of the waveforms do not match')
        if np.min(wf) < -1 or np.max(wf) > 1:
            raise TypeError('Waveform values out of bonds.' +
                            ' Allowed values: -1 to 1 (inclusive)')
        if not np.all(np.in1d(m1, np.array([0, 1]))):
            raise TypeError('Marker 1 contains invalid values.' +
                            ' Only 0 and 1 are allowed')
        if not np.all(np.in1d(m2, np.array([0, 1]))):
            raise TypeError('Marker 2 contains invalid values.' +
                            ' Only 0 and 1 are allowed')

        # Note: we use np.trunc here rather than np.round
        # as it is an order of magnitude faster
        packed_wf = np.trunc(16384 * m1 + 32768 * m2
                             + wf * 8191 + 8191.5).astype(np.uint16)

        if len(np.where(packed_wf == -1)[0]) > 0:
            print(np.where(packed_wf == -1))
        return packed_wf

    ###########################
    # Waveform file functions #
    ###########################

    def _file_dict(
        self, wf: np.ndarray, m1: np.ndarray, m2: np.ndarray, clock: Optional[float]
    ) -> dict[str, Union[np.ndarray, float, None]]:
        """"""
        Make a file dictionary as used by self.send_waveform_to_list

        Args:
            wf: A numpy array containing the waveform. The
                data type of wf is unimportant.
            m1: A numpy array containing the first marker.
            m2: A numpy array containing the second marker.
            clock: The desired clock frequency

        Returns:
            dict: A dictionary with keys 'w', 'm1', 'm2', 'clock_freq', and
                'numpoints' and corresponding values.
        """"""

        outdict = {
            'w': wf,
            'm1': m1,
            'm2': m2,
            'clock_freq': clock,
            'numpoints': len(wf)
        }

        return outdict

    def delete_all_waveforms_from_list(self) -> None:
        """"""
        Delete all user-defined waveforms in the list in a single
        action. Note that there is no “UNDO” action once the waveforms
        are deleted. Use caution before issuing this command.

        If the deleted waveform(s) is (are) currently loaded into
        waveform memory, it (they) is (are) unloaded. If the RUN state
        of the instrument is ON, the state is turned OFF. If the
        channel is on, it will be switched off.
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    def get_filenames(self) -> str:
        """"""Duplicate of self.get_folder_contents""""""
        return self.ask('MMEMory:CATalog?')

    def send_DC_pulse(self,
                      DC_channel_number: int,
                      set_level: float,
                      length: float) -> None:
        """"""
        Sets the DC level on the specified channel, waits a while and then
        resets it to what it was before.

        Note: Make sure that the output DC state is ON.

        Args:
            DC_channel_number (int): The channel number (1-4).
            set_level (float): The voltage level to set to (V).
            length (float): The time to wait before resetting (s).
        """"""
        DC_channel_number -= 1
        chandcs = [self.ch1_DC_out, self.ch2_DC_out, self.ch3_DC_out,
                   self.ch4_DC_out]

        restore = chandcs[DC_channel_number].get()
        chandcs[DC_channel_number].set(set_level)
        sleep(length)
        chandcs[DC_channel_number].set(restore)

    def is_awg_ready(self) -> bool:
        """"""
        Assert if the AWG is ready.

        Returns:
            True, irrespective of anything.
        """"""
        try:
            self.ask('*OPC?')
        # makes the awg read again if there is a timeout
        except Exception as e:
            log.warning(e)
            log.warning('AWG is not ready')
            self.visa_handle.read()
        return True

    def send_waveform_to_list(
            self,
            w: np.ndarray,
            m1: np.ndarray,
            m2: np.ndarray,
            wfmname: str) -> None:
        """"""
        Send a single complete waveform directly to the ""User defined""
        waveform list (prepend it). The data type of the input arrays
        is unimportant, but the marker arrays must contain only 1's
        and 0's.

        Args:
            w: The waveform
            m1: Marker1
            m2: Marker2
            wfmname: waveform name

        Raises:
            Exception: if the lengths of w, m1, and m2 don't match
            TypeError: if the waveform contains values outside (-1, 1)
            TypeError: if the markers contain values that are not 0 or 1
        """"""
        log.debug(f'Sending waveform {wfmname} to instrument')
        # Check for errors
        dim = len(w)

        # Input validation
        if (not((len(w) == len(m1)) and (len(m1) == len(m2)))):
            raise Exception('error: sizes of the waveforms do not match')
        if min(w) < -1 or max(w) > 1:
            raise TypeError('Waveform values out of bonds.' +
                            ' Allowed values: -1 to 1 (inclusive)')
        if (list(m1).count(0) + list(m1).count(1)) != len(m1):
            raise TypeError('Marker 1 contains invalid values.' +
                            ' Only 0 and 1 are allowed')
        if (list(m2).count(0) + list(m2).count(1)) != len(m2):
            raise TypeError('Marker 2 contains invalid values.' +
                            ' Only 0 and 1 are allowed')

        self._values['files'][wfmname] = self._file_dict(w, m1, m2, None)

        # if we create a waveform with the same name but different size,
        # it will not get over written
        # Delete the possibly existing file (will do nothing if the file
        # doesn't exist
        s = f'WLISt:WAVeform:DEL ""{wfmname}""'
        self.write(s)

        # create the waveform
        s = f'WLISt:WAVeform:NEW ""{wfmname}"",{dim:d},INTEGER'
        self.write(s)
        # Prepare the data block
        number = ((2**13 - 1) + (2**13 - 1) * w + 2**14 *
                  np.array(m1) + 2**15 * np.array(m2))
        number = number.astype('int')
        ws_array = arr.array('H', number)

        ws = ws_array.tobytes()
        s1_str = f'WLISt:WAVeform:DATA ""{wfmname}"",'
        s1 = s1_str.encode('UTF-8')
        s3 = ws
        s2_str = '#' + str(len(str(len(s3)))) + str(len(s3))
        s2 = s2_str.encode('UTF-8')

        mes = s1 + s2 + s3
        self.visa_handle.write_raw(mes)

    def clear_message_queue(self, verbose: bool = False) -> None:
        """"""
        Function to clear up (flush) the VISA message queue of the AWG
        instrument. Reads all messages in the queue.

        Args:
            verbose: If True, the read messages are printed.
                Default: False.
        """"""
        original_timeout = self.visa_handle.timeout
        self.visa_handle.timeout = 1000  # 1 second as VISA counts in ms
        gotexception = False
        while not gotexception:
            try:
                message = self.visa_handle.read()
                if verbose:
                    print(message)
            except VisaIOError:
                gotexception = True
        self.visa_handle.timeout = original_timeout


class Tektronix_AWG5014(TektronixAWG5014):
    """"""
    Alias with non-conformant name left for backwards compatibility
    """"""

    pass
"
310,https://www.testequipmenthq.com/datasheets/KEITHLEY-2636B-Datasheet.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attWTucviVCSlbPmo'), ('width', 320), ('height', 145), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZnJu-stNzqeB5V_iyBvwKg/uyPSn7HzprJTY2fuOVguNAKmAntDrm0ywraK2C9kqbszEAuWPs9W9nk_y8_ZjbC1EbFOjA0ZPLqjWOxpfX0912PaMUPoBUIJqbHgs1XJj-Q/CEV_taasyCZf7WfIuSPxZWwiclgldhamm97a9mQPijU'), ('filename', '2636b.webp'), ('size', 7332), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CvAjxnKyGLy6arv4hZhFkQ/g-o74mrPYvEpOFq8y2ckmMEL25MbP97pxgNvt0DRphaj_g-ng68zIITSCwKsCSaIHRcylVszGo5NHtGFNjc0T6Ir-YKNhgmMu3ntY9LyJGk/dzM1qwyINFzsv6TFXjDOQi3v5ng6JKOs4BdoJ4ziAxI'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EdpU_jAAqpryuThz0Xc-xg/lAk16TFT_rD1eulqWjdONYWE9xSfEDd42pH7o9ndcr545n14rKbpwGU0mFCNECjetBGMxn3D1KLT5rL7aDA49G2M8QrcVFnR0hZG-xZHetc/womUhIHQMxWFily-EmHaheOZfMzEtGJPkMEucLFoWFU'), ('width', 320), ('height', 145)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VLJ0jPOwr2mSqszwnws2rA/GS7voa86RLlr2cb9sZtw8EQk2qm_881kahBCSliEdo-hW4raXQSOLZMAi7WqAS9Jyq93VnOR0sZmb3icZ359UJGu8itziQVFqvH1oDuTjX8/UkpZAEa2tQ7XTwD25T3S5SwP2By7e8GoJQUgATb8L60'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2636B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",https://www.newark.com/keithley/2636b/source-meter-voltage-current-30/dp/44W8041,Keithley 2636 B,265.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2636B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782699/Instruments/Power%20Supplies/Keithley-2636B/Keithley-2636B.webp,Keithley 2636B,Write a Python script that uses Qcodes to connect to a Keithley 2636B Power Supplies,23900.0,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
311,,,,,,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116714/Instruments/Vendor%20Logos/NoLogo.png,,,Stahl,528.0,,,,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stahl/stahl.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Stahl.html#qcodes.instrument_drivers.stahl.Stahl,Stahl,,https://r-stahl.com/en/global/home/,,Stahl,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,require module installation,"""""""
This is a driver for the Stahl power supplies
""""""

import logging
import re
from collections import OrderedDict
from collections.abc import Iterable
from functools import partial
from typing import Any, Callable, Optional

import numpy as np
from pyvisa.resources.serial import SerialInstrument

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.validators import Numbers

logger = logging.getLogger()


def chain(*functions: Callable[..., Any]) -> Callable[..., Any]:
    """"""
    The output of the first callable is piped to the input of the second, etc.

    Example:
        >>> def f():
        >>>   return ""1.2""
        >>> chain(f, float)()  # return 1.2 as float
    """"""

    def make_iter(args: Any) -> Iterable[Any]:
        if not isinstance(args, Iterable) or isinstance(args, str):
            return args,
        return args

    def inner(*args: Any) -> Any:
        result = args
        for fun in functions:
            new_args = make_iter(result)
            result = fun(*new_args)

        return result

    return inner


class StahlChannel(InstrumentChannel):
    """"""
    A Stahl source channel

    Args:
        parent
        name
        channel_number
    """"""

    acknowledge_reply = chr(6)

    def __init__(self, parent: VisaInstrument, name: str, channel_number: int):
        super().__init__(parent, name)

        self._channel_string = f""{channel_number:02d}""
        self._channel_number = channel_number

        self.add_parameter(
            ""voltage"",
            get_cmd=f""{self.parent.identifier} U{self._channel_string}"",
            get_parser=chain(
                re.compile(r""^([+\-]\d+,\d+) V$"").findall,
                partial(re.sub, "","", "".""),
                float
            ),
            set_cmd=self._set_voltage,
            unit=""V"",
            vals=Numbers(
                -self.parent.voltage_range,
                self.parent.voltage_range
            )
        )

        self.add_parameter(
            ""current"",
            get_cmd=f""{self.parent.identifier} I{self._channel_string}"",
            get_parser=chain(
                re.compile(r""^([+\-]\d+,\d+) mA$"").findall,
                partial(re.sub, "","", "".""),
                lambda ma: float(ma) / 1000  # Convert mA to A
            ),
            unit=""A"",
        )

        self.add_parameter(
            ""is_locked"",
            get_cmd=self._get_lock_status
        )

    def _set_voltage(self, voltage: float) -> None:
        """"""
        Args:
            voltage
        """"""
        # Normalize the voltage in the range 0 to 1, where 0 is maximum negative
        # voltage and 1 is maximum positive voltage
        voltage_normalized = np.interp(
            voltage,
            self.parent.voltage_range * np.array([-1, 1]),
            [0, 1]
        )

        send_string = f""{self.parent.identifier} CH{self._channel_string} "" \
            f""{voltage_normalized:.5f}""
        response = self.ask(send_string)

        if response != self.acknowledge_reply:
            self.log.warning(
                f""Command {send_string} did not produce an acknowledge reply"")

    def _get_lock_status(self) -> bool:
        """"""
        A lock occurs when an output is overloaded

        Return:
            lock_status: True when locked
        """"""
        send_string = f""{self.parent.identifier} LOCK""

        response = self.parent.visa_handle.query_binary_values(
            send_string,
            datatype='B',
            header_fmt=""empty""
        )

        channel_index = self._channel_number - 1
        channel_group = channel_index // 4
        lock_code_group = response[channel_group]
        return format(lock_code_group, ""b"")[channel_index % 4 + 1] == ""1""


class Stahl(VisaInstrument):
    """"""
    Stahl driver.

    Args:
        name
        address: A serial port address
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator=""\r"", **kwargs)
        assert isinstance(self.visa_handle, SerialInstrument)

        self.visa_handle.baud_rate = 115200

        instrument_info = self.parse_idn_string(
            self.ask(""IDN"")
        )

        for key, value in instrument_info.items():
            setattr(self, key, value)

        channels = ChannelList(
            self, ""channel"", StahlChannel, snapshotable=False
        )

        for channel_number in range(1, self.n_channels + 1):
            name = f""channel{channel_number}""
            channel = StahlChannel(
                self,
                name,
                channel_number
            )
            self.add_submodule(name, channel)
            channels.append(channel)

        self.add_submodule(""channel"", channels)

        self.add_parameter(
            ""temperature"",
            get_cmd=f""{self.identifier} TEMP"",
            get_parser=chain(
                re.compile(""^TEMP (.*)°C$"").findall,
                float
            ),
            unit=""C""
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response

    @staticmethod
    def parse_idn_string(idn_string: str) -> dict[str, Any]:
        """"""
        Return:
             dict: The dict contains the following keys ""model"",
             ""serial_number"", ""voltage_range"",""n_channels"", ""output_type""
        """"""
        result = re.search(
            r""(HV|BS)(\d{3}) (\d{3}) (\d{2}) ([buqsm])"",
            idn_string
        )

        if result is None:
            raise RuntimeError(
                ""Unexpected instrument response. Perhaps the model of the ""
                ""instrument does not match the drivers expectation or a ""
                ""firmware upgrade has taken place. Please get in touch ""
                ""with a QCoDeS core developer""
            )

        converters: dict[str, Callable[..., Any]] = OrderedDict(
            {
                ""model"": str,
                ""serial_number"": str,
                ""voltage_range"": float,
                ""n_channels"": int,
                ""output_type"": {
                    ""b"": ""bipolar"",
                    ""u"": ""unipolar"",
                    ""q"": ""quadrupole"",
                    ""s"": ""steerer"",
                    ""m"": ""bipolar milivolt"",
                }.get,
            }
        )

        return {
            name: converter(value)
            for (name, converter), value in zip(converters.items(), result.groups())
        }

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        The Stahl sends a uncommon IDN string which does not include a
        firmware version.
        """"""
        return {
            ""vendor"": ""Stahl"",
            ""model"": self.model,
            ""serial"": self.serial_number,
            ""firmware"": None
        }

    @property
    def identifier(self) -> str:
        return f""{self.model}{self.serial_number}""
"
313,https://download.tek.com/datasheet/1KW-60906-0_Series_2600BDatasheet_112718.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'atteZ4wUgdO693Swh'), ('width', 320), ('height', 143), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tTWkie-XmaKVe5tI8HPczA/LKWq6ZB8mjm0DvDCTNBUOe6jO7gSWTExhQaNyueQY27a8JIdnYkRmDEXk0Ewt9dhMzbhl6BPfMX0B5wTxkAcjzxiH8zaf8pGs5tgq-8G3KE/LSqoBrdYnV5uzWq6UMdf1tvBKnh1aOnQum8yG6seYCE'), ('filename', '2614b.webp'), ('size', 7384), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HdprCh5YWF2D-aDRNAVVzA/CgKe8HaNiCXZEb-YEWP9f7qRvXAq-SNtQI240O63A1_8rXjKRSavkmAwy85IpW0iCHC0hKDLiH_DeVJZiVRIjxNaCd1pwWQyyvumxWRtGcU/rdDE9evG1hbyggHo9mKVfeFQV3ypJByGv4ATKAoiLHI'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZZtVdTdQzj3QLs7-f0gZsw/fFDWTg_lh7AMaHX2gY-bl-tfk8tD5RBUTLbVmbGoT-oBBODK6V-rjhOjjmkIDJ3AU8UXnmDUhRbXatboN5FJNiJs6bjOky-SWhLaUA2IMFA/JqNL3rDT1Mkc66UOTczCksB1TRrqRCoDm6Rv-wg9gg8'), ('width', 320), ('height', 143)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yiym-jV7pYCA62OlRUJOKw/LJK2xV8X9x9MuoCrAogQ8ynWaooS8ib1AH0ydYlmq13ShvMYJCAMX_0EHWZw9rcubW4dnY_QLFZdnAtcR19bjPiGC3TsNc5H-pl3PL5M_OE/UQ5_eSeu4wM-34O0aA2q-XEBrnCmeKSEIr4-OE03w5s'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The 2614B SourceMeter SMU Instrument is a new dual-channel SMU instrument with best-in-class value and performance. Its tightly integrated, four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The Model 2614B is equipped with Keithley's high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2614B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2612B SourceMeter SMU Instrument, which includes digital I/O, TSP-Link technology, and contact check function.",https://www.newark.com/keithley/2614b/source-meter-voltage-current-30/dp/44W8038,Keithley 2614 B,268.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/_Keithley_2600.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2614B,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782701/Instruments/Power%20Supplies/Keithley-2614B/Keithley-2614B.webp,Keithley 2614B,Write a Python script that uses Qcodes to connect to a Keithley 2614B Power Supplies,13800.0,,,,"from __future__ import annotations

import logging
import struct
import sys
import warnings
from collections.abc import Sequence
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)

if TYPE_CHECKING:
    from qcodes_loop.data.data_set import DataSet


if sys.version_info >= (3, 11):
    from enum import StrEnum
else:

    class StrEnum(str, Enum):
        pass

log = logging.getLogger(__name__)


class LuaSweepParameter(ArrayParameter):
    """"""
    Parameter class to hold the data from a
    deployed Lua script sweep.
    """"""

    def __init__(self, name: str, instrument: Instrument, **kwargs: Any) -> None:

        super().__init__(
            name=name,
            shape=(1,),
            docstring=""Holds a sweep"",
            instrument=instrument,
            **kwargs,
        )

    def prepareSweep(self, start: float, stop: float, steps: int, mode: str) -> None:
        """"""
        Builds setpoints and labels

        Args:
            start: Starting point of the sweep
            stop: Endpoint of the sweep
            steps: No. of sweep steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        if mode not in [""IV"", ""VI"", ""VIfourprobe""]:
            raise ValueError('mode must be either ""VI"", ""IV"" or ""VIfourprobe""')

        self.shape = (steps,)

        if mode == ""IV"":
            self.unit = ""A""
            self.setpoint_names = (""Voltage"",)
            self.setpoint_units = (""V"",)
            self.label = ""current""
            self._short_name = ""iv_sweep""

        if mode == ""VI"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep""

        if mode == ""VIfourprobe"":
            self.unit = ""V""
            self.setpoint_names = (""Current"",)
            self.setpoint_units = (""A"",)
            self.label = ""voltage""
            self._short_name = ""vi_sweep_four_probe""

        self.setpoints = (tuple(np.linspace(start, stop, steps)),)

        self.start = start
        self.stop = stop
        self.steps = steps
        self.mode = mode

    def get_raw(self) -> np.ndarray:

        if self.instrument is not None:
            data = self.instrument._fast_sweep(
                self.start, self.stop, self.steps, self.mode
            )
        else:
            raise RuntimeError(""No instrument attached to Parameter."")

        return data


class TimeTrace(ParameterWithSetpoints):
    """"""
    A parameter class that holds the data corresponding to the time dependence of
    current and voltage.
    """"""

    def _check_time_trace(self) -> None:
        """"""
        A helper function that compares the integration time with measurement
        interval for accurate results.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""
        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        dt = self.instrument.timetrace_dt()
        nplc = self.instrument.nplc()
        linefreq = self.instrument.linefreq()
        plc = 1 / linefreq
        if nplc * plc > dt:
            warnings.warn(
                f""Integration time of {nplc*plc*1000:.1f} ""
                + f""ms is longer than {dt*1000:.1f} ms set ""
                + ""as measurement interval. Consider lowering ""
                + ""NPLC or increasing interval."",
                UserWarning,
                2,
            )

    def _set_mode(self, mode: str) -> None:
        """"""
        A helper function to set correct units and labels.

        Args:
            mode: User defined mode for the timetrace. It can be either
            ""current"" or ""voltage"".
        """"""
        if mode == ""current"":
            self.unit = ""A""
            self.label = ""Current""
        if mode == ""voltage"":
            self.unit = ""V""
            self.label = ""Voltage""

    def _time_trace(self) -> np.ndarray:
        """"""
        The function that prepares a Lua script for timetrace data acquisition.

        Raises:
            RuntimeError: If no instrument attached to Parameter.
        """"""

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        channel = self.instrument.channel
        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        mode = self.instrument.timetrace_mode()

        mode_map = {""current"": ""i"", ""voltage"": ""v""}

        script = [
            f""{channel}.measure.count={npts}"",
            f""oldint={channel}.measure.interval"",
            f""{channel}.measure.interval={dt}"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.measure.{mode_map[mode]}({channel}.nvbuffer1)"",
            f""{channel}.measure.interval=oldint"",
            f""{channel}.measure.count=1"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {npts}, {channel}.nvbuffer1.readings)"",
        ]

        return self.instrument._execute_lua(script, npts)

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        self._check_time_trace()
        data = self._time_trace()
        return data


class TimeAxis(Parameter):
    """"""
    A simple :class:`.Parameter` that holds all the times (relative to the
    measurement start) at which the points of the time trace were acquired.
    """"""

    def get_raw(self) -> np.ndarray:  # pylint: disable=E0202

        if self.instrument is None:
            raise RuntimeError(""No instrument attached to Parameter."")

        npts = self.instrument.timetrace_npts()
        dt = self.instrument.timetrace_dt()
        return np.linspace(0, dt * npts, npts, endpoint=False)


class Keithley2600MeasurementStatus(StrEnum):
    """"""
    Keeps track of measurement status.
    """"""

    CURRENT_COMPLIANCE_ERROR = ""Reached current compliance limit.""
    VOLTAGE_COMPLIANCE_ERROR = ""Reached voltage compliance limit.""
    VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR = (
        ""Reached both voltage and current compliance limits.""
    )
    NORMAL = ""No error occured.""
    COMPLIANCE_ERROR = ""Reached compliance limit.""  # deprecated, dont use it. It exists only for backwards compatibility


MeasurementStatus = Keithley2600MeasurementStatus
""Alias for backwards compatibility. Will eventually be deprecated and removed""

_from_bits_tuple_to_status = {
    (0, 0): Keithley2600MeasurementStatus.NORMAL,
    (1, 0): Keithley2600MeasurementStatus.VOLTAGE_COMPLIANCE_ERROR,
    (0, 1): Keithley2600MeasurementStatus.CURRENT_COMPLIANCE_ERROR,
    (1, 1): Keithley2600MeasurementStatus.VOLTAGE_AND_CURRENT_COMPLIANCE_ERROR,
}


class _ParameterWithStatus(Parameter):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self._measurement_status: Keithley2600MeasurementStatus | None = None

    @property
    def measurement_status(self) -> Keithley2600MeasurementStatus | None:
        return self._measurement_status

    @staticmethod
    def _parse_response(data: str) -> tuple[float, Keithley2600MeasurementStatus]:
        value, meas_status = data.split(""\t"")

        status_bits = [
            int(i)
            for i in bin(int(float(meas_status))).replace(""0b"", """").zfill(16)[::-1]
        ]

        status = _from_bits_tuple_to_status[
            (status_bits[0], status_bits[1])
        ]  # pyright: ignore[reportGeneralTypeIssues]

        return float(value), status

    def snapshot_base(
        self,
        update: bool | None = True,
        params_to_skip_update: Sequence[str] | None = None,
    ) -> dict[Any, Any]:
        snapshot = super().snapshot_base(
            update=update, params_to_skip_update=params_to_skip_update
        )

        if self._snapshot_value:
            snapshot[""measurement_status""] = self.measurement_status

        return snapshot


class _MeasurementCurrentParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.leveli={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.i(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class _MeasurementVoltageParameter(_ParameterWithStatus):
    def set_raw(self, value: ParamRawDataType) -> None:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu_chan = self.instrument
        channel = smu_chan.channel

        smu_chan.write(f""{channel}.source.levelv={value:.12f}"")

        smu_chan._reset_measurement_statuses_of_parameters()

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, Keithley2600Channel)
        assert isinstance(self.root_instrument, Keithley2600)

        smu = self.instrument
        channel = self.instrument.channel

        data = smu.ask(
            f""{channel}.measure.v(), ""
            f""status.measurement.instrument.{channel}.condition""
        )
        value, status = self._parse_response(data)

        self._measurement_status = status

        return value


class Keithley2600Channel(InstrumentChannel):
    """"""
    Class to hold the two Keithley channels, i.e.
    SMUA and SMUB.
    """"""

    def __init__(self, parent: Instrument, name: str, channel: str) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel
            channel: The name used by the Keithley, i.e. either
                'smua' or 'smub'
        """"""

        if channel not in [""smua"", ""smub""]:
            raise ValueError('channel must be either ""smub"" or ""smua""')

        super().__init__(parent, name)
        self.model = self._parent.model
        self._extra_visa_timeout = 5000
        self._measurement_duration_factor = 2  # Ensures that we are always above
        # the expected time.
        vranges = self._parent._vranges
        iranges = self._parent._iranges
        vlimit_minmax = self.parent._vlimit_minmax
        ilimit_minmax = self.parent._ilimit_minmax

        self.add_parameter(
            ""volt"",
            parameter_class=_MeasurementVoltageParameter,
            label=""Voltage"",
            unit=""V"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""curr"",
            parameter_class=_MeasurementCurrentParameter,
            label=""Current"",
            unit=""A"",
            snapshot_get=False,
        )

        self.add_parameter(
            ""res"",
            get_cmd=f""{channel}.measure.r()"",
            get_parser=float,
            set_cmd=False,
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f""{channel}.source.func"",
            get_parser=float,
            set_cmd=f""{channel}.source.func={{:d}}"",
            val_mapping={""current"": 0, ""voltage"": 1},
            docstring=""Selects the output source type. ""
            ""Can be either voltage or current."",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""{channel}.source.output"",
            get_parser=float,
            set_cmd=f""{channel}.source.output={{:d}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""linefreq"",
            label=""Line frequency"",
            get_cmd=""localnode.linefreq"",
            get_parser=float,
            set_cmd=False,
            unit=""Hz"",
        )

        self.add_parameter(
            ""nplc"",
            label=""Number of power line cycles"",
            set_cmd=f""{channel}.measure.nplc={{}}"",
            get_cmd=f""{channel}.measure.nplc"",
            get_parser=float,
            docstring=""Number of power line cycles, used "" ""to perform measurements"",
            vals=vals.Numbers(0.001, 25),
        )
        # volt range
        # needs get after set (WilliamHPNielsen): why?
        self.add_parameter(
            ""sourcerange_v"",
            label=""voltage source range"",
            get_cmd=f""{channel}.source.rangev"",
            get_parser=float,
            set_cmd=self._set_sourcerange_v,
            unit=""V"",
            docstring=""The range used when sourcing voltage ""
            ""This affects the range and the precision ""
            ""of the source."",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_v_enabled"",
            label=""voltage source autorange"",
            get_cmd=f""{channel}.source.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangev={{}}"",
            docstring=""Set autorange on/off for source voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_v"",
            label=""voltage measure range"",
            get_cmd=f""{channel}.measure.rangev"",
            get_parser=float,
            set_cmd=self._set_measurerange_v,
            unit=""V"",
            docstring=""The range to perform voltage ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and ""
            ""source current this will have no effect, ""
            ""set `sourcerange_v` instead"",
            vals=vals.Enum(*vranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_v_enabled"",
            label=""voltage measure autorange"",
            get_cmd=f""{channel}.measure.autorangev"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangev={{}}"",
            docstring=""Set autorange on/off for measure voltage."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # current range
        # needs get after set
        self.add_parameter(
            ""sourcerange_i"",
            label=""current source range"",
            get_cmd=f""{channel}.source.rangei"",
            get_parser=float,
            set_cmd=self._set_sourcerange_i,
            unit=""A"",
            docstring=""The range used when sourcing current ""
            ""This affects the range and the ""
            ""precision of the source."",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""source_autorange_i_enabled"",
            label=""current source autorange"",
            get_cmd=f""{channel}.source.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.source.autorangei={{}}"",
            docstring=""Set autorange on/off for source current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""measurerange_i"",
            label=""current measure range"",
            get_cmd=f""{channel}.measure.rangei"",
            get_parser=float,
            set_cmd=self._set_measurerange_i,
            unit=""A"",
            docstring=""The range to perform current ""
            ""measurements in. This affects the range ""
            ""and the precision of the measurement. ""
            ""Note that if you both measure and source ""
            ""current this will have no effect, set ""
            ""`sourcerange_i` instead"",
            vals=vals.Enum(*iranges[self.model]),
        )

        self.add_parameter(
            ""measure_autorange_i_enabled"",
            label=""current autorange"",
            get_cmd=f""{channel}.measure.autorangei"",
            get_parser=float,
            set_cmd=f""{channel}.measure.autorangei={{}}"",
            docstring=""Set autorange on/off for measure current."",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )
        # Compliance limit
        self.add_parameter(
            ""limitv"",
            get_cmd=f""{channel}.source.limitv"",
            get_parser=float,
            set_cmd=f""{channel}.source.limitv={{}}"",
            docstring=""Voltage limit e.g. the maximum voltage ""
            ""allowed in current mode. If exceeded ""
            ""the current will be clipped."",
            vals=vals.Numbers(
                vlimit_minmax[self.model][0], vlimit_minmax[self.model][1]
            ),
            unit=""V"",
        )
        # Compliance limit
        self.add_parameter(
            ""limiti"",
            get_cmd=f""{channel}.source.limiti"",
            get_parser=float,
            set_cmd=f""{channel}.source.limiti={{}}"",
            docstring=""Current limit e.g. the maximum current ""
            ""allowed in voltage mode. If exceeded ""
            ""the voltage will be clipped."",
            vals=vals.Numbers(
                ilimit_minmax[self.model][0], ilimit_minmax[self.model][1]
            ),
            unit=""A"",
        )

        self.add_parameter(""fastsweep"", parameter_class=LuaSweepParameter)

        self.add_parameter(
            ""timetrace_npts"",
            initial_value=500,
            label=""Number of points"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            ""timetrace_dt"",
            initial_value=1e-3,
            label=""Time resolution"",
            unit=""s"",
            get_cmd=None,
            set_cmd=None,
        )

        self.add_parameter(
            name=""time_axis"",
            label=""Time"",
            unit=""s"",
            snapshot_value=False,
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            parameter_class=TimeAxis,
        )

        self.add_parameter(
            ""timetrace"",
            vals=vals.Arrays(shape=(self.timetrace_npts,)),
            setpoints=(self.time_axis,),
            parameter_class=TimeTrace,
        )

        self.add_parameter(
            ""timetrace_mode"",
            initial_value=""current"",
            get_cmd=None,
            set_cmd=self.timetrace._set_mode,
            vals=vals.Enum(""current"", ""voltage""),
        )

        self.channel = channel

    def _reset_measurement_statuses_of_parameters(self) -> None:
        assert isinstance(self.volt, _ParameterWithStatus)
        self.volt._measurement_status = None
        assert isinstance(self.curr, _ParameterWithStatus)
        self.curr._measurement_status = None

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets only the relevant channel.
        """"""
        self.write(f""{self.channel}.reset()"")
        # remember to update all the metadata
        log.debug(f""Reset channel {self.channel}."" + ""Updating settings..."")
        self.snapshot(update=True)

    def doFastSweep(self, start: float, stop: float, steps: int, mode: str) -> DataSet:
        """"""
        Perform a fast sweep using a deployed lua script and
        return a QCoDeS DataSet with the sweep.

        Args:
            start: starting sweep value (V or A)
            stop: end sweep value (V or A)
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""
        try:
            from qcodes_loop.measure import Measure
        except ImportError as e:
            raise ImportError(
                ""The doFastSweep method requires the ""
                ""qcodes_loop package to be installed.""
            ) from e
        # prepare setpoints, units, name
        self.fastsweep.prepareSweep(start, stop, steps, mode)

        data = Measure(self.fastsweep).run()

        return data

    def _fast_sweep(
        self,
        start: float,
        stop: float,
        steps: int,
        mode: Literal[""IV"", ""VI"", ""VIfourprobe""] = ""IV"",
    ) -> np.ndarray:
        """"""
        Perform a fast sweep using a deployed Lua script.
        This is the engine that forms the script, uploads it,
        runs it, collects the data, and casts the data correctly.

        Args:
            start: starting voltage
            stop: end voltage
            steps: number of steps
            mode: Type of sweep, either 'IV' (voltage sweep),
                'VI' (current sweep two probe setup) or
                'VIfourprobe' (current sweep four probe setup)
        """"""

        channel = self.channel

        # an extra visa query, a necessary precaution
        # to avoid timing out when waiting for long
        # measurements
        nplc = self.nplc()

        dV = (stop - start) / (steps - 1)

        if mode == ""IV"":
            meas = ""i""
            sour = ""v""
            func = ""1""
            sense_mode = ""0""
        elif mode == ""VI"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""0""
        elif mode == ""VIfourprobe"":
            meas = ""v""
            sour = ""i""
            func = ""0""
            sense_mode = ""1""
        else:
            raise ValueError(f""Invalid mode {mode}"")

        script = [
            f""{channel}.measure.nplc = {nplc:.12f}"",
            f""{channel}.source.output = 1"",
            f""startX = {start:.12f}"",
            f""dX = {dV:.12f}"",
            f""{channel}.sense = {sense_mode}"",
            f""{channel}.source.output = 1"",
            f""{channel}.source.func = {func}"",
            f""{channel}.measure.count = 1"",
            f""{channel}.nvbuffer1.clear()"",
            f""{channel}.nvbuffer1.appendmode = 1"",
            f""for index = 1, {steps} do"",
            ""  target = startX + (index-1)*dX"",
            f""  {channel}.source.level{sour} = target"",
            f""  {channel}.measure.{meas}({channel}.nvbuffer1)"",
            ""end"",
            ""format.data = format.REAL32"",
            ""format.byteorder = format.LITTLEENDIAN"",
            f""printbuffer(1, {steps}, {channel}.nvbuffer1.readings)"",
        ]

        return self._execute_lua(script, steps)

    def _execute_lua(self, _script: list[str], steps: int) -> np.ndarray:
        """"""
        This is the function that sends the Lua script to be executed and
        returns the corresponding data from the buffer.

        Args:
            _script: The Lua script to be executed.
            steps: Number of points.
        """"""
        nplc = self.nplc()
        linefreq = self.linefreq()
        _time_trace_extra_visa_timeout = self._extra_visa_timeout
        _factor = self._measurement_duration_factor
        estimated_measurement_duration = _factor * 1000 * steps * nplc / linefreq
        new_visa_timeout = (
            estimated_measurement_duration + _time_trace_extra_visa_timeout
        )

        self.write(self.root_instrument._scriptwrapper(program=_script, debug=True))

        # now poll all the data
        # The problem is that a '\n' character might by chance be present in
        # the data
        fullsize = 4 * steps + 3
        received = 0
        data = b""""
        # we must wait for the script to execute
        with self.root_instrument.timeout.set_to(new_visa_timeout):
            while received < fullsize:
                data_temp = self.root_instrument.visa_handle.read_raw()
                received += len(data_temp)
                data += data_temp

        # From the manual p. 7-94, we know that a b'#0' is prepended
        # to the data and a b'\n' is appended
        data = data[2:-1]
        outdata = np.array(list(struct.iter_unpack(""<f"", data)))
        outdata = np.reshape(outdata, len(outdata))
        return outdata

    def _set_sourcerange_v(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_v_enabled(False)
        self.write(f""{channel}.source.rangev={val}"")

    def _set_measurerange_v(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_v_enabled(False)
        self.write(f""{channel}.measure.rangev={val}"")

    def _set_sourcerange_i(self, val: float) -> None:
        channel = self.channel
        self.source_autorange_i_enabled(False)
        self.write(f""{channel}.source.rangei={val}"")

    def _set_measurerange_i(self, val: float) -> None:
        channel = self.channel
        self.measure_autorange_i_enabled(False)
        self.write(f""{channel}.measure.rangei={val}"")


class Keithley2600(VisaInstrument):
    """"""
    This is the qcodes driver for the Keithley 2600 Source-Meter series,
    tested with Keithley 2614B

    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        model = self.ask(""localnode.model"")

        knownmodels = [
            ""2601B"",
            ""2602A"",
            ""2602B"",
            ""2604B"",
            ""2611B"",
            ""2612B"",
            ""2614B"",
            ""2634B"",
            ""2635B"",
            ""2636B"",
        ]
        if model not in knownmodels:
            kmstring = (""{}, "" * (len(knownmodels) - 1)).format(*knownmodels[:-1])
            kmstring += f""and {knownmodels[-1]}.""
            raise ValueError(""Unknown model. Known model are: "" + kmstring)

        self.model = model

        self._vranges = {
            ""2601B"": [0.1, 1, 6, 40],
            ""2602A"": [0.1, 1, 6, 40],
            ""2602B"": [0.1, 1, 6, 40],
            ""2604B"": [0.1, 1, 6, 40],
            ""2611B"": [0.2, 2, 20, 200],
            ""2612B"": [0.2, 2, 20, 200],
            ""2614B"": [0.2, 2, 20, 200],
            ""2634B"": [0.2, 2, 20, 200],
            ""2635B"": [0.2, 2, 20, 200],
            ""2636B"": [0.2, 2, 20, 200],
        }

        # TODO: In pulsed mode, models 2611B, 2612B, and 2614B
        # actually allow up to 10 A.
        self._iranges = {
            ""2601B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602A"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2602B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2604B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 3],
            ""2611B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2612B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2614B"": [100e-9, 1e-6, 10e-6, 100e-6, 1e-3, 0.01, 0.1, 1, 1.5],
            ""2634B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2635B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
            ""2636B"": [
                1e-9,
                10e-9,
                100e-9,
                1e-6,
                10e-6,
                100e-6,
                1e-3,
                10e-6,
                100e-3,
                1,
                1.5,
            ],
        }

        self._vlimit_minmax = {
            ""2601B"": [10e-3, 40],
            ""2602A"": [10e-3, 40],
            ""2602B"": [10e-3, 40],
            ""2604B"": [10e-3, 40],
            ""2611B"": [20e-3, 200],
            ""2612B"": [20e-3, 200],
            ""2614B"": [20e-3, 200],
            ""2634B"": [20e-3, 200],
            ""2635B"": [20e-3, 200],
            ""2636B"": [20e-3, 200],
        }

        self._ilimit_minmax = {
            ""2601B"": [10e-9, 3],
            ""2602A"": [10e-9, 3],
            ""2602B"": [10e-9, 3],
            ""2604B"": [10e-9, 3],
            ""2611B"": [10e-9, 3],
            ""2612B"": [10e-9, 3],
            ""2614B"": [10e-9, 3],
            ""2634B"": [100e-12, 1.5],
            ""2635B"": [100e-12, 1.5],
            ""2636B"": [100e-12, 1.5],
        }
        # Add the channel to the instrument
        self.channels: list[Keithley2600Channel] = []
        for ch in [""a"", ""b""]:
            ch_name = f""smu{ch}""
            channel = Keithley2600Channel(self, ch_name, ch_name)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        # display
        self.add_parameter(
            ""display_settext"", set_cmd=self._display_settext, vals=vals.Strings()
        )

        self.connect_message()

    def _display_settext(self, text: str) -> None:
        self.visa_handle.write(f'display.settext(""{text}"")')

    def get_idn(self) -> dict[str, str | None]:
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))
        model = model[6:]

        IDN: dict[str, str | None] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def display_clear(self) -> None:
        """"""
        This function clears the display, but also leaves it in user mode
        """"""
        self.visa_handle.write(""display.clear()"")

    def display_normal(self) -> None:
        """"""
        Set the display to the default mode
        """"""
        self.visa_handle.write(""display.screen = display.SMUA_SMUB"")

    def exit_key(self) -> None:
        """"""
        Get back the normal screen after an error:
        send an EXIT key press event
        """"""
        self.visa_handle.write(""display.sendkey(75)"")

    def reset(self) -> None:
        """"""
        Reset instrument to factory defaults.
        This resets both channels.
        """"""
        self.write(""reset()"")
        # remember to update all the metadata
        log.debug(""Reset instrument. Re-querying settings..."")
        self.snapshot(update=True)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")

    @staticmethod
    def _scriptwrapper(program: list[str], debug: bool = False) -> str:
        """"""
        wraps a program so that the output can be put into
        visa_handle.write and run.
        The script will run immediately as an anonymous script.

        Args:
            program: A list of program instructions. One line per
            list item, e.g. ['for ii = 1, 10 do', 'print(ii)', 'end' ]
        """"""
        mainprog = ""\r\n"".join(program) + ""\r\n""
        wrapped = f""loadandrunscript\r\n{mainprog}endscript""
        if debug:
            log.debug(""Wrapped the following script:"")
            log.debug(wrapped)
        return wrapped
"
315,,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'atttN3wQNVQ7fDNe9'), ('width', 4188), ('height', 2470), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/UDBvOKxTeVK7_zUT02Qliw/2F3-qP7WtbhrTOxeD3vCtGdKe8UZUlyjBowH6bCxJkG4KTTyHIKCENhdXs9NgDrnQgz4UCC8TH605e03MVLMh6_YCZ78l5QKsqmL56HZedw/-dem91IS8pIxnvbBK3-SmkT3fsdpMMy6vlezjtNpaN0'), ('filename', 'SR865A.jpeg'), ('size', 2302119), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1u0SkG_eZ92W28v_jz0Nkg/Ope6JXcD8tfE-niu6oBewhsRCf8VPwWA1wU4cQvB6z8JKuj_CXeAd06CPzC0zfptXapyqJlBfZ8bU1wxYInheQ/hVgIDdqlt5UldnYstwTCuMFF06Xh7vFxuyHFZX9kUOw'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ySz09l8iXJHvePJnB91C3g/YPYrZ8UgWQjNO9D_hnbd2F_Fi3-o5h8c8KOSeCQJ5Lk_5XHQmt9J9sdX1dbERz0IRMQu2B40gp2E8_mO-VM2qw/8QTywGcsasF97fYGBHV3pG5g9XiLJ0_SPDS-ooqabd4'), ('width', 868), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/EfyZtESnXlrjRAdEhU4ypA/U-PHc9pNSw73yyx1unS1UWM2-6Ry8bSql-CKqtJUDz0K1D_p-0EJbLpd5FvV07qRnZvzHeB5Q31oZskLrXre9A/WroEpjAAmAam-hkU7Fien4bmh9LcHjMXUU1bmfLAces'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,,,SR 865,531.0,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR865.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR860,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782703/Instruments/Lockin%20Amplifiers/SR-865/SR-865.jpg,SR 865,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,,,,,"from qcodes.instrument_drivers.stanford_research.SR86x import SR86x


class SR865(SR86x):
    """"""
    QCoDeS driver for the Stanford Research Systems SR865 Lock-in Amplifier.

    The SR865 instrument is almost equal to the SR860, except for the max frequency
    """"""

    def __init__(
        self, name: str, address: str, reset: bool = False, **kwargs: str
    ) -> None:
        super().__init__(name, address, max_frequency=2e6, reset=reset, **kwargs)
"
323,,https://en.wikipedia.org/wiki/Function_generator,"[OrderedDict([('id', 'att7O8kQA6F5OfhRY'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Bv1AtSDoQyf6Y3VQMzotFw/5NB_R7HoVM01T1ASGD-cu0In0IKcyGrlM-AMVQF5cRZ5-2kEXKaBWh7xbjMC8lp-cl8ZSzOGeTskSdlsaRWa4gmi4EYCXuZ-F9MlzKF8KedN5svO8K1ZvUUBqAp7ICBm/G49uq3JlNdesfWgLktX86hYC7KGAhgaFWUbxJkErSt0'), ('filename', 'dg1062z-front-1200x735-White-b.jpg'), ('size', 129264), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yxrnidwq1VSzZ8pheBG8gQ/TxFBzgcT_O9FAI2fDr-LH0541Emyj2GsNggUNyjjLy4vRgKncC8Kqa8zcL9gtrq9dT_3gPE7t1pyWTTBbzRhsg/SCJu0RjT8Zt1dWccYJcRCaU7cJcu1OVB_OScWsSYo9M'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/8G1LSJcnoOYpIGeSmShiMg/ysXoILQJWldNe7I9WTa-9F6XWGLTu3w5RCHtJvBcRoH7ikc15CsQtfiHfEij7Xc2I39hgx8WjAkaPV_NzoPQ3w/jXWWe8NZ3VrLtNhz5iotSax5jeGIjgBQHiob0YP5J8U'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LQrC37Rtuas__pR3R9MEpQ/tLeCP3Q-Hh2VQ9AoswGaWepDihbOdop9SokTNrwaUSPE-oQdxKgjro-uwciFZjreJFYhdjaA1ckgC2-56v_31A/HxVkquQXNladqV_d46UBWHXu3MDcoeZvbF_McWsI4MI'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"The Rigol DG1062Z is a two channel Function / Arbitrary Waveform Generator to create high quality signals up to 60 MHz (Sine) with very low jitter (200 ps) and the new SiFi (SIgnal FIdelity) technology. Beside the two analog outputs, the device includes an USB-Host- and an USB-device interface.

",https://www.batronix.com/shop/waveform-generator/Rigol-DG1062Z.html,Rigol DG 1062,452.0,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DG1062.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDG1062,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782710/Instruments/Function%20Generators/Rigol-DG1062Z/Rigol-DG1062Z.jpg,Rigol DG1062Z,Write a Python script that uses Qcodes to connect to a Rigol DG1062Z Function Generators,,,,,"import logging
from functools import partial
from typing import Any, Union, cast

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.utils import partial_with_docstring

log = logging.getLogger(__name__)


class RigolDG1062Burst(InstrumentChannel):
    """"""
    Burst commands for the DG1062. We make a separate channel for these to
    group burst commands together.
    """"""

    def __init__(self, parent: ""RigolDG1062"", name: str, channel: int):
        super().__init__(parent, name)
        self.channel = channel

        self.add_parameter(
            ""on"",
            get_cmd=f"":SOUR{channel}:BURS?"",
            set_cmd=f"":SOUR{channel}:BURS {{}}"",
            vals=vals.Enum(0, 1, ""ON"", ""OFF""),
        )

        self.add_parameter(
            ""polarity"",
            get_cmd=f"":SOUR{channel}:BURS:GATE:POL?"",
            set_cmd=f"":SOUR{channel}:BURS:GATE:POL {{}}"",
            vals=vals.Enum(""NORM"", ""INV""),
        )

        self.add_parameter(
            ""period"",
            get_cmd=f"":SOUR{channel}:BURS:INT:PER?"",
            set_cmd=f"":SOUR{channel}:BURS:INT:PER {{}}"",
            vals=vals.MultiType(
                vals.Numbers(min_value=3e-6, max_value=500), vals.Enum(""MIN"", ""MAX"")
            ),
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f"":SOUR{channel}:BURS:MODE?"",
            set_cmd=f"":SOUR{channel}:BURS:MODE {{}}"",
            vals=vals.Enum(""TRIG"", ""INF"", ""GAT""),
        )

        self.add_parameter(
            ""ncycles"",
            get_cmd=f"":SOUR{channel}:BURS:NCYC?"",
            set_cmd=f"":SOUR{channel}:BURS:NCYC {{}}"",
            vals=vals.Numbers(min_value=1, max_value=500000),
        )

        self.add_parameter(
            ""phase"",
            get_cmd=f"":SOUR{channel}:BURS:PHAS?"",
            set_cmd=f"":SOUR{channel}:BURS:PHAS {{}}"",
            vals=vals.Numbers(min_value=0, max_value=360),
        )

        self.add_parameter(
            ""time_delay"",
            get_cmd=f"":SOUR{channel}:BURS:TDEL?"",
            set_cmd=f"":SOUR{channel}:BURS:TDEL {{}}"",
            vals=vals.Numbers(min_value=0),
        )

        self.add_parameter(
            ""trigger_slope"",
            get_cmd=f"":SOUR{channel}:BURS:TRIG:SLOP?"",
            set_cmd=f"":SOUR{channel}:BURS:TRIG:SLOP {{}}"",
            vals=vals.Enum(""POS"", ""NEG""),
        )

        self.add_parameter(
            ""source"",
            get_cmd=f"":SOUR{channel}:BURS:TRIG:SOUR?"",
            set_cmd=f"":SOUR{channel}:BURS:TRIG:SOUR {{}}"",
            vals=vals.Enum(""INT"", ""EXT"", ""MAN""),
        )

        self.add_parameter(
            ""idle"",
            get_cmd=f"":SOUR{channel}:BURST:IDLE?"",
            set_cmd=f"":SOUR{channel}:BURST:IDLE {{}}"",
            vals=vals.MultiType(
                vals.Enum(""FPT"", ""TOP"", ""BOTTOM"", ""CENTER""), vals.Numbers()  # DIY
            ),
        )

    def trigger(self) -> None:
        """"""
        Send a software trigger to the instrument. This only works if the
        trigger source is set to manual.
        """"""
        self.parent.write_raw(f"":SOUR{self.channel}:BURS:TRIG"")


class RigolDG1062Channel(InstrumentChannel):

    min_impedance = 1
    max_impedance = 10000

    waveform_params = {
        waveform: [""freq"", ""ampl"", ""offset"", ""phase""]
        for waveform in [""HARM"", ""NOIS"", ""RAMP"", ""SIN"", ""SQU"", ""TRI"", ""USER"", ""PULS""]
    }

    waveform_params[""DC""] = [""freq"", ""ampl"", ""offset""]
    waveform_params[""ARB""] = [""sample_rate"", ""ampl"", ""offset""]

    """"""
    Responses from the machine don't always match
    the name to set the function, hence a translater
    """"""
    waveform_translate = {
        ""HARM"": ""HARM"",
        ""NOISE"": ""NOIS"",
        ""RAMP"": ""RAMP"",
        ""SIN"": ""SIN"",
        ""SQU"": ""SQU"",
        ""TRI"": ""TRI"",
        ""USER"": ""USER"",
        ""PULSE"": ""PULS"",
    }

    waveforms = list(waveform_params.keys())

    def __init__(self, parent: ""RigolDG1062"", name: str, channel: int):
        """"""
        Args:
            parent: The instrument this channel belongs to
            name (str)
            channel (int)
        """"""

        super().__init__(parent, name)
        self.channel = channel

        for param, unit in [
            (""freq"", ""Hz""),
            (""ampl"", ""V""),
            (""offset"", ""V""),
            (""phase"", ""deg""),
            (""sample_rate"", ""1/s""),
        ]:
            self.add_parameter(
                param,
                unit=unit,
                get_cmd=partial(self._get_waveform_param, param),
                set_cmd=partial(self._set_waveform_param, param),
            )

        self.add_parameter(
            ""waveform"", get_cmd=partial(self._get_waveform_param, ""waveform"")
        )

        self.add_parameter(
            ""impedance"",
            get_cmd=f"":OUTPUT{channel}:IMP?"",
            set_cmd=f"":OUTPUT{channel}:IMP {{}}"",
            unit=""Ohm"",
            vals=vals.MultiType(
                vals.Ints(
                    min_value=RigolDG1062Channel.min_impedance,
                    max_value=RigolDG1062Channel.max_impedance,
                ),
                vals.Enum(""INF"", ""MIN"", ""MAX"", ""HighZ""),
            ),
            get_parser=(
                lambda value: ""HighZ""
                if float(value) > RigolDG1062Channel.max_impedance
                else float(value)
            ),
            set_parser=lambda value: ""INF"" if value == ""HighZ"" else value,
        )

        self.add_parameter(
            ""sync"",
            get_cmd=f"":OUTPUT{channel}:SYNC?"",
            set_cmd=f""OUTPUT{channel}:SYNC {{}}"",
            vals=vals.Enum(0, 1, ""ON"", ""OFF""),
        )

        self.add_parameter(
            ""polarity"",
            get_cmd=f"":OUTPUT{channel}:GAT:POL?"",
            set_cmd=f"":OUTPUT{channel}:GAT:POL {{}}"",
            vals=vals.OnOff(),
            val_mapping={1: ""POSITIVE"", 0: ""NEGATIVE""},
        )

        self.add_parameter(
            ""state"",
            get_cmd=f""OUTPUT{channel}:STATE?"",
            set_cmd=f""OUTPUT{channel}:STATE {{}}"",
        )

        self.add_parameter(
            ""duty_cycle"",
            get_cmd=self._get_duty_cycle,
            set_cmd=self._set_duty_cycle,
            unit=""%"",
            vals=vals.Numbers(min_value=1, max_value=99),
            docstring=(
                ""This functions reads/sets the duty ""
                ""cycle for a square and pulse wave ""
                ""since these inherit a duty cycle.\n""
                ""For other waveforms it will give ""
                ""the user an error""
            ),
        )

        burst = RigolDG1062Burst(cast(RigolDG1062, self.parent), ""burst"", self.channel)
        self.add_submodule(""burst"", burst)

        # We want to be able to do the following:
        # >>> help(gd.channels[0].sin)
        # >>> gd.channels[0].sin(freq=2E3, ampl=1.0, offset=0, phase=0)
        # We do not use add_function as it is more cumbersome to use.
        for waveform in self.waveforms:
            f = partial_with_docstring(
                self.apply,
                docstring=""Args: "" + "", "".join(self.waveform_params[waveform]),
                waveform=waveform,
            )
            setattr(self, waveform.lower(), f)

        # Retrieve current waveform from device
        self.waveform()

    def apply(self, **kwargs: Any) -> None:
        """"""
        Public interface to apply a waveform on the channel
        Example:
        >>> gd = RigolDG1062(""gd"", ""TCPIP0::169.254.187.99::inst0::INSTR"")
        >>> gd.channels[0].apply(waveform=""SIN"", freq=1E3, ampl=1.0, offset=0, phase=0)
        Valid waveforms are: HARM, NOIS, RAMP, SIN, SQU, TRI, USER, DC, ARB
        To find the correct arguments of each waveform we can e.g. do:
        >>> help(gd.channels[0].sin)
        Notice the lower case when accessing the waveform through convenience
        functions.
        If not kwargs are given a dictionary with the current waveform
        parameters are returned.
        """"""
        self._set_waveform_params(**kwargs)

    def current_waveform(self) -> dict[Any, Any]:
        """"""Public interface to get the current waveform""""""
        return self._get_waveform_params()

    def _get_waveform_param(self, param: str) -> float:
        """"""
        Get a parameter of the current waveform. Valid param names are
        dependent on the waveform type (e.g. ""DC"" does not have a ""phase"")
        """"""
        params_dict = self._get_waveform_params()
        return params_dict.get(param, None)

    def _get_waveform_params(self) -> dict[Any, Any]:
        """"""
        Get all the parameters of the current waveform and
        """"""

        def to_float(string: str) -> Union[float, str]:
            try:
                return float(string)
            except ValueError:
                return string

        waveform_str = self.parent.ask_raw(f"":SOUR{self.channel}:APPL?"")
        parts = waveform_str.strip('""').split("","")

        current_waveform = self.waveform_translate[parts[0]]
        param_vals: list[Union[str, float]] = [current_waveform]
        param_vals += [to_float(i) for i in parts[1:]]
        param_names = [""waveform""] + self.waveform_params[current_waveform]
        params_dict = dict(zip(param_names, param_vals))

        return params_dict

    def _set_waveform_param(self, param: str, value: float) -> None:
        """"""
        Set a particular waveform param to the given value.
        """"""
        params_dict = self._get_waveform_params()

        if param in params_dict:
            params_dict[param] = value
        else:
            log.warning(
                f""Warning, unable to set '{param}' for the current "" f""waveform""
            )
            return

        return self._set_waveform_params(**params_dict)

    def _set_waveform_params(self, **params_dict: Union[int, float]) -> None:
        """"""
        Apply a waveform with values given in a dictionary.
        """"""
        if ""waveform"" not in params_dict:
            raise ValueError(""At least 'waveform' argument needed"")

        waveform = str(params_dict[""waveform""])
        if waveform not in self.waveform_params:
            raise ValueError(
                f""Unknown waveform '{waveform}'. Options are ""
                f""{self.waveform_params.keys()}""
            )

        param_names = self.waveform_params[waveform]

        if not set(param_names).issubset(params_dict.keys()):
            raise ValueError(
                f""Waveform {waveform} needs at least parameters "" f""{param_names}""
            )

        string = f"":SOUR{self.channel}:APPL:{waveform} ""
        values = [f""{params_dict[param]:7e}"" for param in param_names]
        string += "","".join(values)
        self.parent.write_raw(string)

    def _get_duty_cycle(self) -> float:
        """"""
        Reads the duty cycle after checking waveform
        """"""
        wf = self.waveform()

        if wf in [""PULS"", ""SQU""]:
            duty_cycle = self.parent.ask_raw(f"":SOUR{self.channel}:FUNC:{wf}:DCYC?"")
        else:
            raise ValueError(
                f""Current function does not contain duty cycle. Current function: {wf}""
            )

        return duty_cycle

    def _set_duty_cycle(self, duty_cycle: float) -> None:
        """"""
        Sets the duty cycle after checking waveform
        """"""
        wf = self.waveform()

        if wf in [""PULS"", ""SQU""]:
            self.parent.write_raw(f"":SOUR{self.channel}:FUNC:{wf}:DCYC {duty_cycle}"")
        else:
            raise ValueError(
                f""Current function does not have duty cycle""
                f"" hence can not set. Current function: {wf}""
            )


class RigolDG1062(VisaInstrument):
    """"""
    Instrument driver for the Rigol DG1062
    """"""

    waveforms = RigolDG1062Channel.waveforms

    def __init__(self, name: str, address: str, **kwargs: Any):

        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""channel"", RigolDG1062Channel, snapshotable=False)

        for ch_num in [1, 2]:
            ch_name = f""ch{ch_num}""
            channel = RigolDG1062Channel(self, ch_name, ch_num)
            channels.append(channel)
            self.add_submodule(ch_name, channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()
"
328,https://www.thinksrs.com/downloads/pdfs/catalog/SR860c.pdf,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,"[OrderedDict([('id', 'attWlGoBv9Sises3P'), ('width', 4428), ('height', 2540), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rjdeGzP-mdoBbxj4qLBotA/8gDS2Nr5WKarFCwwlxfCc-yKCYOgz_3ORHuUxVjhSUmRKiw90ZuB2LQ9U1Jdg03BK5QEHVBvg0d8XY98QZZUh_omKyzZDjykK6QJPUMfr7o/zXCOrSrTxSBFEl8oXJ11NhoWTYVnDo_m6YqpvSrzHx8'), ('filename', 'SR860_Lt_Wide (1).jpg'), ('size', 2290334), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/3_H9wQ0ypCYHL_J_289Czg/Szknp_nluJtX5_SIanmAQYi5iGnqrXm3B57aruKyYAawJWPim0lB9Ylj1_GzAeEZ7LFw8894-5hTADTyRklbmQ/bDdAfj3TSHD9eihdEsKMzzjQYFoYsiyoB7-QNwZ4xB8'), ('width', 63), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/PLGYscAlVgfGvGsMxZIMfA/JF2t01eDzTxb0YqCERyzaWuHEDnNJiskEYosbJOnUYFgyXiv51ce33h3w9C40Rpdi83hx3FwVyvT8bqC0ggVPg/0aA9XRSCsr0zTWj8p0RMxg3l2bPZL6cUx2qMoUagipc'), ('width', 893), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/sYi8Uwo0VNyvbEYo0swR6w/DgAcUveQSNlT1CW5HjCZCMa1BCWR45P_0OkBSFhw2mN3aKhcdx7_v4TeZ2i5LX6hkxWuZX3Ba6-5n5RMp5R7mQ/95wlHfZajRUW8Q2mEOXj18_22nmSDIOuMyZAVydCCAg'), ('width', 3000), ('height', 3000)]))]))])]",25.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116726/Instruments/Vendor%20Logos/Stanford_Research.png,"The new SR860 Lock-in Amplifier is the latest in a line of innovative lock-ins from SRS. With unparalleled analog performance, sophisticated new digital signal processing features, a thoroughly modern, intuitive user interface, and a wide range of computer connectivity options, the SR860 is the ideal choice for any synchronous detection application.",https://www.thinksrs.com/products/sr860.html,SR 860,532.0,['Lockin Amplifiers'],"An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.","Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR860.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR860,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HT3DpJ0dPzh3So5LglKD3Q/NXBHnuVNKRR94xYlwGDEERhnN7kFmAzX5IVmgMwlPWSQyeTI5znNIgthc78M_Pjce-ip0edCto9Lxyn4vrE-YBW4huCvumgqDh5SsZxiUdRxQo5QZj2r1r_L8DQUgweq/RgFfMs0JYwLCvNcRSSynUmaBMkpX7RbQdZEkYMVCsQc'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/zKEUuKYWTul5CkZfz6TuAA/a6I5hIbOMHhPuCWAPe0b5CW4PQyMkJZGxwD2FYD0kGc_2u2icCWYfDOkOQmu_bW7tZcXF565sDptob8GGYyuCnVOTIAT9bHQ4eIDCMJNNwo/Vrcm5vEyYDmHBBcJiDtQMa6ccY4rHc6vn_SBF9IwomM'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/z9rv2rQ5yOdB514oRy7Y3w/ym9wnAsto8J5MbIr47zkb78oB2JM2UHTgFTSzbZzMkfVIB4BUCQwR8dPc1cfE_i-4Jt_NSuI82_vU9Dng-Icjn1JZoB0femn98jIUzThUHU/1dLxTooPs-ZfEZFP4Ej8aDYkRugAA9UzBdQBOBUYxxw'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/FJB4gJG5EkFJpYbG2EDd4w/b3e0yrTJRXICD6pAUL4k5G-V0nl6aGNqR4uc6BrcYWNQnVIPg4uSU7lirBzhiWoJIJya_P1jT7QH4-ltwIUiF6R4P9oOKAm4y9x74YGfVjc/8vqqIjujDUOuL6DtiU92Z4CSRn0Jt-xHp3pyEso9emA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782674/Instruments/Lockin%20Amplifiers/SR-860/SR-860.jpg,SR 860,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,6495.0,,True,,"from qcodes.instrument_drivers.stanford_research.SR86x import SR86x


class SR860(SR86x):
    """"""
    QCoDeS driver for the Stanford Research Systems SR860 Lock-in Amplifier.

    The SR860 instrument is almost equal to the SR865, except for the max frequency
    """"""

    def __init__(
        self, name: str, address: str, reset: bool = False, **kwargs: str
    ) -> None:
        super().__init__(name, address, max_frequency=500e3, reset=reset, **kwargs)
"
329,,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'atti8JmrGIhdR7Wie'), ('width', 1110), ('height', 532), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ee-Dpk3T5yjB6gNZZzVZ_w/nkL_ilPKP7oSF6KCX58_vKqCtB_8HInBf7eY1BQmp9oNKvc9hdbGhhooYLZH4xhnXKrV47Nxf9-IGtRUMsgMg2l2SA8xejT9aIbFcAczX6w/UIrkbRxHLYS89MESRDFYsoFetRsSHhAcoE4r7EQaNyc'), ('filename', 'Rigol_4000.jpeg'), ('size', 152681), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/eC2Ki0iXz8nmaeUaXrpQUg/Z4s4QGbGZbTvD-zSELHSzgMcIbxipGEypdLnkvu4IvYpbTF3_K8R1sYRqqEQq59PTrUSPMQQan2LrY530wsOTA/wvd6Sfdb1YPZfoaYgW9u9pUtrT-LCcApLZ5vc5UkNrA'), ('width', 75), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/SVaI6Rd82CQJIKyGfgGesQ/anbZ4dJIUklketz1HK0XIsMUMUv0o2fgiOOjlJkulcPIZKJq7XPmsxj6IapmcVSWxISzuVOHYHqiP1WQcsK8hw/DGMVO9b-keUUgAOfdxTXV0CPScYVswVY63Ri5esw7wY'), ('width', 1068), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aJqhaAyze1aR1LbM6PP4JA/kcfW6EdnorVrFHbRAGgq88nrHt0rHFxv41zztCRL-l37kq-U3DKZp_QLDgZPhLx1hPfvSJ964dd57hzTdE0QGw/OHBfDMrZ7nu7uUunf3QivmUteu6W2N5xYhUdt5O9O0I'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"The Rigol DS4000 series consists of 8 high level Oscilloscopes for professional operation, which come off very well compared to higher prices models of other brands.",https://www.batronix.com/shop/rigol/DS4000.html,Rigol DS 4000,457.0,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DS4000.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDG4000,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782714/Instruments/Oscilloscopes/Rigol-DS4000-Series/Rigol-DS4000-Series.jpg,Rigol DS4000-Series,Write a Python script that uses Qcodes to connect to a Rigol DS4000-Series Oscilloscopes,,,,,"from __future__ import annotations

import logging
import re
import time
import warnings
from collections import namedtuple
from typing import Any

import numpy as np
from packaging import version

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, ParamRawDataType

log = logging.getLogger(__name__)


class RigolDS4000TraceNotReady(Exception):
    pass


class ScopeArray(ArrayParameter):
    def __init__(
        self,
        name: str,
        instrument: RigolDS4000Channel,
        channel: int,
        raw: bool = False,
    ):
        super().__init__(
            name=name,
            shape=(1400,),
            label=""Voltage"",
            unit=""V"",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""holds an array from scope"",
            instrument=instrument,
        )
        self.channel = channel
        self.raw = raw
        self.max_read_step = 50
        self.trace_ready = False

    def prepare_curvedata(self) -> None:
        """"""
        Prepare the scope for returning curve data
        """"""
        assert isinstance(self.instrument, RigolDS4000Channel)
        if self.raw:
            self.instrument.write("":STOP"")  # Stop acquisition
            self.instrument.write("":WAVeform:MODE RAW"")  # Set RAW mode
        else:
            self.instrument.write("":WAVeform:MODE NORM"")  # Set normal mode

        self.get_preamble()
        p = self.preamble

        # Generate time axis data
        xdata = np.linspace(p.xorigin, p.xorigin + p.xincrement * p.points, p.points)
        self.setpoints = (tuple(xdata),)
        self.shape = (p.points,)

        self.trace_ready = True

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, RigolDS4000Channel)
        assert isinstance(self.root_instrument, RigolDS4000)
        if not self.trace_ready:
            raise RigolDS4000TraceNotReady(
                ""Please run prepare_curvedata to prepare ""
                ""the scope for giving a trace.""
            )
        else:
            self.trace_ready = False

        # Set the data type for waveforms to ""BYTE""
        self.instrument.write("":WAVeform:FORMat BYTE"")
        # Set read channel
        self.instrument.write(f"":WAVeform:SOURce CHAN{self.channel}"")

        data_bin = bytearray()
        if self.raw:
            log.info(""Readout of raw waveform started, %g points"", self.shape[0])
            # Ask for the right number of points
            self.instrument.write(f"":WAVeform:POINts {self.shape[0]}"")
            # Resets the waveform data reading
            self.instrument.write("":WAVeform:RESet"")
            # Starts the waveform data reading
            self.instrument.write("":WAVeform:BEGin"")

            for i in range(self.max_read_step):
                status = self.instrument.ask("":WAVeform:STATus?"").split("","")[0]

                # Ask and retrieve waveform data
                # It uses .read_raw() to get a byte
                # string since our data is binary
                self.instrument.write("":WAVeform:DATA?"")
                data_chunk = self.root_instrument.visa_handle.read_raw()
                data_chuck = self._validate_strip_block(data_chunk)
                data_bin.extend(data_chuck)

                if status == ""IDLE"":
                    self.instrument.write("":WAVeform:END"")
                    break
                else:
                    # Wait some time to have the buffer re-filled
                    time.sleep(0.3)
                log.info(
                    ""chucks read: %d, last chuck points: "" ""%g, total read size: %g"",
                    i,
                    len(data_chuck),
                    len(data_bin),
                )
            else:
                raise ValueError(""Communication error"")
        else:
            # Ask and retrieve waveform data
            # It uses .read_raw() to get a byte string since our data is binary
            log.info(""Readout of display waveform started, %d points"", self.shape[0])
            self.instrument.write("":WAVeform:DATA?"")  # Query data
            data_chunk = self.root_instrument.visa_handle.read_raw()
            data_bin.extend(self._validate_strip_block(data_chunk))

        log.info(""Readout ended, total read size: %g"", len(data_bin))

        log.info(""Data conversion"")
        # Convert data to byte array
        data_raw = np.frombuffer(data_bin, dtype=np.uint8).astype(float)

        # Convert byte array to real data
        p = self.preamble
        data = (data_raw - p.yreference - p.yorigin) * p.yincrement
        log.info(""Data conversion done"")

        return data

    @staticmethod
    def _validate_strip_block(block: bytes) -> bytes:
        """"""
        Given a block of raw data from the instrument, validate and
        then strip the header with
        size information. Raise ValueError if the sizes don't match.

        Args:
            block: The data block
        Returns:
            The stripped data
        """"""
        # Validate header
        header = block[:11].decode(""ascii"")
        match = re.match(r""#9(\d{9})"", header)
        if match:
            size = int(match[1])
            block_nh = block[11:]  # Strip header
            block_nh = block_nh.strip()  # Strip \n

            if size == len(block_nh):
                return block_nh

        raise ValueError(""Malformed data"")

    def get_preamble(self) -> None:
        assert isinstance(self.instrument, RigolDS4000Channel)
        preamble_nt = namedtuple(
            ""preamble_nt"",
            [
                ""format"",
                ""mode"",
                ""points"",
                ""count"",
                ""xincrement"",
                ""xorigin"",
                ""xreference"",
                ""yincrement"",
                ""yorigin"",
                ""yreference"",
            ],
        )

        def conv(x: str) -> float:
            return int(x) if x.isdigit() else float(x)

        preamble_raw = self.instrument.ask("":WAVeform:PREamble?"")
        preamble_num = [conv(x) for x in preamble_raw.strip().split("","")]
        self.preamble = preamble_nt(*preamble_num)


class RigolDS4000Channel(InstrumentChannel):
    def __init__(self, parent: RigolDS4000, name: str, channel: int):
        super().__init__(parent, name)

        self.add_parameter(
            ""amplitude"", get_cmd=f"":MEASure:VAMP? chan{channel}"", get_parser=float
        )
        self.add_parameter(
            ""vertical_scale"",
            get_cmd=f"":CHANnel{channel}:SCALe?"",
            set_cmd="":CHANnel{}:SCALe {}"".format(channel, ""{}""),
            get_parser=float,
        )

        # Return the waveform displayed on the screen
        self.add_parameter(
            ""curvedata"", channel=channel, parameter_class=ScopeArray, raw=False
        )

        # Return the waveform in the internal memory
        self.add_parameter(
            ""curvedata_raw"", channel=channel, parameter_class=ScopeArray, raw=True
        )


class RigolDS4000(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Rigol DS4000 series oscilloscopes.
    """"""

    def __init__(self, name: str, address: str, timeout: float = 20, **kwargs: Any):
        """"""
        Initialises the DS4000.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: visa timeout, in secs. long default (180)
                to accommodate large waveforms
        """"""

        # Init VisaInstrument. device_clear MUST NOT be issued, otherwise communications hangs
        # due a bug in firmware
        super().__init__(name, address, device_clear=False, timeout=timeout, **kwargs)
        self.connect_message()

        self._check_firmware_version()

        # functions
        self.add_function(""run"", call_cmd="":RUN"", docstring=""Start acquisition"")
        self.add_function(""stop"", call_cmd="":STOP"", docstring=""Stop acquisition"")
        self.add_function(
            ""single"", call_cmd="":SINGle"", docstring=""Single trace acquisition""
        )
        self.add_function(
            ""force_trigger"", call_cmd=""TFORce"", docstring=""Force trigger event""
        )
        self.add_function(
            ""auto_scale"", call_cmd="":AUToscale"", docstring=""Perform autoscale""
        )

        # general parameters
        self.add_parameter(
            ""trigger_type"",
            label=""Type of the trigger"",
            get_cmd="":TRIGger:MODE?"",
            set_cmd="":TRIGger:MODE {}"",
            vals=vals.Enum(
                ""EDGE"",
                ""PULS"",
                ""RUNT"",
                ""NEDG"",
                ""SLOP"",
                ""VID"",
                ""PATT"",
                ""RS232"",
                ""IIC"",
                ""SPI"",
                ""CAN"",
                ""FLEX"",
                ""USB"",
            ),
        )
        self.add_parameter(
            ""trigger_mode"",
            label=""Mode of the trigger"",
            get_cmd="":TRIGger:SWEep?"",
            set_cmd="":TRIGger:SWEep {}"",
            vals=vals.Enum(""AUTO"", ""NORM"", ""SING""),
        )
        self.add_parameter(
            ""time_base"",
            label=""Horizontal time base"",
            get_cmd="":TIMebase:MAIN:SCALe?"",
            set_cmd="":TIMebase:MAIN:SCALe {}"",
            get_parser=float,
            unit=""s/div"",
        )
        self.add_parameter(
            ""sample_point_count"",
            label=""Number of the waveform points"",
            get_cmd="":WAVeform:POINts?"",
            set_cmd="":WAVeform:POINts {}"",
            get_parser=int,
            vals=vals.Ints(min_value=1),
        )
        self.add_parameter(
            ""enable_auto_scale"",
            label=""Enable or disable autoscale"",
            get_cmd="":SYSTem:AUToscale?"",
            set_cmd="":SYSTem:AUToscale {}"",
            get_parser=bool,
            vals=vals.Bool(),
        )

        channels = ChannelList(self, ""Channels"", RigolDS4000Channel, snapshotable=False)

        for channel_number in range(1, 5):
            channel = RigolDS4000Channel(self, f""ch{channel_number}"", channel_number)
            channels.append(channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())

    def _check_firmware_version(self) -> None:
        # Require version 00.02.03

        idn = self.get_idn()
        verstr = idn[""firmware""]
        if verstr is None:
            raise RuntimeError(""Could not determine firmware version of DS4000."")
        ver = version.parse(verstr)
        if ver < version.parse(""00.02.03""):
            warnings.warn(
                ""Firmware version should be at least 00.02.03,""
                ""data transfer may not work correctly""
            )
"
331,hhttps://www.axiomtest.com/documents/models/RS%20SGS100A%20Datasheet.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attOOcfzLHctI1oDv'), ('width', 2880), ('height', 1620), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Vl_R2ldnRt_MinWoY3PC0A/VzalwPHqO5NWq5MBUuvQSGfaTLjnTRxHCLizXajI78ZSsaZ_l9GKWbJlQ-D0gpswpWm_KB97TmwRI14LESeTOUAufreBKJxpmu6n-JrcLxCzGr9ppia2jJm-INJkqlkH1yk0O2sIIahDSyFBryesfJQzpKh8wf5h0carUu4SALs/xSAdv5pCFHQEh11u8z_JY3763pEjf7FxnoJdNG_1uls'), ('filename', 'sgs100a-sgma-rf-source-front-view-rohde-schwarz_200_1102_2880_1620_2.jpg'), ('size', 208002), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nXUIAdcVxkPaRrpkXfaIXA/5Fpqk3xeDNWveSiR8LS2DPWlkLb_2xXmueZMK34vnUVDhPryDWr1pcpWSCa0t_rw1Y5_qrfIucBlq_2SNuoldg/qXHHZbYr9pOyGfqyoCtrjan-jiFn3cuTs9-2jKTzQbQ'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/HI0uqpbmo0ef2PCcVDckKA/ImIHQKpLc7leIRpBzMtGEnE5tHimbApCj4CPnmn-r00Zesc2487SRi-Et66l9inRplz1kEW7yLNHHUXYpz_NaA/o_GPNIvc3_gOzdHgGNDtomth7aK_AB2Hl9eJREr-HbM'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/mVZOssqhhs0zBerXDQGxzw/_qUISRUTmkgJUcXzwO0HxGO-MAv7OvMDGcW9Ef_8SVFrFbDSsGqZVmsnfKijLVI3Oq-C4pMBJknwViiK_fTVrw/nlxUnP3QXsBuehizZYtLeR9lg-EtJXO8nLy1HgL38ys'), ('width', 3000), ('height', 3000)]))]))])]",2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116717/Instruments/Vendor%20Logos/RohdeSchwarz.png,"The R&S®SGS100A is an RF source designed to meet the requirements of automated test systems. It is available as a CW source or as a vector signal generator with an integrated I/Q modulator. With its frequency range of up to 12.75 GHz, the vector signal generation version covers the essential digital signals. The CW version can be used as a flexible local oscillator and for interference testing against mobile radio standards.

",https://www.rohde-schwarz.com/us/products/test-and-measurement/analog-signal-generators/rs-sgs100a-sgma-rf-source_63493-9030.html,SGS 100 A,461.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/SGS100A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzSGS100A,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XHBiQ9oxXm-n-HvM6LnRsA/zCF7wkTRkwfOTCAuwmibY3O7w00r82Jr-e9BArEz2wuEOw-7rLpTsqnPaLuh9W23W58Qwn9JURC-40I0_-4JxPkfgmT1CSF7VPctZxztnV4/I5ofu9MkvIeeFWHtoXZm_t6fUCujFLfj-JFESMUqIgk'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rp7cS3TGPqAHuTUKlrNiDg/VQ8_PlSktrAEUSma3ec9casPyXqUCiOYTta1bFMCr-JbFojx11fj4PsFxxQcQkgk5T0s4eilsQBFkmKe1f5C4A/plUaF2hmxk-9dn7wzOx_UZSUTlLGORdKrjwdpcJGgiM'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ouYl2k3tZan1Mqr3gFZ4XQ/eznvJmkOWcALsfmYE2FWZIIuDkvhPsL5ha4wYwX2hkGiFmGNwyYpsS2lgvAprhPlVCGH-c59BKm4kM4jMvjwlA/h8aBHQcCEhxqGNo05zJPlPwJ7fdGYthLjdrl6yX_uaY'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6WMk-uFRvLMFJ3F3nCseOQ/Ssto5hgGHjq8Q9vjrgnj3D0-Fay9y9tubFUbdbvK9IeGUYn2K3euoW1jshe65viP4uybZmkDEuVY84MH5n021w/_2LXQNPKEtc9MtuRG0jFWn1Hay_SQ8m2sSYN4caNxpw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782716/Instruments/RF%20Signal%20Generator/RS-SGS100A/RS-SGS100A.jpg,R&S SGS100A,Write a Python script that uses Qcodes to connect to a R&S SGS100A RF Signal Generator,,,,,"from typing import Any

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class RohdeSchwarzSGS100A(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Rohde & Schwarz SGS100A signal generator.

    Status: beta-version.

    .. todo::

        - Add all parameters that are in the manual
        - Add test suite
        - See if there can be a common driver for RS mw sources from which
          different models inherit

    This driver will most likely work for multiple Rohde & Schwarz sources.
    it would be a good idea to group all similar RS drivers together in one
    module.

    Tested working with

    - RS_SGS100A

    This driver does not contain all commands available for the RS_SGS100A but
    only the ones most commonly used.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)

        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='SOUR:FREQ?',
                           set_cmd='SOUR:FREQ {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(1e6, 20e9))
        self.add_parameter(name='phase',
                           label='Phase',
                           unit='deg',
                           get_cmd='SOUR:PHAS?',
                           set_cmd='SOUR:PHAS {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(0, 360))
        self.add_parameter(name='power',
                           label='Power',
                           unit='dBm',
                           get_cmd='SOUR:POW?',
                           set_cmd='SOUR:POW {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-120, 25))
        self.add_parameter('status',
                           label='RF Output',
                           get_cmd=':OUTP:STAT?',
                           set_cmd=':OUTP:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('IQ_state',
                           label='IQ Modulation',
                           get_cmd=':IQ:STAT?',
                           set_cmd=':IQ:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('pulsemod_state',
                           label='Pulse Modulation',
                           get_cmd=':SOUR:PULM:STAT?',
                           set_cmd=':SOUR:PULM:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('pulsemod_source',
                           label='Pulse Modulation Source',
                           get_cmd='SOUR:PULM:SOUR?',
                           set_cmd='SOUR:PULM:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        self.add_parameter('ref_osc_source',
                           label='Reference Oscillator Source',
                           get_cmd='SOUR:ROSC:SOUR?',
                           set_cmd='SOUR:ROSC:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        # Define LO source INT/EXT (Only with K-90 option)
        self.add_parameter('LO_source',
                           label='Local Oscillator Source',
                           get_cmd='SOUR:LOSC:SOUR?',
                           set_cmd='SOUR:LOSC:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        # Define output at REF/LO Output (Only with K-90 option)
        self.add_parameter('ref_LO_out',
                           label='REF/LO Output',
                           get_cmd='CONN:REFL:OUTP?',
                           set_cmd='CONN:REFL:OUTP {}',
                           vals=vals.Enum('REF', 'LO', 'OFF', 'ref', 'lo',
                                          'off', 'Off'))
        # Frequency mw_source outputs when used as a reference
        self.add_parameter('ref_osc_output_freq',
                           label='Reference Oscillator Output Frequency',
                           get_cmd='SOUR:ROSC:OUTP:FREQ?',
                           set_cmd='SOUR:ROSC:OUTP:FREQ {}',
                           vals=vals.Enum('10MHz', '100MHz', '1000MHz'))
        # Frequency of the external reference mw_source uses
        self.add_parameter('ref_osc_external_freq',
                           label='Reference Oscillator External Frequency',
                           get_cmd='SOUR:ROSC:EXT:FREQ?',
                           set_cmd='SOUR:ROSC:EXT:FREQ {}',
                           vals=vals.Enum('10MHz', '100MHz', '1000MHz'))

        # IQ impairments
        self.add_parameter('IQ_impairments',
                           label='IQ Impairments',
                           get_cmd=':SOUR:IQ:IMP:STAT?',
                           set_cmd=':SOUR:IQ:IMP:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('I_offset',
                           label='I Offset',
                           get_cmd='SOUR:IQ:IMP:LEAK:I?',
                           set_cmd='SOUR:IQ:IMP:LEAK:I {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-10, 10))
        self.add_parameter('Q_offset',
                           label='Q Offset',
                           get_cmd='SOUR:IQ:IMP:LEAK:Q?',
                           set_cmd='SOUR:IQ:IMP:LEAK:Q {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-10, 10))
        self.add_parameter('IQ_gain_imbalance',
                           label='IQ Gain Imbalance',
                           get_cmd='SOUR:IQ:IMP:IQR?',
                           set_cmd='SOUR:IQ:IMP:IQR {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-1, 1))
        self.add_parameter('IQ_angle',
                           label='IQ Angle Offset',
                           get_cmd='SOUR:IQ:IMP:QUAD?',
                           set_cmd='SOUR:IQ:IMP:QUAD {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-8, 8))

        self.add_function('reset', call_cmd='*RST')
        self.add_function('run_self_tests', call_cmd='*TST?')

        self.connect_message()

    def on(self) -> None:
        self.status('on')

    def off(self) -> None:
        self.status('off')


class RohdeSchwarz_SGS100A(RohdeSchwarzSGS100A):
    pass
"
338,https://www.keysight.com/us/en/assets/7018-01289/data-sheets/5989-2785.pdf,https://www.atecorp.com/category/semiconductor-parameter-analyzers,"[OrderedDict([('id', 'attXqVnDukWaMVFsj'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/GDK9i4jdi82RjLgKL0v8TA/zQ2Mv381-78HDe-Y3Dv6-vSowRScnTYaZwbl1artnvP7Pe0-6jSHBv_c2_UpjYzYYMedAZtKaoMlTmIryqDr8oVj2GuVGBRfKZSIhiTY4AnZWnskZxhqbHoAdvSFBKHb/bIfCtCChoW13P4hI9jAqaKWwp86ZJykB1Hh4XX9F3H0'), ('filename', 'B1500_FL_TRANS_SHAD_2016April13.png'), ('size', 1136027), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/dTgtMd0wpyyyf7ergVNckw/GDacTOQWgzO9k38gTC8Qsfe6I_SASDCItAkChU3mBuGU1kjtU-j_Q_vMIPYXq-RELrKIhUGJyuaj09cbTMiUqg/b2Bzl5JzWzz-hiTtcsgg4e_i_Nfrm8elaKLH4O2rIA0'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPuJMES5Oyt5wcxChTg1aw/dSuMmzy2mUzh_qNceuR-A5YH5sKMOJUB_XtS2tPdJYvu40PQWMG3Yassob5dnGgrvzlnx3ZAwFLUYJN8dAjKMg/XkKmU7LxmyqZPCV7xih7JlOActakVXhAb54bVB3DhUs'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Tzv7Y6gKnr1mvKFHMGE82w/g4UIdEY0WcgCVujIdlhLukAF_8PgSIrXhmcGJsDqZoB8etHy4-6sQKGUjW5hmyC8P5h0DLs0hwA2L3-ffzk2pA/I2Z_FWJcM7H2Cm5kSStTIlMW0PYXPjQCrC4dfVoTN2Y'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight B1500A semiconductor parameter analyzer is an all-in-one device characterization analyzer supporting IV, CV, pulse/dynamic IV and more.","https://www.keysight.com/us/en/product/B1500A/semiconductor-device-parameter-analyzer-system-mainframe.html#:~:text=The%20Keysight%20B1500A%20semiconductor%20parameter,%2C%20and%20active%20%2F%20passive%20components.",Keysightb 1500,327.0,['Spectrum Analyzers'],"The semiconductor parameter analyzer is an all-in-one unit, that consists of a power supplies, voltage meters, current meters, switching matrices and LCR meters to test semiconductors","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysightb1500/KeysightB1500_base.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightB1500,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782723/Instruments/Spectrum%20Analyzers/Keysight-B1500A/Keysight-B1500A.png,Keysight B1500A,Write a Python script that uses Qcodes to connect to a Keysight B1500A Spectrum Analyzers,,,,,"import re
import textwrap
from typing import Optional, Union, Dict, List, Tuple, Any, Sequence
from collections import defaultdict

from qcodes import VisaInstrument, MultiParameter, Parameter
from qcodes.instrument_drivers.Keysight.keysightb1500.KeysightB1500_module \
    import _FMTResponse, fmt_response_base_parser, StatusMixin, \
    convert_dummy_val_to_nan
from qcodes.utils.helpers import create_on_off_val_mapping
from .KeysightB1530A import B1530A
from .KeysightB1520A import B1520A
from .KeysightB1517A import B1517A, _ParameterWithStatus
from .KeysightB1511B import B1511B
from .KeysightB1500_module import B1500Module, parse_module_query_response, \
    parse_spot_measurement_response
from . import constants
from .message_builder import MessageBuilder


class KeysightB1500(VisaInstrument):
    """"""Driver for Keysight B1500 Semiconductor Parameter Analyzer.

    For the list of supported modules, refer to :meth:`from_model_name`.
    """"""
    calibration_time_out = 60  # 30 seconds suggested by manual

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator=""\r\n"", **kwargs)
        self.by_slot: Dict[constants.SlotNr, B1500Module] = {}
        self.by_channel: Dict[constants.ChNr, B1500Module] = {}
        self.by_kind: Dict[constants.ModuleKind, List[B1500Module]] = defaultdict(list)

        self._find_modules()

        self.add_parameter('autozero_enabled',
                           unit='',
                           label='Autozero enabled of the high-resolution ADC',
                           set_cmd=self._set_autozero,
                           get_cmd=None,
                           val_mapping=create_on_off_val_mapping(
                               on_val=True, off_val=False),
                           initial_cache_value=False,
                           docstring=textwrap.dedent(""""""
            Enable or disable cancelling of the offset of the
            high-resolution A/D converter (ADC).

            Set the function to OFF in cases that the measurement speed is
            more important than the measurement accuracy. This roughly halves
            the integration time.""""""))

        self.add_parameter(name='run_iv_staircase_sweep',
                           parameter_class=IVSweepMeasurement,
                           docstring=textwrap.dedent(""""""
               This is MultiParameter. Running the sweep runs the measurement
               on the list of source values defined using
               `setup_staircase_sweep` method. The output is a
               primary parameter (e.g. Gate current)  and a secondary
               parameter (e.g. Source/Drain current) both of which use the same
               setpoints. Note you must `set_measurement_mode` and specify
               2 channels as the argument before running the sweep. First
               channel (SMU) must be the channel on which you set the sweep (
               WV) and second channel(SMU) must be the one which remains at
               constants voltage.
                              """"""))

        self.connect_message()

    def write(self, cmd: str) -> None:
        """"""
        Extend write method from the super to ask for error message each
        time a write command is called.
        """"""
        super().write(cmd)
        error_message = self.error_message()
        if error_message != '+0,""No Error.""':
            raise RuntimeError(f""While setting this parameter received ""
                               f""error: {error_message}"")

    def add_module(self, name: str, module: B1500Module) -> None:
        super().add_submodule(name, module)

        self.by_kind[module.MODULE_KIND].append(module)
        self.by_slot[module.slot_nr] = module
        for ch in module.channels:
            self.by_channel[ch] = module

    def reset(self) -> None:
        """"""Performs an instrument reset.

        This does not reset error queue!
        """"""
        self.write(""*RST"")

    def get_status(self) -> int:
        return int(self.ask(""*STB?""))

    # TODO: Data Output parser: At least for Format FMT1,0 and maybe for a
    # second (binary) format. 8 byte binary format would be nice because it
    # comes with time stamp
    # FMT1,0: ASCII (12 digits data with header) <CR/LF^EOI>

    def _find_modules(self) -> None:
        from .constants import UNT

        r = self.ask(MessageBuilder()
                     .unt_query(mode=UNT.Mode.MODULE_INFO_ONLY)
                     .message
                     )

        slot_population = parse_module_query_response(r)

        for slot_nr, model in slot_population.items():
            module = self.from_model_name(model, slot_nr, self)

            self.add_module(name=module.short_name, module=module)

    @staticmethod
    def from_model_name(model: str, slot_nr: int, parent: 'KeysightB1500',
                        name: Optional[str] = None) -> 'B1500Module':
        """"""Creates the correct instance of instrument module by model name.

        Args:
            model: Model name such as 'B1517A'
            slot_nr: Slot number of this module (not channel number)
            parent: Reference to B1500 mainframe instance
            name: Name of the instrument instance to create. If `None`
                (Default), then the name is autogenerated from the instrument
                class.

        Returns:
            A specific instance of :class:`.B1500Module`
        """"""
        if model == ""B1511B"":
            return B1511B(slot_nr=slot_nr, parent=parent, name=name)
        elif model == ""B1517A"":
            return B1517A(slot_nr=slot_nr, parent=parent, name=name)
        elif model == ""B1520A"":
            return B1520A(slot_nr=slot_nr, parent=parent, name=name)
        elif model == ""B1530A"":
            return B1530A(slot_nr=slot_nr, parent=parent, name=name)
        else:
            raise NotImplementedError(f""Module type {model} in slot""
                                      f"" {slot_nr} not yet supported."")

    def enable_channels(self, channels: Optional[constants.ChannelList] = None
                        ) -> None:
        """"""Enable specified channels.

        If channels is omitted or `None`, then all channels are enabled.
        """"""
        msg = MessageBuilder().cn(channels)

        self.write(msg.message)

    def disable_channels(
            self,
            channels: Optional[constants.ChannelList] = None
    ) -> None:
        """"""Disable specified channels.

        If channels is omitted or `None`, then all channels are disabled.
        """"""
        msg = MessageBuilder().cl(channels)

        self.write(msg.message)

    # Response parsing functions as static methods for user convenience
    parse_spot_measurement_response = parse_spot_measurement_response
    parse_module_query_response = parse_module_query_response

    def _setup_integration_time(self,
                                adc_type: constants.AIT.Type,
                                mode: Union[constants.AIT.Mode, int],
                                coeff: Optional[int] = None
                                ) -> None:
        """"""See :meth:`MessageBuilder.ait` for information""""""
        if coeff is not None:
            coeff = int(coeff)
        self.write(MessageBuilder()
                   .ait(adc_type=adc_type, mode=mode, coeff=coeff)
                   .message
                   )

    def _reset_measurement_statuses_of_smu_spot_measurement_parameters(
            self, parameter_name: str) -> None:
        if parameter_name not in ('voltage', 'current'):
            raise ValueError(f'Parameter name should be one of [voltage,current], '
                             f'got {parameter_name}.')
        for smu in self.by_kind[constants.ModuleKind.SMU]:
            param = smu.parameters[parameter_name]
            assert isinstance(param, _ParameterWithStatus)
            param._measurement_status = None

    def use_nplc_for_high_speed_adc(
            self, n: Optional[int] = None) -> None:
        """"""
        Set the high-speed ADC to NPLC mode, with optionally defining number
        of averaging samples via argument `n`.

        Args:
            n: Value that defines the number of averaging samples given by
                the following formula:

                ``Number of averaging samples = n / 128``.

                n=1 to 100. Default setting is 1 (if `None` is passed).

                The Keysight B1500 gets 128 samples in a power line cycle,
                repeats this for the times you specify, and performs
                averaging to get the measurement data. (For more info see
                Table 4-21.).  Note that the integration time will not be
                updated if a non-integer value is written to the B1500.
        """"""
        self._setup_integration_time(
            adc_type=constants.AIT.Type.HIGH_SPEED,
            mode=constants.AIT.Mode.NPLC,
            coeff=n
        )

    def use_nplc_for_high_resolution_adc(
            self, n: Optional[int] = None) -> None:
        """"""
        Set the high-resolution ADC to NPLC mode, with optionally defining
        the number of PLCs per sample via argument `n`.

        Args:
            n: Value that defines the integration time given by the
                following formula:

                ``Integration time = n / power line frequency``.

                n=1 to 100. Default setting is 1 (if `None` is passed).
                (For more info see Table 4-21.).  Note that the integration
                time will not be updated if a non-integer value is written
                to the B1500.
        """"""
        self._setup_integration_time(
            adc_type=constants.AIT.Type.HIGH_RESOLUTION,
            mode=constants.AIT.Mode.NPLC,
            coeff=n
        )

    def use_manual_mode_for_high_speed_adc(
            self, n: Optional[int] = None) -> None:
        """"""
        Set the high-speed ADC to manual mode, with optionally defining number
        of averaging samples via argument `n`.

        Use ``n=1`` to disable averaging (``n=None`` uses the default
        setting from the instrument which is also ``n=1``).

        Args:
            n: Number of averaging samples, between 1 and 1023. Default
                setting is 1. (For more info see Table 4-21.)
                Note that the integration time will not be updated
                if a non-integer value is written to the B1500.
        """"""
        self._setup_integration_time(
            adc_type=constants.AIT.Type.HIGH_SPEED,
            mode=constants.AIT.Mode.MANUAL,
            coeff=n
        )

    def _set_autozero(self, do_autozero: bool) -> None:
        self.write(MessageBuilder().az(do_autozero=do_autozero).message)

    def self_calibration(self,
                         slot: Optional[Union[constants.SlotNr, int]] = None
                         ) -> constants.CALResponse:
        """"""
        Performs the self calibration of the specified module (SMU) and
        returns the result. Failed modules are disabled, and can only be
        enabled by the ``RCV`` command.

        Calibration takes about 30 seconds (the visa timeout for it is
        controlled by :attr:`calibration_time_out` attribute).

        Execution Conditions: No SMU may be in the high voltage state
        (forcing more than ±42 V, or voltage compliance set to more than
        ±42 V). Before starting the calibration, open the measurement
        terminals.

        Args:
            slot: Slot number of the slot that installs the module to perform
                the self-calibration. For Ex:
                constants.SlotNr.ALL, MAINFRAME, SLOT01, SLOT02 ...SLOT10
                If not specified, the calibration is performed for all the
                modules and the mainframe.
        """"""
        msg = MessageBuilder().cal_query(slot=slot)
        with self.root_instrument.timeout.set_to(self.calibration_time_out):
            response = self.ask(msg.message)
        return constants.CALResponse(int(response))

    def error_message(self, mode: Optional[Union[constants.ERRX.Mode,
                                                 int]] = None) -> str:
        """"""
        This method reads one error code from the head of the error
        queue and removes that code from the queue. The read error is
        returned as the response of this method.

        Args:
            mode: If no valued passed returns both the error value and the
                error message. See :class:`.constants.ERRX.Mode` for possible
                arguments.

        Returns:
            In the default case response message contains an error message
            and a custom message containing additional information such as
            the slot number. They are separated by a semicolon (;). For
            example, if the error 305 occurs on the slot 1, this method
            returns the following response. 305,""Excess current in HPSMU.;
            SLOT1"" If no error occurred, this command returns 0,""No Error.""
        """"""

        msg = MessageBuilder().errx_query(mode=mode)
        response = self.ask(msg.message)
        return response

    def clear_buffer_of_error_message(self) -> None:
        """"""
        This method clears the error message stored in buffer when the
        error_message command is executed.
        """"""
        msg = MessageBuilder().err_query()
        self.write(msg.message)

    def clear_timer_count(self, chnum: Optional[int] = None) -> None:
        """"""
        This command clears the timer count. This command is effective for
        all measurement modes, regardless of the TSC setting. This command
        is not effective for the 4 byte binary data output format
        (FMT3 and FMT4).

        Args:
            chnum: SMU or MFCMU channel number. Integer expression. 1 to 10.
                See Table 4-1 on page 16 of 2016 manual. If chnum is
                specified, this command clears the timer count once at the
                source output start by the DV, DI, or DCV command for the
                specified channel. The channel output switch of the
                specified channel must be ON when the timer count is
                cleared.

        If chnum is not specified, this command clears the timer count
        immediately,
        """"""
        msg = MessageBuilder().tsr(chnum=chnum)
        self.write(msg.message)

    def set_measurement_mode(self,
                             mode: Union[constants.MM.Mode, int],
                             channels: Optional[constants.ChannelList] = None
                             ) -> None:
        """"""
        This method specifies the measurement mode and the channels used
        for measurements. This method must be entered to specify the
        measurement mode. For the high speed spot measurements,
        do not use this method.
        NOTE Order of the channels are important. The SMU which is setup to
        run the sweep goes first.

        Args:
            mode: Measurement mode. See `constants.MM.Mode` for all possible
                modes
            channels: Measurement channel number. See `constants.ChannelList`
                for all possible channels.
        """"""
        msg = MessageBuilder().mm(mode=mode, channels=channels).message
        self.write(msg)

    def get_measurement_mode(self) -> Dict[str, Union[constants.MM.Mode,
                                                      List[int]]]:
        """"""
        This method gets the measurement mode(MM) and the channels used
        for measurements. It outputs a dictionary with 'mode' and
        'channels' as keys.
        """"""
        msg = MessageBuilder().lrn_query(type_id=constants.LRN.
                                         Type.TM_AV_CM_FMT_MM_SETTINGS)
        response = self.ask(msg.message)
        match = re.search('MM(?P<mode>.*?),(?P<channels>.*?)(;|$)', response)

        if not match:
            raise ValueError('Measurement Mode (MM) not found.')

        out_dict: Dict[str, Union[constants.MM.Mode, List[int]]] = {}
        resp_dict = match.groupdict()
        out_dict['mode'] = constants.MM.Mode(int(resp_dict['mode']))
        out_dict['channels'] = list(map(int, resp_dict['channels'].split(',')))
        return out_dict

    def get_response_format_and_mode(self) -> \
            Dict[str, Union[constants.FMT.Format, constants.FMT.Mode]]:
        """"""
        This method queries the the data output format and mode.
        """"""
        msg = MessageBuilder().lrn_query(type_id=constants.LRN.
                                         Type.TM_AV_CM_FMT_MM_SETTINGS)
        response = self.ask(msg.message)
        match = re.search('FMT(?P<format>.*?),(?P<mode>.*?)(;|$)',
                          response)

        if not match:
            raise ValueError('Measurement Mode (FMT) not found.')

        out_dict: Dict[str, Union[constants.FMT.Format, constants.FMT.Mode]] \
            = {}
        resp_dict = match.groupdict()
        out_dict['format'] = constants.FMT.Format(int(resp_dict[
                                                          'format']))
        out_dict['mode'] = constants.FMT.Mode(int(resp_dict['mode']))
        return out_dict

    def enable_smu_filters(
            self,
            enable_filter: bool,
            channels: Optional[constants.ChannelList] = None
    ) -> None:
        """"""
        This methods sets the connection mode of a SMU filter for each channel.
        A filter is mounted on the SMU. It assures clean source output with
        no spikes or overshooting. A maximum of ten channels can be set.

        Args:
            enable_filter : Status of the filter.
                False: Disconnect (initial setting).
                True: Connect.
            channels : SMU channel number. Specify channel from
                `constants.ChNr` If you do not specify chnum,  the FL
                command sets the same mode for all channels.
        """"""
        self.write(MessageBuilder().fl(enable_filter=enable_filter,
                                       channels=channels).message)


class IVSweepMeasurement(MultiParameter, StatusMixin):
    """"""
    IV sweep measurement outputs a list of measured current parameters
    as a result of voltage sweep.

    Args:
        name: Name of the Parameter.
        instrument: Instrument to which this parameter communicates to.
    """"""

    def __init__(self, name: str, instrument: B1517A, **kwargs: Any):
        super().__init__(
            name,
            names=tuple(['param1', 'param2']),
            units=tuple(['A', 'A']),
            labels=tuple(['Param1 Current', 'Param2 Current']),
            shapes=((1,),) * 2,
            setpoint_names=(('Voltage',),) * 2,
            setpoint_labels=(('Voltage',),) * 2,
            setpoint_units=(('V',),) * 2,
            instrument=instrument,
            **kwargs)

        self.instrument: B1517A
        self.root_instrument: KeysightB1500

        self.param1 = _FMTResponse(None, None, None, None)
        self.param2 = _FMTResponse(None, None, None, None)
        self.source_voltage = _FMTResponse(None, None, None, None)
        self._fudge: float = 1.5

    def set_names_labels_and_units(self,
                                   names: Optional[Sequence[str]] = None,
                                   labels: Optional[Sequence[str]] = None,
                                   units: Optional[Sequence[str]] = None
                                   ) -> None:
        """"""
        Set names, labels, and units of the measured parts of the MultiParameter.

        If units are not provided, ""A"" will be used because this parameter
        measures currents.

        If labels are not provided, names will be used.

        If names are not provided, ``param#`` will be used as names; the number
        of those names will be the same as the number of measured channels
        that ``B1500.get_measurement_mode`` method returns. Note that it is
        possible to not provide names and provide labels at the same time.
        In case, neither names nor labels are provided, the labels will be
        generated as ``Param# Current``.

        The number of provided names, labels, and units must be the same.
        Moreover, that number has to be equal to the number of channels
        that ``B1500.get_measurement_mode`` method returns. It is
        recommended to set measurement mode and number of channels first,
        and only then call this method to provide names/labels/units.

        The name/label/unit of the setpoint of this parameter will also be
        updated to defaults dictated by the
        ``set_setpoint_name_label_and_unit`` method.

        Note that ``.shapes`` of this parameter will also be updated to
        be in sync with the number of names.
        """"""
        measurement_mode = self.instrument.get_measurement_mode()
        channels = measurement_mode['channels']

        if names is None:
            names = [f""param{n+1}"" for n in range(len(channels))]
            if labels is None:
                labels = [f""Param{n + 1} Current"" for n in range(len(channels))]

        if labels is None:
            labels = tuple(names)

        if units is None:
            units = ['A'] * len(names)

        if len(labels) != len(names) or len(units) != len(names):
            raise ValueError(
                f""If provided, the number of names, labels, and units must be ""
                f""the same, instead got {len(names)} names, {len(labels)} ""
                f""labels, {len(units)} units.""
            )

        if len(names) != len(channels):
            raise ValueError(
                f""The number of names ({len(names)}) does not match the number ""
                f""of channels expected for the IV sweep measurement, ""
                f""which is {len(channels)}. Please, when providing names, ""
                f""provide them for every channel.""
            )

        self.names = tuple(names)
        self.labels = tuple(labels)
        self.units = tuple(units)

        for n in range(len(channels)):
            setattr(self, f""param{n+1}"", _FMTResponse(None, None, None, None))

        self.shapes = ((1,),) * len(self.names)

        self.set_setpoint_name_label_and_unit()

    def set_setpoint_name_label_and_unit(
            self,
            name: Optional[str] = None,
            label: Optional[str] = None,
            unit: Optional[str] = None
    ) -> None:
        """"""
        Set name, label, and unit of the setpoint of the MultiParameter.

        If unit is not provided, ""V"" will be used because this parameter
        sweeps voltage.

        If label is not provided, ""Voltage"" will be used.

        If name are not provided, ``voltage`` will be used.

        The attributes describing the setpoints of this MultiParameter
        will be updated to match the number of measured parameters of
        this MultiParameter, as dictated by ``.names``.
        """"""
        # number of measured parameters of this MultiParameter
        n_names = len(self.names)

        name = name if name is not None else ""voltage""
        label = label if label is not None else ""Voltage""
        unit = unit if unit is not None else ""V""

        self.setpoint_names = ((name,),) * n_names
        self.setpoint_labels = ((label,),) * n_names
        self.setpoint_units = ((unit,),) * n_names

    def get_raw(self) -> Tuple[Tuple[float, ...], ...]:
        measurement_mode = self.instrument.get_measurement_mode()
        channels = measurement_mode['channels']
        n_channels = len(channels)

        if n_channels < 1:
            raise ValueError('At least one measurement channel is needed for '
                             'an IV sweep.')

        if (
                len(self.names) != n_channels
                or len(self.units) != n_channels
                or len(self.labels) != n_channels
                or len(self.shapes) != n_channels
        ):
            raise ValueError(
                f""The number of `.names` ({len(self.names)}), ""
                f""`.units` ({len(self.units)}), `.labels` (""
                f""{len(self.labels)}), or `.shapes` ({len(self.shapes)}) ""
                f""of the {self.full_name} parameter ""
                f""does not match the number of channels expected for the IV ""
                f""sweep measurement, which is {n_channels}. One must set ""
                f""enough names, units, and labels for all the channels that ""
                f""are to be measured.""
            )

        smu = self.instrument.by_channel[channels[0]]

        if not smu.setup_fnc_already_run:
            raise Exception(f'Sweep setup has not yet been run successfully '
                            f'on {smu.full_name}')

        delay_time = smu.iv_sweep.step_delay()
        if smu._average_coefficient < 0:
            # negative coefficient means nplc and positive means just
            # averaging, see B1517A.set_average_samples_for_high_speed_adc
            # for more info
            nplc = 128 * abs(smu._average_coefficient)
            power_line_time_period = 1 / smu.power_line_frequency
            calculated_time = 2 * nplc * power_line_time_period
        else:
            calculated_time = smu._average_coefficient * delay_time
        num_steps = smu.iv_sweep.sweep_steps()
        estimated_timeout = max(delay_time, calculated_time) * num_steps
        new_timeout = estimated_timeout * self._fudge

        format_and_mode = self.instrument.get_response_format_and_mode()
        fmt_format = format_and_mode['format']
        fmt_mode = format_and_mode['mode']
        try:
            self.root_instrument.write(MessageBuilder().fmt(1, 1).message)
            with self.root_instrument.timeout.set_to(new_timeout):
                raw_data = self.instrument.ask(MessageBuilder().xe().message)
        finally:
            self.root_instrument.write(MessageBuilder().fmt(fmt_format,
                                                            fmt_mode).message)

        parsed_data = fmt_response_base_parser(raw_data)

        # The `4` comes from the len(_FMTResponse(None, None, None, None)),
        # the _FMTResponse tuple declares these items that the instrument
        # gives for each data point
        n_items_per_data_point = 4

        # sourced voltage values are also returned, hence the `+1`
        n_all_data_channels = n_channels + 1

        for channel_index in range(n_channels):
            parsed_data_items = [
                parsed_data[i][channel_index::n_all_data_channels]
                for i in range(0, n_items_per_data_point)
            ]
            single_channel_data = _FMTResponse(*parsed_data_items)
            convert_dummy_val_to_nan(single_channel_data)

            # Store the results to `.param#` attributes for convenient access
            # to all the data, e.g. status of each value in the arrays
            setattr(self, f""param{channel_index+1}"", single_channel_data)

        channel_values_to_return = tuple(
            getattr(self, f""param{n + 1}"").value
            for n in range(n_channels)
        )

        source_voltage_index = n_channels
        parsed_source_voltage_items = [
            parsed_data[i][source_voltage_index::n_all_data_channels]
            for i in range(0, n_items_per_data_point)
        ]
        self.source_voltage = _FMTResponse(*parsed_source_voltage_items)

        self.shapes = ((len(self.source_voltage.value),),) * n_channels
        self.setpoints = ((self.source_voltage.value,),) * n_channels

        return channel_values_to_return
"
340,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attbuXPs6Pc510cXh'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-arWxoxLk2hmuVY6AWNnkg/51p8hSdhifadatdQnM_mVie5tReCoqWHktf7ncUOyLwwMbeLKNah2I_Qy5kD9fHrn7bs5_8qoBzFHpT29P9OpBPOfwkjATpul1CBVH3bAZuFDy5uwDdmMXZOsluBBuxb/Y0JOfD7oryEfUWWmp7AS7OIN2byJFUyu-Ggnzj149H4'), ('filename', 'dp832-oblique-1200x735-White-b.jpg'), ('size', 120933), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iEtnh8WzX2B3gYIBMH7qvw/g1DRGiPoSFGYXWFDvpX2b84O1r1Q0xI1MQJVFTbOd3Pc7XRL7ZmYzI7VchvE_we2rA8uv72E3GvDfNWwndNsbQ/fVzPWrb52e3UUdPeTsTYZtCIHIQN8vHJy4fH8pH1lFE'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LW17CYUHDcOQRIVPExZAbA/AHVkxB_ouh-hDVklYSg1eE7NPUz7K66nxQ2aGuDMDl2EQEZo5q0r2oQmibwDrPIalD-2PJfrha7SWRwSXbl9IQ/kxs9-nhF9csLvvryMhM2ekcR_9YIyeq6OHTVt5ewE7M'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/IMIZ_NInDbszXiQbenYtGQ/-XqU5zZOdfwosYZt7_lPiw8ZSjzeJdRgUpSD_GY8P6mAf-R9OyrZ0svtXAvVcZK_1aVlQwY2m9ohGlZ8hMbEsA/I7WwTEpug57putFxq-9okzHFU4UIRij8KrWEb42egP0'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"3 Outputs; total power up to 195W
Low Ripple Noise <350 uVrms/2mVpp
Fast transient response time: <50 us
Channel isolation: CH1 || CH2,CH3
OVP/OCP/OTP protection functions
Built in V, A, W measurements and waveform display",https://www.tequipment.net/RigolDP832.html,DP 832,449.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP832.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP831,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782725/Instruments/Power%20Supplies/Rigol-DP832/Rigol-DP832.jpg,Rigol DP832,Write a Python script that uses Qcodes to connect to a Rigol DP832 Power Supplies,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP832(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP832(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [(30.0, 3.0), (30.0, 3.0), (5.0, 3.0)]

        ovp_ranges_std = [(0.01, 33.0), (0.01, 33.0), (0.01, 5.5)]
        ocp_ranges_std = [(0.001, 3.3), (0.001, 3.3), (0.001, 3.3)]

        ovp_ranges_precision = [(0.001, 33.0), (0.001, 33.0), (0.001, 5.5)]
        ocp_ranges_precision = [(0.001, 3.3), (0.001, 3.3), (0.001, 3.3)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
345,http://www.octsources.com/otcadmin/document/pdf/20180815/1534322934.pdf,https://en.wikipedia.org/wiki/Analog-to-digital_converter,"[OrderedDict([('id', 'attTCX5gifGPnLbsx'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZPT8gIzUAtx_UNLzrZAyxw/CJ7NntBvJmXQnmPDL2FolCsWlTL20E3I5XldQ3WNVwFgqmvF-uA_wJEpfcQMdvROiJWw920HW-pog12BQRhUHSk5LQn4DZHA11XCU79nVbk/coTQsrv_tMNAkydz3X4VAWkFPzlJQFlQ4N4CnGRseuw'), ('filename', 'ATS9360.jpg'), ('size', 525306), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/AEgkIKFZXHlAjZefdqWMBg/tX23yyPNLSwc1MMQ3eAqKMHwlSvXJ80EhC-4eLFfgPWcNsggHRJcN6BDLPLGXuttXp9H89w8B6RAEGVxrlb7Kg/fP2Z9GbWNiZpPYfPT61XCv56daGCTLgZwqlTmPYZGys'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ng25ZE_OY3y9hlX2yscMug/MsHEFbXAWRJcTl-80du004AFM9qI7YnavuG1osHq0fE--WVnqsbBDuhT8xXzRId9GkPci8_Y1L2VkdXYNNAkCA/mYym-4W4mL9gYoJI5gCn_a2uVOugin70j0nPkQdBqb4'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/CO1EJRjtP_4dXZ5SNcdtcA/eJ2BHLtS1MDpI9G7B343ti3zUbHJWzSVu_hCBbhJjB5WwHnB24TxKCAK4OKDGt6usMMLlcGdU4Krs7l95sGm9A/czKJf6NaPBO0FhxAuU2yrokjPtQVtj2eR_KFL5JR2rA'), ('width', 3000), ('height', 3000)]))]))])]",4.0,CANADA - QC,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692117216/Instruments/Vendor%20Logos/Alazartech.png,"ATS9360 is a fast, 12-bit waveform digitizer based on the 8-lane PCI Express Gen2 interface.
",https://www.alazartech.com/en/product/ats9360/3/,ATS 9360,62.0,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
", https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AlazarTech/ATS9360.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AlazarTech.html#qcodes.instrument_drivers.AlazarTech.AlazarTechATS9360,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qAKVZnWakj3BsqaWIGBWRQ/ZrX_1_RMjBiSZrv9vP_57uXX3nVYvTG1M9yX0X0AbV2ABAwNqnlZ9ph2VxPWUntz57MfzGIcVtzwp_xIT4ogdpEUOSJkRSVjiQ9SdRaAR8Y/iqBF0wweZWGzh_PoUEPAoR1OMbJQ4ahE5SQ20efnW3w'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/c4okM_mAktf0nM5a4ujUcw/ojbZu24hQ3OsnpsLBQXtdSWuTk3Iklxwh_8h6Gu6nI-N-cZTED09W58zGdsdkzX784cjIMgM0mnM_Z10HE0DWw/-nQKXfI9UrjNxpUl6HPlw0VxPf0bhIFJu_puq3PBLH4'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wLU644oqMwyGp0nvbNsxWg/zc4O5FXXDWFC_3eWYDbTDhZ-8RKh4CywL6uxn3m30ZG4fRuCONJ6Iogf6ftQ_O_Q8qSa8Eq3C__L1bpo6Vc0tQ/tV1Jc99vngeTFMSvJRsKPiMPSZq261WWlEYFw6eF4dU'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pkhaW6W4s4X9DwUXiC5Qnw/twaNCkfaOpFsDIxJR3erWLY6uTRf-2naFC2FMhp_b49XItnrDMobUqWla3Gd6BRrhtn7cJNMypgCsWLD8PhzCw/_jkIrQ_2tQiU0GB3OhyCLuO6UO3JEk_1njNMezltdd4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782729/Instruments/DAQ%20boards/ATS9360---12bit%2C-1.8GS-s/ATS9360---12bit_-1.8GS-s.jpg,"ATS9360 - 12bit, 1.8GS/s","Write a Python script that uses Qcodes to connect to a ATS9360 - 12bit, 1.8GS/s DAQ boards",,"
",,,
346,https://www.keysight.com/us/en/assets/7018-06774/data-sheets/5968-0162.pdf,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,"[OrderedDict([('id', 'att9b4fdU88PPuq2T'), ('width', 1164), ('height', 628), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/duxFpRSl0UE4F-njCLFjEw/I8vJ2H6CBhkq3e86KNsgeH3QBMgzXY1ARWHT1yDrr2wThTi-_oXn3_1WSuBBSgVyxBllSGAakqHPHpHh2Etvvk8M4cV3yZxr61HqRpm7Od8/aPrPG-tt2VgGFa98ilxVa1YWmQbDegQMIHL-ngDvkDA'), ('filename', '34401A.png'), ('size', 394318), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RCFpX6M9-9-uHGSIn4I2wA/s8eEbeSTQKfvMawkzxfq4ac0xPM3KbMqO0shuCFLYZ4pHJdgokx-jiL2J9bNWeBTE-xEE2_RmkN9yHqBSx4hug/inllsEPOXsRSI60OLcsMD9xjcNEztAJ5m9Ip9lIV8YY'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QYBAFvi0rMB1r-FFaD3XPA/mF5__3ymw8sBmeXgUGeAnmr0FqzPPcJWiR5daX3wXPAiAfHf0j9BG9vK0GMEoWCIfWHe7rO1gQyj6mmZHbqoUQ/rFKVxnqJABXLTEtt_VTj5InkFRVBqFfLNdzzUs6QyFQ'), ('width', 949), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hvrTvfdr6d6Uo3VkOnvG4A/t8kO-xXhCPXgMTT2Lo0cVK32W_A5kqQoQBdjYrrGDleEGuD6HUzhxhzZt-iCZQX0IQjLQp66A0QihzkVmzKMcA/QqRW9hSia_qNDh0tUqFiXKEGzOwQdo9rcOZcXAmaRq8'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Agilent.png,"The Keysight Technologies, Inc. 34401A multimeter gives you the performance you need for fast, accurate bench and system testing. The 34401A provides a combination of resolution, accuracy and speed that rivals DMMs costing many times more. 6½ digits of resolution",https://www.keysight.com/us/en/product/34401A/digital-multimeter-6-digit.html,Agilent 34401 A,31.0,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Agilent.html#qcodes.instrument_drivers.agilent.Agilent34401A,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/iBkD5hWEdE9VzBFEnSeOfA/NjWxUxjJA8yGPExBiN-PkZNjv4VfBExywq89pMu9c9Ra2W7et-Aw64QgEaSQebRctQuA2kL2PnwYRmggAnp4lSGJ5zznVS6ye7vLZh646iQ/Kl7uXhhhwfiGUId4CxlN-USzNex2x6CGk7CVIvfLvQ4'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f6t0-WbC6cKqyn0DT117iA/QPT0gpK6FG2qsOLK-bt0IxmOydbb6-9Pxg2hNGQF0mxWHfXPYXFiZagCw1Yj9qkKeKEbN-OQzc1R1_lDDq3DCa-N0BRerbz5SnzZQJlzbJ8/iuupeOUi0pSC13qOqrqjRHiA-gwJTseDKR1IenXqWtY'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/cFs4Pvz6m9YFSFnAUBP9Jw/NgiAU7UcTKsj4PX6Lzw6SkhLC1rCN7-KpOyUy0E3yh7QLAbmpKXYyYKq1x_OkoLZAlEY7R20W5zF_Vo0-E3cUyiYsxgXKf9_RTswNy3Wd7w/GhCXNKTSYmUF5vw3ifd6HKHmQkYlHKJQaWCVYa06Xqg'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Pxy_7pX_47hdW9iN2Gvi7A/4LRl2aDd8IoPIwJ53KRuFtJ4dEG8aRW8frebU514v4lYFkRRLyyF7Kcfv4Q3zGQT19g9Bs1hNet5CN1YxdFcjM9hQIBoBBiixzvExLQHvMM/RhEKW_l5u-Xiv303cIU5H_n4SPQvKttNDyTSjmqpWkI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782730/Instruments/Multimeters/Keysight-34401A/Keysight-34401A.png,Keysight 34401A,Write a Python script that uses Qcodes to connect to a Keysight 34401A Multimeters,,"
",True,,"import logging
from functools import partial
from typing import Any, Union

from qcodes import validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument

from .private.error_handling import KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class Keysight33xxxOutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a Keysight 33xxxx waveform generator.
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


OutputChannel = Keysight33xxxOutputChannel


class Keysight33xxxSyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output of a Keysight 33xxxx waveform generator.
    Has very few parameters for single channel instruments.
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


SyncChannel = Keysight33xxxSyncChannel


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels + 1):
            channel = Keysight33xxxOutputChannel(self, f""ch{i}"", i)
            self.add_submodule(f""ch{i}"", channel)

        sync = Keysight33xxxSyncChannel(self, ""sync"")
        self.add_submodule(""sync"", sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
350,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,"[OrderedDict([('id', 'attep8JPM5PjAYEs7'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZMzsfPYcCDsLKkJEAH8JDw/PCFOvaOW9v2DIzUeoj9RKNCMq-BN5GIr-UYyVKcf1fAyEDBVmXZzzXdjVcA-hxvr7CW7TYAQs6fGDTBQScS8xY_4-PY7jLbzV1Q_1lG98xXmzPgcOD-yqbELXDKF5nCF/lno8WHNrQfzRJHtNxrCUdkk_mZ61SvHUUY_nX7fVg7A'), ('filename', '34980A-FRONT-TRANSP-01-20190415.png'), ('size', 891966), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/WlYjEn1gTrmX7QxnU3YK5Q/E2XwDfyeQTN2oHThq0GlIOkc6R3j7tmQ62VF99TyK1uhGHCmF-ilbBVbiZDiaSrX38_MP8s0S2a8ECSUofkfKg/tKMGQDjqdedIz8JwO9Y5ltKUYkqM9ZZ6R0b0WFy8i4w'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/lZLeaPe95yuZmegj4GrgDA/FzHryBk0ab5xyrtEhV3VtEMeZqXQmQJnI5I-dnN2bF1eHw9GGS4Gj866AoNiB_I71VHpylen8UTBxTgJDm-66A/p2y0OC_FmUlv-pSr6yjOpSLcRg6scZRUTut1Zjzfx5g'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9t9IEY1dFpyjcNJmIeMQ9A/km0ju1t_LX75aUiSGEymCfym47a3tRkTn6yD7VrRGiXXSoOXvAB2YwGyXScI34a5E0EGl8agWpx5KhWY-Ie7vw/My0UmN_611pcOpJXuwk6CthfjqHqyb0tIyk33xcm8PU'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight 34980A Multifunction Switch/Measure unit is designed for R&D and
manufacturing test engineers who are working in design verification, automated
test or data acquisition and are either looking to upgrade their existing systems or
are in need of a new, cost-effective alternative",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,Keysight 34980 A Submodules,340.0,"['DAQ boards', 'Multimeters']","With 19 different plug-in modules in low frequency, RF and microwave switching to
20GHz, digital I/O, D/A converters, and counter/totalizer functionality, the 34980A
has the core switch/measure functionality needed for most automated test and
data acquisition applications. The 34980A can accommodate up to 560 2-wire
MUX or 1024 2-wire matrix crosspoints in one mainframe.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34980a_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34980ASwitchMatrixSubModule,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782733/Instruments/DAQ%20boards/Keysight-34980A-Submodules/Keysight-34980A-Submodules.png,Keysight 34980A Submodules,"Write a Python script that uses Qcodes to connect to a Keysight 34980A Submodules DAQ boards, Multimeters",4167.0,,,,"from qcodes import VisaInstrument, InstrumentChannel
from typing import Union, List, Tuple, Optional


class KeysightSubModule(InstrumentChannel):
    """"""
    A base class for submodules for the 34980A systems.

    Args:
        parent: the system which the module is installed on
        name: user defined name for the module
        slot: the slot the module is installed
    """"""
    def __init__(
            self,
            parent: Union[VisaInstrument, InstrumentChannel],
            name: str,
            slot: int
    ) -> None:

        super().__init__(parent, name)

        self.slot = slot


class KeysightSwitchMatrixSubModule(KeysightSubModule):
    """"""
    A base class for **Switch Matrix** submodules for the 34980A systems.
    """"""
    def validate_value(self, row: int, column: int) -> None:
        """"""
        to check if the row and column number is within the range of the module
        layout.

        Args:
            row: row value
            column: column value
        """"""
        raise NotImplementedError(""Please subclass this"")

    def to_channel_list(
            self,
            paths: List[Tuple[int, int]],
            wiring_config: Optional[str] = None
    ) -> str:
        """"""
        convert the (row, column) pair to a 4-digit channel number 'sxxx', where
        s is the slot number, xxx is generated from the numbering function.
        This may be different for different modules.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
            wiring_config: for 1-wire matrices, values are 'MH', 'ML';
                                 for 2-wire matrices, values are 'M1H', 'M2H',
                                 'M1L', 'M2L'

        Returns:
            in the format of '(@sxxx, sxxx, sxxx, sxxx)', where sxxx is a
            4-digit channel number
        """"""
        raise NotImplementedError(""Please subclass this"")

    def is_open(self, row: int, column: int) -> bool:
        """"""
        to check if a channel is open/disconnected

        Args:
            row: row number
            column: column number

        Returns:
            True if the channel is open/disconnected
            False if it's closed/connected.
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        message = self.ask(f'ROUT:OPEN? {channel}')
        return bool(int(message))

    def is_closed(self, row: int, column: int) -> bool:
        """"""
        to check if a channel is closed/connected

        Args:
            row: row number
            column: column number

        Returns:
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        message = self.ask(f'ROUT:CLOSe? {channel}')
        return bool(int(message))

    def connect(self, row: int, column: int) -> None:
        """"""
        to connect/close the specified channels

        Args:
            row: row number
            column: column number
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        self.write(f'ROUT:CLOSe {channel}')

    def disconnect(self, row: int, column: int) -> None:
        """"""
        to disconnect/open the specified channels

        Args:
            row: row number
            column: column number
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        self.write(f'ROUT:OPEN {channel}')

    def connect_paths(self, paths: List[Tuple[int, int]]) -> None:
        """"""
        to connect/close the specified channels.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        self.write(f""ROUTe:CLOSe {channel_list_str}"")

    def disconnect_paths(self, paths: List[Tuple[int, int]]) -> None:
        """"""
        to disconnect/open the specified channels.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        self.write(f""ROUTe:OPEN {channel_list_str}"")

    def are_closed(self, paths: List[Tuple[int, int]]) -> List[bool]:
        """"""
        to check if a list of channels is closed/connected

        Args:
            paths: list of channels [(r1, c1), (r2, c2), (r3, c3)]

        Returns:
            a list of True and/or False
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        messages = self.ask(f""ROUTe:CLOSe? {channel_list_str}"")
        return [bool(int(message)) for message in messages.split(',')]

    def are_open(self, paths: List[Tuple[int, int]]) -> List[bool]:
        """"""
        to check if a list of channels is open/disconnected

        Args:
            paths: list of channels [(r1, c1), (r2, c2), (r3, c3)]

        Returns:
            a list of True and/or False
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        messages = self.ask(f""ROUTe:OPEN? {channel_list_str}"")
        return [bool(int(message)) for message in messages.split(',')]
"
353,https://www.keysight.com/us/en/assets/7018-01701/data-sheets/5989-7607.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),"[OrderedDict([('id', 'attPtUSwhI8DGuduQ'), ('width', 300), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RBdR1mLBcJ4tMv2cY0iTHQ/zMbNLV4vP0H2JCWfjmuhI1Whks3C16BUPbW-f89OhM6WUblUcVmJLV-c49dByaSrNQKmAtpeuvCoFtlgP6FqK8gz4vEo4Z-zIklrPcF_DVo/D8HV0hCWWB-4tldmpC_vi1r06bXxRxTdh3si8LFXGHA'), ('filename', 'PROD-2813653-01.jpeg'), ('size', 8794), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/d-R1JJ7-4vusdSLpS6MaJw/J6HJCr8v2myaoYJ5h3dH3Y0PKwRbXsosI8cAxW3Cl5LrcQxJVicrRkuxFov1D8znY7J30tTOJ5CF1nArKTgbAg/4p0KbChrSmUzIQ1fWotS6cYzQ9LnmHulGZ1sVsy8h2A'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/kEJhsV6FdoxEuuI_it6BJw/53SkwCbx4202QkbVNo-GEsmX2jua0ZYwMfHrNDMxQgU-0RCDJRgmz-au7g16EvWcDx89-a0q3XWceue6fbKA3g/IIkAChvjsLWaHnNOX8vHtsyTTem_-u1BKecoBhzPaJM'), ('width', 300), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/qp4boSQA5JJNEbVlZBMORw/62Nvo4A5BOAfPvNPtcGNUkdK17qvVcZw6FJ8eLsUP9XWO_M5oix8LU-YZpvJwAI_i3tUdVCjGyzoTcjFe1N2RQ/i9QDb2RTSTovIRoXsphzgflEN8K68IFMU94iq0kM1-c'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The Keysight N5230C PNA-L is a microwave network analyzer made to test amplifiers, passive parts, and frequency converters using S-parameters and basic nonlinearity. The Keysight N5230C has a 110 dB system / 122 dB receiver dynamic range. The N5230C has a 300 kHz to 20 GHz frequency range and has 2 or 4 ports with built-in sources. ",https://www.atecorp.com/products/keysight-technologies/n5230c?utm_campaign=15209129943&utm_source=google&utm_medium=cpc&utm_content=561353703737&utm_term=n5230c&adgroupid=133315120241&gclid=CjwKCAjwkeqkBhAnEiwA5U-uM_jEyq6KdRiHb-ejDqCOp_dmY1vg0I-730tGgDsNF7YH_L9dfrCPORoCRWIQAvD_BwE,Keysight N 5230 C,312.0,['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N5230C.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5230C,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782736/Instruments/Network%20Analyzer/Keysight-N5230C/Keysight-N5230C.jpg,Keysight N5230C,Write a Python script that uses Qcodes to connect to a Keysight N5230C Network Analyzer,19995.0,,True,,"from typing import Any

from . import N52xx

class N5230C(N52xx.PNABase):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address,
                         min_freq=300e3, max_freq=13.5e9,
                         min_power=-90, max_power=13,
                         nports=2,
                         **kwargs)
"
354,https://download.tek.com/datasheet/1KW-61232-0_Series_3700A_System_Switch_Multimeter_Datasheet_051122.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'att5DpqBAEQuD5qpR'), ('width', 320), ('height', 171), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/F1_j429ZWTVqSI3NWdT43Q/SwCU21zzjhYaNqFUoS3mQ3dfH9Gb2rqBgj7tBFnjtnf9io5sQftZo1L3wNV-nAmT83nycb0ooThOTvREIMBt722bEGIT8Bqmoj7kMq9sC6I/ZIuN9L7KODe9SQZF313xpxDSRe-3nV_EhanaWTjHTxk'), ('filename', '3706a.webp'), ('size', 2692), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xTefsqrmMm4TLmoAWx_Cgg/9UtBnKDmALnDq3aM76pi8kI7FJ1_yppPAhd2aKnnIMbtAtSlSF-KIEGAaW4g-nUdDc-6zFF6NNWRXwkPxZWcH-l0mH15xenP_RYG0Q8fpVY/Mo1V6tDslE7YGwxpKTf_hUvIEOYqwnSsM6liXLMoOxM'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/baDosPRohgUDqty-3NqOfg/0G9NyZT1idSMGGu_wWjBDFW_9mP6j17BSsS8KiiNuDczGyriMYDke8lSkQAKjksY35jGDbg2KynSL_f-sLvjGtVJ-C8ZspXZAHOEAteNUag/6sFilBw2etfaHQw9UE4sucpRsH_wpGSjzi6-QRjJ1HY'), ('width', 320), ('height', 171)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VS244Ais18R9jY71okStYQ/MgJcaUyqOXYJxmRCw6PA8kqwo9pk0cOPGJlbc0clPp9FLPaBIUt_aA0GdGcRf5uJjmmD8ABY_-B7GZzAUpmHWD28vcnVyuOMHTumxyH2xnw/83JB7QuouztwWnursU0Y__n-i4K8iuhDyVw2wk9VLGg'), ('width', 3000), ('height', 3000)]))]))])]",110.6,"Cleveland, Ohio, United States",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116722/Instruments/Vendor%20Logos/Keithley.png,"The Model 3706A system switch with high performance DMM contains six slots for plug-in cards in a compact 2U high enclosure that easily accommodates the needs of medium to high channel count applications. When fully loaded, a mainframe can support up to 576 two-wire multiplexer channels for unrivaled density and economical per channel costs. The result is a tightly integrated switch and measurement solution that’s equally at home on the bench or in the rack.",https://www.tek.com/en/products/keithley/switching-and-data-acquisition-systems/3700a-systems-switch-multimeter,Keithley 3706 A,264.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_3706A.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley3706A,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/JPWbbY0RLTwvCH95zF0lUw/FYE_qzqVeKunCKXZHcCO2IQTlNtrj9deJrJ8IvRi4E8DhdciuLtui1KbfRNDyts0f82Yurlppm-Hpyw3N70TJuAIKY3_44qDFhUb8ydul1PEtbKFosfYlGsV4U7IYpib3RVUQUX5GWVokNgkYfRknw/WU55GPpzEr8Un4iaGll8XGxfZsNp7qoBV0mtZZFez5s'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VBp9CVCl0gO2A14HXB5CIA/Xtk2sr79MHggQNs60J8dAjJHuRLmrvNscTMXYVwGV-rOZX5ZQ4F7ACtavmtqrw0hhhYlJn4zHMcxjwK-x-WurQ/oE5_tuvZoBAR0QruNt2Xeul6WMntVby0GJuS2SR_fo0'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yaThx4kuSOslFnzq5eZpVQ/hNGVd1kgX7qo-Cv7FP9SK4FZBtGf6rfq2o4m_CWKrLkbqbSICtQmrqYH0b_i97LMUNtmJS49zBQ1ggsKG7GbMQ/aLt21VBpyLvyGoECYC69PHf_IKCG95xaVCmAVNleiU4'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ExgTiTQZwc2k2En25SNuZg/jVYfq4gboOT4ayM0U7gaP_jOrYvw63gq8LdOviK8pjRBK24qXRRVHJkZCsY3WIMXq_zK_qoOOwSZifr4odddsA/Xrej63AC0_Tv8PsRwHhmYW8nkHQ-rKBZOkMsm3Q7Dxk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782738/Instruments/Multimeters/Keithley-3706A/Keithley-3706A.webp,Keithley 3706A,Write a Python script that uses Qcodes to connect to a Keithley 3706A Multimeters,5000.0,,,,"import itertools
import textwrap
import warnings
from typing import Any, Optional, Union

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class Keithley3706AUnknownOrEmptySlot(Exception):
    pass


class Keithley3706AInvalidValue(Exception):
    pass


class Keithley3706A(VisaInstrument):
    """"""
    This is the QCoDeS instrument driver for the Keithley 3706A-SNFP
    System Switch.
    """"""

    def __init__(
        self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any
    ) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""channel_connect_rule"",
            get_cmd=self._get_channel_connect_rule,
            set_cmd=self._set_channel_connect_rule,
            docstring=textwrap.dedent(
                """"""\
                                    Controls the connection rule for closing
                                    and opening channels when using
                                    `exclusive_close` and `exclusive_slot_close`
                                    parameters.

                                    If it is set to break before make,
                                    it is ensured that all channels open
                                    before any channels close.

                                    If it is set to make before break, it is
                                    ensured that all channels close before any
                                    channels open.

                                    If it is off, channels open and close
                                    simultaneously.""""""
            ),
            vals=vals.Enum(""BREAK_BEFORE_MAKE"", ""MAKE_BEFORE_BREAK"", ""OFF""),
        )

        self.add_parameter(
            ""gpib_enabled"",
            get_cmd=self._get_gpib_status,
            set_cmd=self._set_gpib_status,
            docstring=""Enables or disables GPIB connection."",
            val_mapping=create_on_off_val_mapping(on_val=""true"", off_val=""false""),
        )

        self.add_parameter(
            ""gpib_address"",
            get_cmd=self._get_gpib_address,
            get_parser=int,
            set_cmd=self._set_gpib_address,
            docstring=""Sets and gets the GPIB address."",
            vals=vals.Ints(1, 30),
        )

        self.add_parameter(
            ""lan_enabled"",
            get_cmd=self._get_lan_status,
            set_cmd=self._set_lan_status,
            docstring=""Enables or disables LAN connection."",
            val_mapping=create_on_off_val_mapping(on_val=""true"", off_val=""false""),
        )

        self.connect_message()

    def reset_channel(self, val: str) -> None:
        """"""
        Resets the specified channels to factory default settings.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays, slots or channel patterns to be queried.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.reset('{val}')"")

    def open_channel(self, val: str) -> None:
        """"""
        Opens the specified channels and backplane relays.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays, slots or channel patterns to be queried.
        """"""

        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.open('{val}')"")

    def close_channel(self, val: str) -> None:
        """"""
        Closes the channels and backplane relays.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        forbidden_channels = self.get_forbidden_channels(""allslots"")
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be closed all together."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        if val in forbidden_channels.split("",""):
            warnings.warn(
                ""You are attempting to close channels that are forbidden to close."",
                UserWarning,
                2,
            )

        self._warn_on_disengaged_interlocks(val)

        self.write(f""channel.close('{val}')"")

    def _warn_on_disengaged_interlocks(self, val: str) -> None:
        """"""
        Checks if backplance channels among the given specifiers can be
        energized dependening on respective hardware interlocks being
        engaged, and raises a warning for those backplane channels which
        cannot be energized.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays.
        """"""
        states = self.get_interlock_state()
        val_specifiers = val.split("","")
        for channel in val_specifiers:
            if self._is_backplane_channel(channel):
                slot = channel[0]
                interlock_state = [
                    state for state in states if state[""slot_no""] == slot
                ][0]
                if (
                    interlock_state[""state""]
                    == ""Interlocks 1 and 2 are disengaged on the card""
                ):
                    warnings.warn(
                        f""The hardware interlocks in Slot ""
                        f'{interlock_state[""slot_no""]} are disengaged. '
                        f""The analog backplane relay {channel} ""
                        ""cannot be energized."",
                        UserWarning,
                        2,
                    )

    def _is_backplane_channel(self, channel_id: str) -> bool:
        if len(channel_id) != 4:
            raise Keithley3706AInvalidValue(f""{channel_id} is not a valid channel id"")
        if channel_id[1] == ""9"":
            return True
        return False

    def exclusive_close(self, val: str) -> None:
        """"""
        Closes the specified channels such that any presently closed channels
        opens if they are not in the specified by the parameter.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be exclusively closed."")
        if val == """":
            raise Keithley3706AInvalidValue(
                ""An empty string may cause all channels and ""
                ""associated backplane relays to open. Use ""
                '""open_channel"" parameter instead.'
            )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        self.write(f""channel.exclusiveclose('{val}')"")

    def exclusive_slot_close(self, val: str) -> None:
        """"""
        Closes the specified channels on the associated slots abd opens any
        other channels if they are not specified by the parameter.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be exclusively closed."")
        if val == """":
            raise Keithley3706AInvalidValue(""Argument cannot be an empty string."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        self.write(f""channel.exclusiveslotclose('{val}')"")

    def _get_channel_connect_rule(self) -> str:
        connect_rule = {1: ""BREAK_BEFORE_MAKE"", 2: ""MAKE_BEFORE_BREAK"", 0: ""OFF""}
        rule = self.ask(""channel.connectrule"")
        return connect_rule[int(float(rule))]

    def _set_channel_connect_rule(self, val: str) -> None:
        self.write(f""channel.connectrule = channel.{val}"")

    def _get_gpib_status(self) -> str:
        return self.ask(""comm.gpib.enable"")

    def _set_gpib_status(self, val: Union[str, bool]) -> None:
        self.write(f""comm.gpib.enable = {val}"")

    def _get_lan_status(self) -> str:
        return self.ask(""comm.lan.enable"")

    def _set_lan_status(self, val: Union[str, bool]) -> None:
        self.write(f""comm.lan.enable = {val}"")

    def _get_gpib_address(self) -> int:
        return int(float(self.ask(""gpib.address"")))

    def _set_gpib_address(self, val: int) -> None:
        self.write(f""gpib.address = {val}"")

    def get_closed_channels(self, val: str) -> Optional[list[str]]:
        """"""
        Queries for the closed channels.

        Args:
            val: A string representing the channels,
                backplane relays or channel patterns to be queried.
        """"""
        if val == """":
            raise Keithley3706AInvalidValue(""Argument cannot be an empty string."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        data = self.ask(f""channel.getclose('{val}')"")
        if data == ""nil"":
            return None
        return data.split("";"")

    def set_forbidden_channels(self, val: str) -> None:
        """"""
        Prevents the closing of specified channels and backplane
        relays.

        Args:
            val: A string representing channels and backplane relays
                to make forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.setforbidden('{val}')"")

    def get_forbidden_channels(self, val: str) -> str:
        """"""
        Returns a string that lists the channels and backplane relays
        that are forbidden to close.

        Args:
            val: A string representing the channels,
                backplane relays or channel patterns to be queried to see
                if they are forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        return self.ask(f""channel.getforbidden('{val}')"")

    def clear_forbidden_channels(self, val: str) -> None:
        """"""
        Clears the list of channels that are forbidden to close.

        Args:
            val: A string representing the channels that will no longer
                be listed as forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.clearforbidden('{val}')"")

    def set_delay(self, val: str, delay_time: float) -> None:
        """"""
        Sets an additional delay time for the specified channels.

        Args:
            val: A string representing the channels for which there will
                be an additional delay time.
            delay_time: Delay time for the specified channels in seconds.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    ""Additional delay times cannot be set for ""
                    ""analog backplane relays.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        self.write(f""channel.setdelay('{val}', {delay_time})"")

    def get_delay(self, val: str) -> list[float]:
        """"""
        Queries for the delay times.

        Args:
            val: A string representing the channels to query for
                additional delay times.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    ""Additional delay times cannot be set for ""
                    ""analog backplane relays.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        delay_times = [
            float(x) for x in self.ask(f""channel.getdelay('{val}')"").split("","")
        ]
        return delay_times

    def set_backplane(self, val: str, backplane: str) -> None:
        """"""
        Sets the analog backplane relays to use with given channels
        when they are used in switching applications.

        Args:
            val: A string representing the list of channels to change.
            backplane: A string representing the list of analog backplane
                relays to set for the channels specified.
        """"""
        states = self.get_interlock_state()
        backplanes = self.get_analog_backplane_specifiers()
        plane_specifiers = backplane.split("","")
        val_specifiers = val.split("","")
        for element in states:
            if element[""state""] == ""Interlocks 1 and 2 are disengaged on the card"":
                warnings.warn(
                    f""The hardware interlocks in Slot ""
                    f'{element[""slot_no""]} are disengaged. '
                    ""The corresponding analog backplane relays ""
                    ""cannot be energized."",
                    UserWarning,
                    2,
                )
        for elem in val_specifiers:
            if elem in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{val} is not a valid specifier. ""
                    ""The specifier cannot be analog ""
                    ""backplane relay.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        for plane in plane_specifiers:
            if plane not in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{backplane} is not a valid specifier. ""
                    ""The specifier should be analog ""
                    ""backplane relay.""
                )
        self.write(f""channel.setbackplane('{val}', '{backplane}')"")

    def get_backplane(self, val: str) -> str:
        """"""
        Lists the backplane relays that are controlled in switching
        applications for specified channels.

        Args:
            val: A string representing the channels being queried.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{val} cannot be a analog backplane relay.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        return self.ask(f""channel.getbackplane('{val}')"")

    def _get_slot_ids(self) -> list[str]:
        """"""
        Returns the slot ids of the installed cards.
        """"""
        cards = self.get_switch_cards()
        slot_id = [f""{card['slot_no']}"" for card in cards]
        return slot_id

    def _get_slot_names(self) -> list[str]:
        """"""
        Returns the names of the slots as ""slotX"",
        where ""X"" is the slot id.
        """"""
        slot_id = self._get_slot_ids()
        slot_names = [f""slot{x}"" for x in slot_id]
        return slot_names

    def _get_number_of_rows(self) -> list[int]:
        """"""
        Returns the total number of rows of the installed cards.
        """"""
        slot_id = self._get_slot_ids()
        total_number_of_rows = [
            int(float(self.ask(f""slot[{i}].rows.matrix""))) for i in slot_id
        ]
        return total_number_of_rows

    def _get_number_of_columns(self) -> list[int]:
        """"""
        Returns the total number of columns of the installed cards.
        """"""
        slot_id = self._get_slot_ids()
        total_number_of_columns = [
            int(float(self.ask(f""slot[{i}].columns.matrix""))) for i in slot_id
        ]
        return total_number_of_columns

    def _get_rows(self) -> list[list[str]]:
        """"""
        Returns the elements of each row.
        """"""
        total_number_of_rows = self._get_number_of_rows()
        row_list = []
        for item in total_number_of_rows:
            rows_in_each_slot = [str(i) for i in range(1, item + 1)]
            row_list.append(rows_in_each_slot)
        return row_list

    def _get_columns(self) -> list[list[str]]:
        """"""
        Returns the elements of each column.
        """"""
        total_number_of_columns = self._get_number_of_columns()
        column_list = []
        for item in total_number_of_columns:
            columns_in_each_slot = []
            for i in range(1, item + 1):
                if i < 10:
                    columns_in_each_slot.append(""0"" + str(i))
                else:
                    columns_in_each_slot.append(str(i))
            column_list.append(columns_in_each_slot)
        return column_list

    def _get_channel_ranges(self) -> list[str]:
        """"""
        A helper function that gets two channel names from the available
        channels list and join them via a colon to define a channel range.
        """"""
        range_list = []
        for i in self._get_slot_ids():
            channel = self.get_channels_by_slot(int(i))
            for element in itertools.combinations(channel, 2):
                range_list.append("":"".join(element))
        return range_list

    def get_channels(self) -> list[str]:
        """"""
        This function returns the name of the matrix channels.
        User can call this function to see the names of the available
        channels, in case he/she is not familiar with the naming convention.
        However, note that, this is a standalone helper function and
        the usage of channel attributes of the instrument driver does
        not depend on the functionality of this method.
        """"""
        slot_id = self._get_slot_ids()
        row_list = self._get_rows()
        column_list = self._get_columns()
        matrix_channels = []
        for i, slot in enumerate(slot_id):
            for element in itertools.product(slot, row_list[i], column_list[i]):
                matrix_channels.append("""".join(element))
        return matrix_channels

    def get_channels_by_slot(self, slot_no: int) -> list[str]:
        """"""
        Returns the channel names of a given slot.

        Args:
            slot_no: An integer value specifying the slot number.
        """"""
        slot_id = self._get_slot_ids()
        if str(slot_no) not in slot_id:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slot_id}.""
            )
        row_list = self._get_rows()
        column_list = self._get_columns()
        matrix_channels_by_slot = []
        for element in itertools.product(str(slot_no), row_list[0], column_list[0]):
            matrix_channels_by_slot.append("""".join(element))
        return matrix_channels_by_slot

    def get_analog_backplane_specifiers(self) -> list[str]:
        """"""
        Returns a list of comma separated strings representing available analog
        backplane relays. This function should not be mixed with the
        `get_backplane` method. The latter returns backplane relays which are
        associated with a channel by using `set_backplane` method.
        """"""
        backplane_common_number = ""9""
        backplane_relay_common_numbers = [""11"", ""12"", ""13"", ""14"", ""15"", ""16""]
        slot_id = self._get_slot_ids()
        analog_backplane_relays = []
        for element in itertools.product(
            slot_id, backplane_common_number, backplane_relay_common_numbers
        ):
            analog_backplane_relays.append("""".join(element))
        return analog_backplane_relays

    def _connect_or_disconnect_row_to_columns(
        self, action: str, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A private function that connects or (disconnects) given columns
        to (from) a row of a slot and opens (closes) the formed channels.
        """"""
        if action not in [""connect"", ""disconnect""]:
            raise ValueError(
                ""The action should be identified as either ""
                ""'connect' or 'disconnect'.""
            )
        slots = self._get_slot_ids()
        slot = str(slot_id)
        if slot not in slots:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slots}.""
            )
        row = str(row_id)
        columns_list = []
        for i in columns:
            if i < 10:
                columns_list.append(""0"" + str(i))
            else:
                columns_list.append(str(i))
        channels_to_connect_or_disconnect = []
        for element in itertools.product(slot, row, columns_list):
            channels_to_connect_or_disconnect.append("""".join(element))
        for channel in channels_to_connect_or_disconnect:
            if action == ""connect"":
                self.open_channel(channel)
            else:
                self.close_channel(channel)
        return channels_to_connect_or_disconnect

    def _connect_or_disconnect_column_to_rows(
        self, action: str, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A private function that connects (disconnects) given rows
        to (from) a column of a slot and opens (closes) the formed channels.
        """"""
        if action not in [""connect"", ""disconnect""]:
            raise ValueError(
                ""The action should be identified as either ""
                ""'connect' or 'disconnect'.""
            )
        slots = self._get_slot_ids()
        slot = str(slot_id)
        if slot not in slots:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slots}.""
            )
        column = []
        if column_id < 10:
            column.append(""0"" + str(column_id))
        else:
            column.append(str(column_id))
        rows_list = [str(x) for x in rows]
        channels_to_connect_or_disconnect = []
        for element in itertools.product(slot, rows_list, column):
            channels_to_connect_or_disconnect.append("""".join(element))
        for channel in channels_to_connect_or_disconnect:
            if action == ""connect"":
                self.open_channel(channel)
            else:
                self.close_channel(channel)
        return channels_to_connect_or_disconnect

    def connect_row_to_columns(
        self, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A convenient function that connects given columns to a row of a
        slot and opens the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            row_id: The specifier for the row to which the provided columns
                will be connected.
            columns: The specifiers of the columns will be connected to the
                provided row.
        """"""
        return self._connect_or_disconnect_row_to_columns(
            ""connect"", slot_id, row_id, columns
        )

    def disconnect_row_from_columns(
        self, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A convenient function that disconnects given columns to a row of a
        slot and closes the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            row_id: The specifier for the row to which the provided columns
                will be disconnected.
            columns: The specifiers of the columns will be disconnected from the
                provided row.
        """"""
        return self._connect_or_disconnect_row_to_columns(
            ""disconnect"", slot_id, row_id, columns
        )

    def connect_column_to_rows(
        self, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A convenient function that connects given rows to a column of a
        slot and opens the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            column_id: The specifier for the column to which the provided rows
                will be connected.
            rows: The specifiers of the rows will be connected to the
                provided column.
        """"""
        return self._connect_or_disconnect_column_to_rows(
            ""connect"", slot_id, column_id, rows
        )

    def disconnect_column_from_rows(
        self, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A convenient function that disconnects given rows to a column of a
        slot and closes the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            column_id: The specifier for the column to which the provided rows
                will be disconnected.
            rows: The specifiers of the rows will be disconnected from the
                provided column.
        """"""
        return self._connect_or_disconnect_column_to_rows(
            ""disconnect"", slot_id, column_id, rows
        )

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Overwrites the generic QCoDeS get IDN method. Returns
        a dictionary including the vendor, model, serial number and
        firmware version of the instrument.
        """"""
        idnstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, idnstr.split("",""))
        model = model[6:]

        idn: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return idn

    def get_switch_cards(self) -> tuple[dict[str, str], ...]:
        """"""
        Returns a list of dictionaries listing the properties of the installed
        switch cards including the slot number tha it is installed, model,
        firmware version and serial number.
        """"""
        switch_cards: list[dict[str, str]] = []
        for i in range(1, 7):
            scard = self.ask(f""slot[{i}].idn"")
            if scard != ""Empty Slot"":
                model, mtype, firmware, serial = map(str.strip, scard.split("",""))
                sdict = {
                    ""slot_no"": str(i),
                    ""model"": model,
                    ""mtype"": mtype,
                    ""firmware"": firmware,
                    ""serial"": serial,
                }
                switch_cards.append(sdict)
        return tuple(switch_cards)

    def get_available_memory(self) -> dict[str, Optional[str]]:
        """"""
        Returns the amount of memory that is currently available for
        storing scripts, configurations and channel patterns.
        """"""
        memstring = self.ask(""memory.available()"")
        system_memory, script_memory, pattern_memory, config_memory = map(
            str.strip, memstring.split("","")
        )

        memory_available: dict[str, Optional[str]] = {
            ""System Memory  (%)"": system_memory,
            ""Script Memory  (%)"": script_memory,
            ""Pattern Memory (%)"": pattern_memory,
            ""Config Memory  (%)"": config_memory,
        }
        return memory_available

    def get_interlock_state(self) -> tuple[dict[str, str], ...]:
        """"""
        A function that collects the interlock status of the installed cards.
        The channel relays can continue to operate even if the interlock
        in the corresponding slot is disengaged, one cannot perform
        measurements through the switching card, as the analog backplanes
        cannot be energized.
        """"""
        slot_id = self._get_slot_ids()
        interlock_status = {
            None: (
                ""No card is installed or the installed card does ""
                ""not support interlocks""
            ),
            0: ""Interlocks 1 and 2 are disengaged on the card"",
            1: ""Interlock 1 is engaged, interlock 2 (if it exists) is disengaged"",
            2: ""Interlock 2 in engaged, interlock 1 is disengaged"",
            3: ""Both interlock 1 and 2 are engaged"",
        }
        states: list[dict[str, str]] = []
        for i in slot_id:
            state = self.get_interlock_state_by_slot(i)
            states.append({""slot_no"": i, ""state"": interlock_status[state]})
        return tuple(states)

    def get_interlock_state_by_slot(self, slot: Union[str, int]) -> Union[int, None]:
        state = self.ask(f""slot[{int(slot)}].interlock.state"")
        if state == ""nil"":
            return None
        else:
            return int(float(state))

    def get_ip_address(self) -> str:
        """"""
        Returns the current IP address of the instrument.
        """"""
        return self.ask(""lan.status.ipaddress"")

    def reset_local_network(self) -> None:
        """"""
        Resets the local network (LAN).
        """"""
        self.write(""lan.reset()"")

    def save_setup(self, val: Optional[str] = None) -> None:
        """"""
        Saves the present setup.

        Args:
            val: An optional string representing the path and the file name
                to which the setup shall be saved on a USB flash drive. If not
                provided, the setup will be saved to the nonvolatile memory
                of the instrument, any previous saves will be overwritten.
        """"""
        if val is not None:
            self.write(f""setup.save('{val}')"")
        else:
            self.write(""setup.save()"")

    def load_setup(self, val: Union[int, str]) -> None:
        """"""
        Loads the settings from a saved setup.

        Args:
            val: An integer or a string that specifies the location of saved
                setup. If it is `0`, factory defaults load. If it is `1`,
                the saved setup from the nonvolatile memory is recalled.
                Otherwise, a string specifying the relative path to the saved
                setup on a USB drive should be passed in.
        """"""
        self.write(f""setup.recall('{val}')"")

    def _validator(self, val: str) -> bool:
        """"""
        Instrument specific validator. As the number of validation points
        are around 15k, to avoid QCoDeS parameter validation to print them all,
        we shall raise a custom exception.
        """"""
        ch = self.get_channels()
        ch_range = self._get_channel_ranges()
        slots = [""allslots"", *self._get_slot_names()]
        backplanes = self.get_analog_backplane_specifiers()
        specifier = val.split("","")
        for element in specifier:
            if element not in (*ch, *ch_range, *slots, *backplanes):
                return False
        return True

    def connect_message(
        self, idn_param: str = ""IDN"", begin_time: Optional[float] = None
    ) -> None:
        """"""
        Overwrites the generic QCoDeS instrument connect message.
        Here, additionally, we provide information about
        which slots of the system switch is occupied with what
        kind of matrix, as well.
        """"""
        idn = self.get_idn()
        cards = self.get_switch_cards()
        states = self.get_interlock_state()

        con_msg = (
            ""Connected to: {vendor} {model} SYSTEM SWITCH ""
            ""(serial:{serial}, firmware:{firmware})"".format(**idn)
        )
        print(con_msg)
        self.log.info(f""Connected to instrument: {idn}"")

        for _, item in enumerate(cards):
            card_info = (
                ""Slot {slot_no}- Model:{model}, Matrix Type:{mtype}, ""
                ""Firmware:{firmware}, Serial:{serial}"".format(**item)
            )
            print(card_info)
            self.log.info(f""Switch Cards: {item}"")

        for _, item in enumerate(states):
            state_info = ""{state} in Slot {slot_no}."".format(**item)
            print(state_info)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")
"
355,https://cdn.tmi.yokogawa.com/1/7543/files/BUGS200-01EN.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'attVoxpUxYSQ6kk0I'), ('width', 800), ('height', 366), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/C2MroL4X-CRv6kIkOC7J0w/AWov_oBX_PyMfXrrlrcxCWtWOt5ZO5MBH3OTR6oxAv50sIc50e_tRRC8Cz19qmbLw_vqRWIFCSd_r0EEFFPMsYR_AC3FRhkTLG0uDPmJkWI/YtV2f9Cs8R0eZzGZEWTPTDPTDUcafmeNA_DRqvB9_NQ'), ('filename', 'gs200_4.jpg'), ('size', 54439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/YKTaSs15SDDHnl-yYGvqKg/Kz-r0XUh8a3c24yx0s0wtrpfBaVBVB1vYdp6pKQ1ymqC2xzg67gOQWICtpOwPSWLiSOy4dNEvZWYh_x5z5ZEYA/pwJqKUb69ENXnXwoer7oQ0WKoYd8ogEv07EGQyeg-mQ'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nMNZ5Z9oxYwpcZqfvEd7aQ/oWRm5kOSs93gXy-1WgrolBAo-zlwsUsy5Mssn_uUWhld_1jS0GtBBOlD3pCE9HLeN1dF_cToDJQe8Wy4cI_AJA/o1JhEZhoZ12vFmaRT0oD8T-Y-eFkBNn5zC--OijZLMs'), ('width', 800), ('height', 366)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/b_2WCRp7i7AWOM1oX4S1mQ/ZFbWglvXA3-21j-qcJrwymqweey5wwsrzgiBwkjGCrtyyElIIoIzSCXmMRoTKmmWSzBkydbUAQrc7FTC8oZ1_w/2kCuhQG0HFMaapNBZGn24uYTZMmaigvm2gUaR7ZZSwM'), ('width', 3000), ('height', 3000)]))]))])]",318.0,Japan,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116709/Instruments/Vendor%20Logos/Yokogawa.png,"The GS200 is a low voltage/current DC source with high accuracy, high stability, and high resolution. With its excellent traceability, stability, and 5 1/2-digit resolution, the GS200 generates extremely low-noise DC voltage and current signals that are required for many applications. Additionally, the optional monitoring feature turns the GS200 into a voltage and current measuring instrument.",https://tmi.yokogawa.com/ca/solutions/products/generators-sources/source-measure-units/gs200/,Yokogawa GS 200,635.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ","Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/yokogawa/Yokogawa_GS200.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Yokogawa.html,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f7hYK50L2LFSnoG6b-tr_Q/PIUr0ysKwfdPoGdRfXB0_h09W8CmAgZMdtnCJA8oACp2MTavzvWTParMzhyBaXLJiz5MWCSGHrK48yk0-3bfUkIGkwJpKTgMFJl-ly-KdSs/005CXDzn6XFLXK7WJHb0bIHDl5oO0DB1Psmc7FeI52s'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hGhnjgmxNSTXxR7kAim1ww/RDzNoEC6FTtC3vztLVJZ89BVEbySAgthi0nJMoDuXoiPA7aSQ1BwyVF4KxdRVyBagIIEuVsDsLXMiBu6r3Uh1Q/cJfrr6UDIT1btUz5czUhSi9oYrVD5uY6Ds17A8WQ26I'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MWH_Mu8dBgIkoDhCCGXp8g/wBAiqUxh-OrvnTMRuOSgOj2_ZB8bIIvBTNIvkqZAlPLE919LoJ2grzsuGm-glI7KS2DdxaXXNwauPeW6l0ME-w/4iMOXEUzxB7fe914JbqzSV_4ze3fhXn_p7DcHRV8Ov0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/9hlyfn9bpaqywUXQIW4RCg/yrzzUFNxV8JpxT7PmwgzAOC8hLbvYZaHUSWDHq2M1BJllptYkuzR1ZdKPdT7GAvsoFmjAKbF3YDr-rjYlPL8Dg/22UwYEpKEOninguLEKbx0zEgLRmTyLKraj9xhGrJifw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782709/Instruments/Power%20Supplies/Yokogawa-GS-200/Yokogawa-GS-200.jpg,Yokogawa GS 200,Write a Python script that uses Qcodes to connect to a {Device name} Power Supplies,,,,,"from functools import partial
from typing import Any, Literal, Optional, Union

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import DelegateParameter
from qcodes.validators import Bool, Enum, Ints, Numbers

ModeType = Literal[""CURR"", ""VOLT""]


def _float_round(val: float) -> int:
    """"""
    Rounds a floating number

    Args:
        val: number to be rounded

    Returns:
        Rounded integer
    """"""
    return round(float(val))


class YokogawaGS200Exception(Exception):
    pass


class YokogawaGS200Monitor(InstrumentChannel):
    """"""
    Monitor part of the GS200. This is only enabled if it is
    installed in the GS200 (it is an optional extra).

    The units will be automatically updated as required.

    To measure:
    `GS200.measure.measure()`

    Args:
        parent (GS200)
        name: instrument name
        present
    """"""

    def __init__(self, parent: ""YokogawaGS200"", name: str, present: bool) -> None:
        super().__init__(parent, name)

        self.present = present

        # Start off with all disabled
        self._enabled = False
        self._output = False

        # Set up mode cache. These will be filled in once the parent
        # is fully initialized.
        self._range: Union[None, float] = None
        self._unit: Union[None, str] = None

        # Set up monitoring parameters
        if present:
            self.add_parameter(
                ""enabled"",
                label=""Measurement Enabled"",
                get_cmd=self.state,
                set_cmd=lambda x: self.on() if x else self.off(),
                val_mapping={
                    ""off"": 0,
                    ""on"": 1,
                },
            )

            # Note: Measurement will only run if source and
            # measurement is enabled.
            self.add_parameter(
                ""measure"",
                label=""<unset>"",
                unit=""V/I"",
                get_cmd=self._get_measurement,
                snapshot_get=False,
            )

            self.add_parameter(
                ""NPLC"",
                label=""NPLC"",
                unit=""1/LineFreq"",
                vals=Ints(1, 25),
                set_cmd="":SENS:NPLC {}"",
                set_parser=int,
                get_cmd="":SENS:NPLC?"",
                get_parser=_float_round,
            )
            self.add_parameter(
                ""delay"",
                label=""Measurement Delay"",
                unit=""ms"",
                vals=Ints(0, 999999),
                set_cmd="":SENS:DEL {}"",
                set_parser=int,
                get_cmd="":SENS:DEL?"",
                get_parser=_float_round,
            )
            self.add_parameter(
                ""trigger"",
                label=""Trigger Source"",
                set_cmd="":SENS:TRIG {}"",
                get_cmd="":SENS:TRIG?"",
                val_mapping={
                    ""READY"": ""READ"",
                    ""READ"": ""READ"",
                    ""TIMER"": ""TIM"",
                    ""TIM"": ""TIM"",
                    ""COMMUNICATE"": ""COMM"",
                    ""IMMEDIATE"": ""IMM"",
                    ""IMM"": ""IMM"",
                },
            )
            self.add_parameter(
                ""interval"",
                label=""Measurement Interval"",
                unit=""s"",
                vals=Numbers(0.1, 3600),
                set_cmd="":SENS:INT {}"",
                set_parser=float,
                get_cmd="":SENS:INT?"",
                get_parser=float,
            )

    def off(self) -> None:
        """"""Turn measurement off""""""
        self.write("":SENS 0"")
        self._enabled = False

    def on(self) -> None:
        """"""Turn measurement on""""""
        self.write("":SENS 1"")
        self._enabled = True

    def state(self) -> int:
        """"""Check measurement state""""""
        state = int(self.ask("":SENS?""))
        self._enabled = bool(state)
        return state

    def _get_measurement(self) -> float:
        if self._unit is None or self._range is None:
            raise YokogawaGS200Exception(""Measurement module not initialized."")
        if self._parent.auto_range.get() or (self._unit == ""VOLT"" and self._range < 1):
            # Measurements will not work with autorange, or when
            # range is <1V.
            self._enabled = False
            raise YokogawaGS200Exception(
                ""Measurements will not work when range is <1V""
                ""or when in auto range mode.""
            )
        if not self._output:
            raise YokogawaGS200Exception(""Output is off."")
        if not self._enabled:
            raise YokogawaGS200Exception(""Measurements are disabled."")
        # If enabled and output is on, then we can perform a measurement.
        return float(self.ask("":MEAS?""))

    def update_measurement_enabled(self, unit: ModeType, output_range: float) -> None:
        """"""
        Args:
            unit
            output_range
        """"""
        # Recheck measurement state next time we do a measurement
        self._enabled = False

        # Update units
        self._range = output_range
        self._unit = unit
        if self._unit == ""VOLT"":
            self.measure.label = ""Source Current""
            self.measure.unit = ""I""
        else:
            self.measure.label = ""Source Voltage""
            self.measure.unit = ""V""


class YokogawaGS200Program(InstrumentChannel):
    """""" """"""

    def __init__(self, parent: ""YokogawaGS200"", name: str) -> None:
        super().__init__(parent, name)
        self._repeat = 1
        self._file_name = None

        self.add_parameter(
            ""interval"",
            label=""the program interval time"",
            unit=""s"",
            vals=Numbers(0.1, 3600.0),
            get_cmd="":PROG:INT?"",
            set_cmd="":PROG:INT {}"",
        )

        self.add_parameter(
            ""slope"",
            label=""the program slope time"",
            unit=""s"",
            vals=Numbers(0.1, 3600.0),
            get_cmd="":PROG:SLOP?"",
            set_cmd="":PROG:SLOP {}"",
        )

        self.add_parameter(
            ""trigger"",
            label=""the program trigger"",
            get_cmd="":PROG:TRIG?"",
            set_cmd="":PROG:TRIG {}"",
            vals=Enum(""normal"", ""mend""),
        )

        self.add_parameter(
            ""save"",
            set_cmd="":PROG:SAVE '{}'"",
            docstring=""save the program to the system memory "" ""(.csv file)"",
        )

        self.add_parameter(
            ""load"",
            get_cmd="":PROG:LOAD?"",
            set_cmd="":PROG:LOAD '{}'"",
            docstring=""load the program (.csv file) from the "" ""system memory"",
        )

        self.add_parameter(
            ""repeat"",
            label=""program execution repetition"",
            get_cmd="":PROG:REP?"",
            set_cmd="":PROG:REP {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        self.add_parameter(
            ""count"",
            label=""step of the current program"",
            get_cmd="":PROG:COUN?"",
            set_cmd="":PROG:COUN {}"",
            vals=Ints(1, 10000),
        )

        self.add_function(
            ""start"", call_cmd="":PROG:EDIT:STAR"", docstring=""start program editing""
        )
        self.add_function(
            ""end"", call_cmd="":PROG:EDIT:END"", docstring=""end program editing""
        )
        self.add_function(
            ""run"",
            call_cmd="":PROG:RUN"",
            docstring=""run the program"",
        )


class YokogawaGS200(VisaInstrument):
    """"""
    QCoDeS driver for the Yokogawa GS200 voltage and current source.

    Args:
      name: What this instrument is called locally.
      address: The GPIB or USB address of this instrument
      kwargs: kwargs to be passed to VisaInstrument class
      terminator: read terminator for reads/writes to the instrument.
    """"""

    def __init__(
        self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any
    ) -> None:
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""output"",
            label=""Output State"",
            get_cmd=self.state,
            set_cmd=lambda x: self.on() if x else self.off(),
            val_mapping={
                ""off"": 0,
                ""on"": 1,
            },
        )

        self.add_parameter(
            ""source_mode"",
            label=""Source Mode"",
            get_cmd="":SOUR:FUNC?"",
            set_cmd=self._set_source_mode,
            vals=Enum(""VOLT"", ""CURR""),
        )

        # We need to get the source_mode value here as we cannot rely on the
        # default value that may have been changed before we connect to the
        # instrument (in a previous session or via the frontpanel).
        self.source_mode()

        self.add_parameter(
            ""voltage_range"",
            label=""Voltage Source Range"",
            unit=""V"",
            get_cmd=partial(self._get_range, ""VOLT""),
            set_cmd=partial(self._set_range, ""VOLT""),
            vals=Enum(10e-3, 100e-3, 1e0, 10e0, 30e0),
            snapshot_exclude=self.source_mode() == ""CURR"",
        )

        self.add_parameter(
            ""current_range"",
            label=""Current Source Range"",
            unit=""I"",
            get_cmd=partial(self._get_range, ""CURR""),
            set_cmd=partial(self._set_range, ""CURR""),
            vals=Enum(1e-3, 10e-3, 100e-3, 200e-3),
            snapshot_exclude=self.source_mode() == ""VOLT"",
        )

        self.add_parameter(""range"", parameter_class=DelegateParameter, source=None)

        # The instrument does not support auto range. The parameter
        # auto_range is introduced to add this capability with
        # setting the initial state at False mode.
        self.add_parameter(
            ""auto_range"",
            label=""Auto Range"",
            set_cmd=self._set_auto_range,
            get_cmd=None,
            initial_cache_value=False,
            vals=Bool(),
        )

        self.add_parameter(
            ""voltage"",
            label=""Voltage"",
            unit=""V"",
            set_cmd=partial(self._get_set_output, ""VOLT""),
            get_cmd=partial(self._get_set_output, ""VOLT""),
            snapshot_exclude=self.source_mode() == ""CURR"",
        )

        self.add_parameter(
            ""current"",
            label=""Current"",
            unit=""I"",
            set_cmd=partial(self._get_set_output, ""CURR""),
            get_cmd=partial(self._get_set_output, ""CURR""),
            snapshot_exclude=self.source_mode() == ""VOLT"",
        )

        self.add_parameter(
            ""output_level"", parameter_class=DelegateParameter, source=None
        )

        # We need to pass the source parameter for delegate parameters
        # (range and output_level) here according to the present
        # source_mode.
        if self.source_mode() == ""VOLT"":
            self.range.source = self.voltage_range
            self.output_level.source = self.voltage
        else:
            self.range.source = self.current_range
            self.output_level.source = self.current

        self.add_parameter(
            ""voltage_limit"",
            label=""Voltage Protection Limit"",
            unit=""V"",
            vals=Ints(1, 30),
            get_cmd="":SOUR:PROT:VOLT?"",
            set_cmd="":SOUR:PROT:VOLT {}"",
            get_parser=_float_round,
            set_parser=int,
        )

        self.add_parameter(
            ""current_limit"",
            label=""Current Protection Limit"",
            unit=""I"",
            vals=Numbers(1e-3, 200e-3),
            get_cmd="":SOUR:PROT:CURR?"",
            set_cmd="":SOUR:PROT:CURR {:.3f}"",
            get_parser=float,
            set_parser=float,
        )

        self.add_parameter(
            ""four_wire"",
            label=""Four Wire Sensing"",
            get_cmd="":SENS:REM?"",
            set_cmd="":SENS:REM {}"",
            val_mapping={
                ""off"": 0,
                ""on"": 1,
            },
        )

        # Note: The guard feature can be used to remove common mode noise.
        # Read the manual to see if you would like to use it
        self.add_parameter(
            ""guard"",
            label=""Guard Terminal"",
            get_cmd="":SENS:GUAR?"",
            set_cmd="":SENS:GUAR {}"",
            val_mapping={""off"": 0, ""on"": 1},
        )

        # Return measured line frequency
        self.add_parameter(
            ""line_freq"",
            label=""Line Frequency"",
            unit=""Hz"",
            get_cmd=""SYST:LFR?"",
            get_parser=int,
        )

        # Check if monitor is present, and if so enable measurement
        monitor_present = ""/MON"" in self.ask(""*OPT?"")
        measure = YokogawaGS200Monitor(self, ""measure"", monitor_present)
        self.add_submodule(""measure"", measure)

        # Reset function
        self.add_function(""reset"", call_cmd=""*RST"")

        self.add_submodule(""program"", YokogawaGS200Program(self, ""program""))

        self.add_parameter(
            ""BNC_out"",
            label=""BNC trigger out"",
            get_cmd="":ROUT:BNCO?"",
            set_cmd="":ROUT:BNCO {}"",
            vals=Enum(""trigger"", ""output"", ""ready""),
            docstring=""Sets or queries the output BNC signal"",
        )

        self.add_parameter(
            ""BNC_in"",
            label=""BNC trigger in"",
            get_cmd="":ROUT:BNCI?"",
            set_cmd="":ROUT:BNCI {}"",
            vals=Enum(""trigger"", ""output""),
            docstring=""Sets or queries the input BNC signal"",
        )

        self.add_parameter(
            ""system_errors"",
            get_cmd="":SYSTem:ERRor?"",
            docstring=""returns the oldest unread error message from the event ""
            ""log and removes it from the log."",
        )

        self.connect_message()

    def on(self) -> None:
        """"""Turn output on""""""
        self.write(""OUTPUT 1"")
        self.measure._output = True

    def off(self) -> None:
        """"""Turn output off""""""
        self.write(""OUTPUT 0"")
        self.measure._output = False

    def state(self) -> int:
        """"""Check state""""""
        state = int(self.ask(""OUTPUT?""))
        self.measure._output = bool(state)
        return state

    def ramp_voltage(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the voltage from the current level to the specified output.

        Args:
            ramp_to: The ramp target in Volt
            step: The ramp steps in Volt
            delay: The time between finishing one step and
                starting another in seconds.
        """"""
        self._assert_mode(""VOLT"")
        self._ramp_source(ramp_to, step, delay)

    def ramp_current(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the current from the current level to the specified output.

        Args:
            ramp_to: The ramp target in Ampere
            step: The ramp steps in Ampere
            delay: The time between finishing one step and starting
                another in seconds.
        """"""
        self._assert_mode(""CURR"")
        self._ramp_source(ramp_to, step, delay)

    def _ramp_source(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the output from the current level to the specified output

        Args:
            ramp_to: The ramp target in volts/amps
            step: The ramp steps in volts/ampere
            delay: The time between finishing one step and
                starting another in seconds.
        """"""
        saved_step = self.output_level.step
        saved_inter_delay = self.output_level.inter_delay

        self.output_level.step = step
        self.output_level.inter_delay = delay
        self.output_level(ramp_to)

        self.output_level.step = saved_step
        self.output_level.inter_delay = saved_inter_delay

    def _get_set_output(
        self, mode: ModeType, output_level: Optional[float] = None
    ) -> Optional[float]:
        """"""
        Get or set the output level.

        Args:
            mode: ""CURR"" or ""VOLT""
            output_level: If missing, we assume that we are getting the
                current level. Else we are setting it
        """"""
        self._assert_mode(mode)
        if output_level is not None:
            self._set_output(output_level)
            return None
        return float(self.ask("":SOUR:LEV?""))

    def _set_output(self, output_level: float) -> None:
        """"""
        Set the output of the instrument.

        Args:
            output_level: output level in Volt or Ampere, depending
                on the current mode.
        """"""
        auto_enabled = self.auto_range()

        if not auto_enabled:
            self_range = self.range()
            if self_range is None:
                raise RuntimeError(
                    ""Trying to set output but not in auto mode and range is unknown.""
                )
        else:
            mode = self.source_mode.get_latest()
            if mode == ""CURR"":
                self_range = 200e-3
            else:
                self_range = 30.0

        # Check we are not trying to set an out of range value
        if self.range() is None or abs(output_level) > abs(self_range):
            # Check that the range hasn't changed
            if not auto_enabled:
                self_range = self.range.get_latest()
                if self_range is None:
                    raise RuntimeError(
                        ""Trying to set output but not in""
                        "" auto mode and range is unknown.""
                    )
            # If we are still out of range, raise a value error
            if abs(output_level) > abs(self_range):
                raise ValueError(
                    ""Desired output level not in range""
                    "" [-{self_range:.3}, {self_range:.3}]"".format(self_range=self_range)
                )

        if auto_enabled:
            auto_str = "":AUTO""
        else:
            auto_str = """"
        cmd_str = f"":SOUR:LEV{auto_str} {output_level:.5e}""
        self.write(cmd_str)

    def _update_measurement_module(
        self,
        source_mode: Optional[ModeType] = None,
        source_range: Optional[float] = None,
    ) -> None:
        """"""
        Update validators/units as source mode/range changes.

        Args:
            source_mode: ""CURR"" or ""VOLT""
            source_range
        """"""
        if not self.measure.present:
            return

        if source_mode is None:
            source_mode = self.source_mode.get_latest()
        # Get source range if auto-range is off
        if source_range is None and not self.auto_range():
            source_range = self.range()

        self.measure.update_measurement_enabled(source_mode, source_range)

    def _set_auto_range(self, val: bool) -> None:
        """"""
        Enable/disable auto range.

        Args:
            val: auto range on or off
        """"""
        self._auto_range = val
        # Disable measurement if auto range is on
        if self.measure.present:
            # Disable the measurement module if auto range is enabled,
            # because the measurement does not work in the
            # 10mV/100mV ranges.
            self.measure._enabled &= not val

    def _assert_mode(self, mode: ModeType) -> None:
        """"""
        Assert that we are in the correct mode to perform an operation.

        Args:
            mode: ""CURR"" or ""VOLT""
        """"""
        if self.source_mode.get_latest() != mode:
            raise ValueError(
                f""Cannot get/set {mode} settings while in {self.source_mode.get_latest()} mode""
            )

    def _set_source_mode(self, mode: ModeType) -> None:
        """"""
        Set output mode and change delegate parameters' source accordingly.
        Also, exclude/include the parameters from snapshot depending on the
        mode. The instrument does not support 'current', 'current_range'
        parameters in ""VOLT"" mode and 'voltage', 'voltage_range' parameters
        in ""CURR"" mode.

        Args:
            mode: ""CURR"" or ""VOLT""

        """"""
        if self.output() == ""on"":
            raise YokogawaGS200Exception(""Cannot switch mode while source is on"")

        if mode == ""VOLT"":
            self.range.source = self.voltage_range
            self.output_level.source = self.voltage
            self.voltage_range.snapshot_exclude = False
            self.voltage.snapshot_exclude = False
            self.current_range.snapshot_exclude = True
            self.current.snapshot_exclude = True
        else:
            self.range.source = self.current_range
            self.output_level.source = self.current
            self.voltage_range.snapshot_exclude = True
            self.voltage.snapshot_exclude = True
            self.current_range.snapshot_exclude = False
            self.current.snapshot_exclude = False

        self.write(f""SOUR:FUNC {mode}"")
        # We set the cache here since `_update_measurement_module`
        # needs the current value which would otherwise only be set
        # after this method exits
        self.source_mode.cache.set(mode)
        # Update the measurement mode
        self._update_measurement_module(source_mode=mode)

    def _set_range(self, mode: ModeType, output_range: float) -> None:
        """"""
        Update range

        Args:
            mode: ""CURR"" or ""VOLT""
            output_range: Range to set. For voltage, we have the ranges [10e-3,
                100e-3, 1e0, 10e0, 30e0]. For current, we have the ranges [1e-3,
                10e-3, 100e-3, 200e-3]. If auto_range = False, then setting the
                output can only happen if the set value is smaller than the
                present range.
        """"""
        self._assert_mode(mode)
        output_range = float(output_range)
        self._update_measurement_module(source_mode=mode, source_range=output_range)
        self.write(f"":SOUR:RANG {output_range}"")

    def _get_range(self, mode: ModeType) -> float:
        """"""
        Query the present range.

        Args:
            mode: ""CURR"" or ""VOLT""

        Returns:
            range: For voltage, we have the ranges [10e-3, 100e-3, 1e0, 10e0,
                30e0]. For current, we have the ranges [1e-3, 10e-3, 100e-3,
                200e-3]. If auto_range = False, then setting the output can only
                happen if the set value is smaller than the present range.
        """"""
        self._assert_mode(mode)
        return float(self.ask("":SOUR:RANG?""))
"
356,https://www.testequipmenthq.com/datasheets/TEKTRONIX-TPS2012-Datasheet.pdf,https://en.wikipedia.org/wiki/Oscilloscope,"[OrderedDict([('id', 'attATDSb8uCvGo2o8'), ('width', 500), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1UOV-gFcnXUjqcVr3R2amg/dvUaL2793aixS7yxq5zfA_PInXXCC8LaRc4KGOTPDq9jcGiWOO_fXe0FG30SFypBWkGiwk2kkUl4n8Tz8h_RhE_iNGeqNlk_04K8YNVVxe4/ZNtpUprpf6xEBQ2WNpLSUgf9J2J14QP97-4XIHwPeaE'), ('filename', 'tektro_tps2012.jpg'), ('size', 30645), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/foAASx5UCHkN2ys1kBhTBg/5_JHwfrMXjGPnhlmYqO5cn0EB2RMQ1_wNbs_cFGaekL-KcH-4rrWjm5YrRgteJTw0lPbESY8vsU32AuyCeVLBA/y4F5BSwDP4ZI127o6g5S4jVGweKxGwUnzW_yViZjm6c'), ('width', 71), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZWy-zo6jnE2FxctfqkTSnQ/_iYjNUTUOoJVOTJMf-Pk65QMw41j9t9DBR4X0fUy3vs8rxi6mwCgRgruKRTa8tUZVxfXetfkUxawECXTGRkKHw/bIOf7562rRdz1-zW9MhT2BWskqbKceqEdzIYQQNl15I'), ('width', 500), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pbCN8AanyjY84ugVqB9vjw/9aChrgDpgwuMT5wMDBHAQaxIqTPgU45UB2dqL7JgSuuSStBv07RQc1guCncK4_KMDPJuiBZfLLVGtwEURiQuyQ/WA0aTl5HHZXsHM1uDvURvufD0vKIx4Tu-kQDSYJ420s'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The TPS2000 Series easily addresses the unique challenges that plague industrial power designers and technicians. You regularly confront high voltages and currents, and must often make potentially hazardous floating measurements. With the TPS2000 Series' power bundle (TPS2PBND), which includes the P5120 passive, high-voltage probes and TPS2PWR1 power measurement and analysis software, you can use a single instrument to make a broad range of measurements.

Easily evaluate these high voltages and currents, or debug power electronics control circuits, with differential voltages up to 600 VRMS CAT II (or 300 VRMS CAT III) floating. Accurately measure three-phase power and circuits with different low levels or ground references.

Quickly perform a broad range of power-specific measurements, such as switching loss, harmonic distortion measurements to the 50th harmonic, and dv/dt and di/dt cursor measurements.",https://www.valuetronics.com/product/tps2012-tektronix-digital-oscilloscope-used,TPS 2012,560.0,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/TPS2012.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixTPS2012,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782739/Instruments/Oscilloscopes/TSP2012/TSP2012.jpg,TSP2012,Write a Python script that uses Qcodes to connect to a TSP2012 Oscilloscopes,4540.0,,True,"The price is taken from Farnell, second hand","import binascii
import logging
from functools import partial
from typing import Any

import numpy as np
from pyvisa.errors import VisaIOError
from typing_extensions import TypedDict

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, ParamRawDataType

log = logging.getLogger(__name__)


class TraceNotReady(Exception):
    pass


class OutputDict(TypedDict):
    no_of_bytes: int
    no_of_bits: int
    encoding: str
    binary_format: str
    byte_order: str
    no_of_points: int
    waveform_ID: str
    point_format: str
    x_incr: float
    x_zero: float
    x_unit: str
    y_multiplier: float
    y_zero: float
    y_offset: float
    y_unit: str


class ScopeArray(ArrayParameter):
    def __init__(
        self,
        name: str,
        instrument: ""TektronixTPS2012Channel"",
        channel: int,
        **kwargs: Any,
    ):
        super().__init__(
            name=name,
            shape=(2500,),
            label=""Voltage"",
            unit=""V "",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""holds an array from scope"",
            instrument=instrument,
            **kwargs,
        )
        self.channel = channel

    def calc_set_points(self) -> tuple[np.ndarray, int]:
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        message = self.instrument.ask('WFMPre?')
        preamble = self._preambleparser(message)
        xstart = preamble['x_zero']
        xinc = preamble['x_incr']
        no_of_points = preamble['no_of_points']
        xdata = np.linspace(xstart, no_of_points * xinc + xstart, no_of_points)
        return xdata, no_of_points

    def prepare_curvedata(self) -> None:
        """"""
        Prepare the scope for returning curve data
        """"""
        # To calculate set points, we must have the full preamble
        # For the instrument to return the full preamble, the channel
        # in question must be displayed
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        assert isinstance(self.root_instrument, TektronixTPS2012)
        self.instrument.parameters['state'].set('ON')
        self.root_instrument.data_source(f'CH{self.channel}')

        xdata, no_of_points = self.calc_set_points()
        self.setpoints = (tuple(xdata), )
        self.shape = (no_of_points, )

        self.root_instrument.trace_ready = True

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.root_instrument, TektronixTPS2012)
        if not self.root_instrument.trace_ready:
            raise TraceNotReady('Please run prepare_curvedata to prepare '
                                'the scope for giving a trace.')
        message = self._curveasker(self.channel)
        _, ydata, _ = self._curveparameterparser(message)
        # Due to the limitations in the current api the below solution
        # to change setpoints does nothing because the setpoints have
        # already been copied to the dataset when get is called.

        # self.setpoints = (tuple(xdata),)
        # self.shape = (npoints,)
        return ydata

    def _curveasker(self, ch: int) -> str:
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        self.instrument.write(f'DATa:SOURce CH{ch}')
        message = self.instrument.ask('WAVFrm?')
        self.instrument.write('*WAI')
        return message

    @staticmethod
    def _binaryparser(curve: str) -> np.ndarray:
        """"""
        Helper function for parsing the curve data

        Args:
            curve: the return value of 'CURVe?' when
              DATa:ENCdg is set to RPBinary.
              Note: The header and final newline character
              must be removed.

        Returns:
            The curve in units where the digitisation range
            is mapped to (-32768, 32767).
        """"""
        # TODO: Add support for data width = 1 mode?
        output = np.zeros(int(len(curve)/2))  # data width 2
        # output = np.zeros(int(len(curve)))  # data width 1
        for ii, _ in enumerate(output):
            # casting FTWs
            temp_1 = curve[2*ii:2*ii+1].encode('latin-1')  # data width 2
            temp_2 = binascii.b2a_hex(temp_1)
            temp_3 = (int(temp_2, 16)-128)*256  # data width 2 (1)
            output[ii] = temp_3
        return output

    @staticmethod
    def _preambleparser(response: str) -> OutputDict:
        """"""
        Parser function for the curve preamble

        Args:
            response: The response of WFMPre?

        Returns:
            A dictionary containing the following keys:
              no_of_bytes, no_of_bits, encoding, binary_format,
              byte_order, no_of_points, waveform_ID, point_format,
              x_incr, x_zero, x_unit, y_multiplier, y_zero, y_offset, y_unit
        """"""
        response_list = response.split(';')

        outdict: OutputDict = {
            'no_of_bytes': int(response_list[0]),
            'no_of_bits': int(response_list[1]),
            'encoding':  response_list[2],
            'binary_format': response_list[3],
            'byte_order': response_list[4],
            'no_of_points': int(response_list[5]),
            'waveform_ID':  response_list[6],
            'point_format': response_list[7],
            'x_incr': float(response_list[8]),
            # outdict['point_offset'] = response_list[9]  # Always zero
            'x_zero': float(response_list[10]),
            'x_unit': response_list[11],
            'y_multiplier': float(response_list[12]),
            'y_zero': float(response_list[13]),
            'y_offset': float(response_list[14]),
            'y_unit': response_list[15]
        }
        return outdict

    def _curveparameterparser(
        self, waveform: str
    ) -> tuple[np.ndarray, np.ndarray, int]:
        """"""
        The parser for the curve parameter. Note that WAVFrm? is equivalent
        to WFMPre?; CURVe?

        Args:
            waveform: The return value of WAVFrm?

        Returns:
            Two numpy arrays with the time axis in units
            of s and curve values in units of V; (time, voltages) and
            the number of points as an integer
        """"""
        fulldata = waveform.split(';')
        preamblestr = ';'.join(fulldata[:16])
        curvestr = ';'.join(fulldata[16:])

        preamble = self._preambleparser(preamblestr)
        # the raw curve data starts with a header containing the char #
        # followed by on digit giving the number of digits in the len of the
        # array in bytes
        # and the length of the array. I.e. the string #45000 is 5000 bytes
        # represented by 4 digits.
        total_number_of_bytes = preamble['no_of_bytes']*preamble['no_of_points']
        raw_data_offset = 2 + len(str(total_number_of_bytes))
        curvestr = curvestr[raw_data_offset:-1]
        rawcurve = self._binaryparser(curvestr)

        yoff = preamble['y_offset']
        yoff -= 2**15  # data width 2
        ymult = preamble['y_multiplier']
        ydata = ymult*(rawcurve-yoff)
        assert len(ydata) == preamble['no_of_points']
        xstart = preamble['x_zero']
        xinc = preamble['x_incr']
        xdata = np.linspace(xstart, len(ydata)*xinc+xstart, len(ydata))
        return xdata, ydata, preamble['no_of_points']


class TektronixTPS2012Channel(InstrumentChannel):
    def __init__(
        self, parent: ""TektronixTPS2012"", name: str, channel: int, **kwargs: Any
    ):
        super().__init__(parent, name, **kwargs)

        self.add_parameter('scale',
                           label=f'Channel {channel} Scale',
                           unit='V/div',
                           get_cmd=f'CH{channel}:SCAle?',
                           set_cmd='CH{}:SCAle {}'.format(channel, '{}'),
                           get_parser=float
                           )
        self.add_parameter('position',
                           label=f'Channel {channel} Position',
                           unit='div',
                           get_cmd=f'CH{channel}:POSition?',
                           set_cmd='CH{}:POSition {}'.format(channel, '{}'),
                           get_parser=float
                           )
        self.add_parameter('curvedata',
                           channel=channel,
                           parameter_class=ScopeArray,
                           )
        self.add_parameter('state',
                           label=f'Channel {channel} display state',
                           set_cmd='SELect:CH{} {}'.format(channel, '{}'),
                           get_cmd=partial(self._get_state, channel),
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

    def _get_state(self, ch: int) -> int:
        """"""
        get_cmd for the chX_state parameter
        """"""
        # 'SELect?' returns a ';'-separated string of 0s and 1s
        # denoting state display state of ch1, ch2, ?, ?, ?
        # (maybe ch1, ch2, math, ref1, ref2 ..?)
        selected = list(map(int, self.ask('SELect?').split(';')))
        state = selected[ch - 1]
        return state


TPS2012Channel = TektronixTPS2012Channel


class TektronixTPS2012(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Tektronix 2012B oscilloscope.
    """"""

    def __init__(self, name: str, address: str,
                 timeout: float = 20, **kwargs: Any):
        """"""
        Initialises the TPS2012.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: visa timeout, in secs. long default (180)
              to accommodate large waveforms
        """"""

        super().__init__(name, address, timeout=timeout, **kwargs)
        self.connect_message()

        # Scope trace boolean
        self.trace_ready = False

        # functions

        self.add_function('force_trigger',
                          call_cmd='TRIGger FORce',
                          docstring='Force trigger event')
        self.add_function('run',
                          call_cmd='ACQuire:STATE RUN',
                          docstring='Start acquisition')
        self.add_function('stop',
                          call_cmd='ACQuire:STATE STOP',
                          docstring='Stop acquisition')

        # general parameters
        self.add_parameter('trigger_type',
                           label='Type of the trigger',
                           get_cmd='TRIGger:MAIn:TYPe?',
                           set_cmd='TRIGger:MAIn:TYPe {}',
                           vals=vals.Enum('EDGE', 'VIDEO', 'PULSE')
                           )
        self.add_parameter('trigger_source',
                           label='Source for the trigger',
                           get_cmd='TRIGger:MAIn:EDGE:SOURce?',
                           set_cmd='TRIGger:MAIn:EDGE:SOURce {}',
                           vals=vals.Enum('CH1', 'CH2')
                           )
        self.add_parameter('trigger_edge_slope',
                           label='Slope for edge trigger',
                           get_cmd='TRIGger:MAIn:EDGE:SLOpe?',
                           set_cmd='TRIGger:MAIn:EDGE:SLOpe {}',
                           vals=vals.Enum('FALL', 'RISE')
                           )
        self.add_parameter('trigger_level',
                           label='Trigger level',
                           unit='V',
                           get_cmd='TRIGger:MAIn:LEVel?',
                           set_cmd='TRIGger:MAIn:LEVel {}',
                           vals=vals.Numbers()
                           )
        self.add_parameter('data_source',
                           label='Data source',
                           get_cmd='DATa:SOUrce?',
                           set_cmd='DATa:SOURce {}',
                           vals=vals.Enum('CH1', 'CH2')
                           )
        self.add_parameter('horizontal_scale',
                           label='Horizontal scale',
                           unit='s',
                           get_cmd='HORizontal:SCAle?',
                           set_cmd=self._set_timescale,
                           get_parser=float,
                           vals=vals.Enum(5e-9, 10e-9, 25e-9, 50e-9, 100e-9,
                                          250e-9, 500e-9, 1e-6, 2.5e-6, 5e-6,
                                          10e-6, 25e-6, 50e-6, 100e-6, 250e-6,
                                          500e-6, 1e-3, 2.5e-3, 5e-3, 10e-3,
                                          25e-3, 50e-3, 100e-3, 250e-3, 500e-3,
                                          1, 2.5, 5, 10, 25, 50))

        # channel-specific parameters
        channels = ChannelList(
            self, ""ScopeChannels"", TektronixTPS2012Channel, snapshotable=False
        )
        for ch_num in range(1, 3):
            ch_name = f""ch{ch_num}""
            channel = TektronixTPS2012Channel(self, ch_name, ch_num)
            channels.append(channel)
            self.add_submodule(ch_name, channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        # Necessary settings for parsing the binary curve data
        self.visa_handle.encoding = 'latin-1'
        log.info('Set VISA encoding to latin-1')
        self.write('DATa:ENCdg RPBinary')
        log.info('Set TPS2012 data encoding to RPBinary' +
                 ' (Positive Integer Binary)')
        self.write('DATa:WIDTh 2')
        log.info('Set TPS2012 data width to 2')
        # Note: using data width 2 has been tested to not add
        # significantly to transfer times. The maximal length
        # of an array in one transfer is 2500 points.

    def _set_timescale(self, scale: float) -> None:
        """"""
        set_cmd for the horizontal_scale
        """"""
        self.trace_ready = False
        self.write(f'HORizontal:SCAle {scale}')

    ##################################################
    # METHODS FOR THE USER                           #
    ##################################################

    def clear_message_queue(self, verbose: bool = False) -> None:
        """"""
        Function to clear up (flush) the VISA message queue of the AWG
        instrument. Reads all messages in the queue.

        Args:
            verbose: If True, the read messages are printed.
                Default: False.
        """"""
        original_timeout = self.visa_handle.timeout
        self.visa_handle.timeout = 1000  # 1 second as VISA counts in ms
        gotexception = False
        while not gotexception:
            try:
                message = self.visa_handle.read()
                if verbose:
                    print(message)
            except VisaIOError:
                gotexception = True
        self.visa_handle.timeout = original_timeout


class TPS2012(TektronixTPS2012):
    """"""
    Deprecated alias for ``TektronixTPS2012``
    """"""

    pass
"
359,https://www.artisantg.com/TestMeasurement/56129-1/DL-Instruments-Ithaco-1211-Current-Preamplifier#,https://en.wikipedia.org/wiki/Preamplifier,"[OrderedDict([('id', 'attfOb3CrJ0Ln0FFn'), ('width', 600), ('height', 481), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3Mr5ryiNQiYoxecWFQqXQ/LZYCePmOAQHj6tK_rY8PiozvXMvociQbcB7VBL9qajQSengtEPxf_Gq2L8qTJ_OBB1DXbAUzYiJ0NlLhgPH-mI3SHIR514WjNEAjKQDQZCG6auMVHGbVqOXPBAKNL5FRcg9fjW8r9nIETJAObxQTMw/nGeTPcw6OES5MgnuugzaWidwSqgN3I59aKbi9g1JvtE'), ('filename', 'DL_Instruments_Ithaco_1211_View1_201942143119.jpg'), ('size', 64251), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wzz6m82KZ-aXl8CLkUQ16w/RWPkQ1igaZus4zWq-Oc_76Z7rj-RUmr0YarmyG5ByMriSeiCZRE2t5ztHJ8xsSpMW1hoiy2tEuhN5qA8CG6VaA/m1QobgI_4mK7gVuZb6FFJ1lgq5fAECYG56FS8sNFYrs'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4P01Ubq0G1Fwephf3KKE8A/cahG7lhmIR3Pb9arUbC7haCt1fOIZGuWdopGrLcGdzNurkD8GFc_Ry3qH2U_H37JnWAwYy-r_hYnq5ARP5p-9w/apZttX5MtpzdXFgbH3GNcV-sLPRFaFg8ydKntDfdHXQ'), ('width', 600), ('height', 481)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/wHFt9LvTnhVZNFXkmQGVUQ/jlEUHGln2aaEv6sA2t4LQ-HkyYil-YAlVI-rtj0k1Z2KkkN1Ue43ZZSGY9LWYJbgOCvK5pn0ABSjyhrYzT5brA/YD2Pzi7yArMRV7a9FQqFiltgHKC8V8kxgTiYleFCaoc'), ('width', 3000), ('height', 3000)]))]))])]",17.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116687/Instruments/Vendor%20Logos/Ithaco.png,The Ithaco 1211 Current Preamplifier measures current with full scale sensitivity ranging from 10-2 to 10-12 amperes,https://www.artisantg.com/TestMeasurement/56129-1/DL-Instruments-Ithaco-1211-Current-Preamplifier,Ithaco 1211,199.0,['Lockin Amplifiers'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker.","Artisan Technology Group ® is a team of top-talent engineers and customer service specialists. We serve organizations that need to maintain and extend the life of their critical industrial, commercial, and military systems beyond obsolescence.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/ithaco/Ithaco_1211.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Ithaco.html#qcodes.instrument_drivers.ithaco.Ithaco1211,Ithaco,"[OrderedDict([('id', 'attO5MSSBstxunS3U'), ('width', 488), ('height', 103), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ipp16zN8I8pyd8_6yzOa8g/wzdnM4tXHOITI6CSY0q7f6R_Or5h_Wn4upXRcB2jW3I-FYrZmJzA3hO6uuQIAnwqE9ezPXEP3NTNtYdpZiLhU865S0xGcYqqJBRVmwARwAc/LIMy1j1ijO6tWqQJg3bkXJ1LemaaZYrb8Rc1-9LwMJI'), ('filename', 'téléchargement (1).jpeg'), ('size', 8832), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/VmUa-gR_T7CQaDEx6vfxjw/_d3MkTttjVEd9K7KSOw3b5RIMYXmMSWYqGI27kOArmKX65x-wQ5qRyYuwBpvTj48YrPMyNuB5lcw83udbrzflA/Pdh9IQJmruWs2zkIPb44PC8QcD1s_WxABoEJzXhWVvo'), ('width', 171), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/szYl3lvHjKmw6U1ygSn4Nw/X-XZ95JiOQH6oDlaV37e-jv3Qyc6rOAJ99dMN4Y2L1PCwR9r7VT4Yj3T_ClzuMNq_JNTRTpJCOMGqf6OFnPVyw/zgccBpm9QaAg8etDCHug0XShZthAqwbvnbdA-W2usWM'), ('width', 488), ('height', 103)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/hiWNtOxdHk5h7Bv7W2rFsg/Bk8kLUH5JtD8zTWrCTY_eiZQhbuLojsAMfv7AG2pnqnvyhG1JxohABSrQ9JiZV25aEJZ6C9P_7t9KDPXm3rtNw/aAOxXkCDwbQHHU1d2Yil6gTlSERxy49FgOC_IKzpICU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782742/Instruments/Lockin%20Amplifiers/Ithaco-1211/Ithaco-1211.jpg,Ithaco 1211,Write a Python script that uses Qcodes to connect to a Ithaco 1211 Lockin Amplifiers,200.0,,,,"from typing import Any, Optional

from qcodes.instrument import Instrument
from qcodes.parameters import MultiParameter, Parameter, ParamRawDataType
from qcodes.validators import Bool, Enum


class CurrentParameter(MultiParameter):
    """"""
    Voltage measurement via an Ithaco preamp and converting volt to current.

    To be used when you feed a current into the Ithaco, send the Ithaco's
    output voltage to a lockin or other voltage amplifier, and you have
    the voltage reading from that amplifier as a qcodes parameter.

    ``CurrentParameter.get()`` returns ``(volt_raw, curr)``

    Args:
        measured_param: a gettable parameter returning the
            voltage read from the Ithaco output.

        c_amp_ins: an Ithaco instance where you manually
            maintain the present settings of the real Ithaco amp.

            Note: it should be possible to use other current preamps, if they
            define parameters ``sens`` (sensitivity, in A/V), ``sens_factor``
            (an additional gain) and ``invert`` (bool, output is inverted)

        name: the name of the current output. Default 'curr'.
            Also used as the name of the whole parameter.
    """"""
    def __init__(self,
                 measured_param: Parameter,
                 c_amp_ins: ""Ithaco_1211"",
                 name: str = 'curr'):
        p_name = measured_param.name

        super().__init__(name=name,
                         names=(p_name+'_raw', name),
                         shapes=((), ()),
                         setpoints=((), ()),
                         instrument=c_amp_ins,
                         snapshot_value=True)

        self._measured_param = measured_param

        p_label = getattr(measured_param, ""label"", """")
        p_unit = getattr(measured_param, ""unit"", """")

        self.labels = (p_label, 'Current')
        self.units = (p_unit, 'A')

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        assert isinstance(self.instrument, Ithaco_1211)
        volt = self._measured_param.get()
        current = (self.instrument.sens.get() *
                   self.instrument.sens_factor.get()) * volt

        if self.instrument.invert.get():
            current *= -1

        value = (volt, current)
        return value


class Ithaco1211(Instrument):
    """"""
    QCoDeS driver for the Ithaco 1211 Current-preamplifier.

    This is a virtual driver only and will not talk to your instrument.
    """"""
    def __init__(self, name: str, **kwargs: Any):
        super().__init__(name, **kwargs)

        self.add_parameter('sens',
                           initial_value=1e-8,
                           label='Sensitivity',
                           unit='A/V',
                           get_cmd=None, set_cmd=None,
                           vals=Enum(1e-11, 1e-10, 1e-09, 1e-08, 1e-07,
                                     1e-06, 1e-05, 1e-4, 1e-3))

        self.add_parameter('invert',
                           initial_value=True,
                           label='Inverted output',
                           get_cmd=None, set_cmd=None,
                           vals=Bool())

        self.add_parameter('sens_factor',
                           initial_value=1,
                           label='Sensitivity factor',
                           unit=None,
                           get_cmd=None, set_cmd=None,
                           vals=Enum(0.1, 1, 10))

        self.add_parameter('suppression',
                           initial_value=1e-7,
                           label='Suppression',
                           unit='A',
                           get_cmd=None, set_cmd=None,
                           vals=Enum(1e-10, 1e-09, 1e-08, 1e-07, 1e-06,
                                     1e-05, 1e-4, 1e-3))

        self.add_parameter('risetime',
                           initial_value=0.3,
                           label='Rise Time',
                           unit='msec',
                           get_cmd=None, set_cmd=None,
                           vals=Enum(0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30,
                                     100, 300, 1000))

    def get_idn(self) -> dict[str, Optional[str]]:
        vendor = 'Ithaco (DL Instruments)'
        model = '1211'
        serial = None
        firmware = None
        return {'vendor': vendor, 'model': model,
                'serial': serial, 'firmware': firmware}


class Ithaco_1211(Ithaco1211):
    """"""
    Old alias for Itaco1211. Will eventually be deprecated and removed.
    """"""
"
361,https://www.lakeshore.com/docs/default-source/product-downloads/325_manualf0dc89f86bfb4740aedde9dce6cdf807.pdf?sfvrsn=4eb4bc0a_1,https://en.wikipedia.org/wiki/Temperature_control,"[OrderedDict([('id', 'attJUPJOD1xl9aFGp'), ('width', 505), ('height', 271), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ma2EHXN_SJXniZTM_JcjBA/TMg0WfWURihSHQuhjrbMiRcJgfb-TMZaOzdvhz9KYC1vHQ71L_Myh-1qdusu9QKu17b-KdZHQkXdwX3uFyTiAA/wtG5SuYNXiJmAZx7ZvbKAN5AaWhm1WucBpA69J4A5to'), ('filename', '325.png'), ('size', 167071), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7yQCuudNZIETF8YPa-TeEw/oxqGOnqlvO3c69tRhUsvTv3UDCgTDUzg0AkAqQAUHbK3NNAYq5QJuJ_P7m3O-f6AW7tpIGkDIymVl7Vu-63AIg/d1uUMEGgKBGSQJhnNMJfKbDAs09168UyOP4g4zn2g7o'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1fQkRdXnBMWSXYUGKTrBsQ/AdwNBNsAeHUvG2MCFNPOkfcB_VE4lkrL5hlhGZMX6ZWbPo6gMdhWqz5dEIqk3PiEmqv0lR54uxvbqzIk0XsQpQ/LSwJNSPGidmnHHEWK5Jg1CKccJZbc0QOhDcYZqoe2J0'), ('width', 505), ('height', 271)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Hfr-cuPRkXRUpKet336wvw/ouwLwyVvT1E06b7_mbkP22gXkLNjYUjM7DkrbYDaKdo3b9whE7_t-S3uXemp9X92IuBMLZC3W95l2TPuOB19vg/L-FF-8d2tCDCCOcSa1buZfeq6cYCtBLCIAKH_U92_vE'), ('width', 3000), ('height', 3000)]))]))])]",21.4,"Westerville, Ohio, USA",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116683/Instruments/Vendor%20Logos/Lakeshore.png,"The Model 325 dual-channel cryogenic temperature controller is capable of supporting nearly any diode, RTD, or thermocouple temperature sensor. Two independent PID control loops with heater outputs of 25 W and 2 W are configured to drive either a 50 Ω or 25 Ω load for optimal cryocooler control flexibility. Designed with ease of use, functionality, and value in mind, the Model 325 is ideal for general-purpose laboratory and industrial temperature measurement and control applications.",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-325-cryogenic-temperature-controller,Lakeshore Model 325,356.0,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_325.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel325,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/uZEb0GeNQJzpY4gfMbqkMw/M10zIQfSkj5HU6JWK8X9RsLmcc6FG4q1B_9kI4z-ykuaLjZtGDg98K_rW2vkRVKv9kldiUZYwemYU05K_vzXf_TBjxzPFxgMsA1BoIcYChw/DVxmeK_C9RjtpXeaqXJsNrznuSYlrdhwulHDJ8BkmD8'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/5GefCSzVLVY17Ld4My8s-g/NtcN3PJb44e30eFFmMzFBkglOYj5xNlZxeH8S64gI0_oIxRf-JmJ-WoC69yAaIJg36Pe3iNv-1-CWVfo-2HBJTRzjezuPL_3iPkxyDeqr4A/ArbmGKilAdh84ZETfXmtPAi8mytPZCucU5LAjQMjnZQ'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yuuObs2i500o0b-5GqJscw/9753dxcHTqtIHxuitI89R2eJjspqnEoNaT8SWWRqMgMb-6ptXR7-BCn3-TfQRJ8rBGMpi8tqEV-9p8TUXDX539az-OaiNmCs02dNRY49sgs/XsZWd5wK_1Oc_KSFTVO59D8LyuR3UfKdkAO4L4apFsM'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/tqoYkvsE1Ysg_yi7G6kDRg/e9o6yxpeBsdjH_H16y73rv1FxGJ0pUBw1YzVBU_sq6Ny2e0BtuHmu7VjLhDKl4CdWHpYEVac1NSRTqIdKs-f1NYdemb4k4EubjoznL2av7U/1kEKtL2HrImdIfc8aXLiWfpR_fCOWyNtsbJQOiNNOU8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782744/Instruments/Temperature%20Controllers/Lakeshore-Model-325/Lakeshore-Model-325.png,Lakeshore Model 325,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,,,True,,"from collections.abc import Iterable
from enum import IntFlag
from itertools import takewhile
from typing import Any, Optional, TextIO, cast

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import Group, GroupParameter
from qcodes.validators import Enum, Numbers


def _read_curve_file(curve_file: TextIO) -> dict[Any, Any]:
    """"""
    Read a curve file with extension .330
    The file format of this file is shown in test_lakeshore_file_parser.py
    in the test module

    The output is a dictionary with keys: ""metadata"" and ""data"".
    The metadata dictionary contains the first n lines of the curve file which
    are in the format ""item: value"". The data dictionary contains the actual
    curve data.
    """"""

    def split_data_line(line: str, parser: type = str) -> list[Any]:
        return [parser(i) for i in line.split(""  "") if i != """"]

    def strip(strings: Iterable[str]) -> tuple[str, ...]:
        return tuple(s.strip() for s in strings)

    lines = iter(curve_file.readlines())
    # Meta data lines contain a colon
    metadata_lines = takewhile(lambda s: "":"" in s, lines)
    # Data from the file is collected in the following dict
    file_data: dict[str, dict[str, Any]] = dict()
    # Capture meta data
    parsed_lines = [strip(line.split("":"")) for line in metadata_lines]
    file_data[""metadata""] = {key: value for key, value in parsed_lines}
    # After meta data we have a data header
    header_items = strip(split_data_line(next(lines)))
    # After that we have the curve data
    data: list[list[float]] = [
        split_data_line(line, parser=float) for line in lines if line.strip() != """"
    ]
    file_data[""data""] = dict(zip(header_items, zip(*data)))

    return file_data


def _get_sanitize_data(file_data: dict[Any, Any]) -> dict[Any, Any]:
    """"""
    Data as found in the curve files are slightly different from
    the dictionary as expected by the 'upload_curve' method of the
    driver
    """"""
    data_dict = dict(file_data[""data""])
    # We do not need the index column
    del data_dict[""No.""]
    # Rename the 'Units' column to the appropriate name
    # Look up under the 'Data Format' entry to find what units we have
    data_format = file_data[""metadata""][""Data Format""]
    # This is a string in the form '4      (Log Ohms/Kelvin)'
    data_format_int = int(data_format.split()[0])
    correct_name = LakeshoreModel325Curve.valid_sensor_units[data_format_int - 1]
    # Rename the column
    data_dict[correct_name] = data_dict[""Units""]
    del data_dict[""Units""]

    return data_dict


class LakeshoreModel325Status(IntFlag):
    """"""
    IntFlag that defines status codes for Lakeshore Model 325
    """"""
    sensor_units_overrang = 128
    sensor_units_zero = 64
    temp_overrange = 32
    temp_underrange = 16
    invalid_reading = 1


class LakeshoreModel325Curve(InstrumentChannel):
    """"""
    An InstrumentChannel representing a curve on a Lakeshore Model 325
    """"""

    valid_sensor_units = [""mV"", ""V"", ""Ohm"", ""log Ohm""]
    temperature_key = ""Temperature (K)""

    def __init__(self, parent: ""LakeshoreModel325"", index: int) -> None:

        self._index = index
        name = f""curve_{index}""
        super().__init__(parent, name)

        self.add_parameter(""serial_number"", parameter_class=GroupParameter)

        self.add_parameter(
            ""format"",
            val_mapping={
                f""{unt}/K"": i + 1 for i, unt in enumerate(self.valid_sensor_units)
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(""limit_value"", parameter_class=GroupParameter)

        self.add_parameter(
            ""coefficient"",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )

        self.add_parameter(""curve_name"", parameter_class=GroupParameter)

        Group(
            [
                self.curve_name,
                self.serial_number,
                self.format,
                self.limit_value,
                self.coefficient,
            ],
            set_cmd=f""CRVHDR {self._index}, {{curve_name}}, ""
            f""{{serial_number}}, {{format}}, {{limit_value}}, ""
            f""{{coefficient}}"",
            get_cmd=f""CRVHDR? {self._index}"",
        )

    def get_data(self) -> dict[Any, Any]:
        curve = [
            float(a)
            for point_index in range(1, 200)
            for a in self.ask(f""CRVPT? {self._index}, {point_index}"").split("","")
        ]

        d = {self.temperature_key: curve[1::2]}
        sensor_unit = self.format().split(""/"")[0]
        d[sensor_unit] = curve[::2]

        return d

    @classmethod
    def validate_datadict(cls, data_dict: dict[Any, Any]) -> str:
        """"""
        A data dict has two keys, one of which is 'Temperature (K)'. The other
        contains the units in which the curve is defined and must be one of:
        'mV', 'V', 'Ohm' or 'log Ohm'

        This method validates this and returns the sensor unit encountered in
        the data dict
        """"""
        if cls.temperature_key not in data_dict:
            raise ValueError(
                f""At least {cls.temperature_key} needed in the "" f""data dictionary""
            )

        sensor_units = [i for i in data_dict.keys() if i != cls.temperature_key]

        if len(sensor_units) != 1:
            raise ValueError(
                ""Data dictionary should have one other key, other then ""
                ""'Temperature (K)'""
            )

        sensor_unit = sensor_units[0]

        if sensor_unit not in cls.valid_sensor_units:
            raise ValueError(
                f""Sensor unit {sensor_unit} invalid. This needs to be one of ""
                f""{', '.join(cls.valid_sensor_units)}""
            )

        data_size = len(data_dict[cls.temperature_key])
        if data_size != len(data_dict[sensor_unit]) or data_size > 200:
            raise ValueError(
                ""The length of the temperature axis should be ""
                ""the same as the length of the sensor axis and ""
                ""should not exceed 200 in size""
            )

        return sensor_unit

    def set_data(
        self, data_dict: dict[Any, Any], sensor_unit: Optional[str] = None
    ) -> None:
        """"""
        Set the curve data according to the values found the the dictionary.

        Args:
            data_dict (dict): See `validate_datadict` to see the format of this
                                dictionary
            sensor_unit (str): If None, the data dict is validated and the
                                units are extracted.
        """"""
        if sensor_unit is None:
            sensor_unit = self.validate_datadict(data_dict)

        temperature_values = data_dict[self.temperature_key]
        sensor_values = data_dict[sensor_unit]

        for value_index, (temperature_value, sensor_value) in enumerate(
            zip(temperature_values, sensor_values)
        ):

            cmd_str = (
                f""CRVPT {self._index}, {value_index + 1}, ""
                f""{sensor_value:3.3f}, {temperature_value:3.3f}""
            )

            self.write(cmd_str)


class LakeshoreModel325Sensor(InstrumentChannel):
    """"""
    InstrumentChannel for a single sensor of a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        inp (str): Either ""A"" or ""B""
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, inp: str) -> None:

        if inp not in [""A"", ""B""]:
            raise ValueError(""Please either specify input 'A' or 'B'"")

        super().__init__(parent, name)
        self._input = inp

        self.add_parameter(
            ""temperature"",
            get_cmd=f""KRDG? {self._input}"",
            get_parser=float,
            label=""Temperature"",
            unit=""K"",
        )

        self.add_parameter(
            ""status"",
            get_cmd=f""RDGST? {self._input}"",
            get_parser=lambda status: self.decode_sensor_status(int(status)),
            label=""Sensor_Status"",
        )

        self.add_parameter(
            ""type"",
            val_mapping={
                ""Silicon diode"": 0,
                ""GaAlAs diode"": 1,
                ""100 Ohm platinum/250"": 2,
                ""100 Ohm platinum/500"": 3,
                ""1000 Ohm platinum"": 4,
                ""NTC RTD"": 5,
                ""Thermocouple 25mV"": 6,
                ""Thermocouple 50 mV"": 7,
                ""2.5 V, 1 mA"": 8,
                ""7.5 V, 1 mA"": 9,
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""compensation"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        Group(
            [self.type, self.compensation],
            set_cmd=f""INTYPE {self._input}, {{type}}, {{compensation}}"",
            get_cmd=f""INTYPE? {self._input}"",
        )

        self.add_parameter(
            ""curve_index"",
            set_cmd=f""INCRV {self._input}, {{}}"",
            get_cmd=f""INCRV? {self._input}"",
            get_parser=int,
            vals=Numbers(min_value=1, max_value=35),
        )

    @staticmethod
    def decode_sensor_status(sum_of_codes: int) -> str:
        total_status = LakeshoreModel325Status(sum_of_codes)
        if sum_of_codes == 0:
            return ""OK""
        status_messages = [
            st.name.replace(""_"", "" "")
            for st in LakeshoreModel325Status
            if st in total_status and st.name is not None
        ]
        return "", "".join(status_messages)

    @property
    def curve(self) -> LakeshoreModel325Curve:
        parent = cast(LakeshoreModel325, self.parent)
        return LakeshoreModel325Curve(parent, self.curve_index())


class LakeshoreModel325Heater(InstrumentChannel):
    """"""
    InstrumentChannel for heater control on a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        loop (int): Either 1 or 2
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, loop: int) -> None:

        if loop not in [1, 2]:
            raise ValueError(""Please either specify loop 1 or 2"")

        super().__init__(parent, name)
        self._loop = loop

        self.add_parameter(
            ""control_mode"",
            get_cmd=f""CMODE? {self._loop}"",
            set_cmd=f""CMODE {self._loop},{{}}"",
            val_mapping={
                ""Manual PID"": ""1"",
                ""Zone"": ""2"",
                ""Open Loop"": ""3"",
                ""AutoTune PID"": ""4"",
                ""AutoTune PI"": ""5"",
                ""AutoTune P"": ""6"",
            },
        )

        self.add_parameter(
            ""input_channel"", vals=Enum(""A"", ""B""), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""unit"",
            val_mapping={""Kelvin"": ""1"", ""Celsius"": ""2"", ""Sensor Units"": ""3""},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""powerup_enable"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""output_metric"",
            val_mapping={
                ""current"": ""1"",
                ""power"": ""2"",
            },
            parameter_class=GroupParameter,
        )

        Group(
            [self.input_channel, self.unit, self.powerup_enable, self.output_metric],
            set_cmd=f""CSET {self._loop}, {{input_channel}}, {{unit}}, ""
            f""{{powerup_enable}}, {{output_metric}}"",
            get_cmd=f""CSET? {self._loop}"",
        )

        self.add_parameter(
            ""P"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""I"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""D"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        Group(
            [self.P, self.I, self.D],
            set_cmd=f""PID {self._loop}, {{P}}, {{I}}, {{D}}"",
            get_cmd=f""PID? {self._loop}"",
        )

        if self._loop == 1:
            valid_output_ranges = Enum(0, 1, 2)
        else:
            valid_output_ranges = Enum(0, 1)

        self.add_parameter(
            ""output_range"",
            vals=valid_output_ranges,
            set_cmd=f""RANGE {self._loop}, {{}}"",
            get_cmd=f""RANGE? {self._loop}"",
            val_mapping={""Off"": ""0"", ""Low (2.5W)"": ""1"", ""High (25W)"": ""2""},
        )

        self.add_parameter(
            ""setpoint"",
            vals=Numbers(0, 400),
            get_parser=float,
            set_cmd=f""SETP {self._loop}, {{}}"",
            get_cmd=f""SETP? {self._loop}"",
        )

        self.add_parameter(
            ""ramp_state"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""ramp_rate"",
            vals=Numbers(0, 100 / 60 * 1e3),
            unit=""mK/s"",
            parameter_class=GroupParameter,
            get_parser=lambda v: float(v) / 60 * 1e3,  # We get values in K/min,
            set_parser=lambda v: v * 60 * 1e-3,  # Convert to K/min
        )

        Group(
            [self.ramp_state, self.ramp_rate],
            set_cmd=f""RAMP {self._loop}, {{ramp_state}}, {{ramp_rate}}"",
            get_cmd=f""RAMP? {self._loop}"",
        )

        self.add_parameter(""is_ramping"", get_cmd=f""RAMPST? {self._loop}"")

        self.add_parameter(
            ""resistance"",
            get_cmd=f""HTRRES? {self._loop}"",
            set_cmd=f""HTRRES {self._loop}, {{}}"",
            val_mapping={
                25: 1,
                50: 2,
            },
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""heater_output"",
            get_cmd=f""HTR? {self._loop}"",
            get_parser=float,
            label=""Heater Output"",
            unit=""%"",
        )


class LakeshoreModel325(VisaInstrument):
    """"""
    QCoDeS driver for Lakeshore Model 325 Temperature Controller.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\r\n"", **kwargs)

        sensors = ChannelList(
            self, ""sensor"", LakeshoreModel325Sensor, snapshotable=False
        )

        for inp in [""A"", ""B""]:
            sensor = LakeshoreModel325Sensor(self, f""sensor_{inp}"", inp)
            sensors.append(sensor)
            self.add_submodule(f""sensor_{inp}"", sensor)

        self.add_submodule(""sensor"", sensors.to_channel_tuple())

        heaters = ChannelList(
            self, ""heater"", LakeshoreModel325Heater, snapshotable=False
        )

        for loop in [1, 2]:
            heater = LakeshoreModel325Heater(self, f""heater_{loop}"", loop)
            heaters.append(heater)
            self.add_submodule(f""heater_{loop}"", heater)

        self.add_submodule(""heater"", heaters.to_channel_tuple())

        curves = ChannelList(self, ""curve"", LakeshoreModel325Curve, snapshotable=False)

        for curve_index in range(1, 35):
            curve = LakeshoreModel325Curve(self, curve_index)
            curves.append(curve)

        self.add_submodule(""curve"", curves)

        self.connect_message()

    def upload_curve(
        self, index: int, name: str, serial_number: str, data_dict: dict[Any, Any]
    ) -> None:
        """"""
        Upload a curve to the given index

        Args:
             index: The index to upload the curve to. We can only use
                            indices reserved for user defined curves, 21-35
             name
             serial_number
             data_dict: A dictionary containing the curve data
        """"""
        if index not in range(21, 36):
            raise ValueError(""index value should be between 21 and 35"")

        sensor_unit = LakeshoreModel325Curve.validate_datadict(data_dict)

        curve = self.curve[index - 1]
        curve.curve_name(name)
        curve.serial_number(serial_number)
        curve.format(f""{sensor_unit}/K"")
        curve.set_data(data_dict, sensor_unit=sensor_unit)

    def upload_curve_from_file(self, index: int, file_path: str) -> None:
        """"""
        Upload a curve from a curve file. Note that we only support
        curve files with extension .330
        """"""
        if not file_path.endswith("".330""):
            raise ValueError(""Only curve files with extension .330 are supported"")

        with open(file_path) as curve_file:
            file_data = _read_curve_file(curve_file)

        data_dict = _get_sanitize_data(file_data)
        name = file_data[""metadata""][""Sensor Model""]
        serial_number = file_data[""metadata""][""Serial Number""]

        self.upload_curve(index, name, serial_number, data_dict)
"
363,,https://en.wikipedia.org/wiki/Digital-to-analog_converter,"[OrderedDict([('id', 'attTi6f3UhfE6DEiY'), ('width', 1024), ('height', 670), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Ol25XpAbia5PrGDS8FC_3A/VS9nifexhnFiCaDGRpCWw7EhLa0rjnl3Fcsv3ewQGET1lR6nBbnpPEyl4PnanvRlSyG2IDxNjoNjW9HpqgF0Eg/m-PbDHIgb0-TnoyLOEem3mHN-hv2gQez31ziwEwGqzk'), ('filename', 'QDAC.png'), ('size', 142257), ('type', 'image/png')])]",2.0,"COPENHAGEN, DENMARK",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116688/Instruments/Vendor%20Logos/QDevils.png,"QDAC is a high-precision, 25-bit resolution, ultra-low-noise computer-controlled DAC with 24 voltage channel generators operating at a sample rate of 1MS/s. It is designed for DC and intermediate-frequency control of quantum devices, including, for example, gate electrodes and flux bias coils in qubits. It is also a very versatile instrument that can be used for many other purposes.

","https://www.quantum-machines.co/products/qdac/#:~:text=QDAC%20is%20a%20high%2Dprecision,flux%20bias%20coils%20in%20qubits.",Qdac Channels,421.0,"['Power Supplies', 'Digital-Analog Converter']","In electronics, a digital-to-analog converter (DAC, D/A, D2A, or D-to-A) is a system that converts a digital signal into an analog signal. An analog-to-digital converter (ADC) performs the reverse function.","Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QDev/QDac_channels.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/QDev.html#qcodes.instrument_drivers.QDev.QDevQDac,Qdev,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZipqRJHx1ZoZu3cghu7vBA/z9H-ZQBq2_I8zCC8dELRC06dUey_nswlbMuiYzEmycqDr8vhnXPF0FBCmXK4wC7kG-jirKCZzJoZX5FXEOL_aZH0awwU4pCaQjWQ9lmundE/m1xO3FphqjdTL2OvdcYibXA5xq2kBXku5jFFSbaE8m0'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_kPkmkp924cYOpBfwTdyRQ/6cwrD_J2gPXVt-4M1mUBTSIIWE-hsbkpM_9AGlgsmak6TyY_f-4iSK54jJhcnISchqqCuBivciv7wIromX99QQ_s6mdvUGEfbghSg5iIUeg/FqDUbUx5DPXHJ6hMeaZnrAmnuuBhJlx8vsMzdsdJC5M'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/vv8Vb8suhbaQ0iYaWaZKMg/KSlmragEXUUzsRLsI6qD88v1EKTJ4gj8pssnhSStMUT69KrN7Q0hz2JLcfFYKvYk-nHLB8WFlHZLRfigCqFgUhecEVCWK04FmYxOhFWjvi4/W_nPBfzjSJkSeffoFXkes8ukvDD7flirUIYQti29HgY'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/h7ewz4-RmYdXWrd-8yIIKg/db9bliGbjLIx49CcrSG-cT5AKuIC2afryQV_vMaEB3E1lUpsqSDprVTnuWANwTJIOK9uszt--wAUBM8uezGAQHlibS3nutwEuf4-J2XDFrg/22-M_b5ipZoxmJW1slGpryiJNTjrKn_fEjpJrsj9qtc'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782644/Instruments/Digital-Analog%20Converter/QDAC/QDAC.png,QDAC,"Write a Python script that uses Qcodes to connect to a QDAC Power Supplies, Digital-Analog Converter",,,,,"# QCoDeS driver for QDac using channels

import logging
import time
from collections.abc import Sequence
from functools import partial
from typing import Any, Optional, Union

import pyvisa
import pyvisa.constants
from pyvisa.resources.serial import SerialInstrument

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import MultiChannelInstrumentParameter, ParamRawDataType

log = logging.getLogger(__name__)


class QDevQDacChannel(InstrumentChannel):
    """"""
    A single output channel of the QDac.

    Exposes chan.v, chan.vrange, chan.slope, chan.i, chan.irange
    """"""

    _CHANNEL_VALIDATION = vals.Numbers(1, 48)

    def __init__(self, parent: Instrument, name: str, channum: int):
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-48)
        """"""
        super().__init__(parent, name)

        # Validate the channel
        self._CHANNEL_VALIDATION.validate(channum)

        # Add the parameters

        self.add_parameter('v',
                           label=f'Channel {channum} voltage',
                           unit='V',
                           set_cmd=partial(self._parent._set_voltage, channum),
                           get_cmd=partial(self._parent._get_voltage, channum),
                           get_parser=float,
                           vals=vals.Numbers(-10, 10)
                           )

        self.add_parameter('vrange',
                           label=f'Channel {channum} atten.',
                           set_cmd=partial(self._parent._set_vrange, channum),
                           get_cmd=partial(self._parent._get_vrange, channum),
                           vals=vals.Enum(0, 1)
                           )

        self.add_parameter('i',
                           label=f'Channel {channum} current',
                           get_cmd=f'get {channum}',
                           unit='A',
                           get_parser=self._parent._current_parser
                           )

        self.add_parameter('irange',
                           label=f'Channel {channum} irange',
                           set_cmd=f'cur {channum} {{}}',
                           get_cmd=f'cur {channum}',
                           get_parser=int
                           )

        self.add_parameter('slope',
                           label=f'Channel {channum} slope',
                           unit='V/s',
                           set_cmd=partial(self._parent._setslope, channum),
                           get_cmd=partial(self._parent._getslope, channum),
                           vals=vals.MultiType(vals.Enum('Inf'),
                                               vals.Numbers(1e-3, 100))
                           )

        self.add_parameter('sync',
                           label=f'Channel {channum} sync output',
                           set_cmd=partial(self._parent._setsync, channum),
                           get_cmd=partial(self._parent._getsync, channum),
                           vals=vals.Ints(0, 5)
                           )

        self.add_parameter(name='sync_delay',
                           label=f'Channel {channum} sync pulse delay',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           initial_value=0
                           )

        self.add_parameter(name='sync_duration',
                           label=f'Channel {channum} sync pulse duration',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           initial_value=0.01
                           )

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._parent._update_currents and update
        if update and not self._parent._get_status_performed:
            self._parent._update_cache(readcurrents=update_currents)
        # call get_status rather than getting the status individually for
        # each parameter. This is only done if _get_status_performed is False
        # this is used to signal that the parent has already called it and
        # no need to repeat.
        if params_to_skip_update is None:
            params_to_skip_update = ('v', 'i', 'irange', 'vrange')
        snap = super().snapshot_base(update=update,
                                     params_to_skip_update=params_to_skip_update)
        return snap


QDacChannel = QDevQDacChannel


class QDevQDacMultiChannelParameter(MultiChannelInstrumentParameter):
    """"""
    The class to be returned by __getattr__ of the ChannelList. Here customised
    for fast multi-readout of voltages.
    """"""
    def __init__(
            self,
            channels: Sequence[InstrumentChannel],
            param_name: str,
            *args: Any,
            **kwargs: Any):
        super().__init__(channels, param_name, *args, **kwargs)

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        """"""
        Return a tuple containing the data from each of the channels in the
        list.
        """"""
        # For voltages, we can do something slightly faster than the naive
        # approach

        if self._param_name == 'v':
            qdac = self._channels[0]._parent
            qdac._update_cache(readcurrents=False)
            output = tuple(chan.parameters[self._param_name].get_latest()
                           for chan in self._channels)
        else:
            output = tuple(chan.parameters[self._param_name].get()
                           for chan in self._channels)

        return output


QDacMultiChannelParameter = QDevQDacMultiChannelParameter


class QDevQDac(VisaInstrument):
    """"""
    Channelised driver for the QDev digital-analog converter QDac

    Based on ""DAC_commands_v_13.pdf""
    Tested with Software Version: 0.170202

    The driver assumes that the instrument is ALWAYS in verbose mode OFF
    """"""


    # set nonzero value (seconds) to accept older status when reading settings
    max_status_age = 1

    def __init__(self,
                 name: str,
                 address: str,
                 num_chans: int = 48,
                 update_currents: bool = True,
                 **kwargs: Any):
        """"""
        Instantiates the instrument.

        Args:
            name: The instrument name used by qcodes
            address: The VISA name of the resource
            num_chans: Number of channels to assign. Default: 48
            update_currents: Whether to query all channels for their
                current current value on startup. Default: True.

        Returns:
            QDac object
        """"""
        super().__init__(name, address, **kwargs)
        self._output_n_lines = 50
        handle = self.visa_handle
        assert isinstance(handle, SerialInstrument)
        self._get_status_performed = False
        # This is the baud rate on power-up. It can be changed later but
        # you must start out with this value.
        handle.baud_rate = 460800
        handle.parity = pyvisa.constants.Parity(0)
        handle.data_bits = 8
        self.set_terminator('\n')
        # TODO: do we want a method for write termination too?
        handle.write_termination = '\n'
        # TODO: do we need a query delay for robust operation?
        self._write_response = ''

        if self._get_firmware_version() < 0.170202:
            raise RuntimeError('''
                               Obsolete QDAC Software version detected.
                               QCoDeS only supports version 0.170202 or newer.
                               Contact rikke.lutge@nbi.ku.dk for an update.
                               ''')

        self.num_chans = num_chans

        # Assigned slopes. Entries will eventually be [chan, slope]
        self._slopes: list[tuple[int, Union[str, float]]] = []
        # Function generators (used in _set_voltage)
        self._fgs = set(range(1, 9))
        self._assigned_fgs: dict[int, int] = {}  # {chan: fg}
        # Sync channels
        self._syncoutputs: list[tuple[int, int]] = []  # Entries: [chan, syncchannel]

        self.chan_range = range(1, 1 + self.num_chans)
        self.channel_validator = vals.Ints(1, self.num_chans)

        channels = ChannelList(
            self,
            ""Channels"",
            QDevQDacChannel,
            snapshotable=False,
            multichan_paramclass=QDevQDacMultiChannelParameter,
        )

        for i in self.chan_range:
            channel = QDevQDacChannel(self, f""chan{i:02}"", i)
            channels.append(channel)
            # Should raise valueerror if name is invalid (silently fails now)
            self.add_submodule(f""ch{i:02}"", channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        for board in range(6):
            for sensor in range(3):
                label = f'Board {board}, Temperature {sensor}'
                self.add_parameter(name=f'temp{board}_{sensor}',
                                   label=label,
                                   unit='C',
                                   get_cmd=f'tem {board} {sensor}',
                                   get_parser=self._num_verbose)

        self.add_parameter(name='cal',
                           set_cmd='cal {}',
                           vals=self.channel_validator)
        # TO-DO: maybe it's too dangerous to have this settable.
        # And perhaps ON is a better verbose mode default?
        self.add_parameter(name='verbose',
                           set_cmd='ver {}',
                           val_mapping={True: 1, False: 0})

        # Initialise the instrument, all channels DC (unbind func. generators)
        for chan in self.chan_range:
            # Note: this call does NOT change the voltage on the channel
            self.write(f'wav {chan} 0 1 0')

        self.verbose.set(False)
        self.connect_message()
        log.info('[*] Querying all channels for voltages and currents...')
        self.version = self._update_cache(readcurrents=update_currents)
        self._update_currents = update_currents
        log.info('[+] Done')

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._update_currents and update is True
        if update:
            self._update_cache(readcurrents=update_currents)
            self._get_status_performed = True
        # call get_status rather than getting the status individually for
        # each parameter. We set _get_status_performed to True
        # to indicate that each update channel does not need to call this
        # function as opposed to when snapshot is called on an individual
        # channel
        snap = super().snapshot_base(update=update,
                                     params_to_skip_update=params_to_skip_update)
        self._get_status_performed = False
        return snap

    #########################
    # Channel gets/sets
    #########################

    def _set_voltage(
            self,
            chan: int,
            v_set: float) -> None:
        """"""
        set_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
            v_set: The target voltage

        If a finite slope has been assigned, we assign a function generator to
        ramp the voltage.
        """"""
        channel = self.channels[chan-1]

        slopechans = [sl[0] for sl in self._slopes]
        if chan in slopechans:
            slope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            # find and assign fg
            fg = min(self._fgs.difference(set(self._assigned_fgs.values())))
            self._assigned_fgs[chan] = fg
            # We need .get and not get_latest in case a ramp was interrupted
            v_start = channel.v.get()
            time = abs(v_set-v_start)/slope
            log.info(f'Slope: {slope}, time: {time}')
            # Attenuation compensation and syncing
            # happen inside _rampvoltage
            self._rampvoltage(chan, fg, v_start, v_set, time)
        else:
            v_dac = QDevQDac._get_v_dac_from_v_exp(channel, v_set)
            # set the mode back to DC in case it had been changed
            # and then set the voltage
            self.write(f'wav {chan} 0 0 0;set {chan} {v_dac:.6f}')

    def _get_voltage(self, chan: int) -> float:
        """"""
        get_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
        """"""
        self._update_cache(readcurrents=False)
        return self.channels[chan - 1].v.cache()


    # In order to get conversions right let us define a vocabulary:
    # v_exp: is the voltage including the attenuation.This is the value
    # we want to store in the cache and the value we interact with as a
    # qcodes user.
    # v_dac: this is the voltage generated by the dac and handled by the VISA
    # commands.
    # Then we have the general relationship`v_exp = v_dac * attenuation`,
    @staticmethod
    def _get_attenuation(channel: QDevQDacChannel) -> float:
        return 0.1 if channel.vrange.cache() == 1 else 1.0

    @staticmethod
    def _get_v_dac_from_v_exp(channel: QDevQDacChannel, v_exp: float) -> float:
        return v_exp / QDevQDac._get_attenuation(channel)

    @staticmethod
    def _get_v_exp_from_v_dac(channel: QDevQDacChannel, v_dac: float) -> float:
        return v_dac * QDevQDac._get_attenuation(channel)

    def _set_vrange(self, chan: int, switchint: int) -> None:
        """"""
        set_cmd for the chXX_vrange parameter

        The switchint is an integer. 1 means attenuation ON.

        Since the vrange is actually a 20 dB attenuator (amplitude factor 0.1)
        immediately applied to the channel output, we must update the voltage
        parameter accordingly
        """"""

        self.write(f'vol {chan} {switchint}')

        # setting v_range preserves v_dac but changes v_exp, see comment above
        # for definitions.
        channel = self.channels[chan-1]
        if channel.vrange.cache() != switchint:
            v_dac = QDevQDac._get_v_dac_from_v_exp(channel, channel.v.cache())
            channel.vrange.cache.set(switchint)
            self._update_v_validator(channel, switchint)
            channel.v.cache.set(QDevQDac._get_v_exp_from_v_dac(channel, v_dac))

    def _get_vrange(self, chan: int) -> float:
        """"""
        get_cmd for the chXX_vrange parameter

        Args:
            chan: The 1-indexed channel number
        """"""
        self._update_cache(readcurrents=False)
        return self.channels[chan - 1].vrange.cache()

    def _num_verbose(self, s: str) -> float:
        """"""
        turn a return value from the QDac into a number.
        If the QDac is in verbose mode, this involves stripping off the
        value descriptor.
        """"""
        if self.verbose.get_latest():
            s = s.split(': ')[-1]
        return float(s)

    def _current_parser(self, s: str) -> float:
        """"""
        parser for chXX_i parameter
        """"""
        return 1e-6*self._num_verbose(s)

    def _update_cache(self, readcurrents: bool = False) -> str:
        r""""""
        Function to query the instrument and get the status of all channels,
        e.g. voltage (``v``), voltage range (``vrange``), and current range (``irange``)
        parameters of all the channels.
        Takes a while to finish.

        The `status` call generates 51 lines of output. Send the command and
        read the first one, which is the software version line
        the full output looks like:
        Software Version: 0.160218\r\n
        Channel\tOut V\t\tVoltage range\tCurrent range\n
        \n
        8\t  0.000000\t\tX 1\t\tpA\n
        7\t  0.000000\t\tX 1\t\tpA\n
        ... (all 48 channels like this in a somewhat peculiar order)
        (no termination afterward besides the \n ending the last channel)
        returns a list of dicts [{v, vrange, irange}]
        NOTE - channels are 1-based, but the return is a list, so of course
        0-based, ie chan1 is out[0]
        """"""

        def validate_version(version_line: str) -> str:
            if version_line.startswith(""Software Version: ""):
                version = version_line.strip().split("": "")[1]
            else:
                self._wait_and_clear()
                raise ValueError('unrecognized version line: ' + version_line)
            return version

        def validate_header(header_line: str) -> None:
            headers = header_line.lower().strip('\r\n').split('\t')
            expected_headers = ['channel', 'out v', '', 'voltage range',
                                'current range']
            if headers != expected_headers:
                raise ValueError('unrecognized header line: ' + header_line)

        def parse_line(line: str) -> tuple[int, int, int, float]:
            i_range_trans = {'hi cur': 1, 'lo cur': 0}
            v_range_trans = {'X 1': 0, 'X 0.1': 1}

            chan_str, v_str, _, v_range_str, _, i_range_str = line.split('\t')
            chan = int(chan_str)
            v_dac = float(v_str)
            v_range = v_range_trans[v_range_str.strip()]
            i_range = i_range_trans[i_range_str.strip()]
            return chan, i_range, v_range, v_dac

        version = validate_version(self.ask(""status""))
        validate_header(self.read())

        chans_left = set(self.chan_range)
        while chans_left:
            line = self.read().strip()
            if not line:
                continue
            chan, i_range, v_range, v_dac = parse_line(line)

            channel = self.channels[chan - 1]
            channel.vrange.cache.set(v_range)
            self._update_v_validator(channel, v_range)
            channel.irange.cache.set(i_range)
            channel.v.cache.set(QDevQDac._get_v_exp_from_v_dac(channel, v_dac))

            chans_left.remove(chan)

        if readcurrents:
            self._read_currents()
        return version

    def _read_currents(self) -> None:
        for chan in range(1, self.num_chans + 1):
            param = self.channels[chan - 1].i
            _ = param.get()

    @staticmethod
    def _update_v_validator(channel: QDevQDacChannel, v_range: int) -> None:
        range = (-10.01, 10.01) if v_range == 0 else (-1.001, 1.001)
        channel.v.vals = vals.Numbers(*range)

    def _setsync(self, chan: int, sync: int) -> None:
        """"""
        set_cmd for the chXX_sync parameter.

        Args:
            chan (int): The channel number (1-48)
            sync (int): The associated sync output. 0 means 'unassign'
        """"""

        if chan not in range(1, 49):
            raise ValueError('Channel number must be 1-48.')

        if sync == 0:
            # try to remove the sync from internal bookkeeping
            try:
                sc = self._syncoutputs
                to_remove = [sc.index(syn) for syn in sc if syn[0] == chan][0]
                self._syncoutputs.remove(sc[to_remove])
            except IndexError:
                pass
            # free the previously assigned sync
            oldsync = self.channels[chan-1].sync.get_latest()
            if oldsync is not None:
                self.write(f'syn {oldsync} 0 0 0')
            return

        if sync in [syn[1] for syn in self._syncoutputs]:
            oldchan = [syn[0] for syn in self._syncoutputs if syn[1] == sync][0]
            self._syncoutputs.remove((oldchan, sync))

        if chan in [syn[0] for syn in self._syncoutputs]:
            oldsyn = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            self._syncoutputs[
                self._syncoutputs.index((chan, oldsyn))
            ] = (chan, sync)
            return

        self._syncoutputs.append((chan, sync))
        return

    def _getsync(self, chan: int) -> float:
        """"""
        get_cmd of the chXX_sync parameter
        """"""
        if chan in [syn[0] for syn in self._syncoutputs]:
            sync = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            return sync
        else:
            return 0

    def _setslope(self, chan: int, slope: Union[float, str]) -> None:
        """"""
        set_cmd for the chXX_slope parameter, the maximum slope of a channel.

        Args:
            chan: The channel number (1-48)
            slope: The slope in V/s. Write 'Inf' to allow
              arbitrary small rise times.
        """"""
        if chan not in range(1, 49):
            raise ValueError('Channel number must be 1-48.')

        if slope == 'Inf':
            self.write(f'wav {chan} 0 0 0')

            # Now clear the assigned slope and function generator (if possible)
            try:
                self._assigned_fgs.pop(chan)
            except KeyError:
                pass
            # Remove a sync output, if one was assigned
            syncchans = [syn[0] for syn in self._syncoutputs]
            if chan in syncchans:
                self.channels[chan-1].sync.set(0)
            try:
                sls = self._slopes
                to_remove = [sls.index(sl) for sl in sls if sl[0] == chan][0]
                self._slopes.remove(sls[to_remove])
                return
            # If the value was already 'Inf', the channel was not
            # in the list and nothing happens
            except IndexError:
                return

        if chan in [sl[0] for sl in self._slopes]:
            oldslope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            self._slopes[self._slopes.index((chan, oldslope))] = (chan, slope)
            return

        if len(self._slopes) >= 8:
            rampchans = "", "".join(str(c[0]) for c in self._slopes)
            raise ValueError(
                ""Can not assign finite slope to more than ""
                + ""8 channels. Assign 'Inf' to at least one of ""
                + f""the following channels: {rampchans}""
            )

        self._slopes.append((chan, slope))
        return

    def _getslope(self, chan: int) -> Union[str, float]:
        """"""
        get_cmd of the chXX_slope parameter
        """"""
        if chan in [sl[0] for sl in self._slopes]:
            slope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            return slope
        else:
            return 'Inf'

    def printslopes(self) -> None:
        """"""
        Print the finite slopes assigned to channels
        """"""
        for sl in self._slopes:
            print(f""Channel {sl[0]}, slope: {sl[1]} (V/s)"")

    def _rampvoltage(
            self,
            chan: int,
            fg: int,
            v_start: float,
            setvoltage: float,
            ramptime: float
    ) -> None:
        """"""
        Smoothly ramp the voltage of a channel by the means of a function
        generator. Helper function used by _set_voltage.

        Args:
            chan: The channel number (counting from 1)
            fg: The function generator (counting from 1)
            setvoltage: The voltage to ramp to
            ramptime: The ramp time in seconds.
        """"""

        # Crazy stuff happens if the period is too small, e.g. the channel
        # can jump to its max voltage
        if ramptime <= 0.002:
            ramptime = 0
            log.warning('Cancelled a ramp with a ramptime of '
                        '{} s'.format(ramptime) + '. Voltage not changed.')

        offset = v_start
        amplitude = setvoltage-v_start
        if self.channels[chan-1].vrange.get_latest() == 1:
            offset *= 10
            amplitude *= 10

        chanmssg = 'wav {} {} {} {}'.format(chan, fg,
                                            amplitude,
                                            offset)

        if chan in [syn[0] for syn in self._syncoutputs]:
            sync = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            sync_duration = 1000*self.channels[chan-1].sync_duration.get()
            sync_delay = 1000*self.channels[chan-1].sync_delay.get()
            self.write('syn {} {} {} {}'.format(sync, fg,
                                                sync_delay,
                                                sync_duration))

        typedict = {'SINE': 1, 'SQUARE': 2, 'RAMP': 3}

        typeval = typedict['RAMP']
        dutyval = 100
        # s -> ms
        periodval = ramptime*1e3
        repval = 1
        funmssg = 'fun {} {} {} {} {}'.format(fg,
                                              typeval, periodval,
                                              dutyval, repval)
        self.write(chanmssg)
        self.write(funmssg)

    def write(self, cmd: str) -> None:
        """"""
        QDac always returns something even from set commands, even when
        verbose mode is off, so we'll override write to take this out
        if you want to use this response, we put it in self._write_response
        (but only for the very last write call)

        In this method we expect to read one termination char per command. As
        commands are concatenated by `;` we count the number of concatenated
        commands as count(';') + 1 e.g. 'wav 1 1 1 0;fun 2 1 100 1 1' is two
        commands. Note that only the response of the last command will be
        available in `_write_response`

        """"""

        log.debug(f""Writing to instrument {self.name}: {cmd}"")

        self.visa_handle.write(cmd)
        for _ in range(cmd.count(';')+1):
            self._write_response = self.visa_handle.read()

    def read(self) -> str:
        return self.visa_handle.read()

    def _wait_and_clear(self, delay: float = 0.5) -> None:
        time.sleep(delay)
        self.visa_handle.clear()

    def connect_message(self,
                        idn_part: str = ""IDN"",
                        being_time: Optional[float] = None) -> None:
        """"""
        Override of the standard Instrument class connect_message.
        Usually, the response to `*IDN?` is printed. Here, the
        software version is printed.
        """"""
        self.visa_handle.write('status')

        log.info('Connected to QDac on {}, {}'.format(self._address,
                                                      self.visa_handle.read()))

        # take care of the rest of the output
        for _ in range(self._output_n_lines):
            self.visa_handle.read()

    def _get_firmware_version(self) -> float:
        self.write('status')
        FW_str = self._write_response
        FW_version = float(FW_str.replace('Software Version: ', ''))
        for _ in range(self._output_n_lines):
            self.read()
        return FW_version

    def print_overview(self, update_currents: bool = False) -> None:
        """"""
        Pretty-prints the status of the QDac
        """"""

        self._update_cache(readcurrents=update_currents)

        paramstoget = [['i', 'v'], ['irange', 'vrange']]
        printdict = {'i': 'Current', 'v': 'Voltage', 'vrange': 'Voltage range',
                     'irange': 'Current range'}

        returnmap = {'vrange': {1: '-1 V to 1 V', 0: '-10 V to 10 V'},
                     'irange': {0: '0 to 1 muA', 1: '0 to 100 muA'}}

        # Print the channels
        for ii in range(self.num_chans):
            line = f""Channel {ii+1} \n""
            line += ""    ""
            for pp in paramstoget[0]:
                param = getattr(self.channels[ii], pp)
                line += printdict[pp]
                line += f': {param.get_latest()}'
                line += f' ({param.unit})'
                line += '. '
            line += '\n    '
            for pp in paramstoget[1]:
                param = getattr(self.channels[ii], pp)
                line += printdict[pp]
                value = param.get_latest()
                line += f"": {returnmap[pp][value]}""
                line += "". ""
            print(line)


class QDac(QDevQDac):
    """"""
    Backwards compatibility alias for QDevQDac driver
    """"""

    pass
"
364,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'att07IIiNQzMwugAH'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/MDbsXagOUmQSOGhMmhx1uA/_8IgjgTusPGqchEaqVm4cbahjebZpKPUBLLrIeJa-GPT6oBnG9rVRjUXjJW7diYPoUFLRevutoGWFM0io10aUYk30aJGwog-RaPOJPcnfGgNXKpOVMjxvsqBKOwIYfFI/FKuegfNmeYNOOt32CinbA4Xv1cTqU7AQ3RZc048KGGg'), ('filename', '34461a-front-black-1200x735-White-b.jpg'), ('size', 201918), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/W22OZfgTHmVv-YwonvmaQg/nVZt0b5716RadxB7QO3KQUNhHw2XA3nXf9FkNS3k6vm9CSDIGWdg9QmU-Nkif3kGr2pOKjlru9YAv-BATJDUqA/tZwe5QMFNOZNZ_itrBO7NbkvFkuCtKBTxF-tj0wSmg0'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ureF9GseRhe7D2lkiZBrPQ/V82-1_uNpC4rKGJjsRjE32Gq1HK3C8vCLlxjZwS2AvZ59iWh6Mq9vSFfHMZyZjvF9hg1Ml4Z7mDHIirvASZhXQ/NuRgRY3zyN34w53HfGiitT4Qzm39KnWL5xf70Jc_Mzs'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/X20jS26DO3RS1wi-I90xrQ/zNkTxXuOJ-dV3ymjAiLBtW5Ja7QEu24vk_pYPmUrFOSTxoKcsPVM0XUEg678vonV5bkWarUoLrSecMTLiCQOLA/IukPktVJAhQtnRtNviTFA79WWRn8_D3gRLiZLHtQ6-A'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34461 A Submodules,273.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34461A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34461A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782747/Instruments/Multimeters/Keysight-34461A-Submodules/Keysight-34461A-Submodules.jpg,Keysight 34461A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34461A Submodules Multimeters,1863.0,,,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34461A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34461A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34461A(_Keysight_344xxA):
    """"""
    Alias for backwards compatibility.
    """"""
"
366,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/ZNB_bro_en_3608-3278-12_v0301.pdf,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),,2500.0,"Munich, Germany",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116717/Instruments/Vendor%20Logos/RohdeSchwarz.png,,,ZNB,460.0,['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/ZNB.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNBChannel,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/XHBiQ9oxXm-n-HvM6LnRsA/zCF7wkTRkwfOTCAuwmibY3O7w00r82Jr-e9BArEz2wuEOw-7rLpTsqnPaLuh9W23W58Qwn9JURC-40I0_-4JxPkfgmT1CSF7VPctZxztnV4/I5ofu9MkvIeeFWHtoXZm_t6fUCujFLfj-JFESMUqIgk'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rp7cS3TGPqAHuTUKlrNiDg/VQ8_PlSktrAEUSma3ec9casPyXqUCiOYTta1bFMCr-JbFojx11fj4PsFxxQcQkgk5T0s4eilsQBFkmKe1f5C4A/plUaF2hmxk-9dn7wzOx_UZSUTlLGORdKrjwdpcJGgiM'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ouYl2k3tZan1Mqr3gFZ4XQ/eznvJmkOWcALsfmYE2FWZIIuDkvhPsL5ha4wYwX2hkGiFmGNwyYpsS2lgvAprhPlVCGH-c59BKm4kM4jMvjwlA/h8aBHQcCEhxqGNo05zJPlPwJ7fdGYthLjdrl6yX_uaY'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6WMk-uFRvLMFJ3F3nCseOQ/Ssto5hgGHjq8Q9vjrgnj3D0-Fay9y9tubFUbdbvK9IeGUYn2K3euoW1jshe65viP4uybZmkDEuVY84MH5n021w/_2LXQNPKEtc9MtuRG0jFWn1Hay_SQ8m2sSYN4caNxpw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,,Series,Write a Python script that uses Qcodes to connect to a Series Network Analyzer,,,,,"import logging
from functools import partial
from typing import Any, Optional

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    ManualParameter,
    MultiParameter,
    ParamRawDataType,
    create_on_off_val_mapping,
)
from qcodes.utils import deprecate

log = logging.getLogger(__name__)


class FixedFrequencyTraceIQ(MultiParameter):
    """"""
    Parameter for sweep that returns the real (I) and imaginary (Q) parts of
    the VNA response.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        npts: int,
        bandwidth: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""I"", ""Q""),
            labels=(f""{instrument.short_name} I"", f""{instrument.short_name} Q""),
            units=("""", """"),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            setpoint_units=((""s"",), (""s"",)),
            setpoint_labels=((""time"",), (""time"",)),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_cw_sweep(npts, bandwidth)

    def set_cw_sweep(self, npts: int, bandwidth: int) -> None:
        """"""
        Updates config of the software parameter on sweep change. This is
        needed in order to sync the setpoint shape with the returned data
        shape after a change of sweep settings.

        Sets setpoints to the tuple which are hashable for look up.

        Note: This is similar to the set_sweep functions of the frequency
        sweep parameters. The time setpoints here neglect a small VNA
        overhead. The total time including overhead can be queried with the
        sweep_time function of the vna, but since it is not clear where this
        overhead is spend, we keep the x-axis set to 1/bandwidth. The error
        is only apparent in really fast measurements at 1us and 10us but
        depends on the amount of points you take. More points give less
        overhead.
        """"""
        t = tuple(np.linspace(0, npts / bandwidth, num=npts))
        self.setpoints = ((t,), (t,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[np.ndarray, np.ndarray]:
        """"""
        Gets the raw real and imaginary part of the data. If parameter
        `cw_check_sweep_first` is set to `True` then at the cost of a few ms
        overhead checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        return i, q


class FixedFrequencyPointIQ(MultiParameter):
    """"""
    Parameter for sweep that returns the mean of the real (I) and imaginary (Q)
    parts of the VNA response.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode
    Useful for two-tone and other bigger sweeps where you do not want to
    store all individual I-Q values.

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
    """"""

    def __init__(
        self, name: str, instrument: ""RohdeSchwarzZNBChannel"", **kwargs: Any
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""I"", ""Q""),
            labels=(f""{instrument.short_name} I"", f""{instrument.short_name} Q""),
            units=("""", """"),
            setpoints=((), (),),
            shapes=((), (),),
            **kwargs,
        )

    def get_raw(self) -> tuple[float, float]:
        """"""
        Gets the mean of the raw real and imaginary part of the data. If
        parameter `cw_check_sweep_first` is set to `True` then at the cost of a
        few ms overhead checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        return float(np.mean(i)), float(np.mean(q))


class FixedFrequencyPointMagPhase(MultiParameter):
    """"""
    Parameter for sweep that returns the magnitude of mean of the real (I) and
    imaginary (Q) parts of the VNA response and it's phase.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
    """"""

    def __init__(
        self, name: str, instrument: ""RohdeSchwarzZNBChannel"", **kwargs: Any
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=("""", ""rad""),
            setpoints=((), (),),
            shapes=((), (),),
            **kwargs,
        )

    def get_raw(self) -> tuple[float, ...]:
        """"""
        Gets the magnitude and phase of the mean of the raw real and imaginary
        part of the data. If the parameter `cw_check_sweep_first` is set to
        `True` for the instrument then at the cost of a few ms overhead
        checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        s = np.mean(i) + 1j * np.mean(q)
        return float(np.abs(s)), float(np.angle(s))


class FrequencySweepMagPhase(MultiParameter):
    """"""
    Sweep that return magnitude and phase.
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=("""", ""rad""),
            setpoint_units=((""Hz"",), (""Hz"",)),
            setpoint_labels=(
                (f""{instrument.short_name} frequency"",),
                (f""{instrument.short_name} frequency"",),
            ),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        # Needed to update config of the software parameter on sweep change
        # frequency setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        with self.instrument.format.set_to(""Complex""):
            data = self.instrument._get_sweep_data(force_polar=True)
        return abs(data), np.angle(data)



class FrequencySweepDBPhase(MultiParameter):
    """"""
    Sweep that return magnitude in decibel (dB) and phase in radians.
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=(""dB"", ""rad""),
            setpoint_units=((""Hz"",), (""Hz"",)),
            setpoint_labels=(
                (f""{instrument.short_name} frequency"",),
                (f""{instrument.short_name} frequency"",),
            ),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        # Needed to update config of the software parameter on sweep change
        # frequency setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        with self.instrument.format.set_to(""Complex""):
            data = self.instrument._get_sweep_data(force_polar=True)
        return 20*np.log10(np.abs(data)), np.angle(data)


class FrequencySweep(ArrayParameter):
    """"""
    Hardware controlled parameter class for Rohde Schwarz ZNB trace.

    Instrument returns an array of transmission or reflection data depending
    on the active measurement.

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
        start: starting frequency of sweep
        stop: ending frequency of sweep
        npts: number of points in frequency sweep

    Methods:
          get(): executes a sweep and returns magnitude and phase arrays

    """"""

    def __init__(
        self,
        name: str,
        instrument: Instrument,
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            shape=(npts,),
            instrument=instrument,
            unit=""dB"",
            label=f""{instrument.short_name} magnitude"",
            setpoint_units=(""Hz"",),
            setpoint_labels=(f""{instrument.short_name} frequency"",),
            setpoint_names=(f""{instrument.short_name}_frequency"",),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        """"""
        sets the shapes and setpoint arrays of the parameter to
        correspond with the sweep

        Args:
            start: Starting frequency of the sweep
            stop: Stopping frequency of the sweep
            npts: Number of points in the sweep

        """"""
        # Needed to update config of the software parameter on sweep change
        # freq setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = (f,)
        self.shape = (npts,)

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        return self.instrument._get_sweep_data()


class RohdeSchwarzZNBChannel(InstrumentChannel):
    def __init__(
        self,
        parent: ""ZNB"",
        name: str,
        channel: int,
        vna_parameter: Optional[str] = None,
        existing_trace_to_bind_to: Optional[str] = None,
    ) -> None:
        """"""
        Args:
            parent: Instrument that this channel is bound to.
            name: Name to use for this channel.
            channel: channel on the VNA to use
            vna_parameter: Name of parameter on the vna that this should
                measure such as S12. If left empty this will fall back to
                `name`.
            existing_trace_to_bind_to: Name of an existing trace on the VNA.
                If supplied try to bind to an existing trace with this name
                rather than creating a new trace.
        """"""
        n = channel
        self._instrument_channel = channel

        if vna_parameter is None:
            vna_parameter = name
        self._vna_parameter = vna_parameter
        super().__init__(parent, name)

        if existing_trace_to_bind_to is None:
            self._tracename = f""Trc{channel}""
        else:
            traces = self._parent.ask(""CONFigure:TRACe:CATalog?"")
            if existing_trace_to_bind_to not in traces:
                raise RuntimeError(
                    f""Trying to bind to""
                    f"" {existing_trace_to_bind_to} ""
                    f""which is not in {traces}""
                )
            self._tracename = existing_trace_to_bind_to

        # map hardware channel to measurement
        # hardware channels are mapped one to one to QCoDeS channels
        # we are not using sub traces within channels.
        if existing_trace_to_bind_to is None:
            self.write(
                f""CALC{self._instrument_channel}:PAR:SDEF""
                f"" '{self._tracename}', '{self._vna_parameter}'""
            )

        # Source power is dependent on model, but not well documented.
        # Here we assume -60 dBm for ZNB20, the others are set,
        # due to lack of knowledge, to -80 dBm as of before the edit.
        full_modelname = self._parent.get_idn()[""model""]
        if full_modelname is not None:
            model = full_modelname.split(""-"")[0]
        else:
            raise RuntimeError(""Could not determine ZNB model"")
        self._model_min_source_power = {
            ""ZNB4"": -80,
            ""ZNB8"": -80,
            ""ZNB20"": -60,
            ""ZNB40"": -60,
        }
        if model not in self._model_min_source_power.keys():
            raise RuntimeError(f""Unsupported ZNB model: {model}"")
        self._min_source_power: float
        self._min_source_power = self._model_min_source_power[model]

        self.add_parameter(
            name=""vna_parameter"",
            label=""VNA parameter"",
            get_cmd=f""CALC{self._instrument_channel}:PAR:MEAS? ""
                    f""'{self._tracename}'"",
            get_parser=self._strip,
        )
        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=f""SOUR{n}:POW?"",
            set_cmd=f""SOUR{n}:POW {{:.4f}}"",
            get_parser=float,
            vals=vals.Numbers(self._min_source_power, 25),
        )
        self.add_parameter(
            name=""bandwidth"",
            label=""Bandwidth"",
            unit=""Hz"",
            get_cmd=f""SENS{n}:BAND?"",
            set_cmd=self._set_bandwidth,
            get_parser=int,
            vals=vals.Enum(
                *np.append(10 ** 6,
                           np.kron([1, 1.5, 2, 3, 5, 7], 10 ** np.arange(6)))
            ),
            docstring=""Measurement bandwidth of the IF filter. ""
            ""The inverse of this sets the integration ""
            ""time per point. ""
            ""There is an 'increased bandwidth option' ""
            ""(p. 4 of manual) that does not get taken ""
            ""into account here."",
        )
        self.add_parameter(
            name=""avg"",
            label=""Averages"",
            unit="""",
            get_cmd=f""SENS{n}:AVER:COUN?"",
            set_cmd=f""SENS{n}:AVER:COUN {{:.4f}}"",
            get_parser=int,
            vals=vals.Ints(1, 5000),
        )
        self.add_parameter(
            name=""start"",
            get_cmd=f""SENS{n}:FREQ:START?"",
            set_cmd=self._set_start,
            get_parser=float,
            vals=vals.Numbers(self._parent._min_freq,
                              self._parent._max_freq - 10),
        )
        self.add_parameter(
            name=""stop"",
            get_cmd=f""SENS{n}:FREQ:STOP?"",
            set_cmd=self._set_stop,
            get_parser=float,
            vals=vals.Numbers(self._parent._min_freq + 1,
                              self._parent._max_freq),
        )
        self.add_parameter(
            name=""center"",
            get_cmd=f""SENS{n}:FREQ:CENT?"",
            set_cmd=self._set_center,
            get_parser=float,
            vals=vals.Numbers(
                self._parent._min_freq + 0.5, self._parent._max_freq - 10
            ),
        )
        self.add_parameter(
            name=""span"",
            get_cmd=f""SENS{n}:FREQ:SPAN?"",
            set_cmd=self._set_span,
            get_parser=float,
            vals=vals.Numbers(1,
                              self._parent._max_freq - self._parent._min_freq),
        )
        self.add_parameter(
            name=""npts"",
            get_cmd=f""SENS{n}:SWE:POIN?"",
            set_cmd=self._set_npts,
            get_parser=int,
        )
        self.add_parameter(
            name=""status"",
            get_cmd=f""CONF:CHAN{n}:MEAS?"",
            set_cmd=f""CONF:CHAN{n}:MEAS {{}}"",
            get_parser=int,
        )
        self.add_parameter(
            name=""format"",
            get_cmd=partial(self._get_format, tracename=self._tracename),
            set_cmd=self._set_format,
            val_mapping={
                ""dB"": ""MLOG\n"",
                ""Linear Magnitude"": ""MLIN\n"",
                ""Phase"": ""PHAS\n"",
                ""Unwr Phase"": ""UPH\n"",
                ""Polar"": ""POL\n"",
                ""Smith"": ""SMIT\n"",
                ""Inverse Smith"": ""ISM\n"",
                ""SWR"": ""SWR\n"",
                ""Real"": ""REAL\n"",
                ""Imaginary"": ""IMAG\n"",
                ""Delay"": ""GDEL\n"",
                ""Complex"": ""COMP\n"",
            },
        )

        self.add_parameter(
            name=""trace_mag_phase"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweepMagPhase,
        )

        self.add_parameter(
            name=""trace_db_phase"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweepDBPhase,
        )
        self.add_parameter(
            name=""trace"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweep,
        )
        self.add_parameter(
            name=""electrical_delay"",
            label=""Electrical delay"",
            get_cmd=f""SENS{n}:CORR:EDEL2:TIME?"",
            set_cmd=f""SENS{n}:CORR:EDEL2:TIME {{}}"",
            get_parser=float,
            unit=""s"",
        )
        self.add_parameter(
            name=""sweep_time"",
            label=""Sweep time"",
            get_cmd=f""SENS{n}:SWE:TIME?"",
            get_parser=float,
            unit=""s"",
        )
        self.add_parameter(
            name=""sweep_type"",
            get_cmd=f""SENS{n}:SWE:TYPE?"",
            set_cmd=self._set_sweep_type,
            val_mapping={
                ""Linear"": ""LIN\n"",
                ""Logarithmic"": ""LOG\n"",
                ""Power"": ""POW\n"",
                ""CW_Time"": ""CW\n"",
                ""CW_Point"": ""POIN\n"",
                ""Segmented"": ""SEGM\n"",
            },
            docstring=""The sweep_type parameter is used to set ""
            ""the type of measurement sweeps. It ""
            ""allows switching the default linear ""
            ""VNA sweep type to other types. Note that ""
            ""at the moment only the linear and ""
            ""CW_Point modes have supporting ""
            ""measurement parameters."",
        )
        self.add_parameter(
            name=""cw_frequency"",
            get_cmd=f""SENS{n}:FREQ:CW?"",
            set_cmd=self._set_cw_frequency,
            get_parser=float,
            vals=vals.Numbers(
                self._parent._min_freq + 0.5, self._parent._max_freq - 10
            ),
            docstring=""Parameter for setting frequency and ""
            ""querying for it when VNA sweep type is ""
            ""set to CW_Point mode."",
        )

        self.add_parameter(
            ""cw_check_sweep_first"",
            parameter_class=ManualParameter,
            initial_value=True,
            vals=vals.Bool(),
            docstring=""Parameter that enables a few commands ""
            ""which are called before each get in ""
            ""continuous wave mode checking whether ""
            ""the vna is setup correctly. Is recommended ""
            ""to be turned, but can be turned off if ""
            ""one wants to minimize overhead in fast ""
            ""measurements. "",
        )

        self.add_parameter(
            name=""trace_fixed_frequency"",
            npts=self.npts(),
            bandwidth=self.bandwidth(),
            parameter_class=FixedFrequencyTraceIQ,
        )
        self.add_parameter(
            name=""point_fixed_frequency"", parameter_class=FixedFrequencyPointIQ
        )
        self.add_parameter(
            name=""point_fixed_frequency_mag_phase"",
            parameter_class=FixedFrequencyPointMagPhase,
        )
        self.add_parameter(
            name=""averaging_enabled"",
            initial_value=False,
            get_cmd=None,
            set_cmd=self._enable_averaging,
            vals=vals.Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
        )
        self.add_parameter(
            name=""auto_sweep_time_enabled"",
            initial_value=False,
            get_cmd=None,
            set_cmd=self._enable_auto_sweep_time,
            vals=vals.Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""When enabled, the (minimum) sweep time is ""
            ""calculated internally using the other channel settings ""
            ""and zero delay"",
        )

        self.add_function(
            ""set_electrical_delay_auto"", call_cmd=f""SENS{n}:CORR:EDEL:AUTO ONCE""
        )
        self.add_function(
            ""autoscale"",
            call_cmd=f""DISPlay:TRACe1:Y:SCALe:AUTO ONCE, {self._tracename}"",
        )

    def _get_format(self, tracename: str) -> str:
        n = self._instrument_channel
        self.write(f""CALC{n}:PAR:SEL '{tracename}'"")
        return self.ask(f""CALC{n}:FORM?"")

    def _set_format(self, val: str) -> None:
        unit_mapping = {
            ""MLOG\n"": ""dB"",
            ""MLIN\n"": """",
            ""PHAS\n"": ""rad"",
            ""UPH\n"": ""rad"",
            ""POL\n"": """",
            ""SMIT\n"": """",
            ""ISM\n"": """",
            ""SWR\n"": ""U"",
            ""REAL\n"": ""U"",
            ""IMAG\n"": ""U"",
            ""GDEL\n"": ""S"",
            ""COMP\n"": """",
        }
        label_mapping = {
            ""MLOG\n"": ""Magnitude"",
            ""MLIN\n"": ""Magnitude"",
            ""PHAS\n"": ""Phase"",
            ""UPH\n"": ""Unwrapped phase"",
            ""POL\n"": ""Complex Magnitude"",
            ""SMIT\n"": ""Complex Magnitude"",
            ""ISM\n"": ""Complex Magnitude"",
            ""SWR\n"": ""Standing Wave Ratio"",
            ""REAL\n"": ""Real Magnitude"",
            ""IMAG\n"": ""Imaginary Magnitude"",
            ""GDEL\n"": ""Delay"",
            ""COMP\n"": ""Complex Magnitude"",
        }
        channel = self._instrument_channel
        self.write(f""CALC{channel}:PAR:SEL '{self._tracename}'"")
        self.write(f""CALC{channel}:FORM {val}"")
        self.trace.unit = unit_mapping[val]
        self.trace.label = f""{self.short_name} {label_mapping[val]}""

    @staticmethod
    def _strip(var: str) -> str:
        """"""Strip newline and quotes from instrument reply.""""""
        return var.rstrip()[1:-1]

    def _set_start(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:START {val:.7f}"")
        stop = self.stop()
        if val >= stop:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        # we get start as the vna may not be able to set it to the
        # exact value provided.
        start = self.start()
        if abs(val - start) >= 1:
            log.warning(
                ""Could not set start to {} setting it to ""
                ""{}"".format(val, start)
            )
        self.update_lin_traces()

    def _set_stop(self, val: float) -> None:
        channel = self._instrument_channel
        start = self.start()
        if val <= start:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        self.write(f""SENS{channel}:FREQ:STOP {val:.7f}"")
        # We get stop as the vna may not be able to set it to the
        # exact value provided.
        stop = self.stop()
        if abs(val - stop) >= 1:
            log.warning(
                ""Could not set stop to {} setting it to ""
                ""{}"".format(val, stop)
            )
        self.update_lin_traces()

    def _set_npts(self, val: int) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:POIN {val:.7f}"")
        if self.sweep_type().startswith(""CW""):
            self.update_cw_traces()
        else:
            self.update_lin_traces()

    def _set_bandwidth(self, val: int) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:BAND {val:.4f}"")
        self.update_cw_traces()

    def _set_span(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:SPAN {val:.7f}"")
        self.update_lin_traces()

    def _set_center(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:CENT {val:.7f}"")
        self.update_lin_traces()

    def _set_sweep_type(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:TYPE {val}"")

    def _set_cw_frequency(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:CW {val:.7f}"")

    def _enable_averaging(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:AVER:STAT {val}"")

    def _enable_auto_sweep_time(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:TIME:AUTO {val}"")

    @deprecate(reason=""the method has been renamed"",
               alternative=""update_lin_traces"")
    def update_traces(self) -> None:
        """""" updates start, stop and npts of all trace parameters""""""
        self.update_lin_traces()

    def update_lin_traces(self) -> None:
        """"""
        Updates start, stop and npts of all trace parameters
        so that the x-coordinates are updated for the sweep.
        """"""
        start = self.start()
        stop = self.stop()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, (FrequencySweep, FrequencySweepMagPhase, FrequencySweepDBPhase)):
                try:
                    parameter.set_sweep(start, stop, npts)
                except AttributeError:
                    pass

    def update_cw_traces(self) -> None:
        """"""
        Updates the bandwidth and npts of all fixed frequency (CW) traces.
        """"""
        bandwidth = self.bandwidth()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, FixedFrequencyTraceIQ):
                try:
                    parameter.set_cw_sweep(npts, bandwidth)
                except AttributeError:
                    pass
        self.sweep_time()

    def _get_sweep_data(self, force_polar: bool = False) -> np.ndarray:

        if not self._parent.rf_power():
            log.warning(""RF output is off when getting sweep data"")
        # It is possible that the instrument and QCoDeS disagree about
        # which parameter is measured on this channel.
        instrument_parameter = self.vna_parameter()
        if instrument_parameter != self._vna_parameter:
            raise RuntimeError(
                ""Invalid parameter. Tried to measure ""
                f""{self._vna_parameter} ""
                f""got {instrument_parameter}""
            )
        self.averaging_enabled(True)
        self.write(f""SENS{self._instrument_channel}:AVER:CLE"")

        # preserve original state of the znb
        with self.status.set_to(1):
            self.root_instrument.cont_meas_off()
            try:
                # if force polar is set, the SDAT data format will be used.
                # Here the data will be transferred as a complex number
                # independent of the set format in the instrument.
                if force_polar:
                    data_format_command = ""SDAT""
                else:
                    data_format_command = ""FDAT""

                with self.root_instrument.timeout.set_to(self._get_timeout()):
                    # instrument averages over its last 'avg' number of sweeps
                    # need to ensure averaged result is returned
                    for _ in range(self.avg()):
                        self.write(f""INIT{self._instrument_channel}:IMM; *WAI"")
                    self.write(
                        f""CALC{self._instrument_channel}:PAR:SEL ""
                        f""'{self._tracename}'""
                    )
                    data_str = self.ask(
                        f""CALC{self._instrument_channel}:DATA?""
                        f"" {data_format_command}""
                    )
                data = np.array(data_str.rstrip().split("","")).astype(""float64"")
                if self.format() in [""Polar"",
                                     ""Complex"",
                                     ""Smith"",
                                     ""Inverse Smith""]:
                    data = data[0::2] + 1j * data[1::2]
            finally:
                self.root_instrument.cont_meas_on()
        return data

    def setup_cw_sweep(self) -> None:
        """"""
        This method sets the VNA to CW mode. CW Mode sweeps are performed at
        fixed frequency and allow to perform measurements versus time instead
        of versus frequency.
        See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
        /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
        -> sweep type tab -> CW mode
        """"""

        # set the channel type to single point msmt
        self.sweep_type(""CW_Point"")
        # turn off average on the VNA since we want single point sweeps.
        self.averaging_enabled(False)
        # This format is required for getting both real and imaginary parts.
        self.format(""Complex"")
        # Set the sweep time to auto such that it sets the delay to zero
        # between each point (e.g msmt speed is optimized). Note that if one
        # would like to do a time sweep with time > npts/bandwidth, this is
        # where the delay would be set, but in general we want to measure as
        # fast as possible without artificial delays.
        self.auto_sweep_time_enabled(True)
        # Set cont measurement off here so we don't have to send that command
        # while measuring later.
        self.root_instrument.cont_meas_off()

    def setup_lin_sweep(self) -> None:
        """"""
        Setup the instrument into linear sweep mode.
        """"""
        self.sweep_type(""Linear"")
        self.averaging_enabled(True)
        self.root_instrument.cont_meas_on()

    def _check_cw_sweep(self) -> None:
        """"""
        Checks if all required settings are met to be able to measure in
        CW_point mode. Similar to what is done in get_sweep_data
        """"""
        if self.sweep_type() != ""CW_Point"":
            raise RuntimeError(
                f""Sweep type is not set to continuous wave ""
                f""mode, instead it is: {self.sweep_type()}""
            )

        if not self.root_instrument.rf_power():
            log.warning(""RF output is off when getting sweep data"")

        # It is possible that the instrument and QCoDeS disagree about
        # which parameter is measured on this channel.
        instrument_parameter = self.vna_parameter()
        if instrument_parameter != self._vna_parameter:
            raise RuntimeError(
                ""Invalid parameter. Tried to measure ""
                f""{self._vna_parameter} ""
                f""got {instrument_parameter}""
            )

        # Turn off average on the VNA since we want single point sweeps.
        self.averaging_enabled(False)
        # Set the format to complex.
        self.format(""Complex"")
        # Set cont measurement off.
        self.root_instrument.cont_meas_off()
        # Cache the sweep time so it is up to date when setting timeouts
        self.sweep_time()

    def _get_cw_data(self) -> tuple[np.ndarray, np.ndarray]:
        # Make the checking optional such that we can do super fast sweeps as
        # well, skipping the overhead of the other commands.
        if self.cw_check_sweep_first():
            self._check_cw_sweep()

        with self.status.set_to(1):
            with self.root_instrument.timeout.set_to(self._get_timeout()):
                self.write(f""INIT{self._instrument_channel}:IMM; *WAI"")
                data_str = self.ask(f""CALC{self._instrument_channel}:DATA? ""
                                    f""SDAT"")
            data = np.array(data_str.rstrip().split("","")).astype(""float64"")
            i = data[0::2]
            q = data[1::2]

        return i, q

    def _get_timeout(self) -> float:
        timeout = self.root_instrument.timeout() or float(""+inf"")
        timeout = max(self.sweep_time.cache.get() * 1.5, timeout)
        return timeout


ZNBChannel = RohdeSchwarzZNBChannel


class ZNB(VisaInstrument):
    """"""
    QCoDeS driver for the Rohde & Schwarz ZNB8 and ZNB20
    virtual network analyser. It can probably be extended to ZNB4 and 40
    without too much work.

    Requires FrequencySweep parameter for taking a trace

    Args:
        name: instrument name
        address: Address of instrument probably in format
            'TCPIP0::192.168.15.100::inst0::INSTR'
        init_s_params: Automatically setup channels for all S parameters on the
            VNA.
        reset_channels: If True any channels defined on the VNA at the time
            of initialization are reset and removed.
        **kwargs: passed to base class

    TODO:
    - check initialisation settings and test functions
    """"""

    CHANNEL_CLASS = ZNBChannel

    def __init__(
        self,
        name: str,
        address: str,
        init_s_params: bool = True,
        reset_channels: bool = True,
        **kwargs: Any,
    ) -> None:

        super().__init__(name=name, address=address, **kwargs)

        # TODO(JHN) I could not find a way to get max and min freq from
        # the API, if that is possible replace below with that
        # See page 1025 in the manual. 7.3.15.10 for details of max/min freq
        # no attempt to support ZNB40, not clear without one how the format
        # is due to variants
        fullmodel = self.get_idn()[""model""]
        if fullmodel is not None:
            model = fullmodel.split(""-"")[0]
        else:
            raise RuntimeError(""Could not determine ZNB model"")
        # format seems to be ZNB8-4Port
        m_frequency = {
            ""ZNB4"": (9e3, 4.5e9),
            ""ZNB8"": (9e3, 8.5e9),
            ""ZNB20"": (100e3, 20e9),
            ""ZNB40"": (10e6, 40e9),
        }
        if model not in m_frequency.keys():
            raise RuntimeError(f""Unsupported ZNB model {model}"")
        self._min_freq: float
        self._max_freq: float
        self._min_freq, self._max_freq = m_frequency[model]

        self.add_parameter(name=""num_ports"",
                           get_cmd=""INST:PORT:COUN?"",
                           get_parser=int)
        num_ports = self.num_ports()

        self.add_parameter(
            name=""rf_power"",
            get_cmd=""OUTP1?"",
            set_cmd=""OUTP1 {}"",
            val_mapping={True: ""1\n"", False: ""0\n""},
        )
        self.add_function(""reset"", call_cmd=""*RST"")
        self.add_function(""tooltip_on"", call_cmd=""SYST:ERR:DISP ON"")
        self.add_function(""tooltip_off"", call_cmd=""SYST:ERR:DISP OFF"")
        self.add_function(""cont_meas_on"", call_cmd=""INIT:CONT:ALL ON"")
        self.add_function(""cont_meas_off"", call_cmd=""INIT:CONT:ALL OFF"")
        self.add_function(""update_display_once"", call_cmd=""SYST:DISP:UPD ONCE"")
        self.add_function(""update_display_on"", call_cmd=""SYST:DISP:UPD ON"")
        self.add_function(""update_display_off"", call_cmd=""SYST:DISP:UPD OFF"")
        self.add_function(
            ""display_sij_split"",
            call_cmd=f""DISP:LAY GRID;:DISP:LAY:GRID {num_ports},{num_ports}"",
        )
        self.add_function(
            ""display_single_window"", call_cmd=""DISP:LAY GRID;:DISP:LAY:GRID 1,1""
        )
        self.add_function(
            ""display_dual_window"", call_cmd=""DISP:LAY GRID;:DISP:LAY:GRID 2,1""
        )
        self.add_function(""rf_off"", call_cmd=""OUTP1 OFF"")
        self.add_function(""rf_on"", call_cmd=""OUTP1 ON"")
        if reset_channels:
            self.reset()
            self.clear_channels()
        channels = ChannelList(
            self, ""VNAChannels"", self.CHANNEL_CLASS, snapshotable=True
        )
        self.add_submodule(""channels"", channels)
        if init_s_params:
            for i in range(1, num_ports + 1):
                for j in range(1, num_ports + 1):
                    ch_name = ""S"" + str(i) + str(j)
                    self.add_channel(ch_name)
            self.display_sij_split()
            self.channels.autoscale()

        self.update_display_on()
        if reset_channels:
            self.rf_off()
        self.connect_message()

    def display_grid(self, rows: int, cols: int) -> None:
        """"""
        Display a grid of channels rows by columns.
        """"""
        self.write(f""DISP:LAY GRID;:DISP:LAY:GRID {rows},{cols}"")

    def add_channel(self, channel_name: str, **kwargs: Any) -> None:
        i_channel = len(self.channels) + 1
        channel = self.CHANNEL_CLASS(self, channel_name, i_channel, **kwargs)
        self.channels.append(channel)
        if i_channel == 1:
            self.display_single_window()
        if i_channel == 2:
            self.display_dual_window()
        # shortcut
        setattr(self, channel_name, channel)
        # initialising channel
        self.write(f""SENS{i_channel}:SWE:TYPE LIN"")
        self.write(f""SENS{i_channel}:SWE:TIME:AUTO ON"")
        self.write(f""TRIG{i_channel}:SEQ:SOUR IMM"")
        self.write(f""SENS{i_channel}:AVER:STAT ON"")

    def clear_channels(self) -> None:
        """"""
        Remove all channels from the instrument and channel list and
        unlock the channel list.
        """"""
        self.write(""CALCulate:PARameter:DELete:ALL"")
        for submodule in self.submodules.values():
            if isinstance(submodule, ChannelList):
                submodule.clear()
"
367,https://www.keysight.com/us/en/assets/7018-04096/data-sheets/5991-3131.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attCdDa2jS5fYORnA'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gog00FWrnBVp7ooAeqESaA/hdXnMyFf5FEHJLlc5-74Ot96C05r8SOra8bGS8kYlMJZ56s_tfZjCC7CheL6DcktadjuyCeCI-CProMyz8qIaq4uW8t50B-kjVRLYfladaw/ti-zZg1EPN-i-A_NS3Yrl910DUhtOuxiQWqEUWPIOUM'), ('filename', 'N5183B_2_1600x900.png'), ('size', 738895), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/xWLRKMqXhEo2hNLiogTnHw/Acd3VNfEIaGWhTZx3lYPZJVRN8HKb0cA-NcLeA3tINcgL5aOw5etYwXo2ASxnwHnaMbnneR7uX7qGiFahmzkWA/qr_ssFe19GagzEqkehGtoKAEzpkJGa0s0WOTnN5ez1s'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/F9mTcEj0sw7rjItJRGuBEA/AZAad0HS28ql3JbHjgwfuIceo4Qqx8eUn9l9Dl8E9TTnbartBnouc7t6zRSDaIMCY-c8ZaPtV9oeWPUFnGWcyw/mv4-c2Y9CSkZmUadPGTMcwIw2qEyrT8UlGIUDZXxg7s'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/aW5jhh_FUX4tP7vQkYROtw/w-5AFGPXM2s2SQCb9jwIoZYO3tuNoRrxTbToL92Mk1lxcIrmCLnOZIXkR22MbxujvRVB44bko3bGFAzjOBC4tA/mbd885wTnapuq5NeRhOmVECQMHanG3B-FEEigXYiBHA'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"N5183B MXG X-Series microwave analog signal generator offers 9 kHz to 40 GHz frequency coverage and near PSG levels of phase noise performance.

",https://www.keysight.com/us/en/product/N5183B/mxg-x-series-microwave-analog-signal-generator-9-khz-40-ghz.html,Keysight N 5183 B,278.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_N5183B.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5183B,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782749/Instruments/RF%20Signal%20Generator/Keysight-N5183B-MXG/Keysight-N5183B-MXG.png,Keysight N5183B MXG,Write a Python script that uses Qcodes to connect to a Keysight N5183B MXG RF Signal Generator,43091.0,,,,"from typing import Any

from qcodes.instrument_drivers.Keysight.N51x1 import N51x1


class KeysightN5183B(N51x1):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, min_power=-20, max_power=19, **kwargs)


class N5183B(KeysightN5183B):
    """""" ""
    Alias for backwards compatiblitly

    """"""
"
370,https://download.tek.com/datasheet/AWG70000B-Arbitrary-Waveform-Generator-Datasheet-76W614122.pdf,https://en.wikipedia.org/wiki/Signal_generator,"[OrderedDict([('id', 'attXtl7MGQfCPYnOG'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/1dxnft2nX4yxbxUwbI_xdQ/9pB8umdMv_855Lwkm-VPMrhnFFjUuSHPeX2WiKu472dCE6MaGRz-PbRW1HOCHaoI72ZYxtgVb1ZkIbVFRdmQpxfSLpE1qoW5EBVPxIzPudCXETXoX_aXDLSa4D3FREtm/zdRwkw1olI6xt1zRZD_Q4X4gESxM8BKDYOoozKH5VDI'), ('filename', 'tektronix_awg70002a-1.jpg'), ('size', 47210), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/OucXh6TVcaxMj1wXA7_nlQ/Nbh84ZRa7eDny8CQ91cB_FhyaDvyHf5As1-EbNdeAPzkZBL3JBtypKxiAjgh3S7oQjfmSuqzuBzZ71DGv6uNkw/2_YTxDUL0lmC2oJxYFLiD4TgNynPASbqy43tSu28O7A'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4onnkhnRKrFRZEy71d4S7Q/D3ztBx53GxrHabZRijCLbrRLBIRjkHrVGl2g6krozvck1YFYfCl8HjUYb1DMSMdAUrRPlHmbsRo-UFpDNapoRQ/a4pBFPh9wClCghU62v8ElOVOmoDrc57dcFIVLta6CoY'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DOBW4rqEW2HrLyQjBU00Pg/18PZfhYvMdFLi5pTRU2gEyP7vq8AmRIl9KYGVzNr5CCd94VAEId_311hnd46Sqrk_9ftETvZU36lBg2f5Eyd3A/LXFIF8sBhgfkpsqRl3coL2QrTifphdzvfV3296dXkGw'), ('width', 3000), ('height', 3000)]))]))])]",5800.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116671/Instruments/Vendor%20Logos/Tektronix.png,"The AWG70000B Series Arbitrary Waveform Generator represents the cutting edge in sample rate, signal fidelity and waveform memory, making it ideal for design, testing and operations of complex components, systems and experiments. With up to sample rate of 50 GS/s and 10-bit vertical resolution, it delivers the industry's best signal stimulus solution for easy generation of ideal, distorted and “real-life” signals.",https://www.tek.com/en/products/arbitrary-waveform-generators/awg70000,Tektronix 70002 B,544.0,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well","Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70002B,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/nnBvPFtDKyvmcbmSqRfUgw/kl0g1_CPWs2u8OLJa01vfkYJ3irXhXP2gwH8HQ5Dec7IAZiDP1D0Ebb6Cu65sdjpdVb_14Saqj4U3beju_ihlg/EmnIBg-DDSjrNsNjacwfDBkG2kyUtCzUsPfocjmcxQk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ZX1j5wMDypIYjfVz8EGww/rew812jBt6gK6-aUkKYgo-lv5EazVteK4l0OrZHpphRGmbnPva-egDgoeDilJ6I37c0oVQDxKG2aSL113Z5qeA/6nEhucAt_EEIoG2k4iHWnY3O34fiP9QbfuNseGQSas8'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jGvxb0D3MLS_6_5nxAlbJQ/qEwTdpdALZ6kebqUAjpDBFAjoV9CYvNGL4gl57OybmH0WLMdHOYlHX5a0Rzm06n6xjDllUlxoLfgFN0mGQALxA/oJjG1FDJ6oGeXrrhVYxJ5JRG-N5oRcpxBZwroLVQsx4'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0XfNVcDdHV5oz2LmbuutBA/U0WYflDJTcSsm1wyQVyd0lSqv6DRoyOvQvYlrCnMI0SuwDZ3pewArjm-Qm1fj_vvSbqgVLfCsrlMRaTl14fQ0A/31X_hphuH9EMrZWEiZr_2THnTQpmqANG7Nz5Aufgh6U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782752/Instruments/RF%20Signal%20Generator/AWG70002B/AWG70002B.jpg,AWG70002B,Write a Python script that uses Qcodes to connect to a AWG70002B RF Signal Generator,122000.0,,,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
372,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,https://en.wikipedia.org/wiki/Power_supply,"[OrderedDict([('id', 'att9FGzGap5vt23ON'), ('width', 800), ('height', 522), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LTc2h8uQSrgrspIqtp1big/yuIxn3FQTFufJ1yd2cSie7Xi3kIVh4HUPfSQ8pH59j2jC0P3HAOZNZXBLc_MJSeTs2Ps6HRbSKKaKDqbxajbn4eDTZJu77bEnCwKCuFQujU/F5GkP4ebOdtui49hIv9XcDBPGuPH0EYXQ1pLW18S_7Y'), ('filename', 'Rigol-DP8xx-Series.jpg'), ('size', 86105), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_qNYoiJUxpq1_v8rCh5pgg/iKp7s99--mHTQ6Zyux9cdPdzZxWTbolQ4yhGfdQayNp8GQXsIPnkG5qYZ0l706MGYnmUwLgHawTakdgxDS7PIw/hYTWgbJPJcqyUiQGIKgPr58_hC-w_L2KkyPRVlJ7dnk'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/7ivDIBBeTI6agsES_ejlVw/qk4fgIukqHDngoYK9C2B9M_OISUnxsS7suTcksGoHAqp3TK2O_wL97vppv2sfxd2FfnfTHh9ODJ3FkrabAx9dw/ORsi5DGB8aoP3LjDV2ZxCOJqvL0rABAa6L4ZpYrxxS8'), ('width', 785), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ctD_z8mKFiebLk9Ul5BMMA/i5AccNzbkRsW8t68SvXdBY2bwyWjZbu7EChimJc9ANsF1-bstFy4rYXib2R9kEGPUzymQn-h_OIhJ3_Kb3VTCg/D2DDZZ3rUF21iFEvnPPsXHf6uyAzfihwhCZ1d8FPCw0'), ('width', 3000), ('height', 3000)]))]))])]",23.0,"Beijing, China",https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116706/Instruments/Vendor%20Logos/Rigol.png,"The DP800 Series Power Supplies combine the ability to source, analyze, and coordinate over time on a powerful platform. The DP800 Series is a family of linear power supplies systems with 1, 2, or 3 outputs and 140 to 200 Watts in total. With one channel isolated users can reconfigure instruments into any number of systems or applications. Built in V, A, and W measurements make power monitoring easy, but additional wave tracking, timing, and analysis features in the advanced ""A"" models means there are even more ways to use the instruments. Digital triggering between instruments also makes it possible to reliably combine and connect supplies together. Intuitive to use for everything from education labs to the R & D bench, the DP800 family of power supplies provide incredible value for any application. Select the value models for best price performance or upgrade to the ""A"" model to improve resolution and add advanced monitoring, triggering, and programming capabilities.",https://www.rigolna.com/products/dc-power-loads/dp800/,Private,455.0,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.","RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/private/DP8xx.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP821,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/NKEq_V1iE6Nn7IP67x7xfQ/FPKF-_mOdSAxq3d7D-uhErY9l9KGYIFxFacfqQ4_4b7OPoqxJpHRQ-UOpZ0o_HAVaxISaGT0TmTNk46Wnzzt5YXB0ER3lzkKfZ9fl5C2waf61FOY5_WEets9Y5DPJCYw/MikyH8nXojQyGMPT1f8XBV4U0NjloGaC3WcQhuDqhCA'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZSqXlisBnt9GRJ23d7_fBw/fOr-5djjO7_BfY5_LNJDDY_iDTJKX8vAzxWyX1ammXblLZ707GTo1YpjZralbCVd238xu6pQ9CmcAhTnHzL4WA/GcN5vZrnjr3_cFs9gZQy6aW1A41dtClpObWDpGrXpzI'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/-CIPfgyWiJTgqif-XFXyuw/SQQerj-SD5Xf3lwnAscI_us_ZG7S2X4RgmL5ZJgdY8jpRrmduaHsIO1x2YJRBGCKf3m3Okt1eozrdVM_IY8kFQ/LXi4kgkzDSeEnr2106Ie3Q80QdyErPQytHlkxM5HIhg'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jopBw8S1kJzCB42o-D9xPw/GCZlSk6Nc0mXqpB8AgC-75f-r2-0vOMRFGEBXKXCRkhfizsSRs4dH4BsrsUJVv0EjPsiYbsAm38KNpgStTGlEA/ZGdTPSgIVjitr_AQfVXVsOrYpFB4C5HTxLiRvLy7zT0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782754/Instruments/Power%20Supplies/Rigol-DP8xx-Series/Rigol-DP8xx-Series.jpg,Rigol DP8xx-Series,Write a Python script that uses Qcodes to connect to a Rigol DP8xx-Series Power Supplies,,,,,"from collections.abc import Sequence
from typing import Any

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument


class RigolDP8xxChannel(InstrumentChannel):
    def __init__(
        self,
        parent: ""_RigolDP8xx"",
        name: str,
        channel: int,
        ch_range: tuple[float, float],
        ovp_range: tuple[float, float],
        ocp_range: tuple[float, float],
    ):
        super().__init__(parent, name)

        self.vmax = ch_range[0]
        self.imax = ch_range[1]
        self.ovp_range = ovp_range
        self.ocp_range = ocp_range

        select_cmd = f"":INSTrument:NSELect {channel};""

        def strstrip(s: str) -> str:
            return str(s).strip()

        self.add_parameter(""set_voltage"",
                           label='Target voltage output',
                           set_cmd=""{} :SOURce:VOLTage:LEVel:IMMediate:AMPLitude {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :SOURce:VOLTage:LEVel:IMMediate:AMPLitude?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                           vals=vals.Numbers(min(0, self.vmax), max(0, self.vmax))
                          )
        self.add_parameter(""set_current"",
                           label='Target current output',
                           set_cmd=""{} :SOURce:CURRent:LEVel:IMMediate:AMPLitude {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :SOURce:CURRent:LEVel:IMMediate:AMPLitude?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           vals=vals.Numbers(0, self.imax)
                           )
        self.add_parameter('state',
                           label='Output enabled',
                           set_cmd='{} :OUTPut:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :OUTPut:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )
        self.add_parameter('mode',
                           label='Get the output mode',
                           get_cmd=f'{select_cmd} :OUTPut:MODE?',
                           get_parser=strstrip,
                           val_mapping={'ConstantVoltage': 'CV',
                                        'ConstantCurrent': 'CC',
                                        'Unregulated': 'UR'}
                          )
        self.add_parameter(""voltage"",
                           label='Measured voltage',
                           get_cmd=""{} :MEASure:VOLTage:DC?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                          )
        self.add_parameter(""current"",
                           label='Measured current',
                           get_cmd=""{} :MEASure:CURRent:DC?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           )
        self.add_parameter(""power"",
                           label='Measured power',
                           get_cmd=""{} :MEASure:POWer?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='W',
                           )
        self.add_parameter(""ovp_value"",
                           label='Over Voltage Protection value',
                           set_cmd=""{} :VOLTage:PROTection:LEVel {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :VOLTage:PROTection:LEVel?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                           vals=vals.Numbers(self.ovp_range[0], self.ovp_range[1])
                           )
        self.add_parameter('ovp_state',
                           label='Over Voltage Protection status',
                           set_cmd='{} :VOLTage:PROTection:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :VOLTage:PROTection:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )
        self.add_parameter(""ocp_value"",
                           label='Over Current Protection value',
                           set_cmd=""{} :CURRent:PROTection:LEVel {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :CURRent:PROTection:LEVel?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           vals=vals.Numbers(self.ocp_range[0], self.ocp_range[1])
                           )
        self.add_parameter('ocp_state',
                           label='Over Current Protection status',
                           set_cmd='{} :CURRent:PROTection:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :CURRent:PROTection:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )


class _RigolDP8xx(VisaInstrument):
    """"""
    This is the general DP8xx Power Supply driver class that implements shared parameters and functionality
    among all similar power supply from Rigole.

    This driver was written to be inherited from by a specific driver (e.g. DP832).
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        channels_ranges: Sequence[tuple[float, float]],
        ovp_ranges: tuple[Sequence[tuple[float, float]], Sequence[tuple[float, float]]],
        ocp_ranges: tuple[Sequence[tuple[float, float]], Sequence[tuple[float, float]]],
        **kwargs: Any,
    ):
        super().__init__(name, address, **kwargs)

        # Check if precision extension has been installed
        opt = self.installed_options()
        if 'DP8-ACCURACY' in opt:
            ovp_ranges_selected = ovp_ranges[1]
            ocp_ranges_selected = ocp_ranges[1]
        else:
            ovp_ranges_selected = ovp_ranges[0]
            ocp_ranges_selected = ocp_ranges[0]

        # channel-specific parameters
        channels = ChannelList(self, ""SupplyChannel"", RigolDP8xxChannel, snapshotable=False)
        for ch_num, channel_range in enumerate(channels_ranges):
            ch_name = f""ch{ch_num + 1}""
            channel = RigolDP8xxChannel(
                self,
                ch_name,
                ch_num + 1,
                channel_range,
                ovp_ranges_selected[ch_num],
                ocp_ranges_selected[ch_num]
            )
            channels.append(channel)
            self.add_submodule(ch_name, channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        self.connect_message()

    def installed_options(self) -> list[str]:
        """"""Return the installed options""""""

        opt = self.ask(""*OPT?"")
        optl = opt.strip().split(',')
        optl_clean = [x for x in optl if x != '0']
        return optl_clean
"
382,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,"[OrderedDict([('id', 'attSmxnTV0u8N4UA6'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/4yc0wEZl_PqHnfdXN_SBZA/oi_nhD_VsMoWHg5hsOLYsYOyz7dqzSaPtSQsiLg6AkHA0zSnexGsggI_LbIbJQxGUsFcfNGC83vEtNeM-xNtqf8dMOqdKGjus4dOMDunSzk/5KuQ_qO8CGo7Ot7By96Jk_zIAdibaJuA3Cp41EK6y0Q'), ('filename', 'PL155P-1000px.jpg'), ('size', 158529), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/RfgP7RfRzwGPwIo3lmEP6A/Q9vKKOyC-2VRPHiVMUIgRWbQfdatYhV42sX4lpfG28INDaosiKBvFA7RlhIv1FcRSLoPq3m0E4Cyt8OVLU9_RQ/DxHtUn5wzUbsfyKztrB2sv1ebp9ehuu6ADBhLyzE7TQ'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/rNXkIT_Gds8Ehg5D5OteZA/cftlhVvG-C3USBEjata9zsP7wJ-Z8Bp-boYteCYhZ1jjLaVWMpSuEQctxUTagt18MIFnj9IWNklQIkkIMpVTbA/HkMIyuzdMXbF2jRZvsGJhYoP2j7OJRAqMUAF3wmfAl0'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DcF5HrjqglGo8WmWQFXjWQ/ZRxYouJXo5axHw72KO9GpgRtkU6n5tWZ5DUPKQI0xCRib0eMAcMSKfOnIOSc9Ta1pfNkvvj-KzbsrbL1OfJtHA/7EW7HhVtph4aQYHyUAuBfaXx6qUP2jdW78CJDz-Jbbk'), ('width', 3000), ('height', 3000)]))]))])]",9000.0,UK,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116679/Instruments/Vendor%20Logos/Aimtti.png,"Bench/System Linear Regulated DC Power Supply Single Output, 15V/5A, USB, RS232, LAN(LXI) and Analogue Interfaces
",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,AIM TTI PL 155 P,50.0,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
","TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/AimTTi/_AimTTi_PL_P.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html#qcodes.instrument_drivers.AimTTi.AimTTiPL155P,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/gFSbEZDoS4XDXg-zNIb4LA/pZy5A-_LpOdPqGCHU2PWQZRzC2z-WXxme705lPm6zrk1SULkXOWFhMN5imvl93YPHXssgr8sUiPUD_muY8W4wTCbuLpaQzDFtqYKUdZczV8/LNFv0u6kiuAzpw1e7BPqEZQGyJS1z6mp8RZZAiR8bzY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/pA9Wtv9X_yENhc4qkEzvLg/x6XDHNYOrTyIWHhIL-92Mio0NYdQwJP0iI-4Z62z9nXNe-XUZ6HMxlPXf98rogYqiAz-sXIhl4EJudbCErAYLg/PlLVNE9zLCVYtl70cTIGsHgvPfMM4Li32MxWFH1O0_o'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Gu8zfqPa7SoPdZawbMZRpg/ckyZQQwaUkbziX8nXrwq10fVwOIA9sTH6Sab-1jREYz7KrxNMtWlusPGhVfeokiUHJmaQwUnD7wxP3CMW4E02g/Uw1Vj8IWV5YPcmK60JkCz-5XNGM_r6Jg6CN-KzP2f9k'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6GtGalIbrxdVl0OyaVTp7A/Lzl41CtRM0BrGjgb31rLNmPC3fQAyNsQPDQlRFGZBouw4ZuD1uC5HbwimScu7KG5-0X3eGDXciGuhNHMNlC_Qw/okaN-IthZGujMbRJQOz0HCzoYK7nsBViLAc7Q8vf7Qo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782760/Instruments/Power%20Supplies/PL155-P/PL155-P.jpg,PL155-P,Write a Python script that uses Qcodes to connect to a PL155-P Power Supplies,700.0,"
",,,"from typing import Any, Optional

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class NotKnownModel(Exception):
    """"""
    An Error thrown when connecting to an unknown Aim TTi model
    """"""

    pass


class AimTTiChannel(InstrumentChannel):
    """"""
    This is the class that holds the output channels of AimTTi power
    supply.
    """"""

    def __init__(
        self, parent: Instrument, name: str, channel: int, **kwargs: Any
    ) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The 'colloquial' name of the channel.
            channel: The name used by the AimTTi.
        """"""
        super().__init__(parent, name, **kwargs)

        self.channel = channel
        # The instrument can store up to ten configurations
        # internally.
        self.set_up_store_slots = [i for i in range(0, 10)]

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_voltage_value,
            get_parser=float,
            set_cmd=f""V{channel} {{}}"",
            label=""Voltage"",
            unit=""V"",
        )

        self.add_parameter(
            ""volt_step_size"",
            get_cmd=self._get_voltage_step_size,
            get_parser=float,
            set_cmd=f""DELTAV{channel} {{}}"",
            label=""Voltage Step Size"",
            unit=""V"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_current_value,
            get_parser=float,
            set_cmd=f""I{channel} {{}}"",
            label=""Current"",
            unit=""A"",
        )

        self.add_parameter(
            ""curr_range"",
            get_cmd=f""IRANGE{channel}?"",
            get_parser=int,
            set_cmd=self._set_current_range,
            label=""Current Range"",
            unit=""A"",
            vals=vals.Numbers(1, 2),
            docstring=""Set the current range of the output.""
            ""Here, the integer 1 is for the Low range, ""
            ""and integer 2 is for the High range."",
        )

        self.add_parameter(
            ""curr_step_size"",
            get_cmd=self._get_current_step_size,
            get_parser=float,
            set_cmd=f""DELTAI{channel} {{}}"",
            label=""Current Step Size"",
            unit=""A"",
        )

        self.add_parameter(
            ""output"",
            get_cmd=f""OP{channel}?"",
            get_parser=float,
            set_cmd=f""OP{channel} {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

    def _get_voltage_value(self) -> float:
        channel_id = self.channel
        _voltage = self.ask_raw(f""V{channel_id}?"")
        _voltage_split = _voltage.split()
        return float(_voltage_split[1])

    def _get_current_value(self) -> float:
        channel_id = self.channel
        _current = self.ask_raw(f""I{channel_id}?"")
        _current_split = _current.split()
        return float(_current_split[1])

    def _get_voltage_step_size(self) -> float:
        channel_id = self.channel
        _voltage_step_size = self.ask_raw(f""DELTAV{channel_id}?"")
        _v_step_size_split = _voltage_step_size.split()
        return float(_v_step_size_split[1])

    def _get_current_step_size(self) -> float:
        channel_id = self.channel
        _current_step_size = self.ask_raw(f""DELTAI{channel_id}?"")
        _c_step_size_split = _current_step_size.split()
        return float(_c_step_size_split[1])

    def _set_current_range(self, val: int) -> None:
        """"""
        This is the private function that ensures that the output is switched
        off before changing the current range, as pointed out by the instrument
        manual.
        """"""
        channel_id = self.channel
        with self.output.set_to(False):
            self.write(f""IRANGE{channel_id} {val}"")

    def increment_volt_by_step_size(self) -> None:
        """"""
        A bound method that increases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def decrement_volt_by_step_size(self) -> None:
        """"""
        A bound method that decreases the voltage output of the corresponding
        channel by an amount the step size set by the user via ``volt_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECV{channel_id}"")
        # Clear the cache.
        _ = self.volt.get()

    def increment_curr_by_step_size(self) -> None:
        """"""
        A bound method that increases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""INCI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def decrement_curr_by_step_size(self) -> None:
        """"""
        A bound method that decreases the current output of the corresponding
        channel by an amount the step size set by the user via ``curr_step_size``
        parameter.
        """"""
        channel_id = self.channel
        self.write(f""DECI{channel_id}"")
        # Clear the cache.
        _ = self.curr.get()

    def save_setup(self, slot: int) -> None:
        """"""
        A bound function that saves the output setup to the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""SAV{channel_id} {slot}"")

    def load_setup(self, slot: int) -> None:
        """"""
        A bound function that loadss the output setup from the internal
        store specified by the numbers 0-9.
        """"""
        if slot not in self.set_up_store_slots:
            raise RuntimeError(""Slote number should be an integer between"" ""0 adn 9."")

        channel_id = self.channel
        self.write(f""RCL{channel_id} {slot}"")
        # Update snapshot after load.
        _ = self.snapshot(update=True)

    def set_damping(self, val: int) -> None:
        """"""
        Sets the current meter measurement averaging on and off.
        """"""
        if val not in [0, 1]:
            raise RuntimeError(
                ""To 'turn on' and 'turn off' the averaging, ""
                ""use '1' and '0', respectively.""
            )
        channel_id = self.channel
        self.write(f""DAMPING{channel_id} {val}"")


class AimTTi(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Aim TTi PL-P series power supply.
    Tested with Aim TTi PL601-P equipped with a single output channel.
    """"""

    _numOutputChannels = {
        ""PL068-P"": 1,
        ""PL155-P"": 1,
        ""PL303-P"": 1,
        ""PL601-P"": 1,
        ""PL303QMD-P"": 2,
        ""PL303QMT-P"": 3,
        ""QL355TP"": 3,
    }

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS.
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""Channels"", AimTTiChannel, snapshotable=False)

        _model = self.get_idn()[""model""]

        if (_model not in self._numOutputChannels.keys()) or (_model is None):
            raise NotKnownModel(""Unknown model, connection cannot be "" ""established."")

        self.numOfChannels = self._numOutputChannels[_model]
        for i in range(1, self.numOfChannels + 1):
            channel = AimTTiChannel(self, f""ch{i}"", i)
            channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()

    # Interface Management

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Returns the instrument identification including vendor, model, serial
        number and the firmware.
        """"""
        IDNstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, IDNstr.split("",""))

        IDN: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return IDN

    def get_address(self) -> int:
        """"""
        Returns the bus address.
        """"""
        busAddressStr = self.ask_raw(""ADDRESS?"")
        busAddress = busAddressStr.strip()
        return int(busAddress)

    def get_IP(self) -> str:
        """"""
        Returns the IP address of the LAN interface, if the connection exists.
        If there is a pre-configured static IP and the instrument is not
        connected to a LAN interface, that static IP will be returned.
        Otherwise, the return value is '0.0.0.0'.
        """"""
        ipAddress = self.ask_raw(""IPADDR?"")
        return ipAddress.strip()

    def get_netMask(self) -> str:
        """"""
        Returns the netmask of the LAN interface, if the connection exists.
        """"""
        netMask = self.ask_raw(""NETMASK?"")
        return netMask.strip()

    def get_netConfig(self) -> str:
        """"""
        Returns the means by which an IP address is acquired, i.e.,
        DHCP, AUTO or STATIC.
        """"""
        netConfig = self.ask_raw(""NETCONFIG?"")
        return netConfig.strip()

    def local_mode(self) -> None:
        """"""
        Go to local mode until the next remote command is recieved. This
        function does not release any active interface lock.
        """"""
        self.write(""LOCAL"")

    def is_interface_locked(self) -> int:
        """"""
        Returns '1' if the interface lock is owned by the requesting instance,
        '0' if there is no active lock and '-1' if the lock is unavailable.
        """"""
        is_lockedSTR = self.ask_raw(""IFLOCK?"")
        is_locked = is_lockedSTR.strip()
        return int(is_locked)

    def lock_interface(self) -> int:
        """"""
        Requests instrument interface lock. Returns '1' if successful and
        '-1' if the lock is unavailable.
        """"""
        lockSTR = self.ask_raw(""IFLOCK"")
        lock = lockSTR.strip()
        return int(lock)

    def unlock_interface(self) -> int:
        """"""
        Requests the release of instrument interface lock. Returns '0'
        if successful and '-1' if unsuccessful.
        """"""
        unlockSTR = self.ask_raw(""IFUNLOCK"")
        unlock = unlockSTR.strip()
        return int(unlock)
"
389,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,https://en.wikipedia.org/wiki/Multimeter,"[OrderedDict([('id', 'attsytGLFo343EuCO'), ('width', 300), ('height', 225), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/LhrgwV8CuLtjNXqHWJJ5tg/My_jpUAh9HQnPkKJusNbwtt4RkP8vCd50NAMheJsNu715NXnn4WGpzNeQ-yjQCoDQBNshoQdtHlOaHJENgj-fldCeGzhhoDe1xzQSQLXpUcH7DLbK28lwJqRqFzS8t7r/XgWa52mRhO0z46y0vBt0BK2-AcEYJtGbFOgXJ4RKOZ0'), ('filename', 'keysight-34470-multimeter.jpg'), ('size', 37141), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/f-X7xRtWDVZLPkECIeHLQg/xzv1TPUxNqPdA-xb6y1t5d9-Lnm2p1_RH51rkIP6S7szaN_Kyq3XYmiaoSZg0n1DLzVm1kj4MvewwxAATWqVfA/MR_Sz1W5lnUb9oYo5etkJDS69ZsNVaFj6zF_7RQe5zc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/v-hJanUKCCJHKm-NXGTb3g/u1KBHbK2LeR60BMiR2B6Lt5YXvikGpWP3cSvciEeA6IgrsahOoo6-YFCCMR-bihoHpnIqa6mCcpeg1HkBr_PaQ/ABtCndqVjhD4edJgUGs7VPwD87pR372OBxaSbSOv7i8'), ('width', 300), ('height', 225)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/jdJ6qjfd0tJmPOh4luz-lg/0q6RHJiVHBMjgP5-hKbAxzctmh7dhxHacEzhyFDBcBNxq2nDsWqcGuc6c1qcCgyw8LeW0z1d35PZStYvUl2w0A/JyoMgdZzio9_DT5mLUwm9guJds8FuPTUuCdWf_fh0Dc'), ('width', 3000), ('height', 3000)]))]))])]",5420.0,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116692/Instruments/Vendor%20Logos/Keysight.png,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,Keysight 34470 A Submodules,275.0,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.","Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34470A_submodules.py,Qcodes,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34470A,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/B6JP97tefGr73h9JME76qw/-sc056QvnU31vjGD3KW61nQL7K0GhLRPhsFhrShFcgzey074qScZAmxAkDn9qtoufuljPvYGQTtgIyxfWK4d6zMHbxJRfztDsRmtG7B5ZFo/v2fAdy_8jrIooZdxxqzzMh7jKeBkF_crXyUEhwKgeY0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/w1T-x1B_2dg5gwKtxE4ZJA/OlO4SSghI0FyWPB6t58G6TQs2X37xlmxzd9gVL3h_81CNpEfECiA9nB2T6bi0nP-cwxhMCxnW5nivMhEpzO9wYobNzaYtkKwaDFQynKWLOM/D5yacguAv4xY1oRCp4Xk7GPo_Djvu3CD-gNOyawYqfs'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/0lj9F-mxou1dKBBiO8oPAw/4Vx7DdbFF3rTN2vbYKpBSvoplpJA0p5aEDC-Kd5a8hs5IxP-lRpt1n5ZMHxzTbQ5F57vC6sJDTcSkQ2O2z2WBHuD-lMvjxeBSHjOmV3D4eA/6Egd3oxpt7iSRZxWOtTox7uHygo7CZB-3iqNjyM-g5c'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/y3sg8S4pzh0JV3fGUpWxvg/6b3z_GtE1kqm-Lkq7bs1lLtLM79QcSqkNu6zBlh4GCGkJv6Qy_x0CCHyiEaCrsXSaUYr9m0sM0K6piXGTNcW-oZEM7DnQWD8g0jyAn2g6Rs/i_ghZ9FBmazF11BD8barJgnQ61SI7AUK-oMN7h7id14'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782766/Instruments/Multimeters/Keysight-34470A-Submodules/Keysight-34470A-Submodules.jpg,Keysight 34470A Submodules,Write a Python script that uses Qcodes to connect to a Keysight 34470A Submodules Multimeters,1863.0,,,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34470A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34470A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34470A(Keysight34470A):
    """"""
    Alias for backwards compatibility.
    """"""
"
393,http://signalhound.com/sigdownloads/datasheets/SA44B_sellsheet-Spring-2021.pdf,https://en.wikipedia.org/wiki/Spectrum_analyzer,"[OrderedDict([('id', 'attUxG81DksxCD0N3'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/U7dCSFr6QOmr51SR97k89Q/NjZWdVjGO7b_GMz6fbAbvmhZcEgfVbJuwX9_RWawZnS0ELyH-kWYbC_fF-Fbhb80S6HrVoQt5Z-pHxwBTXqOgP2ksTa5KG2wwAeBMZU6ySc/eEZwlfHV_8ct_-I5xLixm1JOgFrxqisiZbOLPeCTzo8'), ('filename', 'SA44B_1.jpg'), ('size', 96905), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/6eeOmyAVnRWdUOUvsDaPVw/JGh2dYT9EehuGjGm8ADXnJSBxxL70fvtsSe31eaf8cVopMeQy7lQijhI85e8yOShZVPqpWnLTw7Nuhk879TAfg/0s8TbAhYqjUSaq6gUTog9VMVc973xJHE7g_cciwLLag'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/yE-jZAgkiqWZKX7krhw25A/4q9qBzmmXqUg4-0Q-fmmUTjav-NlfzYrSPW5Evc095J0UO1BQ4XXoul16fTyBEl1raev1_ie6XcPOJMZBp4etA/S6-jS1jVZWTWwAKnPHmdknVRq1E6Avv1_bE6u6xCwnM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/DUL4boxnTlZki4wfrzSxrA/xJu-6QhL5s74YJA-uXZN8NGipqN4KQTSvl3bLSW92FIOQKjiCDJn5xQUnScY6coIRDXOE7X2rnnkxNWylScSjw/r3qi_qeB0VXkJrk7paG7IQTy-jl9xONjndNZJItHSsY'), ('width', 3000), ('height', 3000)]))]))])]",3.6,USA,https://res.cloudinary.com/dhopxs1y3/image/upload/v1692116719/Instruments/Vendor%20Logos/Signalhound.png,"The Signal Hound USB-SA44B is a Software Defined Receiver (SDR) optimized as a narrow-band real-time RF spectrum analyzer. It is a compact, simple to use, effective troubleshooting tool for the general lab user, engineering students, and ham radio enthusiast.",https://signalhound.com/products/usb-sa44b/,USB SA 124 B,506.0,['Spectrum Analyzers'],"A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals. The input signal that most common spectrum analyzers measure is electrical; however, spectral compositions of other signals, such as acoustic pressure waves and optical light waves, can be considered through the use of an appropriate transducer. Spectrum analyzers for other types of signals also exist, such as optical spectrum analyzers which use direct optical techniques such as a monochromator to make measurements.","Signal Hound is a manufacturer of RF spectrum analyzers and signal generators.
",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/signal_hound/SignalHound_USB_SA124B.py,Qcodes,https://qcodes.github.io/Qcodes/drivers_api/SignalHound.html,Signal Hound,"[OrderedDict([('id', 'attxALdqBv1g4lMjd'), ('width', 545), ('height', 92), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/_3qiaBNtBFba6sNtnz-HiA/qY19fCH_d_T4Nma6BXMPBEf0VhD-B6aPjkL_j13rqGPgEV4hs4rEAZdsF3vax6nxBoVyQC9wQOKBGugtonA-U6FUFy291CW2qehd5nAYwW0/Bs9HKkSZkxxiBeCKKjO1Zj3pKLioRqNFLrpZE2cCUAQ'), ('filename', 'download.png'), ('size', 4801), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/QK9qJ8DC9BjqRrHjsh6TKg/1TIhyZ6orVwnmHaokTGoBPJsK39OhBr3M9jd7kVzLXITtqjos3y0CnJo-KX6Zua8yJAnPKOq-QAp5QRkSPtW5Q/K7RHG_oRvrarwmPQ4CsRC0ypN32WdFuhoJ6E9XXSvVM'), ('width', 213), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/Jg7ZOfKyOiSF7y2YgVjFFQ/B3unEq-ikne6Mm7U4gvCqgbXVx8XmHi4nAiuRGOeTPC9EL7WwR8z6QejbULU_slHYrod6NHK7rOSdqeEy8CVyg/vMQp4v5KgdKMnCpx-DXiLIAMU_tmAXt_nMVSjZsfCxk'), ('width', 545), ('height', 92)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1692129600000/ZFdJx9QFl-xHH8FVLwcdaA/y--rNaSxKNGYFDHQm7NURRClpGreMwYCmpyYJJWFTo2kOPkQdtdGljfLAGPEu5RL5o3m7rje-V63g7gyaR0YNA/1Ta8_en2gw1aQws1PSpk0aqB-VA0BwG75q4t1pM2Jpk'), ('width', 3000), ('height', 3000)]))]))])]",https://signalhound.com/,https://res.cloudinary.com/dhopxs1y3/image/upload/v1691782769/Instruments/Spectrum%20Analyzers/USB-SA-124-B/USB-SA-124-B.jpg,USB SA 124 B,Write a Python script that uses Qcodes to connect to a {Device name} Spectrum Analyzers,1195.0,,,,"import ctypes as ct
import logging
from enum import IntEnum
from time import sleep
from typing import Any, Optional

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument
from qcodes.parameters import ArrayParameter, Parameter, ParameterWithSetpoints

log = logging.getLogger(__name__)


class TraceParameter(Parameter):
    """"""
    A parameter that used a flag on the instrument to keeps track of if it's
    value has been synced to the instrument. It is intended that this
    type of parameter is synced using an external method which resets the flag.

    This is most likely used similar to a ``ManualParameter``
    I.e. calling set/get will not communicate with the instrument.
    """"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

    def set_raw(self, value: Any) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""TraceParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        self.instrument._parameters_synced = False


class ExternalRefParameter(TraceParameter):
    """"""
    Parameter that handles the fact that external reference can only be
    enabled but not disabled.

    From the manual:

    Once a device has successfully switched to an external reference it
    must remain using it until the device is closed, and it is undefined
    behavior to disconnect the reference input from the reference BNC port.
    """"""

    def set_raw(self, value: bool) -> None:  # pylint: disable=method-hidden
        if self.get_latest() is True and value is False:
            raise RuntimeError(
                ""Signal Hound does not support disabling ""
                ""external reference. To switch back to internal ""
                ""reference close the device and start again.""
            )
        super().set_raw(value)


class ScaleParameter(TraceParameter):
    """"""
    Parameter that handles changing the unit when the scale is changed.
    """"""

    def set_raw(self, value: str) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""ScaleParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        if value in (""log-scale"", ""log-full-scale""):
            unit = ""dBm""
        elif value in (""lin-scale"", ""lin-full-scale""):
            unit = ""mV""
        else:
            raise RuntimeError(""Unsupported scale"")
        self.instrument.trace.unit = unit
        self.instrument.power.unit = unit
        super().set_raw(value)


class SweepTraceParameter(TraceParameter):
    """"""
    An extension to TraceParameter that keeps track of the trace setpoints in
    addition to the functionality of `TraceParameter`
    """"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

    def set_raw(self, value: Any) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""SweepTraceParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        self.instrument._trace_updated = False
        super().set_raw(value)


class FrequencySweep(ArrayParameter):
    """"""
    Hardware controlled parameter class for SignalHound_USB_SA124B.

    Instrument returns an array of powers for different frequencies

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
        sweep_len: Number of steps in sweep
        start_freq: Starting frequency
        stepsize: Size of a frequency step

    Methods:
          get(): executes a sweep and returns magnitude and phase arrays

    """"""

    def __init__(
        self,
        name: str,
        instrument: ""SignalHoundUSBSA124B"",
        sweep_len: int,
        start_freq: float,
        stepsize: float,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            shape=(sweep_len,),
            instrument=instrument,
            unit=""dBm"",
            label=""Magnitude"",
            setpoint_units=(""Hz"",),
            setpoint_labels=(""Frequency"",),
            setpoint_names=(""frequency"",),
            **kwargs,
        )
        self.set_sweep(sweep_len, start_freq, stepsize)

    def set_sweep(self, sweep_len: int, start_freq: float, stepsize: float) -> None:
        """"""
        Set the setpoints of the Array parameter representing a frequency
        sweep.

        Args:
            sweep_len: Number of points in the sweep
            start_freq: Starting frequency of the sweep
            stepsize: Size of step between individual points

        """"""
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""'FrequencySweep' is only implemented"" ""for 'SignalHound_USB_SA124B'""
            )
        end_freq = start_freq + stepsize * (sweep_len - 1)
        freq_points = tuple(np.linspace(start_freq, end_freq, sweep_len))
        self.setpoints = (freq_points,)
        self.shape = (sweep_len,)
        self.instrument._trace_updated = True

    def get_raw(self) -> np.ndarray:
        if self.instrument is None:
            raise RuntimeError(""No instrument is attached to"" ""'FrequencySweep'"")
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""'FrequencySweep' is only implemented"" ""for 'SignalHound_USB_SA124B'""
            )
        if not self.instrument._trace_updated:
            raise RuntimeError(""trace not updated, run configure to update"")
        data = self.instrument._get_sweep_data()
        sleep(2 * self.instrument.sleep_time.get())
        return data


class SignalHoundUSBSA124B(Instrument):
    """"""
    QCoDeS driver for the SignalHound USB SA124B

    The driver needs Signal Hounds software
    `Spike <https://signalhound.com/spike/>`_ installed to function.
    In addition, you may need to install Microsoft Visual Studio C++
    Redistributable for the driver to function within QCoDeS.
    At the time of writing the current version of Spike (3.2.3) uses
    `Microsoft Visual Studio C++ Redistributable 2012
    <https://www.microsoft.com/en-us/download/details.aspx?id=30679>`_

    """"""

    dll_path = ""C:\\Program Files\\Signal Hound\\Spike\\sa_api.dll""

    def __init__(self, name: str, dll_path: Optional[str] = None, **kwargs: Any):
        """"""
        Args:
            name: Name of the instrument.
            dll_path: Path to ``sa_api.dll`` Defaults to the default dll within
                Spike installation
            **kwargs:
        """"""
        super().__init__(name, **kwargs)
        self._parameters_synced = False
        self._trace_updated = False
        log.info(""Initializing instrument SignalHound USB 124B"")
        self.dll = ct.CDLL(dll_path or self.dll_path)

        self._set_ctypes_argtypes()

        self.hf = Constants
        self.add_parameter(
            ""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            initial_value=5e9,
            vals=vals.Numbers(),
            parameter_class=SweepTraceParameter,
            docstring=""Center frequency for sweep.""
            ""This is the set center, the actual ""
            ""center may be subject to round off ""
            ""compared to this value"",
        )
        self.add_parameter(
            ""span"",
            label=""Span"",
            unit=""Hz"",
            initial_value=0.25e6,
            vals=vals.Numbers(),
            parameter_class=SweepTraceParameter,
            docstring=""Width of frequency span""
            ""This is the set span, the actual ""
            ""span may be subject to round off ""
            ""compared to this value"",
        )
        self.add_parameter(
            ""npts"",
            label=""Number of Points"",
            get_cmd=self._get_npts,
            set_cmd=False,
            docstring=""Number of points in frequency sweep."",
        )
        self.add_parameter(
            ""avg"",
            label=""Averages"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            vals=vals.Ints(),
            docstring=""Number of averages to perform. ""
            ""Averages are performed in software by ""
            ""acquiring multiple sweeps"",
        )
        self.add_parameter(
            ""ref_lvl"",
            label=""Reference power"",
            unit=""dBm"",
            initial_value=0,
            vals=vals.Numbers(max_value=20),
            parameter_class=TraceParameter,
            docstring=""Setting reference level will ""
            ""automatically select gain and attenuation""
            ""optimal for measuring at and below ""
            ""this level"",
        )
        self.add_parameter(
            ""external_reference"",
            initial_value=False,
            vals=vals.Bool(),
            parameter_class=ExternalRefParameter,
            docstring=""Use an external 10 MHz reference source. ""
            ""Note that Signal Hound does not support ""
            ""disabling external ref. To disable close ""
            ""the connection and restart."",
        )
        self.add_parameter(""device_type"", set_cmd=False, get_cmd=self._get_device_type)
        self.add_parameter(
            ""device_mode"",
            get_cmd=lambda: ""sweeping"",
            set_cmd=False,
            docstring=""The driver currently only  ""
            ""supports sweeping mode. ""
            ""It is therefor not possible""
            ""to set this parameter to anything else"",
        )
        self.add_parameter(
            ""acquisition_mode"",
            get_cmd=lambda: ""average"",
            set_cmd=False,
            docstring=""The driver only supports averaging ""
            ""mode it is therefor not possible to set""
            ""this parameter to anything else"",
        )
        self.add_parameter(
            ""rbw"",
            label=""Resolution Bandwidth"",
            unit=""Hz"",
            initial_value=1e3,
            vals=vals.Numbers(0.1, 250e3),
            parameter_class=TraceParameter,
            docstring=""Resolution Bandwidth (RBW) is""
            ""the bandwidth of ""
            ""spectral energy represented in each ""
            ""frequency bin"",
        )
        self.add_parameter(
            ""vbw"",
            label=""Video Bandwidth"",
            unit=""Hz"",
            initial_value=1e3,
            vals=vals.Numbers(),
            parameter_class=TraceParameter,
            docstring=""The video bandwidth (VBW) is applied ""
            ""after the signal has been converted to ""
            ""frequency domain as power, voltage, ""
            ""or log units. It is implemented as a ""
            ""simple rectangular window, averaging the ""
            ""amplitude readings for each frequency ""
            ""bin over several overlapping FFTs. ""
            ""For best performance use RBW as the VBW."",
        )

        self.add_parameter(
            ""reject_image"",
            label=""Reject image"",
            unit="""",
            initial_value=True,
            parameter_class=TraceParameter,
            get_cmd=None,
            docstring=""Apply software filter to remove "" ""undersampling mirroring"",
            vals=vals.Bool(),
        )
        self.add_parameter(
            ""sleep_time"",
            label=""Sleep time"",
            unit=""s"",
            initial_value=0.1,
            get_cmd=None,
            set_cmd=None,
            docstring=""Time to sleep before and after ""
            ""getting data from the instrument"",
            vals=vals.Numbers(0),
        )
        # We don't know the correct values of
        # the sweep parameters yet so we supply
        # some defaults. The correct will be set when we call configure below
        self.add_parameter(
            name=""trace"",
            sweep_len=1,
            start_freq=1,
            stepsize=1,
            parameter_class=FrequencySweep,
        )
        self.add_parameter(
            ""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=self._get_power_at_freq,
            set_cmd=False,
            docstring=""The maximum power in a window of 250 kHz""
            ""around the specified  frequency with ""
            ""Resolution bandwidth set to 1 kHz.""
            ""The integration window is specified by ""
            ""the VideoBandWidth (set by vbw)"",
        )
        # scale is defined after the trace and power parameter so that
        # it can change the units of those in it's set method when the
        # scale changes
        self.add_parameter(
            ""scale"",
            initial_value=""log-scale"",
            vals=vals.Enum(
                ""log-scale"", ""lin-scale"", ""log-full-scale"", ""lin-full-scale""
            ),
            parameter_class=ScaleParameter,
        )

        self.add_parameter(
            ""frequency_axis"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=self._get_freq_axis,
            set_cmd=False,
            vals=vals.Arrays(shape=(self.npts,)),
            snapshot_value=False,
        )
        self.add_parameter(
            ""freq_sweep"",
            label=""Power"",
            unit=""depends on mode"",
            get_cmd=self._get_sweep_data,
            set_cmd=False,
            parameter_class=ParameterWithSetpoints,
            vals=vals.Arrays(shape=(self.npts,)),
            setpoints=(self.frequency_axis,),
            snapshot_value=False,
        )

        self.openDevice()
        self.configure()

        self.connect_message()

    def _set_ctypes_argtypes(self) -> None:
        """"""
        Set the expected argtypes for function calls in the sa_api dll
        These should match the function signatures defined in the sa-api
        header files included with the signal hound sdk
        """"""
        self.dll.saConfigCenterSpan.argtypes = [ct.c_int, ct.c_double, ct.c_double]
        self.dll.saConfigAcquisition.argtypes = [ct.c_int, ct.c_int, ct.c_int]
        self.dll.saConfigLevel.argtypes = [ct.c_int, ct.c_double]
        self.dll.saSetTimebase.argtypes = [ct.c_int, ct.c_int]
        self.dll.saConfigSweepCoupling.argtypes = [
            ct.c_int,
            ct.c_double,
            ct.c_double,
            ct.c_bool,
        ]
        self.dll.saInitiate.argtypes = [ct.c_int, ct.c_int, ct.c_int]
        self.dll.saOpenDevice.argtypes = [ct.POINTER(ct.c_int)]
        self.dll.saCloseDevice.argtypes = [ct.c_int]
        self.dll.saPreset.argtypes = [ct.c_int]
        self.dll.saGetDeviceType.argtypes = [ct.c_int, ct.POINTER(ct.c_int)]
        self.dll.saQuerySweepInfo.argtypes = [
            ct.c_int,
            ct.POINTER(ct.c_int),
            ct.POINTER(ct.c_double),
            ct.POINTER(ct.c_double),
        ]
        self.dll.saGetSweep_32f.argtypes = [
            ct.c_int,
            ct.POINTER(ct.c_float),
            ct.POINTER(ct.c_float),
        ]
        self.dll.saGetSerialNumber.argtypes = [ct.c_int, ct.POINTER(ct.c_int)]
        self.dll.saGetFirmwareString.argtypes = [ct.c_int, ct.c_char_p]

    def _get_npts(self) -> int:
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_info = self.QuerySweep()
        sweep_len = sweep_info[0]
        return sweep_len

    def _update_trace(self) -> None:
        """"""
        Private method to sync changes of the
        frequency axis to the setpoints of the
        trace parameter. This also set the units
        of power and trace.
        """"""
        sweep_info = self.QuerySweep()
        self.npts.cache.set(sweep_info[0])
        self.trace.set_sweep(*sweep_info)

    def sync_parameters(self) -> None:
        """"""
        Sync parameters sets the configuration of the instrument using the
        parameters specified in the Qcodes instrument.

        Sync parameters consists of five parts
            1. Center span configuration (freqs and span)
            2. Acquisition configuration
                lin-scale/log-scale
                avg/max power
            3. Configuring the external 10MHz reference
            4. Configuration of the mode that is being used
            5. Acquisition mode. At the moment only `sweeping` is implemented

        This does not currently implement Configuration of the tracking
        generator used in VNA mode
        """"""

        # 1. CenterSpan Configuration
        center = ct.c_double(self.frequency())
        span = ct.c_double(self.span())
        log.info(""Setting device CenterSpan configuration."")

        err = self.dll.saConfigCenterSpan(self.deviceHandle, center, span)
        self.check_for_error(err, ""saConfigCenterSpan"")

        # 2. Acquisition configuration
        detectorVals = {
            ""min-max"": ct.c_int(self.hf.sa_MIN_MAX),
            ""average"": ct.c_int(self.hf.sa_AVERAGE),
        }
        scaleVals = {
            ""log-scale"": ct.c_int(self.hf.sa_LOG_SCALE),
            ""lin-scale"": ct.c_int(self.hf.sa_LIN_SCALE),
            ""log-full-scale"": ct.c_int(self.hf.sa_LOG_FULL_SCALE),
            ""lin-full-scale"": ct.c_int(self.hf.sa_LIN_FULL_SCALE),
        }
        detector = detectorVals[self.acquisition_mode()]
        scale = scaleVals[self.scale()]

        err = self.dll.saConfigAcquisition(self.deviceHandle, detector, scale)
        self.check_for_error(err, ""saConfigAcquisition"")

        # 3. Reference Level configuration
        log.info(""Setting device reference level configuration."")
        err = self.dll.saConfigLevel(self.deviceHandle, ct.c_double(self.ref_lvl()))
        self.check_for_error(err, ""saConfigLevel"")

        # 4. External Reference configuration
        if self.external_reference():
            external = self.hf.sa_REF_EXTERNAL_IN
            log.info(""Setting reference frequency from external source."")
            err = self.dll.saSetTimebase(self.deviceHandle, external)
            self.check_for_error(err, ""saSetTimebase"")

        reject_var = ct.c_bool(self.reject_image())
        log.info(""Setting device Sweeping configuration."")
        err = self.dll.saConfigSweepCoupling(
            self.deviceHandle,
            ct.c_double(self.rbw()),
            ct.c_double(self.vbw()),
            reject_var,
        )
        self.check_for_error(err, ""saConfigSweepCoupling"")

        modeOpts = {
            ""sweeping"": self.hf.sa_SWEEPING,
            ""real_time"": self.hf.sa_REAL_TIME,  # not implemented
            ""IQ"": self.hf.sa_IQ,  # not implemented
            ""idle"": self.hf.sa_IDLE,
        }
        mode = modeOpts[self.device_mode()]
        # the third argument to saInitiate is a flag that is
        # currently not used
        err = self.dll.saInitiate(self.deviceHandle, mode, 0)
        extrainfo: Optional[str] = None
        if err == saStatus.saInvalidParameterErr:
            extrainfo = """"""
                 In real-time mode, this value may be returned if the span
                 limits defined in the API header are broken. Also in
                 real-time mode, this error will be returned if the
                 resolution bandwidth is outside the limits defined in
                 the API header.
                 In time-gate analysis mode this error will be returned if
                 span limits defined in the API header are broken. Also in
                 time gate analysis, this error is returned if the
                 bandwidth provided require more samples for processing
                 than is allowed in the gate length. To fix this
                 increase rbw/vbw.
             """"""
        elif err == saStatus.saBandwidthErr:
            extrainfo = ""RBW is larger than your span. (Sweep Mode)!""
        self.check_for_error(err, ""saInitiate"", extrainfo)

        self._parameters_synced = True

    def configure(self) -> None:
        """"""
        Syncs parameters to the Instrument and updates the setpoint of the
        trace.
        """"""
        self.sync_parameters()
        self._update_trace()

    def openDevice(self) -> None:
        """"""
        Opens connection to the instrument
        """"""
        log.info(""Opening Device"")
        self.deviceHandle = ct.c_int(0)
        deviceHandlePnt = ct.pointer(self.deviceHandle)
        err = self.dll.saOpenDevice(deviceHandlePnt)
        self.check_for_error(err, ""saOpenDevice"")
        self.device_type()

    def close(self) -> None:
        """"""
        Close connection to the instrument.
        """"""
        log.info(""Closing Device with handle num: "" f""{self.deviceHandle.value}"")

        try:
            self.abort()
            log.info(""Running acquistion aborted."")
        except Exception as e:
            # it's ok to catch any exception here
            # as we are tearing down the instrument we might
            # as well try to continue
            log.warning(f""Could not abort acquisition: {e}"")

        err = self.dll.saCloseDevice(self.deviceHandle)
        self.check_for_error(err, ""saCloseDevice"")
        log.info(f""Closed Device with handle num: {self.deviceHandle.value}"")
        super().close()

    def abort(self) -> None:
        """"""
        Abort any running acquisition.
        """"""
        log.info(""Stopping acquisition"")

        err = self.dll.saAbort(self.deviceHandle)
        extrainfo: Optional[str] = None
        if err == saStatus.saDeviceNotConfiguredErr:
            extrainfo = (
                ""Device was already idle! Did you call abort ""
                ""without ever calling initiate()""
            )

        self.check_for_error(err, ""saAbort"", extrainfo)

    def preset(self) -> None:
        """"""
        Like close but performs a hardware reset before closing the
        connection.
        """"""
        log.warning(""Performing hardware-reset of device!"")

        err = self.dll.saPreset(self.deviceHandle)
        self.check_for_error(err, ""saPreset"")
        super().close()

    def _get_device_type(self) -> str:
        """"""
        Returns the model string of the Spectrum Analyzer.
        """"""
        log.info(""Querying device for model information"")

        devType = ct.c_int32(0)
        devTypePnt = ct.pointer(devType)

        err = self.dll.saGetDeviceType(self.deviceHandle, devTypePnt)
        self.check_for_error(err, ""saGetDeviceType"")

        if devType.value == self.hf.saDeviceTypeNone:
            dev = ""No device""
        elif devType.value == self.hf.saDeviceTypeSA44:
            dev = ""sa44""
        elif devType.value == self.hf.saDeviceTypeSA44B:
            dev = ""sa44B""
        elif devType.value == self.hf.saDeviceTypeSA124A:
            dev = ""sa124A""
        elif devType.value == self.hf.saDeviceTypeSA124B:
            dev = ""sa124B""
        else:
            raise ValueError(""Unknown device type!"")
        return dev

    ########################################################################

    def QuerySweep(self) -> tuple[int, float, float]:
        """"""
        Queries the sweep for information on the parameters that defines the
            x axis of the sweep

        Returns:
            number of points in sweep, start frequency and step size
        """"""

        sweep_len = ct.c_int(0)
        start_freq = ct.c_double(0)
        stepsize = ct.c_double(0)
        err = self.dll.saQuerySweepInfo(
            self.deviceHandle,
            ct.pointer(sweep_len),
            ct.pointer(start_freq),
            ct.pointer(stepsize),
        )
        self.check_for_error(err, ""saQuerySweepInfo"")
        return sweep_len.value, start_freq.value, stepsize.value

    def _get_sweep_data(self) -> np.ndarray:
        """"""
        This function performs a sweep over the configured ranges.
        The result of the sweep is returned along with the sweep points

        returns:
            datamin numpy array
        """"""
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_len, _, _ = self.QuerySweep()

        data = np.zeros(sweep_len)
        Navg = self.avg()
        for i in range(Navg):

            datamin = np.zeros((sweep_len), dtype=np.float32)
            datamax = np.zeros((sweep_len), dtype=np.float32)

            minarr = datamin.ctypes.data_as(ct.POINTER(ct.c_float))
            maxarr = datamax.ctypes.data_as(ct.POINTER(ct.c_float))

            sleep(self.sleep_time.get())  # Added extra sleep for updating issue
            err = self.dll.saGetSweep_32f(self.deviceHandle, minarr, maxarr)
            self.check_for_error(err, ""saGetSweep_32f"")
            data += datamin

        return data / Navg

    def _get_power_at_freq(self) -> float:
        """"""
        Returns the maximum power in a window of 250 kHz
        around the specified  frequency with Resolution bandwidth set to 1 kHz.
        The integration window is specified by the VideoBandWidth (set by vbw)
        """"""
        original_span = self.span()
        original_rbw = self.rbw()
        needs_reset = False
        if not (original_span == 0.25e6 and original_rbw == 1e3):
            needs_reset = True
            self.span(0.25e6)
            self.rbw(1e3)
        if not self._parameters_synced:
            # call configure to update both
            # the parameters on the device and the
            # setpoints and units
            self.configure()
        data = self._get_sweep_data()
        max_power = np.max(data)
        if needs_reset:
            self.span(original_span)
            self.rbw(original_rbw)
            self.configure()
        sleep(2 * self.sleep_time.get())
        return max_power

    @staticmethod
    def check_for_error(err: int, source: str, extrainfo: Optional[str] = None) -> None:
        if err != saStatus.saNoError:
            err_str = saStatus(err).name
            if err > 0:
                msg = (
                    f""During call of {source} the following""
                    f""Warning: {err_str} was raised""
                )
                if extrainfo is not None:
                    msg = msg + f""\n Extra info: {extrainfo}""
                log.warning(msg)
            else:
                msg = (
                    f""During call of {source} the following Error: ""
                    f""{err_str} was raised""
                )
                if extrainfo is not None:
                    msg = msg + f""\n Extra info: {extrainfo}""
                raise OSError(msg)
        else:
            msg = ""Call to {source} was successful""
            if extrainfo is not None:
                msg = msg + f""\n Extra info: {extrainfo}""
            log.info(msg)

    def get_idn(self) -> dict[str, Optional[str]]:
        output: dict[str, Optional[str]] = {}
        output[""vendor""] = ""Signal Hound""
        output[""model""] = self._get_device_type()
        serialnumber = ct.c_int32()
        err = self.dll.saGetSerialNumber(self.deviceHandle, ct.pointer(serialnumber))
        self.check_for_error(err, ""saGetSerialNumber"")
        output[""serial""] = str(serialnumber.value)
        fw_version = (ct.c_char * 17)()
        # the manual says that this must be at least 16 char
        # but not clear if that includes a termination zero so
        # make it 17 just in case
        err = self.dll.saGetFirmwareString(self.deviceHandle, fw_version)
        self.check_for_error(err, ""saGetFirmwareString"")
        output[""firmware""] = fw_version.value.decode(""ascii"")
        return output

    def _get_freq_axis(self) -> np.ndarray:
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_len, start_freq, stepsize = self.QuerySweep()
        end_freq = start_freq + stepsize * (sweep_len - 1)
        freq_points = np.linspace(start_freq, end_freq, sweep_len)
        return freq_points


class Constants:
    """"""
    These constants are defined in sa_api.h as part of the the Signal Hound
    SDK
    """"""

    SA_MAX_DEVICES = 8

    saDeviceTypeNone = 0
    saDeviceTypeSA44 = 1
    saDeviceTypeSA44B = 2
    saDeviceTypeSA124A = 3
    saDeviceTypeSA124B = 4

    sa44_MIN_FREQ = 1.0
    sa124_MIN_FREQ = 100.0e3
    sa44_MAX_FREQ = 4.4e9
    sa124_MAX_FREQ = 13.0e9
    sa_MIN_SPAN = 1.0
    sa_MAX_REF = 20
    sa_MAX_ATTEN = 3
    sa_MAX_GAIN = 2
    sa_MIN_RBW = 0.1
    sa_MAX_RBW = 6.0e6
    sa_MIN_RT_RBW = 100.0
    sa_MAX_RT_RBW = 10000.0
    sa_MIN_IQ_BANDWIDTH = 100.0
    sa_MAX_IQ_DECIMATION = 128

    sa_IQ_SAMPLE_RATE = 486111.111

    sa_IDLE = -1
    sa_SWEEPING = 0x0
    sa_REAL_TIME = 0x1
    sa_IQ = 0x2
    sa_AUDIO = 0x3
    sa_TG_SWEEP = 0x4

    sa_MIN_MAX = 0x0
    sa_AVERAGE = 0x1

    sa_LOG_SCALE = 0x0
    sa_LIN_SCALE = 0x1
    sa_LOG_FULL_SCALE = 0x2
    sa_LIN_FULL_SCALE = 0x3

    sa_AUTO_ATTEN = -1
    sa_AUTO_GAIN = -1

    sa_LOG_UNITS = 0x0
    sa_VOLT_UNITS = 0x1
    sa_POWER_UNITS = 0x2
    sa_BYPASS = 0x3

    sa_AUDIO_AM = 0x0
    sa_AUDIO_FM = 0x1
    sa_AUDIO_USB = 0x2
    sa_AUDIO_LSB = 0x3
    sa_AUDIO_CW = 0x4

    TG_THRU_0DB = 0x1
    TG_THRU_20DB = 0x2

    sa_REF_UNUSED = 0
    sa_REF_INTERNAL_OUT = 1
    sa_REF_EXTERNAL_IN = 2


class saStatus(IntEnum):
    saUnknownErr = -666
    saFrequencyRangeErr = 99
    saInvalidDetectorErr = -95
    saInvalidScaleErr = -94
    saBandwidthErr = -91
    saExternalReferenceNotFound = -89
    # Device specific errors
    saOvenColdErr = -20
    # Data errors
    saInternetErr = -12
    saUSBCommErr = -11
    # General configuration errors
    saTrackingGeneratorNotFound = -10
    saDeviceNotIdleErr = -9
    saDeviceNotFoundErr = -8
    saInvalidModeErr = -7
    saNotConfiguredErr = -6
    saDeviceNotConfiguredErr = -6  # Added because key error raised
    saTooManyDevicesErr = -5
    saInvalidParameterErr = -4
    saDeviceNotOpenErr = -3
    saInvalidDeviceErr = -2
    saNullPtrErr = -1
    # No error
    saNoError = 0
    # Warnings
    saNoCorrections = 1
    saCompressionWarning = 2
    saParameterClamped = 3
    saBandwidthClamped = 4
"
