,"Yearly revenue (millions, USD)",Vendor headquarters,Device Description,Device,Field 1,Vendor wikipedia or cruncbase description,Library,Vendor,Vendor logo,Vendor website,ChatGPT prompt,Category description link,Device Category,Category Description,Corrected device name,Device datasheet (PDF),Device picture,Device Description Link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Python docs link,Device Price,ChatGPT code,Obsolete,Notes,docstring
1,5420.0,USA,,N 52 XX,313.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N52XXA Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT N52XXA,,,,,,,,,,
7,5420.0,USA,"The 33511B waveform generator provides Keysight's exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements.
",Keysight 33511 B,290.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33511B RF Signal Generator,https://en.wikipedia.org/wiki/Arbitrary_waveform_generator,['RF Signal Generator'],An arbitrary waveform generator (AWG) is a piece of electronic test equipment used to generate electrical waveforms. These waveforms can be either repetitive or single-shot (once only) in which case some kind of triggering source is required (internal or external).,KEYSIGHT 33511B,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,"[OrderedDict([('id', 'attUw2UrpImX6Whdc'), ('width', 1418), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AvImdsa7eWg9sF6xdn8nSQ/sDzP-4B-WDwL-gUzP9JfaD6jPVh0pqSsJy0qgaXoX_8_4rxtsolyA0XoYlXnwFfdbqrvJm2Wl1FlzkxZQgKndJ_FDYLw2Uqfn1m9c4nUb3o/snmFkvK7ScAMfQ5W7sFQ0FSFGH3OQixwUt7CLuL3D94'), ('filename', '94T6987-40.jpg'), ('size', 99871), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V2e1_SNMRI2S7Pri0luoug/857AcAoiIVmaZtJJbIDyx46u1-0KL4FEQkVHGLSbxEPJHpEbUlrsGaRF_xapX8YABNDm8AwLB-wAwOBUcao4yg/3PShH6jUE9_l95AhACTHQTw2ljyRSmYcY3snWRVPe2Y'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2hJ2rESCoj1ymXbFZs8Znw/aojwmx7PLJQMR-G22zUNCnIuiwtfvZHua0Wj2BWc2dLKRTwo-1r0MWphPmy31Xz5GZdcZ73wYs2-wQHMNgJaEw/uMA8y-w2PP_1ngIBy_L_A2iIMxyGmqN2jne4ZN8qLhY'), ('width', 980), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/d8I_8nivdEJ-yAP4-GB_5A/X_tMp1f1X1I8sCSwubbcnOuPA378oib3DU5BGgtQWD5_4MprRlFZsFOPcO8PkGHnUykcqb8R_cvFfcFDUDsUVA/1mGpzu-A8taeN2vUrUe5fFkT9PeiSQMixvpMDvAH7oE'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/33511B/waveform-generator-20-mhz-1-channel-arb.html#:~:text=The%2033511B%20waveform%20generator%20provides,for%20your%20most%20demanding%20measurements.",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33511B,2760.0,,,,"from functools import partial
import logging
from typing import Union, Any

from qcodes import VisaInstrument, validators as vals
from qcodes.instrument.channel import InstrumentChannel
from qcodes.instrument.base import Instrument
from qcodes.instrument_drivers.Keysight.private.error_handling import \
    KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class OutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a waveform generator
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


class SyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output. Has very few parameters for
    single channel instruments
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels+1):
            channel = OutputChannel(self, f'ch{i}', i)
            self.add_submodule(f'ch{i}', channel)

        sync = SyncChannel(self, 'sync')
        self.add_submodule('sync', sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
11,21.4,"Westerville, Ohio, USA",The Model 372 AC resistance bridge and temperature controller builds on the solid foundation provided by the original Lake Shore AC resistance bridge. The Model 372 provides the best possible temperature measurement and control capabilities for dilution refrigerators (DRs) that are intended to be operated below 100 mK. The Model 372 makes it easy to perform multiple tasks that were once very difficult to perform reliably at ultra-low temperatures:,Lakeshore Model 372,358.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Qcodes,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,"Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers, Power Meters",https://en.wikipedia.org/wiki/Resistance_thermometer,"['Temperature Controllers', 'Power Meters']","Resistance thermometers, also called resistance temperature detectors (RTDs), are sensors used to measure temperature. Many RTD elements consist of a length of fine wire wrapped around a heat-resistant ceramic or glass core but other constructions are also used. The RTD wire is a pure material, typically platinum (Pt), nickel (Ni), or copper (Cu). The material has an accurate resistance/temperature relationship which is used to provide an indication of temperature. As RTD elements are fragile, they are often housed in protective probes.",,https://www.lakeshore.com/docs/default-source/product-downloads/manuals/372_manual.pdf?sfvrsn=906d7988_4,"[OrderedDict([('id', 'attP2S5AlGl1nkoZY'), ('width', 505), ('height', 152), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pAcaZiLE5VweIU1I8fMBVg/3VFrmWtCuATNh_GX1KA6KdaQkxInXztntZ9vjeyhLIZ1sNyPw_vZ5CBg46L9Nk150zvs42mpDLErm1yQ7PzCAw/zZfMWJBRepo0u3nEGv-PERUqTMqoqIYXJnB0Wi5VvMU'), ('filename', '372.png'), ('size', 107074), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h5aD2h-Lh8DOUGPgR1iJvw/1b43dknGxiAPvJSwc3Q-lCc49wU2JDvQhBNkPbAF3YVg9B1TrpY-i9zBG1NDx8gS_x-WutUiqupMX8GhGP5rEQ/-iDVMqeuFzPn6YUhX5ueZ1aMxLEclaT15iuO14MkuXA'), ('width', 120), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AdjjDNl5g6z6sixB2OChuw/7bL7Wl95ZaFemi7ihDJTJZkgVucDa2isGjEtrw0Tq5eHdN8BLel3oguP1Hvl7uTvd4l3UwY4EaMqN1bsF-AGEw/xEUo4CK18cFYd5hDn6plinCFNRSHT40PjVimuCCRY0o'), ('width', 505), ('height', 152)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FWMytbO8FDFGUySV5bB4IQ/2WQ68BCtkdvLsAtuCC0kUGh52E7tG2z-Zj_8Dm4LVTr2gh2bID0ZNM_7_SYqyYnpv1RFexjBnbDP5hyP699bQw/UhoGi-nenFD_LpJWkSDDUUpYcX5clWUkBOpQvyPnOnw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/temperature-products/ac-resistance-bridges/model-372-ac-resistance-bridge-temperature-controller,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_372.py,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel372,9149.0,,,,"from typing import Any, ClassVar

import qcodes.validators as vals
from qcodes.instrument_drivers.Lakeshore.lakeshore_base import (
    BaseOutput,
    BaseSensorChannel,
    LakeshoreBase,
)
from qcodes.parameters import Group, GroupParameter

# There are 16 sensors channels (a.k.a. measurement inputs) in Model 372
_n_channels = 16


class LakeshoreModel372Output(BaseOutput):
    """"""An InstrumentChannel for control outputs (heaters) of Lakeshore Model 372""""""

    MODES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""monitor_out"": 1,
        ""open_loop"": 2,
        ""zone"": 3,
        ""still"": 4,
        ""closed_loop"": 5,
        ""warm_up"": 6,
    }
    POLARITIES: ClassVar[dict[str, int]] = {""unipolar"": 0, ""bipolar"": 1}
    RANGES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""31.6μA"": 1,
        ""100μA"": 2,
        ""316μA"": 3,
        ""1mA"": 4,
        ""3.16mA"": 5,
        ""10mA"": 6,
        ""31.6mA"": 7,
        ""100mA"": 8,
    }

    _input_channel_parameter_kwargs: ClassVar[dict[str, Any]] = {
        ""get_parser"": int,
        ""vals"": vals.Numbers(1, _n_channels),
    }

    def __init__(
        self, parent: ""LakeshoreModel372"", output_name: str, output_index: int
    ) -> None:
        super().__init__(parent, output_name, output_index, has_pid=True)

        # Add more parameters for OUTMODE command
        # and redefine the corresponding group
        self.add_parameter(
            ""polarity"",
            label=""Output polarity"",
            docstring=""Specifies output polarity (not "" ""applicable to warm-up heater)"",
            val_mapping=self.POLARITIES,
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""use_filter"",
            label=""Use filter for readings"",
            docstring=""Specifies controlling on unfiltered or "" ""filtered readings"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""delay"",
            label=""Delay"",
            unit=""s"",
            docstring=""Delay in seconds for setpoint change "" ""during Autoscanning"",
            vals=vals.Ints(0, 255),
            get_parser=int,
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.mode,
                self.input_channel,
                self.powerup_enable,
                self.polarity,
                self.use_filter,
                self.delay,
            ],
            set_cmd=f""OUTMODE {output_index}, {{mode}}, ""
            f""{{input_channel}}, ""
            f""{{powerup_enable}}, {{polarity}}, ""
            f""{{use_filter}}, {{delay}}"",
            get_cmd=f""OUTMODE? {output_index}"",
        )

        self.P.vals = vals.Numbers(0.0, 1000)
        self.I.vals = vals.Numbers(0.0, 10000)
        self.D.vals = vals.Numbers(0, 2500)


class LakeshoreModel372Channel(BaseSensorChannel):
    """"""
    An InstrumentChannel representing a single sensor on a Lakeshore Model 372.

    """"""
    SENSOR_STATUSES = {
        0: ""OK"",
        1: ""CS OVL"",
        2: ""VCM OVL"",
        4: ""VMIX OVL"",
        8: ""VDIF OVL"",
        16: ""R. OVER"",
        32: ""R. UNDER"",
        64: ""T. OVER"",
        128: ""T. UNDER"",
    }

    def __init__(self, parent: ""LakeshoreModel372"", name: str, channel: str):
        super().__init__(parent, name, channel)

        # Parameters related to Input Channel Parameter Command (INSET)
        self.add_parameter(
            ""enabled"",
            label=""Enabled"",
            docstring=""Specifies whether the input/channel is ""
            ""enabled or disabled. At least one ""
            ""measurement input channel must be ""
            ""enabled. If all are configured to ""
            ""disabled, channel 1 will change to ""
            ""enabled."",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""dwell"",
            label=""Dwell"",
            docstring=""Specifies a value for the autoscanning "" ""dwell time."",
            unit=""s"",
            get_parser=int,
            vals=vals.Numbers(1, 200),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""pause"",
            label=""Change pause time"",
            docstring=""Specifies a value for "" ""the change pause time"",
            unit=""s"",
            get_parser=int,
            vals=vals.Numbers(3, 200),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""curve_number"",
            label=""Curve"",
            docstring=""Specifies which curve the channel uses: ""
            ""0 = no curve, 1 to 59 = standard/user ""
            ""curves. Do not change this parameter ""
            ""unless you know what you are doing."",
            get_parser=int,
            vals=vals.Numbers(0, 59),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""temperature_coefficient"",
            label=""Change pause time"",
            docstring=""Sets the temperature coefficient that ""
            ""will be used for temperature control if ""
            ""no curve is selected (negative or ""
            ""positive). Do not change this parameter ""
            ""unless you know what you are doing."",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.enabled,
                self.dwell,
                self.pause,
                self.curve_number,
                self.temperature_coefficient,
            ],
            set_cmd=f""INSET {self._channel}, ""
            f""{{enabled}}, {{dwell}}, {{pause}}, ""
            f""{{curve_number}}, ""
            f""{{temperature_coefficient}}"",
            get_cmd=f""INSET? {self._channel}"",
        )

        # Parameters related to Input Setup Command (INTYPE)
        self.add_parameter(
            ""excitation_mode"",
            label=""Excitation mode"",
            docstring=""Specifies excitation mode"",
            val_mapping={""voltage"": 0, ""current"": 1},
            parameter_class=GroupParameter,
        )
        # The allowed values for this parameter change based on the value of
        # the 'excitation_mode' parameter. Moreover, there is a table in the
        # manual that assigns the numbers to particular voltage/current ranges.
        # Once this parameter is heavily used, it can be implemented properly
        # (i.e. using val_mapping, and that val_mapping is updated based on the
        # value of 'excitation_mode'). At the moment, this parameter is added
        # only because it is a part of a group.
        self.add_parameter(
            ""excitation_range_number"",
            label=""Excitation range number"",
            docstring=""Specifies excitation range number ""
            ""(1-12 for voltage excitation, 1-22 for ""
            ""current excitation); refer to the manual ""
            ""for the table of ranges"",
            get_parser=int,
            vals=vals.Numbers(1, 22),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""auto_range"",
            label=""Auto range"",
            docstring=""Specifies auto range setting"",
            val_mapping={""off"": 0, ""current"": 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""range"",
            label=""Range"",
            val_mapping={
                ""2.0 mOhm"": 1,
                ""6.32 mOhm"": 2,
                ""20.0 mOhm"": 3,
                ""63.2 mOhm"": 4,
                ""200 mOhm"": 5,
                ""632 mOhm"": 6,
                ""2.00 Ohm"": 7,
                ""6.32 Ohm"": 8,
                ""20.0 Ohm"": 9,
                ""63.2 Ohm"": 10,
                ""200 Ohm"": 11,
                ""632 Ohm"": 12,
                ""2.00 kOhm"": 13,
                ""6.32 kOhm"": 14,
                ""20.0 kOhm"": 15,
                ""63.2 kOhm"": 16,
                ""200 kOhm"": 17,
                ""632 kOhm"": 18,
                ""2.0 MOhm"": 19,
                ""6.32 MOhm"": 20,
                ""20.0 MOhm"": 21,
                ""63.2 MOhm"": 22,
            },
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""current_source_shunted"",
            label=""Current source shunt"",
            docstring=""Current source either not shunted ""
            ""(excitation on), or shunted ""
            ""(excitation off)"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""units"",
            label=""Preferred units"",
            docstring=""Specifies the preferred units parameter ""
            ""for sensor readings and for the control ""
            ""setpoint (kelvin or ohms)"",
            val_mapping={""kelvin"": 1, ""ohms"": 2},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.excitation_mode,
                self.excitation_range_number,
                self.auto_range,
                self.range,
                self.current_source_shunted,
                self.units,
            ],
            set_cmd=f""INTYPE {self._channel}, ""
            f""{{excitation_mode}}, ""
            f""{{excitation_range_number}}, ""
            f""{{auto_range}}, {{range}}, ""
            f""{{current_source_shunted}}, ""
            f""{{units}}"",
            get_cmd=f""INTYPE? {self._channel}"",
        )


class LakeshoreModel372(LakeshoreBase):
    """"""
    QCoDeS driver for Lakeshore Model 372 Temperature Controller.

    Note that interaction with the control input (referred to as 'A' in the
    Computer Interface Operation section of the manual) is not implemented.
    """"""

    channel_name_command: dict[str, str] = {
        f""ch{i:02}"": str(i) for i in range(1, 1 + _n_channels)
    }
    input_channel_parameter_values_to_channel_name_on_instrument = {
        i: f""ch{i:02}"" for i in range(1, 1 + _n_channels)
    }

    CHANNEL_CLASS = LakeshoreModel372Channel

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, **kwargs)

        heaters = {""sample_heater"": 0, ""warmup_heater"": 1, ""analog_heater"": 2}
        for heater_name, heater_index in heaters.items():
            self.add_submodule(
                heater_name, LakeshoreModel372Output(self, heater_name, heater_index)
            )
"
12,110.6,"Cleveland, Ohio, United States",,Keithley S 46,254.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,,,,,,
14,38.0,Switzerland,"The Zurich Instruments UHFQA Quantum Analyzer is a unique instrument for parallel readout of up to 10 superconducting or spin qubits with highest speed and fidelity. The UHFQA operates on a frequency span of up to ±600 MHz with nanosecond timing resolution, and it features 2 signal inputs and outputs for IQ base-band operation. Thanks to its low-latency signal processing chain of matched filters, real-time matrix operations, and state discrimination, the UHFQA supports the development of ambitious quantum computing projects for 100 qubits and more.",Uhfqa,641.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a UHFQA ,,,,UHFQA,https://docs.zhinst.com/pdf/ziUHFQA_UserManual.pdf,"[OrderedDict([('id', 'att3VgCNpet0BxOHv'), ('width', 1183), ('height', 362), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JB31No9tJDbhKYvxY6Vttw/DSESuTNn4PM-hV_dVHlDLwT6PzRj_GR5Ge2Rbzh8t770TAr-FbijXYOmFBjj_LBclFuwekcaAR8kFmWBJq_SdkAsnuQ8GC8Ve3zZVxkzftPoEo5OyESIkC8xGrCko2I2/Vnj5WaaP1ufIcbir-GSBVXUbxkx4Nugm6u0HtxNgLFI'), ('filename', 'uhfqa_schraeg_2800.png.webp'), ('size', 25058), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0ibZ25xi1QsElNfBAoGmnw/wJBXtRwwcXeAzzj4wV5FcXK_KdNCYfCaZ7K8PugQ4kFJ1Do_4l8rvLZp1UeaD7QC1IKRROi7qyvXy_Z6ZVhDRntutVEY51245Q4swNscEho/Ec58OfKRcggK8-b8coPFsdOVFFF_mQbbfRs6niIuBMs'), ('width', 118), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tdEmKhtSp-CPFy3AC0YPIA/-Ij1K0NFnuFVea2c4JhwRoHEZdaNUiXtnHDcwpfhYplfEBteJ7hWG2uV3TbA2YbRJRzHRrrddXduXjsJOtSUPXVtR8tpaZFW1HJ8WDsWV98/j1j1xc1eI_rkDtug2uN6dlljjreRhvhoiPJW4N5J1MY'), ('width', 1183), ('height', 362)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iPYM3aIsVWklvg4YjRkH-w/1EVnKCUanNWxAtX2FoFF3NIYs3EFSqxRcV-ACHn9EmTPV-3aVFTJcqoG3EIEvJmvHq_p8uJTZqGlHrk5pd32cDr6Qe08l2WiVrwfN65HlAQ/rpFZWi12VI_RhEZap_feYiGdmy9WVJ_jCYXFmSOWR2U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/uhfqa-quantum-analyzer,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqa.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.uhfqa.html,,,,,"""""""Autogenerated module for the SHFQA QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import Sequence, Waveforms
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQA(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQA.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
16,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Dual Output, 2 x 30V/3A, USB, RS232 & LAN Interfaces
",AIM TTI PL 303 QMD P,49.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL303QMD-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL303QMD-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'attgSpBoGYLMyzxqA'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IBm4n7QjynnHKV6xroWITA/gbyLmhrBLQ1EC-u6g8amOIDkvlJU14J1G7m1oAz2ojp06mjxCUo6ZvbTbechfx08aOSPS8TzrSRDP4zcLqzitrMZX7IdaE7VXtAAeDlESyQ/gjvtUo9SOW6vQRvUR_K3ADdBbKFgujx7cQqc12rZRRs'), ('filename', 'PL303QMD-1000px.jpg'), ('size', 183214), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MNPuISsXaKx8BvfFnz7saQ/NC3uDAvpklHbfDmthopTyMBcOIiRrAMiTaX9XCCcChtOf_afHHjdpbaoTXHLYUimQfUaCfDrntSu9cqBCnCj4A/pP4DMw9_Zrq5U68USjb8G25Zxtb_PSa5LRA-05NKBis'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/p_YTniU6RqyRHyeOSshNsw/jJi4gEvsmmJjvRdirgaU7GmRu0V3yhvWeZgsCX85husq1AglFBy1CYA88OVd_nWf-N3cHhh_gA0Ite_gQ9Vpqg/3mvFdUTTKnQNOrV4klGFxy2fT9ss4PlYvkTJrxqPlhI'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ga9Q58aqr4Zwzy7gyU-qvw/Wt6akzaX0n1OIJTECFZzird7wb_WVI2kdZWNszjKC0R74_JTakSiQ8mz7_1nBRqJkyak5V9V5rJR9veouQf0aA/818EL1YWdGCmRvwK_VYBfteJnc-SzQ7tZRTBgNLx2Z4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,1150.0,"
",,,
19,5420.0,USA,"The Keysight Technologies, Inc. 34410A and 34411A 6½-Digit DMMs build on the phenomenal success of the industry-standard Keysight 34401A. These new meters offer improved accuracy, expanded measurement capability, dramatically improved measurement speed and throughput, and modern computer interfaces including LAN and USB.",Agilent 34410A,32.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT - 34410A Multimeters,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.",KEYSIGHT - 34410A,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,"[OrderedDict([('id', 'attSsiYamVSrHxqrI'), ('width', 1164), ('height', 566), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4PicMO72hcb7xLqtYNUX1A/zkgwOGGERxcE1O7NuWT9WNF_wWaXIjwa5d77Z7dwYTiNd3df7vYMx3bS4QJLuGUwFSLvLt31waNptDcI5SQi4gXu0hUSfFXxSQc_teDDZD0/MbymVX6sPEbr9PBt0w4DPACY8B6ODqnZCl3Gh0OIOWY'), ('filename', '34410A.png'), ('size', 439324), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CBMFVibEae8i_aa72l3eHw/mJkyt1AUz6mhWq68ubMsgtS0Z_FrzWBgf31Og-7BXW1uar_KF-TIeMZHlhYfL0GMAZ9fiPrXuNtmcYDfh8L_VQ/UseK34l_BcE96hsTNupsqseE-6EMfCEedpll2XJUv7c'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TsQyid06_3_rQ9z9h7m0Ew/dPhBDDAnos9GBZj3zT5_IDcdB27Bpxt-XZOB8HkVJGRDBcBMt0XxO_7azagto_Q4nhG0vKqo-k7m2oDLAjVfLg/4_-VwJT0clJ_Bqh4KSfGMBYQczVLhxB-Za2t9LOm_Ms'), ('width', 1053), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Dx2VF_dEoV2eECfTf_74Mg/BLCaEALnnneaOGssUWPJQqD4G5ye5yOsEcnotFzfiWyJNk-bcrmXfmczBr0VCd3rYSs8D5k7WzmPfgaMlBuIFQ/8yrktatLJaDHN-NPdNzzvjNg_T8YxpZtPRFWccHJFw4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/34410A/digital-multimeter-6-digit.html,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/agilent/agilent34410A.py,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/agilent/agilent34410a.html,,,True,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument


class Agilent34410A(Instrument):
    """"""
    Represent the HP/Agilent/Keysight 34410A and related multimeters.

    Implemented measurements: voltage_dc, voltage_ac, current_dc, current_ac, resistance,
    resistance_4w
    """"""
    # only the most simple functions are implemented
    voltage_dc = Instrument.measurement(""MEAS:VOLT:DC? DEF,DEF"", ""DC voltage, in Volts"")

    voltage_ac = Instrument.measurement(""MEAS:VOLT:AC? DEF,DEF"", ""AC voltage, in Volts"")

    current_dc = Instrument.measurement(""MEAS:CURR:DC? DEF,DEF"", ""DC current, in Amps"")

    current_ac = Instrument.measurement(""MEAS:CURR:AC? DEF,DEF"", ""AC current, in Amps"")

    resistance = Instrument.measurement(""MEAS:RES? DEF,DEF"", ""Resistance, in Ohms"")

    resistance_4w = Instrument.measurement(
        ""MEAS:FRES? DEF,DEF"", ""Four-wires (remote sensing) resistance, in Ohms"")

    def __init__(self, adapter, name=""HP/Agilent/Keysight 34410A Multimeter"", **kwargs):
        super().__init__(
            adapter, name, **kwargs
        )
"
23,110.6,"Cleveland, Ohio, United States","The 2604B SourceMeter SMU instrument is a new dual channel SMU instrument with best-in-class value and performance. Its tightly integrated four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The Model 2604B is equipped with our high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2604B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2602B SourceMeter SMU Instrument that includes digital I/O, TSP-Link technology, and contact check function. The wide range of 3A DC, 10A pulse, 40V output makes the Model 2604B suitable for testing a wide range of higher current devices, materials, components, and sub-assemblies.",Keithley 2604 B,247.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2604B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2604B,https://download.tek.com/datasheet/1KW-60906-0_Series_2600BDatasheet_112718.pdf,"[OrderedDict([('id', 'attH0k7mcZZK9q4aR'), ('width', 320), ('height', 146), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/H6ftS3YywEbug1irW4MnmA/zKRlja-gUeZVijyzMZmZ22_R7-qnMx5uGyt5OCbrB7pZ29uUJKLIhkCT-WGN5PeWcquhG1JtFhcjPjMYDQkMlmTmSnuZLpn6HoOwzCxNu0k/Dtay-sN_WOXHuMw4Nb1kKNN0efv1klMoKwuAn6NVyCs'), ('filename', '2604b.webp'), ('size', 7146), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Dy3RKuhc9UY6FNsfxrt23A/LOdyeMCwB_ghj5_b6abb_8tDG5TGYwftLtkjRdqiPQ0x2WPQXevnbVDipiuLv0g3jbmfGS1IwIP4WDEsmE1aPUyF97tL4ybc0EycW5Kvcr8/uKBGrUIVDWW1IS9WH7LEc4NgMuT021ZCyX9TrYvoZgk'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HW4_1cxOP_CCItfAypAhlQ/eW_6fDk8owq-5aYzWrbsPPJ2gS1LyNocNmXogkl0qTrI35lwn-nHTaln_5MWZp2EMcuDqalCZ-d7fd1YVaMGGCF0rOnI2k61Btp6ssyEnwQ/jqHbZWYhIMiupqGLFxJfKPUVSi8vDnX6Cvk4m6kIdwU'), ('width', 320), ('height', 146)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FNfMQe5DOyKxKbD_f8mKHQ/NSfms9aj8Hdooyyk3cr4N27w-QKf2P3ELHj_D39sT1lQBuxxBGPUzUaKW_dRRKxic1DaHWtWmUgNgtzS8rluseTr601XMHeQBqusFSCeDIM/_LCCQHkk1d346AvcdJ1sUv4Xx66i-SWpSBMcwFPJyzU'), ('width', 3000), ('height', 3000)]))]))])]",https://airtable.com/appltTe3yZzVV3Ouj/tblL9tOZ9MjjSCZoS/viwuhy7fMXGLRPE9u?blocks=hide,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2604B,17514.0,,,,
27,5800.0,USA,"AWG5000 Series models, with a 14
bits DA converter based sample rate
from 600 MS/s to 1.2 GS/s, two to four output channels, synchronized four to eight digital marker outputs, and 28-channels of digital data outputs, easilysolve the toughest measurement challenges in wireless base band I/Q communications, digital consumer product design such as imaging devices, data conversion equipment and semiconductor design and test",AWG 5208,557.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG5208 RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG5208,https://download.tek.com/datasheet/76W-20381-3.pdf,"[OrderedDict([('id', 'att98yXFO6xRfBxDx'), ('width', 721), ('height', 481), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TcJGawxm52MacW_QdL-uFw/5VCZi9ewBcQTWtdNdPPKjXw8C1L7pHAelzQTMqM_z9-_QCd63dRS_-AYEzEjztzAeJ-cRvhK15Eumz_MmANS8BGYr2oxI0Lqb6S7lqF6YH0/X30QflQnf1tCo3bWbxEVd4oZkRMXakjSqcbwFsGGQfM'), ('filename', 'TEKAWG5208-1.webp'), ('size', 21040), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V451GargPKPVEKKnndgdoA/2yCGOFOFdehFIo8tgBLTJ8kSPbUu3c0MDJefVA-FP1lbO5-UKTNjTK2ioYTK3dz2Jd2lw9eq9Uolrkwt8-C0-AylLiaNkiTUV6bhRUAEe44/nauVYvvbuZBsLWEicsh-FDAgdhXWSmoQh6CUaoAFYb4'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/W2_Dcp5Q_fIEbIBV1NBViA/FHdZLF_DqAIA8fPY7cfFxG2uebQdL7GoTWVWpItqLQp_mIHxBeByzs03tt38j6EsqKzcszqbjTMokVL-4nGRWeP2baKew1gd7_M-McXmll4/tsfi3gA4Gkldgo9m-ctKokcxcJP9eymidR6Tz5-_F8g'), ('width', 721), ('height', 481)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oKTqsxXExeJgWvU4gzyAGA/ij2A-0Hv4Frb6qX07JHf5g7IU5y6yl_D0mqrk_MT9udgrgi6CHIbbWEfvdgx0Vl8yT812_ZSb8pXEW0PcXAEJFw32f0QYk2UPmri81pwqoM/nkMPni9DnEGav7JQpoKU3dOU1DxtbF6ka0FXpoA9-oI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/awg5000-series,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG5208.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG5208,,,True,,"from typing import Any

from .AWG70000A import AWG70000A


class TektronixAWG5208(AWG70000A):
    """"""
    The QCoDeS driver for Tektronix AWG5208
    """"""

    def __init__(self, name: str, address: str,
                 timeout: float = 10, **kwargs: Any) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds).
        """"""

        super().__init__(name, address, num_channels=8,
                         timeout=timeout, **kwargs)


class AWG5208(TektronixAWG5208):
    """"""
    Alias with non-conformant name left for backwards compatibility
    """"""

    pass
"
28,1.0,Switzerland,"The low-noise high-stability (LNHS) I to V Converter offers ultra-low noise, excellent stability, and unique features such as a floating input and the possibility to apply an external bias voltage",SP 983 C,105.0,"Basel Precision Instruments develop ultra-low-noise precision laboratory and scientific electronics for applications requiring ultra-high sensitivity, such as low-temperature quantum physics.
",Qcodes,Basel,"[OrderedDict([('id', 'attcofhhVdBDZ49OD'), ('width', 2359), ('height', 1152), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/p2snk2PTNrputRW0nmy2kQ/vNHzhn1mIJt8TODuVqfTwR7UGjbhNdUQycb2b1kY4HP4K6-8p101lmpIhh7Ik80BSIDIctNRCSCWJb84cdQAftUsDFpMmkBiDZnafPpA4gI/wOFmUa3RRxp7napzJAuuqX-Y6GqGnj4qArHoncJugSU'), ('filename', 'baspi-logo-i.jpg'), ('size', 238504), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8xJwDxX3Bl1KIr-yUmA4Aw/gfYVResdNu6r0CQeDatBchtIRyo1AYxSxKHC9L8JWcKlErq4f8VHtbuvhDcbY1Lb00BZC5DBNpE5TxjfYJ5mfg/ztXvAqhlzsQ0MLt0QpKg9A8YPbIcr6zzDBFUICXE65o'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GEQpWfACKlQeV-cRwaKnDA/g0wJB7upACS_7kV60jYASA99ghLwY0vMZ78z-Urabmwgqa5g9IEyvDo-TKBMg-7NTAx9lSNmyFVe5-s-_-gSKA/Ytqe-UFBfaBjdP8s5wxSYeUilHWmOcZN26R1bCIkBeQ'), ('width', 1048), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5AWeTEAiirZS72AjUP7F5Q/_cvLx4NgEx94SvCQC8xTLdj0bTun9lXLcqstJqU5o8sYQ-oTg2YiS5Edp5Sy2TdMBXqwZMgQ5rb5CQvizfTvfA/VFDRgbySUwmYCVMshuwj6hB85ZJMm78JsnhJdeoznwc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.baspi.ch/,Write a Python script that uses Qcodes to connect to a SP983c IV Converter,https://www.by-rutgers.nl/IV-converter.html,['IV Converter'],An I/V-convertor is intended to convert the current from a DAC (Digital Analog Convertor) into an analog voltage and to filter this signal to keep out the alias frequencies,SP983c,https://www.baspi.ch/_files/ugd/68eb62_d9c26342fd8f4960a2ebee967ff5a9d4.pdf,"[OrderedDict([('id', 'attrqrvLofLNFwEwM'), ('width', 1556), ('height', 686), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ou5BuzR0dzrNZGUqadj9sw/_sxu1uhN4fl4keL360ImlZSqHiDkgc6LHDNVodBCM1PgHXEy5MyyMIGNsQPdkbN1cfTZZC0I02B4oliMykN--BtOpHN89kfqM6mvFUz4bfw/3kloaCXM3J6y1JzxXHMDUS1Z7f4QuqsuE4Vb1OvqzYk'), ('filename', 'IV converter.webp'), ('size', 125458), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ev56oajqZUYUXhLB00s-Mw/Qtj_9yXtRnskhlG5OT2hGjX4gFFRYVhHKD5n9lsH3QZlleYL3B-gOw2_8MeHSa8Z_2QRruT200teN7sGuDe6M_p6FrYAvToXazgJ1txkSpc/PmjFHJCAStrihdLxoqtWG0rrx5yb37PTQ0uqjiapEnc'), ('width', 82), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ulGwmHjXc_c7m_n6ZTC_qQ/CUYPuVXsYYySbnnE1Foa1Y-iwlSw6nEx5YckRYWyXqNTG4irIPjWY4v3w94zoywH3yLQ0EClnXFrY8C4Q8v2qf9YCsFqmAlg_pB64_rYzGc/xaezhi6-QfySiSyUOsGmpgMT_rsRAMddRC94vPoeM34'), ('width', 1161), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ax29nJtzwaW7TX1lIz4wWQ/TqaOYsw_n8CCZfM6hMKekbvO60m5AaQnAf4zHJPWweG6y_RNdu2DCw0SxkC5KmBSlBL_-oWLiNp-sgZwOtGl0cisVPX4ez3hSPhCUIddRLU/Q63UkxbGlwtw5UK8t_m6WT5gqDOTtiyH_k0WR9_DkVU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.baspi.ch/low-noise-high-stab-itov-conv,https://qcodes.github.io/Qcodes/drivers_api/Basel.html,https://qcodes.github.io/Qcodes/drivers_api/Basel.html,,,,,
32,38.0,Switzerland,"The SHFQC Qubit Controller can control, read out and provide fast feedback on up to 6 superconducting qubits. It integrates the functionality of the SHFQA Quantum Analyzer, the SHFSG Signal Generator and more in a single instrument. ",Shfqc,643.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a SHFQC ,https://en.wikipedia.org/wiki/Signal_generator,,"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",SHFQC,https://docs.zhinst.com/pdf/ziSHFQC_UserManual.pdf,"[OrderedDict([('id', 'att78kCP7VAAtY058'), ('width', 1183), ('height', 405), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aykoGvLU6RwMLaOI0SzKGw/4-GkoIGRjXxwA5nyGmQYZjPk7ZibDlabZN9PtXYyQoMJpcshiUEs7fmYzeRf2E_wArTZWR1pcDIndC_Vul0vSMEXHgLrJCdZuzlTpf-8px0qmnGbC3OvE8Nbf2bFnxFb/Obg3LfDz8qW59jVHCQUaUzS05R1NaetW6rWX-DXCE3o'), ('filename', 'SHFQC_8_schraeg_2800.jpg.webp'), ('size', 39270), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KyfnmHILkPzdtNPGZXr-XA/H2Ys9vrsARmbyZjJ14lacYvqQ0dqjvwnQlhq-DreWnztNXWVkKJ-YdSs_EIgDMZ3jn09ZF0j1VVNZuZ05rZL8rx8gmrpkrgGB4dKgq6Tb9w/8r_bwwESWuj7RCymGrdojps48mwr8f0dPgMc9GXisqE'), ('width', 105), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ByEWJPfunDaxGbfdZmNL4g/1gReXXcxUBCKPGcjC9QAp5DoV-LDf-dvmQV6ZJTbVjMPrUOjHza6ZiOlWuF9pMjmVk__qC48hyRTt4Ee0qtQymvgFyA3VVZztvl9sb-joPU/F1OXI-Ya1KJEBDwBw_l50n61M3GXhgwbAyWlYDqUXTw'), ('width', 1183), ('height', 405)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VXAbEXgJ2cfvpIhJA2WvMw/YGW7VJarLoWSxwu-RklmTtg7na0r1h8W6SoD5817agpe2xnqd5AbiTgk9HrFgzxxjzpSoNgBU8edXxXlRQskhT7lQsfIMK4oNCo7pMzNpSk/ylCyZfE4kZXz8JSJRIrfSKevbGTPBTxbWmgirzAuU0Y'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/shfqc-qubit-controller,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqc.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfqc.html,,,,,"""""""Autogenerated module for the SHFQC QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWGCore(ZINode):
    """"""AWG Core Node.""""""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""awg"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)

    def configure_marker_and_trigger(
        self, *, trigger_in_source: str, trigger_in_slope: str, marker_out_source: str
    ) -> None:
        """"""Configures the trigger inputs and marker outputs of the AWG.

        Args:
            trigger_in_source: Alias for the trigger input used by the
                sequencer. For a list of available values use:
                `available_trigger_inputs`
            trigger_in_slope: Alias for the slope of the input trigger
                used by sequencer. For a list of available values use
                `available_trigger_inputs`
            marker_out_source: Alias for the marker output source used by
                the sequencer. For a list of available values use
                `available_trigger_slopes`
        """"""
        return self._tk_object.configure_marker_and_trigger(
            trigger_in_source=trigger_in_source,
            trigger_in_slope=trigger_in_slope,
            marker_out_source=marker_out_source,
        )

    @property
    def available_trigger_inputs(self) -> List:
        """"""List the available trigger sources for the sequencer.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_trigger_slopes(self) -> List:
        """"""List the available trigger slopes for the sequencer.""""""
        return self._tk_object.available_trigger_slopes

    @property
    def available_marker_outputs(self) -> List:
        """"""List the available trigger marker outputs for the sequencer.""""""
        return self._tk_object.available_marker_outputs


class SGChannel(ZINode):
    """"""Signal Generator Channel for the SHFSG.

    :class:`SGChannel` implements basic functionality to configure SGChannel
    settings of the :class:`SHFSG` instrument.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""sgchannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.awg:

            self.add_submodule(
                ""awg"",
                AWGCore(
                    self,
                    self._tk_object.awg,
                    zi_node=self._tk_object.awg.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self, *, enable: bool, output_range: int, center_frequency: float, rf_path: bool
    ) -> None:
        """"""Configures the RF input and output.

        Args:
            enable: Flag if the signal output should be enabled.
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency before modulation
            rf_path: Flag if the RF(True) or LF(False) path should be
                configured.
        """"""
        return self._tk_object.configure_channel(
            enable=enable,
            output_range=output_range,
            center_frequency=center_frequency,
            rf_path=rf_path,
        )

    def configure_pulse_modulation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        global_amp: float = 0.5,
        gains: tuple = (1.0, -1.0, 1.0, 1.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configure the pulse modulation.

        Configures the sine generator to digitally modulate the AWG output, for
        generating single sideband AWG signals

        Args:
            enable: Flag if the modulation should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used to modulate the AWG
                outputs. (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            global_amp: Global scale factor for the AWG outputs. (default = 0.5)
            gains: Sets the four amplitudes used for single sideband generation.
                Default values correspond to upper sideband with a positive
                oscillator frequency. (default = (1.0, -1.0, 1.0, 1.0))
            sine_generator_index: Selects which sine generator to use on a
                given channel.
        """"""
        return self._tk_object.configure_pulse_modulation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            global_amp=global_amp,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    def configure_sine_generation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        gains: tuple = (0.0, 1.0, 1.0, 0.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configures the sine generator output.

        Configures the sine generator output of a specified channel for generating
        continuous wave signals without the AWG.

        Args:
            enable: Flag if the sine generator output should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used by the sine generator
                (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            gains: Sets the four amplitudes used for single sideband
                generation. Default values correspond to upper sideband with a
                positive oscillator frequency.
                Gains are set in the following order I/sin, I/cos, Q/sin, Q/cos.
                (default = (0.0, 1.0, 1.0, 0.0))
            sine_generator_index: Selects which sine generator to use on a given
                channel
        """"""
        return self._tk_object.configure_sine_generation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    @property
    def awg_modulation_freq(self) -> float:
        """"""Modulation frequency of the AWG.

        Depends on the selected oscillator.
        """"""
        return self._tk_object.awg_modulation_freq


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQC(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQC.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.sgchannels:

            channel_list = ZIChannelList(
                self,
                ""sgchannels"",
                SGChannel,
                zi_node=self._tk_object.sgchannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.sgchannels):
                channel_list.append(
                    SGChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.sgchannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""sgchannels"", channel_list)

        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
33,110.6,"Cleveland, Ohio, United States","The DMM7510 7.5 digit multimeter combines a precision, high-resolution digital multimeter (DMM), graphical touchscreen display, and high-speed, high-resolution digitizer to create the first graphical sampling multimeter. With pA-level sensitivity and 1Msample/s sampling, it accurately measures ultra-low sleep mode currents and transmit drain currents from wireless devices. ",Keithley 7510,252.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a DMM7510 Keithley  Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",DMM7510 Keithley ,https://www.farnell.com/datasheets/3540326.pdf,"[OrderedDict([('id', 'attU27V7yxtikH7Dx'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/15seRXz0Se1u8jLxkrtIAA/2hMnD-x9-38K2WRm79EyJLi7GAINJiY-RqwvHQ8sJX_QtaNeEv0hAKvjwBN4tjqTaxdFXz2Q6ASbJGKbABRwHal56IFlQjqpCc6jlGuIOzQ/8dOCco3pnYim2P0rO4pL-co5HXy65b6EcKAIIif5TmU'), ('filename', '7510.webp'), ('size', 20588), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ajXe6mAeeZypcIHJxMb5bw/dSMxTxarR4WK-8nbgyjQZSABxnCJhjlDn41nzjtF1Wl3O1BFbbOQxSAfD7tFABxjo0iVLK5DeZ9q2GggtEf-pKCa5_AjAPEtnG128QU4Mzk/regvKO8BJS3uMWjwioIn9K3nnwcESJ3YE0EDRPMlvh0'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/v5iXENdvVUO3KbcRRr9RUw/UAkouOm9JJXzVtVVIvshoGN2sJu7DLSmJNVkdRXmo5tp-bedxTPdUFO8RLgcz681hEI0mQQLgJyd6VI4jNGX8pjfZhL5M9Wl5N9Zxxg0kqo/86SpQHjKajxhSyROR3Lw5_L9p6SLBXGjiI0idAe4mEY'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uxwPYyQGZDwaKuN6DzPlEw/xus5KCJc_bYhiFsG_7Ljs2oahIO_ENG9JzjFQjanebgSmhp9qdRbGVh8_W5JndyjVqbLpAy7kC4RsikYdQQn0Llnm32q_HX8VZpBV6Pgf0k/JSntaPiVxW8j-G9zsHSOdhg6y7SOaXNn3BrPSmE7XDk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/digital-multimeter/dmm7510,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_7510.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley7510,7050.0,,,,"from collections.abc import Sequence
from types import TracebackType
from typing import Any, Optional, Union, cast

import numpy as np

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    DelegateParameter,
    MultiParameter,
    Parameter,
    ParamRawDataType,
    create_on_off_val_mapping,
    invert_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Lists, Numbers


class DataArray7510(MultiParameter):
    """"""
    Data class when user selected more than one field for data output.
    """"""

    _data: tuple[tuple[Any, ...], ...] = ((), ())

    def __init__(
        self,
        names: Sequence[str],
        shapes: Sequence[Sequence[int]],
        setpoints: Optional[Sequence[Sequence[Any]]],
        **kwargs: Any,
    ):
        super().__init__(
            name=""data_array_7510"",
            names=names,
            shapes=shapes,
            setpoints=setpoints,
            **kwargs,
        )
        for param_name in self.names:
            self.__dict__.update({param_name: []})

    def get_raw(self) -> Optional[tuple[ParamRawDataType, ...]]:
        return self._data


class GeneratedSetPoints(Parameter):
    """"""
    A parameter that generates a setpoint array from start, stop and num points
    parameters.
    """"""

    def __init__(
        self,
        start: Parameter,
        stop: Parameter,
        n_points: Parameter,
        *args: Any,
        **kwargs: Any,
    ):
        super().__init__(*args, **kwargs)
        self._start = start
        self._stop = stop
        self._n_points = n_points

    def get_raw(self) -> np.ndarray:
        start = self._start()
        assert start is not None
        stop = self._stop()
        assert stop is not None
        n_points = self._n_points()
        assert n_points is not None

        return np.linspace(start, stop, n_points)


class Keithley7510Buffer(InstrumentChannel):
    """"""
    Treat the reading buffer as a submodule, similar to Sense.
    """"""

    default_buffer = {""defbuffer1"", ""defbuffer2""}

    buffer_elements = {
        ""date"": ""DATE"",
        ""measurement_formatted"": ""FORMatted"",
        ""fractional_seconds"": ""FRACtional"",
        ""measurement"": ""READing"",
        ""relative_time"": ""RELative"",
        ""seconds"": ""SEConds"",
        ""measurement_status"": ""STATus"",
        ""time"": ""TIME"",
        ""timestamp"": ""TSTamp"",
        ""measurement_unit"": ""UNIT"",
    }

    inverted_buffer_elements = invert_val_mapping(buffer_elements)

    def __init__(
        self,
        parent: ""Keithley7510"",
        name: str,
        size: Optional[int] = None,
        style: str = """",
    ) -> None:
        super().__init__(parent, name)
        self._size = size
        self.style = style

        if self.short_name not in self.default_buffer:
            # when making a new buffer, the ""size"" parameter is required.
            if size is None:
                raise TypeError(
                    ""buffer() missing 1 required positional argument: 'size'""
                )
            self.write(f"":TRACe:MAKE '{self.short_name}', {self._size}, {self.style}"")
        else:
            # when referring to default buffer, ""size"" parameter is not needed.
            if size is not None:
                self.log.warning(
                    f""Please use method 'size()' to resize default buffer ""
                    f""{self.short_name} size to {self._size}.""
                )

        self.add_parameter(
            ""size"",
            get_cmd=f"":TRACe:POINts? '{self.short_name}'"",
            set_cmd=f"":TRACe:POINts {{}}, '{self.short_name}'"",
            get_parser=int,
            docstring=""The number of readings a buffer can store."",
        )

        self.add_parameter(
            ""number_of_readings"",
            get_cmd=f"":TRACe:ACTual? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the number of readings in the reading buffer."",
        )

        self.add_parameter(
            ""last_index"",
            get_cmd=f"":TRACe:ACTual:END? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the last index of readings in the reading buffer."",
        )

        self.add_parameter(
            ""first_index"",
            get_cmd=f"":TRACe:ACTual:STARt? '{self.short_name}'"",
            get_parser=int,
            docstring=""Get the starting index of readings in the reading "" ""buffer."",
        )

        self.add_parameter(
            ""data_start"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            docstring=""First index of the data to be returned."",
        )

        self.add_parameter(
            ""data_end"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            docstring=""Last index of the data to be returned."",
        )

        self.add_parameter(
            ""elements"",
            get_cmd=None,
            get_parser=self._from_scpi_to_name,
            set_cmd=None,
            set_parser=self._from_name_to_scpi,
            vals=Lists(Enum(*list(self.buffer_elements.keys()))),
            docstring=""List of buffer elements to read."",
        )

        self.add_parameter(
            ""setpoints_start"",
            label=""start value for the setpoints"",
            source=None,
            parameter_class=DelegateParameter,
        )

        self.add_parameter(
            ""setpoints_stop"",
            label=""stop value for the setpoints"",
            source=None,
            parameter_class=DelegateParameter,
        )

        self.add_parameter(
            ""n_pts"", label=""total n for the setpoints"", get_cmd=self._get_n_pts
        )

        self.add_parameter(
            ""setpoints"",
            parameter_class=GeneratedSetPoints,
            start=self.setpoints_start,
            stop=self.setpoints_stop,
            n_points=self.n_pts,
            vals=Arrays(shape=(self.n_pts.get_latest,)),
        )

        self.add_parameter(
            ""t_start"",
            label=""start time"",
            unit=""s"",
            initial_value=0,
            get_cmd=None,
            set_cmd=None,
            set_parser=float,
        )

        self.add_parameter(
            ""t_stop"",
            label=""stop time"",
            unit=""s"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            set_parser=float,
        )

        self.add_parameter(
            ""fill_mode"",
            get_cmd=f"":TRACe:FILL:MODE? '{self.short_name}'"",
            set_cmd=f"":TRACe:FILL:MODE {{}}, '{self.short_name}'"",
            vals=Enum(""CONT"", ""continuous"", ""ONCE"", ""once""),
            docstring=""if a reading buffer is filled continuously or is filled""
            "" once and stops"",
        )

    def _from_name_to_scpi(self, element_names: list[str]) -> list[str]:
        return [self.buffer_elements[element] for element in element_names]

    def _from_scpi_to_name(self, element_scpis: list[str]) -> list[str]:
        if element_scpis is None:
            return []
        return [self.inverted_buffer_elements[element] for element in element_scpis]

    def _get_n_pts(self) -> int:
        return self.data_end() - self.data_start() + 1

    def set_setpoints(
        self, start: Parameter, stop: Parameter, label: Optional[str] = None
    ) -> None:
        self.setpoints_start.source = start
        self.setpoints_stop.source = stop
        self.setpoints.unit = start.unit
        if label is not None:
            self.setpoints.label = label

    def __enter__(self) -> ""Keithley7510Buffer"":
        return self

    def __exit__(
        self,
        exception_type: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None:
        self.delete()

    @property
    def available_elements(self) -> set[str]:
        return set(self.buffer_elements.keys())

    @property
    def n_elements(self) -> int:
        return max(1, len(self.elements()))

    @property
    def data(self) -> DataArray7510:
        return self._get_data()

    def get_last_reading(self) -> str:
        """"""
        This method requests the latest reading from a reading buffer.

        """"""
        if not self.elements():
            return self.ask(f"":FETCh? '{self.short_name}'"")
        fetch_elements = [self.buffer_elements[element] for element in self.elements()]
        return self.ask(f"":FETCh? '{self.short_name}', {','.join(fetch_elements)}"")

    def _get_data(self) -> DataArray7510:
        """"""
        This command returns the data in the buffer, depends on the user
        selected elements.
        """"""
        try:
            _ = self.setpoints()
        except NotImplementedError:
            # if the ""setpionts"" has not been implemented, use a time series
            # with parameters ""t_start"" and ""t_stop"":
            self.set_setpoints(self.t_start, self.t_stop)

        if self.parent.digi_sense_function() == ""None"":
            # when current sense is not digitize sense
            sense_function = self.parent.sense_function()
            unit = Keithley7510Sense.function_modes[sense_function][""unit""]
        else:
            # when current sense is digitize sense
            sense_function = self.parent.digi_sense_function()
            unit = Keithley7510DigitizeSense.function_modes[sense_function][""unit""]

        elements_units = {
            ""date"": ""str"",
            ""measurement_formatted"": ""str"",
            ""fractional_seconds"": ""s"",
            ""measurement"": unit,
            ""relative_time"": ""s"",
            ""seconds"": ""s"",
            ""measurement_status"": """",
            ""time"": ""str"",
            ""timestamp"": ""str"",
            ""measurement_unit"": ""str"",
        }

        if not self.elements():
            raw_data = self.ask(
                f"":TRACe:DATA? ""
                f""{self.data_start()}, ""
                f""{self.data_end()}, ""
                f""'{self.short_name}'""
            )
        else:
            elements = [self.buffer_elements[element] for element in self.elements()]
            raw_data = self.ask(
                f"":TRACe:DATA? {self.data_start()}, ""
                f""{self.data_end()}, ""
                f""'{self.short_name}', ""
                f""{','.join(elements)}""
            )

        all_data = raw_data.split("","")

        if len(self.elements()) == 0:
            elements = [""measurement""]
        else:
            elements = self.elements()
        n_elements = len(elements)

        units = tuple(elements_units[element] for element in elements)
        processed_data = dict.fromkeys(elements)
        for i, (element, unit) in enumerate(zip(elements, units)):
            if unit == ""str"":
                processed_data[element] = np.array(all_data[i::n_elements])
            else:
                processed_data[element] = np.array(
                    [float(v) for v in all_data[i::n_elements]]
                )

        data = DataArray7510(
            names=tuple(elements),
            shapes=((self.n_pts(),),) * n_elements,
            units=units,
            setpoints=((self.setpoints(),),) * n_elements,
            setpoint_units=((self.setpoints.unit,),) * n_elements,
            setpoint_names=((self.setpoints.label,),) * n_elements,
        )
        data._data = tuple(
            tuple(processed_data[element]) for element in elements  # type: ignore[arg-type]
        )
        for i in range(len(data.names)):
            setattr(data, data.names[i], tuple(processed_data[data.names[i]]))  # type: ignore[arg-type]
        return data

    def clear_buffer(self) -> None:
        """"""
        Clear the data in the buffer
        """"""
        self.write(f"":TRACe:CLEar '{self.short_name}'"")

    def trigger_start(self) -> None:
        """"""
        This method makes readings using the active measure function and
        stores them in a reading buffer.
        """"""
        self.write(f"":TRACe:TRIGger '{self.short_name}'"")

    def delete(self) -> None:
        if self.short_name not in self.default_buffer:
            self.parent.submodules.pop(f""_buffer_{self.short_name}"")
            self.parent.buffer_name(""defbuffer1"")
            self.write(f"":TRACe:DELete '{self.short_name}'"")


class Keithley7510Sense(InstrumentChannel):
    """"""
    The sense module of the Keithley 7510 DMM, based on the sense module of
    Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of modes listed in the dictionary
            ""function_modes"", e.g.,  ""current"", ""voltage"", or ""resistance"".
            ""voltage""/""current"" is for DC voltage/current.
            ""Avoltage""/""Acurrent"" is for AC voltage/current.
            ""resistance"" is for two-wire measurement of resistance.
            ""Fresistance"" is for Four-wire measurement of resistance.

            All parameters and methods in this submodule should only be
            accessible to the user if
            self.parent.sense_function.get() == self._proper_function. We
            ensure this through the 'sense' property on the main driver class
            which returns the proper submodule for any given function mode.
    """"""

    function_modes = {
        ""voltage"": {
            ""name"": '""VOLT:DC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 1000),
        },
        ""Avoltage"": {
            ""name"": '""VOLT:AC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 700),
        },
        ""current"": {
            ""name"": '""CURR:DC""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(10e-6, 10),
        },
        ""Acurrent"": {
            ""name"": '""CURR:AC""',
            ""unit"": ""A"",
            ""range_vals"": Numbers(1e-3, 10),
        },
        ""resistance"": {
            ""name"": '""RES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(10, 1e9),
        },
        ""Fresistance"": {
            ""name"": '""FRES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(1, 1e9),
        },
    }

    def __init__(self, parent: VisaInstrument, name: str, proper_function: str) -> None:

        super().__init__(parent, name)

        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.sense_function

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            get_parser=float,
            unit=unit,
            docstring=""Make measurements, place them in a reading buffer, and ""
            ""return the last reading."",
        )

        self.add_parameter(
            ""auto_range"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO?"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Determine if the measurement range is set manually or ""
            ""automatically for the selected measure function."",
        )

        self.add_parameter(
            ""range"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe?"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe {{}}"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
            docstring=""Determine the positive full-scale measure range."",
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=f"":SENSe:{self._proper_function}:NPLCycles?"",
            set_cmd=f"":SENSe:{self._proper_function}:NPLCycles {{}}"",
            vals=Numbers(0.01, 10),
            get_parser=float,
            docstring=""Set the time that the input signal is measured for the ""
            ""selected function.(NPLC = number of power line cycles)"",
        )

        self.add_parameter(
            ""auto_delay"",
            get_cmd=f"":SENSe:{self._proper_function}:DELay:AUTO?"",
            set_cmd=f"":SENSe:{self._proper_function}:DELay:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Enable or disable the automatic delay that occurs ""
            ""before each measurement."",
        )

        self.add_parameter(
            ""user_number"",
            get_cmd=None,
            set_cmd=None,
            vals=Ints(1, 5),
            docstring=""Set the user number for user-defined delay."",
        )

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            vals=Numbers(0, 1e4),
            unit=""second"",
            docstring=""Set a user-defined delay that you can use in the ""
            ""trigger model."",
        )

        self.add_parameter(
            ""auto_zero"",
            get_cmd=f"":SENSe:{self._proper_function}:AZERo?"",
            set_cmd=f"":SENSe:{self._proper_function}:AZERo {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enable or disable automatic updates to the internal ""
            ""reference measurements (autozero) of the instrument."",
        )

        self.add_parameter(
            ""auto_zero_once"",
            set_cmd="":SENSe:AZERo:ONCE"",
            docstring=""Cause the instrument to refresh the reference and ""
            ""zero measurements once"",
        )

        self.add_parameter(
            ""average"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enable or disable the averaging filter for measurements ""
            ""of the selected function."",
        )

        self.add_parameter(
            ""average_count"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage:COUNt?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage:COUNt {{}}"",
            vals=Numbers(1, 100),
            docstring=""Set the number of measurements that are averaged when ""
            ""filtering is enabled."",
        )

        self.add_parameter(
            ""average_type"",
            get_cmd=f"":SENSe:{self._proper_function}:AVERage:TCONtrol?"",
            set_cmd=f"":SENSe:{self._proper_function}:AVERage:TCONtrol {{}}"",
            vals=Enum(""REP"", ""rep"", ""MOV"", ""mov""),
            docstring=""Set the type of averaging filter that is used for the ""
            ""selected measure function when the measurement filter ""
            ""is enabled."",
        )

    def _get_user_delay(self) -> str:
        get_cmd = f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return self.ask(get_cmd)

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()} {value}""
        )
        self.write(set_cmd)

    def _measure(self) -> Union[float, str]:
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure? '{buffer_name}'""))

    def clear_trace(self, buffer_name: str = ""defbuffer1"") -> None:
        """"""
        Clear the data buffer
        """"""
        self.write(f"":TRACe:CLEar '{buffer_name}'"")


class Keithley7510DigitizeSense(InstrumentChannel):
    """"""
    The Digitize sense module of the Keithley 7510 DMM.
    """"""

    function_modes: dict[str, dict[str, Any]] = {
        ""None"": {""name"": '""NONE""', ""unit"": """", ""range_vals"": None},
        ""voltage"": {
            ""name"": '""VOLT""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(0.1, 1000),
        },
        ""current"": {
            ""name"": '""CURR""',
            ""unit"": ""V"",
            ""range_vals"": Numbers(10e-6, 10),
        },
    }

    def __init__(self, parent: VisaInstrument, name: str, proper_function: str) -> None:

        super().__init__(parent, name)

        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.digi_sense_function

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            unit=unit,
            docstring=""Make measurements, place them in a reading buffer, and ""
            ""return the last reading."",
        )

        self.add_parameter(
            ""range"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:RANGe?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:RANGe {{}}"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
            docstring=""Determine the positive full-scale measure range."",
        )

        self.add_parameter(
            ""input_impedance"",
            get_cmd="":SENSe:DIGitize:VOLTage:INPutimpedance?"",
            set_cmd="":SENSe:DIGitize:VOLTage:INPutimpedance {}"",
            vals=Enum(""AUTO"", ""MOHM10""),
            docstring=""Determine when the 10 MΩ input divider is enabled. ""
            ""'MOHM10' means 10 MΩ for all ranges."",
        )

        self.add_parameter(
            ""acq_rate"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:SRATE?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:SRATE {{}}"",
            vals=Ints(1000, 1000000),
            docstring=""Define the precise acquisition rate at which the ""
            ""digitizing measurements are made."",
        )

        self.add_parameter(
            ""aperture"",
            get_cmd=f"":SENSe:DIGitize:{self._proper_function}:APERture?"",
            set_cmd=f"":SENSe:DIGitize:{self._proper_function}:APERture {{}}"",
            unit=""us"",
            docstring=""Determine the aperture setting."",
        )

        self.add_parameter(
            ""count"",
            get_cmd=""SENSe:DIGitize:COUNt?"",
            set_cmd=""SENSe:DIGitize:COUNt {}"",
            vals=Ints(1, 55000000),
            docstring=""Set the number of measurements to digitize when a ""
            ""measurement is requested"",
        )

    def _measure(self) -> Union[float, str]:
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure:DIGitize? '{buffer_name}'""))


class Keithley7510(VisaInstrument):
    """"""
    The QCoDeS driver for the Keithley 7510 DMM
    """"""

    def __init__(self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""sense_function"",
            set_cmd="":SENSe:FUNCtion {}"",
            get_cmd="":SENSe:FUNCtion?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley7510Sense.function_modes.items()
            },
            docstring=""Add sense functions listed in the function modes."",
        )

        self.add_parameter(
            ""digi_sense_function"",
            set_cmd="":DIGitize:FUNCtion {}"",
            get_cmd="":DIGitize:FUNCtion?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley7510DigitizeSense.function_modes.items()
            },
            docstring=""Make readings using the active digitize function."",
        )

        self.add_parameter(
            ""buffer_name"",
            get_cmd=None,
            set_cmd=None,
            docstring=""Name of the reading buffer in use."",
        )

        self.add_parameter(
            ""trigger_block_list"",
            get_cmd="":TRIGger:BLOCk:LIST?"",
            docstring=""Return the settings for all trigger model blocks."",
        )

        self.add_parameter(
            ""trigger_in_ext_clear"",
            set_cmd="":TRIGger:EXTernal:IN:CLEar"",
            docstring=""Clear the trigger event on the external in line."",
        )

        self.add_parameter(
            ""trigger_in_ext_edge"",
            get_cmd="":TRIGger:EXTernal:IN:EDGE?"",
            set_cmd="":TRIGger:EXTernal:IN:EDGE {}"",
            vals=Enum(""FALL"", ""RIS"", ""falling"", ""rising"", ""EITH"", ""either""),
            docstring=""Type of edge that is detected as an input on the ""
            ""external trigger in line"",
        )

        self.add_parameter(
            ""overrun_status"",
            get_cmd="":TRIGger:EXTernal:IN:OVERrun?"",
            docstring=""Return the event detector overrun status."",
        )

        self.add_parameter(
            ""digitize_trigger"",
            get_cmd="":TRIGger:DIGitize:STIMulus?"",
            set_cmd="":TRIGger:DIGitize:STIMulus {}"",
            vals=Enum(""EXT"", ""external"", ""NONE""),
            docstring=""Set the instrument to digitize a measurement the next ""
            ""time it detects the specified trigger event."",
        )

        self.add_parameter(
            ""system_errors"",
            get_cmd="":SYSTem:ERRor?"",
            docstring=""Return the oldest unread error message from the event ""
            ""log and removes it from the log."",
        )

        for proper_sense_function in Keithley7510Sense.function_modes:
            self.add_submodule(
                f""_sense_{proper_sense_function}"",
                Keithley7510Sense(self, ""sense"", proper_sense_function),
            )

        for proper_sense_function in Keithley7510DigitizeSense.function_modes:
            self.add_submodule(
                f""_digi_sense_{proper_sense_function}"",
                Keithley7510DigitizeSense(self, ""digi_sense"", proper_sense_function),
            )

        self.buffer_name(""defbuffer1"")
        self.buffer(name=self.buffer_name())
        self.connect_message()

    @property
    def sense(self) -> Keithley7510Sense:
        """"""
        We have different sense modules depending on the sense function.

        Return the correct source module based on the sense function.
        """"""
        sense_function = self.sense_function.get_latest() or self.sense_function()
        submodule = self.submodules[f""_sense_{sense_function}""]
        return cast(Keithley7510Sense, submodule)

    @property
    def digi_sense(self) -> Keithley7510DigitizeSense:
        """"""
        We have different sense modules depending on the sense function.

        Return the correct source module based on the sense function.
        """"""
        if self.digi_sense_function() == ""None"":
            raise AttributeError(
                ""Please use 'digi_sense_function()' to select""
                "" a digitize function first""
            )
        sense_function = (
            self.digi_sense_function.get_latest() or self.digi_sense_function()
        )
        submodule = self.submodules[f""_digi_sense_{sense_function}""]
        return cast(Keithley7510DigitizeSense, submodule)

    def buffer(
        self, name: str, size: Optional[int] = None, style: str = """"
    ) -> Keithley7510Buffer:
        self.buffer_name(name)
        if f""_buffer_{name}"" in self.submodules:
            return cast(Keithley7510Buffer, self.submodules[f""_buffer_{name}""])
        new_buffer = Keithley7510Buffer(parent=self, name=name, size=size, style=style)
        self.add_submodule(f""_buffer_{name}"", new_buffer)
        return new_buffer

    def initiate(self) -> None:
        """"""
        This command starts the trigger model.
        """"""
        self.write("":INITiate"")

    def wait(self) -> None:
        """"""
        This command postpones the execution of subsequent commands until all
        previous overlapped commands are finished.
        """"""
        self.write(""*WAI"")

    def clear_status(self) -> None:
        """"""
        This command clears the event registers of the Questionable Event and
        Operation Event Register set. It does not affect the Questionable Event
        Enable or Operation Event Enable registers.
        """"""
        self.write(""*CLS"")

    def reset(self) -> None:
        """"""
        Returns the instrument to default settings, cancels all pending
        commands.
        """"""
        self.write(""*RST"")
"
34,5420.0,USA,"The Keysight N5222B PNA Microwave Network Analyzer 10 MHz to 26.5 GHz is an integrated and flexible test engine that can measure active devices such as amplifiers, mixers, and frequency converters. This analyzer operates at a frequency range of 900 Hz to 26.5 GHz. The Keysight N5222B provides a combination of excellent hardware and powerful measurement applications to measure a broad range of devices quickly and accurately. ",Keysight N 5222 B,288.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 5222B Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT 5222B,https://www.keysight.com/us/en/assets/9018-03959/technical-specifications/9018-03959.pdf,"[OrderedDict([('id', 'attZoKpo6CTDzBvzw'), ('width', 500), ('height', 311), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OW9q4uvTbqdUksL7GwaGUQ/PsqUCOy3idGhZ6iL_D8KOa5ehMMzqIt4q_oXD9xt_eDR0NtVMcBZ0xfBA9UgN0BW2gwNwLt8qIJAewMj0qoFvUVKU8R3MilzNFM3BrXRw04/nuNiNI3pjOFM2QdP3QA7I_CKa3i1ii8UC6oiyJoXgN4'), ('filename', 'N5222B.2.jpg'), ('size', 32062), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PM-p-F1fTIg4WeqHMwQEwA/GyAsxbzc9Yop1LL1_1c5tmN2IFvlOgAHAxeUNk6T2iLgXKhWg4OhGNzmp6MYQMQMqEUhvweN8ek9j7rJ04tPcQ/lCRPTA1FwYXjE_PulHwRTu1ZVXoc41vbBq0AleYeNUc'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jo0KhZfXElLJKwevIMxJzQ/RE2GISUn9JheWuGx-LCIAjYBq1H_bQTSBec1c-WP6r8SfwedIByOiJLmNW6SPK_6ufirP3O5AkkFgCmZ7tBI_w/MgZlEAp0Ub0AdIMUyx-ofXFmAXXHe-cNfmbsT6l6iAE'), ('width', 500), ('height', 311)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fPqr-g6MUWPBEmYocHzPQQ/Kzr77AUCCD01kQ3Rsw9Je82pVfgL17pxxerDfLRyrkTK-LsJrIn3A444Btt81e-wCPXngRGhl57uxZW_66zHAQ/wRpQUaZYx16wN7Uxteqyb6ymxEfGiaHCXuERrP424Ss'), ('width', 3000), ('height', 3000)]))]))])]",https://www.atecorp.com/products/keysight-technologies/n5222b,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N52xx.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5222B,,,,,"from typing import Sequence, Union, Any
import time
import re
import logging

import numpy as np
from pyvisa import VisaIOError, errors
from qcodes import (VisaInstrument, InstrumentChannel, ArrayParameter,
                    ChannelList)
from qcodes.utils.validators import Ints, Numbers, Enum, Bool

logger = logging.getLogger()

class PNASweep(ArrayParameter):
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 **kwargs: Any) -> None:

        super().__init__(name,
                         instrument=instrument,
                         shape=(0,),
                         setpoints=((0,),),
                         **kwargs)

    @property  # type: ignore[override]
    def shape(self) -> Sequence[int]:  # type: ignore[override]
        if self._instrument is None:
            return (0,)
        return (self._instrument.root_instrument.points(),)

    @shape.setter
    def shape(self, val: Sequence[int]) -> None:
        pass

    @property  # type: ignore[override]
    def setpoints(self) -> Sequence[np.ndarray]:  # type: ignore[override]
        if self._instrument is None:
            raise RuntimeError(""Cannot return setpoints if not attached ""
                               ""to instrument"")
        start = self._instrument.root_instrument.start()
        stop = self._instrument.root_instrument.stop()
        return (np.linspace(start, stop, self.shape[0]),)

    @setpoints.setter
    def setpoints(self, val: Sequence[int]) -> None:
        pass


class FormattedSweep(PNASweep):
    """"""
    Mag will run a sweep, including averaging, before returning data.
    As such, wait time in a loop is not needed.
    """"""
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 sweep_format: str,
                 label: str,
                 unit: str,
                 memory: bool = False) -> None:
        super().__init__(name,
                         instrument=instrument,
                         label=label,
                         unit=unit,
                         setpoint_names=('frequency',),
                         setpoint_labels=('Frequency',),
                         setpoint_units=('Hz',)
                         )
        self.sweep_format = sweep_format
        self.memory = memory

    def get_raw(self) -> Sequence[float]:
        if self._instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr = self._instrument.root_instrument
        # Check if we should run a new sweep
        if root_instr.auto_sweep():
            prev_mode = self._instrument.run_sweep()
        # Ask for data, setting the format to the requested form
        self._instrument.format(self.sweep_format)
        data = root_instr.visa_handle.query_binary_values('CALC:DATA? FDATA',
                                                          datatype='f',
                                                          is_big_endian=True)
        data = np.array(data)
        # Restore previous state if it was changed
        if root_instr.auto_sweep():
            root_instr.sweep_mode(prev_mode)

        return data


class PNAPort(InstrumentChannel):
    """"""
    Allow operations on individual PNA ports.
    Note: This can be expanded to include a large number of extra parameters...
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 port: int,
                 min_power: Union[int, float],
                 max_power: Union[int, float]) -> None:
        super().__init__(parent, name)

        self.port = int(port)
        if self.port < 1 or self.port > 4:
            raise ValueError(""Port must be between 1 and 4."")

        pow_cmd = f""SOUR:POW{self.port}""
        self.add_parameter(""source_power"",
                           label=""power"",
                           unit=""dBm"",
                           get_cmd=f""{pow_cmd}?"",
                           set_cmd=f""{pow_cmd} {{}}"",
                           get_parser=float,
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.source_power.vals = Numbers(min_value=min_power,
                                         max_value=max_power)


class PNATrace(InstrumentChannel):
    """"""
    Allow operations on individual PNA traces.
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 trace_name: str,
                 trace_num: int) -> None:
        super().__init__(parent, name)
        self.trace_name = trace_name
        self.trace_num = trace_num

        # Name of parameter (i.e. S11, S21 ...)
        self.add_parameter('trace',
                           label='Trace',
                           get_cmd=self._Sparam,
                           set_cmd=self._set_Sparam)
        # Format
        # Note: Currently parameters that return complex values are not
        # supported as there isn't really a good way of saving them into the
        # dataset
        self.add_parameter('format',
                           label='Format',
                           get_cmd='CALC:FORM?',
                           set_cmd='CALC:FORM {}',
                           vals=Enum('MLIN', 'MLOG', 'PHAS',
                                     'UPH', 'IMAG', 'REAL'))

        # And a list of individual formats
        self.add_parameter('magnitude',
                           sweep_format='MLOG',
                           label='Magnitude',
                           unit='dB',
                           parameter_class=FormattedSweep)
        self.add_parameter('linear_magnitude',
                           sweep_format='MLIN',
                           label='Magnitude',
                           unit='ratio',
                           parameter_class=FormattedSweep)
        self.add_parameter('phase',
                           sweep_format='PHAS',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter('unwrapped_phase',
                           sweep_format='UPH',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter(""group_delay"",
                           sweep_format='GDEL',
                           label='Group Delay',
                           unit='s',
                           parameter_class=FormattedSweep)
        self.add_parameter('real',
                           sweep_format='REAL',
                           label='Real',
                           unit='LinMag',
                           parameter_class=FormattedSweep)
        self.add_parameter('imaginary',
                           sweep_format='IMAG',
                           label='Imaginary',
                           unit='LinMag',
                           parameter_class=FormattedSweep)

    def run_sweep(self) -> str:
        """"""
        Run a set of sweeps on the network analyzer.
        Note that this will run all traces on the current channel.
        """"""
        root_instr = self.root_instrument
        # Store previous mode
        prev_mode = root_instr.sweep_mode()
        # Take instrument out of continuous mode, and send triggers equal to
        # the number of averages
        if root_instr.averages_enabled():
            avg = root_instr.averages()
            root_instr.reset_averages()
            root_instr.group_trigger_count(avg)
            root_instr.sweep_mode('GRO')
        else:
            root_instr.sweep_mode('SING')

        # Once the sweep mode is in hold, we know we're done
        try:
            while root_instr.sweep_mode() != 'HOLD':
                time.sleep(0.1)
        except KeyboardInterrupt:
            # If the user aborts because (s)he is stuck in the infinite loop
            # mentioned above, provide a hint of what can be wrong.
            msg = ""User abort detected. ""
            source = root_instr.trigger_source()
            if source == ""MAN"":
                msg += ""The trigger source is manual. Are you sure this is "" \
                       ""correct? Please set the correct source with the "" \
                       ""'trigger_source' parameter""
            elif source == ""EXT"":
                msg += ""The trigger source is external. Is the trigger "" \
                       ""source functional?""
            logger.warning(msg)

        # Return previous mode, incase we want to restore this
        return prev_mode

    def write(self, cmd: str) -> None:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        super().write(cmd)

    def ask(self, cmd: str) -> str:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        return super().ask(cmd)

    def _Sparam(self) -> str:
        """"""
        Extrace S_parameter from returned PNA format
        """"""
        paramspec = self.root_instrument.get_trace_catalog()
        specs = paramspec.split(',')
        for spec_ind in range(len(specs)//2):
            name, param = specs[spec_ind*2:(spec_ind+1)*2]
            if name == self.trace_name:
                return param
        raise RuntimeError(""Can't find selected trace on the PNA"")

    def _set_Sparam(self, val: str) -> None:
        """"""
        Set an S-parameter, in the format S<a><b>, where a and b
        can range from 1-4
        """"""
        if not re.match(""S[1-4][1-4]"", val):
            raise ValueError(""Invalid S parameter spec"")
        self.write(f""CALC:PAR:MOD:EXT \""{val}\"""")


class PNABase(VisaInstrument):
    """"""
    Base qcodes driver for Agilent/Keysight series PNAs
    http://na.support.keysight.com/pna/help/latest/Programming/GP-IB_Command_Finder/SCPI_Command_Tree.htm

    Note: Currently this driver only expects a single channel on the PNA. We
          can handle multiple traces, but using traces across multiple channels
          may have unexpected results.
    """"""

    def __init__(self,
                 name: str,
                 address: str,
                 # Set frequency ranges
                 min_freq: Union[int, float], max_freq: Union[int, float],
                 # Set power ranges
                 min_power: Union[int, float], max_power: Union[int, float],
                 nports: int, # Number of ports on the PNA
                 **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.min_freq = min_freq
        self.max_freq = max_freq

        #Ports
        ports = ChannelList(self, ""PNAPorts"", PNAPort)
        for port_num in range(1, nports+1):
            port = PNAPort(self, f""port{port_num}"", port_num,
                           min_power, max_power)
            ports.append(port)
            self.add_submodule(f""port{port_num}"", port)
        ports.lock()
        self.add_submodule(""ports"", ports)

        # Drive power
        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

        # IF bandwidth
        self.add_parameter('if_bandwidth',
                           label='IF Bandwidth',
                           get_cmd='SENS:BAND?',
                           get_parser=float,
                           set_cmd='SENS:BAND {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=1, max_value=15e6))

        # Number of averages (also resets averages)
        self.add_parameter('averages_enabled',
                           label='Averages Enabled',
                           get_cmd=""SENS:AVER?"",
                           set_cmd=""SENS:AVER {}"",
                           val_mapping={True: '1', False: '0'})
        self.add_parameter('averages',
                           label='Averages',
                           get_cmd='SENS:AVER:COUN?',
                           get_parser=int,
                           set_cmd='SENS:AVER:COUN {:d}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=65536))

        # Setting frequency range
        self.add_parameter('start',
                           label='Start Frequency',
                           get_cmd='SENS:FREQ:STAR?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STAR {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('stop',
                           label='Stop Frequency',
                           get_cmd='SENS:FREQ:STOP?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STOP {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('center',
                           label='Center Frequency',
                           get_cmd='SENS:FREQ:CENT?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:CENT {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('span',
                           label='Frequency Span',
                           get_cmd='SENS:FREQ:SPAN?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:SPAN {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))

        # Number of points in a sweep
        self.add_parameter('points',
                           label='Points',
                           get_cmd='SENS:SWE:POIN?',
                           get_parser=int,
                           set_cmd='SENS:SWE:POIN {}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=100001))

        # Electrical delay
        self.add_parameter('electrical_delay',
                           label='Electrical Delay',
                           get_cmd='CALC:CORR:EDEL:TIME?',
                           get_parser=float,
                           set_cmd='CALC:CORR:EDEL:TIME {:.6e}',
                           unit='s',
                           vals=Numbers(min_value=0, max_value=100000))

        # Sweep Time
        self.add_parameter('sweep_time',
                           label='Time',
                           get_cmd='SENS:SWE:TIME?',
                           get_parser=float,
                           unit='s',
                           vals=Numbers(0, 1e6))
        # Sweep Mode
        self.add_parameter('sweep_mode',
                           label='Mode',
                           get_cmd='SENS:SWE:MODE?',
                           set_cmd='SENS:SWE:MODE {}',
                           vals=Enum(""HOLD"", ""CONT"", ""GRO"", ""SING""))
        # Group trigger count
        self.add_parameter('group_trigger_count',
                           get_cmd=""SENS:SWE:GRO:COUN?"",
                           get_parser=int,
                           set_cmd=""SENS:SWE:GRO:COUN {}"",
                           vals=Ints(1, 2000000))
        # Trigger Source
        self.add_parameter('trigger_source',
                           get_cmd=""TRIG:SOUR?"",
                           set_cmd=""TRIG:SOUR {}"",
                           vals=Enum(""EXT"", ""IMM"", ""MAN""))

        # Traces
        self.add_parameter('active_trace',
                           label='Active Trace',
                           get_cmd=""CALC:PAR:MNUM?"",
                           get_parser=int,
                           set_cmd=""CALC:PAR:MNUM {}"",
                           vals=Numbers(min_value=1, max_value=24))
        # Note: Traces will be accessed through the traces property which
        # updates the channellist to include only active trace numbers
        self._traces = ChannelList(self, ""PNATraces"", PNATrace)
        self.add_submodule(""traces"", self._traces)
        # Add shortcuts to first trace
        trace1 = self.traces[0]
        params = trace1.parameters
        if not isinstance(params, dict):
            raise RuntimeError(f""Expected trace.parameters to be a dict got ""
                               f""{type(params)}"")
        for param in params.values():
            self.parameters[param.name] = param
        # And also add a link to run sweep
        self.run_sweep = trace1.run_sweep
        # Set this trace to be the default (it's possible to end up in a
        # situation where no traces are selected, causing parameter snapshots
        # to fail)
        self.active_trace(trace1.trace_num)

        # Set auto_sweep parameter
        # If we want to return multiple traces per setpoint without sweeping
        # multiple times, we should set this to false
        self.add_parameter('auto_sweep',
                           label='Auto Sweep',
                           set_cmd=None,
                           get_cmd=None,
                           vals=Bool(),
                           initial_value=True)

        # A default output format on initialisation
        self.write('FORM REAL,32')
        self.write('FORM:BORD NORM')

        self.connect_message()

    @property
    def traces(self) -> ChannelList:
        """"""
        Update channel list with active traces and return the new list
        """"""
        # Keep track of which trace was active before. This command may fail
        # if no traces were selected.
        try:
            active_trace = self.active_trace()
        except VisaIOError as e:
            if e.error_code == errors.StatusCode.error_timeout:
                active_trace = None
            else:
                raise

        # Get a list of traces from the instrument and fill in the traces list
        parlist = self.get_trace_catalog().split("","")
        self._traces.clear()
        for trace_name in parlist[::2]:
            trace_num = self.select_trace_by_name(trace_name)
            pna_trace = PNATrace(self, f""tr{trace_num}"",
                                 trace_name, trace_num)
            self._traces.append(pna_trace)

        # Restore the active trace if there was one
        if active_trace:
            self.active_trace(active_trace)

        # Return the list of traces on the instrument
        return self._traces

    def get_options(self) -> Sequence[str]:
        # Query the instrument for what options are installed
        return self.ask('*OPT?').strip('""').split(',')

    def get_trace_catalog(self) -> str:
        """"""
        Get the trace catalog, that is a list of trace and sweep types
        from the PNA.

        The format of the returned trace is:
            trace_name,trace_type,trace_name,trace_type...
        """"""
        return self.ask(""CALC:PAR:CAT:EXT?"").strip('""')

    def select_trace_by_name(self, trace_name: str) -> int:
        """"""
        Select a trace on the PNA by name.

        Returns:
            The trace number of the selected trace
        """"""
        self.write(f""CALC:PAR:SEL '{trace_name}'"")
        return self.active_trace()

    def reset_averages(self) -> None:
        """"""
        Reset averaging
        """"""
        self.write(""SENS:AVER:CLE"")

    def averages_on(self) -> None:
        """"""
        Turn on trace averaging
        """"""
        self.averages_enabled(True)

    def averages_off(self) -> None:
        """"""
        Turn off trace averaging
        """"""
        self.averages_enabled(False)

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.power.vals = Numbers(min_value=min_power,
                                  max_value=max_power)
        for port in self.ports:
            port._set_power_limits(min_power, max_power)


class PNAxBase(PNABase):
    def _enable_fom(self) -> None:
        '''
        PNA-x units with two sources have an enormous list of functions &
        configurations. In practice, most of this will be set up manually on
        the unit, with power and frequency varied in a sweep.
        '''
        self.add_parameter('aux_frequency',
                           label='Aux Frequency',
                           get_cmd='SENS:FOM:RANG4:FREQ:CW?',
                           get_parser=float,
                           set_cmd='SENS:FOM:RANG4:FREQ:CW {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=self.min_freq,
                                        max_value=self.max_freq))
"
37,4.0,CANADA - QC,ATS9373 is a 12-bit waveform digitizer board that can sample one analog input at rates up to 4 GS/s or two inputs at 2 GS/s.,ATS 9373,63.0,"Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",Qcodes,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h8yDC782gmJYILVwetqyNg/XNft-iYe6x8LEFTaoDNdcglx8uZWwUUbNf4oX-ErBZYvya3nvf9i0ao4jJp70hHk7oN7wtgcaboMWlcRtFbUeccPNbUJ0Ajzieb7_-0dOvY/M5yDXUl_TYlDiCuUg_-hevxefX_4ZGtn62x5xIZ0wso'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gmlldA7Zo_-OSPyZsu7mPQ/XKZDoQmgc3wi6TkdRJNKT5dYVGwmvfciyRHelmq94Fmnai7rVErHtEDREKJXu9_IHjQS7AeXExr0raP0i8qt9g/rKROdmQfR-K5ATu1ZN_qmcHLCXjquZ1AQFi7pM4PIRY'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-xGoEh8NzGkRqLzjthJ-1A/El2jn-9r8vkBM8mzLCyPAJp4mhEuwwyz-Mjkamgj3Nb-6HmhSMwQGCrm1aoGHp3LwUNAI6zroK3Xqc0OGV9org/tjN2cvTq9f28KHrk67tlaSmFHLwgdKOLL8IIa1-o5us'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t_PiUYdPzQjLjJU9vEarJQ/uVumfw7c89vOKsptIyuF2g3LBU5I8wWQSuR2hRnlrVTLECKdyi_DwwHGMI6y2EQRUFS6qlkmQtCh3GYKCuYvqg/FS3WfkFziiTlklsy7j-a1DSgE14IyXx9JDShkxKJwrQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,"Write a Python script that uses Qcodes to connect to a ATS9373 - 12 bit, 4 GS/s DAQ boards",https://en.wikipedia.org/wiki/Analog-to-digital_converter,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","ATS9373 - 12 bit, 4 GS/s",https://www.alazartech.com/en/download/product/9064/300/ats9373-datasheet-and-specifications/1-6n/,"[OrderedDict([('id', 'att14GxiD8DuYiJSe'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OnQiZ6z3EH7eL9_7yf2cfw/7TRtHR_gPhbTtp0MRWupRugLbrEJDJRKCn6BKowUWvf_EJwN-5hetWF0eXgnHo63gt5aza15UD33SW90U0IEo_wQOExnn-JMklDUEmHRwao/r75frF2hkw2pG6qKh67JiBMw3b5WZom1i2Tpz005TM8'), ('filename', 'ATS9373.jpg'), ('size', 499073), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Jih9kea-YaJRzrwhdSPsgA/SGm5Zyxt7-8m35f5aWjKcJpNuGseNPpomixfrR0XPUq9sc_viME0Iqzqh9ZSX9gEZWcnXr624BLuvX5SwcouNg/O7ivCege_dq42pMw3gwe_MutK_BygTr4--bhLVdPAIE'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vtv3W2UjqCYfH_FFsE_ndQ/tfqLLtspBu62lOjnShBUyj6OogB8wSy8hO3YJQRHlden9D8l_uzXqTzyT2AGN_FTvnzsPPAw9a1V6Y96UeOO_w/0UUvg1NvUVhlIigoTQmqwsB3jgSUP0V_fWPWLLRan8I'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NfIHuZMPZI3QJlWb1-6w1A/fSeYfwHC7enaOPCQEcI6hdpgvz2aQ6rvQiH0amlEHn1nqhUEYNQtVCGt4OYi0gstP5zQ_zNfHXWYM0vzekL_5g/W5EXTH96lkEiXi_ozoo6JXgTSdkC-VIpizPsiIRw_XY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/en/product/ats9373/2/,https://github.com/Exopy/exopy_hqc_legacy/blob/main/exopy_hqc_legacy/instruments/drivers/dll/atsapi.py,https://qcodes.github.io/Qcodes/_modules/qcodes/instrument_drivers/AlazarTech/ATS9373.html,,"
",,,"# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# This file comes AlazarTech SDK and was edited by ExopyHqcLegacy Authors
# see AUTHORS for more details.
#
# -----------------------------------------------------------------------------
""""""Python interface to the AlazarTech SDK.

This module provides a thin wrapper on top of the AlazarTech C
API. All the exported methods directly map to underlying C
functions. Please see the ATS-SDK Guide for detailed specification of
these functions. In addition, this module provides a few classes for
convenience.

Attributes:

  Board: Represents a digitizer. Provides methods for configuration
  and data acquisition

  DMABuffer: Holds a memory buffer suitable for data transfer with
  digitizers.

""""""

# ExopyHqcLegacy modifications:
# - use numpy for memory allocation in DMABuffer
# - remove tk WaitBar
# - delay the loading of the ats library

from ctypes import (CDLL, byref, c_byte, c_int, c_long, c_float, c_uint32,
                    c_int64, c_void_p, c_char_p)
import numpy as np
import os

'''Types of clocks that a board can use for acquiring data.
Note: Available sources for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.
'''
INTERNAL_CLOCK = 0x1
EXTERNAL_CLOCK = 0x2
FAST_EXTERNAL_CLOCK = 0x2
MEDIUM_EXTERNAL_CLOCK = 0x3
SLOW_EXTERNAL_CLOCK = 0x4
EXTERNAL_CLOCK_AC = 0x5
EXTERNAL_CLOCK_DC = 0x6
EXTERNAL_CLOCK_10MHz_REF = 0x7
INTERNAL_CLOCK_10MHz_REF = 0x8
EXTERNAL_CLOCK_10MHz_PXI = 0xA
INTERNAL_CLOCK_DIV_4 = 0xF
INTERNAL_CLOCK_DIV_5 = 0x10
MASTER_CLOCK = 0x11
INTERNAL_CLOCK_SET_VCO = 0x12

'''Sample rates that the internal clock of a board can generate.

Note: Available sample rates for a given board form a subset of
this class' members. Please see your board's specification as well
as the ATS-SDK manual for more information.

'''
SAMPLE_RATE_1KSPS = 0x1
SAMPLE_RATE_2KSPS = 0x2
SAMPLE_RATE_5KSPS = 0x5
SAMPLE_RATE_10KSPS = 0x8
SAMPLE_RATE_20KSPS = 0xA
SAMPLE_RATE_50KSPS = 0xC
SAMPLE_RATE_100KSPS = 0xE
SAMPLE_RATE_200KSPS = 0x10
SAMPLE_RATE_500KSPS = 0x12
SAMPLE_RATE_1MSPS = 0x14
SAMPLE_RATE_2MSPS = 0x18
SAMPLE_RATE_5MSPS = 0x1A
SAMPLE_RATE_10MSPS = 0x1C
SAMPLE_RATE_20MSPS = 0x1E
SAMPLE_RATE_25MSPS = 0x21
SAMPLE_RATE_50MSPS = 0x22
SAMPLE_RATE_100MSPS = 0x24
SAMPLE_RATE_125MSPS = 0x25
SAMPLE_RATE_160MSPS = 0x26
SAMPLE_RATE_180MSPS = 0x27
SAMPLE_RATE_200MSPS = 0x28
SAMPLE_RATE_250MSPS = 0x2B
SAMPLE_RATE_400MSPS = 0x2D
SAMPLE_RATE_500MSPS = 0x30
SAMPLE_RATE_800MSPS = 0x32
SAMPLE_RATE_1000MSPS = 0x35
SAMPLE_RATE_1200MSPS = 0x37
SAMPLE_RATE_1500MSPS = 0x3A
SAMPLE_RATE_1600MSPS = 0x3B
SAMPLE_RATE_1800MSPS = 0x3D
SAMPLE_RATE_2000MSPS = 0x3F
SAMPLE_RATE_2400MSPS = 0x6A
SAMPLE_RATE_3000MSPS = 0x75
SAMPLE_RATE_3600MSPS = 0x7B
SAMPLE_RATE_4000MSPS = 0x80
SAMPLE_RATE_USER_DEF = 0x40

'''Direction of the edge from the external clock signal that the board
syncrhonises with.'''
CLOCK_EDGE_RISING = 0
CLOCK_EDGE_FALLING = 1

'''Board input channel identifiers

Note: The channels available for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.

'''
CHANNEL_A = 0x1
CHANNEL_B = 0x2
CHANNEL_C = 0x4
CHANNEL_D = 0x8
CHANNEL_E = 0x16
CHANNEL_F = 0x32
CHANNEL_G = 0x64
CHANNEL_H = 0x128
CHANNEL_I = 0x256
CHANNEL_J = 0x512
CHANNEL_K = 0x1024
CHANNEL_L = 0x2048
CHANNEL_M = 0x4096
CHANNEL_N = 0x8192
CHANNEL_O = 0x16384
CHANNEL_P = 0x32768

channels = [
    CHANNEL_A,
    CHANNEL_B,
    CHANNEL_C,
    CHANNEL_D,
    CHANNEL_E,
    CHANNEL_F,
    CHANNEL_G,
    CHANNEL_H,
    CHANNEL_I,
    CHANNEL_J,
    CHANNEL_K,
    CHANNEL_L,
    CHANNEL_M,
    CHANNEL_N,
    CHANNEL_O,
    CHANNEL_P
]

'''AutoDMA acquisitions flags

Note: Not all AlazarTech devices are capable of dual-ported
acquisitions. Please see your board's specification for more
information.
'''
ADMA_TRADITIONAL_MODE = 0
ADMA_NPT = 0x200
ADMA_CONTINUOUS_MODE = 0x100
ADMA_TRIGGERED_STREAMING = 0x400
ADMA_EXTERNAL_STARTCAPTURE = 0x1
ADMA_ENABLE_RECORD_HEADERS = 0x8
ADMA_ALLOC_BUFFERS = 0x20
ADMA_FIFO_ONLY_STREAMING = 0x800
ADMA_INTERLEAVE_SAMPLES = 0x1000
ADMA_GET_PROCESSED_DATA = 0x2000

'''Boards'''
ATS850  = 1
ATS310  = 2
ATS330  = 3
ATS855  = 4
ATS315  = 5
ATS335  = 6
ATS460  = 7
ATS860  = 8
ATS660  = 9
ATS665  = 10
ATS9462 = 11
ATS9434 = 12
ATS9870 = 13
ATS9350 = 14
ATS9325 = 15
ATS9440 = 16
ATS9410 = 17
ATS9351 = 18
ATS9310 = 19
ATS9461 = 20
ATS9850 = 21
ATS9625 = 22
ATG6500 = 23
ATS9626 = 24
ATS9360 = 25
AXI9870 = 26
ATS9370 = 27
ATU7825 = 28
ATS9373 = 29
ATS9416 = 30

boardNames = {
    ATS850 : ""ATS850"" ,
    ATS310 : ""ATS310"" ,
    ATS330 : ""ATS330"" ,
    ATS855 : ""ATS855"" ,
    ATS315 : ""ATS315"" ,
    ATS335 : ""ATS335"" ,
    ATS460 : ""ATS460"" ,
    ATS860 : ""ATS860"" ,
    ATS660 : ""ATS660"" ,
    ATS665 : ""ATS665"" ,
    ATS9462: ""ATS9462"",
    ATS9434: ""ATS9434"",
    ATS9870: ""ATS9870"",
    ATS9350: ""ATS9350"",
    ATS9325: ""ATS9325"",
    ATS9440: ""ATS9440"",
    ATS9410: ""ATS9410"",
    ATS9351: ""ATS9351"",
    ATS9310: ""ATS9310"",
    ATS9461: ""ATS9461"",
    ATS9850: ""ATS9850"",
    ATS9625: ""ATS9625"",
    ATG6500: ""ATG6500"",
    ATS9626: ""ATS9626"",
    ATS9360: ""ATS9360"",
    AXI9870: ""AXI9870"",
    ATS9370: ""ATS9370"",
    ATU7825: ""ATU7825"",
    ATS9373: ""ATS9373"",
    ATS9416: ""ATS9416""
}


'''Board input ranges (amplitudes) identifiers. PM stands for
plus/minus.

Note: Available input ranges for a given board _and_ a given
configuration form a subset of this class' members. Please see
your board's specification as well as the ATS-SDK manual for more
information.

'''
INPUT_RANGE_PM_40_MV = 0x2
INPUT_RANGE_PM_50_MV = 0x3
INPUT_RANGE_PM_80_MV = 0x4
INPUT_RANGE_PM_100_MV = 0x5
INPUT_RANGE_PM_200_MV = 0x6
INPUT_RANGE_PM_400_MV = 0x7
INPUT_RANGE_PM_500_MV = 0x8
INPUT_RANGE_PM_800_MV = 0x9
INPUT_RANGE_PM_1_V = 0xA
INPUT_RANGE_PM_2_V = 0xB
INPUT_RANGE_PM_4_V = 0xC
INPUT_RANGE_PM_5_V = 0xD
INPUT_RANGE_PM_8_V = 0xE
INPUT_RANGE_PM_10_V = 0xF
INPUT_RANGE_PM_20_V = 0x10
INPUT_RANGE_PM_40_V = 0x11
INPUT_RANGE_PM_16_V = 0x12
INPUT_RANGE_HIFI = 0x20
INPUT_RANGE_PM_1_V_25 = 0x21
INPUT_RANGE_PM_2_V_5  = 0x25
INPUT_RANGE_PM_125_MV = 0x28
INPUT_RANGE_PM_250_MV = 0x30

'''Coupling types identifiers for all boards input'''
AC_COUPLING = 1
DC_COUPLING = 2

'''Trigger engine identifiers.'''
TRIG_ENGINE_J = 0
TRIG_ENGINE_K = 1

'''Trigger engine operation identifiers.'''
TRIG_ENGINE_OP_J = 0
TRIG_ENGINE_OP_K = 1
TRIG_ENGINE_OP_J_OR_K = 2
TRIG_ENGINE_OP_J_AND_K = 3
TRIG_ENGINE_OP_J_XOR_K = 4
TRIG_ENGINE_OP_J_AND_NOT_K = 5
TRIG_ENGINE_OP_NOT_J_AND_K = 6

'''Types of input that the board can trig on.'''
TRIG_CHAN_A = 0
TRIG_CHAN_B = 1
TRIG_CHAN_C = 4
TRIG_CHAN_D = 5
TRIG_EXTERNAL = 2
TRIG_DISABLE = 3

'''Edge of the external trigger signal that the board syncrhonises with.'''
TRIGGER_SLOPE_POSITIVE = 1
TRIGGER_SLOPE_NEGATIVE = 2

'''Impedance identifiers for the board inputs.

Note: Available parameters for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.

'''
IMPEDANCE_1M_OHM = 1
IMPEDANCE_50_OHM = 2
IMPEDANCE_75_OHM = 4
IMPEDANCE_300_OHM = 8

'''External trigger range identifiers.'''
ETR_5V = 0
ETR_1V = 1
ETR_TTL = 2
ETR_2V5 = 3

'''LED State'''
LED_OFF = 0
LED_ON = 1

'''LSB Values'''
LSB_DEFAULT = 0
LSB_EXT_TRIG = 1
LSB_AUX_IN_0 = 2
LSB_AUX_IN_1 = 3

'''Operating modes for the auxiliary input/output port.'''
AUX_OUT_TRIGGER = 0
AUX_IN_TRIGGER_ENABLE = 1
AUX_OUT_PACER = 2
AUX_IN_AUXILIARY = 13
AUX_OUT_SERIAL_DATA = 14

'''Parameters for setParameter'''
SETGET_ASYNC_BUFFCOUNT = 0x10000040
SET_DATA_FORMAT        = 0x10000041
ECC_MODE               = 0x10000048

'''Parameters that apply to some modes of the auxiliary input/output
port.'''
TRIGGER_SLOPE_POSITIVE = 1
TRIGGER_SLOPE_NEGATIVE = 2

'''Record average options'''
CRA_MODE_DISABLE = 0
CRA_MODE_ENABLE_FPGA_AVE = 1
CRA_OPTION_UNSIGNED = 0
CRA_OPTION_SIGNED = 1

'''Reset timestamp'''
TIMESTAMP_RESET_FIRSTTIME_ONLY = 0
TIMESTAMP_RESET_ALWAYS = 1

'''Sleep State'''
POWER_OFF = 0
POWER_ON = 1


class DMABuffer(object):
    '''Buffer suitable for DMA transfers.

    AlazarTech digitizers use direct memory access (DMA) to transfer
    data from digitizers to the computer's main memory. This class
    abstracts a memory buffer on the host, and ensures that all the
    requirements for DMA transfers are met.

    DMABuffers export a 'buffer' member, which is a NumPy array view
    of the underlying memory buffer

    Args:

      bytes_per_sample (int): The number of bytes per samples of the
      data. This varies with digitizer models and configurations.

      size_bytes (int): The size of the buffer to allocate, in bytes.

    '''
    def __init__(self, bytes_per_sample, size_bytes):
        self.size_bytes = size_bytes

        np_sample_type = np.uint8
        if bytes_per_sample > 1:
            np_sample_type = np.uint16

        self.buffer = np.empty(size_bytes//bytes_per_sample, np_sample_type)
        self.addr = self.buffer.ctypes.data_as(c_void_p)


#: Global variable used to store the dynamically loaded library
ats = None

# C types used by Alazar
U32 = c_uint32
U8 = c_byte


def load_library():
    """"""Load the ATS library and register the c signatures.

    """"""
    global ats
    if os.name == 'nt':
        ats = CDLL(""ATSApi.dll"")
    elif os.name == 'posix':
        ats = CDLL(""libATSApi.so"")
    else:
        raise Exception(""Unsupported OS"")

    # Registering c signature for ctypes to perform automatic conversions
    ats.AlazarErrorToText.restype = c_char_p
    ats.AlazarErrorToText.argtypes = [U32]

    ats.AlazarGetBoardBySystemID.restype = U32
    ats.AlazarGetBoardBySystemID.argtypes = [U32, U32]

    ats.AlazarGetBoardKind.restype = U32
    ats.AlazarGetBoardKind.argtypes = [U32]

    ats.AlazarAbortAsyncRead.restype = U32
    ats.AlazarAbortAsyncRead.argtypes = [U32]
    ats.AlazarAbortAsyncRead.errcheck = returnCodeCheck

    ats.AlazarAbortCapture.restype = U32
    ats.AlazarAbortCapture.argtypes = [U32]
    ats.AlazarAbortCapture.errcheck = returnCodeCheck

    ats.AlazarBeforeAsyncRead.restype = U32
    ats.AlazarBeforeAsyncRead.argtypes = [U32, U32, c_long, U32, U32, U32, U32]
    ats.AlazarBeforeAsyncRead.errcheck = returnCodeCheck

    ats.AlazarBusy.restype = U32
    ats.AlazarBusy.argtypes = [U32]

    ats.AlazarConfigureAuxIO.restype = U32
    ats.AlazarConfigureAuxIO.argtypes = [U32, U32, U32]
    ats.AlazarConfigureAuxIO.errcheck = returnCodeCheck

    ats.AlazarConfigureLSB.restype = U32
    ats.AlazarConfigureLSB.argtypes = [U32, U32, U32]
    ats.AlazarConfigureLSB.errcheck = returnCodeCheck

    ats.AlazarConfigureRecordAverage.restype = U32
    ats.AlazarConfigureRecordAverage.argtypes = [U32, U32, U32, U32, U32]
    ats.AlazarConfigureRecordAverage.errcheck = returnCodeCheck

    ats.AlazarForceTrigger.restype = U32
    ats.AlazarForceTrigger.argtypes = [U32]
    ats.AlazarForceTrigger.errcheck = returnCodeCheck

    ats.AlazarForceTriggerEnable.restype = U32
    ats.AlazarForceTriggerEnable.argtypes = [U32]
    ats.AlazarForceTriggerEnable.errcheck = returnCodeCheck

    ats.AlazarGetChannelInfo.restype = U32
    ats.AlazarGetChannelInfo.argtypes = [U32, c_void_p, c_void_p]

    ats.AlazarInputControl.restype = U32
    ats.AlazarInputControl.argtypes = [U32, U8, U32, U32, U32]
    ats.AlazarInputControl.errcheck = returnCodeCheck

    ats.AlazarNumOfSystems.restype = U32
    ats.AlazarNumOfSystems.argtypes = []

    ats.AlazarPostAsyncBuffer.restype = U32
    ats.AlazarPostAsyncBuffer.argtypes = [U32, c_void_p, U32]
    ats.AlazarPostAsyncBuffer.errcheck = returnCodeCheck

    ats.AlazarReadEx.restype = U32
    ats.AlazarReadEx.argtypes = [U32, U32, c_void_p, c_int, c_long,
                                 c_int64, U32]
    ats.AlazarReadEx.errcheck = returnCodeCheck

    ats.AlazarResetTimeStamp.restype = U32
    ats.AlazarResetTimeStamp.argtypes = [U32, U32]
    ats.AlazarResetTimeStamp.errcheck = returnCodeCheck

    ats.AlazarSetBWLimit.restype = U32
    ats.AlazarSetBWLimit.argtypes = [U32, U32, U32]
    ats.AlazarSetBWLimit.errcheck = returnCodeCheck

    ats.AlazarSetCaptureClock.restype = U32
    ats.AlazarSetCaptureClock.argtypes = [U32, U32, U32, U32, U32]
    ats.AlazarSetCaptureClock.errcheck = returnCodeCheck

    ats.AlazarSetExternalClockLevel.restype = U32
    ats.AlazarSetExternalClockLevel.argtypes = [U32, c_float]
    ats.AlazarSetExternalClockLevel.errcheck = returnCodeCheck

    ats.AlazarSetExternalTrigger.restype = U32
    ats.AlazarSetExternalTrigger.argtypes = [U32, U32, U32]
    ats.AlazarSetExternalTrigger.errcheck = returnCodeCheck

    ats.AlazarSetLED.restype = U32
    ats.AlazarSetLED.argtypes = [U32, U32]
    ats.AlazarSetLED.errcheck = returnCodeCheck

    ats.AlazarSetParameter.restype = U32
    ats.AlazarSetParameter.argtypes = [U32, U8, U32, c_long]
    ats.AlazarSetParameter.errcheck = returnCodeCheck

    ats.AlazarSetParameterUL.restype = U32
    ats.AlazarSetParameterUL.argtypes = [U32, U8, U32, c_long]
    ats.AlazarSetParameterUL.errcheck = returnCodeCheck

    ats.AlazarSetRecordCount.restype = U32
    ats.AlazarSetRecordCount.argtypes = [U32, U32]
    ats.AlazarSetRecordCount.errcheck = returnCodeCheck

    ats.AlazarSetRecordSize.restype = U32
    ats.AlazarSetRecordSize.argtypes = [U32, U32, U32]
    ats.AlazarSetRecordSize.errcheck = returnCodeCheck

    ats.AlazarSetTriggerDelay.restype = U32
    ats.AlazarSetTriggerDelay.argtypes = [U32, U32]
    ats.AlazarSetTriggerDelay.errcheck = returnCodeCheck

    ats.AlazarSetTriggerOperation.restype = U32
    ats.AlazarSetTriggerOperation.argtypes = [U32, U32, U32, U32, U32, U32,
                                              U32, U32, U32, U32]
    ats.AlazarSetTriggerOperation.errcheck = returnCodeCheck

    ats.AlazarSetTriggerTimeOut.restype = U32
    ats.AlazarSetTriggerTimeOut.argtypes = [U32, U32]
    ats.AlazarSetTriggerTimeOut.errcheck = returnCodeCheck

    ats.AlazarSleepDevice.restype = U32
    ats.AlazarSleepDevice.argtypes = [U32, U32]
    ats.AlazarSleepDevice.errcheck = returnCodeCheck

    ats.AlazarStartCapture.restype = U32
    ats.AlazarStartCapture.argtypes = [U32]
    ats.AlazarStartCapture.errcheck = returnCodeCheck

    ats.AlazarTriggered.restype = U32
    ats.AlazarTriggered.argtypes = [U32]

    ats.AlazarWaitAsyncBufferComplete.restype = U32
    ats.AlazarWaitAsyncBufferComplete.argtypes = [U32, c_void_p, U32]
    ats.AlazarWaitAsyncBufferComplete.errcheck = returnCodeCheck


def returnCodeCheck(result, func, arguments):
    '''Function used internally to check the return code of the C ATS-SDK
    functions.'''
    if (result != 512):
        raise Exception(""Error calling function %s with arguments %s : %s"" %
                        (func.__name__,
                         str(arguments),
                         str(ats.AlazarErrorToText(result))))


class Board(object):
    """"""Interface to an AlazarTech digitizer.

    The Board class represents an acquisition device on the local
    system. It can be used to control configuration parameters, to
    start acquisitions and to retrieve the acquired data.

    Args:

      systemId (int): The board system identifier of the target
      board. Defaults to 1, which is suitable when there is only one
      board in the system.

      boardId (int): The target's board identifier in it's
      system. Defaults to 1, which is suitable when there is only one
      board in the system.

    """"""
    def __init__(self, systemId=1, boardId=1):
        if ats is None:
            load_library()
        self.systemId = systemId
        self.boardId = boardId
        self.handle = ats.AlazarGetBoardBySystemID(systemId, boardId)
        if self.handle == 0:
            raise Exception(""Board %d.%d not found"" % (systemId, boardId))

        self.type = ats.AlazarGetBoardKind(self.handle)

    def abortAsyncRead(self):
        """"""Cancels any asynchronous acquisition running on a board.

        """"""
        ats.AlazarAbortAsyncRead(self.handle)

    def abortCapture(self):
        """"""Abort an acquisition to on-board memory.

        """"""
        ats.AlazarAbortCapture(self.handle)

    def beforeAsyncRead(self, channels, transferOffset, samplesPerRecord,
                        recordsPerBuffer, recordsPerAcquisition, flags):
        """"""Prepares the board for an asynchronous acquisition.

        """"""
        ats.AlazarBeforeAsyncRead(self.handle, channels, transferOffset,
                                  samplesPerRecord, recordsPerBuffer,
                                  recordsPerAcquisition, flags)

    def busy(self):
        """"""Determine if an acquisition to on-board memory is in progress.

        """"""
        return True if (ats.AlazarBusy(self.handle) > 0) else False

    def configureAuxIO(self, mode, parameter):
        """"""Configures the auxiliary output.

        """"""
        ats.AlazarConfigureAuxIO(self.handle, mode, parameter)

    def configureLDB(self, valueLSB0, valueLSB1):
        """"""Change unused bits to digital outputs.

        """"""
        ats.AlazarConfigureLSB(self.handle, valueLSB0, valueLSB1)

    def configureRecordAverage(self, mode, samplesPerRecord, recordsPerAverage,
                               options):
        """"""Co-add ADC samples into accumulator record.

        """"""
        ats.AlazarConfigureRecordAverage(self.handle, mode, samplesPerRecord,
                                         recordsPerAverage, options)

    def forceTrigger(self):
        """"""Generate a software trigger event.

        """"""
        ats.AlazarForceTrigger(self.handle)

    def forceTriggerEnable(self):
        """"""Generate a software trigger enable event.

        """"""
        ats.AlazarForceTriggerEnable(self.handle)

    def getChannelInfo(self):
        """"""Get the on-board memory in samples per channel and sample size in
        bits per sample.

        """"""
        memorySize_samples = U32(0)
        bitsPerSample = U8(0)
        ats.AlazarGetChannelInfo(self.handle, byref(memorySize_samples),
                                 byref(bitsPerSample))
        return (memorySize_samples, bitsPerSample)

    def inputControl(self, channel, coupling, inputRange, impedance):
        """"""Configures one input channel on a board.

        """"""
        ats.AlazarInputControl(self.handle, channel, coupling, inputRange,
                               impedance)

    def numOfSystems():
        """"""Returns the number of board systems installed.

        """"""
        ats.AlazarNumOfSystems()

    def postAsyncBuffer(self, buffer, bufferLength):
        """"""Posts a DMA buffer to a board.

        """"""
        ats.AlazarPostAsyncBuffer(self.handle, buffer, bufferLength)

    def read(self, channelId, buffer, elementSize, record, transferOffset,
             transferLength):
        """"""Read all or part of a record from on-board memory.

        """"""
        ats.AlazarReadEx(self.handle, channelId, buffer, elementSize, record,
                         transferOffset, transferLength)

    def resetTimeStamp(self, option):
        """"""Control record timestamp counter reset.

        """"""
        ats.AlazarResetTimeStamp(self.handle, option)

    def setBWLimit(self, channel, enable):
        """"""Activates or deactivates the low-pass filter on a given channel.

        """"""
        ats.AlazarSetBWLimit(self.handle, channel, enable)

    def setCaptureClock(self, source, rate, edge, decimation):
        """"""Configures the board's acquisition clock.

        """"""
        ats.AlazarSetCaptureClock(self.handle,
                                  int(source),
                                  int(rate),
                                  int(edge),
                                  decimation)

    def setExternalClockLevel(self, level_percent):
        """"""Set the external clock comparator level.

        """"""
        ats.AlazarSetExternalClockLevel(self.handle, level_percent)

    def setExternalTrigger(self, coupling, range):
        """"""Configure the external trigger.

        """"""
        ats.AlazarSetExternalTrigger(self.handle, coupling, range)

    def setLED(self, ledState):
        """"""Control LED on a board's mounting bracket.

        """"""
        ats.AlazarSetLED(self.handle, ledState)

    def setParameter(self, channelId, parameterId, value):
        """"""Set a device parameter as a signed long value.

        """"""
        ats.AlazarSetParameter(self.handle, channelId, parameterId, value)

    def setParameterUL(self, channelId, parameterId, value):
        """"""Set a device parameter as a signed long value.

        """"""
        ats.AlazarSetParameterUL(self.handle, channelId, parameterId, value)

    def setRecordCount(self, count):
        """"""Configure the record count for single ported acquisitions.

        """"""
        ats.AlazarSetRecordCount(self.handle, count)

    def setRecordSize(self, preTriggerSamples, postTriggerSamples):
        """"""Configures the acquisition records size.

        """"""
        ats.AlazarSetRecordSize(self.handle, preTriggerSamples,
                                postTriggerSamples)

    def setTriggerDelay(self, delay_samples):
        """"""Configures the trigger delay.

        """"""
        ats.AlazarSetTriggerDelay(self.handle, delay_samples)

    def setTriggerOperation(self, operation,
                            engine1, source1, slope1, level1,
                            engine2, source2, slope2, level2):
        """"""Set trigger operation.

        """"""
        ats.AlazarSetTriggerOperation(
            self.handle, operation,
            engine1, source1, slope1, level1,
            engine2,
            source2,
            slope2,
            level2)

    def setTriggerTimeOut(self, timeout_clocks):
        """"""Configures the trigger timeout.

        """"""
        ats.AlazarSetTriggerTimeOut(self.handle, timeout_clocks)

    def sleepDevice(self, sleepState):
        """"""Control power to ADC devices.

        """"""
        ats.AlazarSleepDevice(self.handle, sleepState)

    def startCapture(self):
        """"""Starts the acquisition.

        """"""
        ats.AlazarStartCapture(self.handle)

    def triggered(self):
        """"""Determine if a board has triggered during the current acquisition.

        """"""
        return ats.AlazarTriggered(self.handle)

    def waitAsyncBufferComplete(self, buffer, timeout_ms):
        """"""Blocks until the board confirms that buffer is filled with data.

        """"""
        ats.AlazarWaitAsyncBufferComplete(self.handle, buffer, timeout_ms)
"
41,2500.0,"Munich, Germany","R&S®RTO oscilloscopes combine excellent signal fidelity, high acquisition rate and the world's first realtime digital trigger system with a compact device format in the 600 MHz to 4 GHz class.",RTE 1000,465.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a R&S RTE1000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,R&S RTE1000,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/service_support_30/RTO_dat-sw_en_5214-5155-22_v2800.pdf,"[OrderedDict([('id', 'attSRBg03GADmzUTH'), ('width', 2880), ('height', 1620), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Qy9wD2-vqKnR0BTisolUtQ/YjmYDPwz-MqTfz_WXNDd8w5b9RDytZsLU8noJoqWaRLuYRc2nidfFAzg6TK7Ujan2Eewu38H9gwhhV5Pz75WKrAvSBt3x35Vf85A3_-ucm3JuIzf2Lp1ilLPMHzqRX3j8YJmpvAag8ObSnr4leRZP1YXc03qRX_jXDAmqKi1XnM/MUslbKGslt7hspXOPzBkDZhXhla6xCCJBRJAENwDrHw'), ('filename', 'rte1000-oscilloscope-front-view-rohde-schwarz_200_2206_2880_1620_1.jpg'), ('size', 523383), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NBEi9NJ36HLgrr3FYaL5yQ/ePRUwhSp-za0mbeOLz_JYMAiNDscwCdyHtFjj7NG1tua4bI6rN9_A1BgCUFHtQIFcww3oKafajT00pFSFCtnRw/HdW8bdB7eYs0WIAFzepPz14b4bBAQ_mDJMkUCD_xR0k'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Fkeego2DV4j2ecB3IM99PQ/Q_SrbozHxdDEqE39ybyOFSpZykRFssaY6IF5mntG_MSfEgJNdywOuwWGK79FvvIrDQI9H6MCUzbChk2BJyVdNQ/2wS1qBNTitRnxyrfuizrCiw_9a-xbsC2oX6aE_RuXj8'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FArfv37w2hr7ecKXV_ptag/xxVfgZ9d87d-38EnCkravD51__uI7aE-cYbbE1cTw0E1I4yyUoxwU1O9IFWYW2cgyduxZiu6y5yLUm-u8hy11A/USmVBf8-7qh5hVHsEXNpTprpHjWTXii6vKJNrU562rA'), ('width', 3000), ('height', 3000)]))]))])]","https://www.rohde-schwarz.com/brochure-datasheet/rto1000/#:~:text=R%26S%C2%AERTO%20oscilloscopes%20combine,MHz%20to%204%20GHz%20class.",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/RTE1000.py,,,,True,,"# Ensuring backwards compatibility

from .RTO1000 import RTO1000 as RTE1000
"
42,2500.0,"Munich, Germany","With an acquisition memory of 400 Mpts per channel simultaneously for all four channels, the oscilloscope offers up to 100 times the memory depth of comparable devices as standard.

The R&S MXO 4 oscilloscopes offer the world's highest update rate of 4.5 million waveforms per second.",RTO 1000,464.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a R&S RTO1000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,R&S RTO1000,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/service_support_30/RTO_dat-sw_en_5214-5155-22_v2800.pdf,"[OrderedDict([('id', 'attVQtWBQ73ZpqeVq'), ('width', 2880), ('height', 1620), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oCDcBs-5SVv9L1ZKUlocdg/tQQFOIYnd0Bd5X6OygzHKppIkyQkh14gnaj9ZIdLa50GSa0Mwbg0rGGeuLY7TGNruwC-6Fa5Ju0ErFxqq2p0bCkJ3PPfFYBkN_nU5etcw491_JrhTqcyxTUPZ0gbzSiBZW02s9VTuyZT0_0YAzwa4pZbSz1xyjukUHY1Mm3OogtsYze-c7BZDFOBEIPnL_Px/4vmpp-lw2d7gW__2pcbzq6BF0gGR137ktbw8svqmof8'), ('filename', 'rto1000-digital-oscilloscope-front-view-rohde-schwarz_200_13475_2880_1620_3.jpg'), ('size', 535832), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UdDIbjO664Iy4cfw5pgv1w/oOyBbsBFh2iKqXFenyp7r8Z1yaQwaZji9Vn_S8WTNC-GD1IhbC4mhbwFLWTh_uZ9qP4nFeGV9sdgYlPUqhXxKg/WzidFC-OBqg8Aady48xWbKrlvKKynN-ZVda_QLPYnB8'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/D6zNLttNdM8UMnhLSfbdPg/mObFr0ySBVoCx9UiDGcFjCoU29ga9NQL0gqJsogbbqLYkNdz_4pz2Nu9ZbWMLqRUeh782g1eR3ro-OjiLkGUEw/V1IpCix7x8t9gaNFJQTg265ocPrHb1KdVT1YqXm74_4'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mB2cEBLDRGMUMg-iKS5REw/ZtBWqfD8rwxVD-Q9o74j2ibB-0NcllLudIoSkTxA91fi0dbQ3x0pepfl1FFtOrJ5d7nWMoM3_FQapbjjbfvKIQ/4xh3T2uZXg1Wr_EKrgZpnxyz2LHLzalc1W7L05PmCgw'), ('width', 3000), ('height', 3000)]))]))])]","https://www.batronix.com/shop/rohde-schwarz/RTE1000.html#:~:text=RTE1000%20Oscilloscopes&text=With%20an%20acquisition%20memory%20of,4.5%20million%20waveforms%20per%20second.",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/RTO1000.py,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzRTO1000,,,True,,"# All manual references are to R&S RTO Digital Oscilloscope User Manual
# for firmware 3.65, 2017

import logging
import time
import warnings
from typing import Any, Optional

import numpy as np
from packaging import version

import qcodes.validators as vals
from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, create_on_off_val_mapping

log = logging.getLogger(__name__)


class ScopeTrace(ArrayParameter):
    def __init__(
        self, name: str, instrument: InstrumentChannel, channum: int, **kwargs: Any
    ) -> None:
        """"""
        The ScopeTrace parameter is attached to a channel of the oscilloscope.

        For now, we only support reading out the entire trace.
        """"""
        super().__init__(
            name=name,
            shape=(1,),
            label=""Voltage"",  # TODO: Is this sometimes dbm?
            unit=""V"",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""Holds scope trace"",
            snapshot_value=False,
            instrument=instrument,
            **kwargs,
        )

        self.channel = instrument
        self.channum = channum
        self._trace_ready = False

    def prepare_trace(self) -> None:
        """"""
        Prepare the scope for returning data, calculate the setpoints
        """"""
        assert self.root_instrument is not None

        # We always use 16 bit integers for the data format
        self.root_instrument.dataformat(""INT,16"")
        # ensure little-endianess
        self.root_instrument.write(""FORMat:BORder LSBFirst"")
        # only export y-values
        self.root_instrument.write(""EXPort:WAVeform:INCXvalues OFF"")
        # only export one channel
        self.root_instrument.write(""EXPort:WAVeform:MULTichannel OFF"")

        # now get setpoints

        hdr = self.root_instrument.ask(f""CHANnel{self.channum}:"" ""DATA:HEADER?"")
        hdr_vals = list(map(float, hdr.split("","")))
        t_start = hdr_vals[0]
        t_stop = hdr_vals[1]
        no_samples = int(hdr_vals[2])
        values_per_sample = hdr_vals[3]

        # NOTE (WilliamHPNielsen):
        # If samples are multi-valued, we need a `MultiParameter`
        # instead of an `ArrayParameter`.
        if values_per_sample > 1:
            raise NotImplementedError('There are several values per sample '
                                      'in this trace (are you using envelope'
                                      ' or peak detect?). We currently do '
                                      'not support saving such a trace.')

        self.shape = (no_samples,)
        self.setpoints = (tuple(np.linspace(t_start, t_stop, no_samples)),)

        self._trace_ready = True
        # we must ensure that all this took effect before proceeding
        self.root_instrument.ask(""*OPC?"")

    def get_raw(self) -> np.ndarray:
        """"""
        Returns a trace
        """"""

        instr = self.root_instrument
        assert instr is not None

        if not self._trace_ready:
            raise ValueError('Trace not ready! Please call '
                             'prepare_trace().')

        if instr.run_mode() == 'RUN Nx SINGLE':
            total_acquisitions = instr.num_acquisitions()
            completed_acquisitions = instr.completed_acquisitions()
            log.info(f'Acquiring {total_acquisitions} traces.')
            while completed_acquisitions < total_acquisitions:
                log.info(f'Acquired {completed_acquisitions}:'
                         f'{total_acquisitions}')
                time.sleep(0.25)
                completed_acquisitions = instr.completed_acquisitions()

        log.info('Acquisition completed. Polling trace from instrument.')
        vh = instr.visa_handle
        vh.write(f'CHANnel{self.channum}:DATA?')
        raw_vals = vh.read_raw()

        num_length = int(raw_vals[1:2])
        no_points = int(raw_vals[2:2+num_length])

        # cut of the header and the trailing '\n'
        raw_vals = raw_vals[2+num_length:-1]

        dataformat = instr.dataformat.get_latest()

        if dataformat == 'INT,8':
            int_vals = np.frombuffer(raw_vals, dtype=np.int8, count=no_points)
        else:
            int_vals = np.frombuffer(raw_vals, dtype=np.int16, count=no_points // 2)

        # now the integer values must be converted to physical
        # values

        scale = self.channel.scale()
        no_divs = 10  # TODO: Is this ever NOT 10?

        # we always export as 16 bit integers
        quant_levels = 253*256
        conv_factor = scale*no_divs/quant_levels
        output = conv_factor*int_vals + self.channel.offset()

        return output


class RohdeSchwarzRTO1000ScopeMeasurement(InstrumentChannel):
    """"""
    Class to hold a measurement of the scope.
    """"""

    def __init__(self, parent: Instrument, name: str, meas_nr: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached
            name: The name of the measurement
            meas_nr: The number of the measurement in question. Must match the
                actual number as used by the instrument (1..8)
        """"""

        if meas_nr not in range(1, 9):
            raise ValueError('Invalid measurement number; Min: 1, max 8')

        self.meas_nr = meas_nr
        super().__init__(parent, name)

        self.sources = vals.Enum('C1W1', 'C1W2', 'C1W3',
                                 'C2W1', 'C2W2', 'C2W3',
                                 'C3W1', 'C3W2', 'C3W3',
                                 'C4W1', 'C4W2', 'C4W3',
                                 'M1', 'M2', 'M3', 'M4',
                                 'R1', 'R2', 'R3',  'R4',
                                 'SBUS1', 'SBUS2', 'SBUS3', 'SBUS4',
                                 'D0', 'D1', 'D2', 'D3',
                                 'D4', 'D5', 'D6', 'D7',
                                 'D8', 'D9', 'D10', 'D11',
                                 'D12', 'D13', 'D14', 'D15',
                                 'TRK1', 'TRK2', 'TRK3', 'TRK4',
                                 'TRK5', 'TRK6', 'TRK7', 'TRK8',
                                 'SG1TL1', 'SG1TL2',
                                 'SG2TL1', 'SG2TL2',
                                 'SG3TL1', 'SG3TL2',
                                 'SG4TL1', 'SG4TL2',
                                 'Z1V1', 'Z1V2', 'Z1V3', 'Z1V4',
                                 'Z1I1', 'Z1I2', 'Z1I3', 'Z1I4',
                                 'Z2V1', 'Z2V2', 'Z2V3',  'Z2V4',
                                 'Z2I1', 'Z2I2', 'Z2I3', 'Z2I4')

        self.categories = vals.Enum('AMPTime', 'JITTer', 'EYEJitter',
                                    'SPECtrum', 'HISTogram', 'PROTocol')

        self.meas_type = vals.Enum(
                        # Amplitude/time measurements
                        'HIGH', 'LOW', 'AMPLitude',
                        'MAXimum', 'MINimum', 'PDELta',
                        'MEAN', 'RMS', 'STDDev',
                        'POVershoot', 'NOVershoot', 'AREA',
                        'RTIMe', 'FTIMe', 'PPULse',
                        'NPULse', 'PERiod', 'FREQuency',
                        'PDCYcle', 'NDCYcle', 'CYCarea',
                        'CYCMean', 'CYCRms', 'CYCStddev',
                        'PULCnt', 'DELay', 'PHASe',
                        'BWIDth', 'PSWitching', 'NSWitching',
                        'PULSetrain', 'EDGecount', 'SHT',
                        'SHR', 'DTOTrigger', 'PROBemeter',
                        'SLERising', 'SLEFalling',
                        # Jitter measurements
                        'CCJitter', 'NCJitter', 'CCWidth',
                        'CCDutycycle', 'TIE', 'UINTerval',
                        'DRATe', 'SKWDelay', 'SKWPhase',
                        # Eye diagram measurements
                        'ERPercent', 'ERDB', 'EHEight',
                        'EWIDth', 'ETOP', 'EBASe',
                        'QFACtor', 'RMSNoise', 'SNRatio',
                        'DCDistortion', 'ERTime', 'EFTime',
                        'EBRate', 'EAMPlitude', 'PPJitter',
                        'STDJitter', 'RMSJitter',
                        # Spectrum measurements
                        'CPOWer', 'OBWidth', 'SBWidth',
                        'THD', 'THDPCT', 'THDA',
                        'THDU', 'THDR', 'HAR',
                        'PLISt',
                        # Histogram measurements
                        'WCOunt', 'WSAMples', 'HSAMples',
                        'HPEak', 'PEAK', 'UPEakvalue',
                        'LPEakvalue', 'HMAXimum', 'HMINimum',
                        'MEDian', 'MAXMin', 'HMEan',
                        'HSTDdev', 'M1STddev', 'M2STddev',
                        'M3STddev', 'MKPositive', 'MKNegative'
                        )

        self.add_parameter('enable',
                           label=f'Measurement {meas_nr} enable',
                           set_cmd=f'MEASurement{meas_nr}:ENABle {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the measurement on or off.')

        self.add_parameter('source',
                           label=f'Measurement {meas_nr} source',
                           set_cmd=f'MEASurement{meas_nr}:SOURce {{}}',
                           vals=self.sources,
                           docstring='Set the source of a measurement if the '
                                     'measurement only needs one source.')

        self.add_parameter('source_first',
                           label=f'Measurement {meas_nr} first source',
                           set_cmd=f'MEASurement{meas_nr}:FSRC {{}}',
                           vals=self.sources,
                           docstring='Set the first source of a measurement'
                                     ' if the measurement only needs multiple'
                                     ' sources.')

        self.add_parameter('source_second',
                           label=f'Measurement {meas_nr} second source',
                           set_cmd=f'MEASurement{meas_nr}:SSRC {{}}',
                           vals=self.sources,
                           docstring='Set the second source of a measurement'
                                     ' if the measurement only needs multiple'
                                     ' sources.')

        self.add_parameter('category',
                           label=f'Measurement {meas_nr} category',
                           set_cmd=f'MEASurement{meas_nr}:CATegory {{}}',
                           vals=self.categories,
                           docstring='Set the category of a measurement.')

        self.add_parameter('main',
                           label=f'Measurement {meas_nr} main',
                           set_cmd=f'MEASurement{meas_nr}:MAIN {{}}',
                           vals=self.meas_type,
                           docstring='Set the main of a measurement.')

        self.add_parameter('statistics_enable',
                           label=f'Measurement {meas_nr} enable statistics',
                           set_cmd=f'MEASurement{meas_nr}:STATistics:ENABle'
                                   f' {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the measurement on or off.')

        self.add_parameter('clear',
                           label=f'Measurement {meas_nr} clear statistics',
                           set_cmd=f'MEASurement{meas_nr}:CLEar',
                           docstring='Clears/reset measurement.')

        self.add_parameter('event_count',
                           label=f'Measurement {meas_nr} number of events',
                           get_cmd=f'MEASurement{meas_nr}:RESult:EVTCount?',
                           get_parser=int,
                           docstring='Number of measurement results in the'
                                     ' long-term measurement.')

        self.add_parameter('result_avg',
                           label=f'Measurement {meas_nr} averages',
                           get_cmd=f'MEASurement{meas_nr}:RESult:AVG?',
                           get_parser=float,
                           docstring='Average of the long-term measurement'
                                     ' results.')


ScopeMeasurement = RohdeSchwarzRTO1000ScopeMeasurement


class RohdeSchwarzRTO1000ScopeChannel(InstrumentChannel):
    """"""
    Class to hold an input channel of the scope.

    Exposes: state, coupling, ground, scale, range, position, offset,
    invert, bandwidth, impedance, overload.
    """"""

    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached
            name: The name of the channel
            channum: The number of the channel in question. Must match the
                actual number as used by the instrument (1..4)
        """"""

        if channum not in [1, 2, 3, 4]:
            raise ValueError('Invalid channel number! Must be 1, 2, 3, or 4.')

        self.channum = channum

        super().__init__(parent, name)

        self.add_parameter('state',
                           label=f'Channel {channum} state',
                           get_cmd=f'CHANnel{channum}:STATe?',
                           set_cmd=f'CHANnel{channum}:STATE {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring='Switches the channel on or off')

        self.add_parameter('coupling',
                           label=f'Channel {channum} coupling',
                           get_cmd=f'CHANnel{channum}:COUPling?',
                           set_cmd=f'CHANnel{channum}:COUPling {{}}',
                           vals=vals.Enum('DC', 'DCLimit', 'AC'),
                           docstring=('Selects the connection of the channel'
                                      'signal. DC: 50 Ohm, DCLimit 1 MOhm, '
                                      'AC: Con. through DC capacitor'))

        self.add_parameter('ground',
                           label=f'Channel {channum} ground',
                           get_cmd=f'CHANnel{channum}:GND?',
                           set_cmd=f'CHANnel{channum}:GND {{}}',
                           vals=vals.Enum('ON', 'OFF'),
                           docstring=('Connects/disconnects the signal to/from'
                                      'the ground.'))

        # NB (WilliamHPNielsen): This parameter depends on other parameters and
        # should be dynamically updated accordingly. Cf. p 1178 of the manual
        self.add_parameter('scale',
                           label=f'Channel {channum} Y scale',
                           unit='V/div',
                           get_cmd=f'CHANnel{channum}:SCALe?',
                           set_cmd=self._set_scale,
                           get_parser=float,
                           )

        self.add_parameter('range',
                           label=f'Channel {channum} Y range',
                           unit='V',
                           get_cmd=f'CHANnel{channum}:RANGe?',
                           set_cmd=self._set_range,
                           get_parser=float
                           )

        # TODO (WilliamHPNielsen): would it be better to recast this in terms
        # of Volts?
        self.add_parameter('position',
                           label=f'Channel {channum} vert. pos.',
                           unit='div',
                           get_cmd=f'CHANnel{channum}:POSition?',
                           set_cmd=f'CHANnel{channum}:POSition {{}}',
                           get_parser=float,
                           vals=vals.Numbers(-5, 5),
                           docstring=('Positive values move the waveform up,'
                                      ' negative values move it down.'))

        self.add_parameter('offset',
                           label=f'Channel {channum} offset',
                           unit='V',
                           get_cmd=f'CHANnel{channum}:OFFSet?',
                           set_cmd=f'CHANnel{channum}:OFFSet {{}}',
                           get_parser=float,
                           )

        self.add_parameter('invert',
                           label=f'Channel {channum} inverted',
                           get_cmd=f'CHANnel{channum}:INVert?',
                           set_cmd=f'CHANnel{channum}:INVert {{}}',
                           vals=vals.Enum('ON', 'OFF'))

        # TODO (WilliamHPNielsen): This parameter should be dynamically
        # validated since 800 MHz BW is only available for 50 Ohm coupling
        self.add_parameter('bandwidth',
                           label=f'Channel {channum} bandwidth',
                           get_cmd=f'CHANnel{channum}:BANDwidth?',
                           set_cmd=f'CHANnel{channum}:BANDwidth {{}}',
                           vals=vals.Enum('FULL', 'B800', 'B200', 'B20')
                           )

        self.add_parameter('impedance',
                           label=f'Channel {channum} impedance',
                           unit='Ohm',
                           get_cmd=f'CHANnel{channum}:IMPedance?',
                           set_cmd=f'CHANnel{channum}:IMPedance {{}}',
                           vals=vals.Ints(1, 100000),
                           docstring=('Sets the impedance of the channel '
                                      'for power calculations and '
                                      'measurements.'))

        self.add_parameter('overload',
                           label=f'Channel {channum} overload',
                           get_cmd=f'CHANnel{channum}:OVERload?')

        self.add_parameter('arithmetics',
                           label=f'Channel {channum} arithmetics',
                           set_cmd=f'CHANnel{channum}:ARIThmetics {{}}',
                           get_cmd=f'CHANnel{channum}:ARIThmetics?',
                           val_mapping={'AVERAGE': 'AVER',
                                        'OFF': 'OFF',
                                        'ENVELOPE': 'ENV'}
                           )

        self.add_parameter('trace',
                           channum=self.channum,
                           parameter_class=ScopeTrace)

        self._trace_ready = False

    # Specialised/interlinked set/getters
    def _set_range(self, value: float) -> None:
        self.scale.cache.set(value/10)

        self._parent.write(f'CHANnel{self.channum}:RANGe {value}')

    def _set_scale(self, value: float) -> None:
        self.range.cache.set(value*10)

        self._parent.write(f'CHANnel{self.channum}:SCALe {value}')


ScopeChannel = RohdeSchwarzRTO1000ScopeChannel


class RohdeSchwarzRTO1000(VisaInstrument):
    """"""
    QCoDeS Instrument driver for the
    Rohde-Schwarz RTO1000 series oscilloscopes.

    """"""

    def __init__(self, name: str, address: str,
                 model: Optional[str] = None, timeout: float = 5.,
                 HD: bool = True,
                 terminator: str = '\n',
                 **kwargs: Any) -> None:
        """"""
        Args:
            name: name of the instrument
            address: VISA resource address
            model: The instrument model. For newer firmware versions,
                this can be auto-detected
            timeout: The VISA query timeout
            HD: Does the unit have the High Definition Option (allowing
                16 bit vertical resolution)
            terminator: Command termination character to strip from VISA
                commands.
        """"""
        super().__init__(name=name, address=address, timeout=timeout,
                         terminator=terminator, **kwargs)

        # With firmware versions earlier than 3.65, it seems that the
        # model number can NOT be queried from the instrument
        # (at least fails with RTO1024, fw 2.52.1.1), so in that case
        # the user must provide the model manually.
        firmware_version_str = self.get_idn()[""firmware""]
        if firmware_version_str is None:
            raise RuntimeError(""Could not determine firmware version of RTO1000."")
        firmware_version = version.parse(firmware_version_str)

        if firmware_version < version.parse(""3""):
            log.warning(
                ""Old firmware version detected. This driver may ""
                ""not be compatible. Please upgrade your firmware.""
            )

        if firmware_version >= version.parse(""3.65""):
            # strip just in case there is a newline character at the end
            self.model = self.ask('DIAGnostic:SERVice:WFAModel?').strip()
            if model is not None and model != self.model:
                warnings.warn(""The model number provided by the user ""
                              ""does not match the instrument's response.""
                              "" I am going to assume that this oscilloscope ""
                              f""is a model {self.model}"")
        else:
            if model is None:
                raise ValueError('No model number provided. Please provide '
                                 'a model number (eg. ""RTO1024"").')
            else:
                self.model = model

        self.HD = HD

        # Now assign model-specific values
        self.num_chans = int(self.model[-1])
        self.num_meas = 8

        self._horisontal_divs = int(self.ask('TIMebase:DIVisions?'))

        self.add_parameter('display',
                           label='Display state',
                           set_cmd='SYSTem:DISPlay:UPDate {}',
                           val_mapping={'remote': 0,
                                        'view': 1})

        # Triggering

        self.add_parameter('trigger_display',
                           label='Trigger display state',
                           set_cmd='DISPlay:TRIGger:LINes {}',
                           get_cmd='DISPlay:TRIGger:LINes?',
                           val_mapping={'ON': 1, 'OFF': 0})

        # TODO: (WilliamHPNielsen) There are more available trigger
        # settings than implemented here. See p. 1261 of the manual
        # here we just use trigger1, which is the A-trigger

        self.add_parameter('trigger_source',
                           label='Trigger source',
                           set_cmd='TRIGger1:SOURce {}',
                           get_cmd='TRIGger1:SOURce?',
                           val_mapping={'CH1': 'CHAN1',
                                        'CH2': 'CHAN2',
                                        'CH3': 'CHAN3',
                                        'CH4': 'CHAN4',
                                        'EXT': 'EXT'})

        self.add_parameter('trigger_mode',
                           label='Trigger mode',
                           set_cmd='TRIGger:MODE {}',
                           get_cmd='TRIGger1:SOURce?',
                           vals=vals.Enum('AUTO', 'NORMAL', 'FREERUN'),
                           docstring='Sets the trigger mode which determines'
                                     ' the behaviour of the instrument if no'
                                     ' trigger occurs.\n'
                                     'Options: AUTO, NORMAL, FREERUN.',
                           unit='none')

        self.add_parameter('trigger_type',
                           label='Trigger type',
                           set_cmd='TRIGger1:TYPE {}',
                           get_cmd='TRIGger1:TYPE?',
                           val_mapping={'EDGE': 'EDGE',
                                        'GLITCH': 'GLIT',
                                        'WIDTH': 'WIDT',
                                        'RUNT': 'RUNT',
                                        'WINDOW': 'WIND',
                                        'TIMEOUT': 'TIM',
                                        'INTERVAL': 'INT',
                                        'SLEWRATE': 'SLEW',
                                        'DATATOCLOCK': 'DAT',
                                        'STATE': 'STAT',
                                        'PATTERN': 'PATT',
                                        'ANEDGE': 'ANED',
                                        'SERPATTERN': 'SERP',
                                        'NFC': 'NFC',
                                        'TV': 'TV',
                                        'CDR': 'CDR'}
                           )
        # See manual p. 1262 for an explanation of trigger types

        self.add_parameter('trigger_level',
                           label='Trigger level',
                           set_cmd=self._set_trigger_level,
                           get_cmd=self._get_trigger_level)

        self.add_parameter('trigger_edge_slope',
                           label='Edge trigger slope',
                           set_cmd='TRIGger1:EDGE:SLOPe {}',
                           get_cmd='TRIGger1:EDGE:SLOPe?',
                           vals=vals.Enum('POS', 'NEG', 'EITH'))

        # Horizontal settings

        self.add_parameter('timebase_scale',
                           label='Timebase scale',
                           set_cmd=self._set_timebase_scale,
                           get_cmd='TIMebase:SCALe?',
                           unit='s/div',
                           get_parser=float,
                           vals=vals.Numbers(25e-12, 10000))

        self.add_parameter('timebase_range',
                           label='Timebase range',
                           set_cmd=self._set_timebase_range,
                           get_cmd='TIMebase:RANGe?',
                           unit='s',
                           get_parser=float,
                           vals=vals.Numbers(250e-12, 100e3))

        self.add_parameter('timebase_position',
                           label='Horizontal position',
                           set_cmd=self._set_timebase_position,
                           get_cmd='TIMEbase:HORizontal:POSition?',
                           get_parser=float,
                           unit='s',
                           vals=vals.Numbers(-100e24, 100e24))

        # Acquisition

        # I couldn't find a way to query the run mode, so we manually keep
        # track of it. It is very important when getting the trace to make
        # sense of completed_acquisitions.
        self.add_parameter('run_mode',
                           label='Run/acquisition mode of the scope',
                           get_cmd=None,
                           set_cmd=None)

        self.run_mode('RUN CONT')

        self.add_parameter('num_acquisitions',
                           label='Number of single acquisitions to perform',
                           get_cmd='ACQuire:COUNt?',
                           set_cmd='ACQuire:COUNt {}',
                           vals=vals.Ints(1, 16777215),
                           get_parser=int)

        self.add_parameter('completed_acquisitions',
                           label='Number of completed acquisitions',
                           get_cmd='ACQuire:CURRent?',
                           get_parser=int)

        self.add_parameter('sampling_rate',
                           label='Sample rate',
                           docstring='Number of averages for measuring '
                           'trace.',
                           unit='Sa/s',
                           get_cmd='ACQuire:POINts:ARATe' + '?',
                           get_parser=int)

        self.add_parameter('acquisition_sample_rate',
                           label='Acquisition sample rate',
                           unit='Sa/s',
                           docstring='recorded waveform samples per second',
                           get_cmd='ACQuire:SRATe'+'?',
                           set_cmd='ACQuire:SRATe ' + ' {:.2f}',
                           vals=vals.Numbers(2, 20e12),
                           get_parser=float)

        # Data

        self.add_parameter('dataformat',
                           label='Export data format',
                           set_cmd='FORMat:DATA {}',
                           get_cmd='FORMat:DATA?',
                           vals=vals.Enum('ASC,0', 'REAL,32',
                                          'INT,8', 'INT,16'))

        # High definition mode (might not be available on all instruments)

        if HD:
            self.add_parameter('high_definition_state',
                               label='High definition (16 bit) state',
                               set_cmd=self._set_hd_mode,
                               get_cmd='HDEFinition:STAte?',
                               val_mapping=create_on_off_val_mapping(on_val=1,
                                                                     off_val=0),
                               docstring='Sets the filter bandwidth for the'
                                         ' high definition mode.\n'
                                         'ON: high definition mode, up to 16'
                                         ' bit digital resolution\n'
                                         'Options: ON, OFF\n\n'
                                         'Warning/Bug: By opening the HD '
                                         'acquisition menu on the scope, '
                                         'this value will be set to ""ON"".')

            self.add_parameter('high_definition_bandwidth',
                               label='High definition mode bandwidth',
                               set_cmd='HDEFinition:BWIDth {}',
                               get_cmd='HDEFinition:BWIDth?',
                               unit='Hz',
                               get_parser=float,
                               vals=vals.Numbers(1e4, 1e9))

        self.add_parameter('error_count',
                           label='Number of errors in the error stack',
                           get_cmd='SYSTem:ERRor:COUNt?',
                           unit='#',
                           get_parser=int)

        self.add_parameter('error_next',
                           label='Next error from the error stack',
                           get_cmd='SYSTem:ERRor:NEXT?',
                           get_parser=str)

        # Add the channels to the instrument
        for ch in range(1, self.num_chans + 1):
            chan = RohdeSchwarzRTO1000ScopeChannel(self, f""channel{ch}"", ch)
            self.add_submodule(f""ch{ch}"", chan)

        for measId in range(1, self.num_meas + 1):
            measCh = RohdeSchwarzRTO1000ScopeMeasurement(
                self, f""measurement{measId}"", measId
            )
            self.add_submodule(f""meas{measId}"", measCh)

        self.add_function('stop', call_cmd='STOP')
        self.add_function('reset', call_cmd='*RST')
        self.add_parameter('opc', get_cmd='*OPC?')
        self.add_parameter('stop_opc', get_cmd='STOP;*OPC?')
        self.add_parameter('status_operation',
                           get_cmd='STATus:OPERation:CONDition?',
                           get_parser=int)
        self.add_function('run_continues', call_cmd='RUNContinous')
        # starts the shutdown of the system
        self.add_function('system_shutdown', call_cmd='SYSTem:EXIT')

        self.connect_message()

    def run_cont(self) -> None:
        """"""
        Set the instrument in 'RUN CONT' mode
        """"""
        self.write('RUN')
        self.run_mode.set('RUN CONT')

    def run_single(self) -> None:
        """"""
        Set the instrument in 'RUN Nx SINGLE' mode
        """"""
        self.write('SINGLE')
        self.run_mode.set('RUN Nx SINGLE')

    def is_triggered(self) -> bool:
        wait_trigger_mask = 0b01000
        return bool(self.status_operation() & wait_trigger_mask) is False

    def is_running(self) -> bool:
        measuring_mask = 0b10000
        return bool(self.status_operation() & measuring_mask)

    def is_acquiring(self) -> bool:
        return self.is_triggered() & self.is_running()

    # Specialised set/get functions

    def _set_hd_mode(self, value: int) -> None:
        """"""
        Set/unset the high def mode
        """"""
        self._make_traces_not_ready()
        self.write(f'HDEFinition:STAte {value}')

    def _set_timebase_range(self, value: float) -> None:
        """"""
        Set the full range of the timebase
        """"""
        self._make_traces_not_ready()
        self.timebase_scale.cache.set(value/self._horisontal_divs)

        self.write(f'TIMebase:RANGe {value}')

    def _set_timebase_scale(self, value: float) -> None:
        """"""
        Set the length of one horizontal division.
        """"""
        self._make_traces_not_ready()
        self.timebase_range.cache.set(value*self._horisontal_divs)

        self.write(f'TIMebase:SCALe {value}')

    def _set_timebase_position(self, value: float) -> None:
        """"""
        Set the horizontal position.
        """"""
        self._make_traces_not_ready()
        self.write(f'TIMEbase:HORizontal:POSition {value}')

    def _make_traces_not_ready(self) -> None:
        """"""
        Make the scope traces be not ready.
        """"""
        self.ch1.trace._trace_ready = False
        self.ch2.trace._trace_ready = False
        self.ch3.trace._trace_ready = False
        self.ch4.trace._trace_ready = False

    def _set_trigger_level(self, value: float) -> None:
        """"""
        Set the trigger level on the currently used trigger source
        channel.
        """"""
        trans = {'CH1': 1, 'CH2': 2, 'CH3': 3, 'CH4': 4, 'EXT': 5}
        # We use get and not get_latest because we don't trust users to
        # not touch the front panel of an oscilloscope.
        source = trans[self.trigger_source.get()]
        if source != 5:
            submodule = self.submodules[f'ch{source}']
            assert isinstance(submodule, InstrumentChannel)
            v_range = submodule.range()
            offset = submodule.offset()

            if (value < -v_range/2 + offset) or (value > v_range/2 + offset):
                raise ValueError('Trigger level outside channel range.')

        self.write(f'TRIGger1:LEVel{source} {value}')

    def _get_trigger_level(self) -> float:
        """"""
        Get the trigger level from the currently used trigger source
        """"""
        trans = {'CH1': 1, 'CH2': 2, 'CH3': 3, 'CH4': 4, 'EXT': 5}
        # we use get and not get_latest because we don't trust users to
        # not touch the front panel of an oscilloscope
        source = trans[self.trigger_source.get()]

        val = self.ask(f'TRIGger1:LEVel{source}?')

        return float(val.strip())


class RTO1000(RohdeSchwarzRTO1000):
    """"""
    Backwards compatibility alias for RohdeSchwarzRTO1000
    """"""

    pass
"
44,110.6,"Cleveland, Ohio, United States","The Model 2000 6_-Digit Multimeter is part of Keithleys family of high performance DMMs. Based on the same high speed, low noise A/D converter technology as the Model 2001 and 2002, the 2000 is a fast, accurate, and highly stable instrument thats as easy to operate as it is to afford. It combines broad measurement ranges with superior accuracy specifications DC voltage from 100nV to 1kV (with 0.002% 90-day basic accuracy) and DC resistance from 100 to 100M (with 0.008% 90-day basic accuracy). Optional switch cards enable multiplexing up to 20 different input signals for multipoint measurement applications.",Keithley 2000,241.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a {Device name} Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",,https://www.testequipmenthq.com/datasheets/KEITHLEY-2000-Datasheet.pdf,"[OrderedDict([('id', 'attDkhYLQ6zcJU0mz'), ('width', 288), ('height', 192), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g8NVRWRCYxFeNnCVE8rBkA/SXZEaj-FkmAbR9wEBqi2qdq9C9bfVztotbsqqti2aNMyC6b0jlxareooxrYkRFZ2wFjES6K0Qq5GNnWf4ZE-w-vPFRGuZlEDM05o92qbV98/W3RG-j7BKmbIom8t9FvC6oyAmVnqp1N9VexEW-5ZNSc'), ('filename', '2000.webp'), ('size', 6118), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QAvV5B847YFg3uI3iHlU5Q/9T3KQzGdCJ5Z0-v1R9zyg9qhsLRe4eBLGi0fffyKyXfVyxmNV8AiiN8sFnzyWIM8Eiy1AGFd7KmUc_YHgIL1pLZB9zhGturDKK6tvDgfMq0/otaYwWB8QK6dHmvuFBQYKkPDJMwuVvL-p4UmSJfyyyE'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fS0cJWXGPpyOHx57eTFU4w/46PP77zdFZBNuKeUYatFm3TIO9Q77H5WPU5S3Ft8lD3l6_ED3Yn08CsvlE3_QujhAxgeSj8FNYN0VfdwGqbPhhXC9gYUj5QQovn8Ka3Hlak/3mP_hDhCnMShVqg89WP7-aL1n-exNIyXqQhjayiwABA'), ('width', 288), ('height', 192)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5_JJVg4EYXiGUbmAcsGuyg/tAc66MXu4_eKSFhQm8SIm-FoD1RcT3PsvN-9Q8mAzrX4Ukfp2r77XFUxvOSRAM7Gmxq0xK3bGTJcUw08dX9SNXIznjDWkOZptw90G-YKt0M/hU1saAYHMpCoLK306-Y7Zzwq45DDGvlTvn6Zuo6Y6rY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.allaboutcircuits.com/test-measurement/multimeters/keithley-2000/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2000.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2000,,,True,,"from functools import partial
from typing import Any, Callable, Union

from qcodes.instrument import VisaInstrument
from qcodes.validators import Bool, Enum, Ints, MultiType, Numbers


def _parse_output_string(s: str) -> str:
    """"""Parses and cleans string outputs of the Keithley""""""
    # Remove surrounding whitespace and newline characters
    s = s.strip()

    # Remove surrounding quotes
    if (s[0] == s[-1]) and s.startswith((""'"", '""')):
        s = s[1:-1]

    s = s.lower()

    # Convert some results to a better readable version
    conversions = {
        ""mov"": ""moving"",
        ""rep"": ""repeat"",
    }

    if s in conversions.keys():
        s = conversions[s]

    return s


def _parse_output_bool(value: str) -> bool:
    return True if int(value) == 1 else False


class Keithley2000(VisaInstrument):
    """"""
    Driver for the Keithley 2000 multimeter.
    """"""

    def __init__(self, name: str, address: str, reset: bool = False, **kwargs: Any):
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self._trigger_sent = False

        # Unfortunately the strings have to contain quotation marks and a
        # newline character, as this is how the instrument returns it.
        self._mode_map = {
            ""ac current"": '""CURR:AC""',
            ""dc current"": '""CURR:DC""',
            ""ac voltage"": '""VOLT:AC""',
            ""dc voltage"": '""VOLT:DC""',
            ""2w resistance"": '""RES""',
            ""4w resistance"": '""FRES""',
            ""temperature"": '""TEMP""',
            ""frequency"": '""FREQ""',
        }

        self.add_parameter(
            ""mode"",
            get_cmd=""SENS:FUNC?"",
            set_cmd=""SENS:FUNC {}"",
            val_mapping=self._mode_map,
        )

        # Mode specific parameters
        self.add_parameter(
            ""nplc"",
            get_cmd=partial(self._get_mode_param, ""NPLC"", float),
            set_cmd=partial(self._set_mode_param, ""NPLC""),
            vals=Numbers(min_value=0.01, max_value=10),
        )

        # TODO: validator, this one is more difficult since different modes
        # require different validation ranges
        self.add_parameter(
            ""range"",
            get_cmd=partial(self._get_mode_param, ""RANG"", float),
            set_cmd=partial(self._set_mode_param, ""RANG""),
            vals=Numbers(),
        )

        self.add_parameter(
            ""auto_range_enabled"",
            get_cmd=partial(self._get_mode_param, ""RANG:AUTO"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""RANG:AUTO""),
            vals=Bool(),
        )

        self.add_parameter(
            ""digits"",
            get_cmd=partial(self._get_mode_param, ""DIG"", int),
            set_cmd=partial(self._set_mode_param, ""DIG""),
            vals=Ints(min_value=4, max_value=7),
        )

        self.add_parameter(
            ""averaging_type"",
            get_cmd=partial(self._get_mode_param, ""AVER:TCON"", _parse_output_string),
            set_cmd=partial(self._set_mode_param, ""AVER:TCON""),
            vals=Enum(""moving"", ""repeat""),
        )

        self.add_parameter(
            ""averaging_count"",
            get_cmd=partial(self._get_mode_param, ""AVER:COUN"", int),
            set_cmd=partial(self._set_mode_param, ""AVER:COUN""),
            vals=Ints(min_value=1, max_value=100),
        )

        self.add_parameter(
            ""averaging_enabled"",
            get_cmd=partial(self._get_mode_param, ""AVER:STAT"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""AVER:STAT""),
            vals=Bool(),
        )

        # Global parameters
        self.add_parameter(
            ""display_enabled"",
            get_cmd=""DISP:ENAB?"",
            get_parser=_parse_output_bool,
            set_cmd=""DISP:ENAB {}"",
            set_parser=int,
            vals=Bool(),
        )

        self.add_parameter(
            ""trigger_continuous"",
            get_cmd=""INIT:CONT?"",
            get_parser=_parse_output_bool,
            set_cmd=""INIT:CONT {}"",
            set_parser=int,
            vals=Bool(),
        )

        self.add_parameter(
            ""trigger_count"",
            get_cmd=""TRIG:COUN?"",
            get_parser=int,
            set_cmd=""TRIG:COUN {}"",
            vals=MultiType(
                Ints(min_value=1, max_value=9999),
                Enum(""inf"", ""default"", ""minimum"", ""maximum""),
            ),
        )

        self.add_parameter(
            ""trigger_delay"",
            get_cmd=""TRIG:DEL?"",
            get_parser=float,
            set_cmd=""TRIG:DEL {}"",
            unit=""s"",
            vals=Numbers(min_value=0, max_value=999999.999),
        )

        self.add_parameter(
            ""trigger_source"",
            get_cmd=""TRIG:SOUR?"",
            set_cmd=""TRIG:SOUR {}"",
            val_mapping={
                ""immediate"": ""IMM"",
                ""timer"": ""TIM"",
                ""manual"": ""MAN"",
                ""bus"": ""BUS"",
                ""external"": ""EXT"",
            },
        )

        self.add_parameter(
            ""trigger_timer"",
            get_cmd=""TRIG:TIM?"",
            get_parser=float,
            set_cmd=""TRIG:TIM {}"",
            unit=""s"",
            vals=Numbers(min_value=0.001, max_value=999999.999),
        )

        self.add_parameter(""amplitude"", unit=""arb.unit"", get_cmd=self._read_next_value)

        self.add_function(""reset"", call_cmd=""*RST"")

        if reset:
            self.reset()

        # Set the data format to have only ascii data without units and channels
        self.write(""FORM:DATA ASCII"")
        self.write(""FORM:ELEM READ"")

        self.connect_message()

    def trigger(self) -> None:
        if not self.trigger_continuous():
            self.write(""INIT"")
            self._trigger_sent = True

    def _read_next_value(self) -> float:
        # Prevent a timeout when no trigger has been sent
        if not self.trigger_continuous() and not self._trigger_sent:
            return 0.0

        self._trigger_sent = False

        return float(self.ask(""SENSE:DATA:FRESH?""))

    def _get_mode_param(
        self, parameter: str, parser: Callable[[str], Any]
    ) -> Union[float, str, bool]:
        """"""Read the current Keithley mode and ask for a parameter""""""
        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter}?""

        return parser(self.ask(cmd))

    def _set_mode_param(self, parameter: str, value: Union[float, str, bool]) -> None:
        """"""Read the current Keithley mode and set a parameter""""""
        if isinstance(value, bool):
            value = int(value)

        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter} {value}""

        self.write(cmd)
"
53,5420.0,USA,"The Keysight (formerly Agilent) 33210A is the latest function/arbitrary waveform generator from Keysight. It uses direct digital synthesis techniques to create a stable, accurate output signal having clean, low distortion sine waves. For user defined waveforms, option 002 provides 14-bit 8k point arbitrary waveform generation",Keysight 33210 A,294.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33210A Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"Function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.",KEYSIGHT 33210A,https://www.mouser.com/pdfdocs/ug33210-90010.pdf,"[OrderedDict([('id', 'attw6E6O3rYWUQBU0'), ('width', 800), ('height', 444), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sA9DGlHEWRakIoffVEupKg/q4epZE--k_RpyEE_KX2U8HvCvD57Bjme4J5QylWWGFI7bZ6VamaoYUn0ydEqP3VeLuTRWDW1ZAlfeGclXHA6JmhG__eIMKLNXYFvLixcpsvM4kCOILPH3PcaGcLTtfGY/bU6OJimpy3XjXC8PK-_PXlBuVqLAP_monv8PuchoSZA'), ('filename', 'Keysight_Agilent_33210A.jpg'), ('size', 85448), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RLrIYEXaCKzqH-GfvPSNrg/hiedtDed9QT-WPVICvk_M_rofHZNo_AUmyxztHQK0GqkCJLL3nsOQj4jP8DJJqR8_Ze81vHocxuZzeAK7uacjQ/c6j9976uCWkPpefhYF4M7yTwsYwNf_QxZD0scdi9O8E'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2vLyz8DkgTbWtCR84d9qgQ/mcoj6x_bYebHpak4Hb-jcPbpN31aLq-WZsF7wOFdSmaKTxF88FZ1giLlHcwUPwrVvd2WD198Q8q0K-wzK-IrrA/yx4IPjYNrA6qBC70Wob9XkgC1rm9XNnAhYZT-Lxi5GY'), ('width', 800), ('height', 444)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Q1xHUqx8ZyFgB6P12_FpJA/917nyAWJ8HmiS6CZLR_IKlOfZ3OcKRiVXmEPDPn1UId2vPE0hNlk3XbKGntEk3MJJmTr1ODjNEATd_Vq-1DTsA/UCqtM4aKeqIHiMOlKmAqDvkByJXhnhQ16C4WyQen5BU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.amplicon.com/products/keysight-33210a/96092536-33210a/,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KeysightAgilent_33XXX.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33210A,,,,,"from functools import partial
import logging
from typing import Union, Any

from qcodes import VisaInstrument, validators as vals
from qcodes.instrument.channel import InstrumentChannel
from qcodes.instrument.base import Instrument
from qcodes.instrument_drivers.Keysight.private.error_handling import \
    KeysightErrorQueueMixin

log = logging.getLogger(__name__)


# This is to be the grand unified driver superclass for
# The Keysight/Agilent/HP Waveform generators of series
# 33200, 33500, and 33600


class OutputChannel(InstrumentChannel):
    """"""
    Class to hold the output channel of a waveform generator
    """"""
    def __init__(self, parent: Instrument, name: str, channum: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-2)
        """"""
        super().__init__(parent, name)

        def val_parser(parser: type, inputstring: str) -> Union[float,int]:
            """"""
            Parses return values from instrument. Meant to be used when a query
            can return a meaningful finite number or a numeric representation
            of infinity

            Args:
                parser: Either int or float, what to return in finite
                    cases
                inputstring: The raw return value
            """"""

            inputstring = inputstring.strip()

            if float(inputstring) == 9.9e37:
                output = float('inf')
            else:
                output = float(inputstring)
                if parser == int:
                    output = parser(output)

            return output

        self.model = self._parent.model

        self.add_parameter('function_type',
                           label=f'Channel {channum} function type',
                           set_cmd=f'SOURce{channum}:FUNCtion {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('SIN', 'SQU', 'TRI', 'RAMP',
                                          'PULS', 'PRBS', 'NOIS', 'ARB',
                                          'DC')
                           )

        self.add_parameter('frequency_mode',
                           label=f'Channel {channum} frequency mode',
                           set_cmd=f'SOURce{channum}:FREQuency:MODE {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency:MODE?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('CW', 'LIST', 'SWEEP', 'FIXED')
                           )

        max_freq = self._parent._max_freqs[self.model]
        self.add_parameter('frequency',
                           label=f'Channel {channum} frequency',
                           set_cmd=f'SOURce{channum}:FREQuency {{}}',
                           get_cmd=f'SOURce{channum}:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           # TODO: max. freq. actually really tricky
                           vals=vals.Numbers(1e-6, max_freq)
                           )

        self.add_parameter('phase',
                           label=f'Channel {channum} phase',
                           set_cmd=f'SOURce{channum}:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:PHASe?',
                           get_parser=float,
                           unit='deg',
                           vals=vals.Numbers(0, 360)
                           )
        self.add_parameter('amplitude_unit',
                           label=f'Channel {channum} amplitude unit',
                           set_cmd=f'SOURce{channum}:VOLTage:UNIT {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:UNIT?',
                           vals=vals.Enum('VPP', 'VRMS', 'DBM'),
                           get_parser=str.rstrip
                           )

        self.add_parameter('amplitude',
                           label=f'Channel {channum} amplitude',
                           set_cmd=f'SOURce{channum}:VOLTage {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage?',
                           unit='',  # see amplitude_unit
                           get_parser=float)

        self.add_parameter('offset',
                           label=f'Channel {channum} voltage offset',
                           set_cmd=f'SOURce{channum}:VOLTage:OFFSet {{}}',
                           get_cmd=f'SOURce{channum}:VOLTage:OFFSet?',
                           unit='V',
                           get_parser=float
                           )
        self.add_parameter('output',
                           label=f'Channel {channum} output state',
                           set_cmd=f'OUTPut{channum} {{}}',
                           get_cmd=f'OUTPut{channum}?',
                           val_mapping={'ON': 1, 'OFF': 0}
                           )

        self.add_parameter('ramp_symmetry',
                           label=f'Channel {channum} ramp symmetry',
                           set_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:RAMP:SYMMetry?',
                           get_parser=float,
                           unit='%',
                           vals=vals.Numbers(0, 100)
                           )

        self.add_parameter('pulse_width',
                           label=f""Channel {channum} pulse width"",
                           set_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh {{}}',
                           get_cmd=f'SOURce{channum}:FUNCtion:PULSE:WIDTh?',
                           get_parser=float,
                           unit='S')

        # TRIGGER MENU
        self.add_parameter('trigger_source',
                           label=f'Channel {channum} trigger source',
                           set_cmd=f'TRIGger{channum}:SOURce {{}}',
                           get_cmd=f'TRIGger{channum}:SOURce?',
                           vals=vals.Enum('IMM', 'EXT', 'TIM', 'BUS'),
                           get_parser=str.rstrip,
                           )

        self.add_parameter('trigger_slope',
                           label=f'Channel {channum} trigger slope',
                           set_cmd=f'TRIGger{channum}:SLOPe {{}}',
                           get_cmd=f'TRIGger{channum}:SLOPe?',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=str.rstrip
                           )

        # Older models do not have all the fancy trigger options
        if self._parent.model[2] in ['5', '6']:
            self.add_parameter('trigger_count',
                               label=f'Channel {channum} trigger count',
                               set_cmd=f'TRIGger{channum}:COUNt {{}}',
                               get_cmd=f'TRIGger{channum}:COUNt?',
                               vals=vals.Ints(1, 1000000),
                               get_parser=partial(val_parser, int)
                               )

            self.add_parameter('trigger_delay',
                               label=f'Channel {channum} trigger delay',
                               set_cmd=f'TRIGger{channum}:DELay {{}}',
                               get_cmd=f'TRIGger{channum}:DELay?',
                               vals=vals.Numbers(0, 1000),
                               get_parser=float,
                               unit='s')

            self.add_parameter('trigger_timer',
                               label=f'Channel {channum} trigger timer',
                               set_cmd=f'TRIGger{channum}:TIMer {{}}',
                               get_cmd=f'TRIGger{channum}:TIMer?',
                               vals=vals.Numbers(1e-6, 8000),
                               get_parser=float)

        # TODO: trigger level doesn't work remotely. Why?

        # output menu
        self.add_parameter('output_polarity',
                           label=f'Channel {channum} output polarity',
                           set_cmd=f'OUTPut{channum}:POLarity {{}}',
                           get_cmd=f'OUTPut{channum}:POLarity?',
                           get_parser=str.rstrip,
                           vals=vals.Enum('NORM', 'INV')
                           )
        # BURST MENU
        self.add_parameter('burst_state',
                           label=f'Channel {channum} burst state',
                           set_cmd=f'SOURce{channum}:BURSt:STATe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:STATe?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        self.add_parameter('burst_mode',
                           label=f'Channel {channum} burst mode',
                           set_cmd=f'SOURce{channum}:BURSt:MODE {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:MODE?',
                           get_parser=str.rstrip,
                           val_mapping={'N Cycle': 'TRIG', 'Gated': 'GAT'},
                           vals=vals.Enum('N Cycle', 'Gated')
                           )

        self.add_parameter('burst_ncycles',
                           label=f'Channel {channum} burst no. of cycles',
                           set_cmd=f'SOURce{channum}:BURSt:NCYCles {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:NCYCLes?',
                           get_parser=partial(val_parser, int),
                           vals=vals.MultiType(vals.Ints(1),
                                               vals.Enum('MIN', 'MAX',
                                                         'INF'))
                           )

        self.add_parameter('burst_phase',
                           label=f'Channel {channum} burst start phase',
                           set_cmd=f'SOURce{channum}:BURSt:PHASe {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:PHASe?',
                           vals=vals.Numbers(-360, 360),
                           unit='degrees',
                           get_parser=float
                           )

        self.add_parameter('burst_polarity',
                           label=f'Channel {channum} burst gated polarity',
                           set_cmd=f'SOURce{channum}:BURSt:GATE:POLarity {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:GATE:POLarity?',
                           vals=vals.Enum('NORM', 'INV')
                           )

        self.add_parameter('burst_int_period',
                           label=(f'Channel {channum}' +
                                  ' burst internal period'),
                           set_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod {{}}',
                           get_cmd=f'SOURce{channum}:BURSt:INTernal:PERiod?',
                           unit='s',
                           vals=vals.Numbers(1e-6, 8e3),
                           get_parser=float,
                           docstring=('The burst period is the time '
                                      'between the starts of consecutive '
                                      'bursts when trigger is immediate.')
                           )


class SyncChannel(InstrumentChannel):
    """"""
    Class to hold the sync output. Has very few parameters for
    single channel instruments
    """"""

    def __init__(self, parent: Instrument, name: str):

        super().__init__(parent, name)

        self.add_parameter('output',
                           label='Sync output state',
                           set_cmd='OUTPut:SYNC {}',
                           get_cmd='OUTPut:SYNC?',
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

        if parent.num_channels == 2:

            self.add_parameter('source',
                               label='Source of sync function',
                               set_cmd='OUTPut:SYNC:SOURce {}',
                               get_cmd='OUTPut:SYNC:SOURce?',
                               val_mapping={1: 'CH1', 2: 'CH2'},
                               vals=vals.Enum(1, 2))


class WaveformGenerator_33XXX(KeysightErrorQueueMixin, VisaInstrument):
    """"""
    QCoDeS driver for the Keysight/Agilent 33XXX series of
    waveform generators
    """"""

    def __init__(self, name: str, address: str,
                 silent: bool = False, **kwargs: Any):
        """"""
        Args:
            name: The name of the instrument used internally
                by QCoDeS. Must be unique.
            address: The VISA resource name.
            silent: If True, no connect message is printed.
        """"""

        super().__init__(name, address, terminator='\n', **kwargs)
        self.model = self.IDN()['model']

        #######################################################################
        # Here go all model specific traits

        # TODO: Fill out this dict with all models
        no_of_channels = {'33210A': 1,
                          '33250A': 1,
                          '33511B': 1,
                          '33512B': 2,
                          '33522B': 2,
                          '33622A': 2,
                          '33510B': 2,
                          }

        self._max_freqs = {'33210A': 10e6,
                           '33511B': 20e6,
                           '33512B': 20e6,
                           '33250A': 80e6,
                           '33522B': 30e6,
                           '33622A': 120e6,
                           '33510B': 20e6,
                          }

        self.num_channels = no_of_channels[self.model]

        for i in range(1, self.num_channels+1):
            channel = OutputChannel(self, f'ch{i}', i)
            self.add_submodule(f'ch{i}', channel)

        sync = SyncChannel(self, 'sync')
        self.add_submodule('sync', sync)

        self.add_function('force_trigger', call_cmd='*TRG')

        self.add_function('sync_channel_phases', call_cmd='PHAS:SYNC')

        if not silent:
            self.connect_message()
"
58,41.5,"San Diego, California","Quantum Design's DynaCool™ PPMS® performs electrical, thermal and magnetic measurements while controlling the samples temperature and magnetic environment.The system uses a single two-stage pulse tube cooler to cool both the superconducting magnet and provide temperature control below 10K, resulting in a low vibration environment for sample measurements. At low temperatures a small amount of Helium-4 is condensed and used to cool the sample while the magnet is cooled through solid contact to a 4 K plate.",Dynacoolppms,426.0,"Quantum Design manufactures automated temperature and magnetic field testing platforms.
",Qcodes,Quantum Design,"[OrderedDict([('id', 'attKqZzJWXKLTBY0y'), ('width', 330), ('height', 76), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-3Qs5hR7DVaaPyZAcbhCHA/pTcTS6d4Vh60ecm2sh3FU43R6IEdJa_BuaoQ4lOnPY0p0VFKk3GaZUMfIzgZafQn6T38D-g8ZWh-FKVuUFSJUzaxKAXdryC-CWemJPUqKo0/ZwVRy_6-0inc8-UBpKt-K2hwcj03cYXNl1PIEZhok7Y'), ('filename', 'QD_logo.png'), ('size', 9920), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-uP49xiff_ccTSWQXRpWGw/e8AXxKSDS85ClQJndZafYzS7qKggHqyJBsFC3ueS5izEVbyyOtMNn8lEq_USAF1QX05YbiJj32Mw0-sBSxb9sA/LVsI393Tz2qy1uMEJ7QJwBaPX0y7kVEf25rfpCeD7hA'), ('width', 156), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/R0DUopIlwmZ50PqFo6sIfA/_wk41X7hq58LDSN9FxcgzVkyqdA_OpCq5cjrgqquyAPMtQD9_rwa7dbA1qg5iN7A5vyFkskZQqrNi3ZrOnmj3w/9Vk3TK03ZwYShw77BomKpwdcJrsbgMxa94ztHFCu5N0'), ('width', 330), ('height', 76)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_hQE1HINmHaDWqI1NbmfTQ/En0kwvJQI_vKfdO3m_iUMIs6nOSmASrDp72igz1C6O7Q8lPEEN5fQvTqDymfe7Tbiq3Qi_1F3oDpHMIyQ75lSQ/rqRO40DJinuFBxUf3jN41gk7h4PVhDmQyLcwEtNsBT4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.qdusa.com/,"Write a Python script that uses Qcodes to connect to a PPMS Dynacool Spectrometers, Temperature Controllers, Power Meters","https://www.uno.edu/amri/amri-facs/analysis/ppms#:~:text=PPMS%20is%20an%20open%20architecture,dc%20magnetometry%2C%20and%20thermal%20transport.","['Spectrometers', 'Temperature Controllers', 'Power Meters']","PPMS is an open architecture, variable temperature-field system, designed to perform a variety of automated measurements, including resistivity, heat capacity, ac/dc magnetometry, and thermal transport.",PPMS Dynacool,https://www.qdusa.com/siteDocs/productBrochures/1307-010.pdf,"[OrderedDict([('id', 'attIdQjUH4YHswsZt'), ('width', 400), ('height', 368), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/G5InEzyURyKkTdt8cLThtg/9Z0GEeP7thK2I7WZ_wy6WPrwNQbkwCwD-YUOq-_63NDyYRMCJ4eKAAnvzjotVMuk0C90SDdE3nBlklgZSC-qyGuqcXo2l2yBfNxxBYrnlq43UVrC8EKeF-wkN1CyKXAC/wNbGeR2YcowFPUiekM-5VBGXoOIZIZkffW61N2yFEaQ'), ('filename', '139_ku_qd_PPMS-dyna-cool_frei.png'), ('size', 116211), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QHsqjwRb5G4ufinHhrRTqQ/GvaBXGmCdO4qk_CDVPyQBrXeRKyCNFpupN7FynMSej0Jp_lDgsK6EPkQ6vT4dib6Yl4cHS8ODrSmBr-x3UGZDw/a1Hm4GNT_D6xmv6UhmvOcFyLdMSije7z8ZAK7QNv3kw'), ('width', 39), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zEboDDKE9-uJo9xh1z7Oew/Plfk28K7HaTqqaCuavXlsNwN73BXCd2GYieOIarI0xuo1coMpxcMlxLdudsznVALeoxbJx0QHZPNx9ehSbsoDw/Y6kDbqZ8lZkqf4tHDWEfoVhBRLqSVIi-fseuDP5hN-A'), ('width', 400), ('height', 368)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FsEAaKc38qfBw0uYV7QQjw/482_XuqKcbyqdOiEe0TmOD-Osp9RKf32pqmaTA7cqY9Dk8t4PLnNPyaTNQAhRaXKcaMVB-j36YbY9O3CFDO4DQ/2Nag6-kXPo_i_uTvohNjjnSoLYnjGhzD-V4kJhyiX-E'), ('width', 3000), ('height', 3000)]))]))])]",https://www.mrl.ucsb.edu/tempo-facility/instruments/dynacool-ppms,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QuantumDesign/DynaCoolPPMS/DynaCool.py,https://qcodes.github.io/Qcodes/drivers_api/QuantumDesign.html#qcodes.instrument_drivers.QuantumDesign.DynaCool,,,,,"import warnings
from functools import partial
from time import sleep
from typing import Any, Optional, Union, cast

import numpy as np
from pyvisa import VisaIOError

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument


class DynaCool(VisaInstrument):
    """"""
    Class to represent the DynaCoolPPMS

    Note that this driver assumes the server
    to be running on the DynaCool dedicated control PC.
    The server can be launched using `qcodes-dynacool-server.exe`
    or by executing server.py (from the 'private' folder)

    Args:
        name: The name used internally by QCoDeS for this driver
        address: The VISA resource name.
          E.g. 'TCPIP0::127.0.0.1::5000::SOCKET' with the appropriate IP
          address instead of 127.0.0.1. Note that the port number is
          hard-coded into the server.
    """"""

    # the ramp time resolution is in (s) and is used in the
    # _do_blocking_ramp method
    _ramp_time_resolution = 0.1

    temp_params = ['temperature_setpoint', 'temperature_rate',
                   'temperature_settling']
    field_params = ['field_target', 'field_rate', 'field_approach']

    _errors = {-2: lambda: warnings.warn('Unknown command'),
               1: lambda: None,
               0: lambda: None}

    def __init__(self, name: str,
                 address: str,
                 **kwargs: Any) -> None:
        super().__init__(name=name, address=address, terminator='\r\n',
                         **kwargs)

        self.add_parameter('temperature',
                           label='Temperature',
                           unit='K',
                           get_parser=partial(DynaCool._pick_one, 1, float),
                           get_cmd='TEMP?')

        # Note: from the Lyngby Materials Lab, we have been told that the
        # manual is wrong about the minimal temperature. The manual says
        # 1.8 K, but it is in fact 1.6 K
        self.add_parameter('temperature_setpoint',
                           label='Temperature setpoint',
                           unit='K',
                           vals=vals.Numbers(1.6, 400),
                           set_cmd=partial(self._temp_setter,
                                           'temperature_setpoint'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_setpoint'))

        self.add_parameter('temperature_rate',
                           label='Temperature settle rate',
                           unit='K/s',
                           vals=vals.Numbers(0.0002, 0.3),
                           set_parser=lambda x: x*60,  # conversion to K/min
                           get_parser=lambda x: x/60,  # conversion to K/s
                           set_cmd=partial(self._temp_setter,
                                           'temperature_rate'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_rate'))

        self.add_parameter('temperature_settling',
                           label='Temperature settling mode',
                           val_mapping={'fast settle': 0,
                                        'no overshoot': 1},
                           set_cmd=partial(self._temp_setter,
                                           'temperature_settling'),
                           get_cmd=partial(self._temp_getter,
                                           'temperature_settling'))

        self.add_parameter('temperature_state',
                           label='Temperature tracking state',
                           val_mapping={""tracking"": 2,
                                        'stable': 1,
                                        'near': 5,
                                        'chasing': 6,
                                        'pot operation': 7,
                                        'standby': 10,
                                        'diagnostic': 13,
                                        'impedance control error': 14,
                                        'failure': 15},
                           get_parser=partial(DynaCool._pick_one, 2, int),
                           get_cmd='TEMP?')

        self.add_parameter('field_measured',
                           label='Field',
                           unit='T',
                           get_cmd=self._measured_field_getter)

        self.add_parameter('field_target',
                           label='Field target',
                           unit='T',
                           get_cmd=None,
                           set_cmd=None,
                           vals=vals.Numbers(-14, 14))

        self.add_parameter('field_ramp',
                           label='Field [ramp]',
                           unit='T',
                           get_cmd=None,
                           set_cmd=self._field_ramp_setter,
                           vals=vals.Numbers(-14, 14))

        self.add_parameter('field_rate',
                           label='Field rate',
                           unit='T/s',
                           get_parser=lambda x: x*1e-4,  # Oe to T
                           set_parser=lambda x: x*1e4,  # T to Oe
                           set_cmd=None,
                           get_cmd=None,
                           initial_value=0,
                           vals=vals.Numbers(0, 1))

        self.add_parameter('field_approach',
                           label='Field ramp approach',
                           val_mapping={'linear': 0,
                                        'no overshoot': 1,
                                        'oscillate': 2},
                           set_cmd=None,
                           get_cmd=None,
                           initial_value='linear')

        self.add_parameter('magnet_state',
                           label='Magnet state',
                           val_mapping={'unknown': 0,
                                        'stable': 1,
                                        'switch warming': 2,
                                        'switch cool': 3,
                                        'holding': 4,
                                        'iterate': 5,
                                        'ramping': 6,
                                        'ramping ': 7,  # map must have inverse
                                        'resetting': 8,
                                        'current error': 9,
                                        'switch error': 10,
                                        'quenching': 11,
                                        'charging error': 12,
                                        'power supply error': 14,
                                        'failure': 15},
                           get_parser=partial(DynaCool._pick_one, 2, int),
                           get_cmd='FELD?')

        self.add_parameter('chamber_temperature',
                           label='Chamber Temperature',
                           unit='K',
                           get_parser=partial(DynaCool._pick_one, 1, float),
                           get_cmd='CHAT?')

        self.add_parameter('chamber_state',
                           label='Chamber vacuum state',
                           val_mapping={'purged and sealed': 1,
                                        'vented and sealed': 2,
                                        'sealed': 3,
                                        'performing purge/seal': 4,
                                        'performing vent/seal': 5,
                                        'pre-high vacuum': 6,
                                        'high vacuum': 7,
                                        'pumping continuously': 8,
                                        'flooding continuously': 9},
                           get_parser=partial(DynaCool._pick_one, 1, int),
                           get_cmd='CHAM?')

        self.add_parameter('field_tolerance',
                           label=""Field Tolerance"",
                           unit='T',
                           get_cmd=None,
                           set_cmd=None,
                           vals=vals.Numbers(0, 1e-2),
                           set_parser=float,
                           docstring=""The tolerance below which fields are ""
                                     ""considered identical in a ""
                                     ""blocking ramp."",
                           initial_value=5e-4)

        # The error code of the latest command
        self._error_code = 0

        # we must know all parameter values because of interlinked parameters
        self.snapshot(update=True)

        # it is a safe default to set the target to the current value
        self.field_target(self.field_measured())

        self.connect_message()

    @property
    def error_code(self) -> int:
        return self._error_code

    @staticmethod
    def _pick_one(which_one: int, parser: type, resp: str) -> Any:
        """"""
        Since most of the API calls return several values in a comma-separated
        string, here's a convenience function to pick out the substring of
        interest
        """"""
        return parser(resp.split(', ')[which_one])

    def get_idn(self) -> dict[str, Optional[str]]:
        response = self.ask('*IDN?')
        # just clip out the error code
        id_parts = response[2:].split(', ')

        return dict(zip(('vendor', 'model', 'serial', 'firmware'), id_parts))

    def ramp(self, mode: str = ""blocking"") -> None:
        """"""
        Ramp the field to the value given by the `field_target` parameter

        Args:
            mode: how to ramp, either ""blocking"" or ""non-blocking"". In
                ""blocking"" mode, this function does not return until the
                target field has been reached. In ""non-blocking"" mode, this
                function immediately returns.
        """"""
        if mode not in ['blocking', 'non-blocking']:
            raise ValueError('Invalid ramp mode received. Ramp mode must be '
                             'either ""blocking"" or ""non-blocking"", received '
                             f'""{mode}""')

        target_in_tesla = self.field_target()
        # the target must be converted from T to Oersted
        target_in_oe = target_in_tesla*1e4

        start_field = self.field_measured()
        ramp_range = np.abs(start_field - target_in_tesla)
        # as the second argument is zero relative tolerance has no effect.
        if np.allclose([ramp_range], 0, rtol=0, atol=self.field_tolerance()):
            return

        if mode == ""blocking"":
            self._do_blocking_ramp(target_in_tesla, start_field)
        else:
            self._field_setter(param='field_target',
                               value=target_in_oe)

    def _do_blocking_ramp(self, target_in_tesla: float,
                          start_field_in_tesla: float) -> None:
        """"""
        Perform a blocking ramp. Only call this function from withing the
        `ramp` method.

        This method is slow; it waits for the magnet to settle. The waiting is
        done in two steps, since users have reported that the magnet state does
        not immediately change to 'ramping' when asked to ramp.
        """"""

        target_in_oe = target_in_tesla*1e4
        ramp_range = np.abs(target_in_tesla - start_field_in_tesla)

        self._field_setter(param='field_target', value=target_in_oe)

        # step 1: wait for the magnet to actually start ramping
        # NB: depending on the `field_approach`, we may reach the target
        # several times before the ramp is over (oscillations around target)
        while np.abs(self.field_measured() - start_field_in_tesla) \
                < ramp_range * 0.5:
            sleep(self._ramp_time_resolution)

        # step 2: wait for the magnet to report that is has reached the
        # setpoint

        while self.magnet_state() != 'holding':
            sleep(self._ramp_time_resolution)

    def _field_ramp_setter(self, target: float) -> None:
        """"""
        set_cmd for the field_ramp parameter
        """"""
        self.field_target(target)
        self.ramp(mode='blocking')

    def _measured_field_getter(self) -> float:
        resp = self.ask('FELD?')
        number_in_oersted = cast(float, DynaCool._pick_one(1, float, resp))
        number_in_tesla = number_in_oersted*1e-4
        return number_in_tesla

    def _field_getter(self, param_name: str) -> Union[int, float]:
        """"""
        The combined get function for the three field parameters,
        field_setpoint, field_rate, and field_approach
        """"""
        raw_response = self.ask('GLFS?')
        sp = self._pick_one(1, float, raw_response)
        rate = self._pick_one(2, float, raw_response)
        approach = self._pick_one(3, int, raw_response)

        return dict(zip(self.field_params, [sp, rate, approach]))[param_name]

    def _field_setter(self, param: str, value: float) -> None:
        """"""
        The combined set function for the three field parameters,
        field_setpoint, field_rate, and field_approach
        """"""
        temporary_values = list(self.parameters[p].raw_value
                                for p in self.field_params)
        values = cast(list[Union[int, float]], temporary_values)
        values[self.field_params.index(param)] = value

        self.write(f'FELD {values[0]}, {values[1]}, {values[2]}, 0')

    def _temp_getter(self, param_name: str) -> Union[int, float]:
        """"""
        This function queries the last temperature setpoint (w. rate and mode)
        from the instrument.
        """"""
        raw_response = self.ask('GLTS?')
        sp = DynaCool._pick_one(1, float, raw_response)
        rate = DynaCool._pick_one(2, float, raw_response)
        mode = DynaCool._pick_one(3, int, raw_response)

        return dict(zip(self.temp_params, [sp, rate, mode]))[param_name]

    def _temp_setter(self, param: str, value: float) -> None:
        """"""
        The setter function for the temperature parameters. All three are set
        with the same call to the instrument API
        """"""
        temp_values = list(self.parameters[par].raw_value
                           for par in self.temp_params)
        values = cast(list[Union[int, float]], temp_values)
        values[self.temp_params.index(param)] = value

        self.write(f'TEMP {values[0]}, {values[1]}, {values[2]}')

    def write(self, cmd: str) -> None:
        """"""
        Since the error code is always returned, we must read it back
        """"""
        super().write(cmd)
        self._error_code = int(self.visa_handle.read())
        self._errors[self._error_code]()
        self.visa_log.debug(f'Error code: {self._error_code}')

    def ask(self, cmd: str) -> str:
        """"""
        Since the error code is always returned, we must read it back
        """"""
        response = super().ask(cmd)
        self._error_code = DynaCool._pick_one(0, int, response)
        self._errors[self._error_code]()
        return response

    def close(self) -> None:
        """"""
        Make sure to nicely close the server connection
        """"""
        try:
            self.log.debug('Closing server connection.')
            self.write('CLOSE')
        except VisaIOError as e:
            self.log.info('Could not close connection to server, perhaps the '
                          'server is down?')
            self.log.info(f'Got the following error from PyVISA: '
                          f'{e.abbreviation}: {e.description}')
        super().close()
"
63,5420.0,USA,"Metrology-grade analog signal generator offering industry-leading output power, level accuracy, and phase noise, with frequency coverage from 100 kHz to 67 GHz (extendable to 500 GHz) for testing advanced RF and microwave radar",Agilent E 8257 D,25.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT E8257D RF Signal Generator,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.

",KEYSIGHT E8257D,https://www.keysight.com/us/en/assets/7018-01211/data-sheets/5989-0698.pdf,"[OrderedDict([('id', 'att4ewWvR06SP3apl'), ('width', 1164), ('height', 504), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ePbUtYJtgD9omP5Rs5hBvQ/fkYlWYEZmplWDzVfAZtBtTA0wgSD3ZmkJriaZ5-Su83kVIZV4ZvPffKo67AaPe0vhf7T5kRF9seT9dFZsrDYlVyahY39y0uzLdXMhoGB78A/1StL2uGnr45gB1xtcu9Y0eL831eh3Vy0PsoxmkAZ7KE'), ('filename', 'E8257B.png'), ('size', 588104), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9q_LYKZ7W0EQkl2AscqlIw/xXPqVJUJ95TASnfPHXb1qQSoK5M8ArHyD0JBK-aqXVJ9BRdOGwpEc13JdYH_5ucSNCxyY1VTu6IyVWZhMo-nFQ/5svV6zooQFlTALswf5UEzOUC_WIrlWEfk9bg4YGO6hA'), ('width', 83), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TOQByrdzeaUsfdg7tnITrw/-vGPsRNjPB2pl8Iqjb9pPWvbPodaeAG2oefUpWXCM-GsjTEnyudYfW95klxxbqW5im8wo1VQ6xO2ZWMM4HGnBw/X73tUVjKdvIEkU7g5y-OXA3Jpe8HK96iALUSsmzQKXc'), ('width', 1164), ('height', 504)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WzTVx022KJqHoePl0hMrNA/riuA15X74zuBr_b24-r_pJL41FeRwNm8m9jowLG69mCT0UY4zGcNPTurVxAs7pt95gjWHhpxUmfqQCbLUxbREg/a1P07D7OJ-FF-N6t2065I0WaOZxM65D47bl8LAP3LEc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E8257D/psg-analog-signal-generator-100-khz-67-ghz.html,https://github.com/lupien/pyHegel/blob/master/pyHegel/instruments/agilent.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/agilent/agilent8257D.html,48000.0,"
",,,"# -*- coding: utf-8 -*-

########################## Copyrights and license ############################
#                                                                            #
# Copyright 2011-2015  Christian Lupien <christian.lupien@usherbrooke.ca>    #
#                                                                            #
# This file is part of pyHegel.  http://github.com/lupien/pyHegel            #
#                                                                            #
# pyHegel is free software: you can redistribute it and/or modify it under   #
# the terms of the GNU Lesser General Public License as published by the     #
# Free Software Foundation, either version 3 of the License, or (at your     #
# option) any later version.                                                 #
#                                                                            #
# pyHegel is distributed in the hope that it will be useful, but WITHOUT     #
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      #
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public        #
# License for more details.                                                  #
#                                                                            #
# You should have received a copy of the GNU Lesser General Public License   #
# along with pyHegel.  If not, see <http://www.gnu.org/licenses/>.           #
#                                                                            #
##############################################################################

from __future__ import absolute_import

import numpy as np
import scipy
import os.path

from ..instruments_base import visaInstrument, visaInstrumentAsync,\
                            BaseDevice, scpiDevice, MemoryDevice, ReadvalDev,\
                            ChoiceMultiple, Choice_bool_OnOff, _repr_or_string,\
                            quoted_string, quoted_list, quoted_dict, ChoiceLimits,\
                            ChoiceStrings, ChoiceDevDep, ChoiceDev, ChoiceDevSwitch, ChoiceIndex,\
                            decode_float64, decode_float64_avg, decode_float64_meanstd,\
                            decode_uint16_bin, _decode_block_base, decode_float64_2col,\
                            decode_complex128, sleep, locked_calling, visa_wrap, _encode_block
from ..instruments_registry import register_instrument, register_usb_name, register_idn_alias

register_usb_name('Agilent Technologies', 0x0957)

#######################################################
##    Agilent RF 33522A generator
#######################################################

#@register_instrument('Agilent Technologies', '33522A', '1.10-1.19-1.01-45-00')
#@register_instrument('Agilent Technologies', '33522A', '1.11-1.19-1.01-46-00')
#@register_instrument('Agilent Technologies', '33522A', '1.12-1.19-1.01-50-00')
#@register_instrument('Agilent Technologies', '33522A', '2.01-1.19-2.00-52-00')
@register_instrument('Agilent Technologies', '33522A', usb_vendor_product=[0x0957, 0x2307], alias='33522A RF generator')
class agilent_rf_33522A(visaInstrument):
    """"""
    New code should use the unumbered devices (numbered device are there for compatibility.)
    The devices
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        opts = ['opt=%s'%self.available_options]
        opts += self._conf_helper('ref_oscillator_current_state', 'coupled_ampl_en', 'coupled_freq_en')
        if self.coupled_freq_en.getcache():
            opts += self._conf_helper('coupled_freq_mode')
            if self.coupled_freq_mode.getcache().upper().startswith('OFF'):
                opts += self._conf_helper('coupled_freq_offset')
            else:
                opts += self._conf_helper('coupled_freq_ratio')
        curr_ch = self.current_ch.getcache()
        ch = options.get('ch', None)
        if ch is not None:
            self.current_ch.set(ch)
        opts += self._conf_helper('current_ch', 'out_en', 'ampl', 'ampl_autorange_en', 'ampl_unit', 'offset',
                                  'volt_limit_low', 'volt_limit_high', 'volt_limit_en', 'out_load_ohm', 'out_polarity',
                                  'freq', 'freq_mode', 'phase', 'mode', 'noise_bw', 'pulse_width',
                                  'mod_am_en', 'mod_am_depth_pct', 'mod_am_dssc_en', 'mod_am_src', 'mod_am_int_func', 'mod_am_int_freq',
                                  'mod_fm_en', 'mod_phase_en')
        self.current_ch.set(curr_ch)
        return opts + self._conf_helper(options)
    def _create_devs(self):
        opt = self.ask('*OPT?')
        opt = opt.split(',')
        if opt[0] == '010':
            tb = 'oven'
        else:
            tb = 'standard'
        if opt[1] == '002':
            extmem = True
        else:
            extmem = False
        if opt[2] == '400':
            gpib_avail = True
        else:
            gpib_avail = False
        self.available_options = {'time_base': tb}
        self.available_options['extended_mem'] = extmem
        self.available_options['gpib_installed'] = gpib_avail
        self.ref_oscillator = scpiDevice('ROSCillator:SOURce', choices=ChoiceStrings('INTernal', 'EXTernal'))
        # This is a weird one. It does not use 0 or 1 like most others. It only accepts ON or OFF
        self.ref_oscillator_auto_en = scpiDevice('ROSCillator:SOURce:AUTO', choices=Choice_bool_OnOff)
        self.ref_oscillator_current_state = scpiDevice(getstr='ROSCillator:SOURce:CURRent?', choices=ChoiceStrings('INTernal', 'EXTernal'))
        # new interface
        self.current_ch = MemoryDevice(1, min=1, max=2)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.coupled_ampl_en = devChOption('SOURce{ch}:VOLTage:COUPle', str_type=bool)
        self.ampl = devChOption('SOURce{ch}:VOLTage', str_type=float, setget=True, doc=""""""Minimum is 1 mVpp. Maximum = 10 Vpp. See ampl_unit device for unit type (Vrms, Vpp or dBm)"""""")
        self.ampl_autorange_en = devChOption('SOURce{ch}:VOLTage:RANGe:AUTO', str_type=bool, doc=""When False, disables the automatic attenuator change."")
        self.offset = devChOption('SOURce{ch}:VOLTage:OFFSet', str_type=float, setget=True, doc=""""""Minimum is -5 V, Maximum = 5 V (but can be smaller because of ampl)."""""")
        self.ampl_unit = devChOption('SOURce{ch}:VOLTage:UNIT', choices=ChoiceStrings('VPP', 'VRMS', 'DBM'))
        self.volt_limit_low = devChOption('SOURce{ch}:VOLTage:LIMit:LOW', str_type=float, setget=True, doc=""""""Output will not go below this voltage, if limit is enabled."""""")
        self.volt_limit_high = devChOption('SOURce{ch}:VOLTage:LIMit:HIGH', str_type=float, setget=True, doc=""""""Output will not go above this voltage, if limit is enabled."""""")
        self.volt_limit_en = devChOption('SOURce{ch}:VOLTage:LIMit:STATe', str_type=bool)
        self.coupled_freq_en = devChOption('SOURce{ch}:FREQuency:COUPle', str_type=bool)
        self.coupled_freq_mode = devChOption('SOURce{ch}:FREQuency:COUPle:MODE', choices=ChoiceStrings('OFFSet', 'RATio'))
        self.coupled_freq_offset = devChOption('SOURce{ch}:FREQuency:COUPle:OFFSet', str_type=float, setget=True)
        self.coupled_freq_ratio = devChOption('SOURce{ch}:FREQuency:COUPle:RATio', str_type=float, setget=True)
        self.freq = devChOption('SOURce{ch}:FREQuency', str_type=float, setget=True, min=1e-6, max=30e6)
        # TODO handle sweep and list
        self.freq_mode = devChOption('SOURce{ch}:FREQuency:MODE', choices=ChoiceStrings('CW','LIST','SWEep','FIXed'), doc='CW and FIXED are the same. SWEep and List are not handled currently.')
        self.phase = devChOption('SOURce{ch}:PHASe', str_type=float, setget=True, min=-360, max=360, doc='Angle in degrees')
        self.mode = devChOption('SOURce{ch}:FUNCtion', choices=ChoiceStrings('SINusoid', 'SQUare', 'RAMP', 'PULSe', 'PRBS', 'NOISe', 'ARB', 'DC'))
        self.noise_bw = devChOption('SOURce{ch}:FUNCtion:NOISe:BANDwidth', str_type=float, setget=True, min=0.001, max=30e6)
        self.pulse_width = devChOption('SOURce{ch}:FUNCtion:PULSe:WIDTh', str_type=float, min=16e-9, max=1e6) # s
        self.out_en = devChOption('OUTPut{ch}', str_type=bool)
        self.out_load_ohm = devChOption('OUTPut{ch}:LOAD', str_type=float, setget=True, min=1, doc=""max is 10 kOhm. For High impedance (INFinity) use 9.9e37"")
        self.out_polarity = devChOption('OUTPut{ch}:POLarity', choices=ChoiceStrings('NORMal', 'INVerted'))
        # Modulations parameters  TODO  missing modulations are BPSK FSKey PWM
        self.mod_am_en = devChOption('SOURce{ch}:AM:STATe', str_type=bool)
        self.mod_am_depth_pct = devChOption('SOURce{ch}:AM:DEPTh', str_type=float, min=0, max=120, setget=True)
        self.mod_am_dssc_en = devChOption('SOURce{ch}:AM:DSSC', str_type=bool, doc=""DSSC = Double Sideband Suppressed Carrier"")
        self.mod_am_src = devChOption('SOURce{ch}:AM:SOURce', choices=ChoiceStrings('INTernal', 'EXTernal', 'CH1', 'CH2'), doc='External input is +- 5V')
        self.mod_am_int_func = devChOption('SOURce{ch}:AM:INTernal:FUNCtion', choices=ChoiceStrings('SINusoid', 'SQUare', 'RAMP', 'NRAMp', 'TRIangle', 'NOISe', 'PRBS', 'ARB'))
        self.mod_am_int_freq = devChOption('SOURce{ch}:AM:INTernal:FREQuency', str_type=float, min=1e-6, setget=True)

        self.mod_fm_en = devChOption('SOURce{ch}:FM:STATe', str_type=bool)
        self.mod_phase_en = devChOption('SOURce{ch}:PM:STATe', str_type=bool)

        # Older interface
        # voltage unit depends on front panel/remote selection (sourc1:voltage:unit) vpp, vrms, dbm
        self.ampl1 = scpiDevice('SOUR1:VOLT', str_type=float, min=0.001, max=10)
        self.freq1 = scpiDevice('SOUR1:FREQ', str_type=float, min=1e-6, max=30e6)
        self.pulse_width1 = scpiDevice('SOURce1:FUNCtion:PULSe:WIDTh', str_type=float, min=16e-9, max=1e6) # s
        self.offset1 = scpiDevice('SOUR1:VOLT:OFFS', str_type=float, min=-5, max=5)
        self.phase1 = scpiDevice('SOURce1:PHASe', str_type=float, min=-360, max=360) # in deg unless changed by unit:angle
        self.mode1 = scpiDevice('SOUR1:FUNC') # SIN, SQU, RAMP, PULS, PRBS, NOIS, ARB, DC
        self.out_en1 = scpiDevice('OUTPut1', str_type=bool) #OFF,0 or ON,1
        self.ampl2 = scpiDevice('SOUR2:VOLT', str_type=float, min=0.001, max=10)
        self.freq2 = scpiDevice('SOUR2:FREQ', str_type=float, min=1e-6, max=30e6)
        self.pulse_width2 = scpiDevice('SOURce2:FUNCtion:PULSe:WIDTh', str_type=float, min=16e-9, max=1e6) # s
        self.phase2 = scpiDevice('SOURce2:PHASe', str_type=float, min=-360, max=360) # in deg unless changed by unit:angle
        self.offset2 = scpiDevice('SOUR2:VOLT:OFFS', str_type=float, min=-5, max=5)
        self.mode2 = scpiDevice('SOUR2:FUNC') # SIN, SQU, RAMP, PULS, PRBS, NOIS, ARB, DC
        self.out_en2 = scpiDevice('OUTPut2', str_type=bool) #OFF,0 or ON,1
        self.alias = self.freq
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def phase_sync(self):
        self.write('PHASe:SYNChronize')
    def phase_ref(self, ch=None):
        if ch is not None:
            self.current_ch.set(ch)
        ch=self.current_ch.getcache()
        self.write('SOURce{ch}:PHASe:REFerence'.format(ch=ch))


#######################################################
##    Agilent EPM power meter
#######################################################

#@register_instrument('Agilent Technologies', 'N1913A', 'A1.01.07')
@register_instrument('Agilent Technologies', 'N1913A', usb_vendor_product=[0x0957, 0x5418], alias='N1913A EPM power meter')
class agilent_PowerMeter(visaInstrumentAsync):
    """"""
    This instrument is for Agilent N1913A EPM seris power meter with a N8487A
    average power sensor.

    Get data with readval (force read of new data) or fetch (gets possibly old data)
    Note that only the upper display upper line is read.

    gain_ch_{dB,en} applies a correction to the channel data.
    gain_{dB,en} applies a correction to the display (measurement menu)
                 (goes with relative menu)
    cset1_en is for manual sensor calibration (cannot be turn on for our sensor
             because it already provides a calibration, see th CF percent value on the
             display that depends on frequency. It is 100% at 50 MHz)
    cset2_en is a second manual calibration (called FDO table in channel/offsets)
             to compensate for the circuit used. It also depends on the frequency.
             You can read this correction value with freq_offset
    """"""
    # As of (firmware A1.01.07) the relative value cannot be read.
    # The instrument has 4 display position (top upper, top lower, ...)
    #  1=upper window upper meas, 2=lower upper, 3=upper lower, 4=lower lower
    # They are not necessarily active on the display but they are all used for
    # average calculation and can all be used for reading data.
    def __init__(self, visa_addr):
        # The SRQ for this intrument only works on gpib
        # for lan or usb we need to revert to polling.
        # That is because the read_status_byte seems to always return 0
        # in those cases. So we use *stb? and polling instead.
        self._status_use_stb = False # Used for init
        super(agilent_PowerMeter, self).__init__(visa_addr, poll='not_gpib')
        if self._async_polling:
            self._status_use_stb = True
    def read_status_byte(self):
        if self._status_use_stb:
            return int(self.ask('*STB?'))
        else:
            return super(agilent_PowerMeter, self).read_status_byte()
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('range', 'range_auto_en', 'unit',
                                 'gain_en', 'hold_mode', 'relative_en', 'average_en',
                                 'average_cnt', 'average_cnt_auto', 'average_step_detection',
                                 'cset1_en', 'cset2_en', 'trig_src',
                                 'sensor_calib_date', 'sensor_type', 'sensor_serialno',
                                 'linear_corr_type', 'meas_rate',
                                 'gain_ch_dB', 'gain_ch_en',
                                 'duty_cycle_percent', 'duty_cycle_en',
                                 'freq', 'freq_offset', 'freq_offset_unit',
                                 options)
    @locked_calling
    def _async_trig(self):
        self.trig_delay_en.set(True)
        self.cont_trigger.set(False)
        super(agilent_PowerMeter, self)._async_trig()
    def set_relative(self):
        self.write('CALCulate1:RELative:AUTO ONCE')
    def _create_devs(self):
        # voltage unit depends on front panel/remote selection (sourc1:voltage:unit) vpp, vrms, dbm
        self.range = scpiDevice('SENSe:POWer:AC:RANGe', str_type=int, min=0, max=1)
        self.config = scpiDevice('CONFigure1')
        #self.resolution = scpiDevice('CONFig1 DEF,{val}', str_type=int, min=1, max=4)
        self.resolution = scpiDevice('DISPlay:WINDow1:NUMeric1:RESolution', str_type=int, min=1, max=4)
        self.range_auto_en = scpiDevice('SENSe:POWer:AC:RANGe:AUTO', str_type=bool)
        self.unit = scpiDevice('UNIT:POWer', choices=ChoiceStrings('DBM', 'W'))
        self.gain_dB = scpiDevice('CALCulate1:GAIN', str_type=float, min=-100, max=100)
        self.gain_en = scpiDevice('CALCulate1:GAIN:STATe', str_type=bool)
        self.hold_mode = scpiDevice('CALCulate1:HOLD:STAT', choices=ChoiceStrings('OFF', 'MIN', 'MAX'))
        self.relative_en = scpiDevice('CALCulate1:RELative:STATe', str_type=bool)
        #SENSE subsystem
        self.average_cnt = scpiDevice('AVERage:COUNt', str_type=int, min=1, max=1024)
        self.average_cnt_auto = scpiDevice('AVERage:COUNt:AUTO', str_type=bool)
        self.average_step_detection = scpiDevice('AVERage:SDETect', str_type=bool)
        self.average_en = scpiDevice('AVERage', str_type=bool)
        #self.gain_factor_pct = scpiDevice('CORRection:CFACtor', str_type=float, min=1., max=150.)
        self.cset1_en = scpiDevice('CORRection:CSET1:STATe', str_type=bool)
        self.cset2_en = scpiDevice('CORRection:CSET2:STATe', str_type=bool)
        self.freq = scpiDevice('FREQuency', str_type=float, min=1e3, max=1e12)
        self.freq_offset = scpiDevice(getstr='CORRection:FDOFfset?', str_type=float)
        self.freq_offset_unit = scpiDevice('CORRection:FDOFfset:UNIT', choices=ChoiceStrings('PCT', 'DB'))
        self.duty_cycle_percent = scpiDevice('CORRection:DCYCle', str_type=float, min=.001, max=99.999)
        self.duty_cycle_en = scpiDevice('CORRection:DCYCle:STATe', str_type=bool)
        self.gain_ch_dB = scpiDevice('CORRection:GAIN2', str_type=float, min=-100, max=100)
        self.gain_ch_en = scpiDevice('CORRection:GAIN2:STATe', str_type=bool)
        self.meas_rate = scpiDevice('MRATe', choices=ChoiceStrings('NORMal', 'DOUBle', 'FAST'))
        self.linear_corr_type = scpiDevice('V2P', choices=ChoiceStrings('ATYPe', 'DTYPe'))
        self.sensor_calib_date = scpiDevice(getstr='SERVice:SENSor:CDATe?')
        self.sensor_calib_place = scpiDevice(getstr='SERVice:SENSor:CPLace?')
        self.sensor_type = scpiDevice(getstr='SERVice:SENSor:TYPE?')
        self.sensor_serialno = scpiDevice(getstr='SERVice:SENSor:SNUMber?')
        self.raw_reading = scpiDevice(getstr='SERVice:SENSor:RADC?', autoinit=False, trig=True)
        #TRIGGER block
        self.trig_src = scpiDevice('TRIGger:SOURce', choices=ChoiceStrings('BUS', 'EXTernal', 'HOLD', 'IMMediate'))
        self.trig_delay_en = scpiDevice('TRIGger:DELay:AUTO', str_type=bool)
        self.cont_trigger = scpiDevice('INITiate:CONTinuous', str_type=bool)
        #READ, FETCH
        self.fetch = scpiDevice(getstr='FETCh?',str_type=float, autoinit=False, trig=True) #You need to read some data first.
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Agilent PSG generator
#######################################################

#@register_instrument('Agilent Technologies', 'E8257D', 'C.06.16')
@register_instrument('Agilent Technologies', 'E8257D', alias='E8257D PSG Generator')
class agilent_rf_PSG(visaInstrument):
    """"""
    This controls a PSG signal generetor
    Most useful devices:
        ampl
        ampl_unit
        rf_en
        mod_en
        freq_cw
    The alc devices refer to automatic level (amplitude) control.
    Available methods:
        phase_sync
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # TODO Get the proper config
        return self._conf_helper('oscillator_source', 'rf_en', 'ampl', 'ampl_unit', 'amp_flatness_corr_en',
                                 'ampl_offset_db', 'ampl_reference_dbm', 'ampl_reference_en',
                                 'ampl_protection', 'ampl_mode', 'ampl_start', 'ampl_stop',
                                 'alc_en', 'alc_source', 'alc_bw', 'alc_bw_auto_en',
                                 'attenuation_db', 'attenuation_auto_en', 'amp_flatness_corr_en',
                                 'output_blanking_en', 'output_blanking_auto_en',
                                 'freq_mode', 'freq_cw', 'freq_start', 'freq_stop',
                                 'freq_multiplier', 'freq_offset', 'freq_offset_en', 'freq_reference', 'freq_reference_en',
                                 'phase', 'mod_en', 'mod_am_en', 'mod_fm_en', 'mod_phase_en', 'mod_pulse_en',
                                 'mod_am_freq', 'mod_am_shape', 'mod_am_depth','mod_am_noise_type',
                                 'mod_pulse_period', 'mod_pulse_width', options)
    def _create_devs(self):
        self.installed_options = scpiDevice(getstr='*OPT?')
        self.oscillator_source = scpiDevice(getstr=':ROSCillator:SOURce?', str_type=str)
        self.rf_en = scpiDevice(':OUTPut', str_type=bool)
        self.ampl = scpiDevice(':POWer', str_type=float, doc='unit depends on device ampl_unit', setget=True)
        self.ampl_unit = scpiDevice(':UNIT:POWer', choices=ChoiceStrings('DBM', 'DBUV', 'DBUVEMF', 'V', 'VEMF', 'DB'),
                                    doc='Note that EMF are 2x above the base unit (power arriving at infinite impedance load)')
        # unit:volt:type affects volt scale like power:alc:search:ref:level, which are not user changeable
        self.ampl_offset_db = scpiDevice(':POWer:OFFset', str_type=float, min=-200, max=+200)
        self.ampl_reference_dbm = scpiDevice(':POWer:REFerence', str_type=float, doc='This value is always in dBm')
        self.ampl_reference_en = scpiDevice(':POWer:REFerence:STATe', str_type=bool)
        self.ampl_mode = scpiDevice(':POWer:MODE', choices=ChoiceStrings('FIXed', 'LIST'))
        #self.ampl_optimize_lownoise = scpiDevice(':POWer:NOISe', str_type=bool)
        self.ampl_protection = scpiDevice(':POWer:PROTection', str_type=bool, doc='When enabled, sets the attenuation to maximum when performing a power search. Could decrease the life of the attenuator.')
        self.ampl_start = scpiDevice(':POWer:STARt', str_type=float, doc='unit depends on device ampl_unit', setget=True)
        self.ampl_stop = scpiDevice(':POWer:STOP', str_type=float, doc='unit depends on device ampl_unit', setget=True)
        # TODO handle the search stuff for when alc is off
        self.alc_en = scpiDevice(':POWer:ALC', str_type=bool)
        self.alc_source = scpiDevice(':POWer:ALC:SOURce', choices=ChoiceStrings('INTernal', 'DIODe'))
        # The alc_bw don't seem to have a front panel control. It might not do anything for the
        # generator N5183A we used.
        self.alc_bw = scpiDevice(':POWer:ALC:BANDwidth', str_type=float)
        self.alc_bw_auto_en = scpiDevice(':POWer:ALC:BANDwidth:AUTO', str_type=bool)
        self.attenuation_db = scpiDevice(':POWer:ATTenuation', str_type=float, min=0, max=15, setget=True)
        self.attenuation_auto_en = scpiDevice(':POWer:ATTenuation:AUTO', str_type=bool)
        self.amp_flatness_corr_en = scpiDevice(':CORRection', str_type=bool)
        self.output_blanking_en = scpiDevice(':OUTPut:BLANKing:STATe', str_type=bool)
        self.output_blanking_auto_en = scpiDevice(':OUTPut:BLANKing:AUTO', str_type=bool)
        self.freq_mode = scpiDevice(':FREQuency:MODE', choices=ChoiceStrings('CW', 'FIXed', 'LIST'), doc='CW and FIXed are the same, LIST means sweeping')
        minfreq = float(self.ask(':FREQ? min'))
        maxfreq = float(self.ask(':FREQ? max'))
        self.freq_cw = scpiDevice(':FREQuency', str_type=float, min=minfreq, max=maxfreq)
        self.freq_center = scpiDevice('FREQuency:CENTer', str_type=float, min=minfreq, max=maxfreq)
        self.freq_start = scpiDevice('FREQuency:STARt', str_type=float, min=minfreq, max=maxfreq)
        self.freq_stop = scpiDevice('FREQuency:STOP', str_type=float, min=minfreq, max=maxfreq)
        # TODO SPAN range is probably something else
        self.freq_span = scpiDevice('FREQuency:SPAN', str_type=float, min=0, max=maxfreq)
        self.freq_multiplier = scpiDevice(':FREQuency:MULTiplier', str_type=float, min=-1000, max=1000, doc='The range is -1000 to -0.001 and 0.001 to 1000')
        self.freq_offset = scpiDevice(':FREQuency:OFFSet', str_type=float, min=-200e9, max=200e9)
        self.freq_offset_en = scpiDevice(':FREQuency:OFFSet:STATe', str_type=bool)
        self.freq_reference = scpiDevice(':FREQuency:REFerence', str_type=float, min=0, max=maxfreq)
        self.freq_reference_en = scpiDevice(':FREQuency:REFerence:STATe', str_type=bool)
        self.phase = scpiDevice(':PHASe', str_type=float, min=-3.14, max=3.14, doc='Adjust phase arounf ref. In rad.')
        # TODO handle the marker stuff
        self.mod_en = scpiDevice(':OUTPut:MODulation:STATe', str_type=bool)
        self.mod_am_en = scpiDevice(':AM:STATe', str_type=bool)
        self.mod_am_freq = scpiDevice(':AM:INTernal:FREQuency', str_type=float, min=0.5, max = 1e6, setget=True, doc=""Frequency of the modulation. From 0 to 1MHz if mod_am_shape is 'sine'; 0 to 100KHz else."")
        self.mod_am_depth = scpiDevice(':AM:DEPTh:LINear', str_type=float, min=0, max = 100, setget=True, doc='Modulation depth in percent')
        self.mod_am_shape = scpiDevice(':AM:INTernal:FUNCtion:SHAPe', choices=ChoiceStrings('SINE', 'SQUare', 'TRIangle', 'NOISe'), doc=""Shape of the modulation"")
        self.mod_am_noise_type = scpiDevice(':AM:INTernal:FUNCtion:NOISE', choices=ChoiceStrings('GAUSsian','UNIForm'), doc=""The noise profile used if mod_am_shape is set to 'noise'"")
        self.mod_fm_en = scpiDevice(':FM:STATe', str_type=bool)
        self.mod_phase_en = scpiDevice(':PM:STATe', str_type=bool)
        self.mod_pulse_en = scpiDevice(':PULM:STATe', str_type=bool)
        self.mod_pulse_period = scpiDevice(':PULM:INTernal:PERiod', str_type=float, min=10e-9, max = 42, setget=True, doc=""Pulse period in s."")
        self.mod_pulse_width = scpiDevice(':PULM:INTernal:PWIDth', str_type=float, min=10e-9, max = 42-20e-9, setget=True, doc=""Pulse width duration in s."")
        self.alias = self.freq_cw
        # This needs to be last to complete creation
        super(agilent_rf_PSG,self)._create_devs()
    def phase_sync(self):
        """"""
        Sets the current output phase as a zero reference.
        """"""
        self.write('PHASe:REFerence')


#######################################################
##    Agilent MXG generator
#######################################################

#@register_instrument('Agilent Technologies', 'N5183A', 'A.01.70')
@register_instrument('Agilent Technologies', 'N5183A', usb_vendor_product=[0x0957, 0x1F01], alias='N5183A MXG Generator')
class agilent_rf_MXG(agilent_rf_PSG):
    """"""
    This controls a MXG signal generetor
    Most useful devices:
        ampl
        ampl_unit
        rf_en
        mod_en
        freq_cw
    The alc devices refer to automatic level (amplitude) control.
    Available methods:
        phase_sync
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # TODO Get the proper config
        return self._conf_helper('oscillator_source', 'rf_en', 'ampl', 'ampl_unit', 'amp_flatness_corr_en',
                                 'ampl_offset_db', 'ampl_reference_dbm', 'ampl_reference_en', 'ampl_min_lim',
                                 'ampl_protection', 'ampl_mode', 'ampl_start', 'ampl_stop', 'ampl_user_max', 'ampl_user_max_en',
                                 'alc_en', 'alc_source', 'alc_bw', 'alc_bw_auto_en',
                                 'attenuation_db', 'attenuation_auto_en', 'amp_flatness_corr_en',
                                 'output_blanking_en', 'output_blanking_auto_en',
                                 'freq_mode', 'freq_cw', 'freq_low_spurs_en', 'freq_start', 'freq_stop',
                                 'freq_multiplier', 'freq_offset', 'freq_offset_en', 'freq_reference', 'freq_reference_en',
                                 'phase', 'mod_en', 'mod_am_en', 'mod_fm_en', 'mod_phase_en', 'mod_pulse_en', options)
    def _create_devs(self):
        self.ampl_min_lim = scpiDevice(':POWer:MINimum:LIMit', choices=ChoiceStrings('LOW', 'HIGH'))
        self.ampl_user_max = scpiDevice(':POWer:USER:MAX', str_type=float, doc='unit depends on device ampl_unit', setget=True)
        self.ampl_user_max_en = scpiDevice(':POWer:USER:ENABle', str_type=bool)
        self.freq_low_spurs_en = scpiDevice(':FREQuency:LSPurs:STATe', str_type=bool)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
    def phase_sync(self):
        """"""
        Sets the current output phase as a zero reference.
        """"""
        self.write('PHASe:REFerence')


#######################################################
##    Agilent multimeter
#######################################################

#@register_instrument('Agilent Technologies', '34410A', '2.35-2.35-0.09-46-09')
@register_instrument('Agilent Technologies', '34410A', usb_vendor_product=[0x0957, 0x0607], alias='34410A multimeter')
class agilent_multi_34410A(visaInstrumentAsync):
    """"""
    This controls the agilent digital multimeters.
    Note that most of the devices requires a proper selection of the
    mode first. They can behave differently in various mode.

    Important devices:
     readval  (default alias), same as initiating a measurement, waiting then fetch
     fetch
     fetch_all   (returns more than one value when count >1)
     fetch_std   (returns the standard deviation when count >1)
     mode
     aperture
     aperture_en
     nplc
     sample_count
     range
     autorange
     zero
    Useful method:
     set_long_avg  To average for even longer than 1s (controls aperture and sample_count)
     show_long_avg To see the current averaging settings.

    Do NOT use the mode parameter of devices (like fetch) when creating
    files (sweep, trace, ...) because the headers in the file might be incorrect.
    Set it first.

    """"""
    def math_clear(self):
        self.write('CALCulate:AVERage:CLEar')
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        mode = self.mode.getcache()
        choices = self.mode.choices
        baselist =('mode', 'trig_src', 'trig_delay', 'trig_count',
                   'sample_count', 'sample_src', 'sample_timer', 'trig_delayauto',
                   'line_freq', 'math_func')
        if mode in choices[['curr:ac', 'volt:ac']]:
            extra = ('bandwidth', 'autorange', 'range',
                     'null_en', 'null_val', 'peak_mode_en')
        elif mode in choices[['volt', 'curr']]:
            extra = ('nplc', 'aperture', 'aperture_en', 'zero', 'autorange', 'range',
                     'null_en', 'null_val', 'peak_mode_en')
            if mode in choices[['volt']]:
                extra += ('voltdc_impedance_autoHigh',)
        elif mode in choices[['cont', 'diode']]:
            extra = ()
        elif mode in choices[['freq', 'period']]:
            extra = ('aperture','null_en', 'null_val',  'freq_period_p_band',
                        'freq_period_autorange', 'freq_period_volt_range')
        elif mode in choices[['res', 'fres']]:
            extra = ('nplc', 'aperture', 'aperture_en', 'autorange', 'range',
                     'null_en', 'null_val', 'res_offset_comp')
            if mode in choices[['res']]:
                extra += ('zero',)
        elif mode in choices[['cap']]:
            extra = ('autorange', 'range', 'null_en', 'null_val')
        elif mode in choices[['temp']]:
            extra = ('nplc', 'aperture', 'aperture_en', 'null_en', 'null_val',
                     'zero', 'temperature_transducer', 'temperature_transducer_subtype')
            t_ch = self.temperature_transducer.choices
            if self.temperature_transducer.getcache() in t_ch[['rtd', 'frtd']]:
                extra += ('temperature_transducer_rtd_ref', 'temperature_transducer_rtd_off')
        return self._conf_helper(*(baselist + extra + (options,)))
    @locked_calling
    def set_long_avg(self, time, force=False):
        """"""
        Select a time in seconds.
        It will change the aperture accordingly (and round it to the nearest nplc
        unless force=True).
        If time is greater than 1 s, an alternative mode
        with a smaller aperture (10 nplc) and a repeat count is used. That
        mode also waits trig_delay between each count.
        In that mode, you can use fetch_std to return the statistical error
        on the measurement.
        """"""
        # update mode first, so aperture applies to correctly
        self.mode.get()
        line_period = 1./self.line_freq.getcache()
        if time > 1.:
            width = 10*line_period
            count = round(time/width)
            self.sample_src.set('immediate')
        else:
            count = 1
            width = time
            if not force:
                width = line_period*round(width/line_period)
        self.aperture.set(width)
        self.sample_count.set(count)
    @locked_calling
    def show_long_avg(self):
        # update mode first, so aperture applies to correctly
        self.mode.get()
        count = self.sample_count.get()
        aper_en = self.aperture_en.get()
        if aper_en:
            width = self.aperture.get()
            width_str = 'aperture=%g'%width
        else:
            line_period = 1./self.line_freq.getcache()
            nplc = self.nplc.get()
            width = nplc * line_period
            width_str = 'nplc=%g'%nplc
        count_str = ''
        if count > 1:
            count_str = ', sample_count=%i'%count
        width = width*count
        print 'The full avg time is %f s (%s%s)'%(width, width_str, count_str)
        return width
    def _create_devs(self):
        # This needs to be last to complete creation
        ch = ChoiceStrings(
          'CURRent:AC', 'VOLTage:AC', 'CAPacitance', 'CONTinuity', 'CURRent', 'VOLTage',
          'DIODe', 'FREQuency', 'PERiod', 'RESistance', 'FRESistance', 'TEMPerature', quotes=True)
        self.mode = scpiDevice('FUNC', choices=ch)
        def devOption(lims, *arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options_lim = kwarg.pop('options_lim', {}).copy()
            options_conv = kwarg.pop('options_conv', {}).copy()
            options.update(mode=self.mode)
            options_lim.update(mode=lims)
            options_conv.update(mode=lambda val, quoted_val: val)
            kwarg.update(options=options)
            kwarg.update(options_lim=options_lim)
            kwarg.update(options_conv=options_conv)
            return scpiDevice(*arg, **kwarg)
        # _decode_float64_avg is needed because count points are returned
        # fetch? and read? return sample_count*trig_count data values (comma sep)
        self.fetch = scpiDevice(getstr='FETCh?',str_type=decode_float64_avg, autoinit=False, trig=True) #You can't ask for fetch after an aperture change. You need to read some data first.
        # autoinit false because it can take too long to readval
        #self.readval = scpiDevice(getstr='READ?',str_type=_decode_float64_avg, autoinit=False, redir_async=self.fetch) # similar to INItiate followed by FETCh.
        self.fetch_all = scpiDevice(getstr='FETCh?',str_type=decode_float64, autoinit=False, trig=True)
        self.fetch_std = scpiDevice(getstr='FETCh?',str_type=decode_float64_meanstd, autoinit=False, trig=True, doc=""""""
             Use this to obtain the standard deviation(using ddof=1) of the fetch.
             It is the standard deviation of the mean (it decreases when the averaging is longer).
             This will only return something usefull for long time averages where
             count is > 1. This is the case with set_long_avg(time) for time longer
             than 1s.
             (fetch_all needs to have more than one value)
        """""")
        self.line_freq = scpiDevice(getstr='SYSTem:LFRequency?', str_type=float) # see also SYST:LFR:ACTual?
        ch_aper = ch[['volt', 'curr', 'res', 'fres', 'temp', 'freq', 'period']]
        ch_aper_nplc = ch[['volt', 'curr', 'res', 'fres', 'temp']]
        aper_max = float(self.ask('volt:aper? max'))
        aper_min = float(self.ask('volt:aper? min'))
        # TODO handle freq, period where valid values are .001, .010, .1, 1 (between .001 and 1 can use setget)
        self.aperture = devOption(ch_aper, '{mode}:APERture', str_type=float, min = aper_min, max = aper_max, setget=True)
        self.aperture_en = devOption(ch_aper_nplc, '{mode}:APERture:ENabled', str_type=bool)
        self.nplc = devOption(ch_aper_nplc, '{mode}:NPLC', str_type=float,
                                   choices=[0.006, 0.02, 0.06, 0.2, 1, 2, 10, 100])
        ch_band = ch[['curr:ac', 'volt:ac']]
        self.bandwidth = devOption(ch_band, '{mode}:BANDwidth', str_type=float,
                                   choices=[3, 20, 200]) # in Hz
        ch_freqperi = ch[['freq', 'per']]
        self.freq_period_p_band = devOption(ch_freqperi, '{mode}:RANGe:LOWer', str_type=float,
                                   choices=[3, 20, 200]) # in Hz
        self.freq_period_autorange = devOption(ch_freqperi, '{mode}:VOLTage:RANGe:AUTO', str_type=bool) # Also use ONCE (immediate autorange, then off)
        self.freq_period_volt_range = devOption(ch_freqperi, '{mode}:VOLTage:RANGe', str_type=float,
                                                choices=[.1, 1., 10., 100., 1000.]) # Setting this disables auto range

        ch_zero = ch[['volt', 'curr', 'res', 'temp']] # same as ch_aper_nplc wihtout fres
        self.zero = devOption(ch_zero, '{mode}:ZERO:AUTO', str_type=bool,
                              doc='Enabling auto zero double the time to take each point (the value and a zero correction is done for each point)') # Also use ONCE (immediate zero, then off)
        ch_range = ch[[0, 1, 2,  4, 5,  9, 10]] # everything except continuity, diode, freq, per and temperature
        self.autorange = devOption(ch_range, '{mode}:RANGE:AUTO', str_type=bool) # Also use ONCE (immediate autorange, then off)
        range_ch = ChoiceDevDep(self.mode, {ch[['volt', 'volt:ac']]:[.1, 1., 10., 100., 1000.],
                                            ch[['curr', 'curr:ac']]:[.1e-3, 1e-3, 1e-2, 1e-1, 1, 3],
                                            ch[['fres', 'res']]:[1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9] }) # in V, A, Ohm
        self.range = devOption(ch_range, '{mode}:RANGe', str_type=float, choices=range_ch) # Setting this disables auto range
        ch_null = ch[[0, 1, 2,  4, 5,  7, 8, 9, 10, 11]] # everything except continuity and diode
        self.null_en = devOption(ch_null, '{mode}:NULL', str_type=bool)
        self.null_val = devOption(ch_null, '{mode}:NULL:VALue', str_type=float)
        self.voltdc_impedance_autoHigh = scpiDevice('VOLTage:IMPedance:AUTO', str_type=bool, doc='When True and V range <= 10V then impedance >10 GO else it is 10 MOhm')
        tch = ChoiceStrings('FRTD', 'RTD', 'FTHermistor', 'THERmistor')
        self.temperature_transducer = scpiDevice('TEMPerature:TRANsducer:TYPE', choices=tch)
        tch_rtd = tch[['frtd', 'rtd']]
        ch_temp_typ = ChoiceDevDep(self.temperature_transducer, {tch_rtd:[85], None:[2252, 5000, 10000]})
        self.temperature_transducer_subtype = scpiDevice('TEMPerature:TRANsducer:{trans}:TYPE',
                                        choices = ch_temp_typ,
                                        options=dict(trans=self.temperature_transducer),
                                        str_type=int)
        self.temperature_transducer_rtd_ref = scpiDevice('TEMPerature:TRANsducer:{trans}:RESistance',
                                        min = 49, max= 2.1e3, str_type=float,
                                        options=dict(trans=self.temperature_transducer),
                                        options_lim=dict(trans=tch_rtd))
        self.temperature_transducer_rtd_off = scpiDevice('TEMPerature:TRANsducer:{trans}:OCOMpensated', str_type=bool,
                                        options=dict(trans=self.temperature_transducer),
                                        options_lim=dict(trans=tch_rtd))

        ch_compens = ch[['res', 'fres']]
        self.res_offset_comp = devOption(ch_compens, '{mode}:OCOMpensated', str_type=bool)
        ch_peak = ch[['volt', 'volt:ac', 'curr', 'curr:ac']]
        self.peak_mode_en = devOption(ch_peak, '{mode}:PEAK:STATe', str_type=bool)
        peak_op = dict(peak=self.peak_mode_en)
        peak_op_lim = dict(peak=[True])
        self.fetch_peaks_ptp = devOption(ch_peak, 'FETCh:{mode}:PTPeak', str_type=float,
                                         doc='Call this after a fetch or readval',
                                         options=peak_op, options_lim=peak_op_lim, autoinit=False, trig=True)
        ch_peak_minmax = ch[['volt', 'curr']]
        self.fetch_peaks_min = devOption(ch_peak_minmax, 'FETCh:{mode}:PEAK:MINimum', str_type=float,
                                         doc='Call this after a fetch or readval',
                                         options=peak_op, options_lim=peak_op_lim, autoinit=False, trig=True)
        self.fetch_peaks_max = devOption(ch_peak_minmax, 'FETCh:{mode}:PEAK:MAXimum', str_type=float,
                                         doc='Call this after a fetch or readval',
                                         options=peak_op, options_lim=peak_op_lim, autoinit=False, trig=True)
        ch = ChoiceStrings('NULL', 'DB', 'DBM', 'AVERage', 'LIMit')
        self.math_func = scpiDevice('CALCulate:FUNCtion', choices=ch)
        self.math_state = scpiDevice('CALCulate:STATe', str_type=bool)
        self.math_avg = scpiDevice(getstr='CALCulate:AVERage:AVERage?', str_type=float, trig=True)
        self.math_count = scpiDevice(getstr='CALCulate:AVERage:COUNt?', str_type=float, trig=True)
        self.math_max = scpiDevice(getstr='CALCulate:AVERage:MAXimum?', str_type=float, trig=True)
        self.math_min = scpiDevice(getstr='CALCulate:AVERage:MINimum?', str_type=float, trig=True)
        self.math_ptp = scpiDevice(getstr='CALCulate:AVERage:PTPeak?', str_type=float, trig=True)
        self.math_sdev = scpiDevice(getstr='CALCulate:AVERage:SDEViation?', str_type=float, trig=True)
        ch = ChoiceStrings('IMMediate', 'BUS', 'EXTernal')
        self.trig_src = scpiDevice('TRIGger:SOURce', choices=ch)
        self.trig_delay = scpiDevice('TRIGger:DELay', str_type=float) # seconds
        self.trig_count = scpiDevice('TRIGger:COUNt', str_type=float)
        self.sample_count = scpiDevice('SAMPle:COUNt', str_type=int)
        ch = ChoiceStrings('IMMediate', 'TIMer')
        self.sample_src = scpiDevice('SAMPle:SOURce', choices=ch)
        self.sample_timer = scpiDevice('SAMPle:TIMer', str_type=float) # seconds
        self.trig_delayauto = scpiDevice('TRIGger:DELay:AUTO', str_type=bool)
        self.readval = ReadvalDev(self.fetch)
        self.alias = self.readval
        super(type(self),self)._create_devs()
        # For INITiate: need to wait for completion of triggered measurement before calling it again
        # for trigger: *trg and visa.trigger seem to do the same. Can only be called after INItiate and
        #   during measurement.
        # To get completion stats: write('INITiate;*OPC') and check results from *esr? bit 0
        #   enable with *ese 1 then check *stb bit 5 (32) (and clear *ese?)
        # Could also ask for data and look at bit 4 (16) output buffer ready
        #dmm1.mathfunc.set('average');dmm1.math_state.set(True)
        #dmm1.write('*ese 1;*sre 32')
        #dmm1.write('init;*opc')
        #dmm1.read_status_byte()
        #dmm1.ask('*stb?;*esr?')
        #dmm1.math_count.get(); dmm1.math_avg.get() # no need to reset count, init does that
        #visa.vpp43.enable_event(dmm1.visa.vi, visa.vpp43.VI_EVENT_SERVICE_REQ, visa.vpp43.VI_QUEUE)
        #dmm1.write('init;*opc')
        #dmm1.read_status_byte()
        #visa.vpp43.wait_on_event(dmm1.visa.vi, visa.vpp43.VI_EVENT_SERVICE_REQ, 10000)
        #dmm1.read_status_byte()
        #dmm1.ask('*stb?;*esr?')
        #  For installing handler (only seems to work with USB not GPIB for NI visa library. Seems to work fine with Agilent IO visa)
        #   def event_handler(vi, event_type, context, use_handle): stb = visa.vpp43.read_stb(vi);  print 'helo 0x%x'%stb, event_type==visa.vpp43.VI_EVENT_SERVICE_REQ, context, use_handle; return visa.vpp43.VI_SUCCESS
        #   def event_handler(vi, event_type, context, use_handle): stb = visa.vpp43.read_stb(vi);  print 'HELLO 0x%x'%stb,vi; return visa.vpp43.VI_SUCCESS
        #   visa.vpp43.install_handler(dmm1.visa.vi, visa.vpp43.VI_EVENT_SERVICE_REQ, event_handler)
        #   visa.vpp43.enable_event(dmm1.visa.vi, visa.vpp43.VI_EVENT_SERVICE_REQ, visa.vpp43.VI_HNDLR)
        #   The handler is called for all srq on the bus (not necessarily the instrument we want)
        #     the vi parameter refers to the installed handler, not the actual srq source
        #The wait_on_event seems to be handling only event from src, not affecting the other instruments srq
        # reading the status is not necessary after wait to clear srq (cleared during wait internal handler) for agilent visa
        #  but it is necessary for NI visa (it will receive the SRQ like for agilent but will not transmit
        #      the next ones to the wait queue until acknowledged)
        #      there seems to be some inteligent buffering going on, which is different in agilent and NI visas
        # When wait_on_event timesout, it produces the VisaIOError (VI_ERROR_TMO) exception
        #        the error code is available as VisaIOErrorInstance.error_code


#######################################################
##    Agilent RF attenuator
#######################################################

register_idn_alias('Agilent Technologies', 'AGILENT TECHNOLOGIES')

#@register_instrument('AGILENT TECHNOLOGIES', 'J7211C', 'A.00.04')
@register_instrument('AGILENT TECHNOLOGIES', 'J7211C', usb_vendor_product=[0x0957, 0x4C18], alias='J7211C RF attenuator')
class agilent_rf_Attenuator(visaInstrument):
    """"""
    This controls an Agilent Attenuation Control Unit
    Use att_level_dB to get or change the attenuation level.
    Use cal_att_level_dB to obtain the calibrated attenuation.
    Note that the attenuation for 0dB is not included for the
    other calibration levels.
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        return self._conf_helper('att_level_dB', 'cal_att_level_dB', 'current_freq_Hz',
                                 'relative_en', 'relative_ref_dB', options)
    def _att_level_dB_getdev(self):
        return int(self.ask('ATTenuation?'))
    def _att_level_dB_setdev(self, val):
        val = int(val)
        self.write('ATTenuation %i'%val)
        sleep(0.02)
    def _create_devs(self):
        self.relative_en = scpiDevice('RELative', str_type=bool)
        self.relative_ref_dB = scpiDevice('REFerence', str_type=float)
        # TODO implement RELative:LEVel  (only when relative is enabled)
        self.current_freq_Hz = MemoryDevice(1e9, min=0, max=26.5e9)
        self._devwrap('att_level_dB', min=0, max=101)
        #self.att_level_dB = scpiDevice('ATTenuation', str_type=int, min=0, max=101)
        self.alias = self.att_level_dB
        self.cal_att_level_dB = scpiDevice(getstr='CORRection? {att},{freq}', str_type=float,
                                           options=dict(att=self.att_level_dB, freq=self.current_freq_Hz),
                                           options_apply=['freq'])
        # This needs to be last to complete creation
        super(agilent_rf_Attenuator, self)._create_devs()


#######################################################
##    Agilent infiniiVision Scopes
#######################################################

#@register_instrument('AGILENT TECHNOLOGIES', 'DSO-X 2024A', '01.10.2011031600', usb_vendor_product=[0x0957, 0x1796])
#@register_instrument('AGILENT TECHNOLOGIES', 'DSO-X 3054A', '01.10.2011031600', usb_vendor_product=[0x0957, 0x17a2])
@register_instrument('AGILENT TECHNOLOGIES', 'DSO-X 2024A', usb_vendor_product=[0x0957, 0x1796])
@register_instrument('AGILENT TECHNOLOGIES', 'DSO-X 3054A', usb_vendor_product=[0x0957, 0x17a2])
class infiniiVision_3000(visaInstrumentAsync):
    """"""
     To use this instrument, the most useful devices are probably:
       fetch  (only works in the main timebase mode, not for roll or XY or zoom)
       readval (press run/stop on scope to terminate it, or use clear_dev method)
       snap_png
     See also the setup_trig_detection method.
     Be warned that fetch, resets the current acquistion and waits for the next
     when the scope is running (a firmware bug?).
     fetch when stopped is ok.
     Another way is to start an acq with single_trig, check the acq with is_running
     and then fetch it.
    """"""
    def __init__(self, visa_addr, poll='force_handler'):
        super(infiniiVision_3000, self).__init__(visa_addr, poll)
    def init(self, full=False):
        self.write(':WAVeform:FORMat WORD') # can be WORD BYTE or ASCii
        self.write(':WAVeform:BYTeorder LSBFirst') # can be LSBFirst pr MSBFirst
        self.write(':WAVeform:UNSigned ON') # ON,1 or OFF,0
        super(infiniiVision_3000, self).init(full=full)
    def _async_trigger_helper(self):
        self.digitize()
        self.write('*OPC')
        #self.write(':DIGitize;*OPC')
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # TODO:  improve this
        return self._conf_helper('source', 'points_mode', 'preamble', options)
    def clear_dev(self):
        self.visa.instr.clear()
    def setup_trig_detection(self):
        """""" This setups trig detection. Only use this on one thread and not with readval (run_and_wait).
            Undo its effect with reset_trig_detection.
            After calling this use:
              s.single_trig()
              get(s.trig_status) # when True there was a trig event
              get(s.lasttrig_time) # if not 0. then there it is the last trig time
            The trig time accuracy is probably within 100 ms.
        """"""
        # lets presume we were started with poll='force_handler'
        self.write('*sre 1')
        self.visa.enable_event(visa_wrap.constants.VI_EVENT_SERVICE_REQ,
                               visa_wrap.constants.VI_HNDLR)
    def reset_trig_detection(self):
        self.visa.disable_event(visa_wrap.constants.VI_EVENT_SERVICE_REQ, visa_wrap.constants.VI_ALL_MECH)
        self.write('*sre 32')
    def digitize(self):
        """"""
        Starts an acquisition
        """"""
        self.write(':DIGitize')
    def run_trig(self):
        """"""
        The same as pressing run
        """"""
        self.write(':RUN')
    def stop_trig(self):
        """"""
        The same as pressing stop
        """"""
        self.write(':STOP')
    def single_trig(self):
        """"""
        The same as pressing single
        """"""
        self.trig_status.get() # reset trig
        self._async_last_status_time = 0.
        self.write(':SINGle')
    def is_running(self):
        status = int(self.ask('OPERegister:condition?'))
        # OPERregister[:event]? is a latch of 0-> from OPERegister:condition?
        # it goes through OPEE (mask) to affect OPER bit7 (128) of *STB
        # OPER has bits 11(Overload), 9(masks), 5(arm, see AER?), 3(run state)
        run_state = 8 # 2**3
        return bool(status&run_state)
    def _lasttrig_time_getdev(self):
        return self._async_last_status_time
    def _fetch_ch_helper(self, ch):
        if ch is None:
            ch = self.find_all_active_channels()
        if not isinstance(ch, (list)):
            ch = [ch]
        return ch
    def _fetch_getformat(self, **kwarg):
        xaxis = kwarg.get('xaxis', True)
        ch = kwarg.get('ch', None)
        ch = self._fetch_ch_helper(ch)
        if xaxis:
            multi = ['time(s)']
        else:
            multi = []
        for c in ch:
            multi.append('ch%i'%c)
        fmt = self.fetch._format
        multi = tuple(multi)
        fmt.update(multi=multi, graph=[], xaxis=xaxis)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_getdev(self, ch=None, xaxis=True):
        """"""
           Options available: ch, xaxis
            -ch:    a single value or a list of values for the channels to capture
                    a value of None selects all the active ones.(1-4)
            -xaxis: Set to True (default) to return the timebase as the first column
        """"""
        ch = self._fetch_ch_helper(ch)
        if ch is None:
            ch = self.find_all_active_channels()
        if not isinstance(ch, (list)):
            ch = [ch]
        ret = []
        first = True
        for c in ch:
            self.source.set('chan%i'%c)
            pream = self.preamble.get()
            data = self.data.get()*1. # make it floats
            data_real = (data - pream['yref']) * pream['yinc'] + pream['yorig']
            if xaxis and first:
                first = False
                ret = [(np.arange(pream['points'])- pream['xref']) * pream['xinc'] + pream['xorig']]
            ret.append(data_real)
        ret = np.asarray(ret)
        if ret.shape[0]==1:
            ret=ret[0]
        return ret
    @locked_calling
    def find_all_active_channels(self):
        orig_ch = self.current_channel.get()
        ret = []
        for i in range(1,5):
            if self.channel_display.get(ch=i):
                ret.append(i)
        self.current_channel.set(orig_ch)
        return ret
    def _create_devs(self):
        self.snap_png = scpiDevice(getstr=':DISPlay:DATA? PNG, COLor', raw=True, str_type=_decode_block_base, autoinit=False, doc=""Use like this: get(s500.snap_png, filename='testname.png')\nThe .png extensions is optional. It will be added if necessary."")
        self.snap_png._format['bin']='.png'
        self.inksaver = scpiDevice(':HARDcopy:INKSaver', str_type=bool, doc='This control whether the graticule colors are inverted or not.') # ON, OFF 1 or 0
        self.data = scpiDevice(getstr=':waveform:DATA?', raw=True, str_type=decode_uint16_bin, autoinit=False) # returns block of data (always header# for asci byte and word)
          # also read :WAVeform:PREamble?, which provides, format(byte,word,ascii),
          #  type (Normal, peak, average, HRes), #points, #avg, xincr, xorg, xref, yincr, yorg, yref
          #  xconv = xorg+x*xincr, yconv= (y-yref)*yincr + yorg
        self.points = scpiDevice(':WAVeform:POINts', str_type=int) # 100, 250, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 4000000, 8000000
        self.points_mode = scpiDevice(':WAVeform:POINts:MODE', choices=ChoiceStrings('NORMal', 'MAXimum', 'RAW'))
        self.preamble = scpiDevice(getstr=':waveform:PREamble?', choices=ChoiceMultiple(['format', 'type', 'points', 'count', 'xinc', 'xorig', 'xref', 'yinc', 'yorig', 'yref'],[int, int, int, int, float, float, int, float, float, int]))
        self.waveform_count = scpiDevice(getstr=':WAVeform:COUNt?', str_type=int)
        self.acq_type = scpiDevice(':ACQuire:TYPE', choices=ChoiceStrings('NORMal', 'AVERage', 'HRESolution', 'PEAK'))
        self.acq_mode= scpiDevice(':ACQuire:MODE', choices=ChoiceStrings('RTIM', 'SEGM'))
        self.average_count = scpiDevice(':ACQuire:COUNt', str_type=int, min=2, max=65536)
        self.acq_samplerate = scpiDevice(getstr=':ACQuire:SRATe?', str_type=float)
        self.acq_npoints = scpiDevice(getstr=':ACQuire:POINts?', str_type=int)
        self.current_channel = MemoryDevice(1, min=1, max=4)
        self.trig_status = scpiDevice(getstr=':TER?', str_type=bool, autoinit=False, doc=""This returns True after the instrument has been triggered. It also resets the trig state."")
        def devChannelOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.source = scpiDevice(':WAVeform:SOURce', choices=ChoiceStrings('CHANnel1', 'CHANnel2', 'CHANnel3', 'CHANnel4'))
        self.channel_display = devChannelOption('CHANnel{ch}:DISPlay', str_type=bool)
        self.timebase_mode= scpiDevice(':TIMebase:MODE', choices=ChoiceStrings('MAIN', 'WINDow', 'XY', 'ROLL'))
        self.timebase_pos= scpiDevice(':TIMebase:POSition', str_type=float) # in seconds from trigger to display ref
        self.timebase_range= scpiDevice(':TIMebase:RANGe', str_type=float) # in seconds, full scale
        self.timebase_reference= scpiDevice(':TIMebase:REFerence', choices=ChoiceStrings('LEFT', 'CENTer', 'RIGHt'))
        self.timebase_scale= scpiDevice(':TIMebase:SCALe', str_type=float) # in seconds, per div
        #TODO: add a bunch of CHANNEL commands, Then MARKER and MEASure, TRIGger
        self._devwrap('fetch', autoinit=False, trig=True)
        self._devwrap('lasttrig_time', trig=False)
        self.readval = ReadvalDev(self.fetch)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()


#######################################################
##    Agilent EXA signal analyzer
#######################################################

#@register_instrument('Agilent Technologies', 'N9010A', 'A.12.13')
@register_instrument('Agilent Technologies', 'N9010A', usb_vendor_product=[0x0957, 0x0B0B], alias='N9010A EXA')
#@register_instrument('Agilent Technologies', 'N9030A', 'A.12.13')
@register_instrument('Agilent Technologies', 'N9030A', usb_vendor_product=[0x0957, 0x0D0B], alias='N9030A PXA')
class agilent_EXA(visaInstrumentAsync):
    """"""
    To use this instrument, the most useful devices are probably:
        fetch, readval
        marker_x, marker_y
        snap_png
    Some commands are available:
        abort
    A lot of other commands require a selected trace or a mkr
    see current_trace, current_mkr
    They are both memory device on the computer. They are not changeable from
    the hardware itself.

    Note about fetch_base and get_trace. They both return the same y data
    The units are given by y_unit and it is not affected by y offset.
    get_trace is immediate, fetch_base waits for the end of the current sweep
    if needed (including averaging).
    fetch_base includes the correct x scale. It can be different from the currently active
    x scale when not updating. x-scales are affected by freq offset.
    """"""
    def init(self, full=False):
        self.Ro = 50
        self.write(':format REAL,64')
        self.write(':format:border swap')
        super(agilent_EXA, self).init(full=full)
    @locked_calling
    def _async_trig(self):
        self.cont_trigger.set(False)
        super(agilent_EXA, self)._async_trig()
    def abort(self):
        self.write('ABORt')
    def _current_config_trace_helper(self, traces=None):
        # traces needs to be a list or None
        just_one = False
        if not isinstance(traces, (list)):
            just_one = True
            traces = [traces]
        trace_conf = ['current_trace', 'trace_type', 'trace_updating', 'trace_displaying',
                                      'trace_detector', 'trace_detector_auto']
        ret = []
        for t in traces:
            if t is not None:
                self.current_trace.set(t)
            tret = []
            for n in trace_conf:
                # follows _conf_helper
                val = _repr_or_string(getattr(self, n).getcache())
                tret.append(val)
            if ret == []:
                ret = tret
            else:
                ret = [old+', '+new for old, new in zip(ret, tret)]
        if just_one:
            ret = [n+'='+v for n, v in zip(trace_conf, ret)]
        else:
            ret = [n+'=['+v+']' for n, v in zip(trace_conf, ret)]
        return ret
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # Assume SA instrument mode, SAN measurement (config)
        if options.has_key('trace'):
            self.current_trace.set(options['trace'])
        if options.has_key('mkr'):
            self.current_mkr.set(options['mkr'])
        extra = []
        base_conf = self._conf_helper('instrument_mode', 'meas_mode', 'attenuation_db', 'attenuation_auto', 'y_unit', 'uW_path_bypass',
                                 'auxif_sel', 'preamp_en', 'preamp_band', 'cont_trigger',
                                 'freq_span', 'freq_start', 'freq_center', 'freq_stop', 'freq_offset', 'input_coupling',
                                 'gain_correction_db', 'ext_ref', 'ext_ref_mode', 'sweep_time', 'sweep_time_auto',
                                 'sweep_time_rule', 'sweep_time_rule_auto', 'sweep_type', 'sweep_type_auto', 'sweep_type_rule',
                                 'sweep_type_rule_auto', 'sweep_fft_width', 'sweep_fft_width_auto', 'sweep_npoints',
                                 'bw_res', 'bw_res_auto', 'bw_video', 'bw_video_auto', 'bw_video_auto_ratio', 'bw_video_auto_ratio_auto',
                                 'bw_res_span', 'bw_res_span_auto', 'bw_res_shape', 'bw_res_gaussian_type', 'noise_eq_bw',
                                 'average_count', 'average_type', 'average_type_auto', options)
        # trace
        if dev_obj in [self.readval, self.fetch]:
            traces_opt = self._fetch_traces_helper(options.get('traces'), options.get('updating'))
            extra = self._current_config_trace_helper(traces_opt)
        elif dev_obj in [self.fetch_base, self.get_trace]:
            extra = self._current_config_trace_helper()
        # marker dependent
        if dev_obj in [self.marker_x, self.marker_y, self.marker_z]:
            extra = self._conf_helper('current_mkr', 'marker_mode', 'marker_x_unit', 'marker_x_unit_auto', 'marker_ref', 'marker_trace',
                                      'marker_x', 'marker_y', 'marker_z', 'marker_trace',
                                      'marker_function', 'marker_function_band_span', 'marker_function_band_left',
                                      'marker_function_band_right', 'peak_search_continuous')
            old_trace = self.current_trace.get()
            extra += self._current_config_trace_helper(self.marker_trace.getcache())
            self.current_trace.set(old_trace)
        return extra+base_conf
    def _noise_eq_bw_getdev(self):
        """"""
        Using the bw_res and bw_res_shape this estimates the bandwith
        necessary to convert the data into power density.

        For gaussian filters the error in the estimate compared to the marker
        result is at most 0.06 dB (1.4% error) at 4 MHz (DB3),
        otherwise it is mostly within 0.01 dB (0.23%)
        For Flattop filters the error is at most -0.45 dB at 8 MHz (11%),
        otherwise it is mostly 0.040 - 0.050 (0.92-1.12%), centered around
        0.045 dB (1.0% offset) for bw below 120 kHz. (EXA N9010A, MY51170142)
        The correction means the equivalent bandwidth used for markers is
        1% greater than the selected value of the flat bandwidth. To correct
        for this, you can substract the noise density by 0.045 dB (or divide by
        1.010 if linear power scale).

        To see this errors, or to obtain the same factor as for the markers,
        set the instrument in the following way:
            -select resolution bandwidth (range, type ...)
            -setup a trace (assume units are dB...)
            -on trace put 2 markers at the same position
            -First marker shows just the raw value
            -Second marker setup to show noise (either noise or band density function)
            -Set band span for second marker to 0 (or the a single bin)
            -Then the bandwith used for marker calculation is
             10**((marker1-marker2)/10)
        You can see both by enabling the marker table. Note that for the function
        results the Y and function column should be the same here, but when the
        band span is larger they will be different. The Y value is the value of
        the function when the sweep has reached the marker position so it uses
        old values after the marker and so is not a valid result. You should
        consider the function result as the proper one. That is the value
        returned by marker_y devce in that case.

        The band power function is the integral of the band density over the
        selected band span (a span of 0 is the same as a span of one bin).
        So when band span is one bin:
            band_power(dBm)-band_density(dBm) = 10*log10(bin_width(Hz))
            bin_width = (freq_stop-freq_start)/(npoints-1)

        The distinction between the noise function and the band density function
        is that the noise function tries to apply correction for non-ideal
        detectors (peak, negative peak) or wrong averaging (volt, log Pow).
        The correction is calculated assuming the incoming signal is purely noise,
        and considers the video bandwidth.
        The band density function makes no such assumption and will return
        incorrect values for wrong detector/averaging. The best result is normally
        obtained with averaging detector in RMS mode.
        """"""
        #bw = self.bw_res.get()
        bw_mode = self.bw_res_shape.get()
        if bw_mode in self.bw_res_shape.choices[['gaussian']]:
            # The filters are always the same. They are defined for db3
            # but they are reported differently in the other modes.
            # We need the noise one.
            # In theory:
            #  The 3dB full width is 2*sqrt(log(2))*sigma
            #  The 6dB full width is sqrt(2) times 3dB
            #  The noise width is sqrt(pi)/(2*sqrt(log(2))) times 3dB (and is equivalent bw for power: from integral of V**2)
            #  The impulse width is sqrt(2) times noise (and is equivalent bw for amplitude: from integral of V)
            # In practice we use the noise and it is probably related to the
            # 3dB by some calibration. The conversion factor between 3dB and noise returned by
            # the instrument is not a constant (it is ~1.065).
            old_gaus_type = self.bw_res_gaussian_type.get()
            self.bw_res_gaussian_type.set('noise')
            bw = self.bw_res.get()
            self.bw_res_gaussian_type.set(old_gaus_type)
            # get the bw_res cache back to the correct value
            self.bw_res.get()
        else: # flat
            # Normally the equivalent noise bandwidth of a flat filter
            # is the bw of the filter. However, in practice, it could be different.
            bw = self.bw_res.get()
            # TODO maybe decide to apply the correction
            #bw *= 1.01
        return bw
    def _fetch_getformat(self, **kwarg):
        unit = kwarg.get('unit', 'default')
        xaxis = kwarg.get('xaxis', True)
        traces = kwarg.get('traces', None)
        updating = kwarg.get('updating', True)
        traces = self._fetch_traces_helper(traces, updating)
        if xaxis:
            zero_span = self.freq_span.get() == 0
            if zero_span:
                multi = 'time(s)'
            else:
                multi = 'freq(Hz)'
            multi = [multi]
        else:
            multi = []
        for t in traces:
            multi.append('trace%i'%t)
        fmt = self.fetch._format
        multi = tuple(multi)
        fmt.update(multi=multi, graph=[], xaxis=xaxis)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_traces_helper(self, traces, updating=True):
        """"""
        When updating is True, only updating trace are selected when
        traces=None. Otherwise all visible traces are selected.
        """"""
        if isinstance(traces, (tuple, list)):
            pass
        elif traces is not None:
            traces = [traces]
        else: # traces is None
            traces = []
            old_trace = self.current_trace.get()
            for t in range(1,7):
                if updating and self.trace_updating.get(trace=t):
                    traces.append(t)
                elif not updating and self.trace_displaying.get(trace=t):
                    traces.append(t)
            self.current_trace.set(old_trace)
        return traces
    def _convert_unit(self, v, from_unit, to_unit, bw):
        Ro = self.Ro
        if to_unit == 'default':
            return v
        from_unit = from_unit.upper()
        db_list = ['DBM', 'DBMV', 'DBMA', 'DBUV', 'DBUA', 'DBUVM', 'DBUAM', 'DBPT', 'DBG']
        db_ref = [1e-3, 2e-8, 5e-5, 2e-14, 5e-11, 0, 0, 0, 0] # in W
        if from_unit in db_list:
            in_db = True
            i = db_list.index(from_unit)
            in_ref = db_ref[i]
            if in_ref == 0:
                raise ValueError, self.perror(""Don't know how to convert from antenna unit %s""%from_unit)
        else: # V, W and A
            in_db = False
            # convert to W
            if from_unit == 'V':
                v = v**2 / Ro
            elif from_unit == 'A':
                v = v**2 * Ro
        to_db_list = ['dBm', 'dBm_Hz']
        to_lin_list = ['W', 'W_Hz', 'V', 'V_Hz', 'V2', 'V2_Hz']
        if to_unit not in to_db_list+to_lin_list:
            raise ValueError, self.perror(""Invalid conversion unit: %s""%to_unit)
        if not to_unit.endswith('_Hz'):
            bw = 0
        if to_unit in to_db_list:
            if in_db:
                v = v + 10*np.log10(in_ref/1e-3)
            else: # in is in W
                v = 10.*np.log10(v/1e-3)
            if bw:
                v -= 10*np.log10(bw)
        else: # W, V and V2 and _Hz variants
            if in_db:
                v = in_ref*10.**(v/10.)
            if to_unit in ['V', 'V_Hz']:
                bw = np.sqrt(bw)
                v = np.sqrt(v*Ro)
            elif to_unit in ['V2', 'V2_Hz']:
                v = v*Ro
            if bw:
                v /= bw
        return v
    def _fetch_getdev(self, traces=None, updating=True, unit='default', xaxis=True):
        """"""
         Available options: traces, updating, unit, xaxis
           -traces:  can be a single value or a list of values.
                     The values are integer representing the trace number (1-6)
           -updating: is used when traces is None. When True (default) only updating traces
                      are fetched. Otherwise all visible traces are fetched.
           -unit: can be default (whatever the instrument gives) or
                       'dBm'    for dBm
                       'W'      for Watt
                       'V'      for Volt
                       'V2'     for Volt**2
                       'dBm_Hz' for noise density
                       'W_Hz'   for W/Hz
                       'V_Hz'   for V/sqrt(Hz)
                       'V2_Hz'  for V**2/Hz
                 It can be a single value or a vector the same length as traces
                 See noise_eq_bw device for information about the
                 bandwidth used for _Hz unit conversion.
            -xaxis:  when True(default), the first column of data is the xaxis

           This version of fetch uses get_trace instead of fetch_base so it never
           block. It assumes all the data have the same x-scale (should be the
           case when they are all updating).
        """"""
        traces = self._fetch_traces_helper(traces, updating)
        if xaxis:
            ret = [self.get_xscale()]
        else:
            ret = []
        if not isinstance(unit, (list, tuple)):
            unit = [unit]*len(traces)
        base_unit = self.y_unit.get()
        noise_bw = self.noise_eq_bw.get()
        for t, u in zip(traces, unit):
            v = self.get_trace.get(trace=t)
            v = self._convert_unit(v, base_unit, u, noise_bw)
            ret.append(v)
        ret = np.asarray(ret)
        if ret.shape[0]==1:
            ret=ret[0]
        return ret
    def restart_averaging(self):
        command = ':AVERage:CLEar'
        self.write(command)
    def peak_search(self, mkr=None, next=False):
        """"""
        next can be True (same as finding next)
        left  to find the left
        right to find the next peak to the right
        """"""
        if mkr is None:
            mkr = self.current_mkr.getcache()
        if mkr<1 or mkr>12:
            raise ValueError, self.perror('mkr need to be between 1 and 12')
        if next == True:
            next = ':NEXT'
        elif next:
            next = ':'+next
        else:
            next = ''
        self.write('CALCulate:MARKer{mkr}:MAXimum'.format(mkr=mkr)+next)
    def marker_to_center_freq(self, mkr=None):
        if mkr is None:
            mkr = self.current_mkr.getcache()
        if mkr<1 or mkr>12:
            raise ValueError, self.perror('mkr need to be between 1 and 12')
        self.write('CALCulate:MARKer{mkr}:CENTer'.format(mkr=mkr))
    @locked_calling
    def get_xscale(self):
        """"""
        Returns the currently active x scale. It uses cached values so make sure
        they are up to date.
        This scale is recalculated but produces the same values (within floating
        point errors) as the instrument.
        """"""
        zero_span = self.freq_span.get() == 0
        if zero_span:
            offset = start = 0
            stop = self.sweep_time.get()
        else:
            start = self.freq_start.get()
            stop = self.freq_stop.get()
            offset = self.freq_offset.get()
        npts = self.sweep_npoints.get()
        return np.linspace(start+offset, stop+offset, npts)
    def _create_devs(self):
        self.installed_options = scpiDevice(getstr='*OPT?', str_type=quoted_string())
        ql = quoted_list(sep=', ')
        instrument_mode_list = ql(self.ask(':INSTrument:CATalog?'))
        # the list is name number, make it only name
        instrument_mode_list = [i.split(' ')[0] for i in instrument_mode_list]
        self.instrument_mode = scpiDevice(':INSTrument', choices=ChoiceStrings(*instrument_mode_list))
        # This list depends on instrument mode: These are measurement type
        self.meas_mode_list = scpiDevice(getstr=':CONFigure:CATalog?', str_type=ql)
        # From the list: SAN=SANalyzer
        self.meas_mode = scpiDevice(':CONFigure:{val}:NDEFault', ':CONFigure?')
        self.attenuation_db = scpiDevice(':POWer:ATTenuation', str_type=float)
        self.attenuation_auto = scpiDevice(':POWer:ATTenuation:AUTO', str_type=bool)
        self.y_unit = scpiDevice('UNIT:POWer', choices=ChoiceStrings('DBM', 'DBMV', 'DBMA', 'DBUV', 'DBUA', 'DBUVM', 'DBUAM', 'DBPT', 'DBG', 'V', 'W', 'A'))
        self.uW_path_bypass = scpiDevice(':POWer:MW:PATH', choices=ChoiceStrings('STD', 'LNPath', 'MPBypass', 'FULL'))
        self.auxif_sel = scpiDevice(':OUTPut:AUX', choices=ChoiceStrings('SIF', 'OFF')) # others could be AIF and LOGVideo if options are installed
        self.preamp_en = scpiDevice(':POWer:GAIN', str_type=bool)
        self.preamp_band = scpiDevice(':POWer:GAIN:BAND', choices=ChoiceStrings('LOW', 'FULL'))
        self.cont_trigger = scpiDevice('INITiate:CONTinuous', str_type=bool)
        minfreq = float(self.ask(':FREQ:START? min'))
        maxfreq = float(self.ask(':FREQ:STOP? max'))
        self.freq_start = scpiDevice(':FREQuency:STARt', str_type=float, min=minfreq, max=maxfreq-10.)
        self.freq_center = scpiDevice(':FREQuency:CENTer', str_type=float, min=minfreq, max=maxfreq)
        self.freq_stop = scpiDevice(':FREQuency:STOP', str_type=float, min=minfreq, max=maxfreq)
        self.freq_offset = scpiDevice(':FREQuency:OFFset', str_type=float, min=-500e-9, max=500e9)
        self.input_coupling = scpiDevice(':INPut:COUPling', choices=ChoiceStrings('AC', 'DC'))
        self.gain_correction_db = scpiDevice(':CORREction:SA:GAIN', str_type=float)
        self.ext_ref = scpiDevice(getstr=':ROSCillator:SOURce?', str_type=str)
        self.ext_ref_mode = scpiDevice(':ROSCillator:SOURce:TYPE', choices=ChoiceStrings('INTernal', 'EXTernal', 'SENSe'))
        self.sweep_time = scpiDevice(':SWEep:TIME', str_type=float, min=1e-6, max=6000) # in sweep: 1ms-4000s, in zero span: 1us-6000s
        self.sweep_time_auto = scpiDevice(':SWEep:TIME:AUTO', str_type=bool)
        self.sweep_time_rule = scpiDevice(':SWEep:TIME:AUTO:RULes', choices=ChoiceStrings('NORMal', 'ACCuracy', 'SRESponse'))
        self.sweep_time_rule_auto = scpiDevice(':SWEep:TIME:AUTO:RULes:AUTO', str_type=bool)
        self.sweep_type = scpiDevice(':SWEep:TYPE', choices=ChoiceStrings('FFT', 'SWEep'))
        self.sweep_type_auto = scpiDevice(':SWEep:TYPE:AUTO', str_type=bool)
        self.sweep_type_rule = scpiDevice(':SWEep:TYPE:AUTO:RULes', choices=ChoiceStrings('SPEed', 'DRANge'))
        self.sweep_type_rule_auto = scpiDevice(':SWEep:TYPE:AUTO:RULes:AUTO', str_type=bool)
        self.sweep_fft_width = scpiDevice(':SWEep:FFT:WIDTh', str_type=float)
        self.sweep_fft_width_auto = scpiDevice(':SWEep:FFT:WIDTh:AUTO', str_type=bool)
        self.sweep_npoints = scpiDevice(':SWEep:POINts', str_type=int, min=1, max=40001)
        # For SAN measurement
        # available bandwidths gaussian db3:
        #   b = around(logspace(0,1,25),1)[:-1]; b[-2]-=.1; b[10:17] +=.1
        #   r = (b*10**arange(7)[:,None]).ravel()
        #   rgaus = append(r[:-12], [4e6,5e6, 6e6, 8e6])
        # and flat:
        #   rflat = append(r[11:-35], [3.9e5, 4.3e5, 5.1e5, 6.2e5, 7.5e5, 1e6, 1.5e6, 3e6, 4e6, 5e6, 6e6, 8e6])
        self.bw_res = scpiDevice(':BANDwidth', str_type=float, min=1, max=8e6, setget=True)
        self.bw_res_auto = scpiDevice(':BANDwidth:AUTO', str_type=bool)
        self.bw_video = scpiDevice(':BANDwidth:VIDeo', str_type=float, min=1, max=50e6)
        self.bw_video_auto = scpiDevice(':BANDwidth:VIDeo:AUTO', str_type=bool)
        self.bw_video_auto_ratio = scpiDevice(':BANDwidth:VIDeo:RATio', str_type=float, min=1e-5, max=3e6)
        self.bw_video_auto_ratio_auto = scpiDevice(':BANDwidth:VIDeo:RATio:AUTO', str_type=bool)
        self.bw_res_span = scpiDevice(':FREQuency:SPAN:BANDwidth:RATio', str_type=float, min=2, max=10000)
        self.bw_res_span_auto = scpiDevice(':FREQuency:SPAN:BANDwidth:RATio:AUTO', str_type=bool)
        self.bw_res_shape = scpiDevice(':BANDwidth:SHAPe', choices=ChoiceStrings('GAUSsian', 'FLATtop'))
        self.bw_res_gaussian_type = scpiDevice(':BANDwidth:TYPE', choices=ChoiceStrings('DB3', 'DB6', 'IMPulse', 'NOISe'))
        self.average_count = scpiDevice(':AVERage:COUNt',str_type=int, min=1, max=10000)
        self.average_type = scpiDevice(':AVERage:TYPE', choices=ChoiceStrings('RMS', 'LOG', 'SCALar'))
        self.average_type_auto = scpiDevice(':AVERage:TYPE:AUTO', str_type=bool)
        self.freq_span = scpiDevice(':FREQuency:SPAN', str_type=float, min=0, doc='You can select 0 span, otherwise minimum span is 10 Hz')
        # Trace dependent
        self.current_trace = MemoryDevice(1, min=1, max=6)
        def devTraceOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(trace=self.current_trace)
            app = kwarg.pop('options_apply', ['trace'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        # trace 0 is special, The others are 1-6 and return x,y pairs
        # trace 0:  margin/limit fail, F, F, F, N dB points result, current avg count, npoints sweep, F, F, F , Mkr1xy, Mkr2xy, .., Mkr12xy
        self.fetch_base = devTraceOption(getstr=':FETCh:{measurement}{trace}?', raw=True,
                                         str_type=decode_float64_2col, autoinit=False, trig=True, options=dict(measurement=self.meas_mode))
        self.fetch0_base = scpiDevice(getstr=':FETCh:{measurement}0?', str_type=str, autoinit=False, trig=True, options=dict(measurement=self.meas_mode))
        self.trace_type = devTraceOption(':TRACe{trace}:TYPE', choices=ChoiceStrings('WRITe', 'AVERage', 'MAXHold', 'MINHold'))
        self.trace_updating = devTraceOption(':TRACe{trace}:UPDate', str_type=bool)
        self.trace_displaying = devTraceOption(':TRACe{trace}:DISPlay', str_type=bool)
        self.trace_detector = devTraceOption(':DETector:TRACe{trace}', choices=ChoiceStrings('AVERage', 'NEGative', 'NORMal', 'POSitive', 'SAMPle', 'QPEak', 'EAVerage', 'RAVerage'))
        self.trace_detector_auto = devTraceOption(':DETector:TRACe{trace}:AUTO', str_type=bool)
        self.get_trace = devTraceOption(getstr=':TRACe? TRACE{trace}', raw=True, str_type=decode_float64, autoinit=False, trig=True)
        # TODO implement trace math, ADC dither, swept IF gain FFT IF gain
        # marker dependent
        self.current_mkr = MemoryDevice(1, min=1, max=12)
        def devMkrOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(mkr=self.current_mkr)
            app = kwarg.pop('options_apply', ['mkr'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.marker_mode = devMkrOption(':CALCulate:MARKer{mkr}:MODE', choices=ChoiceStrings('POSition', 'DELTa', 'FIXed', 'OFF'))
        self.marker_x = devMkrOption(':CALCulate:MARKer{mkr}:X', str_type=float, trig=True)
        self.marker_x_unit = devMkrOption(':CALCulate:MARKer{mkr}:X:READout', choices=ChoiceStrings('FREQuency', 'TIME', 'ITIMe', 'PERiod'))
        self.marker_x_unit_auto = devMkrOption(':CALCulate:MARKer{mkr}:X:READout:AUTO', str_type=bool)
        self.marker_y = devMkrOption(':CALCulate:MARKer{mkr}:Y', str_type=float, trig=True)
        self.marker_z = devMkrOption(':CALCulate:MARKer{mkr}:Z', str_type=float, trig=True) # for spectrogram mode
        self.marker_ref = devMkrOption(':CALCulate:MARKer{mkr}:REFerence', str_type=int, min=1, max=12)
        self.marker_trace = devMkrOption(':CALCulate:MARKer{mkr}:TRACe', str_type=int, min=1, max=6)
        self.marker_function = devMkrOption(':CALCulate:MARKer{mkr}:FUNCtion', choices=ChoiceStrings('NOISe', 'BPOWer', 'BDENsity', 'OFF'))
        self.marker_function_band_span = devMkrOption(':CALCulate:MARKer{mkr}:FUNCtion:BAND:SPAN', str_type=float, min=0)
        self.marker_function_band_left = devMkrOption(':CALCulate:MARKer{mkr}:FUNCtion:BAND:LEFT', str_type=float, min=0)
        self.marker_function_band_right = devMkrOption(':CALCulate:MARKer{mkr}:FUNCtion:BAND:RIGHt', str_type=float, min=0)
        self.peak_search_continuous = devMkrOption(':CALCulate:MARKer{mkr}:CPSearch', str_type=bool)

        # initial hack for list sweep measurement
        self.fetch_list = scpiDevice(getstr=':FETCh:LIST?', str_type=decode_float64, autoinit=False, trig=True)

        #following http://www.mathworks.com/matlabcentral/fileexchange/30791-taking-a-screenshot-of-an-agilent-signal-analyzer-over-a-tcpip-connection
        #note that because of *OPC?, the returned string is 1;#....
        self.snap_png = scpiDevice(getstr=r':MMEMory:STORe:SCReen ""C:\TEMP\SCREEN.PNG"";*OPC?;:MMEMory:DATA? ""C:\TEMP\SCREEN.PNG""',
                                   raw=True, str_type=lambda x:_decode_block_base(x[2:]), autoinit=False)
        self.snap_png._format['bin']='.png'

        self._devwrap('noise_eq_bw', autoinit=.5) # This should be initialized after the devices it depends on (if it uses getcache)
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()
# status byte stuff
# There is a bunch of register groups:
#  :status:operation
#  :status:questionable
#  :status:questionable:power
#  :status:questionable:frequency
# ALSO see comments below agilent_PNAL


#######################################################
##    Agilent PNA-L network analyzer
#######################################################

#@register_instrument('Agilent Technologies', 'N5244A', 'A.09.50.13')
#@register_instrument('Agilent Technologies', 'N5230C', 'A.09.20.08')
@register_instrument('Agilent Technologies', 'N5244A', usb_vendor_product=[0x0957, 0x0118], alias='N5244A PNAX')
@register_instrument('Agilent Technologies', 'N5230C', usb_vendor_product=[0x0957, 0x0118], alias='N5230C PNA-L')
class agilent_PNAL(visaInstrumentAsync):
    """"""
    To use this instrument, the most useful device is probably:
        fetch, readval
    Some commands are available:
        abort
        create_measurement
        delete_measurement
        restart_averaging
        phase_unwrap, phase_wrap, phase_flatten
        get_file
    Other useful devices:
        channel_list
        current_channel
        select_trace
        select_traceN
        freq_start, freq_stop, freq_cw
        power_en
        power_dbm_port1, power_dbm_port2
        marker_x, marker_y
        snap_png
        cont_trigger

    Note that almost all devices/commands require a channel.
    It can be specified with the ch option or will use the last specified
    one if left to the default.
    A lot of other commands require a selected trace (per channel)
    The active one can be selected with the trace option or select_trace, select_traceN
    If unspecified, the last one is used.

    If a trace is REMOVED from the instrument, you should perform a get of
    the channel_list device to update pyHegel knowledge of the available
    traces (needed when trying to fetch all traces).
    """"""
    def init(self, full=False):
        self.write(':format REAL,64')
        self.write(':format:border swap')
        super(agilent_PNAL, self).init(full=full)
    @locked_calling
    def _async_trig(self):
        # we don't use the STATus:OPERation:AVERaging1? status
        # because for n averages they turn on after the n-1 average.
        # Also it is a complex job to figure out which traces to keep track of
        # Here we will assume that _async_trigger_helper ('INITiate;*OPC')
        # starts all the channels (global triggering). It also does a single
        # iteration of an average.
        # We will just count the correct number of repeats to do.
        ch_orig = self.current_channel.getcache()
        ch_list = self.active_channels_list.getcache()
        reps = 1
        for ch in ch_list:
            if self.average_en.get(ch=ch):
                self.restart_averaging(ch) # so instrument displays shows the restart
                count = self.average_count.get()
                reps = max(reps, count)
        self.current_channel.set(ch_orig)
        self._trig_reps_total = reps
        self._trig_reps_current = 0
        self.cont_trigger.set(False)
        super(agilent_PNAL, self)._async_trig()
    def _async_detect(self, max_time=.5): # 0.5 s max by default
        ret = super(agilent_PNAL, self)._async_detect(max_time)
        if not ret:
            # This cycle is not finished
            return ret
        # cycle is finished
        self._trig_reps_current += 1
        if self._trig_reps_current < self._trig_reps_total:
            self._async_trigger_helper()
            return False
        return True
    def abort(self):
        self.write('ABORt')
    @locked_calling
    def create_measurement(self, name, param, ch=None):
        """"""
        name: any unique, non-empty string. If it already exists, we change its param
        param: Any S parameter as S11 or S1_1 (second form only for double-digit port numbers S10_1)
               Ratio measurement, any 2 physical receiver separated by / and followed by , and source port
               like A/R1,3
               Non-Ratio measurement: Any receiver followed by , and source port like A,4
               Ratio and non-ratio can also use logical receiver notation
               ADC measurement: ADC receiver, then , then source por like AI1,2
               Balanced measurment: ...
        """"""
        ch_list = self.channel_list.get(ch=ch)
        ch=self.current_channel.getcache()
        if name in ch_list:
            self.select_trace.set(name)
            command = 'CALCulate{ch}:PARameter:MODify:EXTended ""{param}""'.format(ch=ch, param=param)
        else:
            command = 'CALCulate{ch}:PARameter:EXTended ""{name}"",""{param}""'.format(ch=ch, name=name, param=param)
        self.write(command)
    @locked_calling
    def delete_measurement(self, name=None, ch=None):
        """""" delete a measurement.
            if name=None: delete all measurements for ch
            see channel_list for the available measurments
        """"""
        ch_list = self.channel_list.get(ch=ch)
        ch=self.current_channel.getcache()
        if name is not None:
            if name not in ch_list:
                raise ValueError, self.perror('Invalid Trace name')
            command = 'CALCulate{ch}:PARameter:DELete ""{name}""'.format(ch=ch, name=name)
        else:
            command = 'CALCulate{ch}:PARameter:DELete:ALL'.format(ch=ch)
        self.write(command)
    @locked_calling
    def restart_averaging(self, ch=None):
        #sets ch if necessary
        if not self.average_en.get(ch=ch):
            return
        ch=self.current_channel.getcache()
        command = 'SENSe{ch}:AVERage:CLEar'.format(ch=ch)
        self.write(command)
    def get_file(self, remote_file, local_file=None):
        """"""
            Obtain the file remote_file from the analyzer and save it
            on this computer as local_file if given, otherwise returns the data
        """"""
        s = self.ask('MMEMory:TRANsfer? ""%s""'%remote_file, raw=True)
        s = _decode_block_base(s)
        if local_file:
            with open(local_file, 'wb') as f:
                f.write(s)
        else:
            return s
    def remote_ls(self, remote_path=None):
        """"""
            if remote_path is None, get catalog of device remote_cwd.
            It only list files (not directories).
            returns None for empty and invalid directories.
        """"""
        extra = """"
        if remote_path:
            extra = ' ""%s""'%remote_path
        res = self.ask('MMEMory:CATalog?'+extra)
        res = quoted_string()(res)
        if res == 'NO CATALOG':
            return None
        else:
            return res.split(',')
    def send_file(self, dest_file, local_src_file=None, src_data=None, overwrite=False):
        """"""
            dest_file: is the file name (absolute or relative to device remote_cwd)
                       you can use / to separate directories
            overwrite: when True will skip testing for the presence of the file on the
                       instrument and proceed to overwrite it without asking confirmation.
            Use one of local_src_file (local filename) or src_data (data string)
            Maximum file size is 20 MB.
        """"""
        if not overwrite:
            # split seeks both / and \
            directory, filename = os.path.split(dest_file)
            ls = self.remote_ls(directory)
            if ls:
                ls = map(lambda s: s.lower(), ls)
                if filename.lower() in ls:
                    raise RuntimeError('Destination file already exists. Will not overwrite.')
        if src_data is local_src_file is None:
            raise ValueError('You need to specify one of local_src_file or src_data')
        if src_data and local_src_file:
            raise ValueError('You need to specify only one of local_src_file or src_data')
        if local_src_file:
            with open(local_src_file, 'rb') as f:
                src_data = f.read()
        data_str = _encode_block(src_data)
        # manually add terminiation to prevent warning if data already ends with termination
        self.write('MMEMory:TRANsfer ""%s"",%s\n'%(dest_file, data_str), termination=None)

    def _fetch_getformat(self, **kwarg):
        unit = kwarg.get('unit', 'default')
        xaxis = kwarg.get('xaxis', True)
        ch = kwarg.get('ch', None)
        traces = kwarg.get('traces', None)
        cook = kwarg.get('cook', False)
        cal = kwarg.get('cal', False)
        if cal:
            cook = False
        if ch is not None:
            self.current_channel.set(ch)
        traces = self._fetch_traces_helper(traces, cal)
        if xaxis:
            sweeptype = self.sweep_type.getcache()
            choice = self.sweep_type.choices
            if sweeptype in choice[['linear', 'log', 'segment']]:
                multi = 'freq(Hz)'
            elif sweeptype in choice[['power']]:
                multi = 'power(dBm)'
            elif sweeptype in choice[['CW']]:
                multi = 'time(s)'
            else: # PHASe
                multi = 'deg' # TODO check this
            multi = [multi]
        else:
            multi = []
        # we don't handle cmplx because it cannot be saved anyway so no header or graph
        for t in traces:
            names = None
            if cook:
                f = self.trace_format.get(trace=t)
                if f not in self.trace_format.choices[['POLar', 'SMITh', 'SADMittance']]:
                    names = ['cook_val']
            if names is None:
                if unit == 'db_deg':
                    names = ['dB', 'deg']
                else:
                    names = ['real', 'imag']
            if cal:
                if isinstance(t, tuple):
                    basename = '%s_%i_%i_'%t
                else:
                    basename = t+'_'
            else:
                name, param = self.select_trace.choices[t]
                basename = ""%s=%s_""%(name, param)
            multi.extend( [basename+n for n in names])
        fmt = self.fetch._format
        multi = tuple(multi)
        fmt.update(multi=multi, graph=[], xaxis=xaxis)
        return BaseDevice.getformat(self.fetch, **kwarg)
    def _fetch_traces_helper(self, traces, cal=False):
        # assume ch is selected
        if cal:
            ch_list = self.calib_data_name_list.get()
        else:
            ch_list = self.channel_list.getcache()
        if isinstance(traces, list) or ((not cal) and isinstance(traces, tuple)):
            traces = traces[:] # make a copy so it can be modified without affecting caller. I don't think this is necessary anymore but keep it anyway.
        elif traces is not None:
            traces = [traces]
        else: # traces is None
            if cal:
                traces = ch_list
            else:
                traces = ch_list.keys()
        return traces
    def _fetch_getdev(self, ch=None, traces=None, unit='default', mem=False, xaxis=True, cook=False, cal=False):
        """"""
           options available: traces, unit, mem and xaxis
            -traces: can be a single value or a list of values.
                     The values are strings representing the trace or the trace number
                     or when cal is True, calibration names like 'Directivity(1,1)'
                     or tuples like ('EDIR', 1, 1)
            -unit:   can be 'default' (real, imag)
                       'db_deg' (db, deg) , where phase is unwrapped
                       'cmplx'  (complexe number), Note that this cannot be written to file
            -mem:    when True, selects the memory trace instead of the active one.
            -xaxis:  when True(default), the first column of data is the xaxis
            -cal:    when True, traces refers to the calibration curves, mem and cook are
                     unused.
            -cook:   when True (default is False) returns the values from the display format
                     They include the possible effects from trace math(edelay, transforms, gating...)
                     as well as smoothing. When this is selected, unit has no effect unless the format is
                     Smith, Polar or Inverted Smith (in which case both real and imaginary are read and
                     converted appropriately)
                     Note that not all the necessary settings are saved in the file headers.
            If you try to read  from ch=200 (for example the ecal viewer), you probably need cook=True.
        """"""
        if ch is not None:
            self.current_channel.set(ch)
        if cal:
            cook = False
        traces = self._fetch_traces_helper(traces, cal)
        if cook:
            getdata = self.calc_fdata
        else:
            getdata = self.calc_sdata
        if mem:
            if cook:
                getdata = self.calc_fmem
            else:
                getdata = self.calc_smem
        if xaxis:
            if cal:
                ret = [self.calib_freq.get()]
            else:
                # get the x axis of the first trace selected
                self.select_trace.set(traces[0])
                ret = [self.calc_x_axis.get()]
        else:
            ret = []
        for t in traces:
            if cal:
                if isinstance(t, tuple):
                    v = self.calib_data.get(eterm=t[0], p1=t[1], p2=t[2])
                else:
                    v = self.calib_data_name.get(eterm=t)
            else:
                v = getdata.get(trace=t)
            if cook:
                f = self.trace_format.get(trace=t)
                if f not in self.trace_format.choices[['POLar', 'SMITh', 'SADMittance']]:
                    # This next check is required for ENA1 at least
                    if v.size == 2*self.npoints.get():
                        if not np.all(v[1::2] == 0):
                            print self.perror(""WARNING: Discarding non-null data"")
                        v = v[::2]
                    ret.append(v)
                    continue
                v = v[0::2] + 1j*v[1::2]
            if unit == 'db_deg':
                r = 20.*np.log10(np.abs(v))
                theta = np.angle(v, deg=True)
                theta = self.phase_unwrap(theta)
                ret.append(r)
                ret.append(theta)
            elif unit == 'cmplx':
                ret.append(v)
            else:
                ret.append(v.real)
                ret.append(v.imag)
        ret = np.asarray(ret)
        if ret.shape[0]==1:
            ret=ret[0]
        return ret
    @staticmethod
    def phase_unwrap(phase_deg):
        return scipy.rad2deg( scipy.unwrap( scipy.deg2rad(phase_deg) ) )
    @staticmethod
    def phase_wrap(phase_deg):
        return (phase_deg +180.) % 360 - 180.
    @staticmethod
    def phase_flatten(phase_deg, freq, delay=0., ratio=[0,-1]):
        """"""
           Using an unwrapped phase, this removes a slope.
           if delay is specified, it adds delay*f*360
           If delay is 0. (default) then it uses 2 points
           specified by ratio (defaults to first and last)
           to use to extract slope (delay)
        """"""
        dp = phase_deg[ratio[1]] - phase_deg[ratio[0]]
        df = freq[ratio[1]] - freq[ratio[0]]
        if delay == 0.:
            delay = -dp/df/360.
            print 'Using delay=', delay
        return phase_deg + delay*freq*360.
    def get_xscale(self):
        return self.x_axis.get()

    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # These all refer to the current channel
        # calib_en depends on trace
        if options.has_key('ch'):
            self.current_channel.set(options['ch'])
        if options.has_key('trace'):
            self.select_trace.set(options['trace'])
        if options.has_key('mkr'):
            self.current_mkr.set(options['mkr'])
        extra = []
        if dev_obj in [self.marker_x, self.marker_y]:
            # Cannot get cache of marker_x while getting marker_x (end up getting an old cache)
            if dev_obj == self.marker_x:
                mxy = 'marker_y'
            else:
                mxy = 'marker_x'
            extra = self._conf_helper('current_mkr', 'marker_format', 'trace_format', 'marker_trac_func', 'marker_trac_en',
                              mxy, 'marker_discrete_en', 'marker_target')
        cook = False
        if dev_obj in [self.readval, self.fetch]:
            cal = options.get('cal', False)
            cook = options.get('cook', False)
            if cal:
                cook = False
            traces_opt = self._fetch_traces_helper(options.get('traces'), cal)
            cal_en = []
            traces = []
            fmts = []
            for t in traces_opt:
                if cal:
                    cal_en.append('Unknown')
                    if isinstance(t, tuple):
                        traces.append('%s_%i_%i'%t)
                    else:
                        traces.append(t)
                else:
                    cal_en.append(self.calib_en.get(trace=t))
                    name, param = self.select_trace.choices[t]
                    traces.append(name+'='+param)
                if cook:
                    fmts.append(self.trace_format.get())
        elif dev_obj == self.snap_png:
            traces = cal_en='Unknown'
        else:
            t=self.select_trace.getcache()
            cal_en = self.calib_en.get()
            name, param = self.select_trace.choices[t]
            traces = name+'='+param
        extra += ['calib_en=%r'%cal_en, 'selected_trace=%r'%traces]
        if cook:
            extra += ['trace_format=%r'%fmts]
        base = self._conf_helper('current_channel', 'freq_cw', 'freq_start', 'freq_stop', 'ext_ref',
                                 'power_en', 'power_couple',
                                 'power_slope', 'power_slope_en',
                                 'power_dbm_port1', 'power_dbm_port2',
                                 'power_mode_port1', 'power_mode_port2',
                                 'npoints', 'sweep_gen', 'sweep_gen_pointsweep',
                                 'sweep_fast_en', 'sweep_time', 'sweep_type',
                                 'bandwidth', 'bandwidth_lf_enh', 'cont_trigger',
                                 'average_count', 'average_mode', 'average_en', options)
        return extra+base
    def _create_devs(self):
        self.installed_options = scpiDevice(getstr='*OPT?', str_type=quoted_string())
        self.self_test_results = scpiDevice(getstr='*tst?', str_type=int, doc=""""""
            Flag bits:
                0=Phase Unlock
                1=Source unleveled
                2=Unused
                3=EEprom write fail
                4=YIG cal failed
                5=Ramp cal failed"""""")
        self.current_channel = MemoryDevice(1, min=1, max=200)
        self.active_channels_list = scpiDevice(getstr='SYSTem:CHANnels:CATalog?', str_type=quoted_list(element_type=int))
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.channel_list = devChOption(getstr='CALCulate{ch}:PARameter:CATalog:EXTended?', str_type=quoted_dict(protect_sep=('(',')')),
                                        autoinit=10, doc='Note that some "","" are replaced by ""_""')
        traceN_options = dict(trace=1)
        traceN_options_lim = dict(trace=(1,None))
        # The instrument complains that MEASurement12 is too long (for 2 digit trace)
        # so use just MEAS instead
        # I think it must be a limit of 12 characters for every scpi element (between :)
        # make autoinit=False because the default of trace=1 might not exist
        self.traceN_name = scpiDevice(getstr=':SYSTem:MEAS{trace}:NAME?', str_type=quoted_string(), autoinit=False,
                                      options = traceN_options, options_lim = traceN_options_lim)
        self.traceN_window = scpiDevice(getstr=':SYSTem:MEAS{trace}:WINDow?', str_type=int, autoinit=False,
                                      options = traceN_options, options_lim = traceN_options_lim)
        # windowTrace restarts at 1 for each window
        self.traceN_windowTrace = scpiDevice(getstr=':SYSTem:MEAS{trace}:TRACe?', str_type=int, autoinit=False,
                                      options = traceN_options, options_lim = traceN_options_lim)
        traceN_name_func = self.traceN_name
        select_trace_choices = ChoiceDevSwitch(self.channel_list,
                                               lambda t: traceN_name_func.get(trace=t),
                                               sub_type=quoted_string())
        self.select_trace = devChOption('CALCulate{ch}:PARameter:SELect', autoinit=8,
                                        choices=select_trace_choices, doc=""""""
                Select the trace using either the trace name (standard ones are 'CH1_S11_1')
                which are unique, the trace param like 'S11' which might not be unique
                (in which case the first one is used), or even the trace number
                which are also unique."""""")
        def devCalcOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(trace=self.select_trace)
            app = kwarg.pop('options_apply', ['ch', 'trace'])
            kwarg.update(options=options, options_apply=app)
            return devChOption(*arg, **kwarg)
        # select_trace needs to be set for most of the calc commands
        #calc:par:TNUMber and WNUMber don't exist for our PNAL
        # since select_trace handles the number here we make it only a get
        # but MNUMber could also be a set.
        self.select_trace_N = devCalcOption(getstr='CALCulate{ch}:PARameter:MNUMber?', str_type=int, doc='The number is from the Tr1 annotation next to the parameter nane on the PNA screen')
        self.edelay_length = devCalcOption('CALCulate{ch}:CORRection:EDELay:DISTance', str_type=float)
        self.edelay_length_unit = devCalcOption('CALC{ch}:CORR:EDEL:UNIT', choices=ChoiceStrings('METer', 'FEET', 'INCH'))
        self.edelay_length_medium = devCalcOption('CALC{ch}:CORR:EDEL:MEDium', choices=ChoiceStrings('COAX', 'WAVEguide'))
        self.edelay_time = devCalcOption('CALC{ch}:CORR:EDEL', str_type=float, min=-10, max=10, doc='Set delay in seconds')
        data_format = ChoiceStrings('MLINear', 'MLOGarithmic', 'PHASe', 'UPHase', 'IMAGinary', 'REAL', 'POLar', 'SMITh', 'SADMittance', 'SWR', 'GDELay', 'KELVin', 'FAHRenheit', 'CELSius')
        self.trace_format = devCalcOption('CALCulate{ch}:FORMat', choices=data_format) # needed when marker_format is 'DEF'
        self.calib_en = devCalcOption('CALC{ch}:CORR', str_type=bool)
        calib_data_options = dict(eterm='EDIR', p1=1, p2=1)
        eterm_options = ChoiceStrings('EDIR', 'ESRM', 'ERFT', 'ELDM', 'ETRT', 'EXTLK', 'ERSPT', 'ERSPI')
        calib_data_options_lim = dict(eterm=eterm_options, p1=(1,4), p2=(1,4))
        calib_data_options_conv = dict(eterm=lambda val, quoted_val: val)
        self.calib_data = devChOption(getstr='SENSe{ch}:CORRection:CSET:DATA? {eterm},{p1},{p2}', str_type=decode_complex128, autoinit=False, raw=True,
                                      options_conv=calib_data_options_conv, options=calib_data_options, options_lim=calib_data_options_lim,
                                      doc=""""""
                                         You should specify eterm, p1 and p2. They default to EDIR, 1, 1
                                         The various values for eterm are:
                                           EDIR:  directivity
                                           ESRM:  source match
                                           ERFT:  reflection tracking
                                           ELDM:  load match
                                           ETRT:  transmission tracking
                                           EXTLK: crosstalk
                                           ERSPT: response tracking
                                           ERSPI: response isolation
                                         p1 is the measured port when used (otherwise needs to be any valid number)
                                         p2 is the source port when used (otherwise needs to be any valid number)
                                      """""")
        self.calib_data_name = devChOption(getstr='SENSe{ch}:CORRection:CSET:ETERm? {eterm}', str_type=decode_complex128, autoinit=False,
                                           options=dict(eterm='Directivity(1,1)'), raw=True,
                                           doc=""The eterm should be specified and is the name used in the cal viewer. see calib_data_name_list device"")
        self.calib_data_name_list = devChOption(getstr='SENSe{ch}:CORRection:CSET:ETERm:CATalog?',
                                                str_type=quoted_list(protect_sep=('(', ')')), autoinit=False)
        self.calib_current_name = devChOption(getstr='SENSe{ch}:CORRection:CSET:NAME?', str_type=quoted_string(), autoinit=False)
        self.calib_current_desc = devChOption(getstr='SENSe{ch}:CORRection:CSET:DESCription?', str_type=quoted_string(), autoinit=False)
        self.calib_list = scpiDevice(getstr='SENSe:CORRection:CSET:CATalog? NAME', str_type=quoted_list(), autoinit=False)
        self.calib_freq = devChOption(getstr='SENSe{ch}:CORRection:CSET:STIMulus?', str_type=decode_float64, autoinit=False)
        self.snap_png = scpiDevice(getstr='HCOPy:SDUMp:DATA:FORMat PNG;:HCOPy:SDUMp:DATA?', raw=True, str_type=_decode_block_base, autoinit=False)
        self.snap_png._format['bin']='.png'
        self.cont_trigger = scpiDevice('INITiate:CONTinuous', str_type=bool)
        self.bandwidth = devChOption('SENSe{ch}:BANDwidth', str_type=float, setget=True) # can obtain min max
        self.bandwidth_lf_enh = devChOption('SENSe{ch}:BANDwidth:TRACk', str_type=bool)
        self.average_count = devChOption('SENSe{ch}:AVERage:COUNt', str_type=int)
        self.average_mode = devChOption('SENSe{ch}:AVERage:MODE', choices=ChoiceStrings('POINt', 'SWEep'))
        self.average_en = devChOption('SENSe{ch}:AVERage', str_type=bool)
        self.coupling_mode = devChOption('SENSe{ch}:COUPle', choices=ChoiceStrings('ALL', 'NONE'), doc='ALL means sweep mode set to chopped (trans and refl measured on same sweep)\nNONE means set to alternate, imporves mixer bounce and isolation but slower')
        self.freq_start = devChOption('SENSe{ch}:FREQuency:STARt', str_type=float, min=10e6, max=40e9)
        self.freq_stop = devChOption('SENSe{ch}:FREQuency:STOP', str_type=float, min=10e6, max=40e9)
        self.freq_center = devChOption('SENSe{ch}:FREQuency:CENTer', str_type=float, min=10e6, max=40e9)
        self.freq_span = devChOption('SENSe{ch}:FREQuency:SPAN', str_type=float, min=0, max=40e9)
        self.freq_cw= devChOption('SENSe{ch}:FREQuency:CW', str_type=float, min=10e6, max=40e9)
        self.ext_ref = scpiDevice(getstr='SENSe:ROSCillator:SOURce?', str_type=str)
        self.npoints = devChOption('SENSe{ch}:SWEep:POINts', str_type=int, min=1)
        self.sweep_gen = devChOption('SENSe{ch}:SWEep:GENeration', choices=ChoiceStrings('STEPped', 'ANALog'))
        self.sweep_gen_pointsweep =devChOption('SENSe{ch}:SWEep:GENeration:POINtsweep', str_type=bool, doc='When true measure rev and fwd at each frequency before stepping')
        self.sweep_fast_en =devChOption('SENSe{ch}:SWEep:SPEed', choices=ChoiceStrings('FAST', 'NORMal'), doc='FAST increases the speed of sweep by almost a factor of 2 at a small cost in data quality')
        self.sweep_time = devChOption('SENSe{ch}:SWEep:TIME', str_type=float, min=0, max=86400.)
        self.sweep_type = devChOption('SENSe{ch}:SWEep:TYPE', choices=ChoiceStrings('LINear', 'LOGarithmic', 'POWer', 'CW', 'SEGMent', 'PHASe'))
        self.x_axis = devChOption(getstr='SENSe{ch}:X?', raw=True, str_type=decode_float64, autoinit=False, doc='This gets the default x-axis for the channel (some channels can have multiple x-axis')
        self.calc_x_axis = devCalcOption(getstr='CALC{ch}:X?', raw=True, str_type=decode_float64, autoinit=False, doc='Get this x-axis for a particular trace.')
        self.calc_fdata = devCalcOption(getstr='CALC{ch}:DATA? FDATA', raw=True, str_type=decode_float64, autoinit=False, trig=True)
        # the f vs s. s is complex data, includes error terms but not equation editor (Except for math?)
        #   the f adds equation editor, trace math, {gating, phase corr (elect delay, offset, port extension), mag offset}, formating and smoothing
        self.calc_sdata = devCalcOption(getstr='CALC{ch}:DATA? SDATA', raw=True, str_type=decode_complex128, autoinit=False, trig=True)
        self.calc_fmem = devCalcOption(getstr='CALC{ch}:DATA? FMEM', raw=True, str_type=decode_float64, autoinit=False)
        self.calc_smem = devCalcOption(getstr='CALC{ch}:DATA? SMEM', raw=True, str_type=decode_complex128, autoinit=False)
        self.current_mkr = MemoryDevice(1, min=1, max=10)
        def devMkrOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(mkr=self.current_mkr)
            app = kwarg.pop('options_apply', ['ch', 'trace', 'mkr'])
            kwarg.update(options=options, options_apply=app)
            return devCalcOption(*arg, **kwarg)
        def devMkrEnOption(*arg, **kwarg):
            # This will check if the marker is currently enabled.
            options = kwarg.pop('options', {}).copy()
            options.update(_marker_enabled=self.marker_en)
            options_lim = kwarg.pop('options_lim', {}).copy()
            options_lim.update(_marker_enabled=[True])
            kwarg.update(options=options, options_lim=options_lim)
            return devMkrOption(*arg, **kwarg)
        self.marker_en = devMkrOption('CALC{ch}:MARKer{mkr}', str_type=bool, autoinit=5)
        marker_funcs = ChoiceStrings('MAXimum', 'MINimum', 'RPEak', 'LPEak', 'NPEak', 'TARGet', 'LTARget', 'RTARget', 'COMPression')
        self.marker_trac_func = devMkrEnOption('CALC{ch}:MARKer{mkr}:FUNCtion', choices=marker_funcs)
        # This is set only
        self.marker_exec = devMkrOption('CALC{ch}:MARKer{mkr}:FUNCTION:EXECute', choices=marker_funcs, autoget=False)
        self.marker_target = devMkrEnOption('CALC{ch}:MARKer{mkr}:TARGet', str_type=float)
        marker_format = ChoiceStrings('DEFault', 'MLINear', 'MLOGarithmic', 'IMPedance', 'ADMittance', 'PHASe', 'IMAGinary', 'REAL',
                                      'POLar', 'GDELay', 'LINPhase', 'LOGPhase', 'KELVin', 'FAHRenheit', 'CELSius')
        self.marker_format = devMkrEnOption('CALC{ch}:MARKer{mkr}:FORMat', choices=marker_format)
        self.marker_trac_en = devMkrEnOption('CALC{ch}:MARKer{mkr}:FUNCtion:TRACking', str_type=bool)
        self.marker_discrete_en = devMkrEnOption('CALC{ch}:MARKer{mkr}:DISCrete', str_type=bool)
        self.marker_x = devMkrEnOption('CALC{ch}:MARKer{mkr}:X', str_type=float, trig=True)
        self.marker_y = devMkrEnOption('CALC{ch}:MARKer{mkr}:Y', str_type=decode_float64, multi=['val1', 'val2'], graph=[0,1], trig=True)
        self.power_en = scpiDevice('OUTPut', str_type=bool)
        self.power_couple = devChOption(':SOURce{ch}:POWer:COUPle', str_type=bool)
        self.power_slope = devChOption(':SOURce{ch}:POWer:SLOPe', str_type=float, min=-2, max=2)
        self.power_slope_en = devChOption(':SOURce{ch}:POWer:SLOPe:STATe', str_type=bool)
        # for max min power, ask source:power? max and source:power? min
        self.power_dbm_port1 = devChOption(':SOURce{ch}:POWer1', str_type=float)
        self.power_dbm_port2 = devChOption(':SOURce{ch}:POWer2', str_type=float)
        self.power_mode_port1 = devChOption(':SOURce{ch}:POWer1:MODE', choices=ChoiceStrings('AUTO', 'ON', 'OFF'))
        self.power_mode_port2 = devChOption(':SOURce{ch}:POWer2:MODE', choices=ChoiceStrings('AUTO', 'ON', 'OFF'))
        self.remote_cwd = scpiDevice('MMEMory:CDIRectory', str_type=quoted_string(),
                                     doc=r""""""
                                          instrument default is C:/Program Files/Agilent/Network Analyzer/Documents
                                          You can use / (if you are using \, make sure to use raw string r"""" or
                                          double them \\)
                                          """""")
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

register_usb_name('PNA network analyser', 0x0957, 0x0118)

# status byte stuff
# There is a bunch of register groups:
#  :status:operation     # 8(256)=averaging, 9(512)=user, 10(1024)=device
#  :status:operation:device  # contains sweep complete 4(16)
#  :status:operation:averaging1 # handles 1 summary of aver2-42(bit0) and traces 1-14 (bit 1:14)
#  :                          2 # handles 1 summary of aver3-42(bit0) and traces 15-28 (bit 1:14)
#  :status:questionable # 9 (512)=inieg, 10(1024)=limit, 11(2048)=define
#  :status:questionable:integrity
#  :status:questionable:limit1
#   ...
#
#  sweep complete and opc give the same information. Note that the status event latches
#   need to be cleared everywhere in order to be reset (STATus:OPERation:AVERaging1, STATus:OPERation:AVERaging2,
#   STATus:OPERation for and average of trace 15-28)
#  Note that average:cond stays True as long as the average count as been reached
#  If average is not enabled, the condition is never set to true
#
# For each group there is
#       :CONDition?   to query instant state
#       [:EVENt]?     To query and reset latch state
#       :NTRansition  To set/query the negative transition latching enable bit flag
#       :PTRansition  To set/query the positive transition latching enable bit flag
#       :ENABle       To set/query the latch to the next level bit flag
#  bit flag can be entered in hex as #Hfff or #hff
#                             oct as #O777 or #o777
#                             bin as #B111 or #b111
#  The connection between condition (instantenous) and event (latch) depends
#  on NTR and PTR. The connection between event (latch) and next level in
#  status hierarchy depends on ENABLE
#
# There are also IEEE status and event groups
# For event: contains *OPC bit, error reports
#       *ESR?    To read and reset the event register (latch)
#       *ESE     To set/query the bit flag that toggles bit 5 of IEEE status
# For IEEE status: contains :operation (bit 7), :questionable (bit 3)
#                           event (bit 5), error (bit 2), message available (bit 4)
#                           Request Service =RQS (bit 6) also MSS (master summary) which
#                                     is instantenous RQS. RQS is latched
#                           Not that first bit is bit 0
# To read error (bit 2): v.ask(':system:error?')
#   that command is ok even without errors
# Message available (bit 4) is 1 after a write be before a read if there was
# a question (?) in the write (i.e. something is waiting to be read)
#
#       the RQS (but not MSS) bit is read and reset by serial poll
#        *STB?   To read (not reset) the IEEE status byte, bit 6 is read as MSS not RQS
#        *SRE    To set/query the bit flag that controls the RQS bit
#                      RQS (bit6) is supposed to be ignored.
# *CLS   is to clear all event registers and empty the error queue.
#
# With both GPIB and USB interface activated. They both have their own status registers
# for STB to OPERATION ...
# They also have their own error queues and most other settings (active measurement for channel,
#   data format) seem to also be independent on the 2 interfaces


#######################################################
##    Agilent ENA network analyzer
#######################################################

#@register_instrument('Agilent Technologies', 'E5061B', 'A.02.09')
@register_instrument('Agilent Technologies', 'E5061B', usb_vendor_product=[0x0957, 0x1309], alias='E5061B ENA')
class agilent_ENA(agilent_PNAL):
    """"""
    To use this instrument, the most useful device is probably:
        fetch, readval  : Note that for the ENA the traces must be the trace number (cannot be a string)
    Some commands are available:
        abort
        reset_trig: to return to continuous internal trig (use this after readval, will restart
                    the automatic refresh on the instrument display)
        restart_averaging
        phase_unwrap, phase_wrap, phase_flatten
    Other useful devices:
        channel_list
        current_channel
        select_trace
        freq_start, freq_stop, freq_cw
        power_en
        power_dbm_port1, power_dbm_port2
        marker_x, marker_y
        cont_trigger
        trig_source
    method:
        load_segment

    Note that almost all devices/commands require a channel.
    It can be specified with the ch option or will use the last specified
    one if left to the default.
    A lot of other commands require a selected trace (per channel)
    The active one can be selected with the trace option or select_trace, select_traceN
    If unspecified, the last one is used.
    """"""
    def init(self, full=False):
        self.write(':format:data REAL')
        self.write(':format:border swap')
        self.reset_trig()
        # skip agilent_PNAL, go directly to its parent.
        super(agilent_PNAL, self).init(full=full)
    def reset_trig(self):
        self.trig_source.set('INTernal')
        self.cont_trigger.set(True)
    @locked_calling
    def _async_trig(self):
        self.cont_trigger.set(False)
        # we bypass the agilent_PNAL _async_trig (our parent) and go to its parent
        super(agilent_PNAL, self)._async_trig()
    def _async_detect(self, max_time=.5): # 0.5 s max by default
        # we bypass the agilent_PNAL _async_detect (our parent) and go to its parent
        return super(agilent_PNAL, self)._async_detect(max_time)
    def _async_trigger_helper(self):
        self.trig_source.set('BUS')
        self.average_triggering_en.set(True)
        self.write(':TRIGger:POINt OFF')
        self.initiate()
        self.write(':TRIGger:SINGle;*OPC')
        #self.trig_source.set('INTernal')
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # These all refer to the current channel
        # calib_en depends on trace
        if options.has_key('ch'):
            self.current_channel.set(options['ch'])
        if options.has_key('trace'):
            self.select_trace.set(options['trace'])
        if options.has_key('mkr'):
            self.current_mkr.set(options['mkr'])
        extra = []
        if dev_obj in [self.marker_x, self.marker_y]:
            # Cannot get cache of marker_x while getting marker_x (end up getting an old cache)
            if dev_obj == self.marker_x:
                mxy = 'marker_y'
            else:
                mxy = 'marker_x'
            extra = self._conf_helper('current_mkr', 'marker_trac_func', 'trace_format', 'marker_trac_en', mxy,
                              'marker_discrete_en', 'marker_target')
        cook = False
        if dev_obj in [self.readval, self.fetch]:
            cook = options.get('cook', False)
            traces_opt = self._fetch_traces_helper(options.get('traces'))
            traces = []
            fmts = []
            for t in traces_opt:
                name, param = self.select_trace.choices[t]
                traces.append(name+'='+param)
                if cook:
                    fmts.append(self.trace_format.get())
        else:
            traces_opt = self._fetch_traces_helper(None) # get all traces
            name, param = self.select_trace.choices[self.select_trace.getcache()]
            traces = name+'='+param
        extra += ['selected_trace=%r'%traces]
        if cook:
            extra += ['trace_format=%r'%fmts]
        if self._is_E5071C:
            base = self._conf_helper('current_channel',
                                 'calib_en', 'freq_cw', 'freq_start', 'freq_stop', 'ext_ref',
                                 'power_en', 'power_couple',
                                 'power_slope', 'power_slope_en',
                                 'power_dbm_port1', 'power_dbm_port2',
                                 'power_dbm_port3', 'power_dbm_port4',
                                 'npoints', 'sweep_gen',
                                 'sweep_time', 'sweep_type',
                                 'bandwidth', 'bandwidth_auto_en', 'bandwidth_auto_limit', 'cont_trigger',
                                 'average_count', 'average_en', options)
        else:
            base = self._conf_helper('current_channel',
                                 'calib_en', 'freq_cw', 'freq_start', 'freq_stop', 'ext_ref',
                                 'power_en', 'power_couple',
                                 'power_slope', 'power_slope_en',
                                 'power_dbm_port1', 'power_dbm_port2',
                                 'npoints',
                                 'sweep_time', 'sweep_type',
                                 'bandwidth', 'bandwidth_auto_en', 'bandwidth_auto_limit', 'cont_trigger',
                                 'average_count', 'average_en', options)
        return extra+base
    def _fetch_traces_helper(self, traces, cal=False):
        if cal:
            raise NotImplementedError('cal=True is not implemented for ena1')
        count = self.select_trace_count.getcache()
        trace_orig = self.select_trace.getcache()
        all_tr = range(1,count+1)
        # First create the necessary entries, so that select_trace works
        self.select_trace.choices = {i:('%i'%i, 'empty') for i in all_tr}
        # Now fill them properly (trace_meas, uses select_trace and needs to access them)
        self.select_trace.choices = {i:('%i'%i, self.trace_meas.get(trace=i)) for i in all_tr}
        self.select_trace.set(trace_orig)
        if isinstance(traces, (tuple, list)):
            traces = traces[:] # make a copy so it can be modified without affecting caller. I don't think this is necessary anymore but keep it anyway.
        elif traces is not None:
            traces = [traces]
        else: # traces is None
            traces = all_tr
        return traces
    @locked_calling
    def initiate(self):
        """""" Enables the current channel for triggering purposes """"""
        ch = self.current_channel.getcache()
        self.write('INITiate%i'%ch)
    def load_segment(self, filename):
        """""" To load from the instrument disk a file describing the
            segments to use.
            Make sure to select the table shape (start/stop or center/span,
            power or no power, etc...) to be the same as the content of the file
            before loading, otherwise the load will fail or be wrong.
            Ex:
                ena1.load_segment('d:/Segments/SEGM100MHz.csv')
            You can use either forward or backslash (but be careful with
            backslash, might need r'd:\\test.csv' or double them 'd:\\\\test.csv')
        """"""
        self.write('MMEMory:LOAD:SEGMent ""%s""'%filename)
    def _create_devs(self):
        idn = self.idn()
        self._is_E5071C = 'E5071C' in idn.split(',')[1]
        self.create_measurement = None
        self.delete_measurement = None
        self.installed_options = scpiDevice(getstr='*OPT?', str_type=str)
        self.current_channel = MemoryDevice(1, min=1, max=160)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        # Either: CALCulate{ch}:PARameter{tr}:SELect (write only)
        #         CALCulate{ch}:PARemeter:COUNt
        # select_trace is needed by PNAL:fetch so we cannot rename it to current_trace.
        self.select_trace = MemoryDevice(1, min=1, max=16)
        #self.select_trace = devChOption('CALCulate{ch}:PARameter{val}:SELect', autoinit=8, autoget=False, str_type=int, min=1, max=16)
        self.select_trace_count = devChOption('CALCulate{ch}:PARameter:COUNt', str_type=int)
        def devCalcOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(trace=self.select_trace)
            app = kwarg.pop('options_apply', ['ch', 'trace'])
            kwarg.update(options=options, options_apply=app)
            return devChOption(*arg, **kwarg)
        # select_trace needs to be set for most of the calc commands
        self.trace_meas = devCalcOption('CALCulate{ch}:PARameter{trace}:DEFine')
        data_format = ChoiceStrings('MLINear', 'MLOGarithmic', 'PHASe', 'UPHase', 'PPHase', 'IMAGinary', 'REAL', 'POLar', 'PLINear', 'PLOGarithmic', 'SMITh', 'SADMittance', 'SLINear', 'SCOMplex', 'SLOGarithmic', 'SWR', 'GDELay')
        self.trace_format = devCalcOption('CALCulate{ch}:FORMat', choices=data_format) # needed when marker_format is 'DEF'
        self.calib_en = devChOption('SENSe{ch}:CORRection:STATe', str_type=bool)
        self.cont_trigger = devChOption('INITiate{ch}:CONTinuous', str_type=bool)
        self.bandwidth = devChOption('SENSe{ch}:BANDwidth', str_type=float, setget=True) # can obtain min max
        self.bandwidth_auto_en = devChOption('SENSe{ch}:BWAuto', str_type=bool)
        self.bandwidth_auto_limit = devChOption('SENSe{ch}:BWAuto:LIMit', str_type=float, setget=True)
        self.average_count = devChOption('SENSe{ch}:AVERage:COUNt', str_type=int)
        self.average_en = devChOption('SENSe{ch}:AVERage', str_type=bool)
        self.average_triggering_en = devChOption('TRIGger:AVERage', str_type=bool)
        self.freq_start = devChOption('SENSe{ch}:FREQuency:STARt', str_type=float, min=5, max=3e9)
        self.freq_stop = devChOption('SENSe{ch}:FREQuency:STOP', str_type=float, min=5, max=3e9)
        self.freq_cw= devChOption('SENSe{ch}:FREQuency:CW', str_type=float, min=5, max=3e9)
        self.ext_ref = scpiDevice(getstr='SENSe:ROSCillator:SOURce?', str_type=str)
        self.npoints = devChOption('SENSe{ch}:SWEep:POINts', str_type=int, min=2, max=20001)
        if self._is_E5071C:
            self.sweep_gen = devChOption('SENSe{ch}:SWEep:GENeration', choices=ChoiceStrings('STEPped', 'ANALog', 'FSTepped', 'FANalog'))
        self.sweep_time = devChOption('SENSe{ch}:SWEep:TIME', str_type=float, min=0, max=86400.)
        self.sweep_type = devChOption('SENSe{ch}:SWEep:TYPE', choices=ChoiceStrings('LINear', 'LOGarithmic', 'POWer', 'SEGMent'))
        self.calc_x_axis = devCalcOption(getstr='CALC{ch}:TRACe{trace}:DATA:XAXIs?', raw=True, str_type=decode_float64, autoinit=False, doc='Get this x-axis for a particular trace.')
        self.calc_fdata = devCalcOption(getstr='CALC{ch}:TRACe{trace}:DATA:FDATa?', raw=True, str_type=decode_float64, autoinit=False, trig=True)
        # the f vs s. s is complex data, includes error terms but not equation editor (Except for math?)
        #   the f adds equation editor, trace math, {gating, phase corr (elect delay, offset, port extension), mag offset}, formating and smoothing
        self.calc_sdata = devCalcOption(getstr='CALC{ch}:TRACe{trace}:DATA:SDATa?', raw=True, str_type=decode_complex128, autoinit=False, trig=True)
        self.calc_fmem = devCalcOption(getstr='CALC{ch}:TRACe{trace}:DATA:FMEMory?', raw=True, str_type=decode_float64, autoinit=False)
        self.calc_smem = devCalcOption(getstr='CALC{ch}:TRACe{trace}:DATA:SMEMory?', raw=True, str_type=decode_complex128, autoinit=False)
        self.current_mkr = MemoryDevice(1, min=1, max=10)
        def devMkrOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(mkr=self.current_mkr)
            app = kwarg.pop('options_apply', ['ch', 'trace', 'mkr'])
            kwarg.update(options=options, options_apply=app)
            return devCalcOption(*arg, **kwarg)
        def devMkrEnOption(*arg, **kwarg):
            # This will check if the marker is currently enabled.
            options = kwarg.pop('options', {}).copy()
            options.update(_marker_enabled=self.marker_en)
            options_lim = kwarg.pop('options_lim', {}).copy()
            options_lim.update(_marker_enabled=[True])
            kwarg.update(options=options, options_lim=options_lim)
            return devMkrOption(*arg, **kwarg)
        self.marker_en = devMkrOption('CALC{ch}:TRACe{trace}:MARKer{mkr}', str_type=bool, autoinit=5)
        marker_funcs = ChoiceStrings('MAXimum', 'MINimum', 'PEAK', 'RPEak', 'LPEak', 'TARGet', 'LTARget', 'RTARget')
        self.marker_trac_func = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:FUNCtion', 'CALC{ch}:MARKer{mkr}:FUNCtion:TYPE?', choices=marker_funcs)
        # This is set only
        self.marker_exec = devMkrOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:FUNCTION:EXECute', choices=marker_funcs, autoget=False)
        self.marker_target = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:FUNCtion:TARGet', str_type=float)
        self.marker_trac_en = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:FUNCtion:TRACking', str_type=bool)
        self.marker_discrete_en = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:DISCrete', str_type=bool)
        self.marker_x = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:X', str_type=float, trig=True)
        self.marker_y = devMkrEnOption('CALC{ch}:TRACe{trace}:MARKer{mkr}:Y', str_type=decode_float64, multi=['val1', 'val2'], graph=[0,1], trig=True)
        self.power_en = scpiDevice('OUTPut', str_type=bool)
        self.power_couple = devChOption(':SOURce{ch}:POWer:PORT:COUPle', str_type=bool)
        self.power_slope = devChOption(':SOURce{ch}:POWer:SLOPe', str_type=float, min=-2, max=2)
        self.power_slope_en = devChOption(':SOURce{ch}:POWer:SLOPe:STATe', str_type=bool)
        # for max min power, ask source:power? max and source:power? min
        self.power_dbm_port1 = devChOption(':SOURce{ch}:POWer:PORT1', str_type=float)
        self.power_dbm_port2 = devChOption(':SOURce{ch}:POWer:PORT2', str_type=float)
        if self._is_E5071C:
            self.power_dbm_port3 = devChOption(':SOURce{ch}:POWer:PORT3', str_type=float)
            self.power_dbm_port4 = devChOption(':SOURce{ch}:POWer:PORT4', str_type=float)
        self.trig_source = scpiDevice(':TRIGger:SOURce',
                                      choices=ChoiceStrings('INTernal', 'EXTernal', 'MANual', 'BUS'))
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        # This needs to be last to complete creation
        super(agilent_PNAL, self)._create_devs()

#######################################################
##    Agilent FieldFox network analyzer
#######################################################

#@register_instrument('Agilent Technologies', 'N9916A', 'A.07.29,2014-02-20.14:09')
@register_instrument('Agilent Technologies', 'N9916A', alias='N9916A FieldFox')
class agilent_FieldFox(agilent_PNAL):
    """"""
    The output is turned off when the device is in hold state (set cont_trig off to go in hold state).
    The instrument does not output sine waves (they are square waves, especially at lower frequencies were
    it is high passed square waves.)
    To use this instrument, the most useful device are probably:
        fetch, readval
    Some commands are available:
        abort
        reset_trig: to return to continuous internal trig (use this after readval, will restart
                    the automatic refresh on the instrument display)
        restart_averaging
        phase_unwrap, phase_wrap, phase_flatten
    Other useful devices:
        channel_list
        select_trace
        freq_start, freq_stop
        power_dbm_port1
        marker_x, marker_y
        cont_trigger
        trig_source
        snap_png
        bias_en, bias_volt, bias_src_state

    A lot of other commands require a selected trace (per channel)
    The active one can be selected with the trace option or select_trace
    If unspecified, the last one is used.
    """"""
    def init(self, full=False):
        self.write(':format REAL,64')
        self.write(':format:border NORMal')
        self.reset_trig()
        # skip agilent_PNAL, go directly to its parent.
        super(agilent_PNAL, self).init(full=full)
    def reset_trig(self):
        #self.trig_source.set('INTernal')
        self.cont_trigger.set(True)
    @locked_calling
    def _async_trig(self):
        # similar to PNAL version
        # Here we will assume that _async_trigger_helper ('INITiate;*OPC')
        # does a single iteration of an average.
        # We will just count the correct number of repeats to do (_async_detect)
        reps = 1
        if self.average_mode.get() in self.average_mode.choices[['sweep']]:
            reps = self.average_count.get()
            if reps>1:
                self.restart_averaging()
        else:
            reps = 1
        self._trig_reps_total = reps
        self._trig_reps_current = 0
        self.cont_trigger.set(False)
        super(agilent_PNAL, self)._async_trig()
    #def _async_detect(self, max_time=.5): # 0.5 s max by default
    #    return super(agilent_PNAL, self)._async_detect(max_time)
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        # These all refer to the current channel
        # calib_en depends on trace
        if options.has_key('trace'):
            self.select_trace.set(options['trace'])
        if options.has_key('mkr'):
            self.current_mkr.set(options['mkr'])
        extra = []
        if dev_obj in [self.marker_x, self.marker_y]:
            # Cannot get cache of marker_x while getting marker_x (end up getting an old cache)
            if dev_obj == self.marker_x:
                mxy = 'marker_y'
            else:
                mxy = 'marker_x'
            extra = self._conf_helper('current_mkr', 'marker_en', mxy,
                              'marker_data_mem_sel', 'marker_format', 'trace_format')
        cook = False
        if dev_obj in [self.readval, self.fetch]:
            cook = options.get('cook', False)
            traces_opt = self._fetch_traces_helper(options.get('traces'))
            traces = []
            fmts = []
            for t in traces_opt:
                name, param = self.select_trace.choices[t]
                traces.append(""%s=%s""%(name,param))
                if cook:
                    fmts.append(self.trace_format.get())
        else:
            traces_opt = self._fetch_traces_helper(None) # get all traces
            name, param = self.select_trace.choices[self.select_trace.getcache()]
            traces = ""%s=%s""%(name,param)
        extra += ['selected_trace=%r'%traces]
        if cook:
            extra += ['trace_format=%r'%fmts]
        base = self._conf_helper('installed_options', 'current_mode',
                                 'bias_en', 'bias_volt', 'bias_src_state', 'bias_volt_meas', 'bias_curr_meas',
                                 'power_mode_port1', 'power_dbm_port1',
                                 'calib_en', 'freq_start', 'freq_stop', 'ext_ref',
                                 'npoints', 'sweep_time',
                                 'bandwidth', 'cont_trigger', 'trig_source',
                                 'average_count', 'average_mode', options)
        return extra+base
    def restart_averaging(self):
        command = 'SENSe:AVERage:CLEar'
        self.write(command)
    def _channel_list_getdev(self):
        """""" returns the list of available channels """"""
        #return range(1, self.select_trace_count.getcache() +1)
        lst = range(1, self.select_trace_count.get() +1)
        return {k:self.trace_meas.get(trace=k) for k in lst}
    def get_file(self, remote_file, local_file=None):
        """"""
            Obtain the file remote_file from the analyzer and save it
            on this computer as local_file if given.
        """"""
        s = self.ask('MMEMory:DATA? ""%s""'%remote_file, raw=True)
        s = _decode_block_base(s)
        if local_file:
            with open(local_file, 'wb') as f:
                f.write(s)
        else:
            return s
    def _snap_png_getdev(self):
        tmpfile_d = '[INTERNAL]:'
        tmpfile_f = 'TempScreenGrab.png'
        tmpfile_p = tmpfile_d + '\\' + tmpfile_f
        prevdir = self.ask('MMEMory:CDIRectory?')
        self.write('MMEMory:CDIRectory ""%s""'%tmpfile_d)
        self.write('MMEMory:STORe:IMAGe ""%s""'%tmpfile_f)
        self.write('MMEMory:CDIRectory %s'%prevdir)
        ret = self.get_file(tmpfile_p)
        self.write('MMEMory:DELete ""%s""'%tmpfile_p)
        return ret
    def _bias_en_setdev(self, val):
        if val:
            self.write('SYSTem:VVS:ENABle ON')
        else:
            self.write('SYSTem:VVS:ENABle OFF')
        #self._bias_en.set(val)
    def _bias_en_getdev(self):
        state = self.bias_src_state.get()
        if state.lower() == 'on':
            return True
        return False # for OFF and Tripped
    def _fetch_getdev(self, traces=None, unit='default', mem=False, xaxis=True):
        """"""
           options available: traces, unit, mem and xaxis
            -traces: can be a single value or a list of values.
                     The values are strings representing the trace or the trace number
            -unit:   can be 'default' (real, imag)
                       'db_deg' (db, deg) , where phase is unwrapped
                       'cmplx'  (complexe number), Note that this cannot be written to file
            -mem:    when True, selects the memory trace instead of the active one.
            -xaxis:  when True(default), the first column of data is the xaxis
        """"""
        return super(agilent_FieldFox,self)._fetch_getdev(ch=None, traces=traces, unit=unit, mem=mem, xaxis=xaxis)
    def _create_devs(self):
        # Similar commands to ENA or PNAL but without channels
        self.installed_options = scpiDevice(getstr='*OPT?', str_type=quoted_string())
        self.available_modes = scpiDevice(getstr='INSTrument:CATalog?', str_type=quoted_list(sep='"",""'))
        # INSTRUMENT only accepts the upper version CAT and NA (not cat or na)
        if self.ask('INSTrument?') != '""NA""':
            raise ValueError, ""This instruments only works if the FieldFox is in NA (network analyzer) mode. Not it SA or CAT mode.""
        self.current_mode = scpiDevice('INSTrument', choices=['CAT', 'NA'], str_type=quoted_string())
        self.ext_ref = scpiDevice(getstr='SENSe:ROSCillator:SOURce?', str_type=str)
        self.cont_trigger = scpiDevice('INITiate:CONTinuous', str_type=bool)
       # Here we only handle the NA mode
        # DC bias (option 309)
        #self._bias_en = scpiDevice('SYSTem:VVS:ENABle', str_type=bool, autoget=False)
        self._devwrap('bias_en')
        self.bias_volt = scpiDevice('SYSTem:VVS:VOLTage', str_type=float, min=1., max=32., setget=True)
        self.bias_volt_meas = scpiDevice(getstr='SYSTem:VVS:MVOLtage?', str_type=float)
        self.bias_curr_meas = scpiDevice(getstr='SYSTem:VVS:CURRent?', str_type=float)
        self.bias_src_state = scpiDevice(getstr='SYSTem:VVS?', doc=""can be on, off or tripped. To clear toggle the enable."")
        # end of Bias
        #self.power_en = scpiDevice('SOURce:ENABle', str_type=bool)
        self.power_dbm_port1 = scpiDevice(':SOURce:POWer', str_type=float, min=-45., max=3., setget=True, doc=""""""
                       Note that the power set by this device is not leveled. The instrument can
                       produce warnings of unlevel for high power/high frequency.
                       If you want a leveled high power, use power_mode_port1 device with 'HIGH' instead"""""")
        self.power_mode_port1 = scpiDevice('SOURce:POWer:ALC', choices=ChoiceStrings('HIGH', 'LOW', 'MAN'))
        #tmpfile = r'""[INTERNAL]:\TempScreenGrab.png""'
        #self.snap_png = scpiDevice(getstr='MMEMory:STORe:IMAGe %s;:MMEMory:DATA? %s;:MMEMory:DELete %s'%(tmpfile,tmpfile,tmpfile),
        #                           raw=True, str_type=_decode_block_base, autoinit=False)
        self._devwrap('snap_png', autoinit=False)
        self.snap_png._format['bin']='.png'
        self.freq_start = scpiDevice('SENSe:FREQuency:STARt', str_type=float, min=30e3, max=14e9)
        self.freq_stop = scpiDevice('SENSe:FREQuency:STOP', str_type=float, min=30e3, max=14e9)
        self.freq_center = scpiDevice('SENSe:FREQuency:CENTer', str_type=float, min=30e3, max=14e9)
        self.freq_span = scpiDevice('SENSe:FREQuency:SPAN', str_type=float, min=0, max=14e9-30e3)
        self.x_axis = scpiDevice(getstr='SENSe:FREQuency:DATA?', raw=True, str_type=decode_float64, autoinit=False)
        self.calc_x_axis = self.x_axis # needed by fetch
        self.npoints = scpiDevice('SENSe:SWEep:POINts', str_type=int, min=2, max=10001)
        self.sweep_time = scpiDevice('SENSe:SWEep:TIME', str_type=float, min=0, max=100., doc='This changes the minimum sweep time, it can be longer.')
        self.bandwidth = scpiDevice('SENSe:BWID', str_type=float, min=10., max=30e3, setget=True, doc=""only certain values are available"")
        self.average_count = scpiDevice('SENSe:AVERage:COUNt', str_type=int, min=1, max=100, doc='count of 1 disables averaging')
        self.average_mode = scpiDevice('SENSe:AVERage:MODE', choices=ChoiceStrings('POINt', 'SWEep'))
        self.calib_en = scpiDevice('SENSe:CORRection:STATe', str_type=bool)
        # needed by PNAL fetch
        class sweep_type_C(object):
            def getcache(self):
                return 'linear'
            choices = ChoiceStrings('LINear', 'LOGarithmic', 'POWer', 'CW', 'SEGMent', 'PHASe')
        self.sweep_type = sweep_type_C()
        self.select_trace_count = scpiDevice('CALCulate:PARameter:COUNt', str_type=int, min=1, max=4)
        # select_trace needs to be set for most of the calc commands
        self._devwrap('channel_list', autoinit=8)
        select_trace_choices = ChoiceDev(self.channel_list, sub_type=int)
        select_trace_choices2 = ChoiceDevDep(self.select_trace_count, {1:[1], 2:[1,2], 3:[1,2,3], 4:[1,2,3,4]})
        # select_trace is needed by PNAL:fetch so we cannot rename it to current_trace.
        self.select_trace = MemoryDevice(1, choices=select_trace_choices)
        self.select_trace1 = scpiDevice('CALCulate:PARameter{val}:SELect', autoinit=8, autoget=False,
                                        choices=select_trace_choices, doc=""""""
                Select the trace using the trace number (1-4)."""""")
        self.select_trace2 = scpiDevice('CALCulate:PARameter{val}:SELect', autoinit=8, autoget=False,
                                        choices=select_trace_choices2, doc=""""""
                Select the trace using the trace number (1-4)."""""")
        #self.select_trace3 = scpiDevice('CALCulate:PARameter{val}:SELect', autoinit=8, str_type=int, min=1, max=4,  autoget=False,
        #                                 doc=""""""Select the trace using the trace number (1-4)."""""")
        #self.select_trace4 = scpiDevice('CALCulate:PARameter{val}:SELect', autoinit=False, autoget=False, get_cached_init=1,
        #                                choices=select_trace_choices2, str_type=int)
        def devCalcOption(*arg, **kwarg):
            extra='CALCulate:PARameter{trace}:SELect;:'
            if len(arg):
                arg = list(arg) # arg was a tuple
                arg[0] = extra+arg[0]
            if 'getstr' in kwarg:
                gs = extra + kwarg['getstr']
                kwarg.update(getstr=gs)
            options = kwarg.pop('options', {}).copy()
            options.update(trace=self.select_trace)
            app = kwarg.pop('options_apply', ['trace'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)

        self.edelay_time = devCalcOption('CALCulate:CORRection:EDELay:TIME', str_type=float, doc='delay in seconds')
        self.edelay_rel_vel = scpiDevice('SENSe:CORRection:RVELocity:COAX', str_type=float, min=0, max=1, doc='.66 = polyethylene dielectric, .7= PTFE dielectric, 1.0=Air')
        self.edelay_length_medium = scpiDevice('SENSe:CORRection:MEDium', choices=ChoiceStrings('COAX', 'WAVeguide'))

        # select_trace needs to be set for most of the calc commands
        #calc:par:TNUMber and WNUMber don't exist for our PNAL
        # since select_trace handles the number here we make it only a get
        # but MNUMber could also be a set.
        #self.select_trace_N = devCalcOption(getstr='CALCulate{ch}:PARameter:MNUMber?', str_type=int, doc='The number is from the Tr1 annotation next to the parameter nane on the PNA screen')
        self.calc_fdata = devCalcOption(getstr='CALCulate:DATA:FDATa?', raw=True, str_type=decode_float64, autoinit=False, trig=True)
        # the f vs s. s is complex data, includes error terms but not equation editor (Except for math?)
        #   the f adds equation editor, trace math, {gating, phase corr (elect delay, offset, port extension), mag offset}, formating and smoothing
        self.calc_sdata = devCalcOption(getstr='CALCulate:DATA:SDATa?', raw=True, str_type=decode_complex128, autoinit=False, trig=True)
        self.calc_fmem = devCalcOption(getstr='CALCulate:DATA:FMEM?', raw=True, str_type=decode_float64, autoinit=False)
        self.calc_smem = devCalcOption(getstr='CALCulate:DATA:SMEM?', raw=True, str_type=decode_complex128, autoinit=False)
        self.current_mkr = MemoryDevice(1, min=1, max=6)
        self.marker_coupling_en = devCalcOption('CALC:MARKer:COUPled', str_type=bool)
        def devMkrOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(mkr=self.current_mkr)
            app = kwarg.pop('options_apply', ['trace', 'mkr'])
            kwarg.update(options=options, options_apply=app)
            return devCalcOption(*arg, **kwarg)
        maker_en_choices = ChoiceStrings('OFF', 'NORM', 'DELT')
        self.marker_en = devMkrOption('CALC:MARKer{mkr}', choices=maker_en_choices, autoinit=5)
        def devMkrEnOption(*arg, **kwarg):
            # This will check if the marker is currently enabled.
            options = kwarg.pop('options', {}).copy()
            options.update(_marker_enabled=self.marker_en)
            options_lim = kwarg.pop('options_lim', {}).copy()
            options_lim.update(_marker_enabled=maker_en_choices[1:])
            kwarg.update(options=options, options_lim=options_lim)
            return devMkrOption(*arg, **kwarg)
        data_format = ChoiceStrings('MLOGarithmic', 'MLINear', 'SWR', 'PHASe', 'UPHase', 'SMITh', 'POLar', 'GDELay')
        self.trace_format = devCalcOption('CALCulate:FORMat', choices=data_format) # needed when marker_format is 'DEF'
        marker_format = ChoiceStrings('DEF', 'IMPedance', 'PHASe', 'IMAGinary', 'REAL', 'MAGPhase', 'ZMAGnitude')
        self.marker_format = devCalcOption('CALC:MARKer:FORMat', choices=marker_format, doc=""The format applies to all marker from one trace"")
        self.marker_x = devMkrOption('CALC:MARKer{mkr}:X', str_type=float, trig=True)
        self.marker_y = devMkrEnOption(getstr='CALC:MARKer{mkr}:Y?', str_type=decode_float64, multi=['val1', 'val2'], graph=[0,1], trig=True)
        self.marker_data_mem_sel = devMkrOption('CALC:MARKer{mkr}:TRACe', choices=ChoiceIndex(['auto', 'data', 'mem']))
        # TODO smoothing affects marker data so does edelay ...

        self.create_measurement = None
        self.delete_measurement = None
        #self.trace_meas = devCalcOption('CALCulate:PARameter{trace}:DEFine',
        #                                choices=ChoiceStrings('S11', 'S12', 'S21', 'S22', 'A', 'B', 'R1', 'R2'))
        #self.trace_meas = scpiDevice('CALCulate:PARameter{trace}:DEFine', options=dict(trace=self.select_trace), options_lim=dict(trace=(1,4)),
        #                                choices=ChoiceStrings('S11', 'S12', 'S21', 'S22', 'A', 'B', 'R1', 'R2'))
        self.trace_meas = scpiDevice('CALCulate:PARameter{trace}:DEFine', options=dict(trace=1), options_lim=dict(trace=(1,4)),
                                        doc=""trace always defaults to 1 and does not change select_trace."",
                                        choices=ChoiceStrings('S11', 'S12', 'S21', 'S22', 'A', 'B', 'R1', 'R2'))
        self.trig_source = scpiDevice('TRIGger:SOURce', choices=ChoiceStrings('INTernal', 'EXTernal'))
        self._devwrap('fetch', autoinit=False, trig=True)
        self.readval = ReadvalDev(self.fetch)
        # This needs to be last to complete creation
        super(agilent_PNAL, self)._create_devs()


#######################################################
##    Agilent M8190A Arbitrary Waveform Generator
#######################################################

#@register_instrument('Agilent Technologies', 'M8190A', '5.0.14.0-2')
@register_instrument('Agilent Technologies', 'M8190A', alias='M8190A AWG')
class agilent_AWG(visaInstrumentAsync):
    """"""
    This is to control the M8190A Arbitrary Waveform Generator.
    It has 2 independent channels that can be coupled (for start/stop)
    and each channel can be with 12 bit @ 12 GS/s max of 2 GS or 14 bit @ 8 GS/s
    max of 1.5 GS.
    For the binary files:
     DAC values are signed. The data is in the most significant bits,
      so bits 15-2 in 14 bit mode and 15-4 in 12 bit mode (then bits 3 and 2 are
      don't care). Bit 1 is the sequence marker, bit 0 is the sample marker.
     Data needs to be in blocks (or vectors). Only the sequence marker of the first
     sample in a vector is used.
     The vector length is 48 samples in 14 bits mode and 64 in 12 bits mode.
     The smallest common multiple of 48 and 64 is 192.
     The minimum length is 5 vectors (240 samples in 14 bits, 320 for 12 bits)

    The voltage amplitude can be set with either volt_amplitude, volt_offset
    or volt_high, volt_low (volt_ampl is peak to peak amplitude)
    There is one sampling frequency for both channels.
    Many options depend on the channel.

    If something looks like it is not working, you might be creating errors so
    first check the get_error function return.
    """"""
    def init(self, full=False):
        self.write(':format:border swap')
        # initialize async stuff
        super(agilent_AWG, self).init(full=full)
        self._async_trigger_helper_string = '*OPC'
    def _async_trigger_helper(self):
        self.write(self._async_trigger_helper_string)
        #self._async_trigger_helper_string = '*OPC'
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        orig_ch = self.current_channel.getcache()
        ch_list = ['current_channel', 'freq_source', 'cont_trigger', 'gate_mode_en', 'output_en',
                                'delay_coarse', 'delay_fine', 'volt_ampl', 'volt_offset',
                                'sample_marker_volt_ampl', 'sample_marker_volt_offset',
                                'sync_marker_volt_ampl', 'sync_marker_volt_offset',
                                'dac_format', 'differential_offset', 'speed_mode',
                                'advance_mode', 'repeat_count', 'marker_en', 'segment_list']
        self.current_channel.set(1)
        ch1 = self._conf_helper(*ch_list)
        self.current_channel.set(2)
        ch2 = self._conf_helper(*ch_list)
        self.current_channel.set(orig_ch)
        return ch1+ch2+self._conf_helper('coupled_en', 'freq_sampling', 'freq_ext',
                                         'ref_source', 'ref_freq', options)
    def _create_devs(self):
        self.current_channel = MemoryDevice(1, min=1, max=2)
        self.coupled_en = scpiDevice(':INSTrument:COUPle:STATe', str_type=bool)
        self.freq_sampling = scpiDevice(':FREQuency:RASTer', str_type=float)
        self.freq_ext = scpiDevice(':FREQuency:RASTer:EXTernal', str_type=float)
        self.ref_source = scpiDevice(':ROSCillator:SOURce', choices=ChoiceStrings('AXI', 'EXTernal'))
        self.ref_freq = scpiDevice(':ROSCillator:FREQuency', str_type=float)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_channel)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        self.freq_source = devChOption(':FREQuency:RASTer:SOURce{ch}', choices=ChoiceStrings('INTernal', 'EXTernal'))
        self.cont_trigger = devChOption(':INITiate:CONTinuous{ch}', str_type=bool)
        self.gate_mode_en = devChOption(':INITiate:GATE{ch}', str_type=bool, doc=
            """"""
            When cont_trigger is False, selects between gate or trigger mode of triggering.
            Under gating mode, the segment repeating is started after the rising edge
            of the gating signal. When the falling edge is detected, repeat_count
            segments are produced and then stops.
            """""")
        #self.arming_mode = devChOption(':INITiate:CONTinuous{ch}:ENABle', choices=ChoiceStrings('SELF', 'ARMed'))
        self.output_en = devChOption(':OUTPut{ch}', str_type=bool)
        self.delay_coarse = devChOption(':ARM:CDELay{ch}', str_type=float, min=0, max=10e-9)
        self.delay_fine = devChOption(':ARM:DELay{ch}', str_type=float, min=0, max=150e-12, doc='max delay is 60e-12 between 2.5 and 6.25 GS/s and 30e-12 above 6.25 GS/s')
        self.volt_ampl = devChOption(':VOLTage{ch}', str_type=float, min=.35, max=0.7)
        self.volt_offset = devChOption(':VOLTage{ch}:OFFSet', str_type=float, min=-.02, max=0.02)
        self.volt_high = devChOption(':VOLTage{ch}:HIGH', str_type=float, min=.155, max=.37)
        self.volt_low = devChOption(':VOLTage{ch}:LOW', str_type=float, min=-0.37, max=0.155)
        self.sample_marker_volt_ampl = devChOption(':MARKer{ch}:SAMPle:VOLTage:AMPLitude', str_type=float, min=0., max=2.25)
        self.sample_marker_volt_offset = devChOption(':MARKer{ch}:SAMPle:VOLTage:OFFSet', str_type=float, min=-0.5, max=1.75)
        self.sample_marker_volt_high = devChOption(':MARKer{ch}:SAMPle:VOLTage:HIGH', str_type=float, min=0.5, max=1.75)
        self.sample_marker_volt_low = devChOption(':MARKer{ch}:SAMPle:VOLTage:LOW', str_type=float, min=-0.5, max=1.75)
        self.sync_marker_volt_ampl = devChOption(':MARKer{ch}:SYNC:VOLTage:AMPLitude', str_type=float, min=0., max=2.25)
        self.sync_marker_volt_offset = devChOption(':MARKer{ch}:SYNC:VOLTage:OFFSet', str_type=float, min=-0.5, max=1.75)
        self.sync_marker_volt_high = devChOption(':MARKer{ch}:SYNC:VOLTage:HIGH', str_type=float, min=0.5, max=1.75)
        self.sync_marker_volt_low = devChOption(':MARKer{ch}:SYNC:VOLTage:LOW', str_type=float, min=-0.5, max=1.75)
        self.dac_format = devChOption(':DAC:FORMat', choices=ChoiceStrings('RZ', 'DNRZ', 'NRZ', 'DOUBlet'), doc=
            """""" RZ:      Return to zero (DAC A, DAC B=0) (first half of time step, second half)
                NRZ:     Non return to zero (DAC A, DAC A)
                DNRZ:    double NRZ (DAC A, DAC B=A)
                Doublet: (DAC A, DAC B=-A)
            """""")
        self.differential_offset = devChOption(':OUTPut{ch}:DIOFfset', str_type=int, doc='An integer to fix DAC offset between direct and its complement output.')
        #self.func_mode = devChOption(':FUNCtion{ch}:MODE', choices=ChoiceStrings('ARBitrary', 'STSequence', 'STSCenario'))
        self.advance_mode = devChOption(':TRACE{ch}:ADVance', choices=ChoiceStrings('AUTO', 'CONDitional', 'REPeat', 'SINGle'), doc=
            """"""
            This setting only works for cont_trigger False and gate_mode_en False
            AUTO:   Every trig event produces repeat_count segments
            REPEAT: A trig event produces repeat_count segments.
                    Then need the advance event to enable next trig.
            SINGLE: A trig event produces the first segment.
                    Then N-1 advance event to produce the N-1 repeats of the segment.
                    (for N=repeat_count)
            COND:   A trig event starts a continous repeat of the segment.
            """""")
        self.repeat_count = devChOption(':TRACE{ch}:COUNt', str_type=int)
        self.marker_en = devChOption(':TRACE{ch}:MARKer', str_type=bool)
        speed_choices = ChoiceStrings('WSPeed', 'WPRecision')
        self.speed_mode = devChOption(':TRACe{ch}:DWIDth', choices=speed_choices, doc=
            """"""
                wspeed:     speed mode, 12 bits, 12 GS/s max
                wprecision: precision mode, 14 bits, 8 GS/s max
                See also: speed_mode_both
            """""") # SKIP all the interpolation modes (INTX3, X12 ...) because needs option DUC
        self.speed_mode_both = scpiDevice(':TRACe1:DWIDth {val};:TRACe2:DWIDth {val}', ':TRACe1:DWIDth?', choices=speed_choices, doc=
            """"""
                Same as speed_mode except it changes both channel at the same time.
                This is needed when both channel use the internal sample clock.
                Using get returns the result for channel 1.
            """""")
        # TODO implement loading of data using the TRACE{ch}:DEFine 1, length, init_val
        #   and TRACE{ch}:DATA 1,offset (scpi has limit of 999999999 bytes 0.999 GB)
        # read with TRACE{ch}:DATA? 1,offset,length  (returns ascii, length needs to be multiple of 48 or 64)
        #   Getting trace data this way seems very slow.
        self.segment_list = devChOption(getstr=':TRACE{ch}:CATalog?', doc='Returns a list of segment id, length')
        # This needs to be last to complete creation
        super(type(self),self)._create_devs()

    @locked_calling
    def run(self, enable=True, ch=None):
        """"""
        When channels are coupled, both are affected.
        """"""
        if ch is not None:
            self.current_channel.set(ch)
        ch = self.current_channel.getcache()
        if enable:
            self.ask(':INITiate:IMMediate%i;*OPC?'%ch)
        else:
            self.ask(':ABORt%i;*OPC?'%ch)
    @locked_calling
    def set_length(self, sample_length, ch=None, init_val=None):
        """"""
        init_val is the DAC value to use for initialization. No initialization by default.
        """"""
        # TODO should check the lenght is valid
        if ch is not None:
            self.current_channel.set(ch)
        ch = self.current_channel.getcache()
        extra=''
        if init_val is not None:
            extra=',{init}'
        self.write((':TRACe{ch}:DELete:ALL;:TRACe{ch}:DEFine 1,{L}'+extra).format(ch=ch, L=sample_length, init=init_val))
    @locked_calling
    def load_file(self, filename, ch=None, fill=False):
        """"""
        filename needs to be a file in the correct binary format.
        fill when True will pad the data with 0 to the correct length
             when an integer (not 0), will pad the data with that DAC value,
             when false, will copy (repeat) the data multiple times to obtain
             the correct length.
             Note that with padding enabled, the segment length stays the same
             length as defined (so it can be shorted than the file; the data is truncated).
             Use the set_length function to change it.
             With fill disabled (False): the segment length is adjusted
        The vector length is 48 samples in 14 bits mode and 64 in 12 bits mode.
        The minimum length is 5 vectors (240 samples in 14 bits, 320 for 12 bits)
        This command will wait for the transfer to finish before returning.
        If the output is running when calling load_file, it will be temporarilly
        stopped during loading.

        Here is an example to produce the file and load it:
          t=linspace(0,10*pi,192*100+1)[:-1]
          y=sin(t)**7
          yy=array(y*(2**15-1), dtype=int16)&np.array(0xfffc, dtype=int16)
          yy.tofile('awgtest1.bin')
          awg1.load_file('awgtest1.bin')
        """"""
        # The newer firmware as fixed the problem with using a non-zero fill.
        if fill==False:
            padding='ALENgth'
        elif fill==True:
            padding='FILL'
        else:
            padding='FILL,%i'%fill
        if ch is not None:
            self.current_channel.set(ch)
        ch = self.current_channel.getcache()
        # Make sure filename is reachable. Make it absolute.
        filename = os.path.abspath(filename)
        self.write(':TRACe{ch}:IQIMPort 1,""{f}"",BIN,BOTH,ON,{p}'.format(ch=ch, f=filename, p=padding))
        #self._async_trigger_helper_string = ':TRACe{ch}:IQIMPort 1,""{f}"",BIN,BOTH,ON,{p};*OPC'.format(ch=ch, f=filename, p=padding)
        self.run_and_wait()


#######################################################
##    Agilent E3631A power supplpy
#######################################################

#@register_instrument('HEWLETT-PACKARD', 'E3631A', '2.1-5.0-1.0')
@register_instrument('HEWLETT-PACKARD', 'E3631A', alias='E3631A')
class agilent_power_supply_E363x(visaInstrument):
    """"""
    This is to control a E363x power supply.
    Useful devices:
      output_en
      volt_level
      volt_measured
      current_level
      current_measured
    Note that the volt and current devices need a channel or use the current_ch.
    Changing the output level can take a while depending on connected load impedance.
    Output off means the volt level becomes 0, the current level is 0.05. It is not a relay.
    """"""
    @locked_calling
    def _current_config(self, dev_obj=None, options={}):
        orig_ch = self.current_ch.getcache()
        ch_list = ['current_ch', 'volt_level', 'current_level', 'volt_measured', 'current_measured', 'status']
        res = []
        for c in ['P6V', 'P25V', 'N25V']:
            self.current_ch.set(c)
            self.status.setcache(None)
            res.extend(self._conf_helper(*ch_list))
        self.current_ch.set(orig_ch)
        return res+self._conf_helper('output_en', 'output_track_en', options)
    def show_text(self, str=None):
        if str is None:
            self.write('DISPlay:TEXT:CLEar')
        else:
            self.write('DISPlay:TEXT ""%s""'%str)
    def _status_getdev(self, ch=None):
        """"""
        returns the status of the ch. ch=None uses the curren default
        Status can be 'CC', 'CV' for current or voltage control
                      'OFF' when not enable or 'FAIL' for a hardware failure
        """"""
        if ch is None:
            ch = self.current_ch.getcache()
        response_dict = {0:'OFF', 1:'CC', 2:'CV', 3:'FAIL'}
        name2num = dict(P6V=1, P25V=2, N25V=3)
        n = name2num[ch.upper()]
        ret = self.ask('STATus:QUEStionable:INSTrument:ISUMmary%d:CONDition?'%n)
        ret = response_dict[int(ret)]
        return ret
    def _create_devs(self):
        ch_choices = ChoiceStrings('P6V', 'P25V', 'N25V')
        self.current_ch =  scpiDevice('INSTrument:SELect', choices=ch_choices)
        def devChOption(*arg, **kwarg):
            options = kwarg.pop('options', {}).copy()
            options.update(ch=self.current_ch)
            app = kwarg.pop('options_apply', ['ch'])
            kwarg.update(options=options, options_apply=app)
            return scpiDevice(*arg, **kwarg)
        volt_limits = ChoiceDevDep(self.current_ch, {ch_choices[[0]]:ChoiceLimits(min=0, max=6.18),
                                                     ch_choices[[1]]:ChoiceLimits(min=0, max=25.75),
                                                     ch_choices[[2]]:ChoiceLimits(min=-25.75, max=0),})
        curr_limits = ChoiceDevDep(self.current_ch, {ch_choices[[0]]:ChoiceLimits(min=0, max=5.15),
                                                     ch_choices[[1]]:ChoiceLimits(min=0, max=1.03),
                                                     ch_choices[[2]]:ChoiceLimits(min=0, max=1.03),})
        self.volt_level = devChOption('VOLTage', str_type=float, choices=volt_limits, setget=True) # SOURce:VOLTage:LEVel:IMMediate:AMPLitude
        self.current_level = devChOption('CURRent', str_type=float, choices=curr_limits, setget=True)
        #self.volt_measured = devChOption(getstr='MEASure:VOLTage? {ch}', str_type=float) # this does the same as changing current_ch
        self.volt_measured = devChOption(getstr='MEASure:VOLTage?', str_type=float)
        self.current_measured = devChOption(getstr='MEASure:CURRent?', str_type=float)
        self.output_en = scpiDevice('OUTput', str_type=bool, setget=True) # setget just makes sure the ouput has been changed before returning
        self.output_track_en = scpiDevice('OUTput:TRACk', str_type=bool, doc='Output tracking will make P25V match N25V and vice versa')
        self._devwrap('status')
        super(type(self),self)._create_devs()
"
66,21.4,"Westerville, Ohio, USA","The Model 335 supports the industry's most advanced line of cryogenic temperature sensors as manufactured by Lake Shore, including diodes, resistance temperature detectors (RTDs), and thermocouples. The controller's zone tuning feature allows you to measure and control temperatures seamlessly from 300 mK to over 1,500 K. This feature automatically switches temperature sensor inputs when your temperature range goes beyond the usable range of a given sensor.",Lakeshore Model 335,362.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Qcodes,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,https://www.lakeshore.com/docs/default-source/product-downloads/lstc_335_l.pdf?sfvrsn=becadb1e_3,"[OrderedDict([('id', 'attWM9BrNjEOhwMP4'), ('width', 500), ('height', 283), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6oMcoO8WvKZNiiR7mFNYSA/JUkBIFiLQxfzujl4BNAsWyvr49eiScYEjF7dwtHzPyVQODDE0hun5nQh-2dOWx_xsgzJpXTIEmLJ8scr8NQnaQ/_KAG_JroPdRMxXDGqyKm8TUXhOQpE5CMt5lXgKFodxI'), ('filename', '335.png'), ('size', 160368), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VPLm8G0aEzxOxSNC_raE5g/ZY0o-aX2OSlxjxQFhwlqJX8wuVuvNzYV-TkmuiMBFCbpRa1zcVwSLaG_6QwU7dlpFl3yJbpWaquM5XpllSa-Iw/v_xiZxnd1b7K4opRZ6B6LktQORDnYi2kmvGPlbvf1BQ'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oDeUig9KXBoPE2vlSV6TlQ/R1a-FRhqeqUawvoe7oKSTZcrM_b30lK7vilNqVRd7F3Ni-RkvmurzvNIvQy8sMJNpKe01JStU6l0yFmQLYXU_A/UjnnL48Ob-0Af3anjYIsf7sN9zVJfQ5KO3Q0FWhxH-8'), ('width', 500), ('height', 283)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r3xeUGqNJWEdbZUuEJRZog/JOWFEYdC6540aLBfzAvPCc0jcAZyMLV1C0l9pczunHdN-0Dvu7iGvMYyS7TS_tvSPk1gbZ4zt_OYgTSajCzYiQ/j1FAXLj4nHip6jsbhh9swpZW5K2PzBAHMCZc5nCPT_E'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-335-cryogenic-temperature-controller,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/_lakeshore_model_335.py,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel335,4181.0,,,,"from typing import Any, ClassVar

import pyvisa.constants
import pyvisa.resources

import qcodes.validators as vals
from qcodes.parameters import Group, GroupParameter

from .lakeshore_base import BaseOutput, BaseSensorChannel, LakeshoreBase

# There are 2 sensors channels (a.k.a. measurement inputs) in Model 335.
# Unlike other Lakeshore models, Model 335 refers to the channels using
# letters, and not numbers
_channel_name_to_command_map: dict[str, str] = {""A"": ""A"", ""B"": ""B""}

# OUTMODE command of this model refers to the outputs via integer numbers,
# while everywhere else within this model letters are used. This map is
# created in order to preserve uniformity of referencing to sensor channels
# within this driver.
_channel_name_to_outmode_command_map: dict[str, int] = {
    ch_name: num_for_cmd + 1
    for num_for_cmd, ch_name in enumerate(_channel_name_to_command_map.keys())
}


class LakeshoreModel335Channel(BaseSensorChannel):
    """"""
    An InstrumentChannel representing a single sensor on a Lakeshore Model 335.

    """"""

    SENSOR_STATUSES = {
        0: ""OK"",
        1: ""Invalid Reading"",
        16: ""Temp Underrange"",
        32: ""Temp Overrange"",
        64: ""Sensor Units Zero"",
        128: ""Sensor Units Overrange"",
    }

    def __init__(self, parent: ""LakeshoreModel335"", name: str, channel: str):
        super().__init__(parent, name, channel)

        # Parameters related to Input Type Parameter Command (INTYPE)
        self.add_parameter(
            ""sensor_type"",
            label=""Input sensor type"",
            docstring=""Specifies input sensor type"",
            val_mapping={""disabled"": 0, ""diode"": 1, ""platinum_rtd"": 2, ""ntc_rtd"": 3},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""auto_range_enabled"",
            label=""Autoranging"",
            docstring=""Specifies if autoranging is enabled. ""
            ""Does not apply for diode sensor type"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""range"",
            label=""Range"",
            docstring=""Specifies input range when autorange is ""
            ""not enabled. If autorange is on, the ""
            ""returned value corresponds to the ""
            ""currently auto-selected range. The list ""
            ""of available ranges depends on the ""
            ""chosen sensor type: diode 0-1, platinum ""
            ""RTD 0-6, NTC RTD 0-8. Refer to the page ""
            ""136 of the manual for the lookup table"",
            vals=vals.Numbers(0, 8),
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""compensation_enabled"",
            label=""Compensation enabled"",
            docstring=""Specifies input compensation. Reversal ""
            ""for thermal EMF compensation if input ""
            ""is resistive, room compensation if ""
            ""input is thermocouple. Always 0 if input ""
            ""is a diode"",
            val_mapping={False: 0, True: 1},
            parameter_class=GroupParameter,
        )
        self.add_parameter(
            ""units"",
            label=""Preferred units"",
            docstring=""Specifies the preferred units parameter ""
            ""for sensor readings and for the control ""
            ""setpoint (kelvin, celsius, or sensor)"",
            val_mapping={""kelvin"": 1, ""celsius"": 2, ""sensor"": 3},
            parameter_class=GroupParameter,
        )
        self.output_group = Group(
            [
                self.sensor_type,
                self.auto_range_enabled,
                self.range,
                self.compensation_enabled,
                self.units,
            ],
            set_cmd=f""INTYPE {self._channel}, ""
            f""{{sensor_type}}, ""
            f""{{auto_range_enabled}}, {{range}}, ""
            f""{{compensation_enabled}}, ""
            f""{{units}}"",
            get_cmd=f""INTYPE? {self._channel}"",
        )


class LakeshoreModel335CurrentSource(BaseOutput):
    """"""
    InstrumentChannel for current sources on Lakeshore Model 335.

    Class for control outputs 1 and 2 of Lakeshore Model 335 that are variable DC current
    sources referenced to chassis ground.
    """"""

    MODES: ClassVar[dict[str, int]] = {
        ""off"": 0,
        ""closed_loop"": 1,
        ""zone"": 2,
        ""open_loop"": 3,
    }

    RANGES: ClassVar[dict[str, int]] = {""off"": 0, ""low"": 1, ""medium"": 2, ""high"": 3}

    _input_channel_parameter_kwargs = {
        ""val_mapping"": _channel_name_to_outmode_command_map
    }

    def __init__(
        self, parent: ""LakeshoreModel335"", output_name: str, output_index: int
    ):
        super().__init__(parent, output_name, output_index, has_pid=True)

        self.P.vals = vals.Numbers(0.1, 1000)
        self.I.vals = vals.Numbers(0.1, 1000)
        self.D.vals = vals.Numbers(0, 200)


class LakeshoreModel335(LakeshoreBase):
    """"""
    Lakeshore Model 335 Temperature Controller Driver
    """"""

    channel_name_command: dict[str, str] = _channel_name_to_command_map

    CHANNEL_CLASS = LakeshoreModel335Channel

    input_channel_parameter_values_to_channel_name_on_instrument = (
        _channel_name_to_command_map
    )

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, print_connect_message=False, **kwargs)

        if isinstance(self.visa_handle, pyvisa.resources.serial.SerialInstrument):
            self.visa_handle.baud_rate = 57600
            self.visa_handle.data_bits = 7
            self.visa_handle.parity = pyvisa.constants.Parity(1)

        self.output_1 = LakeshoreModel335CurrentSource(self, ""output_1"", 1)
        self.output_2 = LakeshoreModel335CurrentSource(self, ""output_2"", 2)

        self.connect_message()
"
71,5420.0,USA,"The Keysight N5232B PNA-L series network analyzer is designed for S-parameter and simple nonlinear testing of passive components, amplifiers, and frequency converters. With the same core firmware as the PNA, the PNA-L offers the perfect balance of value and performance. The PNA-L provides efficiency and flexibility in both manufacturing and R&D applications, for industries ranging from mobile-telecomm and wireless-LAN component production to aerospace and defense. ",Keysight N 5232 B,342.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5232B Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT N5232B,https://www.keysight.com/us/en/assets/9018-04392/technical-specifications/9018-04392.pdf,"[OrderedDict([('id', 'atti4AL2ETsCbVK4I'), ('width', 500), ('height', 308), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7QhsWDfFv2zQASqHJ15Kvw/zc_MLj4Y4QoqoAjtiucp89Jz2aT8GR3IXEOkJs78gljStSx-QD-EZ0pdqi04V2uz0QYWBuMs8gwKESYf3P6DAPNp7xSdilKqSeBo2y38B_A/836EbP9xp4zrknzudr6y4IW44TYy5yo1blYllHeZzhU'), ('filename', 'N5232B.2.jpg'), ('size', 38845), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0n5ckv2j-iJyWeZvA3NyKQ/PrPKaJsaDbmWGxDI5M8rWIFLbGTK6GGyZ9NOY-qeShU5dwzzlQjKZrY50WwRvx_gdJGwD2imiK1YSKpI8b968Q/pUSuBkJ1dD_U86aa3-ahuMxE31aBTV0kj-FiEKGIygs'), ('width', 58), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BuVlEuAf4oP2u5i-1tYFSw/c0kzivNz-Bc31kYCePjzJnvAtRcPCIWMxienHJiIaLUOo9LD8Y486Pa4p5WHU3neJPZ8RdVXhTaHNTglgEEz5w/n4JvfSY89tiQtIFuB99HAWD7GFbIWO1gNwjgcMQhFek'), ('width', 500), ('height', 308)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yatnxtLXIMP7U6a9xXbjYQ/yfGXfwtEyWCj6tx--TvkkinaIqkfanYQ9s8giHY1lSM6PsmnGypuSBz9ScTzdF7Szxbjuhx5Y4FHdA31mtZghQ/NCLlP_rGq09Rl1VAPz3cHY_TUoHBRIhclm9QL1qjOlE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.axiomtest.com/Network-Analyzers/More-than-6-GHz%2C-up-to-20-GHz/Keysight-..-Agilent/N5232B/PNA_L-Network-Analyzer%2C-300-kHz-_-20-GHz%2C-2-or-4_ports/,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N52xx.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5232B,,,,,"from typing import Sequence, Union, Any
import time
import re
import logging

import numpy as np
from pyvisa import VisaIOError, errors
from qcodes import (VisaInstrument, InstrumentChannel, ArrayParameter,
                    ChannelList)
from qcodes.utils.validators import Ints, Numbers, Enum, Bool

logger = logging.getLogger()

class PNASweep(ArrayParameter):
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 **kwargs: Any) -> None:

        super().__init__(name,
                         instrument=instrument,
                         shape=(0,),
                         setpoints=((0,),),
                         **kwargs)

    @property  # type: ignore[override]
    def shape(self) -> Sequence[int]:  # type: ignore[override]
        if self._instrument is None:
            return (0,)
        return (self._instrument.root_instrument.points(),)

    @shape.setter
    def shape(self, val: Sequence[int]) -> None:
        pass

    @property  # type: ignore[override]
    def setpoints(self) -> Sequence[np.ndarray]:  # type: ignore[override]
        if self._instrument is None:
            raise RuntimeError(""Cannot return setpoints if not attached ""
                               ""to instrument"")
        start = self._instrument.root_instrument.start()
        stop = self._instrument.root_instrument.stop()
        return (np.linspace(start, stop, self.shape[0]),)

    @setpoints.setter
    def setpoints(self, val: Sequence[int]) -> None:
        pass


class FormattedSweep(PNASweep):
    """"""
    Mag will run a sweep, including averaging, before returning data.
    As such, wait time in a loop is not needed.
    """"""
    def __init__(self,
                 name: str,
                 instrument: 'PNABase',
                 sweep_format: str,
                 label: str,
                 unit: str,
                 memory: bool = False) -> None:
        super().__init__(name,
                         instrument=instrument,
                         label=label,
                         unit=unit,
                         setpoint_names=('frequency',),
                         setpoint_labels=('Frequency',),
                         setpoint_units=('Hz',)
                         )
        self.sweep_format = sweep_format
        self.memory = memory

    def get_raw(self) -> Sequence[float]:
        if self._instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr = self._instrument.root_instrument
        # Check if we should run a new sweep
        if root_instr.auto_sweep():
            prev_mode = self._instrument.run_sweep()
        # Ask for data, setting the format to the requested form
        self._instrument.format(self.sweep_format)
        data = root_instr.visa_handle.query_binary_values('CALC:DATA? FDATA',
                                                          datatype='f',
                                                          is_big_endian=True)
        data = np.array(data)
        # Restore previous state if it was changed
        if root_instr.auto_sweep():
            root_instr.sweep_mode(prev_mode)

        return data


class PNAPort(InstrumentChannel):
    """"""
    Allow operations on individual PNA ports.
    Note: This can be expanded to include a large number of extra parameters...
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 port: int,
                 min_power: Union[int, float],
                 max_power: Union[int, float]) -> None:
        super().__init__(parent, name)

        self.port = int(port)
        if self.port < 1 or self.port > 4:
            raise ValueError(""Port must be between 1 and 4."")

        pow_cmd = f""SOUR:POW{self.port}""
        self.add_parameter(""source_power"",
                           label=""power"",
                           unit=""dBm"",
                           get_cmd=f""{pow_cmd}?"",
                           set_cmd=f""{pow_cmd} {{}}"",
                           get_parser=float,
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.source_power.vals = Numbers(min_value=min_power,
                                         max_value=max_power)


class PNATrace(InstrumentChannel):
    """"""
    Allow operations on individual PNA traces.
    """"""

    def __init__(self,
                 parent: 'PNABase',
                 name: str,
                 trace_name: str,
                 trace_num: int) -> None:
        super().__init__(parent, name)
        self.trace_name = trace_name
        self.trace_num = trace_num

        # Name of parameter (i.e. S11, S21 ...)
        self.add_parameter('trace',
                           label='Trace',
                           get_cmd=self._Sparam,
                           set_cmd=self._set_Sparam)
        # Format
        # Note: Currently parameters that return complex values are not
        # supported as there isn't really a good way of saving them into the
        # dataset
        self.add_parameter('format',
                           label='Format',
                           get_cmd='CALC:FORM?',
                           set_cmd='CALC:FORM {}',
                           vals=Enum('MLIN', 'MLOG', 'PHAS',
                                     'UPH', 'IMAG', 'REAL'))

        # And a list of individual formats
        self.add_parameter('magnitude',
                           sweep_format='MLOG',
                           label='Magnitude',
                           unit='dB',
                           parameter_class=FormattedSweep)
        self.add_parameter('linear_magnitude',
                           sweep_format='MLIN',
                           label='Magnitude',
                           unit='ratio',
                           parameter_class=FormattedSweep)
        self.add_parameter('phase',
                           sweep_format='PHAS',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter('unwrapped_phase',
                           sweep_format='UPH',
                           label='Phase',
                           unit='deg',
                           parameter_class=FormattedSweep)
        self.add_parameter(""group_delay"",
                           sweep_format='GDEL',
                           label='Group Delay',
                           unit='s',
                           parameter_class=FormattedSweep)
        self.add_parameter('real',
                           sweep_format='REAL',
                           label='Real',
                           unit='LinMag',
                           parameter_class=FormattedSweep)
        self.add_parameter('imaginary',
                           sweep_format='IMAG',
                           label='Imaginary',
                           unit='LinMag',
                           parameter_class=FormattedSweep)

    def run_sweep(self) -> str:
        """"""
        Run a set of sweeps on the network analyzer.
        Note that this will run all traces on the current channel.
        """"""
        root_instr = self.root_instrument
        # Store previous mode
        prev_mode = root_instr.sweep_mode()
        # Take instrument out of continuous mode, and send triggers equal to
        # the number of averages
        if root_instr.averages_enabled():
            avg = root_instr.averages()
            root_instr.reset_averages()
            root_instr.group_trigger_count(avg)
            root_instr.sweep_mode('GRO')
        else:
            root_instr.sweep_mode('SING')

        # Once the sweep mode is in hold, we know we're done
        try:
            while root_instr.sweep_mode() != 'HOLD':
                time.sleep(0.1)
        except KeyboardInterrupt:
            # If the user aborts because (s)he is stuck in the infinite loop
            # mentioned above, provide a hint of what can be wrong.
            msg = ""User abort detected. ""
            source = root_instr.trigger_source()
            if source == ""MAN"":
                msg += ""The trigger source is manual. Are you sure this is "" \
                       ""correct? Please set the correct source with the "" \
                       ""'trigger_source' parameter""
            elif source == ""EXT"":
                msg += ""The trigger source is external. Is the trigger "" \
                       ""source functional?""
            logger.warning(msg)

        # Return previous mode, incase we want to restore this
        return prev_mode

    def write(self, cmd: str) -> None:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        super().write(cmd)

    def ask(self, cmd: str) -> str:
        """"""
        Select correct trace before querying
        """"""
        self.root_instrument.active_trace(self.trace_num)
        return super().ask(cmd)

    def _Sparam(self) -> str:
        """"""
        Extrace S_parameter from returned PNA format
        """"""
        paramspec = self.root_instrument.get_trace_catalog()
        specs = paramspec.split(',')
        for spec_ind in range(len(specs)//2):
            name, param = specs[spec_ind*2:(spec_ind+1)*2]
            if name == self.trace_name:
                return param
        raise RuntimeError(""Can't find selected trace on the PNA"")

    def _set_Sparam(self, val: str) -> None:
        """"""
        Set an S-parameter, in the format S<a><b>, where a and b
        can range from 1-4
        """"""
        if not re.match(""S[1-4][1-4]"", val):
            raise ValueError(""Invalid S parameter spec"")
        self.write(f""CALC:PAR:MOD:EXT \""{val}\"""")


class PNABase(VisaInstrument):
    """"""
    Base qcodes driver for Agilent/Keysight series PNAs
    http://na.support.keysight.com/pna/help/latest/Programming/GP-IB_Command_Finder/SCPI_Command_Tree.htm

    Note: Currently this driver only expects a single channel on the PNA. We
          can handle multiple traces, but using traces across multiple channels
          may have unexpected results.
    """"""

    def __init__(self,
                 name: str,
                 address: str,
                 # Set frequency ranges
                 min_freq: Union[int, float], max_freq: Union[int, float],
                 # Set power ranges
                 min_power: Union[int, float], max_power: Union[int, float],
                 nports: int, # Number of ports on the PNA
                 **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.min_freq = min_freq
        self.max_freq = max_freq

        #Ports
        ports = ChannelList(self, ""PNAPorts"", PNAPort)
        for port_num in range(1, nports+1):
            port = PNAPort(self, f""port{port_num}"", port_num,
                           min_power, max_power)
            ports.append(port)
            self.add_submodule(f""port{port_num}"", port)
        ports.lock()
        self.add_submodule(""ports"", ports)

        # Drive power
        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,
                                        max_value=max_power))

        # IF bandwidth
        self.add_parameter('if_bandwidth',
                           label='IF Bandwidth',
                           get_cmd='SENS:BAND?',
                           get_parser=float,
                           set_cmd='SENS:BAND {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=1, max_value=15e6))

        # Number of averages (also resets averages)
        self.add_parameter('averages_enabled',
                           label='Averages Enabled',
                           get_cmd=""SENS:AVER?"",
                           set_cmd=""SENS:AVER {}"",
                           val_mapping={True: '1', False: '0'})
        self.add_parameter('averages',
                           label='Averages',
                           get_cmd='SENS:AVER:COUN?',
                           get_parser=int,
                           set_cmd='SENS:AVER:COUN {:d}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=65536))

        # Setting frequency range
        self.add_parameter('start',
                           label='Start Frequency',
                           get_cmd='SENS:FREQ:STAR?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STAR {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('stop',
                           label='Stop Frequency',
                           get_cmd='SENS:FREQ:STOP?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:STOP {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('center',
                           label='Center Frequency',
                           get_cmd='SENS:FREQ:CENT?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:CENT {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))
        self.add_parameter('span',
                           label='Frequency Span',
                           get_cmd='SENS:FREQ:SPAN?',
                           get_parser=float,
                           set_cmd='SENS:FREQ:SPAN {}',
                           unit='Hz',
                           vals=Numbers(min_value=min_freq,
                                        max_value=max_freq))

        # Number of points in a sweep
        self.add_parameter('points',
                           label='Points',
                           get_cmd='SENS:SWE:POIN?',
                           get_parser=int,
                           set_cmd='SENS:SWE:POIN {}',
                           unit='',
                           vals=Numbers(min_value=1, max_value=100001))

        # Electrical delay
        self.add_parameter('electrical_delay',
                           label='Electrical Delay',
                           get_cmd='CALC:CORR:EDEL:TIME?',
                           get_parser=float,
                           set_cmd='CALC:CORR:EDEL:TIME {:.6e}',
                           unit='s',
                           vals=Numbers(min_value=0, max_value=100000))

        # Sweep Time
        self.add_parameter('sweep_time',
                           label='Time',
                           get_cmd='SENS:SWE:TIME?',
                           get_parser=float,
                           unit='s',
                           vals=Numbers(0, 1e6))
        # Sweep Mode
        self.add_parameter('sweep_mode',
                           label='Mode',
                           get_cmd='SENS:SWE:MODE?',
                           set_cmd='SENS:SWE:MODE {}',
                           vals=Enum(""HOLD"", ""CONT"", ""GRO"", ""SING""))
        # Group trigger count
        self.add_parameter('group_trigger_count',
                           get_cmd=""SENS:SWE:GRO:COUN?"",
                           get_parser=int,
                           set_cmd=""SENS:SWE:GRO:COUN {}"",
                           vals=Ints(1, 2000000))
        # Trigger Source
        self.add_parameter('trigger_source',
                           get_cmd=""TRIG:SOUR?"",
                           set_cmd=""TRIG:SOUR {}"",
                           vals=Enum(""EXT"", ""IMM"", ""MAN""))

        # Traces
        self.add_parameter('active_trace',
                           label='Active Trace',
                           get_cmd=""CALC:PAR:MNUM?"",
                           get_parser=int,
                           set_cmd=""CALC:PAR:MNUM {}"",
                           vals=Numbers(min_value=1, max_value=24))
        # Note: Traces will be accessed through the traces property which
        # updates the channellist to include only active trace numbers
        self._traces = ChannelList(self, ""PNATraces"", PNATrace)
        self.add_submodule(""traces"", self._traces)
        # Add shortcuts to first trace
        trace1 = self.traces[0]
        params = trace1.parameters
        if not isinstance(params, dict):
            raise RuntimeError(f""Expected trace.parameters to be a dict got ""
                               f""{type(params)}"")
        for param in params.values():
            self.parameters[param.name] = param
        # And also add a link to run sweep
        self.run_sweep = trace1.run_sweep
        # Set this trace to be the default (it's possible to end up in a
        # situation where no traces are selected, causing parameter snapshots
        # to fail)
        self.active_trace(trace1.trace_num)

        # Set auto_sweep parameter
        # If we want to return multiple traces per setpoint without sweeping
        # multiple times, we should set this to false
        self.add_parameter('auto_sweep',
                           label='Auto Sweep',
                           set_cmd=None,
                           get_cmd=None,
                           vals=Bool(),
                           initial_value=True)

        # A default output format on initialisation
        self.write('FORM REAL,32')
        self.write('FORM:BORD NORM')

        self.connect_message()

    @property
    def traces(self) -> ChannelList:
        """"""
        Update channel list with active traces and return the new list
        """"""
        # Keep track of which trace was active before. This command may fail
        # if no traces were selected.
        try:
            active_trace = self.active_trace()
        except VisaIOError as e:
            if e.error_code == errors.StatusCode.error_timeout:
                active_trace = None
            else:
                raise

        # Get a list of traces from the instrument and fill in the traces list
        parlist = self.get_trace_catalog().split("","")
        self._traces.clear()
        for trace_name in parlist[::2]:
            trace_num = self.select_trace_by_name(trace_name)
            pna_trace = PNATrace(self, f""tr{trace_num}"",
                                 trace_name, trace_num)
            self._traces.append(pna_trace)

        # Restore the active trace if there was one
        if active_trace:
            self.active_trace(active_trace)

        # Return the list of traces on the instrument
        return self._traces

    def get_options(self) -> Sequence[str]:
        # Query the instrument for what options are installed
        return self.ask('*OPT?').strip('""').split(',')

    def get_trace_catalog(self) -> str:
        """"""
        Get the trace catalog, that is a list of trace and sweep types
        from the PNA.

        The format of the returned trace is:
            trace_name,trace_type,trace_name,trace_type...
        """"""
        return self.ask(""CALC:PAR:CAT:EXT?"").strip('""')

    def select_trace_by_name(self, trace_name: str) -> int:
        """"""
        Select a trace on the PNA by name.

        Returns:
            The trace number of the selected trace
        """"""
        self.write(f""CALC:PAR:SEL '{trace_name}'"")
        return self.active_trace()

    def reset_averages(self) -> None:
        """"""
        Reset averaging
        """"""
        self.write(""SENS:AVER:CLE"")

    def averages_on(self) -> None:
        """"""
        Turn on trace averaging
        """"""
        self.averages_enabled(True)

    def averages_off(self) -> None:
        """"""
        Turn off trace averaging
        """"""
        self.averages_enabled(False)

    def _set_power_limits(self,
                          min_power: Union[int, float],
                          max_power: Union[int, float]) -> None:
        """"""
        Set port power limits
        """"""
        self.power.vals = Numbers(min_value=min_power,
                                  max_value=max_power)
        for port in self.ports:
            port._set_power_limits(min_power, max_power)


class PNAxBase(PNABase):
    def _enable_fom(self) -> None:
        '''
        PNA-x units with two sources have an enormous list of functions &
        configurations. In practice, most of this will be set up manually on
        the unit, with power and frequency varied in a sweep.
        '''
        self.add_parameter('aux_frequency',
                           label='Aux Frequency',
                           get_cmd='SENS:FOM:RANG4:FREQ:CW?',
                           get_parser=float,
                           set_cmd='SENS:FOM:RANG4:FREQ:CW {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=self.min_freq,
                                        max_value=self.max_freq))
"
73,5420.0,USA,"8753D Network Analyzer, 30 kHz to 3 GHz",HP 8753 D,174.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,HP,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a Keisight 8753D Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],A network analyzer is an instrument that measures the network parameters of electrical networks.,Keisight 8753D,https://www.keysight.com/us/en/assets/9018-40537/user-manuals/9018-40537.pdf,"[OrderedDict([('id', 'atthgLOInyyT7kYQx'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BctwVeoSunDYwNITWxv1Ow/Sst927rDjJkIVmwubFkzDt4lp7ITcmrmVGoyK6ucx0AMWzX1nF5ODi2-WyhGSS2VC4yhWPnX6cZnAEzzeRjc3QboSvDgSFxQ0kWcaKIq13U/gMlMIDlIjFovL3jRc0J3vOExsHE1ld5sNvD_RnupkY0'), ('filename', 'HP8753.webp'), ('size', 9110), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vnUDgnVyEJ32KL_3gR8Ndg/Wrpu-oel_wo61iv5hSMDAp8qoGM4j0kWmMqbIdTmvJ-o1OKHSlDE8paRe5MleSBi21lZMvPe7wwZq2jv7iZUO8Xh8ilhnEmUz-XX-lYncn0/lYUVeoWz7ZCpToaC4LSdiH8R51gEk5wAlc9RmK-9Aro'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GTpY3SbH2y3H-x8MJoCaLw/C-iKV3rbbfa4-oI8ZRBE6wWZoOzktCy6e1bzEK_ycm79PDbq9Qb4KevVpOK8IfskxSaKgoF7FHLLHGSo50WNGt5SzhBtvXtF8C29W1_zjuM/RCnvuwACLJy3SXZ4FNvbcscOdRH15-VX865ky3TBuOM'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JYsvPYLN3554blnpm_3vNA/lUDizOB03ioeL8TMEzHgG7aqb-nifdCxk1USdZsrexDp1410CP-8Hquy9EAVlL_zc2qbCa8OV1Vfp7IP_1L2fuzwBF00049xudpyR1chLpY/ADD92vngLhGnRK78Mkw_REv7OkX_gWBrVlJ1Rq_p7Io'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/8753D/network-analyzer-30-khz-to-3-ghz.html,https://github.com/heeres/qtlab/blob/master/instrument_plugins/HP_8753C.py,https://github.com/heeres/qtlab/blob/master/MANUAL,,,True,,"# HP_8753C.py class, to perform the communication between the Wrapper and the device
# Pieter de Groot <pieterdegroot@gmail.com>, 2008
# Martijn Schaafsma <qtlab@mcschaafsma.nl>, 2008
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from instrument import Instrument
import visa
import types
import logging
from time import sleep
import struct
import numpy

import qt

class HP_8753C(Instrument):
    '''
    This is the python driver for the HP 8753C
    network analyzer

    Usage:
    Initialise with
    <name> = instruments.create('<name>', 'HP_8753C', address='<GPIB address>',
        reset=<bool>)

    The last parameter is optional. Default is reset=False

    TODO:
    1. make todo list
    2. ask Pieter about the purpose of the specific tools
    3. fix docstrings
    '''

    def __init__(self, name, address, reset=False):
        '''
        Initializes the HP_8753C, and communicates with the wrapper

        Input:
            name (string)    : name of the instrument
            address (string) : GPIB address
            reset (bool)     : resets to default values, default=false
        '''
        Instrument.__init__(self, name)

        self._address = address
        self._visainstrument = visa.instrument(self._address)

        self._visainstrument.timeout = 30
        # BEWARE! in case of low IFWB, it might be
        # necessary to add additional delay
        # ( ~ numpoints / IFBW ) yourself!
        # see for example get_trace()

        self._visainstrument.send_end = False
        self._visainstrument.term_chars = ''
        # BEWARE! need to end strings with ';' yourself!

        self.add_parameter('IF_Bandwidth', flags=Instrument.FLAG_GETSET, type=types.IntType)
        self.add_parameter('numpoints', flags=Instrument.FLAG_GETSET, type=types.IntType)
        self.add_parameter('start_freq', flags=Instrument.FLAG_GETSET, type=types.FloatType)
        self.add_parameter('stop_freq', flags=Instrument.FLAG_GETSET, type=types.FloatType)
        self.add_parameter('power', flags=Instrument.FLAG_GETSET, type=types.FloatType)

        self.add_function('set_freq_3GHz')
        self.add_function('set_freq_6GHz')
        self.add_function('set_measurement_S11')
        self.add_function('set_measurement_S22')
        self.add_function('set_measurement_S12')
        self.add_function('set_measurement_S21')
        self.add_function('set_format_logm')
        self.add_function('set_format_phas')
        self.add_function('set_lin_freq')

        self.add_function('set_conversion_off')
        self.add_function('set_average_off')
        self.add_function('set_smooth_off')
        self.add_function('set_correction_off')
        self.add_function('set_trigger_exttoff')

        self.add_function('set_trigger_hold')
        self.add_function('send_trigger')
        self.add_function('reset')

        self.get_all()

    def get_all(self):

        sl = 1

        self.get_start_freq()
        sleep(sl)

        self.get_stop_freq()
        sleep(sl)

        self.get_IF_Bandwidth()
        sleep(sl)

        self.get_numpoints()
        sleep(sl)

        self.get_power()
        sleep(sl)

    def default_init(self):

        sl = 1

        print 'resetting'
        self.reset()
        sleep(sl)

        print 'set trigger hold'
        self.set_trigger_hold()
        sleep(sl)

        print 'set format logm'
        self.set_format_logm()
        sleep(sl)
        print 'set measurement S21'
        self.set_measurement_S21()
        sleep(sl)

        print 'set start freq'
        self.set_start_freq(10e6)
        sleep(sl)
        print 'set stop freq'
        self.set_stop_freq(3e9)
        sleep(sl)
        print 'set IF bandwidth'
        self.set_IF_Bandwidth(3000)
        sleep(sl)
        print 'set numpoints'
        self.set_numpoints(401)
        sleep(sl)
        print 'set power'
        self.set_power(0.0)
        sleep(sl)

    def reset(self):
        '''
        Resets the instrument to default values

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('PRES;')

    def set_trigger_hold(self):
        '''
        Puts instrument on hold. It will wait for
        trigger to initiate a trace.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('HOLD;')


    def send_trigger(self):
        '''
        Send trigger to the instrument.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('SING;')

    def read(self):
        '''
        Read the date from the instrument.

        Input:
            None

        Output:
            data (int)  : list of data points
        '''
        data = self._visainstrument.ask('FORM2;DISPDATA;OUTPFORM;')
        d = [struct.unpack('>f', data[i:i+4])[0] for i in range(4, len(data),8)]
        return d

### Functions for doing measurements

    def get_trace(self):
        '''
        This function performs a full measurement.
        First a trigger is sent to initiate a sweep.
        An estimate is made of the time the sweep takes.
        After the estimated time the data is queried from
        the device. Usually the estimated time is a bit
        lower then the actual time, the device will
        respond as soon as it is finished.
        It is assumed that the instrument is already on
        'trigger hold'-mode.

        Input:
            None

        Ouptput:
            freqs (array of floats):    The frequencies at which the
                                        reflection / transmission was
                                        measured
            reply (arrray of foats):    Measured data

        '''
        qt.mstart()

        startfreq = self.get_start_freq(query=False)
        stopfreq = self.get_stop_freq(query=False)
        numpoints = self.get_numpoints(query=False)
        IF_Bandwidth = self.get_IF_Bandwidth(query=False)

        freqs = numpy.linspace(startfreq,stopfreq,numpoints)
        sweep_time = numpoints / IF_Bandwidth

        print 'sending trigger to network analyzer, and wait to finish'
        print 'estimated waiting time: %.2f s' % sweep_time
        self.send_trigger()
        qt.msleep(sweep_time)

        print 'reading out network analyzer'
        reply = self.read()
        reply = numpy.array(reply)

        qt.mend()

        return (freqs, reply)

    def save_trace(self, filepath=None, plot=True):
        '''
        runs 'get_trace()' and saves the output to a file.

        Input:
            filepath (string):  Path to where the file should be saved.(optional)

        Output:
            filepath (string):  The filepath where the file has been created.
        '''
        #TODO: change value label 'S_ij' to represent actual measurement
        freqs, reply = self.get_trace()
        d = qt.Data(name='netan')
        d.add_coordinate('freq [Hz]')
        d.add_value('S_ij [dB]')
        d.create_file(filepath=filepath)
        d.add_data_point(zip(freqs, reply))
        d.close_file()
        if plot:
            p = qt.plot(d, name='netan', clear=True)
            p.save_png()
            p.save_gp()
        return d.get_filepath()

    def plot_trace(self):
        '''
        performs a measurement and plots the data.
        '''
        freqs, reply = self.get_trace()
        qt.plot(freqs, reply, name='netan',
                xlabel='freq [Hz]', ylabel='S_ij [dB]',
                clear=True)

### Functions for changing measurement settings

    def set_freq_3GHz(self):
        '''
        Set to 3 GHz range.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('FREQRANG3GHz;')

    def set_freq_6GHz(self):
        '''
        Set to 6 GHz range.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('FREQRANG6GHz;')

    def set_measurement_S11(self):
        '''
        Set S11 measurement.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('S11;')

    def set_measurement_S22(self):
        '''
        Set S22 measurement.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('S22;')

    def set_measurement_S12(self):
        '''
        Set S12 measurement.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('S12;')

    def set_measurement_S21(self):
        '''
        Set S21 measurement.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('S21;')

    def set_lin_freq(self):
        '''
        Set the frequency to linear scale.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('LINFREQ;')

    def set_format_logm(self):
        '''
        Set output format to 'log magnitude'.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('LOGM;')

    def set_format_phas(self):
        '''
        Set output format to 'phase'.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('PHAS;')

### Functions for turning stuff 'off'

    def set_trigger_exttoff(self):
        '''
        Set external trigger input off.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('EXTTOFF;')

    def set_conversion_off(self):
        '''
        Set conversion off.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('CONVOFF;')

    def set_average_off(self):
        '''
        Set averaging off.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('AVEROOFF;')

    def set_smooth_off(self):
        '''
        Set smoothing off.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('SMOOOOFF;')

    def set_correction_off(self):
        '''
        Set correction off.

        Input:
            None

        Output:
            None
        '''
        self._visainstrument.write('CORROFF;CORIOFF;')


### parameters

    def do_set_IF_Bandwidth(self, bw):
        '''
        Set IF Bandwidth.
        Can be 10, 30, 100, 300, 1000, 3000

        Input:
            bw (float)

        Output:
            None
        '''
        self._visainstrument.write('IFBW%d;' %bw)

    def do_get_IF_Bandwidth(self):
        '''
        Get IF Bandwith.

        Input:
            None

        Output:
            bandwidth (float)   : IF bandwidth
        '''
        return int(float(self._visainstrument.ask('IFBW?;')))

    def do_set_numpoints(self, numpts):
        '''
        Set number of points in trace.
        Can be 3, 11, 26, 51, 101, 201, 401, 801, 1601

        Input:
            numpts (int)    : number of points in trace

        Output:
            None
        '''
        self._visainstrument.write('POIN%d;' %numpts)

    def do_get_numpoints(self):
        '''
        Get number of points in trace

        Input:
            None

        Output:
            numpoints (int) : Number of points in trace
        '''
        return int(float(self._visainstrument.ask('POIN?;')))

    def do_set_start_freq(self, freq):
        '''
        Set start frequency.

        Input:
            freq (float)    : Start frequency

        Output:
            None
        '''
        self._visainstrument.write('STAR%eHZ;' %freq)

    def do_get_start_freq(self):
        '''
        Get start frequency.

        Input:
            None

        Output:
            freq (float)    : Start frequency
        '''
        return float(self._visainstrument.ask('STAR?;'))

    def do_set_stop_freq(self, freq):
        '''
        Set stop frequency.

        Input:
            freq (float)    : Stop frequency

        Output:
            None
        '''
        self._visainstrument.write('STOP%eHZ;' %freq)

    def do_get_stop_freq(self):
        '''
        Get stop frequency.

        Input:
            None

        Output:
            freq (float)    : Stop frequency
        '''
        return float(self._visainstrument.ask('STOP?;'))

    def do_set_power(self, pow):
        '''
        Set power.

        Input:
            pow (float) : Power

        Output:
            None
        '''
        self._visainstrument.write('POWE%.3e;' % pow)

    def do_get_power(self):
        '''
        Get power

        Input:
            None

        Output:
            pow (float) : Power
        '''
        return float(self._visainstrument.ask('POWE?;'))

"
75,110.6,"Cleveland, Ohio, United States","The 2635B SourceMeter SMU instrument, is a new and improved one-channel SMU instrument with a tightly integrated four-quadrant design that allows it to simultaneously source and measure both voltage and current to boost productivity in applications ranging from R&D to automated production test. The wide range of 1.5A DC, 10A pulse, 200V output and 0.1fA measurement resolution makes it ideal to test a wide range of lower current devices and materials. In addition to retaining all the features of the Model 2635A, the Model 2635B has 6½-digit resolution, USB 2.0 connectivity, and software command emulation of the Model 2400 SourceMeter SMU Instrument to enable easy migration of legacy test code. The Model 2635B is equipped with Keithley's high speed TSP technology (over 190% faster than traditional PC-to-instrument communication techniques,) which dramatically improves the system-level speed to lower the cost of test.",Keithley 2635 B,266.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2635B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2635B,https://www.farnell.com/datasheets/2619879.pdf,"[OrderedDict([('id', 'attka6V7nbvKPV5eZ'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TgyTqAT25r15U8QeNC0fcA/gcR55AAKiI8RgTiof5Qdzha307s2PHxCuoCuRs-YWJN1zAJ3fLon4xcey1Kt-NiReXIxC8RAc-6_Znepn0tYd_Lo2afeYDKHpFn91F8zQAw/vhEzNH6Lrgczri5Hi_f7jT4hoyV9L28uN87gGRQCopo'), ('filename', '2635b.webp'), ('size', 5770), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/24Ych8vPEdKa_O62rLReXw/WVdGoM1FXxa6lX_BVexRPVPJrGy1k9jJtrF3wflBfYZ7HjnKtsvNljf98NVygmD86JsIQs_7eJrV1A1G6LA-UyC5aR3JOba9ac2MJt4trws/oBd3PCrYa0Umg_D1r76IOjQ6Fp1mpCWNgJdBcK6Jpns'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OXW07A8WVl-3DzAYckRhiA/EiK8x6ns50AUHFPTgPF3v5MO3-RZHrNM3EO7EmeTd_iR62R71qfXxiJOjyTG9yWY8ntwabNV5NwRptp1zTOBOEe6DO7NUTswVVD1IH548sU/HGQoiLXmU8r4vqTUt07Xt-KnVTORKBIYVt40b9NvE6E'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Zi4-GE1hD-XyMl9vMHSTpw/ORm69CY2RE1UkPyP0bkeo9lHMudK2Wm_s72vRcMitqqIWV8uB0TCWzy8fCmNjc5mUsNbcTQAFU1vCmvK5D06LP894QGvOrgeuXhMSg17sbg/DEkzPYMAh5HF1XytMIkrRk_6iJIliiQtvrJ7KsF8hTA'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2635b/source-meter-voltage-current-30/dp/44W8040,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2635B,22379.0,,,,
82,110.6,"Cleveland, Ohio, United States","6½ digit bench/system digital multimeter with large 5"" (12.7cm) multi touch capacitive touchscreen and graphical display. It supports SCPI, TSP® scripting, Keithley 2000 SCPI emulation and Keysight 34401A SCPI emulation language modes.",Keithley 6500,211.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a DMM6500 Keithley Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",DMM6500 Keithley,https://www.farnell.com/datasheets/2607096.pdf?_ga=2.134065926.922366921.1579493884-611634051.1579231713,"[OrderedDict([('id', 'attptYwWAOrQzTAZz'), ('width', 320), ('height', 169), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NRnmfFNMUnkVqE5tQHJAXA/u6w6nju2-6f4M8L5S2g1_KGpkawJMWsxKOy5x1SZJi4YShjoVeAlISBPY0EqE7vJ7pNuXE1rUd-g1qY8CYf4BYL723gAQT-gJQLQ0GngJHQ/UzZxBI-e6x7X5HRr4o82bmOhxxecYPGem5r26ETajI8'), ('filename', '6500.webp'), ('size', 7262), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/14YFrAxBOCAP_rzbzuuJcQ/Q5GHo0wJS2-vje3Et7_aqo_XZgvHzoKcoWqF2p9-BRUZH2RqrUYT1bbwAtAjyuRLqK58AJscEcWju3qXhU8BAe--X7Y3kOhejKtOtdTQPMY/-vOYgO7yB9DHVg65EzzeCCHoJ7cEPtWAOVA1uGTyOuE'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/s9vkISqMvKmqCKqHFe5dBw/QTS6TuobWB1ey6xaDVuSMm-38CjL61PWlGCf3v2kWqsfYGATIlVkYcpl86GTCq9bcK9suOebcsgcVaSDQbLStq6uB6BaEu276XVzDkPhdHg/mYYBTWky54oEAMJeh4121K31kvxHSi-E_j-55eqKI4s'), ('width', 320), ('height', 169)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TeVRUQ1qU0uSoRYfHSSiIQ/JHci_vs123XKTOi574DShDlqfsQG5fdLIb-QlqUum3uSJ14fvlS5d6nWiJ3SWfA4EyvAaA2aTa-N7xySm9ofF0SdPvWqwjqenUd5D1e5MNU/So5M0KjZaSN-Tn6vim4D3kaXU8KRln1DwrtaoIXK-8A'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/digital-multimeter/dmm6500,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_6500.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley6500,2160.0,,,,"from functools import partial
from typing import Any, Callable, TypeVar, Union

from qcodes.instrument import VisaInstrument
from qcodes.validators import Bool, Enum, Ints, MultiType, Numbers

T = TypeVar(""T"")


def _parse_output_string(string_value: str) -> str:
    """"""Parses and cleans string output of the multimeter. Removes the surrounding
        whitespace, newline characters and quotes from the parsed data. Some results
        are converted for readablitity (e.g. mov changes to moving).

    Args:
        string_value: The data returned from the multimeter reading commands.

    Returns:
        The cleaned-up output of the multimeter.
    """"""
    s = string_value.strip().lower()
    if (s[0] == s[-1]) and s.startswith((""'"", '""')):
        s = s[1:-1]

    conversions = {""mov"": ""moving"", ""rep"": ""repeat""}
    if s in conversions.keys():
        s = conversions[s]
    return s


def _parse_output_bool(numeric_value: Union[float, str]) -> bool:
    """"""Parses and converts the value to boolean type. True is 1.

    Args:
        numeric_value: The numerical value to convert.

    Returns:
        The boolean representation of the numeric value.
    """"""
    return bool(numeric_value)


class Keithley6500CommandSetError(Exception):
    pass


class Keithley6500(VisaInstrument):
    def __init__(
        self, name: str, address: str, reset_device: bool = False, **kwargs: Any
    ):
        """"""Driver for the Keithley 6500 multimeter. Based on the Keithley 2000 driver,
            commands have been adapted for the Keithley 6500. This driver does not contain
            all commands available, but only the ones most commonly used.

            Status: beta-version.

        Args:
            name (str): The name used internally by QCoDeS in the DataSet.
            address (str): The VISA device address.
            reset_device (bool): Reset the device on startup if true.
        """"""
        super().__init__(name, address, terminator=""\n"", **kwargs)

        command_set = self.ask(""*LANG?"")
        if command_set != ""SCPI"":
            error_msg = (
                ""This driver only compatible with the 'SCPI' command ""
                ""set, not '{}' set"".format(command_set)
            )
            raise Keithley6500CommandSetError(error_msg)

        self._trigger_sent = False

        self._mode_map = {
            ""ac current"": ""CURR:AC"",
            ""dc current"": ""CURR:DC"",
            ""ac voltage"": ""VOLT:AC"",
            ""dc voltage"": ""VOLT:DC"",
            ""2w resistance"": ""RES"",
            ""4w resistance"": ""FRES"",
            ""temperature"": ""TEMP"",
            ""frequency"": ""FREQ"",
        }

        self.add_parameter(
            ""mode"",
            get_cmd=""SENS:FUNC?"",
            set_cmd=""SENS:FUNC '{}'"",
            val_mapping=self._mode_map,
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=partial(self._get_mode_param, ""NPLC"", float),
            set_cmd=partial(self._set_mode_param, ""NPLC""),
            vals=Numbers(min_value=0.01, max_value=10),
        )

        #  TODO: validator, this one is more difficult since different modes
        #  require different validation ranges.
        self.add_parameter(
            ""range"",
            get_cmd=partial(self._get_mode_param, ""RANG"", float),
            set_cmd=partial(self._set_mode_param, ""RANG""),
            vals=Numbers(),
        )

        self.add_parameter(
            ""auto_range_enabled"",
            get_cmd=partial(self._get_mode_param, ""RANG:AUTO"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""RANG:AUTO""),
            vals=Bool(),
        )

        self.add_parameter(
            ""digits"",
            get_cmd=""DISP:VOLT:DC:DIG?"",
            get_parser=int,
            set_cmd=""DISP:VOLT:DC:DIG? {}"",
            vals=Ints(min_value=4, max_value=7),
        )

        self.add_parameter(
            ""averaging_type"",
            get_cmd=partial(self._get_mode_param, ""AVER:TCON"", _parse_output_string),
            set_cmd=partial(self._set_mode_param, ""AVER:TCON""),
            vals=Enum(""moving"", ""repeat""),
        )

        self.add_parameter(
            ""averaging_count"",
            get_cmd=partial(self._get_mode_param, ""AVER:COUN"", int),
            set_cmd=partial(self._set_mode_param, ""AVER:COUN""),
            vals=Ints(min_value=1, max_value=100),
        )

        self.add_parameter(
            ""averaging_enabled"",
            get_cmd=partial(self._get_mode_param, ""AVER:STAT"", _parse_output_bool),
            set_cmd=partial(self._set_mode_param, ""AVER:STAT""),
            vals=Bool(),
        )

        # Global parameters
        self.add_parameter(
            ""display_backlight"",
            docstring=""Control the brightness of the display ""
            ""backligt. Off turns the display off and""
            ""Blackout also turns off indicators and ""
            ""key lights on the device."",
            get_cmd=""DISP:LIGH:STAT?"",
            set_cmd=""DISP:LIGH:STAT {}"",
            val_mapping={
                ""On 100"": ""ON100"",
                ""On 75"": ""ON75"",
                ""On 50"": ""ON50"",
                ""On 25"": ""ON25"",
                ""Off"": ""OFF"",
                ""Blackout"": ""BLACkout"",
            },
        )

        self.add_parameter(
            ""trigger_count"",
            get_parser=int,
            get_cmd=""ROUT:SCAN:COUN:SCAN?"",
            set_cmd=""ROUT:SCAN:COUN:SCAN {}"",
            vals=MultiType(
                Ints(min_value=1, max_value=9999),
                Enum(""inf"", ""default"", ""minimum"", ""maximum""),
            ),
        )

        for trigger in range(1, 5):
            self.add_parameter(
                ""trigger%i_delay"" % trigger,
                docstring=""Set and read trigger delay for "" ""timer %i."" % trigger,
                get_parser=float,
                get_cmd=""TRIG:TIM%i:DEL?"" % trigger,
                set_cmd=""TRIG:TIM%i:DEL {}"" % trigger,
                unit=""s"",
                vals=Numbers(min_value=0, max_value=999999.999),
            )

            self.add_parameter(
                ""trigger%i_source"" % trigger,
                docstring=""Set the trigger source for "" ""timer %i."" % trigger,
                get_cmd=""TRIG:TIM%i:STAR:STIM?"" % trigger,
                set_cmd=""TRIG:TIM%i:STAR:STIM {}"" % trigger,
                val_mapping={
                    ""immediate"": ""NONE"",
                    ""timer1"": ""TIM1"",
                    ""timer2"": ""TIM2"",
                    ""timer3"": ""TIM3"",
                    ""timer4"": ""TIM4"",
                    ""notify1"": ""NOT1"",
                    ""notify2"": ""NOT2"",
                    ""notify3"": ""NOT3"",
                    ""front-panel"": ""DISP"",
                    ""bus"": ""COMM"",
                    ""external"": ""EXT"",
                },
            )

        # Control interval between scans; the default value from the instrument is 0,
        # hence 0 is included in the validator's range of this parameter.
        self.add_parameter(
            ""trigger_timer"",
            get_parser=float,
            get_cmd=""ROUT:SCAN:INT?"",
            set_cmd=""ROUT:SCAN:INT {}"",
            unit=""s"",
            vals=Numbers(min_value=0, max_value=999999.999),
        )

        self.add_parameter(
            ""amplitude"", get_cmd=self._read_next_value, set_cmd=False, unit=""a.u.""
        )

        if reset_device:
            self.reset()
        self.write(""FORM:DATA ASCII"")
        self.connect_message()

    def reset(self) -> None:
        """"""Reset the device""""""
        self.write(""*RST"")

    def _read_next_value(self) -> float:
        return float(self.ask(""READ?""))

    def _get_mode_param(self, parameter: str, parser: Callable[[str], T]) -> T:
        """"""Reads the current mode of the multimeter and ask for the given parameter.

        Args:
            parameter: The asked parameter after getting the current mode.
            parser: A function that parses the input buffer read.

        Returns:
            Any: the parsed ask command. The parser determines the return data-type.
        """"""
        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter}?""
        return parser(self.ask(cmd))

    def _set_mode_param(self, parameter: str, value: Union[str, float, bool]) -> None:
        """"""Gets the current mode of the multimeter and sets the given parameter.

        Args:
            parameter: The set parameter after getting the current mode.
            value: Value to set
        """"""
        if isinstance(value, bool):
            value = int(value)

        mode = _parse_output_string(self._mode_map[self.mode()])
        cmd = f""{mode}:{parameter} {value}""
        self.write(cmd)
"
84,5800.0,USA,"The MSO/DPO5000 Series offers the industry's most complete visualization of signals, providing fast insight into the real operation of your device. Tektronix proprietary FastAcq™ technology delivers a fast waveform capture – greater than 250,000 waveforms per second – that enables you to see glitches and other infrequent transients within seconds, revealing the true nature of device faults. A digital phosphor display with color intensity grading shows the history of a signal's activity by using color to identify areas of the signal that occur more frequently, providing a visual display of just how often anomalies occur.",Tektronix DPO 5000,570.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a DPO5000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",DPO5000,https://download.tek.com/datasheet/MSO5000-DPO5000-Mixed-Signal-Oscilloscope-Datasheet-9.pdf,"[OrderedDict([('id', 'attbSlGCqWoVTZaSj'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZFFu0Lly_djgLoyR_TEw7Q/OXEoZpl3kGoqG_4XyhVaDwIB6TWPCqUf1Qt8yrW-FDFn0WDyhS54Tq3VsZ8T5AxONsWyhKp-fshDX4pMPXKM2M_x39SH2Ci2JfaM4Xrfs84/eKjllicwwF6Ng4JFk-upArIEDmgHcqP-u2XtIyAEz5E'), ('filename', 'mso5000-front-view (1).webp'), ('size', 109264), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Kvi0qi_gpknji8wn8U9JzQ/vqw2hxUnoi1NPN5lwTgFxJEC6Mj768gdimYBZuuA04h40flycpInUgcz_UBEkgTEM_bZeYM9h4fQ7fKHol4NX-FSsgabVS0VD7USglw8VKY/cHc9UBc7uJCtdie-g-A-i1sumxOan-aQ3VQiZseQBa8'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cK_dCUFqXdDC2ZpnCRnHnw/6akG-VQBqGHKT8-1vSlThPwShr5IBaxfmYuD-ZGp9bOdUbJAuQEt5ZaQ21dUuP3F2uqQMhN1PDkB_gPiR3Zxf384MDodoU-d72xV3gaxgNQ/btM7K2zLBIuNGAA28dO0NS4lwPTID7gq7yDoodlQWoc'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0rnTlNhe27O255mfZuvY8A/zjeuRyC6gt4qLkqkSNAU3leBq2959NY169RurfnP85AJ3PjgSLCi7nSAAjr1FmrIeGkdvXskatH51AwSAbVYHQBX-P28wJlDcUdYN2PnF5A/LUMKJLnwbzno7n0VEkUyVkz_1ZmQXvWQkeqncWyR2A4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/oscilloscopes/mso5000-dpo5000,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO5000,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
91,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Single Output, 6V/8A, USB, RS232, LAN(LXI) and Analogue interfaces
",AIM TTI PL 068 P,54.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL068-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL068-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'attpAsShHG4lQXH7N'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B3g3aCg2uJMp1V01WiYqkw/_3kGNMz1qJhxh0vICfUH4jr4akznUJnyGcJPi2MzI6ANydNlsFZmRp7i41NPK0JOgjbyBK8weOsy65zcUDeeGcw0PiVEcKR8jSLwqSZ9zOU/Xlp0C4ctZYtNRbpgmrYQFzuYDSBFdaSBt7-wMJOFzb4'), ('filename', 'PL068P-1000px.jpg'), ('size', 161046), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qppeqJlgmGo6PcUQjjC9oQ/Ir_ixVIouwh9G6AvOoSZvTgkjjateALmlSGPr4ddYwD691YUDxuKOPj7LFaVBT53TsHrOOljUeCKeNcaQglN7Q/dwex7GYwnKr25hqAqlRmQJgZ0Vv0kgHfF-3_guz0VRY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jGojwdlEyttqFpMjy6QimQ/o-db-fyjo5PZK0MYEF6q6_gH7U2GqRhUE-Dost4xRmfRW5iOkjY4xOYBKoLr89gQB4SruQbBLTp5sMJmeCL8Nw/NATstk4CymMUBvw3x2fDWSGPFQOzBo5KwxbfHE3eubo'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IM0VAYfDw6-NWrvvpDyxJw/BQDBorLjiuRZrgpHbj7FTXNqu_vGlkj8RVeDIcNEfkkrBu1GfyAUUD9uFE_GJiNN4YrNXMgMGCTHaBVBVgRS6w/SD7TM8mobYV2uDg942FMt3W3TAdbickgVtV_YSgbQYM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,700.0,"
",,,
93,110.6,"Cleveland, Ohio, United States","Keithley’s Standard Series 2400 Source Measure Unit (SMU) Instruments offer four-quadrant precision voltage and current source/load coupled with measurement. Each SMU instrument is both a highly stable DC power source and a true instrument-grade 6½-digit multimeter. The power source characteristics include low noise, precision, and readback. The multimeter capabilities include high repeatability and low noise.",Keithley 2400,242.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",,https://download.tek.com/datasheet/1KW-2798-4_2400_SourceMeter_SMU_Datasheet_061622.pdf,"[OrderedDict([('id', 'attFCwQhJ4waLZGsg'), ('width', 327), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ufM9niuYoxIqNOZhZ6C-ew/ncGFMJTq6JXc3xeEJwO-HdOvCTZeRz2xtT6xisW2VmC3xZdVm3emtOpPuffoxOxHANIRw7QbgXftUsoTX4hSR3tw9EidUaGKNm7xoPcnbv0/kMGQ9cu0KbZ0jws896dyOQk4vl1yHBOGnbJVv5ZHV7M'), ('filename', '2400.webp'), ('size', 10742), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2hYIsb3W4uCpf6cEK92ORw/kWA0bz799rNdks3QxCSMxnhUlaGrNPrapQAwBqG7Zd8vErwWyyKfo5nPUrT6WLGdBh_zQsLiFJtogHXmN5ZMK0NJObPdnHhnH4C0r2iMrcU/XKIrAHx_-g9SQLaFbBhoakI2KSl-qZntQ85scnqwP8k'), ('width', 38), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/23PRKGoP3FUGhD9roP1lrQ/-9NkQMMg0mPbZsSQenA6RH07wUt24ZmCMDsEVPHJYz143xONzFWOWZRg4rWXHQlRrM7DXVX043gqYXXBGkTkhSi-HqCkvsKydM4fWsbjBww/Bt800-nWeS1c5z1fKtJ1YzFi7G-Ofd3eODSLxu2ZaeI'), ('width', 327), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1XfEbUYOO0xMqV3JUkbkag/nXCjuiDj8PVuqVxlatzaBPg5ce4CSu1mLqH_oF5XBUijTlPnZfpHuxcfCyQ8bfwb6R15dDL73B8Sa_9iY6O7rT0CtwuX6JFotZL_K2refUU/eI-oPkMeTjLzZKHYfvnI7XgnnryNxa1PcQfJ6FSigP0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/source-measure-units/2400-standard-series-sourcemeter,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2400.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2400,13000.0,,,,"from typing import Any

from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping
from qcodes.validators import Enum, Strings


class Keithley2400(VisaInstrument):
    """"""
    QCoDeS driver for the Keithley 2400 voltage source.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_parameter(
            ""rangev"",
            get_cmd=""SENS:VOLT:RANG?"",
            get_parser=float,
            set_cmd=""SOUR:VOLT:RANG {:f}"",
            label=""Voltage range"",
        )

        self.add_parameter(
            ""rangei"",
            get_cmd=""SENS:CURR:RANG?"",
            get_parser=float,
            set_cmd=""SOUR:CURR:RANG {:f}"",
            label=""Current range"",
        )

        self.add_parameter(
            ""compliancev"",
            get_cmd=""SENS:VOLT:PROT?"",
            get_parser=float,
            set_cmd=""SENS:VOLT:PROT {:f}"",
            label=""Voltage Compliance"",
        )

        self.add_parameter(
            ""compliancei"",
            get_cmd=""SENS:CURR:PROT?"",
            get_parser=float,
            set_cmd=""SENS:CURR:PROT {:f}"",
            label=""Current Compliance"",
        )

        self.add_parameter(
            ""volt"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._volt_parser,
            set_cmd="":SOUR:VOLT:LEV {:.8f}"",
            label=""Voltage"",
            unit=""V"",
            docstring=""Sets voltage in 'VOLT' mode. ""
            ""Get returns measured voltage if ""
            ""sensing 'VOLT' otherwise it returns ""
            ""setpoint value. ""
            ""Note that it is an error to read voltage with ""
            ""output off"",
        )

        self.add_parameter(
            ""curr"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._curr_parser,
            set_cmd="":SOUR:CURR:LEV {:.8f}"",
            label=""Current"",
            unit=""A"",
            docstring=""Sets current in 'CURR' mode. ""
            ""Get returns measured current if ""
            ""sensing 'CURR' otherwise it returns ""
            ""setpoint value. ""
            ""Note that it is an error to read current with ""
            ""output off"",
        )

        self.add_parameter(
            ""mode"",
            vals=Enum(""VOLT"", ""CURR""),
            get_cmd="":SOUR:FUNC?"",
            set_cmd=self._set_mode_and_sense,
            label=""Mode"",
        )

        self.add_parameter(
            ""sense"",
            vals=Strings(),
            get_cmd="":SENS:FUNC?"",
            set_cmd=':SENS:FUNC ""{:s}""',
            label=""Sense mode"",
        )

        self.add_parameter(
            ""output"",
            set_cmd="":OUTP:STAT {}"",
            get_cmd="":OUTP:STAT?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""nplcv"",
            get_cmd=""SENS:VOLT:NPLC?"",
            get_parser=float,
            set_cmd=""SENS:VOLT:NPLC {:f}"",
            label=""Voltage integration time"",
        )

        self.add_parameter(
            ""nplci"",
            get_cmd=""SENS:CURR:NPLC?"",
            get_parser=float,
            set_cmd=""SENS:CURR:NPLC {:f}"",
            label=""Current integration time"",
        )

        self.add_parameter(
            ""resistance"",
            get_cmd=self._get_read_output_protected,
            get_parser=self._resistance_parser,
            label=""Resistance"",
            unit=""Ohm"",
            docstring=""Measure resistance from current and voltage ""
            ""Note that it is an error to read current ""
            ""and voltage with output off"",
        )

        self.write("":TRIG:COUN 1;:FORM:ELEM VOLT,CURR"")
        # This line sends 2 commands to the instrument:
        # "":TRIG:COUN 1"" sets the trigger count to 1 so that each READ? returns
        # only 1 measurement result.
        # "":FORM:ELEM VOLT,CURR"" sets the output string formatting of the the
        # Keithley 2400 to return ""{voltage}, {current}"".
        # Default value on instrument reset is ""VOLT, CURR, RES, TIME, STATUS"";
        # however, resistance, status, and time are unused in this driver and
        # so are omitted.
        # These commands do not reset the instrument but do the minimal amount
        # to ensure that voltage and current parameters can be read from the
        # instrument, in the event that output formatting of the instrument was
        # previously changed to some other unknown state.
        self.connect_message()

    def _get_read_output_protected(self) -> str:
        """"""
        This wrapper function around "":READ?"" exists because calling
        "":READ?"" on an instrument with output disabled is an error.
        So first we check that output is on and if not we return
        nan for volt, curr etc.
        """"""
        output = self.output.get_latest()
        if output is None:
            # if get_latest returns None we have
            # to ask the instrument for the status of output
            output = self.output.get()

        if output == 1:
            msg = self.ask("":READ?"")
        else:
            raise RuntimeError(""Cannot perform read with output off"")
        return msg

    def _set_mode_and_sense(self, msg: str) -> None:
        # This helps set the correct read out curr/volt
        if msg == ""VOLT"":
            self.sense(""CURR"")
        elif msg == ""CURR"":
            self.sense(""VOLT"")
        else:
            raise AttributeError(""Mode does not exist"")
        self.write(f"":SOUR:FUNC {msg:s}"")

    def reset(self) -> None:
        """"""
        Reset the instrument. When the instrument is reset, it performs the
        following actions.

            Returns the SourceMeter to the GPIB default conditions.

            Cancels all pending commands.

            Cancels all previously send `*OPC` and `*OPC?`
        """"""
        self.write("":*RST"")

    def _volt_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        return fields[0]

    def _curr_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        return fields[1]

    def _resistance_parser(self, msg: str) -> float:
        fields = [float(x) for x in msg.split("","")]
        res = fields[0] / fields[1]
        return res
"
94,5420.0,USA,"PXI source/measure units are the source and measurement resources of voltage and current for test applications requiring high accuracy, high resolution, and measurement flexibility

",KTM 960 X,329.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,"Write a Python script that uses Qcodes to connect to a KEYSIGHT M960(X --> Series)A Power Meters, Power Supplies",https://www.keysight.com/us/en/products/source-measure-units-smu.html,"['Power Meters', 'Power Supplies']","Keysight provides a wide range of source measure units (SMU) from precision, application-specific, general-purpose, to basic instruments. Keysight SMUs precisely force and simultaneously measure voltage and/or current.

",KEYSIGHT M960(X --> Series)A,,"[OrderedDict([('id', 'attYFiY8awycga5u9'), ('width', 1600), ('height', 1067), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eCWMXzQCP4v6vbr-tuETHA/Mm_uGN19zR3tWHNyUeY_71jVUQLswUCigwLG7yD_1Z5CiYRciOYcObtV_HMXNIS2smwid6pU0u8syfOCjweO6di-3mpaq7UY_LB9-FvoAbw/JjdCGhTGKXreJrgWNRzSw90gsArNbyZgXZmOr-CKxJ0'), ('filename', 'PROD-3075050-01.png'), ('size', 1143931), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Tgbc-I-ku0pInuzCSYI9Rw/scrsWeinFkP8BlipkjnI7TQrvw4VD8C1Cp-kn8DMgwRb2wWqwnHdoyba95AFgwyu4Wvw97TYhxQsCpwVb1TjdA/L1SnBdLvButrz0PZpObw-EG56Jmo9XrfK-ltbKTmxb8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Lz6SIy7ThOAtxTDRtAKtGA/LKdQakDBHU3HF_RTgPVWSU600f7k0q6S9bciFzRLdHVRxQyxveSI2RE6f0Wo6LmqBVJR0-udZp0cpjArVVy8Tw/-oV1YXvOv4yZ05bNuwSfasgtDmfI5zGkn1cmWNEsU9w'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qxtrr1bxheQKGVs67dEDiA/jwQ7rw1gw2uPBlsbStLS-2-QXvZAW-dyTEolae8XoMK2qmnDHKSZA2AJmLDuaktQOHcTkOGNWPALd5IW_bW1iw/QhqavcnXexcEsyoL3zxbhYCdlRxGHlzfuOIcicImrcE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/products/source-measure-units-smu/pxi-source-measure-units.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtM960x.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightM960x,,,,,"import ctypes
from functools import partial
from typing import Any, Optional

import qcodes.validators as vals
from qcodes.instrument import Instrument
from qcodes.parameters import (
    MultiParameter,
    ParamRawDataType,
    create_on_off_val_mapping,
)

from .KtM960xDefs import *  # noqa F403


class Measure(MultiParameter):
    def __init__(self, name: str, instrument: ""KeysightM960x"") -> None:
        super().__init__(name=name,
                         names=(""voltage"", ""current"", ""resistance"", ""status"",
                                ""timestamp"", ""source""),
                         shapes=((), (), (), (), (), ()),
                         units=(""V"", ""A"", ""Ohm"", """", """", """"),
                         instrument=instrument,
                         labels=""Measurement Data"",
                         docstring=""param that returns measurement values"")
        self.instrument: ""KeysightM960x""

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        return self.instrument._measure()


class KeysightM960x(Instrument):
    """"""
    Provide a wrapper for the Keysight KtM960x DAC. This driver provides an
    interface into the IVI-C driver provided by Keysight. The .dll is installed
    by default into C:\\Program Files\\IVI Foundation\\IVI\\Bin\\KtM960x_64.dll
    but a different path can be supplied to the constructor
    """"""

    _default_buf_size = 256

    def __init__(self,
                 name: str,
                 address: str,
                 options: str = """",
                 dll_path: str = r""C:\Program Files\IVI ""
                                 r""Foundation\IVI\Bin\KtM960x_64.dll"",
                 **kwargs: Any) -> None:
        super().__init__(name, **kwargs)

        self._address = bytes(address, ""ascii"")
        self._options = bytes(options, ""ascii"")
        self._session = ctypes.c_int(0)
        self._dll_loc = dll_path
        self._dll = ctypes.cdll.LoadLibrary(self._dll_loc)

        self.add_parameter('output',
                           label=""Source Output Enable"",
                           get_cmd=partial(self._get_vi_bool,
                                           KTM960X_ATTR_OUTPUT_ENABLED),
                           set_cmd=partial(self._set_vi_bool,
                                           KTM960X_ATTR_OUTPUT_ENABLED),
                           val_mapping=create_on_off_val_mapping(on_val=True,
                                                                 off_val=False)
                           )

        self.add_parameter('voltage_level',
                           label=""Source Voltage Level"",
                           unit=""Volt"",
                           get_cmd=partial(self._get_vi_real64,
                                           KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL),
                           set_cmd=partial(self._set_vi_real64,
                                           KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL),
                           vals=vals.Numbers(-210, 210))

        self.add_parameter(""current_range"",
                           label=""Output Current Range"",
                           unit=""Amp"",
                           vals=vals.Numbers(1e-9, 300e-3),
                           get_cmd=partial(self._get_vi_real64,
                                           KTM960X_ATTR_OUTPUT_CURRENT_RANGE),
                           set_cmd=partial(self._set_vi_real64,
                                           KTM960X_ATTR_OUTPUT_CURRENT_RANGE)
                           )

        self.add_parameter(""measure_current_range"",
                           label=""Current Measurement Range"",
                           unit=""Amp"",
                           get_cmd=partial(
                               self._get_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE),
                           set_cmd=partial(
                               self._set_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE),
                           vals=vals.Numbers(1e-9, 300e-3),
                           )

        self.add_parameter(""measure_current_time"",
                           label=""Current Measurement Integration Time"",
                           unit=""Seconds"",
                           get_cmd=partial(
                               self._get_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE),
                           set_cmd=partial(
                               self._set_vi_real64,
                               KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE),
                           vals=vals.Numbers(800e-9, 2)
                           )

        self.add_parameter(""measure_data"",
                           parameter_class=Measure)

        self._get_driver_desc = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_DESCRIPTION)
        self._get_driver_prefix = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_PREFIX)
        self._get_driver_revision = partial(
            self._get_vi_string, KTM960X_ATTR_SPECIFIC_DRIVER_REVISION)
        self._get_firmware_revision = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_FIRMWARE_REVISION)
        self._get_model = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_MODEL)
        self._get_serial_number = partial(
            self._get_vi_string, KTM960X_ATTR_MODULE_SERIAL_NUMBER)
        self._get_manufacturer = partial(
            self._get_vi_string, KTM960X_ATTR_INSTRUMENT_MANUFACTURER)

        self._connect()

        self.connect_message()

    def _connect(self) -> None:
        status = self._dll.KtM960x_InitWithOptions(self._address,
                                                   1,
                                                   1,
                                                   self._options,
                                                   ctypes.byref(self._session))
        if status:
            raise SystemError(f""connection to device failed! error: {status}"")

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""generates the ``*IDN`` dictionary for qcodes""""""

        id_dict: dict[str, Optional[str]] = {
            'firmware': self._get_firmware_revision(),
            'model': self._get_model(),
            'serial': self._get_serial_number(),
            'vendor': self._get_manufacturer(),
            'driver desc': self._get_driver_desc(),
            'driver prefix': self._get_driver_prefix(),
            'driver revision': self._get_driver_revision()
        }
        return id_dict

    def _measure(self) -> tuple[ParamRawDataType, ...]:

        # Setup the output
        self._set_vi_int(KTM960X_ATTR_OUTPUT_PRIORITY_MODE,
                         KTM960X_VAL_PRIORITY_MODE_VOLTAGE)
        self._set_vi_int(KTM960X_ATTR_OUTPUT_OPERATION_MODE,
                         KTM960X_VAL_OUTPUT_OPERATION_MODE_STANDARD)
        self._set_vi_int(KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE,
                         KTM960X_VAL_ACQUISITION_MODE_NORMAL)

        ch_num_buf = (ctypes.c_int32 * 1)()
        val_buf = (ctypes.c_double * 1024)()
        actual_size = ctypes.c_int32(0)
        ch_num_buf[0] = 1
        status = self._dll.KtM960x_MeasurementMeasure(
            self._session,
            KTM960X_VAL_MEASUREMENT_TYPE_ALL,
            1,
            ch_num_buf,
            1024,
            val_buf,
            ctypes.byref(actual_size)
        )

        if status:
            raise ValueError(f""Driver error: {status}"")
        # This might be a bit slow?
        # Returned as [voltage, current, resistance, status,
        #                                               timestamp, and source]
        v = list(val_buf)[0:actual_size.value]

        # 'voltage': v[0], 'current': v[1], 'resistance': v[2], 'status': v[3],
        # 'timestamp': v[4], 'source': v[5]
        return v[0], v[1], v[2], v[3], v[4], v[5]

    # Query the driver for errors
    def get_errors(self) -> dict[int, str]:
        error_code = ctypes.c_int(-1)
        error_message = ctypes.create_string_buffer(256)
        error_dict = dict()
        while error_code.value != 0:
            status = self._dll.KtM960x_error_query(
                self._session, ctypes.byref(error_code), error_message)
            assert(status == 0)
            error_dict[error_code.value] = error_message.value.decode('utf-8')

        return error_dict

    # Generic functions for reading/writing different attributes
    def _get_vi_string(self, attr: int) -> str:
        s = ctypes.create_string_buffer(self._default_buf_size)
        status = self._dll.KtM960x_GetAttributeViString(self._session,
                                                        b"""",
                                                        attr,
                                                        self._default_buf_size,
                                                        s)
        if status:
            raise ValueError(f""Driver error: {status}"")
        return s.value.decode('utf-8')

    def _get_vi_bool(self, attr: int) -> bool:
        s = ctypes.c_uint16(0)
        status = self._dll.KtM960x_GetAttributeViBoolean(self._session, b"""",
                                                         attr, ctypes.byref(s))
        if status:
            raise ValueError(f""Driver error: {status}"")
        return bool(s)

    def _set_vi_bool(self, attr: int, value: bool) -> None:
        v = ctypes.c_uint16(1) if value else ctypes.c_uint16(0)
        status = self._dll.KtM960x_SetAttributeViBoolean(self._session, b"""",
                                                         attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_real64(self, attr: int) -> float:
        s = ctypes.c_double(0)
        status = self._dll.KtM960x_GetAttributeViReal64(self._session, b"""",
                                                        attr, ctypes.byref(s))

        if status:
            raise ValueError(f""Driver error: {status}"")
        return float(s.value)

    def _set_vi_real64(self, attr: int, value: float) -> None:
        v = ctypes.c_double(value)
        status = self._dll.KtM960x_SetAttributeViReal64(self._session, b"""",
                                                        attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _set_vi_int(self, attr: int, value: int) -> None:
        v = ctypes.c_int32(value)
        status = self._dll.KtM960x_SetAttributeViInt32(self._session, b"""",
                                                       attr, v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_int(self, attr: int) -> int:
        v = ctypes.c_int32(0)
        status = self._dll.KtM960x_GetAttributeViInt32(self._session, b"""",
                                                       attr, ctypes.byref(v))
        if status:
            raise ValueError(f""Driver error: {status}"")
        return int(v.value)

    def close(self) -> None:
        self._dll.KtM960x_close(self._session)
        super().close()


KtM960x = KeysightM960x
""Alias for backwards compatibility""
"
96,5420.0,USA,"PXA signal analyzers are ideally suited for high-performance research and development (R&D) applications in aerospace/defense and commercial wireless communications. The PXA analyzes signals over wider bandwidths, reduces measurement uncertainty, and reveals previously hidden signals with noise floor extension (NFE). Unravel complex signals through the PXA’s broad set of measurement applications and demodulation capabilities or add real-time spectrum analysis capabilities with an upgradeable option.",Keysight N 9030 B,282.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N9030B PXA RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT N9030B PXA,https://www.keysight.com/us/en/assets/7018-05093/data-sheets/5992-1317.pdf,"[OrderedDict([('id', 'attaE3LeIhFoN0BuG'), ('width', 500), ('height', 242), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PmDnN48isEYowVnIXTAFRw/q7oHGMyJb8I_TvIvmOIteo_hjsCOU2nYieJKYhsX32RsfZ0SlGcLpgCxC_GUgJ6Ipw6jKafY74c6FQ-fPpImJ0mmyCdgEB3_dU8NOK8qe0M/gjThb7L__RniAkb1IAMiIpHr-dUNooHp7xLm58F9pgA'), ('filename', 'N9030B.2.jpg'), ('size', 27618), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Nwbju44DDCBOw9XW_POX7A/P1VueYTLaNyhIKbRVT9QpXi6uKieFZJzJbPrG9ZVfh-liClCJrrFdfagfwjOm7VgolddI3DdpiegqrHxfsGK4Q/Y0pmGRgqEkqYbMksQA-dWrIIzPYKpxIILfBExPfbguY'), ('width', 74), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DzVsbEY_pYDYfyfmSZCm0w/tmjMAbyAB8u4lV9zp2pkz0xXvIOSZ9TG9lu1FhDPesMLDDdwCxKbsrrCa6Swi2dpsMBZEbT3i8VtX80AnW9EIQ/XBSis-NJ8OhY2kd-Rg3BUIqeYWd1kOPOBkqlSPfmjKI'), ('width', 500), ('height', 242)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vS422XaNccn-A0pXEDjtxQ/d3AoDUvQI3nfoX0gpAWJjLIHviRRwtMEKK9_mnLagXWK02m7N6lUhg1YSTu60AyPRF9sC-PPVFZQ4FEEuEtXuQ/KwWwfsYjNtCH2VuvsKCMPBHLRiYAammY8rsXWrng7R8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/N9030B/pxa-signal-analyzer-multi-touch-2-hz-50-ghz.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_N9030B.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN9030B,,,,,"from __future__ import annotations

from typing import Any

import numpy as np

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Numbers


class FrequencyAxis(Parameter):
    def __init__(
        self,
        start: Parameter,
        stop: Parameter,
        npts: Parameter,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        super().__init__(*args, **kwargs)
        self._start: Parameter = start
        self._stop: Parameter = stop
        self._npts: Parameter = npts

    def get_raw(self) -> ParamRawDataType:
        start_val = self._start()
        stop_val = self._stop()
        npts_val = self._npts()
        assert start_val is not None
        assert stop_val is not None
        assert npts_val is not None
        return np.linspace(start_val, stop_val, npts_val)


class Trace(ParameterWithSetpoints):
    def __init__(self, number: int, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.instrument: (
            KeysightN9030BSpectrumAnalyzerMode | KeysightN9030BPhaseNoiseMode
        )
        self.root_instrument: KeysightN9030B

        self.number = number

    def get_raw(self) -> ParamRawDataType:
        return self.instrument._get_data(trace_num=self.number)


class KeysightN9030BSpectrumAnalyzerMode(InstrumentChannel):
    """"""
    Spectrum Analyzer Mode for Keysight N9030B instrument.
    """"""

    def __init__(self, parent: KeysightN9030B, name: str, *arg: Any, **kwargs: Any):
        super().__init__(parent, name, *arg, **kwargs)

        self._min_freq = -8e7
        self._valid_max_freq: dict[str, float] = {
            ""503"": 3.7e9,
            ""508"": 8.5e9,
            ""513"": 13.8e9,
            ""526"": 27e9,
            ""544"": 44.5e9,
        }
        opt: str | None = None
        for hw_opt_for_max_freq in self._valid_max_freq.keys():
            if hw_opt_for_max_freq in self.root_instrument._options():
                opt = hw_opt_for_max_freq
        assert opt is not None
        self._max_freq = self._valid_max_freq[opt]

        self.add_parameter(
            name=""start"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:STARt?"",
            set_cmd=self._set_start,
            get_parser=float,
            vals=Numbers(self._min_freq, self._max_freq - 10),
            docstring=""start frequency for the sweep"",
        )

        self.add_parameter(
            name=""stop"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:STOP?"",
            set_cmd=self._set_stop,
            get_parser=float,
            vals=Numbers(self._min_freq + 10, self._max_freq),
            docstring=""stop frequency for the sweep"",
        )

        self.add_parameter(
            name=""center"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:CENTer?"",
            set_cmd=self._set_center,
            get_parser=float,
            vals=Numbers(self._min_freq + 5, self._max_freq - 5),
            docstring=""Sets and gets center frequency"",
        )

        self.add_parameter(
            name=""span"",
            unit=""Hz"",
            get_cmd="":SENSe:FREQuency:SPAN?"",
            set_cmd=self._set_span,
            get_parser=float,
            vals=Numbers(10, self._max_freq - self._min_freq),
            docstring=""Changes span of frequency"",
        )

        self.add_parameter(
            name=""npts"",
            get_cmd="":SENSe:SWEep:POINts?"",
            set_cmd=self._set_npts,
            get_parser=int,
            vals=Ints(1, 20001),
            docstring=""Number of points for the sweep"",
        )

        self.add_parameter(
            name=""sweep_time"",
            label=""Sweep time"",
            get_cmd="":SENSe:SWEep:TIME?"",
            set_cmd="":SENSe:SWEep:TIME {}"",
            get_parser=float,
            unit=""s"",
            docstring=""gets sweep time"",
        )

        self.add_parameter(
            name=""auto_sweep_time_enabled"",
            get_cmd="":SENSe:SWEep:TIME:AUTO?"",
            set_cmd=self._enable_auto_sweep_time,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""enables auto sweep time"",
        )

        self.add_parameter(
            name=""auto_sweep_type_enabled"",
            get_cmd="":SENSe:SWEep:TYPE:AUTO?"",
            set_cmd=self._enable_auto_sweep_type,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""enables auto sweep type"",
        )

        self.add_parameter(
            name=""sweep_type"",
            get_cmd="":SENSe:SWEep:TYPE?"",
            set_cmd=self._set_sweep_type,
            val_mapping={
                ""fft"": ""FFT"",
                ""sweep"": ""SWE"",
            },
            docstring=""Sets up sweep type. Possible options are 'fft' and 'sweep'."",
        )

        self.add_parameter(
            name=""freq_axis"",
            label=""Frequency"",
            unit=""Hz"",
            start=self.start,
            stop=self.stop,
            npts=self.npts,
            vals=Arrays(shape=(self.npts.get_latest,)),
            parameter_class=FrequencyAxis,
            docstring=""Creates frequency axis for the sweep from start, ""
            ""stop and npts values."",
        )

        self.add_parameter(
            name=""trace"",
            label=""Trace"",
            unit=""dB"",
            number=1,
            vals=Arrays(shape=(self.npts.get_latest,)),
            setpoints=(self.freq_axis,),
            parameter_class=Trace,
            docstring=""Gets trace data."",
        )

    def _set_start(self, val: float) -> None:
        """"""
        Sets start frequency
        """"""
        stop = self.stop()
        if val >= stop:
            raise ValueError(
                f""Start frequency must be smaller than stop ""
                f""frequency. Provided start freq is: {val} Hz and ""
                f""set stop freq is: {stop} Hz""
            )

        self.write(f"":SENSe:FREQuency:STARt {val}"")

        start = self.start()
        if abs(val - start) >= 1:
            self.log.warning(f""Could not set start to {val} setting it to {start}"")

    def _set_stop(self, val: float) -> None:
        """"""
        Sets stop frequency
        """"""
        start = self.start()
        if val <= start:
            raise ValueError(
                f""Stop frequency must be larger than start ""
                f""frequency. Provided stop freq is: {val} Hz and ""
                f""set start freq is: {start} Hz""
            )

        self.write(f"":SENSe:FREQuency:STOP {val}"")

        stop = self.stop()
        if abs(val - stop) >= 1:
            self.log.warning(f""Could not set stop to {val} setting it to {stop}"")

    def _set_center(self, val: float) -> None:
        """"""
        Sets center frequency and updates start and stop frequencies if they
        change.
        """"""
        self.write(f"":SENSe:FREQuency:CENTer {val}"")
        self.update_trace()

    def _set_span(self, val: float) -> None:
        """"""
        Sets frequency span and updates start and stop frequencies if they
        change.
        """"""
        self.write(f"":SENSe:FREQuency:SPAN {val}"")
        self.update_trace()

    def _set_npts(self, val: int) -> None:
        """"""
        Sets number of points for sweep
        """"""
        self.write(f"":SENSe:SWEep:POINts {val}"")

    def _enable_auto_sweep_time(self, val: str) -> None:
        """"""
        Enables auto sweep time
        """"""
        self.write(f"":SENSe:SWEep:TIME:AUTO {val}"")

    def _enable_auto_sweep_type(self, val: str) -> None:
        """"""
        Enables auto sweep type
        """"""
        self.write(f"":SENSe:SWEep:TYPE:AUTO {val}"")

    def _set_sweep_type(self, val: str) -> None:
        """"""
        Sets sweep type
        """"""
        self.write(f"":SENSe:SWEep:TYPE {val}"")

    def _get_data(self, trace_num: int) -> ParamRawDataType:
        """"""
        Gets data from the measurement.
        """"""
        try:
            timeout = self.sweep_time() + self.root_instrument._additional_wait
            with self.root_instrument.timeout.set_to(timeout):
                data_str = self.ask(
                    f"":READ:"" f""{self.root_instrument.measurement()}"" f""{trace_num}?""
                )
                data = np.array(data_str.rstrip().split("","")).astype(""float64"")
        except TimeoutError as e:
            raise TimeoutError(""Couldn't receive any data. Command timed out."") from e

        trace_data = data[1::2]
        return trace_data

    def update_trace(self) -> None:
        """"""
        Updates start and stop frequencies whenever span of/or center frequency
        is updated.
        """"""
        self.start()
        self.stop()

    def setup_swept_sa_sweep(self, start: float, stop: float, npts: int) -> None:
        """"""
        Sets up the Swept SA measurement sweep for Spectrum Analyzer Mode.
        """"""
        self.root_instrument.mode(""SA"")
        if ""SAN"" in self.root_instrument._available_meas():
            self.root_instrument.measurement(""SAN"")
        else:
            raise RuntimeError(
                ""Swept SA measurement is not available on your ""
                ""Keysight N9030B instrument with Spectrum ""
                ""Analyzer mode.""
            )
        self.start(start)
        self.stop(stop)
        self.npts(npts)

    def autotune(self) -> None:
        """"""
        Autotune quickly get to the most likely signal of interest, and
        position it optimally on the display.
        """"""
        self.write("":SENS:FREQuency:TUNE:IMMediate"")
        self.center()


class KeysightN9030BPhaseNoiseMode(InstrumentChannel):
    """"""
    Phase Noise Mode for Keysight N9030B instrument.
    """"""

    def __init__(self, parent: KeysightN9030B, name: str, *arg: Any, **kwargs: Any):
        super().__init__(parent, name, *arg, **kwargs)

        self._min_freq = 1
        self._valid_max_freq: dict[str, float] = {
            ""503"": 3699999995,
            ""508"": 8499999995,
            ""513"": 13799999995,
            ""526"": 26999999995,
            ""544"": 44499999995,
        }
        opt: str | None = None
        for hw_opt_for_max_freq in self._valid_max_freq.keys():
            if hw_opt_for_max_freq in self.root_instrument._options():
                opt = hw_opt_for_max_freq
        assert opt is not None
        self._max_freq = self._valid_max_freq[opt]

        self.add_parameter(
            name=""npts"",
            get_cmd="":SENSe:LPLot:SWEep:POINts?"",
            set_cmd="":SENSe:LPLot:SWEep:POINts {}"",
            get_parser=int,
            vals=Ints(601, 20001),
            docstring=""Number of points for the sweep"",
        )

        self.add_parameter(
            name=""start_offset"",
            unit=""Hz"",
            get_cmd="":SENSe:LPLot:FREQuency:OFFSet:STARt?"",
            set_cmd=self._set_start_offset,
            get_parser=float,
            vals=Numbers(self._min_freq, self._max_freq - 10),
            docstring=""start frequency offset for the plot"",
        )

        self.add_parameter(
            name=""stop_offset"",
            unit=""Hz"",
            get_cmd="":SENSe:LPLot:FREQuency:OFFSet:STOP?"",
            set_cmd=self._set_stop_offset,
            get_parser=float,
            vals=Numbers(self._min_freq + 99, self._max_freq),
            docstring=""stop frequency offset for the plot"",
        )

        self.add_parameter(
            name=""signal_tracking_enabled"",
            get_cmd="":SENSe:FREQuency:CARRier:TRACk?"",
            set_cmd="":SENSe:FREQuency:CARRier:TRACk {}"",
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Gets/Sets signal tracking. When signal tracking is ""
            ""enabled carrier signal is repeatedly realigned. Signal ""
            ""Tracking assumes the new acquisition occurs repeatedly ""
            ""without pause."",
        )

        self.add_parameter(
            name=""freq_axis"",
            label=""Frequency"",
            unit=""Hz"",
            start=self.start_offset,
            stop=self.stop_offset,
            npts=self.npts,
            vals=Arrays(shape=(self.npts.get_latest,)),
            parameter_class=FrequencyAxis,
            docstring=""Creates frequency axis for the sweep from ""
            ""start_offset, stop_offset and npts values."",
        )

        self.add_parameter(
            name=""trace"",
            label=""Trace"",
            unit=""dB"",
            number=3,
            vals=Arrays(shape=(self.npts.get_latest,)),
            setpoints=(self.freq_axis,),
            parameter_class=Trace,
            docstring=""Gets trace data."",
        )

    def _set_start_offset(self, val: float) -> None:
        """"""
        Sets start offset for frequency in the plot
        """"""
        stop_offset = self.stop_offset()
        self.write(f"":SENSe:LPLot:FREQuency:OFFSet:STARt {val}"")
        start_offset = self.start_offset()

        if abs(val - start_offset) >= 1:
            self.log.warning(
                f""Could not set start offset to {val} setting it to "" f""{start_offset}""
            )
        if val >= stop_offset or abs(val - stop_offset) < 10:
            self.log.warning(
                f""Provided start frequency offset {val} Hz was ""
                f""greater than preset stop frequency offset ""
                f""{stop_offset} Hz. Provided start frequency ""
                f""offset {val} Hz is set and new stop freq offset""
                f"" is: {self.stop_offset()} Hz.""
            )

    def _set_stop_offset(self, val: float) -> None:
        """"""
        Sets stop offset for frequency in the plot
        """"""
        start_offset = self.start_offset()
        self.write(f"":SENSe:LPLot:FREQuency:OFFSet:STOP {val}"")
        stop_offset = self.stop_offset()

        if abs(val - stop_offset) >= 1:
            self.log.warning(
                f""Could not set stop offset to {val} setting it to "" f""{stop_offset}""
            )

        if val <= start_offset or abs(val - start_offset) < 10:
            self.log.warning(
                f""Provided stop frequency offset {val} Hz was ""
                f""less than preset start frequency offset ""
                f""{start_offset} Hz. Provided stop frequency ""
                f""offset {val} Hz is set and new start freq offset""
                f"" is: {self.start_offset()} Hz.""
            )

    def _get_data(self, trace_num: int) -> ParamRawDataType:
        """"""
        Gets data from the measurement.
        """"""
        raw_data = self.ask(f"":READ:{self.root_instrument.measurement()}{1}?"")
        trace_res_details = np.array(raw_data.rstrip().split("","")).astype(""float64"")

        if len(trace_res_details) != 7 or (
            len(trace_res_details) >= 1 and trace_res_details[0] < -50
        ):
            self.log.warning(""Carrier(s) Incorrect or Missing!"")
            return -1 * np.ones(self.npts())

        try:
            data_str = self.ask(
                f"":READ:{self.root_instrument.measurement()}"" f""{trace_num}?""
            )
            data = np.array(data_str.rstrip().split("","")).astype(""float64"")
        except TimeoutError as e:
            raise TimeoutError(""Couldn't receive any data. Command timed out."") from e

        trace_data = data[1::2]
        return trace_data

    def setup_log_plot_sweep(
        self, start_offset: float, stop_offset: float, npts: int
    ) -> None:
        """"""
        Sets up the Log Plot measurement sweep for Phase Noise Mode.
        """"""
        self.root_instrument.mode(""PNOISE"")
        if ""LPL"" in self.root_instrument._available_meas():
            self.root_instrument.measurement(""LPL"")
        else:
            raise RuntimeError(
                ""Log Plot measurement is not available on your ""
                ""Keysight N9030B instrument with Phase Noise ""
                ""mode.""
            )

        self.start_offset(start_offset)
        self.stop_offset(stop_offset)
        self.npts(npts)

    def autotune(self) -> None:
        """"""
        On autotune, the measurement automatically searches for and tunes to
        the strongest signal in the full span of the analyzer.
        """"""
        self.write("":SENSe:FREQuency:CARRier:SEARch"")
        self.start_offset()
        self.stop_offset()


class KeysightN9030B(VisaInstrument):
    """"""
    Driver for Keysight N9030B PXA signal analyzer. Keysight N9030B PXA
    signal analyzer is part of Keysight X-Series Multi-touch Signal
    Analyzers.
    This driver allows Swept SA measurements in Spectrum Analyzer mode and
    Log Plot measurements in Phase Noise mode of the instrument.

    Args:
        name
        address
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\n"", **kwargs)

        self._min_freq: float
        self._max_freq: float
        self._additional_wait: float = 1

        self.add_parameter(
            name=""mode"",
            get_cmd="":INSTrument:SELect?"",
            set_cmd="":INSTrument:SELect {}"",
            vals=Enum(*self._available_modes()),
            docstring=""Allows setting of different modes present and licensed ""
            ""for the instrument."",
        )

        self.add_parameter(
            name=""measurement"",
            get_cmd="":CONFigure?"",
            set_cmd="":CONFigure:{}"",
            vals=Enum(""SAN"", ""LPL""),
            docstring=""Sets measurement type from among the available ""
            ""measurement types."",
        )

        self.add_parameter(
            name=""cont_meas"",
            initial_value=False,
            get_cmd="":INITiate:CONTinuous?"",
            set_cmd=self._enable_cont_meas,
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""Enables or disables continuous measurement."",
        )

        self.add_parameter(
            name=""format"",
            get_cmd="":FORMat:TRACe:DATA?"",
            set_cmd="":FORMat:TRACe:DATA {}"",
            val_mapping={
                ""ascii"": ""ASCii"",
                ""int32"": ""INTeger,32"",
                ""real32"": ""REAL,32"",
                ""real64"": ""REAL,64"",
            },
            docstring=""Sets up format of data received"",
        )

        if ""SA"" in self._available_modes():
            sa_mode = KeysightN9030BSpectrumAnalyzerMode(self, name=""sa"")
            self.add_submodule(""sa"", sa_mode)
        else:
            self.log.info(""Spectrum Analyzer mode is not available on this instrument."")

        if ""PNOISE"" in self._available_modes():
            pnoise_mode = KeysightN9030BPhaseNoiseMode(self, name=""pn"")
            self.add_submodule(""pn"", pnoise_mode)
        else:
            self.log.info(""Phase Noise mode is not available on this instrument."")
        self.connect_message()

    def _available_modes(self) -> tuple[str, ...]:
        """"""
        Returns present and licensed modes for the instrument.
        """"""
        available_modes = self.ask("":INSTrument:CATalog?"")
        av_modes = available_modes[1:-1].split("","")
        modes: tuple[str, ...] = ()
        for i, mode in enumerate(av_modes):
            if i == 0:
                modes = modes + (mode.split("" "")[0],)
            else:
                modes = modes + (mode.split("" "")[1],)
        return modes

    def _available_meas(self) -> tuple[str, ...]:
        """"""
        Gives available measurement with a given mode for the instrument
        """"""
        available_meas = self.ask("":CONFigure:CATalog?"")
        av_meas = available_meas[1:-1].split("","")
        measurements: tuple[str, ...] = ()
        for i, meas in enumerate(av_meas):
            if i == 0:
                measurements = measurements + (meas,)
            else:
                measurements = measurements + (meas[1:],)
        return measurements

    def _enable_cont_meas(self, val: str) -> None:
        """"""
        Sets continuous measurement to ON or OFF.
        """"""
        self.write(f"":INITiate:CONTinuous {val}"")

    def _options(self) -> tuple[str, ...]:
        """"""
        Returns installed options numbers.
        """"""
        options_raw = self.ask(""*OPT?"")
        return tuple(options_raw[1:-1].split("",""))

    def reset(self) -> None:
        """"""
        Reset the instrument by sending the RST command
        """"""
        self.write(""*RST"")

    def abort(self) -> None:
        """"""
        Aborts the measurement
        """"""
        self.write("":ABORt"")
"
99,9000.0,UK,"0 to >15V; 0 to >5A (75W nominal power)
",AIM TTI EL 155 R,51.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a EL155-R Power Supplies,https://www.aimtti.com/go/er/index.php?p=elr-index,['Power Supplies'],EL-R Series DC Supplies,EL155-R,https://www.aimtti.com/go/er/index.php?p=elr-spec,"[OrderedDict([('id', 'attXbV4ojjbKKu0iy'), ('width', 284), ('height', 352), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VTbHWb0t3Kt40kuZtXvRZQ/16wwLGxqXYPXAap2zeC4zYmFaj5roWXloi-G8U0IDXd5udEUxrr1n-HjNftLdNsFNjl10sMaS9QZ0aBLCHnZKn6dxBjR5w0K3xtA6oIyXpA/a5vIUbkjwgYGiwP20l-w37GNidt0MbIz-JZV4BKYICc'), ('filename', 'EL155R.jpeg'), ('size', 28760), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Pf6Re852q38awCX-sFrViA/tBI6hrYAwVs-5TV2a7WxlgD8zEi74H387bs-r4tTpbcjxZiz5Zb-09jdAH10XA304vC6V9OEO9Ni1LEYaNSO8w/zDNvUyWSY-4nQgJr_61MghOzX1LDjtyXwtiIudfmeyU'), ('width', 29), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6qn6eHgPHMG8uo6-fJXjug/_GWcpj3kGeF-ylJG25z35mhUtEU8MJqV7HoE2pBaMiVUI4tFMR-3zWx0ymYsN_j1NN2yRqtZ2YR2M-tKMzrIpQ/lf4DxPhXlL7HJISvv122H94zyhRL8GQIOQ7Mc6mB6wY'), ('width', 284), ('height', 352)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vT4M0SoQFAP2nkODinL_mA/55UvewxZ01dt6lpfFRnJgvWY9uVxYkZAsDo12qAGhtn_rlapN0kblhNVFfKzq-kdFSrHlKPpyw7lvVx0V2J5IQ/itUxLiXaS9HBKCPpQR0mymvEisyzTwxlL2lLua2S8bk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/go/er/index.php?p=elr-spec,?? ,?? ,400.0,,,,
101,5420.0,USA,,Ktmawgdefs,286.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT MAwgDef RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"An arbitrary waveform generator (AWG or ARB) is a sophisticated signal generator that generates arbitrary waveforms within published limits of frequency range, accuracy, and output level. Unlike a function generator that produces a small set of specific waveforms, an AWG allows the user to specify a source waveform in a variety of different ways.",KEYSIGHT MAwgDef,,"[OrderedDict([('id', 'atts4XZWkT4pxuTR4'), ('width', 300), ('height', 166), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kgqmhQDWvddN6A2c0K4Bzw/oE6Nqv0IfUiTk2RtXhN08IywLflMQ0UYkQNMakKWBjrlL6HpVny7CxvB7ocbeHEihi6E3x6k8AUmDW_TER1AwdRECWQY-yVmKozlRCL-dkU/EEH9NEeCrLy9m4VurjdvYvkLXQC-6_GlK1mGYNI7F6g'), ('filename', 'PROD-2917039-01.jpeg'), ('size', 7332), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hPLvhsh_I6n7eg8MiEXVPw/EtduQHaNViCMztoBfcNVGzdlIlM_0HSNgqsfVZFtKW3d4FIRkDIv0SoxzkMD8KGCFg-SIZqGfCsucpblbXX6Pg/qKfDJKd4WR4izF9KWnqKcsNczbbKn7DDzNNGyO_3GME'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HXUIv_n0ZC00eZwHpyNVAA/ZdkLSmc5CEoJ7glbPYxKDtlCvmUNIlB9vXPrTkgqDKHdUMcKeYYcBLzimJBnBaiM5EZffUce09XqJfQ2xWhnnQ/rR2J99GHLvpr5iBA4tTe2jWvTgPRjI0VqUFRoN_f73A'), ('width', 300), ('height', 166)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zjgZY80oZlrsBSjmQPp_Kg/HJwswloDTm5FrNax3_5NfYFFC4mLgli4n2Ty08nQLbFzrlDpT8V6RAP7miZoPMpvId-PuQDNyWpcprQX6lw6vg/YbIOjenmGQKesxifZq7nWSZje3d0svKYMF8incnxBf0'), ('width', 3000), ('height', 3000)]))]))])]",,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtMAwgDefs.py,,,,,,"# ***************************************************************************
# *---------------------------- Attribute Defines ---------------------------*
# ***************************************************************************

IVI_ATTR_BASE = 1000000


IVI_INHERENT_ATTR_BASE = (
    IVI_ATTR_BASE + 50000
)  # base for inherent capability attributes

# base for IVI-defined class attributes
IVI_CLASS_ATTR_BASE = IVI_ATTR_BASE + 250000

# base for IviLxiSync attributes
IVI_LXISYNC_ATTR_BASE = IVI_ATTR_BASE + 950000


IVI_SPECIFIC_ATTR_BASE = (
    IVI_ATTR_BASE + 150000
)  # base for attributes of specific drivers


# ===== IVI Inherent Instrument Attributes ===========

# - Driver Identification

KTMAWG_ATTR_SPECIFIC_DRIVER_DESCRIPTION = (
    IVI_INHERENT_ATTR_BASE + 514
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_PREFIX = IVI_INHERENT_ATTR_BASE + 302
# ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_VENDOR = IVI_INHERENT_ATTR_BASE + 513
KTMAWG_ATTR_SPECIFIC_DRIVER_REVISION = (
    IVI_INHERENT_ATTR_BASE + 551
)  # ViString, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MAJOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 515
)  # ViInt32, read-only
KTMAWG_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MINOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 516
)  # ViInt32, read-only

# - User Options
# ViBoolean, read-write
KTMAWG_ATTR_RANGE_CHECK = IVI_INHERENT_ATTR_BASE + 2
KTMAWG_ATTR_QUERY_INSTRUMENT_STATUS = (
    IVI_INHERENT_ATTR_BASE + 3
)  # ViBoolean, read-write
# ViBoolean, read-write
KTMAWG_ATTR_CACHE = IVI_INHERENT_ATTR_BASE + 4
# ViBoolean, read-write
KTMAWG_ATTR_SIMULATE = IVI_INHERENT_ATTR_BASE + 5
# ViBoolean, read-write
KTMAWG_ATTR_RECORD_COERCIONS = IVI_INHERENT_ATTR_BASE + 6
# ViBoolean, read-write
KTMAWG_ATTR_INTERCHANGE_CHECK = IVI_INHERENT_ATTR_BASE + 21

# - Advanced Session Information
# ViString, read-only
KTMAWG_ATTR_LOGICAL_NAME = IVI_INHERENT_ATTR_BASE + 305
# ViString, read-only
KTMAWG_ATTR_IO_RESOURCE_DESCRIPTOR = IVI_INHERENT_ATTR_BASE + 304
# ViString, read-only
KTMAWG_ATTR_DRIVER_SETUP = IVI_INHERENT_ATTR_BASE + 7

# - Driver Capabilities
# ViString, read-only
KTMAWG_ATTR_GROUP_CAPABILITIES = IVI_INHERENT_ATTR_BASE + 401
KTMAWG_ATTR_SUPPORTED_INSTRUMENT_MODELS = (
    IVI_INHERENT_ATTR_BASE + 327
)  # ViString, read-only

# - Instrument Identification

KTMAWG_ATTR_INSTRUMENT_FIRMWARE_REVISION = (
    IVI_INHERENT_ATTR_BASE + 510
)  # ViString, read-only
KTMAWG_ATTR_INSTRUMENT_MANUFACTURER = (
    IVI_INHERENT_ATTR_BASE + 511
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_INSTRUMENT_MODEL = IVI_INHERENT_ATTR_BASE + 512


# ===== Instrument-Specific Attributes =====================================

# - Instrument Specific

KTMAWG_ATTR_GENERATION_SETTINGS_RESTRICTIONS = (
    IVI_SPECIFIC_ATTR_BASE + 101
)  # ViBoolean, read-only

# - System
# ViString, read-only
KTMAWG_ATTR_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 3
# ViString, read-only
KTMAWG_ATTR_SYSTEM_ABOUT = IVI_SPECIFIC_ATTR_BASE + 4
KTMAWG_ATTR_SYSTEM_GC_TIMING_OPTIMIZATION_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 5
)  # ViBoolean, read-write
KTMAWG_ATTR_SYSTEM_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 6
)  # ViBoolean, read-write
# ViInt32, read-only
KTMAWG_ATTR_SYSTEM_INSTANCE_ID = IVI_SPECIFIC_ATTR_BASE + 7
# ViString, read-only
KTMAWG_ATTR_SYSTEM_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 8
# ViInt32, read-write
KTMAWG_ATTR_SYSTEM_TIMEOUT = IVI_SPECIFIC_ATTR_BASE + 9

# - Licensing

KTMAWG_ATTR_LICENSING_HOST_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 11
)  # ViString, read-only
KTMAWG_ATTR_LICENSING_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 12
)  # ViString, read-only

# - Calibration

KTMAWG_ATTR_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 16
)  # ViString, read-only
# ViString, read-only
KTMAWG_ATTR_CALIBRATION_DUE_DATE = IVI_SPECIFIC_ATTR_BASE + 17
KTMAWG_ATTR_CALIBRATION_INSTRUMENT_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 18
)  # ViString, read-only
# ViInt32, read-only
KTMAWG_ATTR_CALIBRATION_STATUS = IVI_SPECIFIC_ATTR_BASE + 19
KTMAWG_ATTR_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 20
)  # ViString, read-only

# - Module
# ViInt32, read-only
KTMAWG_ATTR_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 23
KTMAWG_ATTR_MODULE_INSTRUMENT_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 24
)  # ViString, read-only
KTMAWG_ATTR_MODULE_MAXIMUM_RECORDED_TEMPERATURE = (
    IVI_SPECIFIC_ATTR_BASE + 25
)  # ViInt32, read-only
# ViString, read-only
KTMAWG_ATTR_MODULE_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 26
# ViString, read-only
KTMAWG_ATTR_MODULE_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 27
# ViInt32, read-only
KTMAWG_ATTR_MODULE_SLOT = IVI_SPECIFIC_ATTR_BASE + 28
# ViReal64, read-only
KTMAWG_ATTR_MODULE_TEMPERATURE = IVI_SPECIFIC_ATTR_BASE + 29

# - Calibration

KTMAWG_ATTR_MODULE_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 30
)  # ViString, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_DUE_DATE = (
    IVI_SPECIFIC_ATTR_BASE + 31
)  # ViString, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_STATUS = (
    IVI_SPECIFIC_ATTR_BASE + 32
)  # ViInt32, read-only
KTMAWG_ATTR_MODULE_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 33
)  # ViString, read-only

# - Nonvolatile

KTMAWG_ATTR_NONVOLATILE_ASSET_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 34
)  # ViString, read-write
KTMAWG_ATTR_NONVOLATILE_CAL_DUE_REMINDER = (
    IVI_SPECIFIC_ATTR_BASE + 35
)  # ViInt32, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_INSTRUMENT_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 36
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_MODULE_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 37
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_ENABLE_PERIODIC_CAL = (
    IVI_SPECIFIC_ATTR_BASE + 38
)  # ViBoolean, read-write
KTMAWG_ATTR_NONVOLATILE_INSTRUMENT_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 39
)  # ViInt32, read-write
KTMAWG_ATTR_NONVOLATILE_MODULE_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 40
)  # ViInt32, read-write
# ViString, read-write
KTMAWG_ATTR_NONVOLATILE_PASSPHRASE = IVI_SPECIFIC_ATTR_BASE + 41
KTMAWG_ATTR_NONVOLATILE_SYSTEM_IDENTIFICATION = (
    IVI_SPECIFIC_ATTR_BASE + 42
)  # ViString, read-write

# - AssetChannel
# ViInt32, read-only
KTMAWG_ATTR_ASSETCHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 60

# - PeerToPeerPort
# ViInt32, read-only
KTMAWG_ATTR_PEERTOPEERPORT_COUNT = IVI_SPECIFIC_ATTR_BASE + 45
# ViString, read-write
KTMAWG_ATTR_ACTIVE_PEERTOPEERPORT = IVI_SPECIFIC_ATTR_BASE + 46

# - DeviceSync
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_CLOCK_RATE = IVI_SPECIFIC_ATTR_BASE + 88
KTMAWG_ATTR_DEVICE_SYNC_CLOCK_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 89
)  # ViString, read-write
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_GROUP_MASK = IVI_SPECIFIC_ATTR_BASE + 90
KTMAWG_ATTR_DEVICE_SYNC_GROUP_SIGNAL = (
    IVI_SPECIFIC_ATTR_BASE + 91
)  # ViInt32, read-write
# ViInt32, read-write
KTMAWG_ATTR_DEVICE_SYNC_ROLE = IVI_SPECIFIC_ATTR_BASE + 92
KTMAWG_ATTR_DEVICE_SYNC_SLAVE_SIGNAL = (
    IVI_SPECIFIC_ATTR_BASE + 93
)  # ViInt32, read-write
# ViInt32, read-only
KTMAWG_ATTR_DEVICE_SYNC_STATE = IVI_SPECIFIC_ATTR_BASE + 94
KTMAWG_ATTR_DEVICE_SYNC_IS_ALIGNMENT_VALID = (
    IVI_SPECIFIC_ATTR_BASE + 97
)  # ViBoolean, read-only
KTMAWG_ATTR_DEVICE_SYNC_SYNC_CHANNELS = (
    IVI_SPECIFIC_ATTR_BASE + 100
)  # ViString, read-write

# - Waveform
# ViInt32, read-only
KTMAWG_ATTR_ARB_NUMBER_WAVEFORMS = IVI_SPECIFIC_ATTR_BASE + 98

# - Sequence
# ViInt32, read-only
KTMAWG_ATTR_ARB_NUMBER_SEQUENCES = IVI_SPECIFIC_ATTR_BASE + 99

# - SequenceTriggers

KTMAWG_ATTR_SEQUENCETRIGGER_MAX_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 73
)  # ViInt32, read-only
# ViInt32, read-only
KTMAWG_ATTR_SEQUENCETRIGGER_COUNT = IVI_SPECIFIC_ATTR_BASE + 74

# - Marker
# ViInt32, read-only
KTMAWG_ATTR_MARKER_COUNT = IVI_SPECIFIC_ATTR_BASE + 75
# ViInt32, read-only
KTMAWG_ATTR_MARKER_MAX_COUNT = IVI_SPECIFIC_ATTR_BASE + 76

# - External
# ViInt32, read-only
KTMAWG_ATTR_EXTERNAL_COUNT = IVI_SPECIFIC_ATTR_BASE + 79
# ViInt32, read-write
KTMAWG_ATTR_EXTERNAL_INPUT_SLOPE = IVI_SPECIFIC_ATTR_BASE + 83
KTMAWG_ATTR_EXTERNAL_OUTPUT_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 84
)  # ViInt32, read-write
# ViReal64, read-write
KTMAWG_ATTR_EXTERNAL_THRESHOLD = IVI_SPECIFIC_ATTR_BASE + 85
# ViReal64, read-write

# - TriggerBusLine
# ViInt32, read-only
KTMAWG_ATTR_TRIGGER_BUS_LINE_COUNT = IVI_SPECIFIC_ATTR_BASE + 80
KTMAWG_ATTR_TRIGGER_BUS_LINE_INPUT_SLOPE = (
    IVI_SPECIFIC_ATTR_BASE + 81
)  # ViInt32, read-write
KTMAWG_ATTR_TRIGGER_BUS_LINE_OUTPUT_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 82
)  # ViInt32, read-write
KTMAWG_ATTR_TRIGGER_BUS_LINE_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 86
)  # ViInt32, read-only

# - ReferenceClock

KTMAWG_ATTR_REF_CLOCK_IS_PHASE_LOCKED = (
    IVI_SPECIFIC_ATTR_BASE + 96
)  # ViBoolean, read-only

# - Arbitrary
# ViReal64, read-write
KTMAWG_ATTR_ARB_GAIN = IVI_CLASS_ATTR_BASE + 202
# ViReal64, read-write
KTMAWG_ATTR_ARB_OFFSET = IVI_CLASS_ATTR_BASE + 203
# ViReal64, read-write
KTMAWG_ATTR_ARB_SAMPLE_RATE = IVI_CLASS_ATTR_BASE + 204

# - Waveform
# ViInt32, read-write
KTMAWG_ATTR_ARB_WAVEFORM_HANDLE = IVI_CLASS_ATTR_BASE + 201
# ViInt32, read-only
KTMAWG_ATTR_MAX_NUM_WAVEFORMS = IVI_CLASS_ATTR_BASE + 205
# ViInt32, read-only
KTMAWG_ATTR_WAVEFORM_QUANTUM = IVI_CLASS_ATTR_BASE + 206
# ViInt32, read-only
KTMAWG_ATTR_MAX_WAVEFORM_SIZE = IVI_CLASS_ATTR_BASE + 208
# ViInt64, read-only
KTMAWG_ATTR_MAX_WAVEFORM_SIZE64 = IVI_CLASS_ATTR_BASE + 222
# ViInt32, read-only
KTMAWG_ATTR_MIN_WAVEFORM_SIZE = IVI_CLASS_ATTR_BASE + 207
# ViInt64, read-only
KTMAWG_ATTR_MIN_WAVEFORM_SIZE64 = IVI_CLASS_ATTR_BASE + 221
# ViInt32, read-only
KTMAWG_ATTR_BINARY_ALIGNMENT = IVI_CLASS_ATTR_BASE + 241
# ViInt32, read-only
KTMAWG_ATTR_SAMPLE_BIT_RESOLUTION = IVI_CLASS_ATTR_BASE + 242
# ViInt32, read-only
KTMAWG_ATTR_OUTPUT_DATA_MASK = IVI_CLASS_ATTR_BASE + 261

# - Sequence
# ViInt32, read-write
KTMAWG_ATTR_ARB_SEQUENCE_HANDLE = IVI_CLASS_ATTR_BASE + 211
# ViInt32, read-only
KTMAWG_ATTR_MAX_SEQUENCE_LENGTH = IVI_CLASS_ATTR_BASE + 214
# ViInt32, read-only
KTMAWG_ATTR_MIN_SEQUENCE_LENGTH = IVI_CLASS_ATTR_BASE + 213
# ViInt32, read-only
KTMAWG_ATTR_MAX_LOOP_COUNT = IVI_CLASS_ATTR_BASE + 215
# ViInt32, read-only
KTMAWG_ATTR_MAX_NUM_SEQUENCES = IVI_CLASS_ATTR_BASE + 212
# ViInt32, read-only
KTMAWG_ATTR_MAX_SEQUENCE_DEPTH = IVI_CLASS_ATTR_BASE + 281

# - Output

# ViInt32, read-only
KTMAWG_ATTR_CHANNEL_COUNT = IVI_INHERENT_ATTR_BASE + 203
# ViBoolean, read-write
KTMAWG_ATTR_OUTPUT_ENABLED = IVI_CLASS_ATTR_BASE + 3
# ViReal64, read-write
KTMAWG_ATTR_OUTPUT_IMPEDANCE = IVI_CLASS_ATTR_BASE + 4
# ViInt32, read-write
KTMAWG_ATTR_OPERATION_MODE = IVI_CLASS_ATTR_BASE + 5
# ViInt32, read-write
KTMAWG_ATTR_OUTPUT_MODE = IVI_CLASS_ATTR_BASE + 1
# ViInt32, read-write
KTMAWG_ATTR_REF_CLOCK_SOURCE = IVI_CLASS_ATTR_BASE + 2
# ViInt32, read-write
KTMAWG_ATTR_TERMINAL_CONFIGURATION = IVI_CLASS_ATTR_BASE + 31

# - Trigger

# ViInt32, read-write
KTMAWG_ATTR_BURST_COUNT = IVI_CLASS_ATTR_BASE + 350
# ViInt32, read-write
KTMAWG_ATTR_TRIGGER_SOURCE = IVI_CLASS_ATTR_BASE + 302

# - Start Trigger

# ViReal64, read-write
KTMAWG_ATTR_START_TRIGGER_DELAY = IVI_CLASS_ATTR_BASE + 320
# ViInt32, read-write
KTMAWG_ATTR_START_TRIGGER_SLOPE = IVI_CLASS_ATTR_BASE + 321
# ViString, read-write
KTMAWG_ATTR_START_TRIGGER_SOURCE = IVI_CLASS_ATTR_BASE + 322
# ViReal64, read-write
KTMAWG_ATTR_START_TRIGGER_THRESHOLD = IVI_CLASS_ATTR_BASE + 323


# ***************************************************************************

# *------------------------ Attribute Value Defines -------------------------*
# ***************************************************************************

# - Defined values for

KTMAWG_VAL_STATUS_BYTE_FLAGS_USER0 = 1
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER1 = 2
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER2 = 4
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER3 = 8
KTMAWG_VAL_STATUS_BYTE_FLAGS_MESSAGE_AVAILABLE = 16
KTMAWG_VAL_STATUS_BYTE_FLAGS_EVENT_STATUS_REGISTER = 32
KTMAWG_VAL_STATUS_BYTE_FLAGS_REQUESTING_SERVICE = 64
KTMAWG_VAL_STATUS_BYTE_FLAGS_USER7 = 128

# - Defined values for

KTMAWG_VAL_UPDATE_STATUS_IN_PROGRESS = 0
KTMAWG_VAL_UPDATE_STATUS_SUCCESS = 1
KTMAWG_VAL_UPDATE_STATUS_RESTART_REQUIRED = 2
KTMAWG_VAL_UPDATE_STATUS_POWER_CYCLE_REQUIRED = 3
KTMAWG_VAL_UPDATE_STATUS_FAILED = 4

# - Defined values for
#  attribute KTMAWG_ATTR_CALIBRATION_STATUS
#  attribute KTMAWG_ATTR_MODULE_CALIBRATION_STATUS

KTMAWG_VAL_CALIBRATION_STATUS_DUE = 1
KTMAWG_VAL_CALIBRATION_STATUS_EXPIRED = 2
KTMAWG_VAL_CALIBRATION_STATUS_INSTRUMENT_CALIBRATED = 0
KTMAWG_VAL_CALIBRATION_STATUS_MODULES_CALIBRATED = 5
KTMAWG_VAL_CALIBRATION_STATUS_NOT_CALIBRATED = 3
KTMAWG_VAL_CALIBRATION_STATUS_NOT_SUBJECT_TO_CALIBRATION = 4

# - Defined values for
#   parameter Mask in function KtMAwg_StatusClearEvent
#   parameter Mask in function KtMAwg_StatusGetEventState
#   parameter Mask in function KtMAwg_StatusSetEvent

KTMAWG_VAL_STATUS_EVENT_ALL = 0
KTMAWG_VAL_STATUS_EVENT_ERROR_IN_QUEUE = 1
KTMAWG_VAL_STATUS_EVENT_THERMAL_SHUTDOWN = 14
KTMAWG_VAL_STATUS_EVENT_THERMAL_WARNING = 15
KTMAWG_VAL_STATUS_EVENT_USER_DEFINED = 2

# - Defined values for

KTMAWG_VAL_MODULE_EVENT_ALL = 0
KTMAWG_VAL_MODULE_EVENT_TIMER1 = 201
KTMAWG_VAL_MODULE_EVENT_TIMER2 = 202
KTMAWG_VAL_MODULE_EVENT_TIMER3 = 203
KTMAWG_VAL_MODULE_EVENT_TIMER4 = 204
KTMAWG_VAL_MODULE_EVENT_TRIGGER1 = 1
KTMAWG_VAL_MODULE_EVENT_TRIGGER10 = 10
KTMAWG_VAL_MODULE_EVENT_TRIGGER2 = 2
KTMAWG_VAL_MODULE_EVENT_TRIGGER3 = 3
KTMAWG_VAL_MODULE_EVENT_TRIGGER4 = 4
KTMAWG_VAL_MODULE_EVENT_TRIGGER5 = 5
KTMAWG_VAL_MODULE_EVENT_TRIGGER6 = 6
KTMAWG_VAL_MODULE_EVENT_TRIGGER7 = 7
KTMAWG_VAL_MODULE_EVENT_TRIGGER8 = 8
KTMAWG_VAL_MODULE_EVENT_TRIGGER9 = 9
KTMAWG_VAL_MODULE_EVENT_USER1 = 101
KTMAWG_VAL_MODULE_EVENT_USER2 = 102
KTMAWG_VAL_MODULE_EVENT_USER3 = 103
KTMAWG_VAL_MODULE_EVENT_USER4 = 104

# - Defined values for

KTMAWG_VAL_SPI_MODE_LSB_FIRST_BYTE = 0
KTMAWG_VAL_SPI_MODE_LSB_FIRST_WORD = 1
KTMAWG_VAL_SPI_MODE_MSB_FIRST_BYTE = 2
KTMAWG_VAL_SPI_MODE_MSB_FIRST_WORD = 3

# - Defined values for

KTMAWG_VAL_TRIGGER_DIRECTION_INPUT = 0
KTMAWG_VAL_TRIGGER_DIRECTION_OUTPUT = 1

# - Defined values for

KTMAWG_VAL_TRIGGER_MODE_LEVEL = 1
KTMAWG_VAL_TRIGGER_MODE_PULSE = 0

# - Defined values for

KTMAWG_VAL_TRIGGER_POLARITY_NEGATIVE = 1
KTMAWG_VAL_TRIGGER_POLARITY_POSITIVE = 0

# - Defined values for

KTMAWG_VAL_TRIGGER_PXI_TRIGGER0 = 0
KTMAWG_VAL_TRIGGER_PXI_TRIGGER1 = 1
KTMAWG_VAL_TRIGGER_PXI_TRIGGER2 = 2
KTMAWG_VAL_TRIGGER_PXI_TRIGGER3 = 3
KTMAWG_VAL_TRIGGER_PXI_TRIGGER4 = 4
KTMAWG_VAL_TRIGGER_PXI_TRIGGER5 = 5
KTMAWG_VAL_TRIGGER_PXI_TRIGGER6 = 6
KTMAWG_VAL_TRIGGER_PXI_TRIGGER7 = 7

# - Defined values for

KTMAWG_VAL_TRIGGER_RESOURCE_NONE = -1
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER1 = 0
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER2 = 1
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER3 = 2
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER4 = 3
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER5 = 4
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER6 = 5
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER7 = 6
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER8 = 7
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER9 = 8
KTMAWG_VAL_TRIGGER_RESOURCE_TRIGGER10 = 9

# - Defined values for

KTMAWG_VAL_TRIGGER_TERMINATION_HIGH_IMPEDANCE = 0
KTMAWG_VAL_TRIGGER_TERMINATION_LOW_IMPEDANCE = 1

# - Defined values for

KTMAWG_VAL_LTC3880_PHASE_BOTH_PHASES = 255
KTMAWG_VAL_LTC3880_PHASE_PHASE0 = 0
KTMAWG_VAL_LTC3880_PHASE_PHASE1 = 1

# - Defined values for

KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_MODE_COMMON_REFERENCE = 1
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_MODE_DIFFERENTIAL = 0

# - Defined values for

KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_0P64 = 5
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE1_0P24 = 1
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_1P28 = 4
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE2_0P48 = 7
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE2_4P576 = 0
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_2P56 = 3
KTMAWG_VAL_SELF_TEST_ADC_MEASUREMENT_RANGE_VOLTAGE_5P12 = 2

# - Defined values for
#   parameter State in function KtMAwg_GetGenerationStateByChannel

KTMAWG_VAL_GENERATION_STATE_CONFIGURATION = 0
KTMAWG_VAL_GENERATION_STATE_OUTPUT_GENERATION = 1

# - Defined values for

KTMAWG_VAL_MEMORY_QUERY_MODE_TOTAL_SIZE = 0
KTMAWG_VAL_MEMORY_QUERY_MODE_FREE_SIZE = 1
KTMAWG_VAL_MEMORY_QUERY_MODE_ALLOCATED_SIZE = 2

# - Defined values for
#   parameter Mode in function KtMAwg_CorrectionsGetFilterMode
#   parameter Mode in function KtMAwg_CorrectionsSetFilterMode

KTMAWG_VAL_CORRECTION_FILTER_MODE_UNCALIBRATED = 1
KTMAWG_VAL_CORRECTION_FILTER_MODE_BYPASS = 2
KTMAWG_VAL_CORRECTION_FILTER_MODE_CALIBRATED = 0

# - Defined values for

KTMAWG_VAL_ATTRIBUTES_ARBITRARY_SAMPLE_RATE = 0
KTMAWG_VAL_ATTRIBUTES_OUTPUT_DELAY = 4
KTMAWG_VAL_ATTRIBUTES_MARKER_DELAY = 20
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_GAIN = 10
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_ANALOG_GAIN = 13
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_DIGITAL_GAIN = 14
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_OFFSET = 11
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_COMMON_MODE_OFFSET = 12
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_LOAD_IMPEDANCE = 8
KTMAWG_VAL_ATTRIBUTES_START_TRIGGER_DELAY = 16
KTMAWG_VAL_ATTRIBUTES_START_TRIGGER_SOURCE = 15
KTMAWG_VAL_ATTRIBUTES_MARKER_DESTINATION = 19
KTMAWG_VAL_ATTRIBUTES_MARKER_BIT_POSITION = 21
KTMAWG_VAL_ATTRIBUTES_SEQUENCE_TRIGGER_SOURCE = 17
KTMAWG_VAL_ATTRIBUTES_SEQUENCE_TRIGGER_DELAY = 18
KTMAWG_VAL_ATTRIBUTES_OUTPUT_OPERATION_MODE = 5
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_GAIN_CONTROL = 9
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_CHANNEL_MODE = 2
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_HANDLE = 1
KTMAWG_VAL_ATTRIBUTES_OUTPUT_ENABLED = 3
KTMAWG_VAL_ATTRIBUTES_OUTPUT_TERMINAL_CONFIGURATION = 7
KTMAWG_VAL_ATTRIBUTES_CORRECTION_FILTER_MODE = 22
KTMAWG_VAL_ATTRIBUTES_BURST_COUNT = 6
KTMAWG_VAL_ATTRIBUTES_ARBITRARY_WAVEFORM_MODE = 30

# - Defined values for
#   parameter Control in function KtMAwg_ArbitrarySetGainControl
#   parameter Control in function KtMAwg_ArbitraryGetGainControl

KTMAWG_VAL_GAIN_CONTROL_COMPONENT = 1
KTMAWG_VAL_GAIN_CONTROL_COMPOSITE = 0

# - Defined values for
#   parameter Events in function KtMAwg_QueryGenerationEvents

KTMAWG_VAL_GENERATION_EVENTS_NONE = 0
KTMAWG_VAL_GENERATION_EVENTS_DIGITAL_GAIN_BLOCK_OVERFLOW = 1
KTMAWG_VAL_GENERATION_EVENTS_FIFO_UNDERRUN = 2
KTMAWG_VAL_GENERATION_EVENTS_RESAMPLER_OVERFLOW = 4
KTMAWG_VAL_GENERATION_EVENTS_CORRECTIONS_OVERFLOW = 8
KTMAWG_VAL_GENERATION_EVENTS_MARKER_QUEUE_OVERRUN = 16
KTMAWG_VAL_GENERATION_EVENTS_MARKER_IGNORED = 32
KTMAWG_VAL_GENERATION_EVENTS_STREAMING_DATA_UNDERRUN = 128

# - Defined values for
#   attribute KTMAWG_ATTR_OUTPUT_MODE
#   parameter OutputMode in function KtMAwg_ConfigureOutputMode

KTMAWG_VAL_OUTPUT_FUNC = 0
KTMAWG_VAL_OUTPUT_ARB = 1
KTMAWG_VAL_OUTPUT_SEQ = 2

# - Defined values for
#   attribute KTMAWG_ATTR_OPERATION_MODE
#   parameter OperationMode in function KtMAwg_ConfigureOperationMode

KTMAWG_VAL_OPERATE_CONTINUOUS = 0
KTMAWG_VAL_OPERATE_BURST = 1

# - Defined values for
#   attribute KTMAWG_ATTR_REF_CLOCK_SOURCE
#   parameter Source in function KtMAwg_ConfigureRefClockSource

KTMAWG_VAL_REF_CLOCK_INTERNAL = 0
KTMAWG_VAL_REF_CLOCK_EXTERNAL = 1
KTMAWG_VAL_REF_CLOCK_RTSI_CLOCK = 101

# - Defined values for
#   attribute KTMAWG_ATTR_TRIGGER_SOURCE
#   parameter Source in function KtMAwg_ConfigureTriggerSource

KTMAWG_VAL_EXTERNAL = 1
KTMAWG_VAL_SOFTWARE_TRIG = 2
KTMAWG_VAL_INTERNAL_TRIGGER = 3
KTMAWG_VAL_TTL0 = 111
KTMAWG_VAL_TTL1 = 112
KTMAWG_VAL_TTL2 = 113
KTMAWG_VAL_TTL3 = 114
KTMAWG_VAL_TTL4 = 115
KTMAWG_VAL_TTL5 = 116
KTMAWG_VAL_TTL6 = 117
KTMAWG_VAL_TTL7 = 118
KTMAWG_VAL_ECL0 = 119
KTMAWG_VAL_ECL1 = 120
KTMAWG_VAL_PXI_STAR = 131
KTMAWG_VAL_RTSI_0 = 141
KTMAWG_VAL_RTSI_1 = 142
KTMAWG_VAL_RTSI_2 = 143
KTMAWG_VAL_RTSI_3 = 144
KTMAWG_VAL_RTSI_4 = 145
KTMAWG_VAL_RTSI_5 = 146
KTMAWG_VAL_RTSI_6 = 147
KTMAWG_VAL_SOFTWARE0 = 1001
KTMAWG_VAL_SOFTWARE1 = 1002
KTMAWG_VAL_SOFTWARE2 = 1003
KTMAWG_VAL_SOFTWARE3 = 1004
KTMAWG_VAL_SOFTWARE4 = 1005
KTMAWG_VAL_SOFTWARE5 = 1006
KTMAWG_VAL_SOFTWARE6 = 1007
KTMAWG_VAL_SOFTWARE7 = 1008
KTMAWG_VAL_SOFTWARE9 = 1010
KTMAWG_VAL_SOFTWARE10 = 1011
KTMAWG_VAL_SOFTWARE11 = 1012
KTMAWG_VAL_SOFTWARE12 = 1013
KTMAWG_VAL_SOFTWARE13 = 1014
KTMAWG_VAL_SOFTWARE14 = 1015
KTMAWG_VAL_SOFTWARE15 = 1016
KTMAWG_VAL_SOFTWARE8 = 1009
KTMAWG_VAL_PXI_TRIG0 = 1017
KTMAWG_VAL_PXI_TRIG1 = 1018
KTMAWG_VAL_PXI_TRIG2 = 1019
KTMAWG_VAL_PXI_TRIG3 = 1020
KTMAWG_VAL_PXI_TRIG4 = 1021
KTMAWG_VAL_PXI_TRIG5 = 1022
KTMAWG_VAL_PXI_TRIG6 = 1023
KTMAWG_VAL_PXI_TRIG7 = 1024
KTMAWG_VAL_EXTERNAL1 = 1025
KTMAWG_VAL_EXTERNAL2 = 1026
KTMAWG_VAL_PXIE_DSTARB = 1027
KTMAWG_VAL_DIO_0 = 1028
KTMAWG_VAL_DIO_1 = 1029
KTMAWG_VAL_DIO_2 = 1030
KTMAWG_VAL_DIO_3 = 1031
KTMAWG_VAL_DIO_4 = 1032
KTMAWG_VAL_DIO_5 = 1033
KTMAWG_VAL_DIO_7 = 1035
KTMAWG_VAL_DIO_6 = 1034
KTMAWG_VAL_TRIG_IMMEDIATE = 1036
KTMAWG_VAL_DISABLED = 1037

# - Defined values for

KTMAWG_VAL_WFM_SINE = 1
KTMAWG_VAL_WFM_SQUARE = 2
KTMAWG_VAL_WFM_TRIANGLE = 3
KTMAWG_VAL_WFM_RAMP_UP = 4
KTMAWG_VAL_WFM_RAMP_DOWN = 5
KTMAWG_VAL_WFM_DC = 6

# - Defined values for

KTMAWG_VAL_AM_INTERNAL_SINE = 1
KTMAWG_VAL_AM_INTERNAL_SQUARE = 2
KTMAWG_VAL_AM_INTERNAL_TRIANGLE = 3
KTMAWG_VAL_AM_INTERNAL_RAMP_UP = 4
KTMAWG_VAL_AM_INTERNAL_RAMP_DOWN = 5

# - Defined values for

KTMAWG_VAL_AM_INTERNAL = 0
KTMAWG_VAL_AM_EXTERNAL = 1

# - Defined values for

KTMAWG_VAL_FM_INTERNAL_SINE = 1
KTMAWG_VAL_FM_INTERNAL_SQUARE = 2
KTMAWG_VAL_FM_INTERNAL_TRIANGLE = 3
KTMAWG_VAL_FM_INTERNAL_RAMP_UP = 4
KTMAWG_VAL_FM_INTERNAL_RAMP_DOWN = 5

# - Defined values for

KTMAWG_VAL_FM_INTERNAL = 0
KTMAWG_VAL_FM_EXTERNAL = 1

# - Defined values for
#   attribute KTMAWG_ATTR_START_TRIGGER_SLOPE
#   parameter Slope in function KtMAwg_ConfigureStartTrigger

KTMAWG_VAL_TRIGGER_POSITIVE = 0
KTMAWG_VAL_TRIGGER_NEGATIVE = 1
KTMAWG_VAL_TRIGGER_EITHER = 2

# - Defined values for
#   attribute KTMAWG_ATTR_TERMINAL_CONFIGURATION
#   parameter Configuration in function KtMAwg_OutputSetTerminalConfiguration

KTMAWG_VAL_TERMINAL_CONFIGURATION_SINGLE_ENDED = 0
KTMAWG_VAL_TERMINAL_CONFIGURATION_DIFFERENTIAL = 1

# - Defined values for

KTMAWG_VAL_SAMPLE_CLOCK_SOURCE_INTERNAL = 0
KTMAWG_VAL_SAMPLE_CLOCK_SOURCE_EXTERNAL = 1

# - Defined values for

KTMAWG_VAL_MARKER_POLARITY_ACTIVE_HIGH = 0
KTMAWG_VAL_MARKER_POLARITY_ACTIVE_LOW = 1

# - Defined values for
#   attribute KTMAWG_ATTR_BINARY_ALIGNMENT

KTMAWG_VAL_BINARY_ALIGNMENT_LEFT = 0
KTMAWG_VAL_BINARY_ALIGNMENT_RIGHT = 1

# - Defined values for
#   parameter Mode in function KtMAwg_GetChannelMode
#   parameter Mode in function KtMAwg_SetChannelMode

KTMAWG_VAL_CHANNEL_MODE_WAVEFORM = 0
KTMAWG_VAL_CHANNEL_MODE_MARKER = 1

# - Defined values for

KTMAWG_VAL_EXTERNAL_IMPEDANCE_OHM_1K = 0
KTMAWG_VAL_EXTERNAL_IMPEDANCE_OHM50 = 1

# - Defined values for

KTMAWG_VAL_EXTERNAL_ATTRIBUTES_THRESHOLD = 0

# - Defined values for
#   attribute KTMAWG_ATTR_EXTERNAL_INPUT_SLOPE
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_INPUT_SLOPE

KTMAWG_VAL_INPUT_SLOPE_POSITIVE = 0
KTMAWG_VAL_INPUT_SLOPE_NEGATIVE = 1

# - Defined values for
#   attribute KTMAWG_ATTR_EXTERNAL_OUTPUT_POLARITY
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_OUTPUT_POLARITY
#   parameter Val in function KtMAwg_GetChannelMarkerPolarity
#  parameter Polarity in function KtMAwg_SetChannelMarkerPolarity

KTMAWG_VAL_OUTPUT_POLARITY_POSITIVE = 0
KTMAWG_VAL_OUTPUT_POLARITY_NEGATIVE = 1

# - Defined values for
#   parameter Option in function KtMAwg_MemoryTest

KTMAWG_VAL_MEMORY_TEST_STANDARD = 1
KTMAWG_VAL_MEMORY_TEST_COMPREHENSIVE = 0

# - Defined values for
#   attribute KTMAWG_ATTR_TRIGGER_BUS_LINE_CAPABILITY

KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_INPUT = 1
KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_OUTPUT = 2
KTMAWG_VAL_TRIGGER_BUS_LINE_CAPABILITY_BOTH = 3

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_GROUP_SIGNAL
#   attribute KTMAWG_ATTR_DEVICE_SYNC_SLAVE_SIGNAL
#   parameter GroupSignal in function KtMAwg_DeviceSyncConfigureMaster
#   parameter SlaveSignals in function KtMAwg_DeviceSyncConfigureMaster
#   parameter GroupSignal in function KtMAwg_DeviceSyncConfigureSlave
#   parameter SlaveSignal in function KtMAwg_DeviceSyncConfigureSlave
#   parameter Val in function KtMAwg_DeviceSyncGetGroupMask
#   parameter SlaveSignals in function KtMAwg_DeviceSyncSetGroupMask

KTMAWG_VAL_DEVICE_SYNC_RESOURCESFP_SYNC = 32768
KTMAWG_VAL_DEVICE_SYNC_RESOURCES_NONE = 0
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_LBL6 = 2048
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_LBR6 = 1024
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_STAR = 512
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG0 = 1
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG1 = 2
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG2 = 4
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG3 = 8
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG4 = 16
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG5 = 32
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG6 = 64
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXI_TRIG7 = 128
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARA = 4096
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARB = 8192
KTMAWG_VAL_DEVICE_SYNC_RESOURCESPXIE_DSTARC = 16384

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_ROLE
#   parameter Role in function KtMAwg_DeviceSyncConfigureMaster

KTMAWG_VAL_DEVICE_SYNC_ROLE_GROUP_MASTER = 3
KTMAWG_VAL_DEVICE_SYNC_ROLE_LOCAL_MASTER = 5
KTMAWG_VAL_DEVICE_SYNC_ROLE_OFF = 0
KTMAWG_VAL_DEVICE_SYNC_ROLE_SLAVE = 2
KTMAWG_VAL_DEVICE_SYNC_ROLE_SANDBOX = 1
KTMAWG_VAL_DEVICE_SYNC_ROLE_SYSTEM_MASTER = 4

# - Defined values for
#   attribute KTMAWG_ATTR_DEVICE_SYNC_STATE

KTMAWG_VAL_DEVICE_SYNC_STATE_ARM = 1
KTMAWG_VAL_DEVICE_SYNC_STATE_IDLE = 0
KTMAWG_VAL_DEVICE_SYNC_STATE_RUN = 3
KTMAWG_VAL_DEVICE_SYNC_STATE_TRIGGER = 2
KTMAWG_VAL_DEVICE_SYNC_STATE_UNKNOWN = 4

# - Defined values for
#   parameter State in function KtMAwg_GetOutputGenerationState

KTMAWG_VAL_OUTPUT_GENERATION_STATE_IDLE = 0
KTMAWG_VAL_OUTPUT_GENERATION_STATE_ARM = 1
KTMAWG_VAL_OUTPUT_GENERATION_STATE_TRIGGER = 2
KTMAWG_VAL_OUTPUT_GENERATION_STATE_RUN = 3
KTMAWG_VAL_OUTPUT_GENERATION_STATE_UNKNOWN = 4

# - Defined values for
#   parameter Val in function KtMAwg_GetWaveformMode
#   parameter Mode in function KtMAwg_SetWaveformMode

KTMAWG_VAL_WAVEFORM_MODE_CATALOGED = 0
KTMAWG_VAL_WAVEFORM_MODE_STREAMING = 1


# ***************************************************************************
# *----------------- Instrument Error And Completion Codes ------------------*
# ***************************************************************************

IVIC_WARN_BASE = 0x3FFA0000
IVIC_CROSS_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x1000
IVIC_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x2000
IVIC_SPECIFIC_WARN_BASE = IVIC_WARN_BASE + 0x4000

IVIC_ERROR_BASE = 0xBFFA0000
IVIC_CROSS_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x1000
IVIC_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x2000
IVIC_SPECIFIC_ERROR_BASE = IVIC_ERROR_BASE + 0x4000
IVIC_LXISYNC_ERROR_BASE = IVIC_ERROR_BASE + 0x2000


KTMAWG_ERROR_CANNOT_RECOVER = IVIC_ERROR_BASE + 0x0000
KTMAWG_ERROR_INSTRUMENT_STATUS = IVIC_ERROR_BASE + 0x0001
KTMAWG_ERROR_CANNOT_OPEN_FILE = IVIC_ERROR_BASE + 0x0002
KTMAWG_ERROR_READING_FILE = IVIC_ERROR_BASE + 0x0003
KTMAWG_ERROR_WRITING_FILE = IVIC_ERROR_BASE + 0x0004
KTMAWG_ERROR_INVALID_PATHNAME = IVIC_ERROR_BASE + 0x000B
KTMAWG_ERROR_INVALID_ATTRIBUTE = IVIC_ERROR_BASE + 0x000C
KTMAWG_ERROR_IVI_ATTR_NOT_WRITABLE = IVIC_ERROR_BASE + 0x000D
KTMAWG_ERROR_IVI_ATTR_NOT_READABLE = IVIC_ERROR_BASE + 0x000E
KTMAWG_ERROR_INVALID_VALUE = IVIC_ERROR_BASE + 0x0010
KTMAWG_ERROR_FUNCTION_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0011
KTMAWG_ERROR_ATTRIBUTE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0012
KTMAWG_ERROR_VALUE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0013
KTMAWG_ERROR_TYPES_DO_NOT_MATCH = IVIC_ERROR_BASE + 0x0015
KTMAWG_ERROR_NOT_INITIALIZED = IVIC_ERROR_BASE + 0x001D
KTMAWG_ERROR_UNKNOWN_CHANNEL_NAME = IVIC_ERROR_BASE + 0x0020
KTMAWG_ERROR_TOO_MANY_OPEN_FILES = IVIC_ERROR_BASE + 0x0023
KTMAWG_ERROR_CHANNEL_NAME_REQUIRED = IVIC_ERROR_BASE + 0x0044
KTMAWG_ERROR_MISSING_OPTION_NAME = IVIC_ERROR_BASE + 0x0049
KTMAWG_ERROR_MISSING_OPTION_VALUE = IVIC_ERROR_BASE + 0x004A
KTMAWG_ERROR_BAD_OPTION_NAME = IVIC_ERROR_BASE + 0x004B
KTMAWG_ERROR_BAD_OPTION_VALUE = IVIC_ERROR_BASE + 0x004C
KTMAWG_ERROR_OUT_OF_MEMORY = IVIC_ERROR_BASE + 0x0056
KTMAWG_ERROR_OPERATION_PENDING = IVIC_ERROR_BASE + 0x0057
KTMAWG_ERROR_NULL_POINTER = IVIC_ERROR_BASE + 0x0058
KTMAWG_ERROR_UNEXPECTED_RESPONSE = IVIC_ERROR_BASE + 0x0059
KTMAWG_ERROR_FILE_NOT_FOUND = IVIC_ERROR_BASE + 0x005B
KTMAWG_ERROR_INVALID_FILE_FORMAT = IVIC_ERROR_BASE + 0x005C
KTMAWG_ERROR_STATUS_NOT_AVAILABLE = IVIC_ERROR_BASE + 0x005D
KTMAWG_ERROR_ID_QUERY_FAILED = IVIC_ERROR_BASE + 0x005E
KTMAWG_ERROR_RESET_FAILED = IVIC_ERROR_BASE + 0x005F
KTMAWG_ERROR_RESOURCE_UNKNOWN = IVIC_ERROR_BASE + 0x0060
KTMAWG_ERROR_ALREADY_INITIALIZED = IVIC_ERROR_BASE + 0x0061
KTMAWG_ERROR_CANNOT_CHANGE_SIMULATION_STATE = IVIC_ERROR_BASE + 0x0062
KTMAWG_ERROR_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR = IVIC_ERROR_BASE + 0x0063
KTMAWG_ERROR_INVALID_RANGE_IN_SELECTOR = IVIC_ERROR_BASE + 0x0064
KTMAWG_ERROR_UNKOWN_NAME_IN_SELECTOR = IVIC_ERROR_BASE + 0x0065
KTMAWG_ERROR_BADLY_FORMED_SELECTOR = IVIC_ERROR_BASE + 0x0066
KTMAWG_ERROR_UNKNOWN_PHYSICAL_IDENTIFIER = IVIC_ERROR_BASE + 0x0067
KTMAWG_ERROR_INVALID_SESSION_HANDLE = IVIC_ERROR_BASE + 0x1190


KTMAWG_SUCCESS = 0
KTMAWG_WARN_NSUP_ID_QUERY = IVIC_WARN_BASE + 0x0065
KTMAWG_WARN_NSUP_RESET = IVIC_WARN_BASE + 0x0066
KTMAWG_WARN_NSUP_SELF_TEST = IVIC_WARN_BASE + 0x0067
KTMAWG_WARN_NSUP_ERROR_QUERY = IVIC_WARN_BASE + 0x0068
KTMAWG_WARN_NSUP_REV_QUERY = IVIC_WARN_BASE + 0x0069


KTMAWG_ERROR_IO_GENERAL = IVIC_SPECIFIC_ERROR_BASE + 0x0214
KTMAWG_ERROR_IO_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0215
KTMAWG_ERROR_CALIBRATION_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0217
KTMAWG_ERROR_CHECK_ERROR_QUEUE = IVIC_SPECIFIC_ERROR_BASE + 0x0218
KTMAWG_ERROR_FILE_TYPE_NOT_RECOGNIZED = IVIC_SPECIFIC_ERROR_BASE + 0x0219
KTMAWG_ERROR_FIRMWARE_UPDATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021A
KTMAWG_ERROR_FIRMWARE_UPDATE_REQUIRED = IVIC_SPECIFIC_ERROR_BASE + 0x021B
KTMAWG_ERROR_FPGA_PROGRAMMING_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021C
KTMAWG_ERROR_HARDWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x021D
KTMAWG_ERROR_HW_RESOURCE_NOT_AVAILABLE = IVIC_SPECIFIC_ERROR_BASE + 0x021E
KTMAWG_ERROR_INCOMPATIBLE_SOFTWARE_VERSION_ERROR = \
    IVIC_SPECIFIC_ERROR_BASE + 0x021F
KTMAWG_ERROR_INSTRUMENT_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0220
KTMAWG_ERROR_INSTRUMENT_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x0221
KTMAWG_ERROR_INSTRUMENT_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x0222
KTMAWG_ERROR_INTERNAL_APPLICATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0223
KTMAWG_ERROR_LICENSE_SYSTEM_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0224
KTMAWG_ERROR_LICENSE_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0225
KTMAWG_ERROR_MAX_TIME_EXCEEDED = IVIC_SPECIFIC_ERROR_BASE + 0x0226
KTMAWG_ERROR_MISSING_CLOCK_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0227
KTMAWG_ERROR_MODEL_NOT_SUPPORTED = IVIC_SPECIFIC_ERROR_BASE + 0x0228
KTMAWG_ERROR_MODULE_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0229
KTMAWG_ERROR_MODULE_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x022A
KTMAWG_ERROR_MODULE_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x022B
KTMAWG_ERROR_MODULE_VALIDATE_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x022C
KTMAWG_ERROR_OPERATION_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x022D
KTMAWG_ERROR_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022E
KTMAWG_ERROR_OUT_OF_MEMORY_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022F
KTMAWG_ERROR_PARAMETER_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0230
KTMAWG_ERROR_PERSONALITY_NOT_ACTIVE = IVIC_SPECIFIC_ERROR_BASE + 0x0231
KTMAWG_ERROR_PERSONALITY_NOT_INSTALLED = IVIC_SPECIFIC_ERROR_BASE + 0x0232
KTMAWG_ERROR_PERSONALITY_NOT_LICENSED = IVIC_SPECIFIC_ERROR_BASE + 0x0233
KTMAWG_ERROR_SELFTEST_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x0234
KTMAWG_ERROR_SOFTWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0235
KTMAWG_ERROR_TEST_FAILED_INCORRECT_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0236
KTMAWG_ERROR_THERMAL_SHUTDOWN = IVIC_SPECIFIC_ERROR_BASE + 0x0237
KTMAWG_ERROR_THERMAL_WARNING = IVIC_SPECIFIC_ERROR_BASE + 0x0238
KTMAWG_ERROR_UNABLE_TO_INITIALIZE_HARDWARE = IVIC_SPECIFIC_ERROR_BASE + 0x0239
KTMAWG_ERROR_UNRECOGNIZED_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023A
KTMAWG_ERROR_UNSUPPORTED_FEATURE = IVIC_SPECIFIC_ERROR_BASE + 0x023B
KTMAWG_ERROR_UNSUPPORTED_PROPERTY = IVIC_SPECIFIC_ERROR_BASE + 0x023C
KTMAWG_ERROR_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023D
KTMAWG_ERROR_VERIFY_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023E
KTMAWG_ERROR_WAIT_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x023F
KTMAWG_ERROR_TRIGGER_NOT_SOFTWARE = IVIC_CLASS_ERROR_BASE + 0x0001
KTMAWG_ERROR_NO_WFMS_AVAILABLE = IVIC_CLASS_ERROR_BASE + 0x0004
KTMAWG_ERROR_WFM_IN_USE = IVIC_CLASS_ERROR_BASE + 0x0008
KTMAWG_ERROR_NO_SEQS_AVAILABLE = IVIC_CLASS_ERROR_BASE + 0x0009
KTMAWG_ERROR_SEQ_IN_USE = IVIC_CLASS_ERROR_BASE + 0x000D
KTMAWG_ERROR_INVALID_WFM_CHANNEL = IVIC_CLASS_ERROR_BASE + 0x000E
KTMAWG_ERROR_COMPILATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0240
KTMAWG_ERROR_HARDWARE_STATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0241
KTMAWG_ERROR_INCONSISTENT_MULTI_CHANNEL_PROPERTY = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0242
KTMAWG_ERROR_INVALID_PARAMETER = IVIC_SPECIFIC_ERROR_BASE + 0x0243
KTMAWG_ERROR_MODULE_OUT_OF_MEMORY = IVIC_SPECIFIC_ERROR_BASE + 0x0245
KTMAWG_ERROR_SETTINGS_CONFLICT = IVIC_SPECIFIC_ERROR_BASE + 0x0246


KTMAWG_WARN_VALIDATION_FAILED = IVIC_SPECIFIC_WARN_BASE + 0x012D
"
111,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34410 A Submodules,281.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34410A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34410A Submodules,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,"[OrderedDict([('id', 'attnu5wrzJ7ApCEEC'), ('width', 700), ('height', 405), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZvXJnQd_DzwntkiZ2gSmQg/wvzn-TQz9Nz_jiUg0nkvaSVHrMiRGUbCZ035eiZpVxKPwLP-3OKcjDsBbX-gMehuIdSGrusDaQ-SgzzuJyQj8sDnJ1VZ2Rx9v9QWWQ1Lhe0/_jZpCU5-77BTWq0xRaD_KgonUZnMtLi6nPp6oPCAsio'), ('filename', 'KT-34411A.webp'), ('size', 101610), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xIgsqT_Osu8VAKe2j1M3Hw/r4x1vxsAe_IGus2YsV78OCg6MfvsqraDxryn26Ya63Q4Nvk5mu7kVG9DHujGejpC7-YE5LnvjOcEFoU7Y3wdWvtRpPtFWUrhM8H3QSpQnUE/coV2Bd3YlFRlpTd71C8bjX6ItETU-SI3tpiA5pjnrxM'), ('width', 62), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UXrCU2Jgm_MPT5g3s3Vhlg/O3Ivl1fjqqu3pCWQVC40b_AUsI71fibzS0CwYv_416ALOXcb5gEZqM_FWETNTdupfPo8QTzuT_sKHbC_F5HZ36zKCtKsqdx1-OM7FS0Kmoo/SIflNrGl_iZqwoe1RNTYmqF6l44YAspCC2TL7WSIbpA'), ('width', 700), ('height', 405)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-odiwN4xXY8afZ3xAiOU_Q/nZHMmpXs_dapcGkgQJGIQZZYY9URLXR5LwIsdm8lgS6yOkH0Ei-z5dfuOJEuP53HQfWySs2AF8LXUzcd2kfLtYDEy21CEuqKA_3XK1YnCbA/bfuMbIDvfbKpgCM5fts9jh7brsdDmxJK8ww3X2G2LRE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34410A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34410A,,,True,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34410A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34410A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34410A(Keysight34410A):
    """"""
    Alias for backwards compatibility.
    """"""
"
113,5420.0,USA,"N5171B EXG X-Series RF analog mid-performance signal generators offer 9 kHz to 6 GHz frequency coverage, optimized for manufacturing with faster throughput and greater uptime at the right price.

",N 51 X 1,287.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5171B EXG RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT N5171B EXG,https://www.keysight.com/us/en/assets/7018-03381/data-sheets/5991-0039.pdf,"[OrderedDict([('id', 'attf5gbhPROoyxfYC'), ('width', 500), ('height', 136), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/osipDjh3uKn-tYIk99cv5g/RWLzeqKE-iJ5sdgk7MdGq9hw-BtKnlv7KI41NGIy3uBFGlmykzW5PtQuuCc0OIhD4dMl7G8sLhUdxRyy49ozJ599shFVTRCmxL462bRe5uM/-Bv2usWvz7NavSftb64pgfPiCn26g4AOcT8i6-dsvpc'), ('filename', 'N5171B.5.jpg'), ('size', 12719), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/leOGM1-gRANn9_kLFTMg0g/udZHfSMWBmBMNQKYV5UF28CVM4Mb9eySQxm-_HR3RtZdJW-L25-D6F4f5lYQq-5OIy3yESMULqcOHcXAty_rrw/CpiOfn-p27rhrLYpVNGE0y5kiYcVLU22ziILl0_EYyw'), ('width', 132), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BMuCO93IRXbMTPkETeR9cg/k7DKUt-7GjZlRWyldyu0IgqoebtBpA2JOK2sjtgyXfHJRgS4EKRzX-LK2aQ8clprm6Sn-793VDfUxTCRmPXDwQ/QV_SOeVncqrgPENKwtuRQMrX5y9PZiZ-Vnayb36MPzQ'), ('width', 500), ('height', 136)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E34Kwj0k5UyeesmED6QJww/jrDOF84cdMsm0blDOdTUC5QXXm12eMuFakilC5CY_obTg_fydouvEISEo7ANT-RPg0yUWadvIQRoNcccOzon_g/SBtoYDk0Kg34lEK9sC2kXt1593Ej8SJgdeYeJ-PS3mY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/N5171B/exg-x-series-rf-analog-signal-generator-9-khz-6-ghz.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/N51x1.py,,13403.0,,,,"from typing import Any, Optional

from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping
from qcodes.validators import Numbers


class N51x1(VisaInstrument):
    """"""
    This is the qcodes driver for Keysight/Agilent scalar RF sources.
    It has been tested with N5171B, N5181A, N5173B, N5183B
    """"""

    def __init__(self, name: str, address: str, min_power: int = -144, max_power: int = 19, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        self._options = self.ask(""*OPT?"")
        # Determine installed frequency option
        freq_dict = {
            ""501"": 1e9,
            ""503"": 3e9,
            ""506"": 6e9,
            ""513"": 13e9,
            ""520"": 20e9,
            ""532"": 31.8e9,
            ""540"": 40e9,
        }

        frequency_option = None
        for f_option in freq_dict.keys():
            if f_option in self._options:
                frequency_option = f_option
        if frequency_option is None:
            raise RuntimeError(""Could not determine the frequency option"")

        max_freq = freq_dict[frequency_option]

        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=min_power,max_value=max_power))

        self.add_parameter(
            ""frequency"",
            label=""Frequency"",
            get_cmd=""SOUR:FREQ?"",
            get_parser=float,
            set_cmd=""SOUR:FREQ {:.2f}"",
            unit=""Hz"",
            vals=Numbers(min_value=9e3, max_value=max_freq),
        )

        self.add_parameter('phase_offset',
                           label='Phase Offset',
                           get_cmd='SOUR:PHAS?',
                           get_parser=float,
                           set_cmd='SOUR:PHAS {:.2f}',
                           unit='rad'
                           )

        self.add_parameter(
            ""auto_freq_ref"",
            get_cmd="":ROSC:SOUR:AUTO?"",
            set_cmd="":ROSC:SOUR:AUTO {}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""rf_output"",
            get_cmd=""OUTP:STAT?"",
            set_cmd=""OUTP:STAT {}"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        if ""UNW"" in self._options:
            self.add_parameter(
                ""pulse_modulation"",
                get_cmd=""PULM:STAT?"",
                set_cmd=""PULM:STAT {}"",
                val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
            )

            self.add_parameter(
                ""pulse_modulation_source"",
                get_cmd=""PULM:SOUR?"",
                set_cmd=""PULM:SOUR {}"",
                val_mapping={""internal"": ""INT"", ""external"": ""EXT""},
            )

        self.connect_message()

    def get_idn(self) -> dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN
"
115,21.4,"Westerville, Ohio, USA",,Lakeshore Base,363.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Qcodes,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,,,,,,
116,5420.0,USA,"Infiniium series oscilloscopes feature application-specific software that allows you to gain valuable insight into your design. Whether you are solving tough jitter or noise problems, removing loss due to cables or probes, or simply looking at protocol, this series has the software tools to help you realize your best design.
",Infiniium,292.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a  (Series --> Infiniium oscilloscopes) Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization.", (Series --> Infiniium oscilloscopes),https://www.keysight.com/us/en/assets/7018-04261/data-sheets/5991-3904.pdf,,https://www.keysight.com/us/en/products/oscilloscopes/infiniium-real-time-oscilloscopes.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Infiniium.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightInfiniium,,,,,"import re
from collections.abc import Sequence
from typing import Any, Literal, Optional, Union

import numpy as np
from pyvisa import VisaIOError
from pyvisa.constants import StatusCode

import qcodes.validators as vals
from qcodes.instrument import (
    ChannelList,
    InstrumentBase,
    InstrumentChannel,
    InstrumentModule,
    VisaInstrument,
)
from qcodes.parameters import (
    Parameter,
    ParameterBase,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.utils import deprecate


class DSOTimeAxisParam(Parameter):
    """"""
    Time axis parameter for the Infiniium series DSO.
    """"""

    def __init__(self, xorigin: float, xincrement: float, points: int, **kwargs: Any):
        """"""
        Initialize time axis. If values are unknown, they can be initialized to zero and
        filled in later.
        """"""
        super().__init__(**kwargs)

        self.xorigin = xorigin
        self.xincrement = xincrement
        self.points = points

    def get_raw(self) -> np.ndarray:
        """"""
        Return the array corresponding to this time axis.
        """"""
        return np.linspace(
            self.xorigin,
            self.xorigin + self.points * self.xincrement,
            self.points,
            endpoint=False,
        )


class DSOFrequencyAxisParam(Parameter):
    """"""
    Frequency axis parameter for the Infiniium series DSO.
    """"""

    def __init__(self, xorigin: float, xincrement: float, points: int, **kwargs: Any):
        """"""
        Initialize frequency axis. If values are unknown, they can be initialized
        to zero and filled in later.
        """"""
        super().__init__(**kwargs)

        self.xorigin = xorigin
        self.xincrement = xincrement
        self.points = points

    def get_raw(self) -> np.ndarray:
        """"""
        Return the array corresponding to this time axis.
        """"""
        return np.linspace(
            self.xorigin,
            self.xorigin + self.points * self.xincrement,
            self.points,
            endpoint=False,
        )


class DSOTraceParam(ParameterWithSetpoints):
    """"""
    Trace parameter for the Infiniium series DSO
    """"""

    UNIT_MAP = {0: ""UNKNOWN"", 1: ""V"", 2: ""s"", 3: ""''"", 4: ""A"", 5: ""dB""}

    def __init__(
        self,
        name: str,
        instrument: Union[""KeysightInfiniiumChannel"", ""KeysightInfiniiumFunction""],
        channel: str,
        **kwargs: Any,
    ):
        """"""
        Initialize DSOTraceParam bound to a specific channel.
        """"""
        self._ch_valid = False
        super().__init__(name, instrument=instrument, **kwargs)
        self._channel = channel
        # This parameter will be updated prior to being retrieved if
        # self.root_instrument.auto_digitize is true.
        self._points = 0
        self._yoffset = 0.0
        self._yincrement = 0.0
        self._unit = 0

    @property
    def setpoints(self) -> Sequence[ParameterBase]:
        """"""
        Overwrite setpoint parameter to update setpoints if auto_digitize is true
        """"""
        instrument = self.instrument
        if isinstance(instrument, KeysightInfiniiumChannel):
            root_instrument: ""KeysightInfiniium""
            root_instrument = self.root_instrument  # type: ignore[assignment]
            cache_setpoints = root_instrument.cache_setpoints()
            if not cache_setpoints:
                self.update_setpoints()
            return (instrument.time_axis,)
        elif isinstance(instrument, KeysightInfiniiumFunction):
            if instrument.function().startswith(""FFT""):
                self.update_fft_setpoints()
                return (instrument.frequency_axis,)
            else:
                self.update_setpoints()
                return (instrument.time_axis,)
        raise RuntimeError(""Invalid type for parent instrument."")

    @setpoints.setter
    def setpoints(self, val: Any) -> None:
        """"""
        Stub to allow initialization. Ignore any set attempts on setpoint as we
        figure it out on the fly.
        """"""
        return

    @property
    def unit(self) -> str:
        """"""
        Return the units for this measurement.
        """"""
        if self._ch_valid is False:
            return ""''""
        elif self._unit != 0:
            return self.UNIT_MAP[self._unit]
        elif self.instrument is not None:
            self.instrument.write(f"":WAV:SOUR {self._channel}"")
            return self.instrument.ask("":WAV:YUN?"")
        return ""''""

    @unit.setter
    def unit(self, val: Any) -> None:
        """"""
        Stub to allow initialization.
        """"""
        return

    @deprecate(""DSOTraceParam.update_setpoints"")
    def prepare_curvedata(self) -> None:
        """"""
        Deprecated method to update waveform parameters.
        """"""
        self.update_setpoints()

    def update_setpoints(self, preamble: Optional[Sequence[str]] = None) -> None:
        """"""
        Update waveform parameters. Must be called before data
        acquisition if instr.cache_setpoints is False
        """"""
        instrument: Union[KeysightInfiniiumChannel, KeysightInfiniiumFunction]
        instrument = self.instrument  # type: ignore[assignment]
        if preamble is None:
            instrument.write(f"":WAV:SOUR {self._channel}"")
            preamble = instrument.ask("":WAV:PRE?"").strip().split("","")
        self._points = int(preamble[2])
        self._yincrement = float(preamble[7])
        self._yoffset = float(preamble[8])
        self._unit = int(preamble[21])
        instrument.time_axis.points = int(preamble[2])
        instrument.time_axis.xorigin = float(preamble[5])
        instrument.time_axis.xincrement = float(preamble[4])
        self._ch_valid = True

    def update_fft_setpoints(self) -> None:
        """"""
        Update waveform parameters for an FFT.
        """"""
        instrument: KeysightInfiniiumFunction = self.instrument  # type: ignore[assignment]
        instrument.write(f"":WAV:SOUR {self._channel}"")
        preamble = instrument.ask("":WAV:PRE?"").strip().split("","")
        self.update_setpoints(preamble)
        instrument.frequency_axis.points = int(preamble[2])
        instrument.frequency_axis.xorigin = float(preamble[5])
        instrument.frequency_axis.xincrement = float(preamble[4])

    def get_raw(self) -> np.ndarray:
        """"""
        Get waveform data from scope
        """"""
        if self.instrument is None:
            raise RuntimeError(""Cannot get data without instrument"")
        root_instr: ""KeysightInfiniium"" = self.root_instrument  # type: ignore[assignment]
        # Check if we can use cached trace parameters
        if not root_instr.cache_setpoints():
            self.update_setpoints()
        if not self._ch_valid:
            raise RuntimeError(
                ""Trace parameters are unknown. If cache_setpoints is True, ""
                ""you must manually call instr.chX.update_setpoints at least""
                ""once prior to measurement.""
            )

        # Check if we should run a new sweep
        if root_instr.auto_digitize():
            root_instr.digitize()
        # Ask for waveform data
        root_instr.write(f"":WAV:SOUR {self._channel}"")
        root_instr.write("":WAV:DATA?"")
        # Ignore first two bytes, which should be ""#0""
        _ = root_instr.visa_handle.read_bytes(2)
        data: np.ndarray
        data = root_instr.visa_handle.read_binary_values(  # type: ignore[assignment]
            ""h"",
            container=np.ndarray,
            header_fmt=""empty"",
            expect_termination=True,
            data_points=self._points,
        )
        data = data.astype(np.float64)
        data = (data * self._yincrement) + self._yoffset
        return data


class AbstractMeasurementSubsystem(InstrumentModule):
    """"""
    Submodule containing the measurement subsystem commands and associated
    parameters.

    Note: these commands are executed on the waveform in the scope buffer.
    If you need to ensure a fresh value, run dso.digitize() prior to reading
    the measurement value.
    """"""

    def __init__(self, parent: InstrumentBase, name: str, **kwargs: Any) -> None:
        """"""
        Add parameters to measurement subsystem. Note: This should not be initialized
        directly, rather initialize BoundMeasurementSubsystem
        or UnboundMeasurementSubsystem.
        """"""
        super().__init__(parent, name, **kwargs)

        ###################################
        # Voltage Parameters
        self.amplitude = Parameter(
            name=""amplitude"",
            instrument=self,
            label=""Voltage amplitude"",
            get_cmd=self._create_query(""VAMP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.average = Parameter(
            name=""average"",
            instrument=self,
            label=""Voltage average"",
            get_cmd=self._create_query(""VAV"", ""DISP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.base = Parameter(
            name=""base"",
            instrument=self,
            label=""Statistical base"",
            get_cmd=self._create_query(""VBAS""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Threshold Voltage Measurements - this measurement ignores overshoot
        # in the data
        self.vlow = Parameter(
            name=""vlow"",
            instrument=self,
            label=""Lower threshold voltage"",
            get_cmd=self._create_query(""VLOW""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vmid = Parameter(
            name=""vmid"",
            instrument=self,
            label=""Middle threshold voltage"",
            get_cmd=self._create_query(""VMID""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vup = Parameter(
            name=""vup"",
            instrument=self,
            label=""Upper threshold voltage"",
            get_cmd=self._create_query(""VUPP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Limit values - the minimum/maximum shown on screen
        self.vmin = Parameter(
            name=""vmin"",
            instrument=self,
            label=""Voltage minimum"",
            get_cmd=self._create_query(""VMIN""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vmax = Parameter(
            name=""vmax"",
            instrument=self,
            label=""Voltage maximum"",
            get_cmd=self._create_query(""VMAX""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        # Waveform Parameters
        self.overshoot = Parameter(
            name=""overshoot"",
            instrument=self,
            label=""Voltage overshoot"",
            get_cmd=self._create_query(""VOV""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vpp = Parameter(
            name=""vpp"",
            instrument=self,
            label=""Voltage peak-to-peak"",
            get_cmd=self._create_query(""VPP""),
            get_parser=float,
            unit=""V"",
            snapshot_value=False,
        )
        self.vrms = Parameter(
            name=""vrms"",
            instrument=self,
            label=""Voltage RMS"",
            get_cmd=self._create_query(""VRMS"", ""CYCL,AC""),
            get_parser=float,
            unit=""V_rms"",
            snapshot_value=False,
        )
        self.vrms_dc = Parameter(
            name=""vrms_dc"",
            instrument=self,
            label=""Voltage RMS with DC Component"",
            get_cmd=self._create_query(""VRMS"", ""CYCL,DC""),
            get_parser=float,
            unit=""V_rms"",
            snapshot_value=False,
        )

        ###################################
        # Time Parameters
        self.rise_time = Parameter(
            name=""rise_time"",
            instrument=self,
            label=""Rise time"",
            get_cmd=self._create_query(""RIS""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.fall_time = Parameter(
            name=""fall_time"",
            instrument=self,
            label=""Fall time"",
            get_cmd=self._create_query(""FALL""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.duty_cycle = Parameter(
            name=""duty_cycle"",
            instrument=self,
            label=""Duty Cycle"",
            get_cmd=self._create_query(""DUTY""),
            get_parser=float,
            unit=""%"",
            snapshot_value=False,
        )
        self.period = Parameter(
            name=""period"",
            instrument=self,
            label=""Period"",
            get_cmd=self._create_query(""PER""),
            get_parser=float,
            unit=""s"",
            snapshot_value=False,
        )
        self.frequency = Parameter(
            name=""frequency"",
            instrument=self,
            label=""Signal frequency"",
            get_cmd=self._create_query(""FREQ""),
            get_parser=float,
            unit=""Hz"",
            docstring=""""""
                                     measure the frequency of the first
                                     complete cycle on the screen using
                                     the mid-threshold levels of the waveform
                                     """""",
            snapshot_value=False,
        )
        self.slew_rate = Parameter(
            name=""slew_rate"",
            instrument=self,
            label=""Slew rate"",
            get_cmd=self._create_query(""SLEW""),
            get_parser=float,
            unit=""S"",
            snapshot_value=False,
        )

        ###################################
        # Deprecated parameter aliases
        self.rms = self.vrms_dc
        self.rms_no_dc = self.vrms
        self.min = self.vmin
        self.middle = self.vmid
        self.max = self.vmax
        self.lower = self.vlow

    def _create_query(self, cmd: str, pre_cmd: str = """", post_cmd: str = """") -> str:
        """"""
        Create a query string with the correct source included
        """"""
        chan_str = self._channel
        if chan_str:
            if pre_cmd:
                chan_str = f"",{chan_str}""
            if post_cmd:
                chan_str = f""{chan_str},""
        else:
            if pre_cmd and post_cmd:
                pre_cmd = f""{pre_cmd},""
        return f"":MEAS:{cmd}? {pre_cmd}{chan_str}{post_cmd}"".strip()


class KeysightInfiniiumBoundMeasurement(AbstractMeasurementSubsystem):
    def __init__(
        self,
        parent: Union[""KeysightInfiniiumChannel"", ""KeysightInfiniiumFunction""],
        name: str,
        **kwargs: Any,
    ):
        """"""
        Initialize measurement subsystem bound to a specific channel
        """"""
        # Bind the channel
        self._channel = parent.channel_name

        # Initialize measurement parameters
        super().__init__(parent, name, **kwargs)


BoundMeasurement = KeysightInfiniiumBoundMeasurement
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumUnboundMeasurement(AbstractMeasurementSubsystem):
    def __init__(self, parent: ""KeysightInfiniium"", name: str, **kwargs: Any):
        """"""
        Initialize measurement subsystem where target is set by the parameter `source`.
        """"""
        # Blank channel
        self._channel = """"

        # Initialize measurement parameters
        super().__init__(parent, name, **kwargs)

        self.source = Parameter(
            name=""source"",
            instrument=self,
            label=""Primary measurement source"",
            set_cmd=self._set_source,
            get_cmd=self._get_source,
            snapshot_value=False,
        )

    def _validate_source(self, source: str) -> str:
        """"""Validate and set the source.""""""
        valid_channels = f""CHAN[1-{self.root_instrument.no_channels}]""
        if re.fullmatch(valid_channels, source):
            if not int(self.ask(f""CHAN{source[-1]}:DISP?"")):
                raise ValueError(f""Channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""DIFF[1-2]"", source):
            diff_chan = (int(source[-1]) - 1) * 2 + 1
            if int(self.ask(f""CHAN{diff_chan}:DIFF?"")) != 1:
                raise ValueError(f""Differential channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""COMM[1-2]"", source):
            diff_chan = (int(source[-1]) - 1) * 2 + 1
            if int(self.ask(f""CHAN{diff_chan}:DIFF?"")) != 1:
                raise ValueError(f""Differential channel {source[-1]} not turned on."")
            return source
        if re.fullmatch(""WMEM[1-4]"", source):
            return source
        match = re.fullmatch(""FUNC([1-9]{1,2})"", source)
        if match:
            func_chan = int(match.groups()[0])
            if not (1 <= func_chan <= 16):
                raise ValueError(
                    f""Function number should be in the range 1-16. Got {func_chan}.""
                )
            if not int(self.ask(f""FUNC{func_chan}:DISP?"")):
                raise ValueError(f""Function {func_chan} is not enabled."")
            return f""FUNC{func_chan}""

        raise ValueError(
            f""Invalid measurement source {source}. Valid values are: (""
            ""CHAN[1-4], DIFF[1-2], COMM[1-2], WMEM[1-4], FUNC[1-16]).""
        )

    def _set_source(self, source: str) -> None:
        source = self._validate_source(source)
        self._channel = source

        # Then set the measurement source
        self.write(f"":MEAS:SOUR {self._channel}"")

    def _get_source(self) -> str:
        if self._channel == """":
            source = self.ask("":MEAS:SOUR?"")
            self._channel = source.strip().split("","")[0]
        return self._channel


UnboundMeasurement = KeysightInfiniiumUnboundMeasurement
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumFunction(InstrumentChannel):
    def __init__(
        self, parent: ""KeysightInfiniium"", name: str, channel: int, **kwargs: Any
    ):
        """"""
        Initialize an infiniium channel.
        """"""
        self._channel = channel
        super().__init__(parent, name, **kwargs)

        # display
        self.display = Parameter(
            name=""display"",
            instrument=self,
            label=f""Function {channel} display on/off"",
            set_cmd=f""FUNC{channel}:DISP {{}}"",
            get_cmd=f""FUNC{channel}:DISP?"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        # Retrieve basic settings of the function
        self.function = Parameter(
            name=""function"",
            instrument=self,
            label=f""Function {channel} function"",
            get_cmd=self._get_func,
            vals=vals.Strings(),
        )
        self.source = Parameter(
            name=""source"",
            instrument=self,
            label=f""Function {channel} source"",
            get_cmd=f""FUNC{channel}?"",
        )

        # Trace settings
        self.points = Parameter(
            name=""points"",
            instrument=self,
            label=f""Function {channel} points"",
            get_cmd=self._get_points,
        )
        self.frequency_axis = DSOFrequencyAxisParam(
            name=""frequency_axis"",
            instrument=self,
            label=""Frequency"",
            unit=""Hz"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )
        self.time_axis = DSOTimeAxisParam(
            name=""time_axis"",
            instrument=self,
            label=""Time"",
            unit=""s"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )
        self.trace = DSOTraceParam(
            name=""trace"",
            instrument=self,
            label=f""Function {channel} trace"",
            channel=self.channel_name,
            vals=vals.Arrays(shape=(self.points,)),
            snapshot_value=False,
        )

        # Measurement subsystem
        self.add_submodule(
            ""measure"", KeysightInfiniiumBoundMeasurement(self, ""measure"")
        )

    @property
    def channel(self) -> int:
        return self._channel

    @property
    def channel_name(self) -> str:
        return f""FUNC{self._channel}""

    def _get_points(self) -> int:
        """"""
        Return the number of points in the current function. This may be
        different to the number of points in the source as often functions
        modify the number of points.
        """"""
        self.write(f"":WAV:SOUR {self.channel_name}"")
        return int(self.ask("":WAV:POIN?""))

    def _get_func(self) -> str:
        """"""
        Return the function applied to the sources for this function
        """"""
        try:
            self.write("":SYST:HEAD ON"")
            func, _ = self.ask(f"":{self.channel_name}?"").strip().split()
            match = re.fullmatch(f"":{self.channel_name}:([\\w]+)"", func)
            if match:
                return match.groups()[0]
            raise ValueError(
                f""Couldn't extract function for {self.channel_name}. Got {func}""
            )
        finally:
            self.write("":SYST:HEAD OFF"")


InfiniiumFunction = KeysightInfiniiumFunction
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniiumChannel(InstrumentChannel):
    def __init__(
        self, parent: ""KeysightInfiniium"", name: str, channel: int, **kwargs: Any
    ):
        """"""
        Initialize an infiniium channel.
        """"""
        self._channel = channel

        super().__init__(parent, name, **kwargs)
        # display
        self.display = Parameter(
            name=""display"",
            instrument=self,
            label=f""Channel {channel} display on/off"",
            set_cmd=f""CHAN{channel}:DISP {{}}"",
            get_cmd=f""CHAN{channel}:DISP?"",
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        # scaling
        self.offset = Parameter(
            name=""offset"",
            instrument=self,
            label=f""Channel {channel} offset"",
            set_cmd=f""CHAN{channel}:OFFS {{}}"",
            unit=""V"",
            get_cmd=f""CHAN{channel}:OFFS?"",
            get_parser=float,
        )
        self.range = Parameter(
            name=""range"",
            instrument=self,
            label=f""Channel {channel} range"",
            unit=""V"",
            set_cmd=f""CHAN{channel}:RANG {{}}"",
            get_cmd=f""CHAN{channel}:RANG?"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Trigger level
        self.trigger_level = Parameter(
            name=""trigger_level"",
            instrument=self,
            label=f""Channel {channel} trigger level"",
            unit=""V"",
            set_cmd=f"":TRIG:LEV CHAN{channel},{{}}"",
            get_cmd=f"":TRIG:LEV? CHAN{channel}"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Trace data
        self.time_axis = DSOTimeAxisParam(
            name=""time_axis"",
            instrument=self,
            label=""Time"",
            unit=""s"",
            xorigin=0.0,
            xincrement=0.0,
            points=1,
            vals=vals.Arrays(shape=(self.parent.acquire_points,)),
            snapshot_value=False,
        )
        self.trace = DSOTraceParam(
            name=""trace"",
            instrument=self,
            label=f""Channel {channel} trace"",
            unit=""V"",
            channel=self.channel_name,
            vals=vals.Arrays(shape=(self.parent.acquire_points,)),
            snapshot_value=False,
        )

        # Measurement subsystem
        self.add_submodule(
            ""measure"", KeysightInfiniiumBoundMeasurement(self, ""measure"")
        )

    @property
    def channel(self) -> int:
        return self._channel

    @property
    def channel_name(self) -> str:
        return f""CHAN{self._channel}""

    def update_setpoints(self) -> None:
        """"""
        Update time axis and offsets for this channel.
        Calling this function is required when instr.cache_setpoints is True
        whenever the scope parameters are changed.
        """"""
        self.trace.update_setpoints()


InfiniiumChannel = KeysightInfiniiumChannel
""""""
Alias for backwards compatibility
""""""


class KeysightInfiniium(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Keysight Infiniium oscilloscopes
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        timeout: float = 20,
        channels: int = 4,
        silence_pyvisapy_warning: bool = False,
        **kwargs: Any,
    ):
        """"""
        Initialises the oscilloscope.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: Visa timeout, in secs.
            channels: The number of channels on the scope.
            silence_pyvisapy_warning: Don't warn about pyvisa-py at startup
        """"""
        super().__init__(name, address, timeout=timeout, terminator=""\n"", **kwargs)
        self.connect_message()

        # Check if we are using pyvisa-py as our visa lib and warn users that
        # this may cause long digitize operations to fail
        if (
            self.visa_handle.visalib.library_path == ""py""
            and not silence_pyvisapy_warning
        ):
            self.log.warning(
                ""Timeout not handled correctly in pyvisa_py. This may cause""
                "" long acquisitions to fail. Either use ni/keysight visalib""
                "" or set timeout to longer than longest expected acquisition""
                "" time.""
            )

        # switch the response header off else none of our parameters will work
        self.write("":SYSTem:HEADer OFF"")

        # Then set up the data format used to retrieve waveforms
        self.write("":WAVEFORM:FORMAT WORD"")
        self.write("":WAVEFORM:BYTEORDER LSBFirst"")
        self.write("":WAVEFORM:STREAMING ON"")

        # Query the oscilloscope parameters
        # Set sample rate, bandwidth and memory depth limits
        self._query_capabilities()
        # Number of channels can't be queried on most older scopes. Use a parameter
        # for now.
        self.no_channels = channels

        # Run state
        self.run_mode = Parameter(
            name=""run_mode"",
            instrument=self,
            label=""run mode"",
            get_cmd="":RST?"",
            vals=vals.Enum(""RUN"", ""STOP"", ""SING""),
        )

        # Timing Parameters
        self.timebase_range = Parameter(
            name=""timebase_range"",
            instrument=self,
            label=""Range of the time axis"",
            unit=""s"",
            get_cmd="":TIM:RANG?"",
            set_cmd="":TIM:RANG {}"",
            vals=vals.Numbers(5e-12, 20),
            get_parser=float,
        )
        self.timebase_position = Parameter(
            name=""timebase_position"",
            instrument=self,
            label=""Offset of the time axis"",
            unit=""s"",
            get_cmd="":TIM:POS?"",
            set_cmd="":TIM:POS {}"",
            vals=vals.Numbers(),
            get_parser=float,
        )
        self.timebase_roll_enabled = Parameter(
            name=""timebase_roll_enabled"",
            instrument=self,
            label=""Is rolling mode enabled"",
            get_cmd="":TIM:ROLL:ENABLE?"",
            set_cmd="":TIM:ROLL:ENABLE {}"",
            val_mapping={True: 1, False: 0},
        )

        # Trigger
        self.trigger_mode = Parameter(
            name=""trigger_mode"",
            instrument=self,
            label=""Trigger mode"",
            get_cmd="":TRIG:MODE?"",
        )
        self.trigger_sweep = Parameter(
            name=""trigger_sweep"",
            instrument=self,
            label=""Trigger sweep mode"",
            get_cmd="":TRIG:SWE?"",
            set_cmd="":TRIG:SWE {}"",
            vals=vals.Enum(""AUTO"", ""TRIG""),
        )
        self.trigger_state = Parameter(
            name=""trigger_state"",
            instrument=self,
            label=""Trigger state"",
            get_cmd="":AST?"",
            vals=vals.Enum(""ARM"", ""TRIG"", ""ATRIG"", ""ADONE""),
            snapshot_value=False,
        )

        # Edge trigger parameters
        # Note that for now we only support parameterized edge triggers - this may
        # be something worth expanding.
        # To set trigger level, use the ""trigger_level"" parameter in each channel
        self.trigger_edge_source = Parameter(
            name=""trigger_edge_source"",
            instrument=self,
            label=""Source channel for the edge trigger"",
            get_cmd="":TRIGger:EDGE:SOURce?"",
            set_cmd="":TRIGger:EDGE:SOURce {}"",
            vals=vals.Enum(
                *(
                    [f""CHAN{i}"" for i in range(1, 4 + 1)]
                    + [f""DIG{i}"" for i in range(16 + 1)]
                    + [""AUX"", ""LINE""]
                )
            ),
        )
        self.trigger_edge_slope = Parameter(
            name=""trigger_edge_slope"",
            instrument=self,
            label=""slope of the edge trigger"",
            get_cmd="":TRIGger:EDGE:SLOPe?"",
            set_cmd="":TRIGger:EDGE:SLOPe {}"",
            vals=vals.Enum(""POS"", ""POSITIVE"", ""NEG"", ""NEGATIVE"", ""EITH""),
        )
        self.trigger_level_aux = Parameter(
            name=""trigger_level_aux"",
            instrument=self,
            label=""Tirgger level AUX"",
            unit=""V"",
            get_cmd="":TRIGger:LEVel? AUX"",
            set_cmd="":TRIGger:LEVel AUX,{}"",
            get_parser=float,
            vals=vals.Numbers(),
        )

        # Aquisition
        # If sample points, rate and timebase_scale are set in an
        # incomensurate way, the scope only displays part of the waveform
        self.acquire_points = Parameter(
            name=""acquire_points"",
            instrument=self,
            label=""sample points"",
            get_cmd="":ACQ:POIN?"",
            set_cmd="":ACQ:POIN {}"",
            get_parser=int,
            vals=vals.Numbers(min_value=self.min_pts, max_value=self.max_pts),
        )
        self.sample_rate = Parameter(
            name=""sample_rate"",
            instrument=self,
            label=""sample rate"",
            get_cmd="":ACQ:SRAT?"",
            set_cmd="":ACQ:SRAT {}"",
            unit=""Hz"",
            get_parser=float,
            vals=vals.Numbers(min_value=self.min_srat, max_value=self.max_srat),
        )
        # Note: newer scopes allow a per-channel bandwidth. This is not implemented yet.
        self.bandwidth = Parameter(
            name=""bandwidth"",
            instrument=self,
            label=""bandwidth"",
            get_cmd="":ACQ:BAND?"",
            set_cmd="":ACQ:BAND {}"",
            unit=""Hz"",
            get_parser=float,
            vals=vals.Numbers(min_value=self.min_bw, max_value=self.max_bw),
        )
        self.acquire_interpolate = Parameter(
            name=""acquire_interpolate"",
            instrument=self,
            get_cmd="":ACQ:INTerpolate?"",
            set_cmd="":ACQuire:INTerpolate {}"",
            vals=vals.Enum(0, 1, ""INT1"", ""INT2"", ""INT4"", ""INT8"", ""INT16"", ""INT32""),
        )
        self.acquire_mode = Parameter(
            name=""acquire_mode"",
            instrument=self,
            label=""Acquisition mode"",
            get_cmd=""ACQuire:MODE?"",
            set_cmd=""ACQuire:MODE {}"",
            vals=vals.Enum(
                ""ETIMe"",
                ""RTIMe"",
                ""PDETect"",
                ""HRESolution"",
                ""SEGMented"",
                ""SEGPdetect"",
                ""SEGHres"",
            ),
        )
        self.average = Parameter(
            name=""average"",
            instrument=self,
            label=""Averages"",
            get_cmd=self._get_avg,
            set_cmd=self._set_avg,
            vals=vals.Ints(min_value=1, max_value=10486575),
        )

        # Automatically digitize before acquiring a trace
        self.auto_digitize: Parameter = Parameter(
            name=""auto_digitize"",
            instrument=self,
            label=""Auto digitize"",
            set_cmd=None,
            get_cmd=None,
            val_mapping=create_on_off_val_mapping(),
            docstring=(
                ""Digitize before each waveform download. ""
                ""If you need to acquire from multiple channels simultaneously ""
                ""or you wish to acquire with the scope running freely, ""
                ""set this value to False.""
            ),
            initial_value=True,
        )
        self.cache_setpoints: Parameter = Parameter(
            name=""cache_setpoints"",
            instrument=self,
            label=""Cache setpoints"",
            set_cmd=None,
            get_cmd=None,
            val_mapping=create_on_off_val_mapping(),
            docstring=(
                ""Cache setpoints. If false, the preamble is queried before each""
                "" acquisition, which may add latency to measurements. If you""
                "" are taking repeated measurements, set this to True and update""
                "" setpoints manually by calling `instr.chX.update_setpoints()`.""
            ),
            initial_value=False,
        )

        # Channels
        _channels = ChannelList(
            self, ""channels"", KeysightInfiniiumChannel, snapshotable=False
        )
        for i in range(1, self.no_channels + 1):
            channel = KeysightInfiniiumChannel(self, f""chan{i}"", i)
            _channels.append(channel)
            self.add_submodule(f""ch{i}"", channel)
        self.add_submodule(""channels"", _channels.to_channel_tuple())

        # Functions
        _functions = ChannelList(
            self, ""functions"", KeysightInfiniiumFunction, snapshotable=False
        )
        for i in range(1, 16 + 1):
            function = KeysightInfiniiumFunction(self, f""func{i}"", i)
            _functions.append(function)
            self.add_submodule(f""func{i}"", function)
        # Have to call channel list ""funcs"" here as functions is a
        # reserved name in Instrument.
        self.add_submodule(""funcs"", _functions.to_channel_tuple())

        # Submodules
        meassubsys = KeysightInfiniiumUnboundMeasurement(self, ""measure"")
        self.add_submodule(""measure"", meassubsys)

    def _query_capabilities(self) -> None:
        """"""
        Query scope capabilities (sample rate, bandwidth, memory depth)
        """"""
        try:
            # Bandwidth
            self.min_bw, self.max_bw = 0.0, 99.0e9  # Set default limits
            bw = self.ask("":ACQ:BAND:TESTLIMITS?"")
            match = re.fullmatch(
                r""1,<numeric>([0-9.]+E\+[0-9]+):([0-9.]+E\+[0-9]+)"", bw
            )
            if match:
                self.min_bw, self.max_bw = (float(f) for f in match.groups())
                self.log.info(f""Scope BW: {self.min_bw}-{self.max_bw}"")
                self._meta_attrs.extend((""min_bw"", ""max_bw""))
            else:
                self.log.warning(
                    f""Unable to query bandwidth limits (inv. format ({bw})). ""
                    f""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query bandwidth limits ({e}). Setting limits to default.""
            )

        # Memory depth
        try:
            self.min_pts, self.max_pts = 16, 1_000_000_000
            mem = self.ask("":ACQ:POIN:TESTLIMITS?"")
            match = re.match(""1,<numeric>([0-9]+):([0-9]+)"", mem)
            if match:
                self.min_pts, self.max_pts = (int(p) for p in match.groups())
                self.log.info(f""Scope memory: {self.min_pts}-{self.max_pts}"")
                self._meta_attrs.extend((""min_pts"", ""max_pts""))
            else:
                self.log.warning(
                    f""Unable to query memory depth (inv. format ({mem})). ""
                    ""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query memory depth ({e}). Setting limits to default.""
            )

        # Sample Rate
        try:
            # Set BW to auto in order to query this
            bw_set: Union[float, Literal[""AUTO""]] = float(self.ask("":ACQ:BAND?""))
            if np.isclose(bw_set, self.max_bw):
                # Auto returns max bandwidth
                bw_set = ""AUTO""
            self.write("":ACQ:BAND AUTO"")
            self.min_srat, self.max_srat = 10.0, 99.0e9  # Set large limits
            srat = self.ask("":ACQ:SRAT:TESTLIMITS?"")
            self.write(f"":ACQ:BAND {bw_set}"")
            match = re.fullmatch(
                r""1,<numeric>([0-9.]+E\+[0-9]+):([0-9.]+E\+[0-9]+)"", srat
            )
            if match:
                self.min_srat, self.max_srat = (float(f) for f in match.groups())
                self.log.info(f""Scope sample rate: {self.min_srat}-{self.max_srat}"")
                self._meta_attrs.extend((""min_srat"", ""max_srat""))
            else:
                self.log.warning(
                    f""Unable to query sample rate (inv. format ({srat})). ""
                    ""Setting limits to default.""
                )
        except VisaIOError as e:
            self.log.warning(
                f""Unable to query sample rate ({e}). Setting limits to default.""
            )

    def _get_avg(self) -> int:
        """"""
        Return the number of averages, or 1 if averaging is disabled.
        """"""
        enabled = int(self.ask("":ACQ:AVER?""))
        if not enabled:
            return 1
        else:
            return int(self.ask("":ACQ:AVER:COUN?""))

    def _set_avg(self, count: int) -> None:
        """"""
        Set the number of averages, or disable if 1.
        """"""
        if count == 1:
            self.write("":ACQ:AVER 0"")
        else:
            self.write(f"":ACQ:AVER:COUN {count}"")
            self.write("":ACQ:AVER 1"")

    # Simple oscilloscope commands
    def run(self) -> None:
        """"""
        Set the scope in run mode.
        """"""
        self.write("":RUN"")
        self.run_mode()

    def stop(self) -> None:
        """"""
        Set the scope in stop mode.
        """"""
        self.write("":STOP"")
        self.run_mode()

    def single(self) -> None:
        """"""
        Take a single acquisition
        """"""
        self.write("":SING"")
        self.run_mode()

    def update_all_setpoints(self) -> None:
        """"""
        Update the setpoints for all enabled channels.
        This method may be run at the beginning of a measurement rather
        than looping through each channel manually.
        """"""
        for channel in self.channels:
            if channel.display():
                channel.update_setpoints()

    def digitize(self, timeout: Optional[int] = None) -> None:
        """"""
        Digitize a full waveform and block until the acquisition is complete.

        Warning: If using pyvisa_py as your visa library, this will not work with
        acquisitions longer than a single timeout period. If you require long
        acquisitions either use Keysight/NI Visa or set timeout to be longer than
        the expected acquisition time.
        """"""
        old_timeout = self.visa_handle.timeout
        if timeout is not None:
            self.visa_handle.timeout = timeout  # 1 second timeout
        try:
            self.visa_handle.write("":DIGITIZE;*OPC?"")
            ret = None
            # Wait until we receive the ""complete"" reply
            while ret != ""1"":
                try:
                    ret = self.visa_handle.read()
                except VisaIOError as e:
                    # Ignore timeout errors - we could still be waiting for a trigger
                    # or taking a long acquisition
                    if e.error_code != StatusCode.error_timeout:
                        self.log.exception(
                            ""Unexpected VisaError while waiting for acquisition.""
                        )
                        raise  # Raise all other visa errors
        except KeyboardInterrupt:
            self.log.error(
                ""Keyboard interrupt while waiting to digitize. Check your trigger?""
            )
            raise  # Pass error upwards
        finally:
            # Clear the device to unblock any failed digitize
            self.device_clear()
            if timeout is not None:
                self.visa_handle.timeout = old_timeout


Infiniium = KeysightInfiniium
""""""
Alias for backwards compatibility
""""""
"
117,25.0,USA,"The SR560 is a high-performance, low-noise preamplifier that is ideal for a wide variety of applications including low-temperature measurements, optical detection, and audio engineering.",SR 560,534.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} Preamplifier,"https://en.wikipedia.org/wiki/Preamplifier#:~:text=A%20preamplifier%2C%20also%20known%20as,power%20amplifier%20and%20a%20loudspeaker.",['Preamplifier'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker. Without this, the final signal would be noisy or distorted. They are typically used to amplify signals from analog sensors such as microphones and pickups. Because of this, the preamplifier is often placed close to the sensor to reduce the effects of noise and interference.",,https://www.thinksrs.com/downloads/pdfs/catalog/SR560c.pdf,"[OrderedDict([('id', 'attATdjuiA6tfEmYQ'), ('width', 3163), ('height', 2157), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VclRWPT0iAhJzT4H9VNyTw/DKtd4t3AvjEFScvRqF0fgnODYaTSH52aK9m9kOen-mdPAkqlRicIERFlh3HDMm-LuFW7qTEZk4FPYHMswp2wcXSF0XKt1Su0jWEaeMiKqkw/aBNWZqxlR1sGH_HJFM-btCv61emt58L4mCOcQ9qtRvM'), ('filename', 'SR560 Wide.jpg'), ('size', 1372854), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dBLujDiLW1W6lvpDSHd-CA/A1LLTtqfOxT9TbvNl2skkrwM7nxdOmkniNIeDP0sPmLBbyCsaJkNI4mHTuYGjrRPFIMaboj-aA7D70BDGdppKQ/a3E-DB4A8Z4gEIrcBfihjzYHOKLssYOMHLZdNFLsvQg'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gpUGyaA_Ci7iz1FWu6Mi9A/aaCcMBLtz058h7uUT-CnaRQ8WetNDw4P2c98qtvT82ClLNI9Ayn6RmVs0nnxI2DFIGFkRKeTcYDBBTNKBucCkA/g2TyrSkrNwOMswD39T8ABsSWrHkLB4yR_Zh2uI-d_hM'), ('width', 751), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/y8V3oEIk7Xxz2rRHxS61eA/tqGzEuu7oujD7KjgqUQyXf-_uo7y-gkx9nDfZ4CnrygcyBldM9fNFSArFoEjGhZYuJc8mTsBVPcNntrCFiNSGQ/zsbjbBLY16QEZv0a9qEUNZysZyR_zugDVxnvoIYo4Zg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr560.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR560.py,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR560,2895.0,,,,"from typing import Any, Optional

from qcodes.instrument import Instrument
from qcodes.parameters import MultiParameter, Parameter, ParamRawDataType
from qcodes.validators import Bool, Enum


class VoltageParameter(MultiParameter):
    """"""
    Amplified voltage measurement via an SR560 preamp and a measured voltage.

    To be used when you feed a voltage into an SR560, send the SR560's
    output voltage to a lockin or other voltage amplifier, and you have
    the voltage reading from that amplifier as a qcodes parameter.

    ``VoltageParameter.get()`` returns ``(voltage_raw, voltage)``

    Args:
        measured_param: a gettable parameter returning the
            voltage read from the SR560 output.
        v_amp_ins: an SR560 instance where you manually
            maintain the present settings of the real SR560 amp.

            Note: it should be possible to use other voltage preamps, if they
            define parameters ``gain`` (V_out / V_in) and ``invert``
            (bool, output is inverted)

        name: the name of the current output. Default 'volt'.
            Also used as the name of the whole parameter.
    """"""
    def __init__(self,
                 measured_param: Parameter,
                 v_amp_ins: ""SR560"",
                 name: str = 'volt',
                 snapshot_value: bool = True):
        p_name = measured_param.name

        super().__init__(name=name,
                         names=(p_name+'_raw', name),
                         shapes=((), ()),
                         instrument=v_amp_ins)

        self._measured_param = measured_param

        p_label = getattr(measured_param, ""label"", """")
        p_unit = getattr(measured_param, ""unit"", """")

        self.labels = (p_label, 'Voltage')
        self.units = (p_unit, 'V')

    def get_raw(self) -> tuple[ParamRawDataType, ParamRawDataType]:
        volt = self._measured_param.get()
        assert isinstance(self.instrument, SR560)
        volt_amp = volt / self.instrument.gain.get()

        if self.instrument.invert.get():
            volt_amp *= -1

        value = (volt, volt_amp)
        return value


class SR560(Instrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SR560 Voltage-preamplifier.

    This is a virtual driver only and will not talk to your instrument.

    Note:

    - The ``cutoff_lo`` and ``cutoff_hi`` parameters will interact with
      each other on the instrument (hi cannot be <= lo) but this is not
      managed here, you must ensure yourself that both are correct whenever
      you change one of them.

    - ``gain`` has a vernier setting, which does not yield a well-defined
      output. We restrict this driver to only the predefined gain values.

    """"""
    def __init__(self, name: str, **kwargs: Any):
        super().__init__(name, **kwargs)

        cutoffs = ['DC', 0.03, 0.1, 0.3, 1, 3, 10, 30, 100, 300, 1000,
                   3000, 10000, 30000, 100000, 300000, 1000000]

        gains = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000,
                 10000, 20000, 50000]

        self.add_parameter('cutoff_lo',
                           get_cmd=None, set_cmd=None,
                           initial_value='DC',
                           label='High pass',
                           unit='Hz',
                           vals=Enum(*cutoffs))

        self.add_parameter('cutoff_hi',
                           get_cmd=None, set_cmd=None,
                           initial_value=1e6,
                           label='Low pass',
                           unit='Hz',
                           vals=Enum(*cutoffs))

        self.add_parameter('invert',
                           get_cmd=None, set_cmd=None,
                           initial_value=True,
                           label='Inverted output',
                           vals=Bool())

        self.add_parameter('gain',
                           get_cmd=None, set_cmd=None,
                           initial_value=10,
                           label='Gain',
                           unit=None,
                           vals=Enum(*gains))

    def get_idn(self) -> dict[str, Optional[str]]:
        vendor = 'Stanford Research Systems'
        model = 'SR560'
        serial = None
        firmware = None

        return {'vendor': vendor, 'model': model,
                'serial': serial, 'firmware': firmware}
"
121,110.6,"Cleveland, Ohio, United States",,Keithley 2600,255.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2600MeasurementStatus,,,,,
131,38.0,Switzerland,"The Zurich Instruments HDAWG multi-channel Arbitrary Waveform Generator has one of the highest channel densities available in its class and is designed for advanced signal generation up to 750 MHz bandwidth. The HDAWG comes with either 4 or 8 DC-coupled, single-ended analog output channels with 16-bit vertical resolution.",Hdawg,647.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a HDAWG Wavemeters,,['Wavemeters'],,HDAWG,https://docs.zhinst.com/pdf/ziHDAWG_UserManual.pdf,"[OrderedDict([('id', 'attDrX4Vlwjak4Pks'), ('width', 1183), ('height', 549), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FoVD0uU2Xxoqf3R74hxJJw/OHRvW6ypEGePYqjpcQEOAw_cQ6ff2bbe-tyb0r7l3sabMjCB96farh7alph1DfgBmZaIGWF5YRv5QGXmBmx9AkRG61-xBFkQTRVECRK21BK194BqD8iVDXQIR-u8c6Ao/7APXsiKhG-KbU9pgMzg-hnUfJkXWXJPPGBH038lkYVQ'), ('filename', 'hdawg8_front_2560.jpg.webp'), ('size', 57176), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/k4Y28VYkoQgbaCRwfZprNg/cW2vQl_QHyG0MapRLIm8qPXsiA1WHflmgj4MRA4yVOFbyYlyMOa-Lrmcmpr6vztIg0HDizuJJjG3Ewmx2FdL7PIQad96xwH_Z55nhcL8cGA/RdjSrWDXW2hOZUgoAHVVvEhd09nQeLjYAlMEN79frGY'), ('width', 78), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WAa9Kqgyjw-TEpoG2Q_Peg/cd7rvw1N1n3cr81LvAeEejxskxFqTBO-IHphSwy78_FgaDhy_LrxcNgCNSyIFshoEGBwerCQiZ0-2aWK6vHXQU0pjO0XN_Z6u_Oq5sFiKy0/KQRXHH_qhO2FhG7meAC6djFwNq5SZjJc5_m7PPiwmmY'), ('width', 1103), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vNM9RudUc_RfpsAplhAY_w/8JYngai8rcmOQAOovuUr6TF83YAiG43pFw-O-y5XdusJHPXK0xwFdnihbuCm4YmdK1Rt2lsGRmz3JVV1YI6G7_SC9flHQZG9OfVamJNJwEc/ufPd999bhXHghEdyQ2n5q_kSXyBvtJ_Ivm0tMBQ8lrQ'), ('width', 3000), ('height', 3000)]))]))])]",https://zhinst.com/americas/en/products/hdawg-arbitrary-waveform-generator,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/hdawg.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.device_creator.HDAWG.html,,,,,"""""""Autogenerated module for the HDAWG QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWG(ZINode):
    """"""AWG node.

    This class implements the basic functionality for the device specific
    arbitrary waveform generator.
    Besides the upload/compilation of sequences it offers the upload of
    waveforms and command tables.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        session: Underlying session.
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        device_type: Device type
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, f""awg_{index}"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)


class HDAWG(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments HDAWG.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.awgs:

            channel_list = ZIChannelList(
                self,
                ""awgs"",
                AWG,
                zi_node=self._tk_object.awgs.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.awgs):
                channel_list.append(
                    AWG(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.awgs[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""awgs"", channel_list)

    def enable_qccs_mode(self) -> None:
        """"""Configure the instrument to work with PQSC.

        This method sets the reference clock source to
        connect the instrument to the PQSC.

        Info:
            Use ``factory_reset`` to reset the changes if necessary
        """"""
        return self._tk_object.enable_qccs_mode()
"
135,5420.0,USA,"E8267C PSG Vector Signal Generator, up to 20 GHz","Agilent E8267C
",,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT E8267C RF Signal Generator,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.",KEYSIGHT E8267C,,"[OrderedDict([('id', 'attMiPyIGeW8iWRJp'), ('width', 482), ('height', 272), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eZhv_9ph3yV2DfbojPk3Aw/gT3_89Ml43UM_WyLXwzhwMsvAhkuVYdtK97t20G8uD7Emt5GHnaDzk_djKMZHOX_LuHdIPCV7LOyG014p0sgIio8SK4AlC-M8WNC96Bp3B4/uzvFzHyG29uMnYfH5N5d3MLxUlsM015R7jI5zbD7ecc'), ('filename', 'E8267C.webp'), ('size', 20484), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK5afoKzLx87Gr3vCVq5wQ/ASoTcLrdQZ8hHqHGbNaASti1sA61fPJ9J3IGfzck4UBvHLCMGHhlxDxMPaZAfu5hfsQjQS_cerYxMwByKxvRAHlDgw9d1cthLc_kbUPz1jM/tqk4U3zP9yk4MbxcfzLeirgsT3upiHB7BcB8sIOeiNw'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fE0NbgHaGQEaOWHK1sf3sA/MI6W_ca5Y6syoakEubcierXlLxOgmCF64Uoq6Ab4Fs8irM--9NzXcx_Ytt6v1liJakfVmXl_E2gJLe560IhgyqxlxxYQhH_eRwzJepIeUPo/MjJ4RPkCh0HKWi20R0I9HRa7A43lwPsH-Ugl0SPqcTI'), ('width', 482), ('height', 272)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FhERf0-R6SNfIuiRX-fsgQ/HG4M0wMMAwFKZGr0d7RGVfqlTTVhT7yeA1qrEITZ8e5R2vhSgnMfftBRcmZTUDzZJygvP9aZ3sW9SMKH7h7PG13wHSEslDkb2UsgzK1qOYM/Yb2oDbzqag6Tjg3cUCJyeqFr1MVXyiy7zRw1kTm8r2A'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E8267C/psg-vector-signal-generator.html,https://github.com/morgan-at-keysight/pyarbtools/blob/c42a10c501d7a678819d35581f6386869d81d390/examples.py,,,"
",True,,"""""""
examples
Author: Morgan Allison, Keysight RF/uW Application Engineer
Provides example scripts for generic VSGs, and AWGs using
instrument classes from PyArbTools.
""""""

import pyarbtools


def vsg_chirp_example(ipAddress):
    """"""Creates downloads, assigns, and plays out a chirp waveform with
    a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 50e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()

    # Waveform definition variables
    name = ""chirp""
    pWidth = 10e-6
    bw = 40e6
    pri = 100e-6

    # Create waveform
    iq = pyarbtools.wfmBuilder.chirp_generator(fs=vsg.fs, pWidth=pWidth, pri=pri, chirpBw=bw)

    # Download and play waveform
    vsg.download_wfm(iq, name)
    vsg.play(name)

    # Check for erros and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_dig_mod_example(ipAddress):
    """"""Generates and plays 1 MHz 16 QAM signal with 0.35 alpha RRC filter
    @ 1 GHz CF with a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 200e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq, iqScale=70)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""10MHZ_16QAM""
    symRate = 10e6
    modType = ""qam16""

    # Create waveform
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=vsg.fs, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_am_example(ipAddress):
    """"""Generates an AM tone with the IQ modulator in a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 100e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""CUSTOM_AM""
    amRate = 100e3
    amDepth = 75

    # Create waveform
    iq = pyarbtools.wfmBuilder.am_generator(fs=vsg.fs, amDepth=amDepth, modRate=amRate)

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_mtone_example(ipAddress):
    """"""Generates a mutlitone signal on a generic VSG.""""""

    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 100e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""MULTITONE""
    numTones = 400
    toneSpacing = 100e3

    # Create waveform
    iq = pyarbtools.wfmBuilder.multitone_generator(fs=vsg.fs, spacing=toneSpacing, num=numTones)

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def m8190a_simple_wfm_example(ipAddress):
    """"""Sets up the M8190A and creates, downloads, assigns, and plays
    out a simple sine waveform from the AC output port.""""""

    res = ""wsp""
    fs = 10e9
    output = ""ac""
    amp = 0.6
    cf = 1e9
    wfmName = ""sine""

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    awg.configure(res=res, fs=fs, out1=output, amp1=amp)

    # Create simple sinusoidal waveform
    real = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=cf, wfmFormat=""real"")

    # Define segment 1 and populate it with waveform data.
    segment = awg.download_wfm(real, ch=1, name=wfmName, wfmFormat=""real"")

    # Assign segment to channel 1 and start playback.
    awg.play(ch=1, wfmID=segment)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8190a_duc_dig_mod_example(ipAddress):
    """"""Creates a 10 MHz 16 QAM waveform using digital upconversion on the M8190A.""""""

    res = ""intx3""
    cf = 1e9
    output = ""ac""

    modType = ""qam16""
    symRate = 10e6
    wfmName = ""10MHz_16QAM""

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    awg.configure(res=res, cf1=cf, out1=output)

    # Create 16 QAM signal.
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=awg.bbfs, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download waveform to memory
    segment = awg.download_wfm(iq, ch=1, name=wfmName, wfmFormat=""iq"")

    # Assign segment to channel 1 and start playback
    awg.play(wfmID=segment, ch=1)
    awg.err_check()
    awg.close()


def m8190a_duc_chirp_example(ipAddress):
    """"""Creates a 40 MHz chirped pulse using digital upconversion on the M8190A.""""""

    wfmName = ""chirp""
    res = ""intx3""
    fs = 7.2e9
    output = ""ac""
    cf = 1e9

    pw = 10e-6
    pri = 100e-6
    bw = 40e6

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    
    awg.configure(res=res, fs=fs, out1=output, cf1=cf)

    # Create chirp waveform.
    iq = pyarbtools.wfmBuilder.chirp_generator(fs=awg.bbfs, pWidth=pw, pri=pri, chirpBw=bw, wfmFormat=""iq"")

    # Interleave i and q into a single waveform and download to segment 1.
    segment = awg.download_wfm(iq, ch=1, name=wfmName, wfmFormat=""iq"")

    # Assign segment to channel 1 and start playback.
    awg.play(wfmID=segment, ch=1)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8195a_simple_wfm_example(ipAddress):
    """"""Sets up the M8195A and creates, downloads, assigns, and plays
    out a simple sine waveform from the AC output port.""""""

    # Create M8195A object
    awg = pyarbtools.instruments.M8195A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8195A(ipAddress, port=5025, timeout=15, reset=True)

    # AWG configuration variables
    dacMode = ""dual""
    fs = 64e9
    awg.configure(dacMode=dacMode, fs=fs, amp1=100e-3)

    # Waveform definition variables
    sineFreq = 1e9
    wfmFormat = ""real""

    # Define a waveform, ensuring min length and granularity requirements are met
    real = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=sineFreq, wfmFormat=wfmFormat)

    # Download waveform to AWG and get waveform identifier
    wfmID = awg.download_wfm(real, ch=1)

    # Play waveform using identifier
    awg.play(wfmID=wfmID, ch=1)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8190a_sequence_example(ipAddress):
    """"""Creates a simple sinusoidal waveform and uses the idle segment in the sequencer to make it a pulsed signal.""""""

    # AWG Settings
    fs = 12e9
    res = ""wsp""
    out1 = ""dac""
    amp1 = 0.7
    func1 = ""sts""

    # Waveform Settings
    cf = 1e9
    pulseOffTime = 1e-6

    # Connect to AWG and configure settings.
    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)

    awg.configure(res=res, fs=fs, out1=out1, amp1=amp1, func1=func1)

    # Create a simple sine wave at our desired carrier frequency.
    sineWfmData = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=cf, wfmFormat=""real"")
    sineWfmID = awg.download_wfm(sineWfmData, name=""sine"", wfmFormat=""real"")

    # We have to create an ""endcap"" waveform because the sequence cannot end with an idle segment.
    zeroWfmData = pyarbtools.wfmBuilder.zero_generator(fs=awg.fs, numSamples=awg.minLen, wfmFormat=""real"")
    zeroWfmID = awg.download_wfm(zeroWfmData, name=""zero"", wfmFormat=""real"")

    # Calculate how many samples to delay in the idle segment, taking into account the length of the ""endcap"" waveform.
    idleDelay = int(pulseOffTime * awg.fs - len(zeroWfmData))

    # Build our sequence
    awg.create_sequence(3)
    awg.insert_wfm_in_sequence(sineWfmID, 0, seqStart=True)
    awg.insert_idle_in_sequence(1, idleDelay=idleDelay)
    awg.insert_wfm_in_sequence(zeroWfmID, 2, seqEnd=True)

    # Play the sequence
    awg.play_sequence()

    awg.close()


def wfm_to_vsa_example(ipAddress):
    """"""This function creates a ""perfect"" digitally modulated waveform, exports it to a csv file,
    recalls it into VSA, and configures VSA to analyze it.""""""

    # Waveform creation variables
    symRate = 10e6
    fs = 100e6
    modType = ""qam256""
    psFilter = ""rootraisedcosine""
    alpha = 0.35
    fileName = ""C:\\Temp\\wfm.csv""
    fileFormat = ""csv""

    print(""Creating waveform."")
    # This is the new digital modulation waveform creation function
    data = pyarbtools.wfmBuilder.digmod_generator(
        fs=fs,
        symRate=symRate,
        modType=modType,
        filt=psFilter,
        numSymbols=10000,
        alpha=alpha,
    )

    print(""Exporting waveform."")
    # Export the waveform to a csv file
    pyarbtools.wfmBuilder.export_wfm(data, fileName, True, fs)

    print(""Setting up VSA."")
    # Create VSA object
    vsa = pyarbtools.vsaControl.VSA(ipAddress, vsaHardware=None, timeout=10, reset=False)

    # Select a digital demod measurement and configure it to measure the saved waveform
    vsa.set_measurement(""ddemod"")
    if psFilter.lower() == ""rootraisedcosine"":
        mFilter = ""rootraisedcosine""
        rFilter = ""raisedcosine""
    elif psFilter.lower() == ""raisedcosine"":
        mFilter = ""none""
        rFilter = ""raisedcosine""
    else:
        raise Exception(""Invalid filter type chosen."")

    # Configure digital demodulation in VSA
    vsa.configure_ddemod(
        amp=0,
        modType=modType,
        symRate=symRate,
        measFilter=mFilter,
        refFilter=rFilter,
        filterAlpha=alpha,
        measLength=1000,
        eqState=False,
    )

    # Recall csv file we exported earlier
    vsa.recall_recording(fileName, fileFormat=fileFormat)

    # Perform a single-shot replay in VSA
    vsa.acquire_single()

    # Check for errors and gracefully disconnect
    vsa.err_check()
    vsa.close()


def vsa_vector_example(ipAddress):
    """"""Connects to a running instance of VSA, configures a vector measurement, and prints out settings.""""""

    # Vector configuration settings
    cf = 1e9
    span = 20e6
    amp = -5
    time = 100e-6

    vsa = pyarbtools.vsaControl.VSA(ipAddress)
    vsa.set_measurement(""vector"")
    vsa.configure_vector(cf=cf, span=span, amp=amp, time=time)
    vsa.acquire_single()
    vsa.sanity_check()

    # Check for errors and gracefully disconnect
    vsa.err_check()
    vsa.close()


def vxg_mat_import_example(ipAddress, fileName):
    """"""Imports an IQ waveform from a .mat file, loads it into the VXG, and plays it out.""""""

    """"""
    import_mat() takes in a .mat file with an array containing the waveform data, and optional variables for
    waveform identifier, sample rate, and waveform type.
    The .mat file used as an example has the following variables:
        iqdata (complex array): Array containing waveform samples
        fs (float): Sample rate at which waveform was created
        wfmID (string): Name of waveform.
    In this case, we know the variable 'iqdata' in the .mat file contains our complex waveform data, so we use 'iqdata' as
    the 'targetVariable' argument.
    import_mat() returns a dict with 'data', 'fs', 'wfmID', and 'wfmFormat' members.
    If the .mat file contains the optional metadata variables, the corresponding dict members will be populated accordingly.
    """"""

    # Load waveform from .mat file
    wfmDict = pyarbtools.wfmBuilder.import_mat(fileName, targetVariable=""iqdata"")

    # Create VXG object
    vxg = pyarbtools.instruments.VXG(ipAddress, apiType='pyvisa', protocol='hislip', port=1, timeout=3, reset=True)
    # vxg = pyarbtools.instruments.VXG(ipAddress, port=5025, timeout=15, reset=True)

    # Configure vxg based on variables imported from the .mat file
    vxg.configure(cf2=1e9, fs2=wfmDict[""fs""], rfState2=1, amp2=0)

    # Download waveform to vxg by passing the complex array of samples and the waveform name from the dict
    vxg.download_wfm(wfmDict[""data""], wfmID=wfmDict[""wfmID""])

    # Play out the waveform by referencing the waveform name from the dict
    vxg.play(wfmID=wfmDict[""wfmID""], ch=2)

    vxg.close()


def vxg_dig_mod_example(ipAddress):
    """"""Generates and plays 1 MHz 16 QAM signal with 0.35 alpha RRC filter
    @ 1 GHz CF with a generic VSG.""""""

    # Create VSG object
    vxg = pyarbtools.instruments.VXG(ipAddress, apiType='pyvisa', protocol='hislip', port=1, timeout=3, reset=True)
    # vxg = pyarbtools.instruments.VXG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 200e6
    freq = 1e9

    # Configure signal generator
    vxg.configure(amp1=amplitude, fs1=sampleRate, cf1=freq, iqScale1=70)
    vxg.sanity_check()
    vxg.err_check()

    # Waveform definition variables
    name = ""100MHZ_16QAM""
    symRate = 100e6
    modType = ""qam16""

    # Create waveform
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=vxg.fs1, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download and play waveform
    vxg.download_wfm(iq, wfmID=name)
    vxg.play(name)

    # Check for errors and gracefully disconnect
    vxg.err_check()
    vxg.close()


def gui_example():
    """"""Starts experimental PyArbTools GUI""""""
    pyarbtools.gui.main()


def main():
    """"""Uncomment the example you'd like to run. For each example,
    replace the IP address with one that is appropriate for your
    instrument(s).""""""
    ipAddress = ""192.168.4.68""
    matFilePath = ""<insert path to .mat file here>""

    # m8190a_simple_wfm_example(ipAddress)
    # m8190a_duc_dig_mod_example(ipAddress)
    # m8190a_duc_chirp_example(ipAddress)
    # m8190a_iq_correction_example(ipAddress, '127.0.0.1', '""Analyzer1""')
    # m8195a_simple_wfm_example(ipAddress)
    # vsg_chirp_example(ipAddress)
    # vsg_dig_mod_example(ipAddress)
    # vsg_am_example(ipAddress)
    # vsg_mtone_example(ipAddress)
    # wfm_to_vsa_example(ipAddress)
    # vsa_vector_example(ipAddress)
    # vxg_mat_import_example(ipAddress, fileName=matFilePath)
    vxg_dig_mod_example(ipAddress)
    # m8190a_sequence_example(ipAddress)
    # gui_example()


if __name__ == ""__main__"":
    main()
"
138,5420.0,USA,"The Keysight B2962A source / measure unit (SMU) is a 6.5-digit low noise power source that provides a power supply and source solution that meets the difficult measurement challenges researchers, designers, and developers face working on advanced components, circuits, and materials.

",Keysight B 2962 A,276.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT B2962A Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",KEYSIGHT B2962A,,"[OrderedDict([('id', 'attPvti3ysTXW2WG7'), ('width', 800), ('height', 560), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VsT-T0Edcly0C1jxDwf63g/nXd7ssLTT16Cag4iJkDrB5PSuUFa2GnI3tZK44Lpd94S3ysZNsr56PhFNq397VmJAe9m6ia85lPSz6CsRHm3e8M116MggGHIkzl_oXi0fjo/M3uVWaOShE5MZy2LEdW_iyEVW1oM4G-n2ZnW6Pa63VA'), ('filename', 'B2961A_FS.2.jpg'), ('size', 53604), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5NYsqOPNcr67_JuKTJND8Q/0NzEsiX-XRo4y7FMF5ie2S8euxiN2jHcH8D_MWqAAmxfhOfv1QY8Es05KLiu1aZ0OxNUACGHTtT7-IfYOoOWUg/rmRixHd5Simtyo8zjBift33PJ0iG-CCEtgBuAcpLh2s'), ('width', 51), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YaR2CjB5_JDk8Wn3nE3DbA/oOj8jAjNJHISjAVOhSv76LtBYIYSxXbQRzWch2QZ7P5MZgfKsWGjZj-wCRkcBH2eFJWSt_AUEhz1nMyXp-LDrg/V99UDPrUbiCVYiLt-N8g2M2gbK-GRIMZ6fV4JsR7HPg'), ('width', 731), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fWefFG4_Bdi0zBDnFMLqoA/VimkP4_vqSCFq8iMni6BoWHTbRiICxU73DwJVARp0vXxTsrc-ICB_5W0HwDt76GhsZXDHHMZhejDeZi6UDYHKQ/nZV7zkS2YBXKBBCaNmuq09f44jflzqZhIMhWvFQDPu0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/B2962A/6-5-digit-low-noise-power-source-2-channels.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_B2962A.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightB2962A,,,,,"from typing import Any, Optional

from qcodes.instrument import Instrument, InstrumentChannel, VisaInstrument


class KeysightB2962AChannel(InstrumentChannel):
    """"""

    """"""
    def __init__(self, parent: Instrument, name: str, chan: int) -> None:
        """"""
        Args:
            parent: The instrument to which the channel is attached.
            name: The name of the channel
            chan: The number of the channel in question (1-2)
        """"""
        # Sanity Check inputs
        if name not in ['ch1', 'ch2']:
            raise ValueError(""Invalid Channel: {}, expected 'ch1' or 'ch2'""
                             .format(name))
        if chan not in [1, 2]:
            raise ValueError(""Invalid Channel: {}, expected '1' or '2'""
                             .format(chan))

        super().__init__(parent, name)

        self.add_parameter('source_voltage',
                           label=f""Channel {chan} Voltage"",
                           get_cmd=f'SOURCE{chan:d}:VOLT?',
                           get_parser=float,
                           set_cmd=f'SOURCE{chan:d}:VOLT {{:.8G}}',
                           unit='V')

        self.add_parameter('source_current',
                           label=f""Channel {chan} Current"",
                           get_cmd=f'SOURCE{chan:d}:CURR?',
                           get_parser=float,
                           set_cmd=f'SOURCE{chan:d}:CURR {{:.8G}}',
                           unit='A')

        self.add_parameter('voltage',
                           get_cmd=f'MEAS:VOLT? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Voltage',
                           unit='V')

        self.add_parameter('current',
                           get_cmd=f'MEAS:CURR? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Current',
                           unit='A')

        self.add_parameter('resistance',
                           get_cmd=f'MEAS:RES? (@{chan:d})',
                           get_parser=float,
                           label=f'Channel {chan} Resistance',
                           unit='ohm')

        self.add_parameter('voltage_limit',
                           get_cmd=f'SENS{chan:d}:VOLT:PROT?',
                           get_parser=float,
                           set_cmd=f'SENS{chan:d}:VOLT:PROT {{:.8G}}',
                           label=f'Channel {chan} Voltage Limit',
                           unit='V')

        self.add_parameter('current_limit',
                           get_cmd=f'SENS{chan:d}:CURR:PROT?',
                           get_parser=float,
                           set_cmd=f'SENS{chan:d}:CURR:PROT {{:.8G}}',
                           label='Channel {} Current Limit',
                           unit='A')

        self.add_parameter('enable',
                           get_cmd=f'OUTP{chan:d}?',
                           set_cmd=f'OUTP{chan:d} {{:d}}',
                           val_mapping={'on':  1, 'off': 0})

        self.add_parameter('source_mode',
                           get_cmd=f':SOUR{chan:d}:FUNC:MODE?',
                           set_cmd=f':SOUR{chan:d}:FUNC:MODE {{:s}}',
                           val_mapping={'current': 'CURR', 'voltage': 'VOLT'})

        self.channel = chan


B2962AChannel = KeysightB2962AChannel


class KeysightB2962A(VisaInstrument):
    """"""
    This is the qcodes driver for the Keysight B2962A 6.5 Digit Low Noise
    Power Source

    Status: alpha-version.
    TODO:
        - Implement any remaining parameters supported by the device
        - Similar drivers have special handlers to map return values of
          9.9e+37 to inf, is this needed?
    """"""
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        # The B2962A supports two channels
        for ch_num in [1, 2]:
            ch_name = f""ch{ch_num:d}""
            channel = KeysightB2962AChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)

        self.connect_message()

    def get_idn(self) -> dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN


class B2962A(KeysightB2962A):
    """"""
    Alias for backwards compatibility
    """"""
"
146,5800.0,USA,"The industry-leading AWG70000A Series arbitrary waveform generator (AWG) provides you with unparalleled performance at the cutting edge for sample rate, signal fidelity, and waveform memory. In order to engineer the world's most complex data communications systems, the ability to create ideal, distorted and ""real life"" signals is essential. The AWG70000A Series of AWGs delivers this, giving you the industry's best signal stimulus solution for ever-increasing measurement challenges. With up to 50 GS/s and 10-bit vertical resolution, it offers easy generation of very complex signals and complete control over signal characteristics.",AWG 70002 A,545.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG70002A RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG70002A,https://download.tek.com/datasheet/AWG70000A-Arbitrary-Waveform-Generator-Datasheet-76W283808.pdf,"[OrderedDict([('id', 'attuN24ZB0RTqUVJh'), ('width', 294), ('height', 220), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_-A7M6MkeBXE0a3eoIRoUA/cW0NLvI7WCPnDf0homujk-AQuU-A0wRzgfyDdImwCcyhmXFOVj8OLZn-QPjS8uc9NxErQfvxqdgglprbLO7bNmX7nXW7ImI7N2lczUA5iZWTSOutU6xXgFk1xx9lBLOkePnp4IK57tCaFCj2kqTDTQ/k1Yymbv_DwQc-Oog344R1CeP5CfBPlfeSN7M_pMpMsU'), ('filename', '02aadca4ffd655cc627bb76eb7983ba7_1490966598 (1).webp'), ('size', 4594), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YQ2SOTbLMVDak41BkGARBA/ON6dTvGmZEiu3NbUd0I8yPaK-qbJtUsMuO56_aCI0XniwNjiBQITPL37PdB-hPNeIra4hrwXU7R8toixVCaV2_wmNT1PzhxX6ghl3HLFmns/6El348pri8lTPoTTrA25PcXqH50-NmGcahnycnhpBvE'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mOpwRCZVeNLruGSVOcBMDg/M9tt3XjHyYUbHI5a5g1sY9RH7LBIrWCniu7wOmIbCtRn3TGFWqT6TmoHc8NhTXtL_ulzgkpcMG2RYLWbpG14iWAxnFIAcDchiCcnW7JwcZc/3Hci8nbFsnF9lS1nGnB7_jIPMOOibrA6P94x-gfF3BM'), ('width', 294), ('height', 220)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/So3zJ6YdzbcjODIgwwxVaw/5WFpUCWsFmaNVKsAqsjPJ02XvEtboTV1MlocAJRaC-RPrPojdDOCQG9dma2L7-w6G_qFsEh-J8I6cHqGbw7YxbHo_nphN3dKapTCVzsKAIo/xv7BmRhxvN4fZhqQfYuep6vAv-_RVCqmm41DJDiNAHM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/arbitrary-waveform-generators-1,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70002A,74999.0,,True,Price from: https://www.transcat.com/tektronix-awg70001a-used-for-sale,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
147,25.0,USA,"The SR865A Lock-In Amplifier offers superb performance and outstanding value. With 4 MHz frequency range, time constants from 1 µs to 30 ks, very low noise front-end amplifiers, and a modern, intuitive user interface, the SR865A is the ideal choice for any synchronous detection application.",SR 865 A,536.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://thinksrs.com/downloads/pdfs/catalog/SR865Ac.pdf,"[OrderedDict([('id', 'attLU55vwUTWxsQyF'), ('width', 4188), ('height', 2470), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DrYf9rUvkhOIAtimW7nQ_A/jIRDw0lZpssRqAmzyJHv4jNkM3iqU9DRSLn3FM0c5neCqrahXxJ1Uk_UQNeHhO2pYjrA53_hzfLZqdJAxDvzacSG-MJMG2AX3-2kkGbBRN4/CO5ti0SIzFezFJg-gsAEOO6oC0ZieebJdIL4Y1Ty4qU'), ('filename', 'SR865A_Lt_Wide.jpg'), ('size', 2302119), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fG3J4Y7cHf67ooIJ6QfLwg/hDJBVq7eIEtXia0iYezBuLxaes6B3F5gXCQ5fBjOzmIc3sE0oJ1UsEYKRkUlrXwlr-Mgwg8cfI4yvqTXQoE-WQ/8cVlqZtiNRPCVO7Me6QWBy_fLowtcNPhE-gg99t8Phw'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/J0hADCmpKJLnzMkBbi4dhw/eYijWNSMmBfkz71RuZKKLDt5J5tlVJ-XUbhjOR117ffoiAPDCP0HrcKbWUs8ru3to7sragJRrgAjVG805WwoHg/Nr_Lrnrpj-Msi7tXx8hsXmtf3kgQDMCeC81Z931X0mM'), ('width', 868), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0yCY572URxPcQWEIoMyPjA/8GMVunGXiymIvxI4aLn2LlS0wKeKJFU4r-72nG7QuFRmGaZksZVpaeVLPobu2xUKnWyXGent3bCmQvbnfHMG5g/ZW1fS6UV7sxbJ8cQg7WcSkqGrORHlTObf07FvnnMuz4'), ('width', 3000), ('height', 3000)]))]))])]",https://thinksrs.com/products/sr865a.htm,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR86x.py,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR865A,8150.0,,,,"import logging
from collections.abc import Sequence
from typing import Any, Callable, Optional

import numpy as np

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter
from qcodes.validators import ComplexNumbers, Enum, Ints, Numbers

log = logging.getLogger(__name__)


class SR86xBufferReadout(ArrayParameter):
    """"""
    The parameter array that holds read out data. We need this to be compatible
    with qcodes.Measure

    Args:
        name: Name of the parameter.
        instrument: The instrument to add this parameter to.
    """"""
    def __init__(self, name: str, instrument: 'SR86x', **kwargs: Any) -> None:

        unit = ""deg""
        if name in [""X"", ""Y"", ""R""]:
            unit = ""V""

        super().__init__(name,
                         shape=(1,),  # dummy initial shape
                         unit=unit,
                         setpoint_names=('Time',),
                         setpoint_labels=('Time',),
                         setpoint_units=('s',),
                         instrument=instrument,
                         docstring='Holds an acquired (part of the) data '
                                   'buffer of one channel.',
                         **kwargs)

        self._capture_data: Optional[np.ndarray] = None

    def prepare_readout(self, capture_data: np.ndarray) -> None:
        """"""
        Prepare this parameter for readout.

        Args:
            capture_data: The data to capture.
        """"""
        self._capture_data = capture_data

        data_len = len(capture_data)
        self.shape = (data_len,)
        self.setpoint_units = ('',)
        self.setpoint_names = ('sample_nr',)
        self.setpoint_labels = ('Sample number',)
        self.setpoints = (tuple(np.arange(0, data_len)),)

    def get_raw(self) -> np.ndarray:
        """"""
        Public method to access the capture data
        """"""
        if self._capture_data is None:
            raise ValueError(f""Cannot return data for parameter {self.name}. ""
                             f""Please prepare for readout by calling ""
                             f""'get_capture_data' with appropriate ""
                             f""configuration settings"")

        return self._capture_data


class SR86xBuffer(InstrumentChannel):
    """"""
    Buffer module for the SR86x drivers.

    This driver has been verified to work with the SR860 and SR865.
    For reference, please consult the SR860
    manual: http://thinksrs.com/downloads/PDFs/Manuals/SR860m.pdf
    """"""

    def __init__(self, parent: 'SR86x', name: str) -> None:
        super().__init__(parent, name)

        self.add_parameter(
            ""capture_length_in_kb"",
            label=""get/set capture length"",
            get_cmd=""CAPTURELEN?"",
            set_cmd=""CAPTURELEN {}"",
            set_parser=self._set_capture_len_parser,
            get_parser=int,
            unit=""kB""
        )
        self.bytes_per_sample = 4
        self.min_capture_length_in_kb = 1  # i.e. minimum buffer size
        self.max_capture_length_in_kb = 4096  # i.e. maximum buffer size
        # Maximum amount of kB that can be read per single CAPTUREGET command
        self.max_size_per_reading_in_kb = 64

        self.add_parameter(  # Configure which parameters we want to capture
            ""capture_config"",
            label=""capture configuration"",
            get_cmd=""CAPTURECFG?"",
            set_cmd=""CAPTURECFG {}"",
            val_mapping={""X"": ""0"", ""X,Y"": ""1"", ""R,T"": ""2"", ""X,Y,R,T"": ""3""}
        )

        self.add_parameter(
            ""capture_rate_max"",
            label=""capture rate maximum"",
            get_cmd=""CAPTURERATEMAX?"",
            get_parser=float
        )

        self.add_parameter(
            ""capture_rate"",
            label=""capture rate raw"",
            get_cmd=""CAPTURERATE?"",
            set_cmd=""CAPTURERATE {}"",
            get_parser=float,
            set_parser=self._set_capture_rate_parser
        )

        max_rate = self.capture_rate_max()
        self.available_frequencies = [max_rate / 2 ** i for i in range(20)]

        self.add_parameter(  # Are we capturing at the moment?
            ""capture_status"",
            label=""capture status"",
            get_cmd=""CAPTURESTAT?""
        )

        self.add_parameter(
            ""count_capture_bytes"",
            label=""captured bytes"",
            get_cmd=""CAPTUREBYTES?"",
            unit=""B"",
            get_parser=int,
            docstring=""Number of bytes captured so far in the buffer. Can be ""
                      ""used to track live progress.""
        )

        self.add_parameter(
            ""count_capture_kilobytes"",
            label=""captured kilobytes"",
            get_cmd=""CAPTUREPROG?"",
            unit=""kB"",
            docstring=""Number of kilobytes captured so far in the buffer, ""
                      ""rounded-up to 2 kilobyte chunks. Capture must be ""
                      ""stopped before requesting the value of this ""
                      ""parameter. If the acquisition wrapped during operating ""
                      ""in Continuous mode, then the returned value is ""
                      ""simply equal to the current capture length.""
        )

        for parameter_name in [""X"", ""Y"", ""R"", ""T""]:
            self.add_parameter(
                parameter_name,
                parameter_class=SR86xBufferReadout
            )

    def snapshot_base(
        self,
        update: Optional[bool] = False,
        params_to_skip_update: Optional[Sequence[str]] = None,
    ) -> dict[Any, Any]:
        if params_to_skip_update is None:
            params_to_skip_update = []
        # we omit count_capture_kilobytes from the snapshot because
        # it can only be read after a completed capture and will
        # timeout otherwise when the snapshot is updated, e.g. at
        # station creation time
        params_to_skip_update = list(params_to_skip_update)
        params_to_skip_update.append('count_capture_kilobytes')

        snapshot = super().snapshot_base(update, params_to_skip_update)
        return snapshot

    def _set_capture_len_parser(self, capture_length_in_kb: int) -> int:
        """"""
        Parse the capture length in kB according to the way buffer treats it
        (refer to the manual for details). The given value has to fit in the
        range and has to be even, otherwise this function raises exceptions.

        Args:
            capture_length_in_kb: The desired capture length in kB.

        Returns:
            capture_length_in_kb
        """"""
        if capture_length_in_kb % 2:
            raise ValueError(""The capture length should be an even number"")

        if not self.min_capture_length_in_kb \
                <= capture_length_in_kb \
                <= self.max_capture_length_in_kb:
            raise ValueError(f""The capture length should be between ""
                             f""{self.min_capture_length_in_kb} and ""
                             f""{self.max_capture_length_in_kb}"")

        return capture_length_in_kb

    def set_capture_rate_to_maximum(self) -> None:
        """"""
        Sets the capture rate to maximum. The maximum capture rate is
        retrieved from the device, and depends on the current value of the
        time constant.
        """"""
        self.capture_rate(self.capture_rate_max())

    def _set_capture_rate_parser(self, capture_rate_hz: float) -> int:
        """"""
        According to the manual, the capture rate query returns a value in
        Hz, but then setting this value it is expected to give a value n,
        where the capture rate in Hz is given by
        capture_rate_hz =  max_rate / 2 ** n. Please see page 136 of the
        manual. Here n is an integer in the range [0, 20].

        Args:
            capture_rate_hz: The desired capture rate in Hz. If the desired
                rate is more than 1 Hz from the nearest valid rate, a warning
                is issued and the nearest valid rate it used.

        Returns:
            n_round
        """"""
        max_rate = self.capture_rate_max()
        n = np.log2(max_rate / capture_rate_hz)
        n_round = int(round(n))

        if not 0 <= n_round <= 20:
            raise ValueError(f""The chosen frequency is invalid. Please ""
                             f""consult the SR860 manual at page 136. ""
                             f""The maximum capture rate is {max_rate}"")

        nearest_valid_rate = max_rate / 2 ** n_round
        if abs(capture_rate_hz - nearest_valid_rate) > 1:
            available_frequencies = "", "".join(
                str(f) for f in self.available_frequencies
            )
            log.warning(f""Warning: Setting capture rate to {nearest_valid_rate:.5} Hz"")
            log.warning(f""The available frequencies are: {available_frequencies}"")

        return n_round

    def start_capture(self, acquisition_mode: str, trigger_mode: str) -> None:
        """"""
        Start an acquisition. Please see page 137 of the manual for a detailed
        explanation.

        Args:
            acquisition_mode: ""ONE"" | ""CONT""
            trigger_mode: ""IMM"" | ""TRIG"" | ""SAMP""
        """"""

        if acquisition_mode not in [""ONE"", ""CONT""]:
            raise ValueError(
                ""The acquisition mode needs to be either 'ONE' or 'CONT'"")

        if trigger_mode not in [""IMM"", ""TRIG"", ""SAMP""]:
            raise ValueError(
                ""The trigger mode needs to be either 'IMM', 'TRIG' or 'SAMP'"")

        cmd_str = f""CAPTURESTART {acquisition_mode}, {trigger_mode}""
        self.write(cmd_str)

    def stop_capture(self) -> None:
        """"""Stop a capture""""""
        self.write(""CAPTURESTOP"")

    def _get_list_of_capture_variable_names(self) -> list[str]:
        """"""
        Retrieve the list of names of variables (readouts) that are
        set to be captured
        """"""
        return self.capture_config().split("","")

    def _get_number_of_capture_variables(self) -> int:
        """"""
        Retrieve the number of variables (readouts) that are
        set to be captured
        """"""
        capture_variables = self._get_list_of_capture_variable_names()
        n_variables = len(capture_variables)
        return n_variables

    def _calc_capture_size_in_kb(self, sample_count: int) -> int:
        """"""
        Given the number of samples to capture, calculate the capture length
        that the buffer needs to be set to in order to fit the requested
        number of samples. Note that the number of activated readouts is
        taken into account.
        """"""
        n_variables = self._get_number_of_capture_variables()
        total_size_in_kb = int(
            np.ceil(n_variables * sample_count * self.bytes_per_sample / 1024)
        )
        # Make sure that the total size in kb is an even number, as expected by
        # the instrument
        if total_size_in_kb % 2:
            total_size_in_kb += 1
        return total_size_in_kb

    def set_capture_length_to_fit_samples(self, sample_count: int) -> None:
        """"""
        Set the capture length of the buffer to fit the given number of
        samples.

        Args:
            sample_count: Number of samples that the buffer has to fit
        """"""
        total_size_in_kb = self._calc_capture_size_in_kb(sample_count)
        self.capture_length_in_kb(total_size_in_kb)

    def wait_until_samples_captured(self, sample_count: int) -> None:
        """"""
        Wait until the given number of samples is captured. This function
        is blocking and has to be used with caution because it does not have
        a timeout.

        Args:
            sample_count: Number of samples that needs to be captured
        """"""
        n_captured_bytes = 0
        n_variables = self._get_number_of_capture_variables()
        n_bytes_to_capture = sample_count * n_variables * self.bytes_per_sample
        while n_captured_bytes < n_bytes_to_capture:
            n_captured_bytes = self.count_capture_bytes()

    def get_capture_data(self, sample_count: int) -> dict[str, np.ndarray]:
        """"""
        Read the given number of samples of the capture data from the buffer.

        Args:
            sample_count: number of samples to read from the buffer

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        total_size_in_kb = self._calc_capture_size_in_kb(sample_count)
        capture_variables = self._get_list_of_capture_variable_names()
        n_variables = self._get_number_of_capture_variables()

        values = self._get_raw_capture_data(total_size_in_kb)

        # Remove zeros which mark the end part of the buffer that is not
        # filled with captured data
        values = values[values != 0]

        values = values.reshape((-1, n_variables)).T
        values = values[:, :sample_count]

        data = {k: v for k, v in zip(capture_variables, values)}

        for capture_variable in capture_variables:
            buffer_parameter = getattr(self, capture_variable)
            buffer_parameter.prepare_readout(data[capture_variable])

        return data

    def _get_raw_capture_data(self, size_in_kb: int) -> np.ndarray:
        """"""
        Read data from the buffer from its beginning avoiding the instrument
        limit of 64 kilobytes per reading.

        Args:
            size_in_kb :Size of the data that needs to be read; if it exceeds
                the capture length, an exception is raised.

        Returns:
            A one-dimensional numpy array of the requested data. Note that the
            returned array contains data for all the variables that are
            mentioned in the capture config.
        """"""
        current_capture_length = self.capture_length_in_kb()
        if size_in_kb > current_capture_length:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""is larger than current capture length of the ""
                             f""buffer ({current_capture_length}kB)."")

        values: np.ndarray = np.array([])
        data_size_to_read_in_kb = size_in_kb
        n_readings = 0

        while data_size_to_read_in_kb > 0:
            offset = n_readings * self.max_size_per_reading_in_kb

            if data_size_to_read_in_kb > self.max_size_per_reading_in_kb:
                size_of_this_reading = self.max_size_per_reading_in_kb
            else:
                size_of_this_reading = data_size_to_read_in_kb

            data_from_this_reading = self._get_raw_capture_data_block(
                size_of_this_reading,
                offset_in_kb=offset)
            values = np.append(values, data_from_this_reading)

            data_size_to_read_in_kb -= size_of_this_reading
            n_readings += 1

        return values

    def _get_raw_capture_data_block(self,
                                    size_in_kb: int,
                                    offset_in_kb: int = 0
                                    ) -> np.ndarray:
        """"""
        Read data from the buffer. The maximum amount of data that can be
        read with this function (size_in_kb) is 64kB (this limitation comes
        from the instrument). The offset argument can be used to navigate
        along the buffer.

        An exception will be raised if either size_in_kb or offset_in_kb are
        longer that the *current* capture length (number of kB of data that is
        captured so far rounded up to 2kB chunks). If (offset_in_kb +
        size_in_kb) is longer than the *current* capture length,
        the instrument returns the wrapped data.

        For more information, refer to the description of the ""CAPTUREGET""
        command in the manual.

        Args:
            size_in_kb: Amount of data in kB that is to be read from the buffer
            offset_in_kb: Offset within the buffer of where to read the data;
                for example, when 0 is specified, the data is read from the
                start of the buffer.

        Returns:
            A one-dimensional numpy array of the requested data. Note that the
            returned array contains data for all the variables that are
            mentioned in the capture config.
        """"""
        if size_in_kb > self.max_size_per_reading_in_kb:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""is larger than maximum size that can be read ""
                             f""at once ({self.max_size_per_reading_in_kb}kB)."")

        # Calculate the size of the data captured so far, in kB, rounded up
        # to 2kB chunks
        size_of_currently_captured_data = int(
            np.ceil(np.ceil(self.count_capture_bytes() / 1024) / 2) * 2
        )

        if size_in_kb > size_of_currently_captured_data:
            raise ValueError(f""The size of the requested data ({size_in_kb}kB) ""
                             f""cannot be larger than the size of currently ""
                             f""captured data rounded up to 2kB chunks ""
                             f""({size_of_currently_captured_data}kB)"")

        if offset_in_kb > size_of_currently_captured_data:
            raise ValueError(f""The offset for reading the requested data ""
                             f""({offset_in_kb}kB) cannot be larger than the ""
                             f""size of currently captured data rounded up to ""
                             f""2kB chunks ""
                             f""({size_of_currently_captured_data}kB)"")

        values = self._parent.visa_handle.query_binary_values(
            f""CAPTUREGET? {offset_in_kb}, {size_in_kb}"",
            datatype='f',
            is_big_endian=False,
            expect_termination=False)
        # the sr86x does not include an extra termination char on binary
        # messages so we set expect_termination to False

        return np.array(values)

    def capture_one_sample_per_trigger(
            self,
            trigger_count: int,
            start_triggers_pulsetrain: Callable[..., Any]
    ) -> dict[str, np.ndarray]:
        """"""
        Capture one sample per each trigger, and return when the specified
        number of triggers has been received.

        Args:
            trigger_count: Number of triggers to capture samples for
            start_triggers_pulsetrain: By calling this *non-blocking*
                function, the train of trigger pulses should start

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(trigger_count)
        self.start_capture(""ONE"", ""SAMP"")
        start_triggers_pulsetrain()
        self.wait_until_samples_captured(trigger_count)
        self.stop_capture()
        return self.get_capture_data(trigger_count)

    def capture_samples_after_trigger(
        self, sample_count: int, send_trigger: Callable[..., Any]
    ) -> dict[str, np.ndarray]:
        """"""
        Capture a number of samples after a trigger has been received.
        Please refer to page 135 of the manual for details.

        Args:
            sample_count: Number of samples to capture
            send_trigger: By calling this *non-blocking* function, one trigger
                should be sent that will initiate the capture

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(sample_count)
        self.start_capture(""ONE"", ""TRIG"")
        send_trigger()
        self.wait_until_samples_captured(sample_count)
        self.stop_capture()
        return self.get_capture_data(sample_count)

    def capture_samples(self, sample_count: int) -> dict[str, np.ndarray]:
        """"""
        Capture a number of samples at a capture rate, starting immediately.
        Unlike the ""continuous"" capture mode, here the buffer does not get
        overwritten with the new data once the buffer is full.

        The function blocks until the required number of samples is acquired,
        and returns them.

        Args:
            sample_count: Number of samples to capture

        Returns:
            The keys in the dictionary correspond to the captured
            variables. For instance, if before the capture, the capture
            config was set as 'capture_config(""X,Y"")', then the keys will
            be ""X"" and ""Y"". The values in the dictionary are numpy arrays
            of numbers.
        """"""
        self.set_capture_length_to_fit_samples(sample_count)
        self.start_capture(""ONE"", ""IMM"")
        self.wait_until_samples_captured(sample_count)
        self.stop_capture()
        return self.get_capture_data(sample_count)


class SR86xDataChannel(InstrumentChannel):
    """"""
    Implements a data channel of SR86x lock-in amplifier. Parameters that are
    assigned to these channels get plotted on the display of the instrument.
    Moreover, there are commands that allow to conveniently retrieve the values
    of the parameters that are currently assigned to the data channels.

    This class relies on the available parameter names that should be
    mentioned in the lock-in amplifier class in `PARAMETER_NAMES` attribute.

    Args:
        parent: an instance of SR86x driver
        name: data channel name that is to be used to reference it from the
            parent
        cmd_id: this ID is used in VISA commands to refer to this data channel,
            usually is an integer number
        cmd_id_name: this name can also be used in VISA commands along with
            channel_id; it is not used in this implementation, but is added
            for reference
        color: every data channel is also referred to by the color with which it
            is being plotted on the instrument's screen; added here only for
            reference
    """"""
    def __init__(self, parent: 'SR86x', name: str, cmd_id: str,
                 cmd_id_name: Optional[str] = None,
                 color: Optional[str] = None) -> None:
        super().__init__(parent, name)

        self._cmd_id = cmd_id
        self._cmd_id_name = cmd_id_name
        self._color = color

        self.add_parameter(
            ""assigned_parameter"",
            label=f""Data channel {cmd_id} parameter"",
            docstring=f""Allows to set and get the ""
            f""parameter that is assigned to data ""
            f""channel {cmd_id}"",
            set_cmd=f""CDSP {cmd_id}, {{}}"",
            get_cmd=f""CDSP? {cmd_id}"",
            val_mapping=self.parent.PARAMETER_NAMES,
        )

    @property
    def cmd_id(self) -> str:
        return self._cmd_id

    @property
    def cmd_id_name(self) -> Optional[str]:
        return self._cmd_id_name

    @property
    def color(self) -> Optional[str]:
        return self._color


class SR86x(VisaInstrument):
    """"""
    This is the code for Stanford_SR865 Lock-in Amplifier
    """"""
    _VOLT_TO_N = {1: 0, 500e-3: 1, 200e-3: 2,
                  100e-3: 3, 50e-3: 4, 20e-3: 5,
                  10e-3: 6, 5e-3: 7, 2e-3: 8,
                  1e-3: 9, 500e-6: 10, 200e-6: 11,
                  100e-6: 12, 50e-6: 13, 20e-6: 14,
                  10e-6: 15, 5e-6: 16, 2e-6: 17,
                  1e-6: 18, 500e-9: 19, 200e-9: 20,
                  100e-9: 21, 50e-9: 22, 20e-9: 23,
                  10e-9: 24, 5e-9: 25, 2e-9: 26,
                  1e-9: 27}
    _N_TO_VOLT = {v: k for k, v in _VOLT_TO_N.items()}

    _CURR_TO_N = {1e-6: 0, 500e-9: 1, 200e-9: 2,
                  100e-9: 3, 50e-9: 4, 20e-9: 5,
                  10e-9: 6, 5e-9: 7, 2e-9: 8,
                  1e-9: 9, 500e-12: 10, 200e-12: 11,
                  100e-12: 12, 50e-12: 13, 20e-12: 14,
                  10e-12: 15, 5e-12: 16, 2e-12: 17,
                  1e-12: 18, 500e-15: 19, 200e-15: 20,
                  100e-15: 21, 50e-15: 22, 20e-15: 23,
                  10e-15: 24, 5e-15: 25, 2e-15: 26,
                  1e-15: 27}
    _N_TO_CURR = {v: k for k, v in _CURR_TO_N.items()}

    _VOLT_ENUM = Enum(*_VOLT_TO_N.keys())
    _CURR_ENUM = Enum(*_CURR_TO_N.keys())

    _INPUT_SIGNAL_TO_N = {
        'voltage': 0,
        'current': 1,
    }
    _N_TO_INPUT_SIGNAL = {v: k for k, v in _INPUT_SIGNAL_TO_N.items()}

    PARAMETER_NAMES = {
                'X': '0',   # X output, 'X'
                'Y': '1',   # Y output, 'Y'
                'R': '2',   # R output, 'R'
                'P': '3',   # theta output, 'THeta'
          'aux_in1': '4',   # Aux In 1, 'IN1'
          'aux_in2': '5',   # Aux In 2, 'IN2'
          'aux_in3': '6',   # Aux In 3, 'IN3'
          'aux_in4': '7',   # Aux In 4, 'IN4'
           'Xnoise': '8',   # X noise, 'XNOise'
           'Ynoise': '9',   # Y noise, 'YNOise'
         'aux_out1': '10',  # Aux Out 1, 'OUT1'
         'aux_out2': '11',  # Aux Out 2, 'OUT2'
            'phase': '12',  # Reference Phase, 'PHAse'
        'amplitude': '13',  # Sine Out Amplitude, 'SAMp'
       'sine_outdc': '14',  # DC Level, 'LEVel'
        'frequency': '15',  # Int. Ref. Frequency, 'FInt'
    'frequency_ext': '16',  # Ext. Ref. Frequency, 'FExt'
    }

    _N_DATA_CHANNELS = 4

    def __init__(
            self,
            name: str,
            address: str,
            max_frequency: float,
            reset: bool = False,
            **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)
        self._max_frequency = max_frequency
        # Reference commands
        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='FREQ?',
                           set_cmd='FREQ {}',
                           get_parser=float,
                           vals=Numbers(
                               min_value=1e-3,
                               max_value=self._max_frequency)
                           )
        self.add_parameter(name='sine_outdc',
                           label='Sine out dc level',
                           unit='V',
                           get_cmd='SOFF?',
                           set_cmd='SOFF {}',
                           get_parser=float,
                           vals=Numbers(min_value=-5, max_value=5))
        self.add_parameter(name='amplitude',
                           label='Amplitude',
                           unit='V',
                           get_cmd='SLVL?',
                           set_cmd='SLVL {}',
                           get_parser=float,
                           vals=Numbers(min_value=0, max_value=2))
        self.add_parameter(name='harmonic',
                           label='Harmonic',
                           get_cmd='HARM?',
                           get_parser=int,
                           set_cmd='HARM {:d}',
                           vals=Ints(min_value=1, max_value=99))
        self.add_parameter(name='phase',
                           label='Phase',
                           unit='deg',
                           get_cmd='PHAS?',
                           set_cmd='PHAS {}',
                           get_parser=float,
                           vals=Numbers(min_value=-3.6e5, max_value=3.6e5))
        # Signal commands
        self.add_parameter(name='sensitivity',
                           label='Sensitivity',
                           get_cmd='SCAL?',
                           set_cmd='SCAL {:d}',
                           get_parser=self._get_sensitivity,
                           set_parser=self._set_sensitivity
                           )
        self.add_parameter(name='filter_slope',
                           label='Filter slope',
                           unit='dB/oct',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           val_mapping={6: 0,
                                        12: 1,
                                        18: 2,
                                        24: 3})
        self.add_parameter(name='sync_filter',
                           label='Sync filter',
                           get_cmd='SYNC?',
                           set_cmd='SYNC {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='noise_bandwidth',
                           label='Noise bandwidth',
                           unit='Hz',
                           get_cmd='ENBW?',
                           get_parser=float)
        self.add_parameter(name='signal_strength',
                           label='Signal strength indicator',
                           get_cmd='ILVL?',
                           get_parser=int)
        self.add_parameter(name='signal_input',
                           label='Signal input',
                           get_cmd='IVMD?',
                           get_parser=self._get_input_config,
                           set_cmd='IVMD {}',
                           set_parser=self._set_input_config,
                           vals=Enum(*self._INPUT_SIGNAL_TO_N.keys()))
        self.add_parameter(name='input_range',
                           label='Input range',
                           unit='V',
                           get_cmd='IRNG?',
                           set_cmd='IRNG {}',
                           val_mapping={1: 0,
                                        300e-3: 1,
                                        100e-3: 2,
                                        30e-3: 3,
                                        10e-3: 4})
        self.add_parameter(name='input_config',
                           label='Input configuration',
                           get_cmd='ISRC?',
                           set_cmd='ISRC {}',
                           val_mapping={'a': 0,
                                        'a-b': 1})
        self.add_parameter(name='input_shield',
                           label='Input shield',
                           get_cmd='IGND?',
                           set_cmd='IGND {}',
                           val_mapping={'float': 0,
                                        'ground': 1})
        self.add_parameter(name='input_gain',
                           label='Input gain',
                           unit='ohm',
                           get_cmd='ICUR?',
                           set_cmd='ICUR {}',
                           val_mapping={1e6: 0,
                                        100e6: 1})
        self.add_parameter(name='adv_filter',
                           label='Advanced filter',
                           get_cmd='ADVFILT?',
                           set_cmd='ADVFILT {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='input_coupling',
                           label='Input coupling',
                           get_cmd='ICPL?',
                           set_cmd='ICPL {}',
                           val_mapping={'ac': 0, 'dc': 1})
        self.add_parameter(name='time_constant',
                           label='Time constant',
                           unit='s',
                           get_cmd='OFLT?',
                           set_cmd='OFLT {}',
                           val_mapping={1e-6: 0, 3e-6: 1,
                                        10e-6: 2, 30e-6: 3,
                                        100e-6: 4, 300e-6: 5,
                                        1e-3: 6, 3e-3: 7,
                                        10e-3: 8, 30e-3: 9,
                                        100e-3: 10, 300e-3: 11,
                                        1: 12, 3: 13,
                                        10: 14, 30: 15,
                                        100: 16, 300: 17,
                                        1e3: 18, 3e3: 19,
                                        10e3: 20, 30e3: 21})

        self.add_parameter(
            name=""external_reference_trigger"",
            label=""External reference trigger mode"",
            get_cmd=""RTRG?"",
            set_cmd=""RTRG {}"",
            val_mapping={
                ""SIN"": 0,
                ""POS"": 1,
                ""POSTTL"": 1,
                ""NEG"": 2,
                ""NEGTTL"": 2,
            },
            docstring=""The triggering mode for synchronization of the ""
                      ""internal reference signal with the externally provided ""
                      ""one""
        )

        self.add_parameter(
            name=""reference_source"",
            label=""Reference source"",
            get_cmd=""RSRC?"",
            set_cmd=""RSRC {}"",
            val_mapping={
                ""INT"": 0,
                ""EXT"": 1,
                ""DUAL"": 2,
                ""CHOP"": 3
            },
            docstring=""The source of the reference signal""
        )

        self.add_parameter(
            name=""external_reference_trigger_input_resistance"",
            label=""External reference trigger input resistance"",
            get_cmd=""REFZ?"",
            set_cmd=""REFZ {}"",
            val_mapping={
                ""50"": 0,
                ""50OHMS"": 0,
                0: 0,
                ""1M"": 1,
                ""1MEG"": 1,
                1: 1,
            },
            docstring=""Input resistance of the input for the external ""
                      ""reference signal""
        )

        # Auto functions
        self.add_function('auto_range', call_cmd='ARNG')
        self.add_function('auto_scale', call_cmd='ASCL')
        self.add_function('auto_phase', call_cmd='APHS')

        # Data transfer
        # first 4 parameters from a list of 16 below.
        self.add_parameter('X',
                           label='In-phase Magnitude',
                           get_cmd='OUTP? 0',
                           get_parser=float,
                           unit='V')
        self.add_parameter('Y',
                           label='Out-phase Magnitude',
                           get_cmd='OUTP? 1',
                           get_parser=float,
                           unit='V')
        self.add_parameter('R',
                           label='Magnitude',
                           get_cmd='OUTP? 2',
                           get_parser=float,
                           unit='V')
        self.add_parameter('P',
                           label='Phase',
                           get_cmd='OUTP? 3',
                           get_parser=float,
                           unit='deg')
        self.add_parameter('complex_voltage',
                           label='Voltage',
                           get_cmd=self._get_complex_voltage,
                           unit='V',
                           vals=ComplexNumbers())

        # CH1/CH2 Output Commands
        self.add_parameter('X_offset',
                           label='X offset ',
                           unit='%',
                           get_cmd='COFP? 0',
                           set_cmd='COFP 0, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('Y_offset',
                           label='Y offset',
                           unit='%',
                           get_cmd='COFP? 1',
                           set_cmd='COFP 1, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('R_offset',
                           label='R offset',
                           unit='%',
                           get_cmd='COFP? 2',
                           set_cmd='COFP 2, {}',
                           get_parser=float,
                           vals=Numbers(min_value=-999.99, max_value=999.99))
        self.add_parameter('X_expand',
                           label='X expand multiplier',
                           get_cmd='CEXP? 0',
                           set_cmd='CEXP 0, {}',
                           val_mapping={'OFF': '0',
                                        'X10': '1',
                                        'X100': '2'})
        self.add_parameter('Y_expand',
                           label='Y expand multiplier',
                           get_cmd='CEXP? 1',
                           set_cmd='CEXP 1, {}',
                           val_mapping={'OFF': 0,
                                        'X10': 1,
                                        'X100': 2})
        self.add_parameter('R_expand',
                           label='R expand multiplier',
                           get_cmd='CEXP? 2',
                           set_cmd='CEXP 2, {}',
                           val_mapping={'OFF': 0,
                                        'X10': 1,
                                        'X100': 2})

        # Aux input/output
        for i in [0, 1, 2, 3]:
            self.add_parameter(f'aux_in{i}',
                               label=f'Aux input {i}',
                               get_cmd=f'OAUX? {i}',
                               get_parser=float,
                               unit='V')
            self.add_parameter(f'aux_out{i}',
                               label=f'Aux output {i}',
                               get_cmd=f'AUXV? {i}',
                               get_parser=float,
                               set_cmd=f'AUXV {i}, {{}}',
                               unit='V')

        # Data channels:
        # 'DAT1' (green), 'DAT2' (blue), 'DAT3' (yellow), 'DAT4' (orange)
        data_channels = ChannelList(self, ""data_channels"", SR86xDataChannel,
                                    snapshotable=False)
        for num, color in zip(range(self._N_DATA_CHANNELS),
                              ('green', 'blue', 'yellow', 'orange')):
            cmd_id = f""{num}""
            cmd_id_name = f""DAT{num + 1}""
            ch_name = f""data_channel_{num + 1}""

            data_channel = SR86xDataChannel(
                self, ch_name, cmd_id, cmd_id_name, color)

            data_channels.append(data_channel)
            self.add_submodule(ch_name, data_channel)

        self.add_submodule(""data_channels"", data_channels.to_channel_tuple())

        # Interface
        self.add_function('reset', call_cmd='*RST')

        self.add_function('disable_front_panel', call_cmd='OVRM 0')
        self.add_function('enable_front_panel', call_cmd='OVRM 1')

        buffer = SR86xBuffer(self, f""{self.name}_buffer"")
        self.add_submodule(""buffer"", buffer)

        self.input_config()
        self.connect_message()

    def _set_units(self, unit: str) -> None:
        for param in [self.X, self.Y, self.R, self.sensitivity]:
            param.unit = unit

    def _get_complex_voltage(self) -> complex:
        x, y = self.get_values('X', 'Y')
        return x + 1.0j*y

    def _get_input_config(self, s: int) -> str:
        mode = self._N_TO_INPUT_SIGNAL[int(s)]

        if mode == 'voltage':
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return mode

    def _set_input_config(self, s: str) -> int:
        if s == 'voltage':
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return self._INPUT_SIGNAL_TO_N[s]

    def _get_sensitivity(self, s: int) -> float:
        if self.signal_input() == 'voltage':
            return self._N_TO_VOLT[int(s)]
        else:
            return self._N_TO_CURR[int(s)]

    def _set_sensitivity(self, s: float) -> int:
        if self.signal_input() == 'voltage':
            return self._VOLT_TO_N[s]
        else:
            return self._CURR_TO_N[s]

    def get_values(self, *parameter_names: str) -> tuple[float, ...]:
        """"""
        Get values of 2 or 3 parameters that are measured by the lock-in
        amplifier. These values are guaranteed to come from the same
        measurement cycle as opposed to getting values of parameters one by
        one (for example, by calling `sr.X()`, and then `sr.Y()`.

        Args:
            *parameter_names: 2 or 3 names of parameters for which the values
                are requested; valid names can be found in `PARAMETER_NAMES`
                attribute of the driver class

        Returns:
            a tuple of 2 or 3 floating point values

        """"""
        if not 2 <= len(parameter_names) <= 3:
            raise KeyError(
                'It is only possible to request values of 2 or 3 parameters '
                'at a time.')

        for name in parameter_names:
            if name not in self.PARAMETER_NAMES:
                raise KeyError(f'{name} is not a valid parameter name. Refer '
                               f'to `PARAMETER_NAMES` for a list of valid '
                               f'parameter names')

        p_ids = [self.PARAMETER_NAMES[name] for name in parameter_names]
        output = self.ask(f'SNAP? {"","".join(p_ids)}')
        return tuple(float(val) for val in output.split(','))

    def get_data_channels_values(self) -> tuple[float, ...]:
        """"""
        Queries the current values of the data channels

        Returns:
            tuple of 4 values of the data channels
        """"""
        output = self.ask('SNAPD?')
        return tuple(float(val) for val in output.split(','))

    def get_data_channels_parameters(
        self, query_instrument: bool = True
    ) -> tuple[str, ...]:
        """"""
        Convenience method to query a list of parameters which the data
        channels are currently assigned to.

        Args:
            query_instrument: If set to False, the internally cashed names of
                the parameters will be returned; if True, then the names will
                be queried through the instrument

        Returns:
            a tuple of 4 strings of parameter names
        """"""
        if query_instrument:
            method_name = 'get'
        else:
            method_name = 'get_latest'

        return tuple(
            getattr(getattr(self.data_channels[i], 'assigned_parameter'),
                    method_name)()
            for i in range(self._N_DATA_CHANNELS)
        )

    def get_data_channels_dict(self, requery_names: bool = False) -> dict[str, float]:
        """"""
        Returns a dictionary where the keys are parameter names currently
        assigned to the data channels, and values are the values of those
        parameters.

        Args:
            requery_names: if False, the currently assigned parameter names
                will not be queries from the instrument in order to save time
                on communication, in this case the cached assigned parameter
                names will be used for the keys of the dicitonary; if True,
                the assigned parameter names will be queried from the
                instrument

        Returns:
            a dictionary where keys are names of parameters assigned to the
            data channels, and values are the values of those parameters
        """"""
        parameter_names = self.get_data_channels_parameters(requery_names)
        parameter_values = self.get_data_channels_values()
        return dict(zip(parameter_names, parameter_values))
"
149,38.0,Switzerland,"The Zurich Instruments MFLI is a digital lock-in amplifier that covers the frequency range from DC to 500 kHz (and up to 5 MHz when upgraded). Thanks to its embedded data and web servers, the MFLI can be used directly with any device running a web browser without further software installations",Mfli,645.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a MFLI Lockin Amplifiers,https://en.wikipedia.org/wiki/Lock-in_amplifier,['Lockin Amplifiers'],"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.",MFLI,https://docs.zhinst.com/pdf/ziMFLI_UserManual.pdf,"[OrderedDict([('id', 'attAZLZ2m8DYsl4M9'), ('width', 1183), ('height', 699), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/an-A1RfgRuU1CNIEGMXa_A/50F_NCMpgg6X3N3_XPmSktJBfAU3A8Du47XLP107rq_2CpN1ScLqzaKGx5CnIHhX_hZy7S-7voYrSo7hT8vVBpIDG_QZ5Hrn8g692VDDqHE/IOENbAgcfiPCZkFAtbNaTU_3S9qX8qVgvFfz8-uHVuY'), ('filename', 'mfli_persp.png.webp'), ('size', 49074), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/X9ofunVkt0UiBq-P2Ftj2Q/y9NAjFUO3K_ElqK3zUPtZNMA4wRrMln0gGaoVrbizYARboiZCiqTltd6kucsPXkPB6mG-W99-tFSpZqoNHWkGH4EOYp4P_LDfjX72bx4qzw/4u1Q8Fv7vmKNm1eFemIxjmMj3E13MRPuoNezX7WvwXI'), ('width', 61), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QThwoNf74L2os8bnUKEwCg/aVg9hOU3LMWY1FDqqMdvo3mG6ueTkhThKNo2qtP4x_IdgX4zFVdG-Gq8AEO8vYOrKaMOalejDtEBf3H1n9DVkkyUhJWHdkQctc7FOuhk9Mk/RARz69JPNQmDABumpZD0lVuKXxQhIeyDSqGdWycTReg'), ('width', 867), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VIOLDbwErTzzoghvOBeflA/TtOljp5lnt5fmp-BgLfVQAXCDTJsBQpEDLcWdDVM22ObGilkezeE2ITGoQl12yff_IgbszGnS7Lx2AXKQsXHzrYGW6lHULA5uTMQqYE4ftg/Qcp8S7GE8WdotyA_rckdaJhy0e8vhkZGtE3qProN7MI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/mfli-lock-in-amplifier,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/zurich_instruments/mfli.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.device_creator.MFLI.html,,,,,"# Zurich Instrument MFLI stub
#
# For the real implementation, please look into the package zhinst-qcodes
# at https://github.com/zhinst/zhinst-qcodes


try:
    from zhinst.qcodes import MFLI
except ImportError:
    raise ImportError(
        """"""
        Could not find Zurich Instruments QCodes drivers.
        Please install package zhinst-qcodes.
        """"""
    )
__all__ = [""MFLI""]
"
153,5800.0,USA,"The AWG70001A, with Option AC, provides you with an additional high output amplitude connector. Option AC adds a single-ended AC coupled Planar Crown connector to the front panel of the single channel AWG70001A Arbitrary Waveform Generator. User controls are added to allow switching the output path between the standard Direct output connectors or the AC output connector. When switched to the AC path, additional user controlled amplification and attenuation is added to the signal path.",Tektronix 70001 A,559.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG70001A RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG70001A,,,https://www.tek.com/en/datasheet/awg70001a-arbitrary-waveform-generator-option-ac-datasheet,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001A,,,True,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
154,5420.0,USA,"PXI source/measure units are the source and measurement resources of voltage and current for test applications requiring high accuracy, high resolution, and measurement flexibility

",KTM 960 Xdefs,284.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,"Write a Python script that uses Qcodes to connect to a KEYSIGHT M960x defs Power Meters, Power Supplies",https://www.keysight.com/us/en/products/source-measure-units-smu.html,"['Power Meters', 'Power Supplies']","Keysight provides a wide range of source measure units (SMU) from precision, application-specific, general-purpose, to basic instruments. Keysight SMUs precisely force and simultaneously measure voltage and/or current.

",KEYSIGHT M960x defs,,"[OrderedDict([('id', 'attKdAoVXw7skVsyH'), ('width', 1600), ('height', 1067), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bKcCtVBu0k-ciXvojwm3iw/eO2_3RRGzoY9RRWnF1YHvzKUvRB_40LVyNX34O8Xk1R-KEWVUb7ln-NqQXcnNnhH6jSm-jiDttW0_Xwm6RB1cZvP2lEqas3PpefNoDD0ch0/EesF_F5ONfHsbAJGA7U12fNLkDakz6u-y-nE-v9JR6w'), ('filename', 'PROD-3075050-01.png'), ('size', 1143931), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lEhVvHXojnpfkHqMLksOkw/gu2m5Qwmn3oA5igPnLco0bLB934gkyJVjqq2hNv9EoFQkxZnUYzOoCf9zKMIJysfTMbhBqrjJiQ7hK5UpKj_Rg/VuulOIDRVekz_jsphXIZKe3ceIrM6AJE4E_bzOFu7js'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fLNuCLU1lZik6ti2vk7JXw/qHl7QIGf8wFTtIxhg77OZtAvH6qVvMu21sFhEUjpvRenVsJNvdx4fYQTpT_0sLOsrL3IIkblfeTdbBsdxEeD-w/w6SsNDO7HGcBIQ9qwEoXGF1qf8t9Vc_z_hBTptq0E-4'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1xt-cd-aOndSxS_P5vKW5w/fsaBE41fQqbIweFOOvV6dV6K4P1CQUy3XXU4zXmEK9ScKtjDFJC7XL9zcFALr4FmkQkRJfvG23anoJIhzxey_w/rZIxOZPVYuviNm18eOtGWybPbMg6uvnKvrbVv9HpwOU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/products/source-measure-units-smu/pxi-source-measure-units.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/KtM960xDefs.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightM960x,,,,,"# KtM960x Definitions
#
#   These have been copy/pasted out of KtM960x.h provided by Keysite
#
IVI_ATTR_BASE = 1000000

IVI_INHERENT_ATTR_BASE = (
    IVI_ATTR_BASE + 50000
)  # base for inherent capability attributes

# base for IVI-defined class attributes
IVI_CLASS_ATTR_BASE = IVI_ATTR_BASE + 250000

# base for IviLxiSync attributes
IVI_LXISYNC_ATTR_BASE = IVI_ATTR_BASE + 950000

IVI_SPECIFIC_ATTR_BASE = (
    IVI_ATTR_BASE + 150000
)  # base for attributes of specific drivers


# #===== IVI Inherent Instrument Attributes ==============================

# - Driver Identification

KTM960X_ATTR_SPECIFIC_DRIVER_DESCRIPTION = (
    IVI_INHERENT_ATTR_BASE + 514
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_PREFIX = (
    IVI_INHERENT_ATTR_BASE + 302
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_VENDOR = (
    IVI_INHERENT_ATTR_BASE + 513
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_REVISION = (
    IVI_INHERENT_ATTR_BASE + 551
)  # ViString, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MAJOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 515
)  # ViInt32, read-only
KTM960X_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MINOR_VERSION = (
    IVI_INHERENT_ATTR_BASE + 516
)  # ViInt32, read-only

# - User Options
# ViBoolean, read-write
KTM960X_ATTR_RANGE_CHECK = IVI_INHERENT_ATTR_BASE + 2
KTM960X_ATTR_QUERY_INSTRUMENT_STATUS = (
    IVI_INHERENT_ATTR_BASE + 3
)  # ViBoolean, read-write
# ViBoolean, read-write
KTM960X_ATTR_CACHE = IVI_INHERENT_ATTR_BASE + 4
# ViBoolean, read-write
KTM960X_ATTR_SIMULATE = IVI_INHERENT_ATTR_BASE + 5
# ViBoolean, read-write
KTM960X_ATTR_RECORD_COERCIONS = IVI_INHERENT_ATTR_BASE + 6
# ViBoolean, read-write
KTM960X_ATTR_INTERCHANGE_CHECK = IVI_INHERENT_ATTR_BASE + 21

# - Advanced Session Information
# ViString, read-only
KTM960X_ATTR_LOGICAL_NAME = IVI_INHERENT_ATTR_BASE + 305
KTM960X_ATTR_IO_RESOURCE_DESCRIPTOR = (
    IVI_INHERENT_ATTR_BASE + 304
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_DRIVER_SETUP = IVI_INHERENT_ATTR_BASE + 7

# - Driver Capabilities
# ViString, read-only
KTM960X_ATTR_GROUP_CAPABILITIES = IVI_INHERENT_ATTR_BASE + 401
KTM960X_ATTR_SUPPORTED_INSTRUMENT_MODELS = (
    IVI_INHERENT_ATTR_BASE + 327
)  # ViString, read-only

# - Instrument Identification

KTM960X_ATTR_INSTRUMENT_FIRMWARE_REVISION = (
    IVI_INHERENT_ATTR_BASE + 510
)  # ViString, read-only
KTM960X_ATTR_INSTRUMENT_MANUFACTURER = (
    IVI_INHERENT_ATTR_BASE + 511
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_INSTRUMENT_MODEL = IVI_INHERENT_ATTR_BASE + 512


# ===== Instrument-Specific Attributes ===========

# - System
# ViString, read-only
KTM960X_ATTR_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 3
# ViString, read-only
KTM960X_ATTR_SYSTEM_ABOUT = IVI_SPECIFIC_ATTR_BASE + 4
KTM960X_ATTR_SYSTEM_GC_TIMING_OPTIMIZATION_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 5
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 6
)  # ViBoolean, read-write
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_INSTANCE_ID = IVI_SPECIFIC_ATTR_BASE + 7
# ViString, read-only
KTM960X_ATTR_SYSTEM_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 8
KTM960X_ATTR_SYSTEM_AUTO_TIMER_RESET_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 435
)  # ViBoolean, read-write
# ViString, read-only
KTM960X_ATTR_SYSTEM_DATE = IVI_SPECIFIC_ATTR_BASE + 436
KTM960X_ATTR_SYSTEM_INTERLOCK_THRESHOLD_VOLTAGE = (
    IVI_SPECIFIC_ATTR_BASE + 437
)  # ViReal64, read-write
KTM960X_ATTR_SYSTEM_INTERLOCK_TRIPPED = (
    IVI_SPECIFIC_ATTR_BASE + 438
)  # ViBoolean, read-only
# ViInt32, read-write
KTM960X_ATTR_SYSTEM_LINE_FREQUENCY = IVI_SPECIFIC_ATTR_BASE + 439
# ViReal64, read-only
KTM960X_ATTR_SYSTEM_TIMER_COUNT = IVI_SPECIFIC_ATTR_BASE + 440
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_CHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 514
# ViInt32, read-only
KTM960X_ATTR_SYSTEM_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 518

# - Licensing

KTM960X_ATTR_LICENSING_HOST_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 11
)  # ViString, read-only
KTM960X_ATTR_LICENSING_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 12
)  # ViString, read-only

# - SFP

KTM960X_ATTR_SYSTEM_SFP_CONTROLS_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 15
)  # ViBoolean, read-write

# - AutoRefresh

KTM960X_ATTR_SYSTEM_SFP_AUTOREFRESH_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 13
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_SFP_AUTOREFRESH_PERIOD = (
    IVI_SPECIFIC_ATTR_BASE + 14
)  # ViReal64, read-write

# - Group

KTM960X_ATTR_SYSTEM_GROUP_SYNC_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 515
)  # ViBoolean, read-write
KTM960X_ATTR_SYSTEM_GROUP_SYNC_MASTER_MODULE = (
    IVI_SPECIFIC_ATTR_BASE + 516
)  # ViInt32, read-write
KTM960X_ATTR_SYSTEM_GROUP_SYNC_TRIGGER_LINE = (
    IVI_SPECIFIC_ATTR_BASE + 517
)  # ViInt32, read-write

# - Module
# ViInt32, read-only
KTM960X_ATTR_MODULE_COUNT = IVI_SPECIFIC_ATTR_BASE + 23
KTM960X_ATTR_MODULE_INSTRUMENT_CAPABILITY = (
    IVI_SPECIFIC_ATTR_BASE + 24
)  # ViString, read-only
KTM960X_ATTR_MODULE_MAXIMUM_RECORDED_TEMPERATURE = (
    IVI_SPECIFIC_ATTR_BASE + 25
)  # ViReal64, read-only
# ViString, read-only
KTM960X_ATTR_MODULE_OPTIONS = IVI_SPECIFIC_ATTR_BASE + 26
# ViString, read-only
KTM960X_ATTR_MODULE_SERIAL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 27
# ViInt32, read-only
KTM960X_ATTR_MODULE_SLOT = IVI_SPECIFIC_ATTR_BASE + 28
# ViReal64, read-only
KTM960X_ATTR_MODULE_TEMPERATURE = IVI_SPECIFIC_ATTR_BASE + 29
# ViInt32, read-only
KTM960X_ATTR_MODULE_CHASSIS_NUMBER = IVI_SPECIFIC_ATTR_BASE + 490
KTM960X_ATTR_MODULE_IDENTIFY_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 491
)  # ViBoolean, read-write
KTM960X_ATTR_MODULE_INSTALLED_LICENSES = (
    IVI_SPECIFIC_ATTR_BASE + 492
)  # ViString, read-only
KTM960X_ATTR_MODULE_MANUFACTURING_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 508
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_MODULE_MODEL_NUMBER = IVI_SPECIFIC_ATTR_BASE + 509
# ViInt64, read-only
KTM960X_ATTR_MODULE_UPTIME = IVI_SPECIFIC_ATTR_BASE + 511
# ViInt32, read-only
KTM960X_ATTR_MODULE_CHANNEL_COUNT = IVI_SPECIFIC_ATTR_BASE + 526
# ViBoolean, read-write
KTM960X_ATTR_MODULE_POWER_STATE = IVI_SPECIFIC_ATTR_BASE + 527
# ViString, read-only
KTM960X_ATTR_MODULE_VENDOR = IVI_SPECIFIC_ATTR_BASE + 528
KTM960X_ATTR_MODULE_INTERLOCK_TRIPPED = (
    IVI_SPECIFIC_ATTR_BASE + 529
)  # ViBoolean, read-only

# - Calibration

KTM960X_ATTR_MODULE_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 30
)  # ViString, read-only
KTM960X_ATTR_MODULE_CALIBRATION_DUE_DATE = (
    IVI_SPECIFIC_ATTR_BASE + 31
)  # ViString, read-only
KTM960X_ATTR_MODULE_CALIBRATION_STATUS = (
    IVI_SPECIFIC_ATTR_BASE + 524
)  # ViInt32, read-only
KTM960X_ATTR_MODULE_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 525
)  # ViString, read-only

# - Nonvolatile

KTM960X_ATTR_NONVOLATILE_ASSET_NUMBER = (
    IVI_SPECIFIC_ATTR_BASE + 34
)  # ViString, read-write
KTM960X_ATTR_NONVOLATILE_CAL_DUE_REMINDER = (
    IVI_SPECIFIC_ATTR_BASE + 35
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_INSTRUMENT_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 36
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_MODULE_CAL_WARNINGS = (
    IVI_SPECIFIC_ATTR_BASE + 37
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_ENABLE_PERIODIC_CAL = (
    IVI_SPECIFIC_ATTR_BASE + 38
)  # ViBoolean, read-write
KTM960X_ATTR_NONVOLATILE_INSTRUMENT_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 39
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_MODULE_CAL_INTERVAL = (
    IVI_SPECIFIC_ATTR_BASE + 40
)  # ViInt32, read-write
KTM960X_ATTR_NONVOLATILE_PASSPHRASE = (
    IVI_SPECIFIC_ATTR_BASE + 41
)  # ViString, read-write
KTM960X_ATTR_NONVOLATILE_SYSTEM_IDENTIFICATION = (
    IVI_SPECIFIC_ATTR_BASE + 42
)  # ViString, read-write

# - External
# ViInt32, read-only
KTM960X_ATTR_EXTERNAL_COUNT = IVI_SPECIFIC_ATTR_BASE + 493
KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_POSITION = (
    IVI_SPECIFIC_ATTR_BASE + 496
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_WIDTH = (
    IVI_SPECIFIC_ATTR_BASE + 497
)  # ViReal64, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_FUNCTION = (
    IVI_SPECIFIC_ATTR_BASE + 498
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 499
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 500
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_EXTERNAL_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 501
)  # ViInt32, read-write

# - PXIe
# ViInt32, read-only
KTM960X_ATTR_PXIE_COUNT = IVI_SPECIFIC_ATTR_BASE + 495
KTM960X_ATTR_MODULE_IO_PXIE_EDGE_POSITION = (
    IVI_SPECIFIC_ATTR_BASE + 503
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_LEVEL = IVI_SPECIFIC_ATTR_BASE + 504
# ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_TYPE = IVI_SPECIFIC_ATTR_BASE + 505
KTM960X_ATTR_MODULE_IO_PXIE_EDGE_WIDTH = (
    IVI_SPECIFIC_ATTR_BASE + 506
)  # ViReal64, read-write
KTM960X_ATTR_MODULE_IO_PXIE_FUNCTION = (
    IVI_SPECIFIC_ATTR_BASE + 507
)  # ViInt32, read-write
KTM960X_ATTR_MODULE_IO_PXIE_POLARITY = (
    IVI_SPECIFIC_ATTR_BASE + 530
)  # ViInt32, read-write

# - Calibration

KTM960X_ATTR_CALIBRATION_ADJUSTMENT_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 480
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_CALIBRATION_DUE_DATE = IVI_SPECIFIC_ATTR_BASE + 481
KTM960X_ATTR_CALIBRATION_INSTRUMENT_IDENTIFIER = (
    IVI_SPECIFIC_ATTR_BASE + 482
)  # ViString, read-only
# ViString, read-only
KTM960X_ATTR_CALIBRATION_LAST_DATE = IVI_SPECIFIC_ATTR_BASE + 483
# ViInt32, read-only
KTM960X_ATTR_CALIBRATION_STATUS = IVI_SPECIFIC_ATTR_BASE + 484
KTM960X_ATTR_CALIBRATION_VERIFICATION_INFORMATION = (
    IVI_SPECIFIC_ATTR_BASE + 485
)  # ViString, read-only

# - Measurement
# ViInt32, read-only
KTM960X_ATTR_MEASUREMENT_COUNT = IVI_SPECIFIC_ATTR_BASE + 327
KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 486
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 489
)  # ViBoolean, read-write

# - Arm

KTM960X_ATTR_MEASUREMENT_ARM_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 328
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_ARM_COUNT = IVI_SPECIFIC_ATTR_BASE + 329
KTM960X_ATTR_MEASUREMENT_ARM_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 330
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_ARM_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 331
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_ARM_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 332
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_ARM_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 333
)  # ViBoolean, read-write

# - Current

KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE = (
    IVI_SPECIFIC_ATTR_BASE + 334
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_APERTURE_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 335
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_IS_COMPLIANCE = (
    IVI_SPECIFIC_ATTR_BASE + 340
)  # ViBoolean, read-only
KTM960X_ATTR_MEASUREMENT_CURRENT_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 341
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NEGATIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 342
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NPLC = (
    IVI_SPECIFIC_ATTR_BASE + 343
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_NPLC_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 344
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_POSITIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 345
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_CURRENT_RANGE = (
    IVI_SPECIFIC_ATTR_BASE + 346
)  # ViReal64, read-write

# - Function

KTM960X_ATTR_MEASUREMENT_FUNCTION_DISABLE_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 348
)  # ViInt32, read-only
KTM960X_ATTR_MEASUREMENT_FUNCTION_ENABLE_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 349
)  # ViInt32, read-only

# - Trigger

KTM960X_ATTR_MEASUREMENT_TRIGGER_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 366
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 367
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 368
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 369
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 370
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_TRIGGER_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 371
)  # ViBoolean, read-write

# - Voltage

KTM960X_ATTR_MEASUREMENT_VOLTAGE_APERTURE = (
    IVI_SPECIFIC_ATTR_BASE + 372
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_APERTURE_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 373
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_IS_COMPLIANCE = (
    IVI_SPECIFIC_ATTR_BASE + 378
)  # ViBoolean, read-only
KTM960X_ATTR_MEASUREMENT_VOLTAGE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 379
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NEGATIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 380
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NPLC = (
    IVI_SPECIFIC_ATTR_BASE + 381
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_NPLC_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 382
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_POSITIVE_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 383
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_VOLTAGE_RANGE = (
    IVI_SPECIFIC_ATTR_BASE + 384
)  # ViReal64, read-write

# - WaitTime

KTM960X_ATTR_MEASUREMENT_WAIT_TIME_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 386
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 387
)  # ViBoolean, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_GAIN = (
    IVI_SPECIFIC_ATTR_BASE + 388
)  # ViReal64, read-write
KTM960X_ATTR_MEASUREMENT_WAIT_TIME_OFFSET = (
    IVI_SPECIFIC_ATTR_BASE + 389
)  # ViReal64, read-write

# - Sampling

KTM960X_ATTR_MEASUREMENT_SAMPLING_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 487
)  # ViInt32, read-write
KTM960X_ATTR_MEASUREMENT_SAMPLING_TOTAL_TIME = (
    IVI_SPECIFIC_ATTR_BASE + 488
)  # ViReal64, read-write

# - Output
# ViInt32, read-only
KTM960X_ATTR_OUTPUT_COUNT = IVI_SPECIFIC_ATTR_BASE + 390
KTM960X_ATTR_OUTPUT_AUTO_OFF_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 391
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_AUTO_ON_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 392
)  # ViBoolean, read-write
# ViBoolean, read-write
KTM960X_ATTR_OUTPUT_ENABLED = IVI_SPECIFIC_ATTR_BASE + 403
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_OFF_CONDITION = IVI_SPECIFIC_ATTR_BASE + 410
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_PRIORITY_MODE = IVI_SPECIFIC_ATTR_BASE + 411
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_SHAPE = IVI_SPECIFIC_ATTR_BASE + 419
# ViInt32, read-write
KTM960X_ATTR_OUTPUT_OPERATION_MODE = IVI_SPECIFIC_ATTR_BASE + 479

# - Current

KTM960X_ATTR_OUTPUT_CURRENT_AUTO_RANGE_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 393
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_CURRENT_BASE_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 394
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_BASE_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 395
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_LEVEL = IVI_SPECIFIC_ATTR_BASE + 396
KTM960X_ATTR_OUTPUT_CURRENT_POST_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 397
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_CURRENT_POST_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 398
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_POST_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 399
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_RANGE = IVI_SPECIFIC_ATTR_BASE + 400
KTM960X_ATTR_OUTPUT_CURRENT_RANGE_LOWER_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 401
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_CURRENT_TRIGGERED_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 402
)  # ViReal64, read-write

# - Filter

KTM960X_ATTR_OUTPUT_FILTER_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 404
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_FILTER_CUT_OFF_FREQUENCY = (
    IVI_SPECIFIC_ATTR_BASE + 405
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_FILTER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 406
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_FILTER_TIME_CONSTANT = (
    IVI_SPECIFIC_ATTR_BASE + 407
)  # ViReal64, read-write

# - Pulse

# ViReal64, read-write
KTM960X_ATTR_OUTPUT_PULSE_DELAY = IVI_SPECIFIC_ATTR_BASE + 413
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_PULSE_WIDTH = IVI_SPECIFIC_ATTR_BASE + 414

# - Voltage

KTM960X_ATTR_OUTPUT_VOLTAGE_AUTO_RANGE_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 420
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 421
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 422
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_LEVEL = IVI_SPECIFIC_ATTR_BASE + 423
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 424
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 425
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_POST_TYPE = (
    IVI_SPECIFIC_ATTR_BASE + 426
)  # ViInt32, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_RANGE = IVI_SPECIFIC_ATTR_BASE + 427
KTM960X_ATTR_OUTPUT_VOLTAGE_RANGE_LOWER_LIMIT = (
    IVI_SPECIFIC_ATTR_BASE + 428
)  # ViReal64, read-write
KTM960X_ATTR_OUTPUT_VOLTAGE_TRIGGERED_LEVEL = (
    IVI_SPECIFIC_ATTR_BASE + 429
)  # ViReal64, read-write

# - WaitTime

KTM960X_ATTR_OUTPUT_WAITTIME_AUTO_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 430
)  # ViBoolean, read-write
KTM960X_ATTR_OUTPUT_WAITTIME_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 431
)  # ViBoolean, read-write
# ViReal64, read-write
KTM960X_ATTR_OUTPUT_WAITTIME_GAIN = IVI_SPECIFIC_ATTR_BASE + 432
KTM960X_ATTR_OUTPUT_WAITTIME_OFFSET = (
    IVI_SPECIFIC_ATTR_BASE + 433
)  # ViReal64, read-write

# - Transient

# ViInt32, read-only
KTM960X_ATTR_TRANSIENT_COUNT = IVI_SPECIFIC_ATTR_BASE + 441
KTM960X_ATTR_TRANSIENT_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 521
)  # ViBoolean, read-write

# - Arm
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_BYPASS = IVI_SPECIFIC_ATTR_BASE + 442
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_COUNT = IVI_SPECIFIC_ATTR_BASE + 443
# ViReal64, read-write
KTM960X_ATTR_TRANSIENT_ARM_DELAY = IVI_SPECIFIC_ATTR_BASE + 444
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_ARM_SOURCE = IVI_SPECIFIC_ATTR_BASE + 445
# ViReal64, read-write
KTM960X_ATTR_TRANSIENT_ARM_TIMER = IVI_SPECIFIC_ATTR_BASE + 446
KTM960X_ATTR_TRANSIENT_ARM_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 447
)  # ViBoolean, read-write

# - Current

KTM960X_ATTR_TRANSIENT_CURRENT_CENTER = (
    IVI_SPECIFIC_ATTR_BASE + 448
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 449
)  # ViInt32, read-only
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_START_POINT = (
    IVI_SPECIFIC_ATTR_BASE + 450
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 451
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_SPAN = (
    IVI_SPECIFIC_ATTR_BASE + 452
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_START = (
    IVI_SPECIFIC_ATTR_BASE + 453
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_STEP = (
    IVI_SPECIFIC_ATTR_BASE + 454
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_STOP = (
    IVI_SPECIFIC_ATTR_BASE + 455
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_SWEEP_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 456
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_LIST_OUTPUT_TRIGGER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 519
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_CURRENT_TRIGGER_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 520
)  # ViInt32, read-only

# - Sweep

KTM960X_ATTR_TRANSIENT_SWEEP_DIRECTION = (
    IVI_SPECIFIC_ATTR_BASE + 457
)  # ViInt32, read-write
# ViInt32, read-write
KTM960X_ATTR_TRANSIENT_SWEEP_MODE = IVI_SPECIFIC_ATTR_BASE + 458
KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_RANGING_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 459
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_SCALE = (
    IVI_SPECIFIC_ATTR_BASE + 460
)  # ViInt32, read-write

# - Trigger

KTM960X_ATTR_TRANSIENT_TRIGGER_BYPASS = (
    IVI_SPECIFIC_ATTR_BASE + 461
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_CONTINUOUS_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 462
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_COUNT = (
    IVI_SPECIFIC_ATTR_BASE + 463
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_DELAY = (
    IVI_SPECIFIC_ATTR_BASE + 464
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_SOURCE = (
    IVI_SPECIFIC_ATTR_BASE + 465
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_TIMER = (
    IVI_SPECIFIC_ATTR_BASE + 466
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_TRIGGER_TRIGGER_OUTPUT_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 467
)  # ViBoolean, read-write

# - Voltage

KTM960X_ATTR_TRANSIENT_VOLTAGE_CENTER = (
    IVI_SPECIFIC_ATTR_BASE + 468
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 469
)  # ViInt32, read-only
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_START_POINT = (
    IVI_SPECIFIC_ATTR_BASE + 470
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_MODE = (
    IVI_SPECIFIC_ATTR_BASE + 471
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_SPAN = (
    IVI_SPECIFIC_ATTR_BASE + 472
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_START = (
    IVI_SPECIFIC_ATTR_BASE + 473
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_STEP = (
    IVI_SPECIFIC_ATTR_BASE + 474
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_STOP = (
    IVI_SPECIFIC_ATTR_BASE + 475
)  # ViReal64, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_SWEEP_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 476
)  # ViInt32, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_LIST_OUTPUT_TRIGGER_ENABLED = (
    IVI_SPECIFIC_ATTR_BASE + 522
)  # ViBoolean, read-write
KTM960X_ATTR_TRANSIENT_VOLTAGE_TRIGGER_LIST_POINTS = (
    IVI_SPECIFIC_ATTR_BASE + 523
)  # ViInt32, read-only


# *------------------------ Attribute Value Defines -------------------------*

# - Defined values for

KTM960X_VAL_STATUS_BYTE_FLAGS_USER0 = 1
KTM960X_VAL_STATUS_BYTE_FLAGS_USER1 = 2
KTM960X_VAL_STATUS_BYTE_FLAGS_USER2 = 4
KTM960X_VAL_STATUS_BYTE_FLAGS_USER3 = 8
KTM960X_VAL_STATUS_BYTE_FLAGS_MESSAGE_AVAILABLE = 16
KTM960X_VAL_STATUS_BYTE_FLAGS_EVENT_STATUS_REGISTER = 32
KTM960X_VAL_STATUS_BYTE_FLAGS_REQUESTING_SERVICE = 64
KTM960X_VAL_STATUS_BYTE_FLAGS_USER7 = 128

# - Defined values for
# 	parameter Buttons in function KtM960x_SystemSfpMessageBox

KTM960X_VAL_MESSAGE_BOX_BUTTONS_OK = 0
KTM960X_VAL_MESSAGE_BOX_BUTTONS_OK_CANCEL = 1
KTM960X_VAL_MESSAGE_BOX_BUTTONS_YES_NO = 2

# - Defined values for
# 	parameter Val in function KtM960x_SystemSfpMessageBox

KTM960X_VAL_MESSAGE_BOX_RESULTS_NONE = 0
KTM960X_VAL_MESSAGE_BOX_RESULTS_OK = 1
KTM960X_VAL_MESSAGE_BOX_RESULTS_CANCEL = 2
KTM960X_VAL_MESSAGE_BOX_RESULTS_YES = 3
KTM960X_VAL_MESSAGE_BOX_RESULTS_NO = 4

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_CALIBRATION_STATUS
# 	attribute KTM960X_ATTR_CALIBRATION_STATUS

KTM960X_VAL_CALIBRATION_STATUS_DUE = 1
KTM960X_VAL_CALIBRATION_STATUS_EXPIRED = 2
KTM960X_VAL_CALIBRATION_STATUS_INSTRUMENT_CALIBRATED = 0
KTM960X_VAL_CALIBRATION_STATUS_MODULES_CALIBRATED = 3
KTM960X_VAL_CALIBRATION_STATUS_NOT_CALIBRATED = 4
KTM960X_VAL_CALIBRATION_STATUS_NOT_SUBJECT_TO_CALIBRATION = 5

# - Defined values for

KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_MASTER_PRODUCER = 0
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_MASTER_CONSUMER = 1
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_SLAVE_PRODUCER = 2
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_SLAVE_CONSUMER = 3
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_MASTER_PRODUCER = 4
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_MASTER_CONSUMER = 5
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_SLAVE_PRODUCER = 6
KTM960X_VAL_PEER_TO_PEER_PORT_ROLE_STREAMING_SLAVE_CONSUMER = 7

# - Defined values for

KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_OPAQUE = 0
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I8 = 1
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I16 = 2
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_I32 = 3
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_F32 = 4
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_F64 = 5
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_K_I32V1 = 101
KTM960X_VAL_PEER_TO_PEER_DATA_FORMAT_K_I24M8 = 102

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_RESOURCES_FP_SYNC = 32768
KTM960X_VAL_DEVICE_SYNC_RESOURCES_NONE = 0
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_LBL6 = 2048
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_LBR6 = 1024
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_STAR = 512
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG0 = 1
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG1 = 2
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG2 = 4
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG3 = 8
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG4 = 16
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG5 = 32
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG6 = 64
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXI_TRIG7 = 128
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARA = 4096
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARB = 8192
KTM960X_VAL_DEVICE_SYNC_RESOURCES_PXIE_DSTARC = 16384

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_STATE_ARM = 1
KTM960X_VAL_DEVICE_SYNC_STATE_IDLE = 0
KTM960X_VAL_DEVICE_SYNC_STATE_RUN = 3
KTM960X_VAL_DEVICE_SYNC_STATE_TRIGGER = 2
KTM960X_VAL_DEVICE_SYNC_STATE_UNKNOWN = 4

# - Defined values for

KTM960X_VAL_DEVICE_SYNC_ROLE_GROUP_MASTER = 2
KTM960X_VAL_DEVICE_SYNC_ROLE_LOCAL_MASTER = 4
KTM960X_VAL_DEVICE_SYNC_ROLE_OFF = 0
KTM960X_VAL_DEVICE_SYNC_ROLE_SLAVE = 3
KTM960X_VAL_DEVICE_SYNC_ROLE_SYSTEM_MASTER = 1
KTM960X_VAL_DEVICE_SYNC_ROLE_NOT_SUPPORTED = -1

# - Defined values for

KTM960X_VAL_ODI_LANE_RATE_12R5G = 1
KTM960X_VAL_ODI_LANE_RATE_14R1G = 2

# - Defined values for

KTM960X_VAL_ODI_DIRECTIONALITY_BIDIRECTIONAL = 1
KTM960X_VAL_ODI_DIRECTIONALITY_PRODUCER = 2
KTM960X_VAL_ODI_DIRECTIONALITY_CONSUMER = 3
KTM960X_VAL_ODI_DIRECTIONALITY_DUAL_UNIDIRECTIONAL = 4

# - Defined values for

KTM960X_VAL_ODI_FLOW_CONTROL_NONE = 1
KTM960X_VAL_ODI_FLOW_CONTROL_INBAND = 2
KTM960X_VAL_ODI_FLOW_CONTROL_INBAND_PER_CHANNEL = 3
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_1WIRE = 4
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_0 = 100
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_1 = 101
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_2 = 102
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_3 = 103
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_4 = 104
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_5 = 105
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_6 = 106
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_7 = 107
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_8 = 108
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_9 = 109
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_10 = 110
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_11 = 111
KTM960X_VAL_ODI_FLOW_CONTROL_OUTOFBAND_BACKPLANE_12 = 112

# - Defined values for

KTM960X_VAL_ODI_PORT_STATUS_ACTIVE = 1
KTM960X_VAL_ODI_PORT_STATUS_TX_READY = 2
KTM960X_VAL_ODI_PORT_STATUS_RX_READY = 4
KTM960X_VAL_ODI_PORT_STATUS_RX_LANE_ERROR = 8
KTM960X_VAL_ODI_PORT_STATUS_RX_BURST_MAX_ERROR = 16
KTM960X_VAL_ODI_PORT_STATUS_RX_CRC_ERROR = 32
KTM960X_VAL_ODI_PORT_STATUS_RX_OVERRUN = 64
KTM960X_VAL_ODI_PORT_STATUS_RX_FC_STATUS = 65536
KTM960X_VAL_ODI_PORT_STATUS_RX_FC_STATUS_0 = 131072
KTM960X_VAL_ODI_PORT_STATUS_RX_SIGNAL_LOSS = 128
KTM960X_VAL_ODI_PORT_STATUS_RX_SYNC_PENDING = 256

# - Defined values for

KTM960X_VAL_ODI_PACKET_FORMAT_NO_HEADER = 1
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_DATA = 2
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_WITH_CONTEXT = 3
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_ONCE = 1001
KTM960X_VAL_ODI_PACKET_FORMAT_VITA49_EXTENSION = 4

# - Defined values for

KTM960X_VAL_ODI_TIMESTAMP_FORMAT_NO_TIMESTAMP = 1
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_GPS = 2
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_RELATIVE = 3
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_SAMPLE_COUNT = 4
KTM960X_VAL_ODI_TIMESTAMP_FORMAT_UTC = 5

# - Defined values for

KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ24 = 10
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ32 = 2
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMATIQ64 = 3
KTM960X_VAL_ARB_DATA_FORMAT_ENUM_ARB_DATA_FORMAT_OPAQUE = 11

# - Defined values for

KTM960X_VAL_MARKER_ENUM_MARKER1 = 1
KTM960X_VAL_MARKER_ENUM_MARKER2 = 2
KTM960X_VAL_MARKER_ENUM_MARKER3 = 3
KTM960X_VAL_MARKER_ENUM_MARKER4 = 4
KTM960X_VAL_MARKER_ENUM_MARKER_NONE = 0

# - Defined values for

KTM960X_VAL_ARB_MEMORY_MODE_ENUM_ARB_MEMORY_MODE_AUTO = 0
KTM960X_VAL_ARB_MEMORY_MODE_ENUM_ARB_MEMORY_MODE_MANUAL = 1

# - Defined values for

KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_AUTO = 99
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBDP = 1
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBDP_PLUS_MARKERS = 0
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_KEYSIGHT = 4
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARB_SHORT = 3
KTM960X_VAL_BINARY_ARB_ENUM_BINARY_ARBSP = 2

# - Defined values for
# parameter FetchType in function KtM960x_MeasurementFetchArrayData
# parameter FetchType in function KtM960x_MeasurementFetchScalarData
# parameter FetchType in function KtM960x_MeasurementReadArrayData
# parameter FetchType in function KtM960x_MeasurementReadScalarData
# parameter FetchType in function KtM960x_MeasurementFetchLatestScalarData

KTM960X_VAL_MEASUREMENT_FETCH_TYPE_CURRENT = 2
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_RESISTANCE = 3
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_SOURCE = 6
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_STATUS = 4
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_TIME = 5
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_VOLTAGE = 1
KTM960X_VAL_MEASUREMENT_FETCH_TYPE_ALL = 0

# - Defined values for
# attribute KTM960X_ATTR_MEASUREMENT_ARM_SOURCE
# attribute KTM960X_ATTR_MEASUREMENT_TRIGGER_SOURCE
# attribute KTM960X_ATTR_TRANSIENT_ARM_SOURCE
# attribute KTM960X_ATTR_TRANSIENT_TRIGGER_SOURCE

KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_AINT = 0
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_BUS = 1
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_TIMER = 2
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI0 = 3
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI1 = 4
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI2 = 5
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI3 = 6
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI4 = 7
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI5 = 8
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI6 = 9
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PXI7 = 10
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_EXTERNAL1 = 11
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_EXTERNAL2 = 12
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_INTERNAL1 = 13
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_INTERNAL2 = 14
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PEER1 = 15
KTM960X_VAL_MEASUREMENT_TRIGGER_SOURCE_PEER2 = 16

# - Defined values for
# parameter MeasureType in function KtM960x_MeasurementMeasure
# parameter Val in function KtM960x_MeasurementFunctionGetDisabled
# parameter Val in function KtM960x_MeasurementFunctionGetEnabled
# parameter MeasureType in function KtM960x_MeasurementFunctionGetState
# parameter MeasureType in function KtM960x_MeasurementFunctionSetDisabled
# parameter MeasureType in function KtM960x_MeasurementFunctionSetEnabled

KTM960X_VAL_MEASUREMENT_TYPE_CURRENT = 2
KTM960X_VAL_MEASUREMENT_TYPE_RESISTANCE = 3
KTM960X_VAL_MEASUREMENT_TYPE_VOLTAGE = 1
KTM960X_VAL_MEASUREMENT_TYPE_ALL = 0

# - Defined values for
# parameter Val in function KtM960x_MeasurementGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementSetOutputTrigger
# parameter Val in function KtM960x_MeasurementArmGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementArmSetOutputTrigger
# parameter Val in function KtM960x_MeasurementTriggerGetOutputTrigger
# parameter Triggers in function KtM960x_MeasurementTriggerSetOutputTrigger
# parameter Val in function KtM960x_TransientGetOutputTrigger
# parameter Triggers in function KtM960x_TransientSetOutputTrigger
# parameter Val in function KtM960x_TransientArmGetOutputTrigger
# parameter Triggers in function KtM960x_TransientArmSetOutputTrigger
# parameter Val in function KtM960x_TransientCurrentGetListOutputTrigger
# parameter Triggers in function KtM960x_TransientCurrentSetListOutputTrigger
# parameter Val in function KtM960x_TransientTriggerGetOutputTrigger
# parameter Triggers in function KtM960x_TransientTriggerSetOutputTrigger
# parameter Val in function KtM960x_TransientVoltageGetListOutputTrigger
# parameter Triggers in function KtM960x_TransientVoltageSetListOutputTrigger

KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI0 = 0
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI1 = 1
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI2 = 2
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI3 = 3
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI4 = 4
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI5 = 5
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI6 = 6
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PXI7 = 7
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_EXTERNAL1 = 8
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_EXTERNAL2 = 9
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_INTERNAL1 = 10
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_INTERNAL2 = 11
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PEER1 = 12
KTM960X_VAL_OUTPUT_TRIGGER_SIGNAL_PEER2 = 13

# - Defined values for
# attribute KTM960X_ATTR_MEASUREMENT_ARM_BYPASS
# attribute KTM960X_ATTR_MEASUREMENT_TRIGGER_BYPASS
# attribute KTM960X_ATTR_TRANSIENT_ARM_BYPASS
# attribute KTM960X_ATTR_TRANSIENT_TRIGGER_BYPASS

KTM960X_VAL_BYPASS_OFF = 0
KTM960X_VAL_BYPASS_ONCE = 1

# - Defined values for

KTM960X_VAL_FORCE_RANGING_MODE_NORMAL = 0
KTM960X_VAL_FORCE_RANGING_MODE_SPEED = 1
KTM960X_VAL_FORCE_RANGING_MODE_RESOLUTION = 2

# - Defined values for

KTM960X_VAL_BUFFER_CONTROL_NEXT = 0
KTM960X_VAL_BUFFER_CONTROL_NEVER = 1

# - Defined values for

KTM960X_VAL_TRACE_OPERATION_MEAN = 0
KTM960X_VAL_TRACE_OPERATION_STANDARD_DEVIATION = 1
KTM960X_VAL_TRACE_OPERATION_MAXIMUM = 2
KTM960X_VAL_TRACE_OPERATION_MINIMUM = 3
KTM960X_VAL_TRACE_OPERATION_PEAK_TO_PEAK = 4

# - Defined values for

KTM960X_VAL_TIME_STAMP_FORMAT_ABSOLUTE = 0
KTM960X_VAL_TIME_STAMP_FORMAT_DELTA = 1

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_CURRENT_BASE_TYPE
# attribute KTM960X_ATTR_OUTPUT_VOLTAGE_BASE_TYPE

KTM960X_VAL_OUTPUT_BASE_TYPE_MANUAL = 0
KTM960X_VAL_OUTPUT_BASE_TYPE_IMMEDIATE = 1
KTM960X_VAL_OUTPUT_BASE_TYPE_TRIGGERED = 2
KTM960X_VAL_OUTPUT_BASE_TYPE_START = 3
KTM960X_VAL_OUTPUT_BASE_TYPE_STOP = 4

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_CURRENT_POST_TYPE
# attribute KTM960X_ATTR_OUTPUT_VOLTAGE_POST_TYPE

KTM960X_VAL_OUTPUT_POST_TYPE_TRIGGERED = 0
KTM960X_VAL_OUTPUT_POST_TYPE_START = 1
KTM960X_VAL_OUTPUT_POST_TYPE_STOP = 2
KTM960X_VAL_OUTPUT_POST_TYPE_BASE = 3
KTM960X_VAL_OUTPUT_POST_TYPE_MANUAL = 4
KTM960X_VAL_OUTPUT_POST_TYPE_IMMEDIATE = 5

# - Defined values for
# attribute KTM960X_ATTR_OUTPUT_OFF_CONDITION

KTM960X_VAL_OFF_CONDITION_ZERO = 0
KTM960X_VAL_OFF_CONDITION_HIZ = 1
KTM960X_VAL_OFF_CONDITION_NORMAL = 2

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_PRIORITY_MODE

KTM960X_VAL_PRIORITY_MODE_VOLTAGE = 0
KTM960X_VAL_PRIORITY_MODE_CURRENT = 1

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_SHAPE

KTM960X_VAL_SHAPE_MODE_DC = 0
KTM960X_VAL_SHAPE_MODE_PULSE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_CURRENT_MODE
# 	attribute KTM960X_ATTR_TRANSIENT_VOLTAGE_MODE

KTM960X_VAL_OUTPUT_MODE_FIXED = 0
KTM960X_VAL_OUTPUT_MODE_LIST = 1
KTM960X_VAL_OUTPUT_MODE_SWEEP = 2

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_MODE

KTM960X_VAL_SWEEP_MODE_SINGLE = 0
KTM960X_VAL_SWEEP_MODE_DOUBLE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_RANGING_MODE

KTM960X_VAL_OUTPUT_RANGING_MODE_BEST = 0
KTM960X_VAL_OUTPUT_RANGING_MODE_FIXED = 2

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_OUTPUT_SCALE

KTM960X_VAL_OUTPUT_SCALE_LINEAR = 0

# - Defined values for
# 	attribute KTM960X_ATTR_TRANSIENT_SWEEP_DIRECTION
#
KTM960X_VAL_SWEEP_DIRECTION_UP = 0
KTM960X_VAL_SWEEP_DIRECTION_DOWN = 1

# - Defined values for
# 	attribute KTM960X_ATTR_OUTPUT_OPERATION_MODE
KTM960X_VAL_OUTPUT_OPERATION_MODE_STANDARD = 0
KTM960X_VAL_OUTPUT_OPERATION_MODE_POWER_SUPPLY = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MEASUREMENT_ACQUISITION_MODE

KTM960X_VAL_ACQUISITION_MODE_NORMAL = 0
KTM960X_VAL_ACQUISITION_MODE_SAMPLING = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_EDGE_POSITION
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_EDGE_POSITION

KTM960X_VAL_IO_EDGE_POSITION_BEFORE = 0
KTM960X_VAL_IO_EDGE_POSITION_AFTER = 1
KTM960X_VAL_IO_EDGE_POSITION_BOTH = 2

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_FUNCTION
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_FUNCTION

KTM960X_VAL_IO_FUNCTION_TRIGGER_OUTPUT = 0
KTM960X_VAL_IO_FUNCTION_TRIGGER_INPUT = 1
KTM960X_VAL_IO_FUNCTION_DIGITAL_OUTPUT = 2

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_LEVEL
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_LEVEL
# 	parameter Val in function KtM960x_ModuleIOExternalRead
# 	parameter Val in function KtM960x_ModuleIOPxieRead

KTM960X_VAL_IO_LEVEL_HIGH = 0
KTM960X_VAL_IO_LEVEL_LOW = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_POLARITY
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_POLARITY

KTM960X_VAL_IO_POLARITY_POSITIVE = 0
KTM960X_VAL_IO_POLARITY_NEGATIVE = 1

# - Defined values for
# 	attribute KTM960X_ATTR_MODULE_IO_EXTERNAL_TYPE
# 	attribute KTM960X_ATTR_MODULE_IO_PXIE_TYPE

KTM960X_VAL_IO_TYPE_EDGE = 0
KTM960X_VAL_IO_TYPE_LEVEL = 1

# - Defined values for
# 	attribute KTM960X_ATTR_SYSTEM_GROUP_SYNC_TRIGGER_LINE

KTM960X_VAL_SYNC_TRIGGER_LINE_PXI0 = 0
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI1 = 1
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI2 = 2
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI3 = 3
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI4 = 4
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI5 = 5
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI6 = 6
KTM960X_VAL_SYNC_TRIGGER_LINE_PXI7 = 7
KTM960X_VAL_SYNC_TRIGGER_LINE_EXTERNAL1 = 8
KTM960X_VAL_SYNC_TRIGGER_LINE_EXTERNAL2 = 9


# ***************************************************************************
# *---------------- Instrument Driver Function Declarations -----------------*
# ***************************************************************************

# ***************************************************************************
# *----------------- Instrument Error And Completion Codes ------------------*
# ***************************************************************************


IVIC_WARN_BASE = 0x3FFA0000
IVIC_CROSS_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x1000
IVIC_CLASS_WARN_BASE = IVIC_WARN_BASE + 0x2000
IVIC_SPECIFIC_WARN_BASE = IVIC_WARN_BASE + 0x4000

IVIC_ERROR_BASE = 0xBFFA0000
IVIC_CROSS_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x1000
IVIC_CLASS_ERROR_BASE = IVIC_ERROR_BASE + 0x2000
IVIC_SPECIFIC_ERROR_BASE = IVIC_ERROR_BASE + 0x4000
IVIC_LXISYNC_ERROR_BASE = IVIC_ERROR_BASE + 0x2000

KTM960X_ERROR_CANNOT_RECOVER = IVIC_ERROR_BASE + 0x0000
KTM960X_ERROR_INSTRUMENT_STATUS = IVIC_ERROR_BASE + 0x0001
KTM960X_ERROR_CANNOT_OPEN_FILE = IVIC_ERROR_BASE + 0x0002
KTM960X_ERROR_READING_FILE = IVIC_ERROR_BASE + 0x0003
KTM960X_ERROR_WRITING_FILE = IVIC_ERROR_BASE + 0x0004
KTM960X_ERROR_INVALID_PATHNAME = IVIC_ERROR_BASE + 0x000B
KTM960X_ERROR_INVALID_ATTRIBUTE = IVIC_ERROR_BASE + 0x000C
KTM960X_ERROR_IVI_ATTR_NOT_WRITABLE = IVIC_ERROR_BASE + 0x000D
KTM960X_ERROR_IVI_ATTR_NOT_READABLE = IVIC_ERROR_BASE + 0x000E
KTM960X_ERROR_INVALID_VALUE = IVIC_ERROR_BASE + 0x0010
KTM960X_ERROR_FUNCTION_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0011
KTM960X_ERROR_ATTRIBUTE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0012
KTM960X_ERROR_VALUE_NOT_SUPPORTED = IVIC_ERROR_BASE + 0x0013
KTM960X_ERROR_TYPES_DO_NOT_MATCH = IVIC_ERROR_BASE + 0x0015
KTM960X_ERROR_NOT_INITIALIZED = IVIC_ERROR_BASE + 0x001D
KTM960X_ERROR_UNKNOWN_CHANNEL_NAME = IVIC_ERROR_BASE + 0x0020
KTM960X_ERROR_TOO_MANY_OPEN_FILES = IVIC_ERROR_BASE + 0x0023
KTM960X_ERROR_CHANNEL_NAME_REQUIRED = IVIC_ERROR_BASE + 0x0044
KTM960X_ERROR_MISSING_OPTION_NAME = IVIC_ERROR_BASE + 0x0049
KTM960X_ERROR_MISSING_OPTION_VALUE = IVIC_ERROR_BASE + 0x004A
KTM960X_ERROR_BAD_OPTION_NAME = IVIC_ERROR_BASE + 0x004B
KTM960X_ERROR_BAD_OPTION_VALUE = IVIC_ERROR_BASE + 0x004C
KTM960X_ERROR_OUT_OF_MEMORY = IVIC_ERROR_BASE + 0x0056
KTM960X_ERROR_OPERATION_PENDING = IVIC_ERROR_BASE + 0x0057
KTM960X_ERROR_NULL_POINTER = IVIC_ERROR_BASE + 0x0058
KTM960X_ERROR_UNEXPECTED_RESPONSE = IVIC_ERROR_BASE + 0x0059
KTM960X_ERROR_FILE_NOT_FOUND = IVIC_ERROR_BASE + 0x005B
KTM960X_ERROR_INVALID_FILE_FORMAT = IVIC_ERROR_BASE + 0x005C
KTM960X_ERROR_STATUS_NOT_AVAILABLE = IVIC_ERROR_BASE + 0x005D
KTM960X_ERROR_ID_QUERY_FAILED = IVIC_ERROR_BASE + 0x005E
KTM960X_ERROR_RESET_FAILED = IVIC_ERROR_BASE + 0x005F
KTM960X_ERROR_RESOURCE_UNKNOWN = IVIC_ERROR_BASE + 0x0060
KTM960X_ERROR_ALREADY_INITIALIZED = IVIC_ERROR_BASE + 0x0061
KTM960X_ERROR_CANNOT_CHANGE_SIMULATION_STATE = IVIC_ERROR_BASE + 0x0062
KTM960X_ERROR_INVALID_NUMBER_OF_LEVELS_IN_SELECTOR = IVIC_ERROR_BASE + 0x0063
KTM960X_ERROR_INVALID_RANGE_IN_SELECTOR = IVIC_ERROR_BASE + 0x0064
KTM960X_ERROR_UNKOWN_NAME_IN_SELECTOR = IVIC_ERROR_BASE + 0x0065
KTM960X_ERROR_BADLY_FORMED_SELECTOR = IVIC_ERROR_BASE + 0x0066
KTM960X_ERROR_UNKNOWN_PHYSICAL_IDENTIFIER = IVIC_ERROR_BASE + 0x0067
KTM960X_ERROR_INVALID_SESSION_HANDLE = IVIC_ERROR_BASE + 0x1190


KTM960X_SUCCESS = 0
KTM960X_WARN_NSUP_ID_QUERY = IVIC_WARN_BASE + 0x0065
KTM960X_WARN_NSUP_RESET = IVIC_WARN_BASE + 0x0066
KTM960X_WARN_NSUP_SELF_TEST = IVIC_WARN_BASE + 0x0067
KTM960X_WARN_NSUP_ERROR_QUERY = IVIC_WARN_BASE + 0x0068
KTM960X_WARN_NSUP_REV_QUERY = IVIC_WARN_BASE + 0x0069


KTM960X_ERROR_IO_GENERAL = IVIC_SPECIFIC_ERROR_BASE + 0x0214
KTM960X_ERROR_IO_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0215
KTM960X_ERROR_CALIBRATION_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0217
KTM960X_ERROR_CHECK_ERROR_QUEUE = IVIC_SPECIFIC_ERROR_BASE + 0x0218
KTM960X_ERROR_FILE_TYPE_NOT_RECOGNIZED = IVIC_SPECIFIC_ERROR_BASE + 0x0219
KTM960X_ERROR_FIRMWARE_UPDATE_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021A
KTM960X_ERROR_FIRMWARE_UPDATE_REQUIRED = IVIC_SPECIFIC_ERROR_BASE + 0x021B
KTM960X_ERROR_FPGA_PROGRAMMING_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x021C
KTM960X_ERROR_HARDWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x021D
KTM960X_ERROR_HW_RESOURCE_NOT_AVAILABLE = IVIC_SPECIFIC_ERROR_BASE + 0x021E
KTM960X_ERROR_INCOMPATIBLE_SOFTWARE_VERSION_ERROR = \
    IVIC_SPECIFIC_ERROR_BASE + 0x021F
KTM960X_ERROR_INSTRUMENT_CALIBRATION_DUE = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0220
KTM960X_ERROR_INSTRUMENT_CALIBRATION_EXPIRED = \
    IVIC_SPECIFIC_ERROR_BASE + 0x0221
KTM960X_ERROR_INSTRUMENT_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x0222
KTM960X_ERROR_INTERNAL_APPLICATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0223
KTM960X_ERROR_LICENSE_SYSTEM_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0224
KTM960X_ERROR_LICENSE_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0225
KTM960X_ERROR_MAX_TIME_EXCEEDED = IVIC_SPECIFIC_ERROR_BASE + 0x0226
KTM960X_ERROR_MISSING_CLOCK_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0227
KTM960X_ERROR_MODEL_NOT_SUPPORTED = IVIC_SPECIFIC_ERROR_BASE + 0x0228
KTM960X_ERROR_MODULE_CALIBRATION_DUE = IVIC_SPECIFIC_ERROR_BASE + 0x0229
KTM960X_ERROR_MODULE_CALIBRATION_EXPIRED = IVIC_SPECIFIC_ERROR_BASE + 0x022A
KTM960X_ERROR_MODULE_NOT_CALIBRATED = IVIC_SPECIFIC_ERROR_BASE + 0x022B
KTM960X_ERROR_MODULE_VALIDATE_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x022C
KTM960X_ERROR_OPERATION_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x022D
KTM960X_ERROR_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022E
KTM960X_ERROR_OUT_OF_MEMORY_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x022F
KTM960X_ERROR_PARAMETER_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x0230
KTM960X_ERROR_PERSONALITY_NOT_ACTIVE = IVIC_SPECIFIC_ERROR_BASE + 0x0231
KTM960X_ERROR_PERSONALITY_NOT_INSTALLED = IVIC_SPECIFIC_ERROR_BASE + 0x0232
KTM960X_ERROR_PERSONALITY_NOT_LICENSED = IVIC_SPECIFIC_ERROR_BASE + 0x0233
KTM960X_ERROR_SELFTEST_FAILED = IVIC_SPECIFIC_ERROR_BASE + 0x0234
KTM960X_ERROR_SOFTWARE_TIMEOUT = IVIC_SPECIFIC_ERROR_BASE + 0x0235
KTM960X_ERROR_TEST_FAILED_INCORRECT_VERSION = IVIC_SPECIFIC_ERROR_BASE + 0x0236
KTM960X_ERROR_THERMAL_SHUTDOWN = IVIC_SPECIFIC_ERROR_BASE + 0x0237
KTM960X_ERROR_THERMAL_WARNING = IVIC_SPECIFIC_ERROR_BASE + 0x0238
KTM960X_ERROR_UNABLE_TO_INITIALIZE_HARDWARE = IVIC_SPECIFIC_ERROR_BASE + 0x0239
KTM960X_ERROR_UNRECOGNIZED_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023A
KTM960X_ERROR_UNSUPPORTED_FEATURE = IVIC_SPECIFIC_ERROR_BASE + 0x023B
KTM960X_ERROR_UNSUPPORTED_PROPERTY = IVIC_SPECIFIC_ERROR_BASE + 0x023C
KTM960X_ERROR_VALIDATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023D
KTM960X_ERROR_VERIFY_OPERATION_ERROR = IVIC_SPECIFIC_ERROR_BASE + 0x023E
KTM960X_ERROR_WAIT_ABORTED = IVIC_SPECIFIC_ERROR_BASE + 0x023F
KTM960X_ERROR_NOT_IMPLEMENTED = IVIC_SPECIFIC_ERROR_BASE + 0x0240
"
159,5420.0,USA,"E8267D PSG Vector Signal Generator, 100 kHz to 44 GHz","Agilent E 8267 D
",26.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attc6xrG2EsYbFAYl'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fQUxMyvye7LkRNrW_9LpDw/a1a72T_ybNDngFNeEthdujK-3J411WCU7p5oSDUdZQKBnyItPISoB5kGTdXbBoZHMWn8OVlfLkqUORBw0cWhS3FAreUOnbjBjTSb7AkMQD0/aWKCcUbxs_atz78f_o0gyPdiOT19I4BOaetlO7zRc7s'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JMLOejSs0sNQqebza0_O4g/ptnoLe_aT143RHRw7XWGMF2Rbl_oJh18VP8XlO3pEzBdEpOleXMyRBWqTWt9h3Cvnv1NVgGzBSewM34fGtz6_G2zfORynLBJVLQttq4CERA/6RykqSNQV6z5GqlyNFAHFATyDxsZtr_dkrebBGCHQqo'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/55V5uSdPbh0zNz0Drmxo7A/nDDnQrgWyg3uGnPFSTEbFZFZg8lh6PmAa0gqcuhRBMy8ux1D1qEeynNZZfXB5RCYzdvd11mgkZDaWWL4zMTDdVK3jm-U_9HlUEEdEIRTjf8/-82nBzlZVRi4Izj7vfypYX3HzbD-Usw5_Owv_MfRxgU'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RWWIIc79xTTZegoK7wkprg/VCK9-LQrz8PtqcOTSmaZiNVa5dpQ2eq5sIELnqJMdDY0-qksJXtd4reH5o2nSEl2SeAVkYTwBrC4ZfMl2h_DMHsN8FrQO1wuGgXs-cNLh60/mZHEAeKa58qt39N5aX3_5o_zlOkrLoir5OMzhvImp8k'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT E8267D RF Signal Generator,https://www.keysight.com/us/en/products/signal-generators-signal-sources/psg-signal-generators.html,['RF Signal Generator'],"The Keysight PSG signal generators offer metrology-grade performance to help you generate realistic wideband radar, electronic warfare, and satellite communications signals.",KEYSIGHT E8267D,https://www.keysight.com/us/en/assets/7018-01210/data-sheets/5989-0697.pdf,"[OrderedDict([('id', 'attIhLiR2xjylECCP'), ('width', 1164), ('height', 494), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zNWxpshU--A2bd9aLqxLEw/KjD8fNr_lWi4Ljt2m0eDkxKl67t6nGDglt7CQm140gvBG9W1mDN3beBZgLdZElTuruVO3953G3exsIoPOyEMT9UM_0Jx4r3SN1n9s0sAO0w/iqCcWQ0kNWHgx_ExWEwBH5D0GCd7cbH_YmcPvO8w8gc'), ('filename', 'E8267D.png'), ('size', 407303), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LZgLUz0qBnoJKXWVNNKUIQ/LY9gFEwz6EVUeGVMRIuZHbXvIkU7wB0NG3XkoiGAL84X4XmDJWMg70IUEmmqW5KGcJhWT8JWKeefAqB0CZa0QA/c50II-B22_0k2cmH4vKeMY03BN6wja53GDt9PRUDl7Y'), ('width', 85), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_BCHOKzEVy9WnlHjTc3cuA/ZBsQJtHOKdPtS_B_DMFs4ZJmUonwU9QRPZR-2fRC7vrXgbnIql_JW3j0W3056eqTcEBh7o2LgBCIG5RADOJFSw/K2JRt2Jd-jCNRr4_6yXUh67dGGktqWFG2PDtEKivWs8'), ('width', 1164), ('height', 494)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1n2sKAPqWoj6ijvgrOU0pA/RM4ebJ9A_Af_3EUDGiSHW2hob6rxWABnbeFVx6u0RDE82Bg2KowXolJFX5-s-BDOD-XF9pHfzfHafyV7cPYeMg/rW31ghvqtR9E90rHer2Gv51yF_HB895EHmNOI_WNWsM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E8267D/psg-vector-signal-generator-100-khz-44-ghz.html?cmpid=ASA-2105924&utm_source=paid-search&utm_medium=ASA&utm_campaign=307&cq_cmp=18159629993&cq_con=141372453995&cq_term=&cq_plac=&cq_net=g&cq_pos=&cq_plt=gp&utm_term=&utm_campaign=Functional+Campaign+Paid+Search+DSA+Product+Ads+-+AMO+-EN&utm_source=adwords&utm_medium=ppc&hsa_acc=1602317043&hsa_cam=18159629993&hsa_grp=141372453995&hsa_ad=646056505105&hsa_src=g&hsa_tgt=aud-1655518197572:dsa-1923700525192&hsa_kw=&hsa_mt=&hsa_net=adwords&hsa_ver=3&gclid=Cj0KCQjw7uSkBhDGARIsAMCZNJvZ0T4_E08SKRFuZKtqOH0R4yQLDgrh8OqeN3-EX9yDvi3kaEdGzrcaAjLIEALw_wcB,https://github.com/morgan-at-keysight/pyarbtools/blob/c42a10c501d7a678819d35581f6386869d81d390/examples.py,https://pypi.org/project/pyarbtools/,100000.0,"
",,,"""""""
examples
Author: Morgan Allison, Keysight RF/uW Application Engineer
Provides example scripts for generic VSGs, and AWGs using
instrument classes from PyArbTools.
""""""

import pyarbtools


def vsg_chirp_example(ipAddress):
    """"""Creates downloads, assigns, and plays out a chirp waveform with
    a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 50e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()

    # Waveform definition variables
    name = ""chirp""
    pWidth = 10e-6
    bw = 40e6
    pri = 100e-6

    # Create waveform
    iq = pyarbtools.wfmBuilder.chirp_generator(fs=vsg.fs, pWidth=pWidth, pri=pri, chirpBw=bw)

    # Download and play waveform
    vsg.download_wfm(iq, name)
    vsg.play(name)

    # Check for erros and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_dig_mod_example(ipAddress):
    """"""Generates and plays 1 MHz 16 QAM signal with 0.35 alpha RRC filter
    @ 1 GHz CF with a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 200e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq, iqScale=70)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""10MHZ_16QAM""
    symRate = 10e6
    modType = ""qam16""

    # Create waveform
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=vsg.fs, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_am_example(ipAddress):
    """"""Generates an AM tone with the IQ modulator in a generic VSG.""""""

    # Create VSG object
    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 100e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""CUSTOM_AM""
    amRate = 100e3
    amDepth = 75

    # Create waveform
    iq = pyarbtools.wfmBuilder.am_generator(fs=vsg.fs, amDepth=amDepth, modRate=amRate)

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def vsg_mtone_example(ipAddress):
    """"""Generates a mutlitone signal on a generic VSG.""""""

    vsg = pyarbtools.instruments.VSG(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # vsg = pyarbtools.instruments.VSG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 100e6
    freq = 1e9

    # Configure signal generator
    vsg.configure(amp=amplitude, fs=sampleRate, cf=freq)
    vsg.sanity_check()
    vsg.err_check()

    # Waveform definition variables
    name = ""MULTITONE""
    numTones = 400
    toneSpacing = 100e3

    # Create waveform
    iq = pyarbtools.wfmBuilder.multitone_generator(fs=vsg.fs, spacing=toneSpacing, num=numTones)

    # Download and play waveform
    vsg.download_wfm(iq, wfmID=name)
    vsg.play(name)

    # Check for errors and gracefully disconnect
    vsg.err_check()
    vsg.close()


def m8190a_simple_wfm_example(ipAddress):
    """"""Sets up the M8190A and creates, downloads, assigns, and plays
    out a simple sine waveform from the AC output port.""""""

    res = ""wsp""
    fs = 10e9
    output = ""ac""
    amp = 0.6
    cf = 1e9
    wfmName = ""sine""

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    awg.configure(res=res, fs=fs, out1=output, amp1=amp)

    # Create simple sinusoidal waveform
    real = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=cf, wfmFormat=""real"")

    # Define segment 1 and populate it with waveform data.
    segment = awg.download_wfm(real, ch=1, name=wfmName, wfmFormat=""real"")

    # Assign segment to channel 1 and start playback.
    awg.play(ch=1, wfmID=segment)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8190a_duc_dig_mod_example(ipAddress):
    """"""Creates a 10 MHz 16 QAM waveform using digital upconversion on the M8190A.""""""

    res = ""intx3""
    cf = 1e9
    output = ""ac""

    modType = ""qam16""
    symRate = 10e6
    wfmName = ""10MHz_16QAM""

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    awg.configure(res=res, cf1=cf, out1=output)

    # Create 16 QAM signal.
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=awg.bbfs, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download waveform to memory
    segment = awg.download_wfm(iq, ch=1, name=wfmName, wfmFormat=""iq"")

    # Assign segment to channel 1 and start playback
    awg.play(wfmID=segment, ch=1)
    awg.err_check()
    awg.close()


def m8190a_duc_chirp_example(ipAddress):
    """"""Creates a 40 MHz chirped pulse using digital upconversion on the M8190A.""""""

    wfmName = ""chirp""
    res = ""intx3""
    fs = 7.2e9
    output = ""ac""
    cf = 1e9

    pw = 10e-6
    pri = 100e-6
    bw = 40e6

    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)
    
    awg.configure(res=res, fs=fs, out1=output, cf1=cf)

    # Create chirp waveform.
    iq = pyarbtools.wfmBuilder.chirp_generator(fs=awg.bbfs, pWidth=pw, pri=pri, chirpBw=bw, wfmFormat=""iq"")

    # Interleave i and q into a single waveform and download to segment 1.
    segment = awg.download_wfm(iq, ch=1, name=wfmName, wfmFormat=""iq"")

    # Assign segment to channel 1 and start playback.
    awg.play(wfmID=segment, ch=1)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8195a_simple_wfm_example(ipAddress):
    """"""Sets up the M8195A and creates, downloads, assigns, and plays
    out a simple sine waveform from the AC output port.""""""

    # Create M8195A object
    awg = pyarbtools.instruments.M8195A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8195A(ipAddress, port=5025, timeout=15, reset=True)

    # AWG configuration variables
    dacMode = ""dual""
    fs = 64e9
    awg.configure(dacMode=dacMode, fs=fs, amp1=100e-3)

    # Waveform definition variables
    sineFreq = 1e9
    wfmFormat = ""real""

    # Define a waveform, ensuring min length and granularity requirements are met
    real = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=sineFreq, wfmFormat=wfmFormat)

    # Download waveform to AWG and get waveform identifier
    wfmID = awg.download_wfm(real, ch=1)

    # Play waveform using identifier
    awg.play(wfmID=wfmID, ch=1)

    # Check for errors and gracefully disconnect.
    awg.err_check()
    awg.close()


def m8190a_sequence_example(ipAddress):
    """"""Creates a simple sinusoidal waveform and uses the idle segment in the sequencer to make it a pulsed signal.""""""

    # AWG Settings
    fs = 12e9
    res = ""wsp""
    out1 = ""dac""
    amp1 = 0.7
    func1 = ""sts""

    # Waveform Settings
    cf = 1e9
    pulseOffTime = 1e-6

    # Connect to AWG and configure settings.
    awg = pyarbtools.instruments.M8190A(ipAddress, apiType='pyvisa', protocol='hislip', port=0, timeout=3, reset=True)
    # awg = pyarbtools.instruments.M8190A(ipAddress, port=5025, timeout=15, reset=True)

    awg.configure(res=res, fs=fs, out1=out1, amp1=amp1, func1=func1)

    # Create a simple sine wave at our desired carrier frequency.
    sineWfmData = pyarbtools.wfmBuilder.sine_generator(fs=awg.fs, freq=cf, wfmFormat=""real"")
    sineWfmID = awg.download_wfm(sineWfmData, name=""sine"", wfmFormat=""real"")

    # We have to create an ""endcap"" waveform because the sequence cannot end with an idle segment.
    zeroWfmData = pyarbtools.wfmBuilder.zero_generator(fs=awg.fs, numSamples=awg.minLen, wfmFormat=""real"")
    zeroWfmID = awg.download_wfm(zeroWfmData, name=""zero"", wfmFormat=""real"")

    # Calculate how many samples to delay in the idle segment, taking into account the length of the ""endcap"" waveform.
    idleDelay = int(pulseOffTime * awg.fs - len(zeroWfmData))

    # Build our sequence
    awg.create_sequence(3)
    awg.insert_wfm_in_sequence(sineWfmID, 0, seqStart=True)
    awg.insert_idle_in_sequence(1, idleDelay=idleDelay)
    awg.insert_wfm_in_sequence(zeroWfmID, 2, seqEnd=True)

    # Play the sequence
    awg.play_sequence()

    awg.close()


def wfm_to_vsa_example(ipAddress):
    """"""This function creates a ""perfect"" digitally modulated waveform, exports it to a csv file,
    recalls it into VSA, and configures VSA to analyze it.""""""

    # Waveform creation variables
    symRate = 10e6
    fs = 100e6
    modType = ""qam256""
    psFilter = ""rootraisedcosine""
    alpha = 0.35
    fileName = ""C:\\Temp\\wfm.csv""
    fileFormat = ""csv""

    print(""Creating waveform."")
    # This is the new digital modulation waveform creation function
    data = pyarbtools.wfmBuilder.digmod_generator(
        fs=fs,
        symRate=symRate,
        modType=modType,
        filt=psFilter,
        numSymbols=10000,
        alpha=alpha,
    )

    print(""Exporting waveform."")
    # Export the waveform to a csv file
    pyarbtools.wfmBuilder.export_wfm(data, fileName, True, fs)

    print(""Setting up VSA."")
    # Create VSA object
    vsa = pyarbtools.vsaControl.VSA(ipAddress, vsaHardware=None, timeout=10, reset=False)

    # Select a digital demod measurement and configure it to measure the saved waveform
    vsa.set_measurement(""ddemod"")
    if psFilter.lower() == ""rootraisedcosine"":
        mFilter = ""rootraisedcosine""
        rFilter = ""raisedcosine""
    elif psFilter.lower() == ""raisedcosine"":
        mFilter = ""none""
        rFilter = ""raisedcosine""
    else:
        raise Exception(""Invalid filter type chosen."")

    # Configure digital demodulation in VSA
    vsa.configure_ddemod(
        amp=0,
        modType=modType,
        symRate=symRate,
        measFilter=mFilter,
        refFilter=rFilter,
        filterAlpha=alpha,
        measLength=1000,
        eqState=False,
    )

    # Recall csv file we exported earlier
    vsa.recall_recording(fileName, fileFormat=fileFormat)

    # Perform a single-shot replay in VSA
    vsa.acquire_single()

    # Check for errors and gracefully disconnect
    vsa.err_check()
    vsa.close()


def vsa_vector_example(ipAddress):
    """"""Connects to a running instance of VSA, configures a vector measurement, and prints out settings.""""""

    # Vector configuration settings
    cf = 1e9
    span = 20e6
    amp = -5
    time = 100e-6

    vsa = pyarbtools.vsaControl.VSA(ipAddress)
    vsa.set_measurement(""vector"")
    vsa.configure_vector(cf=cf, span=span, amp=amp, time=time)
    vsa.acquire_single()
    vsa.sanity_check()

    # Check for errors and gracefully disconnect
    vsa.err_check()
    vsa.close()


def vxg_mat_import_example(ipAddress, fileName):
    """"""Imports an IQ waveform from a .mat file, loads it into the VXG, and plays it out.""""""

    """"""
    import_mat() takes in a .mat file with an array containing the waveform data, and optional variables for
    waveform identifier, sample rate, and waveform type.
    The .mat file used as an example has the following variables:
        iqdata (complex array): Array containing waveform samples
        fs (float): Sample rate at which waveform was created
        wfmID (string): Name of waveform.
    In this case, we know the variable 'iqdata' in the .mat file contains our complex waveform data, so we use 'iqdata' as
    the 'targetVariable' argument.
    import_mat() returns a dict with 'data', 'fs', 'wfmID', and 'wfmFormat' members.
    If the .mat file contains the optional metadata variables, the corresponding dict members will be populated accordingly.
    """"""

    # Load waveform from .mat file
    wfmDict = pyarbtools.wfmBuilder.import_mat(fileName, targetVariable=""iqdata"")

    # Create VXG object
    vxg = pyarbtools.instruments.VXG(ipAddress, apiType='pyvisa', protocol='hislip', port=1, timeout=3, reset=True)
    # vxg = pyarbtools.instruments.VXG(ipAddress, port=5025, timeout=15, reset=True)

    # Configure vxg based on variables imported from the .mat file
    vxg.configure(cf2=1e9, fs2=wfmDict[""fs""], rfState2=1, amp2=0)

    # Download waveform to vxg by passing the complex array of samples and the waveform name from the dict
    vxg.download_wfm(wfmDict[""data""], wfmID=wfmDict[""wfmID""])

    # Play out the waveform by referencing the waveform name from the dict
    vxg.play(wfmID=wfmDict[""wfmID""], ch=2)

    vxg.close()


def vxg_dig_mod_example(ipAddress):
    """"""Generates and plays 1 MHz 16 QAM signal with 0.35 alpha RRC filter
    @ 1 GHz CF with a generic VSG.""""""

    # Create VSG object
    vxg = pyarbtools.instruments.VXG(ipAddress, apiType='pyvisa', protocol='hislip', port=1, timeout=3, reset=True)
    # vxg = pyarbtools.instruments.VXG(ipAddress, port=5025, timeout=15, reset=True)

    # Signal generator configuration variables
    amplitude = -5
    sampleRate = 200e6
    freq = 1e9

    # Configure signal generator
    vxg.configure(amp1=amplitude, fs1=sampleRate, cf1=freq, iqScale1=70)
    vxg.sanity_check()
    vxg.err_check()

    # Waveform definition variables
    name = ""100MHZ_16QAM""
    symRate = 100e6
    modType = ""qam16""

    # Create waveform
    iq = pyarbtools.wfmBuilder.digmod_generator(fs=vxg.fs1, modType=modType, symRate=symRate, filt=""rootraisedcosine"")

    # Download and play waveform
    vxg.download_wfm(iq, wfmID=name)
    vxg.play(name)

    # Check for errors and gracefully disconnect
    vxg.err_check()
    vxg.close()


def gui_example():
    """"""Starts experimental PyArbTools GUI""""""
    pyarbtools.gui.main()


def main():
    """"""Uncomment the example you'd like to run. For each example,
    replace the IP address with one that is appropriate for your
    instrument(s).""""""
    ipAddress = ""192.168.4.68""
    matFilePath = ""<insert path to .mat file here>""

    # m8190a_simple_wfm_example(ipAddress)
    # m8190a_duc_dig_mod_example(ipAddress)
    # m8190a_duc_chirp_example(ipAddress)
    # m8190a_iq_correction_example(ipAddress, '127.0.0.1', '""Analyzer1""')
    # m8195a_simple_wfm_example(ipAddress)
    # vsg_chirp_example(ipAddress)
    # vsg_dig_mod_example(ipAddress)
    # vsg_am_example(ipAddress)
    # vsg_mtone_example(ipAddress)
    # wfm_to_vsa_example(ipAddress)
    # vsa_vector_example(ipAddress)
    # vxg_mat_import_example(ipAddress, fileName=matFilePath)
    vxg_dig_mod_example(ipAddress)
    # m8190a_sequence_example(ipAddress)
    # gui_example()


if __name__ == ""__main__"":
    main()
"
162,2500.0,"Munich, Germany","The R&S ZNB8 from Rohde & Schwarz is a Vector Network Analyzer with Frequency 9 kHz to 8.5 GHz, Measurement Speed 4 ms, Dynamic Range typ. 122 dB to 140 dB, Output Power typ. 12 dBm to 15 dBm, Power Sweep Range 98 dB. Tags: VNA with Screen. More details for R&S ZNB8 can be seen below.",Rohde Schwarz ZNB 8,462.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a R&S ZNB8 Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.",R&S ZNB8,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/ZNB_bro_en_3608-3278-12_v0301.pdf,"[OrderedDict([('id', 'atttzWdgNIQu62X2D'), ('width', 700), ('height', 388), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HvkkjGq6lTGeenQa0vVUSw/YeN0pZYQjZTFGSaw_tyVarELwACp3MAlY--F8ZMD1uPMmlUP4oCKTQsl5stbX20ZCqZmoVNeozhjam2T9EY0a5x_hlX3pGmMYueP9aVJNw0/xw4uhgjFkcxtNROqbVKpScw6_7uNNU4lAFl_nh9ikjw'), ('filename', 'RS-ZNB-4port.webp'), ('size', 167034), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/3ujS4bMQOLPbmEJGZyGQwQ/1y3QKoY1M3sVt2Fm8ksd23MW0sy9vsPjGB7rE6M9I6joGYfmoMc63It8ItfXXcLmEnFNJhUv1Rb9DSb9E1yhCw3k87lIfyoNWJvKj5vMLhQ/Qc8jnZLB91hvVe-7jYg05vWTxpMmc1L02NfRVAyc_pw'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hu_LUlWj-tOS7w-MRcRVrA/5czSzKooXG5FiEJjnoS4PlruzBCzKqu0QjlXKdVwkGyvjcId3C9jje7iSbSajNZNZstH8AVOs0JwqCPv5YRsJfRnE-ukxofHlwA-A3QYr28/1KjLHjBuYrUHiTbPBDmusDzJ36AXkPRBusCOz62mrC8'), ('width', 700), ('height', 388)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oXeE3398MSVE2hC5rRbfTA/o916jG3LyEl0L-Ka60cumeqJdNwUq_f_H9AOkpwSvg0rnMS2YXwqjGzxzxeoH8T-n_R4uZZgkozLAzYMcpTbs8nbUTnhZD3_fpZVi9KbSjw/lC6QGhZ6K4Pdrf1dvs2laxkyVaoJKM9YVAMJDB5FZvQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.everythingrf.com/products/vector-network-analyzers/rohde-schwarz/565-92-r-s-znb8,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/Rohde_Schwarz_ZNB8.py,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNB8,,,,,"# Ensuring backwards compatibility

from .ZNB import ZNB


class RohdeSchwarzZNB8(ZNB):
    """"""
    QCoDeS driver for Rohde & Schwarz ZNB8

    """"""

    pass
"
164,25.0,USA,"SR830 Lock-In Amplifier provide high performance at a reasonable cost. The SR830 simultaneously displays the magnitude and phase of a signal,",SR 830,533.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"Lock-in amplifiers are used to detect and measure very small
AC signalsall the way down to a few nanovolts. Accurate
measurements may be made even when the small signal is
obscured by noise sources many thousands of times larger.
Lock-in amplifiers use a technique known as phase-sensitive
detection to single out the component of the signal at a
specific reference frequency and phase. Noise signals, at
frequencies other than the reference frequency, are rejected
and do not affect the measurement",,https://www.thinksrs.com/downloads/pdfs/catalog/SR810830c.pdf,"[OrderedDict([('id', 'attggHVukOXnjVx1E'), ('width', 4674), ('height', 4062), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_oFvqk58KUPCh1cMFnj9OQ/SA_rvJKW3PX0lcSfhJC-bsjkcURXiAjD8vLIgCpQfEsLy1lVyTKwDSh9k0A51H1rEs1x707B6XXJmd9dsrysQ2BOUVcLwNosGyEGQtNPMf0/PyZOh_8T0z257WbeIrwFWql5dxqFfUhlujGzJpSBoZs'), ('filename', 'SR830_FP_Wide1 (1).jpg'), ('size', 2833727), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/579-HKaGGUHx6Tgaae0ckg/gkOyELjOwebhzHO7iyR9YiUaJ7iazTByjg5WpS33TFAeH5RyMIogkLkH2APIFy7ernQsl1WQuanOk_Y07XMm0A/Nvd18SKpMaE0Bi_r0sq2ftG3pxD82pDR_zlHo6HqD_s'), ('width', 41), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XcWkrzclzDzpV1Dv8o7rPg/1GB_IAQpYAnPe3jkY2TPyTYyzgT-5vKVATURmuqxmn2DtznqcXz3sGv9kZNrbYq4pcO0WstiA29ZIYARgvi18Q/gCu2fch2w3dE2-k8Ix3cihmO-NnOWdMOJ7YaFBVZRy8'), ('width', 589), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BD7Hn9F6ME8SX5ssXV5rRQ/xkUN1ht6007H1fMsYPJ4hK2IuCUEn4r3-4k-bfl4aZmWzGQssc6Heq0hFW5GohnGoUkhrZFxejRQXvhAl76lMw/HGczOEbV9X8NHKj_9dvy2WFE1gTxGjjfZ-g419d_GeY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr810830.htm,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR830.py,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR830,4250.0,,,,"import time
from collections.abc import Iterable
from functools import partial
from typing import Any, Union

import numpy as np

from qcodes.instrument import VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    Parameter,
    ParameterWithSetpoints,
    ParamRawDataType,
)
from qcodes.validators import Arrays, ComplexNumbers, Enum, Ints, Numbers, Strings


class ChannelTrace(ParameterWithSetpoints):
    """"""
    Parameter class for the two channel buffers
    """"""

    def __init__(self, name: str, channel: int, **kwargs: Any) -> None:
        """"""
        Args:
            name: The name of the parameter
            channel: The relevant channel (1 or 2). The name should
                match this.
        """"""
        super().__init__(name, **kwargs)

        self._valid_channels = (1, 2)

        if channel not in self._valid_channels:
            raise ValueError('Invalid channel specifier. SR830 only has '
                             'channels 1 and 2.')

        if not isinstance(self.root_instrument, SR830):
            raise ValueError('Invalid parent instrument. ChannelBuffer '
                             'can only live on an SR830.')

        self.channel = channel
        self.update_unit()

    def update_unit(self) -> None:
        assert isinstance(self.root_instrument, SR830)
        params = self.root_instrument.parameters
        if params[f'ch{self.channel}_ratio'].get() != 'none':
            self.unit = '%'
        else:
            disp = params[f'ch{self.channel}_display'].get()
            if disp == 'Phase':
                self.unit = 'deg'
            else:
                self.unit = 'V'
            self.label = disp

    def get_raw(self) -> ParamRawDataType:
        """"""
        Get command. Returns numpy array
        """"""
        assert isinstance(self.root_instrument, SR830)
        N = self.root_instrument.buffer_npts()
        if N == 0:
            raise ValueError('No points stored in SR830 data buffer.'
                             ' Can not poll anything.')

        # poll raw binary data
        self.root_instrument.write(f'TRCL ? {self.channel}, 0, {N}')
        rawdata = self.root_instrument.visa_handle.read_raw()

        # parse it
        realdata = np.frombuffer(rawdata, dtype=""<i2"")
        numbers = realdata[::2] * 2.0 ** (realdata[1::2] - 124)

        return numbers


class ChannelBuffer(ArrayParameter):
    """"""
    Parameter class for the two channel buffers

    Currently always returns the entire buffer
    TODO (WilliamHPNielsen): Make it possible to query parts of the buffer.
    The instrument natively supports this in its TRCL call.
    """"""

    def __init__(self, name: str, instrument: 'SR830', channel: int) -> None:
        """"""
        Args:
            name: The name of the parameter
            instrument: The parent instrument
            channel: The relevant channel (1 or 2). The name should
                should match this.
        """"""
        self._valid_channels = (1, 2)

        if channel not in self._valid_channels:
            raise ValueError('Invalid channel specifier. SR830 only has '
                             'channels 1 and 2.')

        if not isinstance(instrument, SR830):
            raise ValueError('Invalid parent instrument. ChannelBuffer '
                             'can only live on an SR830.')

        super().__init__(
            name,
            shape=(1,),  # dummy initial shape
            unit=""V"",  # dummy initial unit
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""Holds an acquired (part of the) data buffer of one channel."",
            instrument=instrument,
        )

        self.channel = channel

    def prepare_buffer_readout(self) -> None:
        """"""
        Function to generate the setpoints for the channel buffer and
        get the right units
        """"""
        assert isinstance(self.instrument, SR830)
        N = self.instrument.buffer_npts()  # problem if this is zero?
        # TODO (WilliamHPNielsen): what if SR was changed during acquisition?
        SR = self.instrument.buffer_SR()
        if SR == 'Trigger':
            self.setpoint_units = ('',)
            self.setpoint_names = ('trig_events',)
            self.setpoint_labels = ('Trigger event number',)
            self.setpoints = (tuple(np.arange(0, N)),)
        else:
            dt = 1/SR
            self.setpoint_units = ('s',)
            self.setpoint_names = ('Time',)
            self.setpoint_labels = ('Time',)
            self.setpoints = (tuple(np.linspace(0, N*dt, N)),)

        self.shape = (N,)

        params = self.instrument.parameters
        # YES, it should be: comparing to the string 'none' and not
        # the None literal
        if params[f'ch{self.channel}_ratio'].get() != 'none':
            self.unit = '%'
        else:
            disp = params[f'ch{self.channel}_display'].get()
            if disp == 'Phase':
                self.unit = 'deg'
            else:
                self.unit = 'V'

        if self.channel == 1:
            self.instrument._buffer1_ready = True
        else:
            self.instrument._buffer2_ready = True

    def get_raw(self) -> ParamRawDataType:
        """"""
        Get command. Returns numpy array
        """"""
        assert isinstance(self.instrument, SR830)
        if self.channel == 1:
            ready = self.instrument._buffer1_ready
        else:
            ready = self.instrument._buffer2_ready

        if not ready:
            raise RuntimeError('Buffer not ready. Please run '
                               'prepare_buffer_readout')
        N = self.instrument.buffer_npts()
        if N == 0:
            raise ValueError('No points stored in SR830 data buffer.'
                             ' Can not poll anything.')

        # poll raw binary data
        self.instrument.write(f""TRCL ? {self.channel}, 0, {N}"")
        rawdata = self.instrument.visa_handle.read_raw()

        # parse it
        realdata = np.frombuffer(rawdata, dtype=""<i2"")
        numbers = realdata[::2] * 2.0 ** (realdata[1::2] - 124)
        if self.shape[0] != N:
            raise RuntimeError(
                f""SR830 got {N} points in buffer expected {self.shape[0]}""
            )
        return numbers


class SR830(VisaInstrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SR830 Lock-in Amplifier.
    """"""

    _VOLT_TO_N = {2e-9:    0, 5e-9:    1, 10e-9:  2,
                  20e-9:   3, 50e-9:   4, 100e-9: 5,
                  200e-9:  6, 500e-9:  7, 1e-6:   8,
                  2e-6:    9, 5e-6:   10, 10e-6:  11,
                  20e-6:  12, 50e-6:  13, 100e-6: 14,
                  200e-6: 15, 500e-6: 16, 1e-3:   17,
                  2e-3:   18, 5e-3:   19, 10e-3:  20,
                  20e-3:  21, 50e-3:  22, 100e-3: 23,
                  200e-3: 24, 500e-3: 25, 1:      26}
    _N_TO_VOLT = {v: k for k, v in _VOLT_TO_N.items()}

    _CURR_TO_N = {2e-15:    0, 5e-15:    1, 10e-15:  2,
                  20e-15:   3, 50e-15:   4, 100e-15: 5,
                  200e-15:  6, 500e-15:  7, 1e-12:   8,
                  2e-12:    9, 5e-12:   10, 10e-12:  11,
                  20e-12:  12, 50e-12:  13, 100e-12: 14,
                  200e-12: 15, 500e-12: 16, 1e-9:    17,
                  2e-9:    18, 5e-9:    19, 10e-9:   20,
                  20e-9:   21, 50e-9:   22, 100e-9:  23,
                  200e-9:  24, 500e-9:  25, 1e-6:    26}
    _N_TO_CURR = {v: k for k, v in _CURR_TO_N.items()}

    _VOLT_ENUM = Enum(*_VOLT_TO_N.keys())
    _CURR_ENUM = Enum(*_CURR_TO_N.keys())

    _INPUT_CONFIG_TO_N = {
        'a': 0,
        'a-b': 1,
        'I 1M': 2,
        'I 100M': 3,
    }

    _N_TO_INPUT_CONFIG = {v: k for k, v in _INPUT_CONFIG_TO_N.items()}

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, **kwargs)

        # Reference and phase
        self.add_parameter('phase',
                           label='Phase',
                           get_cmd='PHAS?',
                           get_parser=float,
                           set_cmd='PHAS {:.2f}',
                           unit='deg',
                           vals=Numbers(min_value=-360, max_value=729.99))

        self.add_parameter('reference_source',
                           label='Reference source',
                           get_cmd='FMOD?',
                           set_cmd='FMOD {}',
                           val_mapping={
                               'external': 0,
                               'internal': 1,
                           },
                           vals=Enum('external', 'internal'))

        self.add_parameter('frequency',
                           label='Frequency',
                           get_cmd='FREQ?',
                           get_parser=float,
                           set_cmd='FREQ {:.4f}',
                           unit='Hz',
                           vals=Numbers(min_value=1e-3, max_value=102e3))

        self.add_parameter('ext_trigger',
                           label='External trigger',
                           get_cmd='RSLP?',
                           set_cmd='RSLP {}',
                           val_mapping={
                               'sine': 0,
                               'TTL rising': 1,
                               'TTL falling': 2,
                           })

        self.add_parameter('harmonic',
                           label='Harmonic',
                           get_cmd='HARM?',
                           get_parser=int,
                           set_cmd='HARM {:d}',
                           vals=Ints(min_value=1, max_value=19999))

        self.add_parameter('amplitude',
                           label='Amplitude',
                           get_cmd='SLVL?',
                           get_parser=float,
                           set_cmd='SLVL {:.3f}',
                           unit='V',
                           vals=Numbers(min_value=0.004, max_value=5.000))

        # Input and filter
        self.add_parameter('input_config',
                           label='Input configuration',
                           get_cmd='ISRC?',
                           get_parser=self._get_input_config,
                           set_cmd='ISRC {}',
                           set_parser=self._set_input_config,
                           vals=Enum(*self._INPUT_CONFIG_TO_N.keys()))

        self.add_parameter('input_shield',
                           label='Input shield',
                           get_cmd='IGND?',
                           set_cmd='IGND {}',
                           val_mapping={
                               'float': 0,
                               'ground': 1,
                           })

        self.add_parameter('input_coupling',
                           label='Input coupling',
                           get_cmd='ICPL?',
                           set_cmd='ICPL {}',
                           val_mapping={
                               'AC': 0,
                               'DC': 1,
                           })

        self.add_parameter('notch_filter',
                           label='Notch filter',
                           get_cmd='ILIN?',
                           set_cmd='ILIN {}',
                           val_mapping={
                               'off': 0,
                               'line in': 1,
                               '2x line in': 2,
                               'both': 3,
                           })

        # Gain and time constant
        self.add_parameter(name='sensitivity',
                           label='Sensitivity',
                           get_cmd='SENS?',
                           set_cmd='SENS {:d}',
                           get_parser=self._get_sensitivity,
                           set_parser=self._set_sensitivity
                           )

        self.add_parameter('reserve',
                           label='Reserve',
                           get_cmd='RMOD?',
                           set_cmd='RMOD {}',
                           val_mapping={
                               'high': 0,
                               'normal': 1,
                               'low noise': 2,
                           })

        self.add_parameter('time_constant',
                           label='Time constant',
                           get_cmd='OFLT?',
                           set_cmd='OFLT {}',
                           unit='s',
                           val_mapping={
                               10e-6:  0, 30e-6:  1,
                               100e-6: 2, 300e-6: 3,
                               1e-3:   4, 3e-3:   5,
                               10e-3:  6, 30e-3:  7,
                               100e-3: 8, 300e-3: 9,
                               1:     10, 3:     11,
                               10:    12, 30:    13,
                               100:   14, 300:   15,
                               1e3:   16, 3e3:   17,
                               10e3:  18, 30e3:  19,
                           })

        self.add_parameter('filter_slope',
                           label='Filter slope',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           unit='dB/oct',
                           val_mapping={
                               6: 0,
                               12: 1,
                               18: 2,
                               24: 3,
                           })

        self.add_parameter('sync_filter',
                           label='Sync filter',
                           get_cmd='SYNC?',
                           set_cmd='SYNC {}',
                           val_mapping={
                               'off': 0,
                               'on': 1,
                           })

        def parse_offset_get(s: str) -> tuple[float, int]:
            parts = s.split(',')

            return float(parts[0]), int(parts[1])

        # TODO: Parameters that can be set with multiple arguments
        # For the OEXP command for example two arguments are needed
        self.add_parameter('X_offset',
                           get_cmd='OEXP? 1',
                           get_parser=parse_offset_get)

        self.add_parameter('Y_offset',
                           get_cmd='OEXP? 2',
                           get_parser=parse_offset_get)

        self.add_parameter('R_offset',
                           get_cmd='OEXP? 3',
                           get_parser=parse_offset_get)

        # Aux input/output
        for i in [1, 2, 3, 4]:
            self.add_parameter(f'aux_in{i}',
                               label=f'Aux input {i}',
                               get_cmd=f'OAUX? {i}',
                               get_parser=float,
                               unit='V')

            self.add_parameter(f'aux_out{i}',
                               label=f'Aux output {i}',
                               get_cmd=f'AUXV? {i}',
                               get_parser=float,
                               set_cmd=f'AUXV {i}, {{}}',
                               unit='V')

        # Setup
        self.add_parameter('output_interface',
                           label='Output interface',
                           get_cmd='OUTX?',
                           set_cmd='OUTX {}',
                           val_mapping={
                               'RS232': '0\n',
                               'GPIB': '1\n',
                           })

        # Data transfer
        self.add_parameter('X',
                           get_cmd='OUTP? 1',
                           get_parser=float,
                           unit='V')

        self.add_parameter('Y',
                           get_cmd='OUTP? 2',
                           get_parser=float,
                           unit='V')

        self.add_parameter('R',
                           get_cmd='OUTP? 3',
                           get_parser=float,
                           unit='V')

        self.add_parameter('P',
                           get_cmd='OUTP? 4',
                           get_parser=float,
                           unit='deg')

        self.add_parameter(
            ""complex_voltage"",
            label=""Voltage"",
            get_cmd=self._get_complex_voltage,
            unit=""V"",
            docstring=""Complex voltage parameter ""
            ""calculated from X, Y phase using ""
            ""Z = X +j*Y"",
            vals=ComplexNumbers(),
        )

        # Data buffer settings
        self.add_parameter('buffer_SR',
                           label='Buffer sample rate',
                           get_cmd='SRAT ?',
                           set_cmd=self._set_buffer_SR,
                           unit='Hz',
                           val_mapping={62.5e-3: 0,
                                        0.125: 1,
                                        0.250: 2,
                                        0.5: 3,
                                        1: 4, 2: 5,
                                        4: 6, 8: 7,
                                        16: 8, 32: 9,
                                        64: 10, 128: 11,
                                        256: 12, 512: 13,
                                        'Trigger': 14},
                           get_parser=int
                           )

        self.add_parameter('buffer_acq_mode',
                           label='Buffer acquistion mode',
                           get_cmd='SEND ?',
                           set_cmd='SEND {}',
                           val_mapping={'single shot': 0,
                                        'loop': 1},
                           get_parser=int)

        self.add_parameter('buffer_trig_mode',
                           label='Buffer trigger start mode',
                           get_cmd='TSTR ?',
                           set_cmd='TSTR {}',
                           val_mapping={'ON': 1, 'OFF': 0},
                           get_parser=int)

        self.add_parameter('buffer_npts',
                           label='Buffer number of stored points',
                           get_cmd='SPTS ?',
                           get_parser=int)

        self.add_parameter('sweep_setpoints',
                           parameter_class=GeneratedSetPoints,
                           vals=Arrays(shape=(self.buffer_npts.get,)))

        # Channel setup
        for ch in range(1, 3):

            # detailed validation and mapping performed in set/get functions
            self.add_parameter(f'ch{ch}_ratio',
                               label=f'Channel {ch} ratio',
                               get_cmd=partial(self._get_ch_ratio, ch),
                               set_cmd=partial(self._set_ch_ratio, ch),
                               vals=Strings())
            self.add_parameter(f'ch{ch}_display',
                               label=f'Channel {ch} display',
                               get_cmd=partial(self._get_ch_display, ch),
                               set_cmd=partial(self._set_ch_display, ch),
                               vals=Strings())
            self.add_parameter(f'ch{ch}_databuffer',
                               channel=ch,
                               parameter_class=ChannelBuffer)
            self.add_parameter(f'ch{ch}_datatrace',
                               channel=ch,
                               vals=Arrays(shape=(self.buffer_npts.get,)),
                               setpoints=(self.sweep_setpoints,),
                               parameter_class=ChannelTrace)

        # Auto functions
        self.add_function('auto_gain', call_cmd='AGAN')
        self.add_function('auto_reserve', call_cmd='ARSV')
        self.add_function('auto_phase', call_cmd='APHS')
        self.add_function('auto_offset', call_cmd='AOFF {0}',
                          args=[Enum(1, 2, 3)])

        # Interface
        self.add_function('reset', call_cmd='*RST')

        self.add_function('disable_front_panel', call_cmd='OVRM 0')
        self.add_function('enable_front_panel', call_cmd='OVRM 1')

        self.add_function('send_trigger', call_cmd='TRIG',
                          docstring=(""Send a software trigger. ""
                                     ""This command has the same effect as a ""
                                     ""trigger at the rear panel trigger""
                                     "" input.""))

        self.add_function('buffer_start', call_cmd='STRT',
                          docstring=(""The buffer_start command starts or ""
                                     ""resumes data storage. buffer_start""
                                     "" is ignored if storage is already in""
                                     "" progress.""))

        self.add_function('buffer_pause', call_cmd='PAUS',
                          docstring=(""The buffer_pause command pauses data ""
                                     ""storage. If storage is already paused ""
                                     ""or reset then this command is ignored.""))

        self.add_function('buffer_reset', call_cmd='REST',
                          docstring=(""The buffer_reset command resets the data""
                                     "" buffers. The buffer_reset command can ""
                                     ""be sent at any time - any storage in ""
                                     ""progress, paused or not, will be reset.""
                                     "" This command will erase the data ""
                                     ""buffer.""))

        # Initialize the proper units of the outputs and sensitivities
        self.input_config()

        # start keeping track of buffer setpoints
        self._buffer1_ready = False
        self._buffer2_ready = False

        self.connect_message()


    SNAP_PARAMETERS = {
            'x': '1',
            'y': '2',
            'r': '3',
            'p': '4',
        'phase': '4',
            'θ': '4',
         'aux1': '5',
         'aux2': '6',
         'aux3': '7',
         'aux4': '8',
         'freq': '9',
          'ch1': '10',
          'ch2': '11'
    }

    def snap(self, *parameters: str) -> tuple[float, ...]:
        """"""
        Get between 2 and 6 parameters at a single instant. This provides a
        coherent snapshot of measured signals. Pick up to 6 from: X, Y, R, θ,
        the aux inputs 1-4, frequency, or what is currently displayed on
        channels 1 and 2.

        Reading X and Y (or R and θ) gives a coherent snapshot of the signal.
        Snap is important when the time constant is very short, a time constant
        less than 100 ms.

        Args:
            *parameters: From 2 to 6 strings of names of parameters for which
                the values are requested. including: 'x', 'y', 'r', 'p',
                'phase' or 'θ', 'aux1', 'aux2', 'aux3', 'aux4', 'freq',
                'ch1', and 'ch2'.

        Returns:
            A tuple of floating point values in the same order as requested.

        Examples:
            >>> lockin.snap('x','y') -> tuple(x,y)

            >>> lockin.snap('aux1','aux2','freq','phase')
            >>> -> tuple(aux1,aux2,freq,phase)

        Note:
            Volts for x, y, r, and aux 1-4
            Degrees for θ
            Hertz for freq
            Unknown for ch1 and ch2. It will depend on what was set.

             - If X,Y,R and θ are all read, then the values of X,Y are recorded
               approximately 10 µs apart from R,θ. Thus, the values of X and Y
               may not yield the exact values of R and θ from a single snap.
             - The values of the Aux Inputs may have an uncertainty of
               up to 32 µs.
             - The frequency is computed only every other period or 40 ms,
               whichever is longer.
        """"""
        if not 2 <= len(parameters) <= 6:
            raise KeyError(
                'It is only possible to request values of 2 to 6 parameters'
                ' at a time.')

        for name in parameters:
            if name.lower() not in self.SNAP_PARAMETERS:
                raise KeyError(f'{name} is an unknown parameter. Refer'
                               f' to `SNAP_PARAMETERS` for a list of valid'
                               f' parameter names')

        p_ids = [self.SNAP_PARAMETERS[name.lower()] for name in parameters]
        output = self.ask(f'SNAP? {"","".join(p_ids)}')

        return tuple(float(val) for val in output.split(','))

    def increment_sensitivity(self) -> bool:
        """"""
        Increment the sensitivity setting of the lock-in. This is equivalent
        to pushing the sensitivity up button on the front panel. This has no
        effect if the sensitivity is already at the maximum.

        Returns:
            Whether or not the sensitivity was actually changed.
        """"""
        return self._change_sensitivity(1)

    def decrement_sensitivity(self) -> bool:
        """"""
        Decrement the sensitivity setting of the lock-in. This is equivalent
        to pushing the sensitivity down button on the front panel. This has no
        effect if the sensitivity is already at the minimum.

        Returns:
            Whether or not the sensitivity was actually changed.
        """"""
        return self._change_sensitivity(-1)

    def _change_sensitivity(self, dn: int) -> bool:
        if self.input_config() in ['a', 'a-b']:
            n_to = self._N_TO_VOLT
            to_n = self._VOLT_TO_N
        else:
            n_to = self._N_TO_CURR
            to_n = self._CURR_TO_N

        n = to_n[self.sensitivity()]

        if n + dn > max(n_to.keys()) or n + dn < min(n_to.keys()):
            return False

        self.sensitivity.set(n_to[n + dn])
        return True

    def _set_buffer_SR(self, SR: int) -> None:
        self.write(f'SRAT {SR}')
        self._buffer1_ready = False
        self._buffer2_ready = False
        self.sweep_setpoints.update_units_if_constant_sample_rate()

    def _get_ch_ratio(self, channel: int) -> str:
        val_mapping = {1: {0: 'none',
                           1: 'Aux In 1',
                           2: 'Aux In 2'},
                       2: {0: 'none',
                           1: 'Aux In 3',
                           2: 'Aux In 4'}}
        resp = int(self.ask(f'DDEF ? {channel}').split(',')[1])

        return val_mapping[channel][resp]

    def _set_ch_ratio(self, channel: int, ratio: str) -> None:
        val_mapping = {1: {'none': 0,
                           'Aux In 1': 1,
                           'Aux In 2': 2},
                       2: {'none': 0,
                           'Aux In 3': 1,
                           'Aux In 4': 2}}
        vals = val_mapping[channel].keys()
        if ratio not in vals:
            raise ValueError(f'{ratio} not in {vals}')
        ratio_int = val_mapping[channel][ratio]
        disp_val = int(self.ask(f'DDEF ? {channel}').split(',')[0])
        self.write(f'DDEF {channel}, {disp_val}, {ratio_int}')
        self._buffer_ready = False

    def _get_ch_display(self, channel: int) -> str:
        val_mapping = {1: {0: 'X',
                           1: 'R',
                           2: 'X Noise',
                           3: 'Aux In 1',
                           4: 'Aux In 2'},
                       2: {0: 'Y',
                           1: 'Phase',
                           2: 'Y Noise',
                           3: 'Aux In 3',
                           4: 'Aux In 4'}}
        resp = int(self.ask(f'DDEF ? {channel}').split(',')[0])

        return val_mapping[channel][resp]

    def _set_ch_display(self, channel: int, disp: str) -> None:
        val_mapping = {1: {'X': 0,
                           'R': 1,
                           'X Noise': 2,
                           'Aux In 1': 3,
                           'Aux In 2': 4},
                       2: {'Y': 0,
                           'Phase': 1,
                           'Y Noise': 2,
                           'Aux In 3': 3,
                           'Aux In 4': 4}}
        vals = val_mapping[channel].keys()
        if disp not in vals:
            raise ValueError(f'{disp} not in {vals}')
        disp_int = val_mapping[channel][disp]
        # Since ratio AND display are set simultaneously,
        # we get and then re-set the current ratio value
        ratio_val = int(self.ask(f'DDEF ? {channel}').split(',')[1])
        self.write(f'DDEF {channel}, {disp_int}, {ratio_val}')
        self._buffer_ready = False
        # we update the unit of the datatrace
        # according to the choice of channel
        params = self.parameters
        dataparam = params[f'ch{channel}_datatrace']
        assert isinstance(dataparam, ChannelTrace)
        dataparam.update_unit()

    def _set_units(self, unit: str) -> None:
        # TODO:
        # make a public parameter function that allows to change the units
        for param in [self.X, self.Y, self.R, self.sensitivity]:
            param.unit = unit

    def _get_complex_voltage(self) -> complex:
        x, y = self.snap(""X"", ""Y"")
        return x + 1.0j * y

    def _get_input_config(self, s: int) -> str:
        mode = self._N_TO_INPUT_CONFIG[int(s)]

        if mode in ['a', 'a-b']:
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return mode

    def _set_input_config(self, s: str) -> int:
        if s in ['a', 'a-b']:
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units('V')
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units('A')

        return self._INPUT_CONFIG_TO_N[s]

    def _get_sensitivity(self, s: int) -> float:
        if self.input_config() in ['a', 'a-b']:
            return self._N_TO_VOLT[int(s)]
        else:
            return self._N_TO_CURR[int(s)]

    def _set_sensitivity(self, s: float) -> int:
        if self.input_config() in ['a', 'a-b']:
            return self._VOLT_TO_N[s]
        else:
            return self._CURR_TO_N[s]

    def autorange(self, max_changes: int = 1) -> None:
        """"""
        Automatically changes the sensitivity of the instrument according to
        the R value and defined max_changes.

        Args:
            max_changes: Maximum number of steps allowing the function to
                automatically change the sensitivity (default is 1). The actual
                number of steps needed to change to the optimal sensitivity may
                be more or less than this maximum.
        """"""
        def autorange_once() -> bool:
            r = self.R()
            sens = self.sensitivity()
            if r > 0.9 * sens:
                return self.increment_sensitivity()
            elif r < 0.1 * sens:
                return self.decrement_sensitivity()
            return False

        sets = 0
        while autorange_once() and sets < max_changes:
            sets += 1
            time.sleep(self.time_constant())

    def set_sweep_parameters(self,
                             sweep_param: Parameter,
                             start: float,
                             stop: float,
                             n_points: int = 10,
                             label: Union[str, None] = None) -> None:

        self.sweep_setpoints.sweep_array = np.linspace(start, stop, n_points)
        self.sweep_setpoints.unit = sweep_param.unit
        if label is not None:
            self.sweep_setpoints.label = label
        elif sweep_param.label is not None:
            self.sweep_setpoints.label = sweep_param.label


class GeneratedSetPoints(Parameter):
    """"""
    A parameter that generates a setpoint array from start, stop and num points
    parameters.
    """"""
    def __init__(self,
                 sweep_array: Iterable[Union[float, int]] = np.linspace(0, 1, 10),
                 *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.sweep_array = sweep_array
        self.update_units_if_constant_sample_rate()

    def update_units_if_constant_sample_rate(self) -> None:
        """"""
        If the buffer is filled at a constant sample rate,
        update the unit to ""s"" and label to ""Time"";
        otherwise do nothing
        """"""
        assert isinstance(self.root_instrument, SR830)
        SR = self.root_instrument.buffer_SR.get()
        if SR != 'Trigger':
            self.unit = 's'
            self.label = 'Time'

    def set_raw(self, value: Iterable[Union[float, int]]) -> None:
        self.sweep_array = value

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.root_instrument, SR830)
        SR = self.root_instrument.buffer_SR.get()
        if SR == 'Trigger':
            return self.sweep_array
        else:
            N = self.root_instrument.buffer_npts.get()
            dt = 1/SR

            return np.linspace(0, N*dt, N)
"
165,5420.0,USA,,Keysightagilent 33 XXX,293.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a (XXX --> Series) ,,,,(XXX --> Series),,,,,,,,,,
168,5420.0,USA,"The Keysight 34980A Multifunction Switch/Measure unit is designed for R&D and
manufacturing test engineers who are working in design verification, automated
test or data acquisition and are either looking to upgrade their existing systems or
are in need of a new, cost-effective alternative",Keysight 34980 A,339.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,"Write a Python script that uses Qcodes to connect to a KEYSIGHT 34980A DAQ boards, Multimeters",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,"['DAQ boards', 'Multimeters']","With 19 different plug-in modules in low frequency, RF and microwave switching to
20GHz, digital I/O, D/A converters, and counter/totalizer functionality, the 34980A
has the core switch/measure functionality needed for most automated test and
data acquisition applications. The 34980A can accommodate up to 560 2-wire
MUX or 1024 2-wire matrix crosspoints in one mainframe.",KEYSIGHT 34980A,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,"[OrderedDict([('id', 'attep8JPM5PjAYEs7'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mb5C2yklE5HVreUbteeFRA/nTCFY1v8dDOvMsTkWDmP99VT89yzx0dB0V3rrPSYrne8QErKTs0QYL8E4w24LMN5Zwp20fdq9fHzTh5uKkevu53dpyDhe-DQtzj-3PjSsdiShfN_w7P6-BOwyuqtGwC1/s5OFBgadwUmqv7IP3sJPF5mqDKfU296KeGIdil_j7ww'), ('filename', '34980A-FRONT-TRANSP-01-20190415.png'), ('size', 891966), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wuLUGOr7_9iHae3fKdQAhw/kMs_HN9I5anpN0hp3b-JcvN57c2fZMpFeKPd-00v5QfcdVbcmWtS5zAreR9sLqf4QnLCJkUGj5cArbpmD1agCQ/gD3JL7VkNHlgqagDfbyEriyklDrvWKnS9Ri-UvRACyY'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CSsgSevVRewVhbB-boT37A/UCMNTOJDT97X5PLZsjhxOOw4GN1nuWl9upN-W0Ebg-e65b4KTC-S85srUE_idV7OjpTcP96PVqoiagiLnt9uUg/emdk6yfso3D8rAycxj0EJkPoLOkOvwmBneRRk1diTL0'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e1ML_kS_AjII3MwxapWXPw/lMrhgSIwQZqiE9p0QQj3ep2zTX6ugimb7sTl9qffw1QViiqSH6_lpriOzThZsVSij69MOwWvhOmHlxyN8_Hofg/O01U6lPj7KIokJT7KjqkPEgWPPuM9SJLQ04_ngtvTao'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34980a.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34980A,4167.0,,,,"import logging
import warnings
import re
from functools import wraps
from typing import Any, TypeVar, Dict
from .keysight_34980a_submodules import KeysightSubModule
from .keysight_34934a import Keysight34934A
from qcodes.instrument.visa import VisaInstrument

from qcodes.utils import validators as vals
from typing import Callable, Optional

KEYSIGHT_MODELS = {'34934A': Keysight34934A}


T = TypeVar('T')


def post_execution_status_poll(func: Callable[..., T]) -> Callable[..., T]:
    """"""
    Generates a decorator that clears the instrument's status registers
    before executing the actual call and reads the status register after the
    function call to determine whether an error occurs.

    Args:
        func: function to wrap
    """"""
    @wraps(func)
    def wrapper(self: ""Keysight34980A"", *args: Any, **kwargs: Any) -> T:
        self.clear_status()
        retval = func(self, *args, **kwargs)

        stb = self.get_status()
        if stb:
            warnings.warn(f""Instrument status byte indicates an error occurred ""
                          f""(value of STB was: {stb})! Use `get_error` method ""
                          f""to poll error message."",
                          stacklevel=2)
        return retval

    return wrapper


class Keysight34980A(VisaInstrument):
    """"""
    QCodes driver for 34980A switch/measure unit
    """"""
    def __init__(self,
                 name: str,
                 address: str,
                 terminator: str = '\n',
                 **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address.
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self._total_slot = 8
        self._system_slots_info_dict: Optional[Dict[int, Dict[str, str]]] = None
        self.module = dict.fromkeys(self.system_slots_info.keys())
        self.scan_slots()
        self.connect_message()

    def get_status(self) -> int:
        """"""
        Queries status register

        Returns:
            0 if there is no error
        """"""
        msg = super().ask('*ESR?')
        nums = list(map(int, re.findall(r'\d+', msg)))
        return nums[0]

    def get_error(self) -> str:
        """"""
        Queries error queue

        Returns:
            error message, or '+0,""No error""' if there is no error
        """"""
        msg = super().ask(':SYST:ERR?')
        return msg

    def clear_status(self) -> None:
        """"""
        Clears status register and error queue of the instrument.
        """"""
        super().write('*CLS')

    def reset(self) -> None:
        """"""
        Performs an instrument reset.
        Does not reset error queue!
        """"""
        super().write('*RST')

    @post_execution_status_poll
    def ask(self, cmd: str) -> str:
        return super().ask(cmd)

    @post_execution_status_poll
    def write(self, cmd: str) -> None:
        return super().write(cmd)

    def scan_slots(self) -> None:
        """"""
        Scan the occupied slots and make an object for each switch matrix
        module installed
        """"""
        for slot in self.system_slots_info.keys():
            model_string = self.system_slots_info[slot]['model']
            for model in KEYSIGHT_MODELS:
                if model in model_string:
                    sub_module_name = f'slot_{slot}_{model}'
                    sub_module = KEYSIGHT_MODELS[model](self,
                                                        sub_module_name,
                                                        slot)
                    self.module[slot] = sub_module
                    self.add_submodule(sub_module_name, sub_module)
                    break
            if self.module[slot] is None:
                sub_module_name = f'slot_{slot}_{model_string}_no_driver'
                sub_module_no_driver = KeysightSubModule(self,
                                                         sub_module_name,
                                                         slot)
                self.module[slot] = sub_module_no_driver
                self.add_submodule(sub_module_name, sub_module_no_driver)
                logging.warning(f'can not find driver for {model_string}'
                                f'in slot {slot}')

    @property
    def system_slots_info(self) -> Dict[int, Dict[str, str]]:
        if self._system_slots_info_dict is None:
            self._system_slots_info_dict = self._system_slots_info()
        return self._system_slots_info_dict

    def _system_slots_info(self) -> Dict[int, Dict[str, str]]:
        """"""
        the command SYST:CTYP? returns the following:
        Agilent Technologies,<Model Number>,<Serial Number>,<Firmware Rev>
        where <Model Number> is '0' if there is no module connected to the
        given slot

        Returns:
            a dictionary, with slot numbers as the keys, and vendor/model/
            serial/firmware dictionaries as the values
        """"""
        slots_dict = {}
        keys = ['vendor', 'model', 'serial', 'firmware']
        for i in range(1, self._total_slot+1):
            identity = self.ask(f'SYST:CTYP? {i}').strip('""').split(',')
            if identity[1] != '0':
                slots_dict[i] = dict(zip(keys, identity))
        return slots_dict

    def disconnect_all(self, slot: Optional[int] = None) -> None:
        """"""
        to open/disconnect all connections on select module

        Args:
            slot: slot number, between 1 and 8 (self._total_slot),
                    default value is None, which means all slots
        """"""
        cmd = 'ROUT:OPEN:ALL'
        if slot is None:
            self.write(cmd)
        else:
            vals.Ints(min_value=1, max_value=self._total_slot).validate(slot)
            self.write(f'ROUT:OPEN:ALL {slot}')
"
172,5420.0,USA,"The 33510B waveform generator provides Keysight's exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements.
",Keysight 33510 B,296.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33510B RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT 33510B,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,"[OrderedDict([('id', 'attzNqAqcbJaKQQP3'), ('width', 1324), ('height', 547), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/a5HuvMK9eZZGMgayEeIzaw/EviNea1Mbe4jjMOZBeHAWZc_eifmq5-R2wEOncc9-pYQFbcHOQh9g9dfz42VIrWHtwx4WtLCu3_p2mjM5VGx197ZmQBZZYtRqbaI6EgMnYI/X_fQ_O9HRLEbjDHj_G_IodX26a4s05iwyyZv-nQHa0s'), ('filename', 'Keysight-33510B-1.jpg'), ('size', 96828), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CNZnxvnvmJWdSXz66-RKQA/cWtY6zcvPGBvc9FXM6Nhu3QTXECDgUS-VH9xQUnPiBXZJlgd8xgySyAso0bwNSmij9m4saf7YrmWemrnTB8rQQ/47lJzgXY4EfQbI5on6BCT0ziX1cybF-MWPL4GjRPHIM'), ('width', 87), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2sNYGpFZfoSsg7gS7QmE-g/dC0J-pHx0fU-NVqXxNttfTqn_Ziy35dXsafBwq9_pRIcPjJJMWC4ordcwr-KuL2JnmJVdANbORtxx-bz5bU99g/u36gDsNaJBF3O2Sh1lsz-amZUiUEKoMUjyimzniOt84'), ('width', 1239), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oO1FVA_-kHBNsVQtVxyX5g/BRZnOhzfxbl26rveBZiv5_z_mGNRs_9Osgi_zJFmGegqp5ICDDJYqLWvAMvGFP0_4U8ysQxt1IrTYPJn2649TQ/AMfSHl6iPAYXt2wD9K-q3mgFax49ax7TP3NGb-qUGuk'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/33510B/waveform-generator-20-mhz-2-channel.html#:~:text=The%2033510B%20waveform%20generator%20provides,for%20your%20most%20demanding%20measurements.",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_33510b.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33xxxOutputChannel,4503.0,,,,"from .KeysightAgilent_33XXX import WaveformGenerator_33XXX


class Keysight33510B(WaveformGenerator_33XXX):
    """"""
    QCoDeS driver for the Keysight 33510B waveform generator.
    """"""
"
174,2500.0,"Munich, Germany",The R&S ZNB20 from R&S is a mid range vector network analyzer with two or four test ports for the frequency range from 100 kHz to 20 GHz. It has a dynamic range of 135 dB which makes it possible to perform precise measurements on wideband DUTs or components whose behavior at low frequencies is especially important. The analyzer has a large 12.1 inches touch screen interface which makes it easy to control and review test results. The ports on the R&S 20 have 2.92 mm Male connectors.,Rohde Schwarz ZNB 20,463.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a R&S ZNB20 Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.",R&S ZNB20,https://www.testequipmenthq.com/datasheets/Rohde-Schwarz-ZNB20-Datasheet.pdf,"[OrderedDict([('id', 'attZlJBeZpD31RwIP'), ('width', 1500), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V07TAdbMpYBS-aeRUkqO_Q/gKBlPtYASUZscXFUVPDV2UWqpCFGN-veuh-qFckcA3_euOyOCFlbB5n-kWxPABdFrK8YpcgmcEOdTfLm2N3EAqz9rm8CrisI6z7mOOB-qapmEc-vLhsBwAS22sUM9tmP/VJtXUEVhijbrpZhr_M19s_zHW1O8EkNC9-oEVI4P2AE'), ('filename', 'Rohde-and-Schwarz-ZNB.webp'), ('size', 117048), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2B04Q1vL_3FyVEPwZr4IWA/ypgAPTyueDSavDOCCLQEfKP3GYQQKoIx7ZdAyNmbWygX2izDvJnj3F9HsZS7N4kaVoRIrNfki4NHQi_nDV0N07_3ZeX3b2nsFtLDejooAjA/DcPr17-I7jIyRZ5fVWmQEgf3SG1mviFsVlWB3BW_iPQ'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/St-4806b53N_iW5dgF5r5A/s35kDxmzwxjUX0IZjHO7B-Y2XIGBZGrYUMHXuy9fBu2hNL55-VKFsnUd4yOSRU0VCutTY6vOhpXW1vqKDqRoaUvtAI2A1ll0yj4woXic9Mk/xVWObL6fnhusCsQ2tHYweBZ_ilz4SGYxvseIIh9oENE'), ('width', 960), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/8L3Md1ZJeHtnGVcnlCrDbw/A2SQmT7-M4uB7U7aGVAEq6izmY3AUtFMIUTkxvPmdklAHlOmbl65xB6ZMW58dAuTMDf_79zOEmrrUvFxYCaIcve7KppHQQ6piNNZxNgfrDE/uVBICU7kaIBNHrM-GKTph3batbd0rywagDzWuBQuExQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.everythingrf.com/products/vector-network-analyzers/rohde-schwarz/565-92-r-s-znb20,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/ZNB20.py,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNB20,,,,,"# Ensuring backwards compatibility

from .ZNB import ZNB

ZNB20 = ZNB
"
178,5420.0,USA,"The 33250A 80 MHz Function/Arbitrary Waveform Generator uses direct digital-synthesis techniques to create a stable, accurate output on all waveforms, down to 1 µHz frequency resolution. The benefits are apparent in every signal you produce, from the sine wave frequency accuracy to the fast rise/fall times of square waves, to the ramp linearity.

",Keysight 33250 A,295.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33250A RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT 33250A,https://www.keysight.com/us/en/assets/7018-06693/data-sheets/5968-8807.pdf,"[OrderedDict([('id', 'attLbrKQfZkBoUpSk'), ('width', 750), ('height', 407), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/C19pXPkAUQy9Qd3a4j48AQ/bBgwxEdu5cjUFZRTAm6-HlX9DDaDHhxf58dBnvfMtiYfGi1ho0IBtWAkunOgsg3JmY07G0_e88pmqUOp_frHcr_BiSHPTmc2hJpGJ1NMXtpnbp4tUN4Cvu-eTnUAZQh-/nMKHEKoNn_7YNgzlPzqZqrvUnTnfWww-_cOq4TSXAPw'), ('filename', 'Keysight_Agilent_33250A.jpg'), ('size', 85765), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1eT7HPwKOec75qsRVVm6oQ/qozHXvrMSrQjjnqubaa_whzRC5E5REFuvVTKM8hgiPsf9cYG4rX9ptrKxdkczDGN3iwXJwX4R6kzomNf2pj0PQ/tnu-xy1fuYLeLzDCzqvqiFvlgeriLnsRqd4Co0d8qas'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UL8fP765DyO9As3BNVG-A/J2nNZrxtvptVHBkNZaDYHr6zs6VszmSWRKuerHj1AkN6JkxKYXGco8xLN3GS29USimtt3_CRm9FfyWKEB8QR1g/zlGC1yxcmTBPDuvewQMzarMt-jY0zCBMrEdImwRrA4g'), ('width', 750), ('height', 407)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/d1FsaHIRT6iZU2GnrQMCDQ/28Rhq3rFj27WHGGPyNnnffHX_hnmk9aZcC1RbM9uHSxHS2QOh-ZD53QPOtxYGReo2Jni0mSrMvLN6E53EEpCNA/K_s808sBXlUpXxfkfa5shFZ9o8QPOER_VV499ESGjFI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.bellnw.com/products/keysight-33250a,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_33250a.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33250A,,,True,,"from .KeysightAgilent_33XXX import WaveformGenerator_33XXX


class Keysight33250A(WaveformGenerator_33XXX):
    """"""
    QCoDeS driver for the Keysight 33250A waveform generator.
    """"""
"
182,110.6,"Cleveland, Ohio, United States","The 2611B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",Keithley 2611 B,248.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2611B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2611B,https://download.tek.com/manual/SPEC-2612B_B_Feb_2014.pdf,"[OrderedDict([('id', 'attcOxZWqsZHSMQ24'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ifB6WzFf1qauwy4GMLrdoQ/Q9FjgESwcj28ITG_EUg1EnB97-fET8ShglIzHhHtnNCrILvarvJlfhwbnylMMNbCG3FsDeywXLEti85RD1kIGs7yrhmBNN_fsN0zYvC-ERw/ASIX3vfyTGCnmVL5rDXgk5BXbNEczMNuM6IAdq57Tu4'), ('filename', '2611b.webp'), ('size', 5900), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Qk87H7SiWmcsffUK1FrLAg/67dKlzZgkhuFp-0WSGyvUES_pNKDeeNQUDtzcAqkV3Zvc7-DHDMwgOacFzrvHl6RESMp8T_57fUnw91L8dgsO3cnVYUHAXY8CAfcEa42N6Q/vwSolNceJMvJznrSr74MDMpBC20byvl_Wr8TI0lgwHA'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Jlc8JeKySsuu5SpOoxNZ6Q/iWpc9a8iIYDvRvTKF1E9FZwlXlQZO75LW73GsQCJRAOCM3G-s2eAb4UUnqHGJmY67Uy-xnFoSXxF9tsU6vogmvWhROU2dRef0Q1bUy3a0qY/zLQpfNLxDo5K8Ih3I_9C5tXtKggUvxHrmYJiz-SUBUU'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iP5_1UofJA3fur8uhgOpFA/nzk9iW28susfIfRZkWaxeSdZGuDzrt_p1pPlKAC0UfuczX-l8IR4Hv9KUNYAuf8ajn7LXcGaHdEDBUSSbhMp6UXbfMiNXCzFbR3mLgZYbgo/LXoLnJJ3MDPmnBO-Zs2tiRwtCaovr4iftM6z817NFpM'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2611b/source-meter-voltage-current-30/dp/44W8036,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2611B,13260.6,,,,
187,367.3,"Abingdon, United Kingdom",,Mercuryips Visa,397.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Qcodes,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,,,,,,
194,25.0,USA,"The SG380 Series RF Signal Generators use a unique, innovative architecture (Rational Approximation Frequency Synthesis) to deliver ultra-high frequency resolution (1 µHz), excellent phase noise, and versatile modulation capabilities (AM, FM, ØM, pulse modulation and sweeps) at a fraction of the cost of competing designs. The standard models produce sine waves from DC to 2.025 GHz (SG382), 4.05 GHz (SG384) and 6.075 GHz (SG386).",SG 384,535.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",,https://www.thinksrs.com/downloads/pdfs/catalog/SG380c.pdf,"[OrderedDict([('id', 'attzGZUu5AMOTH1Yg'), ('width', 2916), ('height', 2136), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IJqNqzNItLGRoNXqt9fAiQ/bRA-dnkTQcbgzVkkHFINhViceUd3--_GlQB1gYtQskXnEN4fBmaRhTdd_QENt_TJdjhZLFlYkmyOb_z-fTub2OG96KRnA5VQmAiDipmT7jQ/Gu8wmH6FICdtLBgi02OKoQTR3qftOoo20kSheMXgfX0'), ('filename', 'SG382 ReflectR (1).jpg'), ('size', 1271602), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Rq0Ensp_LAxlSPzzzQO4Kw/VIys_nTel_pzoi9sqpD7CjepdlmOLZxZWmncv48w9_Oh2E7L7zqpWR2X1jmO5RMpLjBPlyrDzXjI8VaUcaEoJg/VTj8uLvkSh2XhK9b-5-6Y3zarzqww2KktgzNBa34qYk'), ('width', 49), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ls_uJNz56E3xyvN8P3yYxg/kNlSh_1UcNxAlPuJgKJIWJ5hkbmjOYznY6fsxBN0A1RYa5DJZUnSKWTLxiPQe4zgmondf-G2glEgAfRZWv2nnQ/EWfOiWu8-XLKtGq9JqQENTP0up0MnwN9JzZe4GwQGtA'), ('width', 699), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M4Jjrz14Z8ZZE6gWAce9pA/KYDVkgGLV6SAdKUoxi_FMeo5FRteli3wJ5I9UVn5rSYij39bCSGz4FP6gN-PdXe-VyLToOfx8MK561TOcN_AVQ/yMG9cOOpgONTuxzRM22c8iRtZvG_r0La9fvGLMbzLqE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sg380.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SG384.py,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SG384,3900.0,,,,"from typing import Any

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument


class SG384(VisaInstrument):
    """"""
    QCoDeS driver for the Stanford Research Systems SG384 RF Signal Generator.

    Status: beta version
    Includes the essential commands from the manual
    """"""
    def __init__(self, name: str, address: str,
                 reset: bool = False, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)
    # signal synthesis commands
        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='FREQ?',
                           set_cmd='FREQ {:.3f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=9.5e5,
                                             max_value=4.05e9))
        self.add_parameter(name='phase',
                           label='Carrier phase',
                           unit='deg',
                           get_cmd='PHAS?',
                           set_cmd='PHAS {:.1f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-360, max_value=360))
        self.add_parameter(name='amplitude_LF',
                           label='Power of BNC output',
                           unit='dBm',
                           get_cmd='AMPL?',
                           set_cmd='AMPL {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-47, max_value=13))
        self.add_parameter(name='amplitude_RF',
                           label='Power of type-N RF output',
                           unit='dBm',
                           get_cmd='AMPR?',
                           set_cmd='AMPR {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-110, max_value=16.5))
        self.add_parameter(name='amplitude_HF',
                           label='Power of RF doubler output',
                           unit='dBm',
                           get_cmd='AMPH?',
                           set_cmd='AMPH {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-10, max_value=13))
        self.add_parameter(name='amplitude_clock',
                           label='Rear clock output',
                           unit='Vpp',
                           get_cmd='AMPC?',
                           set_cmd='AMPC {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=0.4, max_value=1.00))
        self.add_parameter(name='noise_mode',
                           label='RF PLL loop filter mode',
                           get_cmd='NOIS?',
                           set_cmd='NOIS {}',
                           val_mapping={'Mode 1': 0,
                                        'Mode 2': 1})
        self.add_parameter(name='enable_RF',
                           label='Type-N RF output',
                           get_cmd='ENBR?',
                           set_cmd='ENBR {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_LF',
                           label='BNC output',
                           get_cmd='ENBL?',
                           set_cmd='ENBL {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_HF',
                           label='RF doubler output',
                           get_cmd='ENBH?',
                           set_cmd='ENBH {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='enable_clock',
                           label='Rear clock output',
                           get_cmd='ENBC?',
                           set_cmd='ENBC {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='offset_clock',
                           label='Rear clock offset voltage',
                           unit='V',
                           get_cmd='OFSC?',
                           set_cmd='OFSC {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-2, max_value=2))
        self.add_parameter(name='offset_rearDC',
                           label='Rear DC offset voltage',
                           unit='V',
                           get_cmd='OFSD?',
                           set_cmd='OFSD {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-10, max_value=10))
        self.add_parameter(name='offset_bnc',
                           label='Low frequency BNC output',
                           unit='V',
                           get_cmd='OFSL?',
                           set_cmd='OFSL {}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=-1.5, max_value=1.5))
    # Modulation commands
        self.add_parameter(name='modulation_coupling',
                           label='External modulation input coupling',
                           get_cmd='COUP?',
                           set_cmd='COUP {}',
                           val_mapping={'AC': 0,
                                        'DC': 1})
        self.add_parameter(name='FM_deviation',
                           label='Frequency modulation deviation',
                           unit='Hz',
                           get_cmd='FDEV?',
                           set_cmd='FDEV {:.1f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=0.1, max_value=32e6))
        self.add_parameter(name='modulation_function',
                           label='Modulation function for AM/FM/PhiM',
                           get_cmd='MFNC?',
                           set_cmd='MFNC {}',
                           val_mapping={'Sine': 0,
                                        'Ramp': 1,
                                        'Triangle': 2,
                                        'Square': 3,
                                        'Noise': 4,
                                        'External': 5})
        self.add_parameter(name='enable_modulation',
                           get_cmd='MODL?',
                           set_cmd='MODL {}',
                           val_mapping={'OFF': 0,
                                        'ON': 1})
        self.add_parameter(name='modulation_rate',
                           get_cmd='RATE?',
                           set_cmd='RATE {:.6f}',
                           get_parser=float,
                           vals=vals.Numbers(min_value=1e-6, max_value=50e3))
        self.add_parameter(name='modulation_type',
                           label='Current modulation type',
                           get_cmd='TYPE?',
                           set_cmd='TYPE {}',
                           val_mapping={'AM': 0,
                                        'FM': 1,
                                        'Phi': 2,
                                        'Sweep': 3,
                                        'Pulse': 4,
                                        'Blank': 5,
                                        'IQ': 6})
        self.connect_message()


class SRS_SG384(SG384):
    """"""
    Deprecated alternative name for backwards compatibility
    """"""

    pass
"
195,5420.0,USA,"Keysight 33500B Series waveform generators with exclusive Trueform signal generation technology offer more capability, fidelity, and flexibility than previous generation DDS generators. Easily generate the full range of signals you need to your devices with confidence the signal generator is outputting the signals you expect.


",Keysight 33522 B,300.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33522B RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT 33522B,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,"[OrderedDict([('id', 'attmm8viACrl42SmY'), ('width', 1200), ('height', 1024), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nJGPKMB0vav9Rbm1m2fHbQ/xwYHkn5TJxSSsv5rcc2GB36bP-L4DeGDf3EfMiSxm7gclNhXATPTPLdAuNUvRZbAlP6i6GPe8E2Mv9EwQ0PZapGdStT8M0oymNUp-PvN_L8/tSgkGLolcmATtF2G5GJtJgbJChkQuZUXYCT9xzznWxI'), ('filename', '0001724_AT_33522B.jpg'), ('size', 200919), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/req27zy6yNUWPHDcTZzbhw/ZIaIYbhvEPBJuLlr-E6AYJQghqP0q9rnQcwkIhaICiPqQ7BXlP6XdNB8vHnu_R7UYfDVE34PKHnU0AkacyIWYw/f_sy0PNm8zIeg4p6ORBtXv3KnWwg4Om48y3U_K-bMK8'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/coiAq9BckISyl6OnLDsBYQ/kLsYV-FRgPHWbxtlDhqaO_Hu-4FnfnJztxC52DN_dAaZVFy3EiaslxzVHHCkD3OSoN03eU7ymFXB4RlbDp6KWA/DkSrD0XSiR-O4SBPuBFq6mVciwdCHSBRZlRr7Qk7AWk'), ('width', 600), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xyFGGw8xyIUeYPCxQDUcdw/qzCskxy4DnCf6BagMFnf8dfeFQED4na54HmiZSeylbbSziC-93QsZ_ipDTeIkt_rnQcyatlPgq3CbOJwm9m7tA/feCwtBQ1J-lgAfNj8tSlrlnryhBxLDy7qviWl-Lx1Ls'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/33522B/waveform-generator-30-mhz-2-channel-arb.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_33522b.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33522B,4607.0,,,,"from .KeysightAgilent_33XXX import WaveformGenerator_33XXX


class Keysight33522B(WaveformGenerator_33XXX):
    """"""
    QCoDeS driver for the Keysight 33522B waveform generator.
    """"""
"
196,5800.0,USA,"The AWG70000B Series Arbitrary Waveform Generator represents the cutting edge in sample rate, signal fidelity and waveform memory, making it ideal for design, testing and operations of complex components, systems and experiments. With up to sample rate of 50 GS/s and 10-bit vertical resolution, it delivers the industry's best signal stimulus solution for easy generation of ideal, distorted and “real-life” signals.",Tektronix 70001 B,558.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG70001B RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG70001B,,,https://www.tek.com/en/products/arbitrary-waveform-generators/awg70000,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001B,122000.0,,,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
200,5420.0,USA,,Keysight B 220 X,337.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a (X --> Series) ,,,,(X --> Series),,,,,,,,,,
201,110.6,"Cleveland, Ohio, United States","The 2450 is Keithley's next-generation SourceMeter source measure unit (SMU) instrument that truly brings Ohm's law (current, voltage, and resistance) testing right to your fingertips. Its innovative graphical user interface (GUI) and advanced, capacitive touchscreen technology allow intuitive usage and minimize the learning curve to enable engineers and scientists to learn faster, work smarter, and invent easier. The 2450 is the SMU for everyone: a versatile instrument, particularly well-suited for characterizing modern scaled semiconductors, nano-scale devices and materials, organic semiconductors, printed electronics, and other small-geometry and low-power devices.",Keithley 2450,243.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2450 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2450,https://www.testequipmenthq.com/datasheets/KEITHLEY-2450-Datasheet.pdf,"[OrderedDict([('id', 'attYj3DDSYAvCGgTQ'), ('width', 589), ('height', 319), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zcMA96mtJXYCOkb6kupHvQ/1ps5TsoRXCKsgqMySssYHoFSmhIRx4aO-XnriClXx2hps3be9sz0iHDjxaiFc2bdN99oaalDnhvz83JRJ2LXAg/J1L5e2oVFP6WmjIXtPMyOo7kKZDtigkNccvN0QWJA34'), ('filename', '2450.png'), ('size', 194295), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ESnqh5TwnjrQtEeabYPoKQ/gk-ujrmURPBE0ke1R-mZFeYnploc5mrcLGXwHxpcXfGfOItUvhXTJ1KRqyYJLMLNoSMzDToglmnmEQjpZsdwTg/qTqGV6hlOyYZ6j4G7XL77nIdu-oeP4zuKe9dbycKwEs'), ('width', 66), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Y0IFHnD1gpxXWlPcN-aBbQ/RlwATNebPwv7UNuAkR02xj2TEzcSh2Ye-f3e9d3lzb121zFJXuYOGNpgR-1F3aCyWbF7GgrgiOPmwozG206Egg/EBNyEc-Z__pKX6YJcEGkA5oqXfg9V0_TPk-5cMCIkb4'), ('width', 589), ('height', 319)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/V2pJhiB2HJsrbTpZR7Dp7A/T_kRNu7Kg6c6wkrPBNFQGCjoxUfansX8IVfb2CJkIAHvd4S9I2WVDht-qUlbycmblE2XD4ztWCmchWmJeTZ5QQ/Kx6THN0HbSzRC4X-fUuyOxlQhk-jZ_QK51SSOiIvs40'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/smu-2400-graphical-sourcemeter/model-2450-touchscreen-source-measure-unit-smu-instrument,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2450.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2450,9549.3,,,,"from types import TracebackType
from typing import Any, Optional, Union, cast

import numpy as np
from typing_extensions import TypedDict

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ParameterWithSetpoints,
    create_on_off_val_mapping,
    invert_val_mapping,
)
from qcodes.validators import Arrays, Enum, Ints, Lists, Numbers


class _SweepDict(TypedDict):
    start: float
    stop: float
    step_count: int
    delay: float
    sweep_count: int
    range_mode: str
    fail_abort: str
    dual: str
    buffer_name: str


class ParameterWithSetpointsCustomized(ParameterWithSetpoints):
    """"""
    While the parent class ParameterWithSetpoints only support numerical data
    (in the format of ""Arrays""), the newly added ""_user_selected_data"" will
    include extra fields which may contain string type, in addition to the
    numerical values, which can be obtained by the get_cmd of the parent class.

    This customized class is used for the ""sweep"" parameter.
    """"""

    _user_selected_data: Optional[list[Any]] = None

    def get_selected(self) -> Optional[list[Any]]:
        return self._user_selected_data


class Keithley2450Buffer(InstrumentChannel):
    """"""
    Treat the reading buffer as a submodule, similar to Sense and Source
    """"""

    default_buffer = {""defbuffer1"", ""defbuffer2""}

    buffer_elements = {
        ""date"": ""DATE"",
        ""measurement_formatted"": ""FORMatted"",
        ""fractional_seconds"": ""FRACtional"",
        ""measurement"": ""READing"",
        ""relative_time"": ""RELative"",
        ""seconds"": ""SEConds"",
        ""source_value"": ""SOURce"",
        ""source_value_formatted"": ""SOURFORMatted"",
        ""source_value_status"": ""SOURSTATus"",
        ""source_value_unit"": ""SOURUNIT"",
        ""measurement_status"": ""STATus"",
        ""time"": ""TIME"",
        ""timestamp"": ""TSTamp"",
        ""measurement_unit"": ""UNIT"",
    }

    inverted_buffer_elements = invert_val_mapping(buffer_elements)

    def __init__(
        self,
        parent: ""Keithley2450"",
        name: str,
        size: Optional[int] = None,
        style: str = """",
    ) -> None:
        super().__init__(parent, name)
        self.buffer_name = name
        self._size = size
        self.style = style

        if self.buffer_name not in self.default_buffer:
            # when making a new buffer, the ""size"" parameter is required.
            if size is None:
                raise TypeError(
                    ""buffer() missing 1 required positional argument: 'size'""
                )
            self.write(f"":TRACe:MAKE '{self.buffer_name}', {self._size}, {self.style}"")
        else:
            # when referring to default buffer, ""size"" parameter is not needed.
            if size is not None:
                self.log.warning(
                    f""Please use method 'size()' to resize default buffer ""
                    f""{self.buffer_name} size to {self._size}.""
                )

        self.add_parameter(
            ""size"",
            get_cmd=f"":TRACe:POINts? '{self.buffer_name}'"",
            set_cmd=f"":TRACe:POINts {{}}, '{self.buffer_name}'"",
            get_parser=int,
            docstring=""The number of readings a buffer can store."",
        )

        self.add_parameter(
            ""number_of_readings"",
            get_cmd=f"":TRACe:ACTual? '{self.buffer_name}'"",
            get_parser=int,
            docstring=""To get the number of readings in the reading buffer."",
        )

        self.add_parameter(
            ""elements"",
            get_cmd=None,
            get_parser=self.from_scpi_to_name,
            set_cmd=None,
            set_parser=self.from_name_to_scpi,
            vals=Lists(Enum(*list(self.buffer_elements.keys()))),
            docstring=""List of buffer elements to read."",
        )

    def from_name_to_scpi(self, element_names: list[str]) -> list[str]:
        return [self.buffer_elements[element] for element in element_names]

    def from_scpi_to_name(self, element_scpis: list[str]) -> list[str]:
        if element_scpis is None:
            return []
        return [self.inverted_buffer_elements[element] for element in element_scpis]

    def __enter__(self) -> ""Keithley2450Buffer"":
        return self

    def __exit__(
        self,
        exception_type: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None:
        self.delete()

    @property
    def available_elements(self) -> set[str]:
        return set(self.buffer_elements.keys())

    def get_last_reading(self) -> str:
        """"""
        This method requests the latest reading from a reading buffer.

        """"""
        if not self.elements():
            return self.ask(f"":FETCh? '{self.buffer_name}'"")
        fetch_elements = [self.buffer_elements[element] for element in self.elements()]
        return self.ask(f"":FETCh? '{self.buffer_name}', {','.join(fetch_elements)}"")

    def get_data(
        self, start_idx: int, end_idx: int, readings_only: bool = False
    ) -> list[Any]:
        """"""
        This command returns specified data elements from reading buffer.

        Args:
            start_idx: beginning index of the buffer to return
            end_idx: ending index of the buffer to return
            readings_only: a flag to temporarily disable the elements and
                output only the numerical readings

        Returns:
            data elements from the reading buffer

        """"""
        if (not self.elements()) or readings_only:
            raw_data = self.ask(
                f"":TRACe:DATA? {start_idx}, {end_idx}, "" f""'{self.buffer_name}'""
            )
            return [float(i) for i in raw_data.split("","")]
        elements = [self.buffer_elements[element] for element in self.elements()]
        raw_data_with_extra = self.ask(
            f"":TRACe:DATA? {start_idx}, ""
            f""{end_idx}, ""
            f""'{self.buffer_name}', ""
            f""{','.join(elements)}""
        )
        return raw_data_with_extra.split("","")

    def clear_buffer(self) -> None:
        """"""
        Clear the data in the buffer
        """"""
        self.write(f"":TRACe:CLEar '{self.buffer_name}'"")

    def trigger_start(self) -> None:
        """"""
        This method makes readings using the active measure function and
        stores them in a reading buffer.
        """"""
        self.write(f"":TRACe:TRIGger '{self.buffer_name}'"")

    def delete(self) -> None:
        if self.buffer_name not in self.default_buffer:
            self.parent.submodules.pop(f""_buffer_{self.buffer_name}"")
            self.parent.buffer_name(""defbuffer1"")
            self.write(f"":TRACe:DELete '{self.buffer_name}'"")


class Keithley2450Sense(InstrumentChannel):
    """"""
    The sense module of the Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of either ""current"", ""voltage""
            or ""resistance"". All parameters and methods in this submodule
            should only be accessible to the user if
            self.parent.sense_function.get() == self._proper_function. We
            ensure this through the 'sense' property on the main driver class
            which returns the proper submodule for any given function mode
    """"""

    function_modes = {
        ""current"": {""name"": '""CURR:DC""', ""unit"": ""A"", ""range_vals"": Numbers(10e-9, 1)},
        ""resistance"": {
            ""name"": '""RES""',
            ""unit"": ""Ohm"",
            ""range_vals"": Numbers(20, 200e6),
        },
        ""voltage"": {""name"": '""VOLT:DC""', ""unit"": ""V"", ""range_vals"": Numbers(0.02, 200)},
    }

    def __init__(self, parent: ""Keithley2450"", name: str, proper_function: str) -> None:
        super().__init__(parent, name)
        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.sense_function

        self.add_parameter(
            ""four_wire_measurement"",
            set_cmd=f"":SENSe:{self._proper_function}:RSENse {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RSENse?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""range"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe?"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""auto_range"",
            set_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO {{}}"",
            get_cmd=f"":SENSe:{self._proper_function}:RANGe:AUTO?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            self._proper_function,
            get_cmd=self._measure,
            get_parser=float,
            unit=unit,
            snapshot_value=False,
        )

        self.add_parameter(
            ""sweep"",
            label=self._proper_function,
            get_cmd=self._measure_sweep,
            unit=unit,
            vals=Arrays(shape=(self.parent.npts,)),
            parameter_class=ParameterWithSetpointsCustomized,
        )

        self.add_parameter(
            ""nplc"",
            get_cmd=f"":SENSe:{self._proper_function}:NPLCycles?"",
            set_cmd=f"":SENSe:{self._proper_function}:NPLCycles {{}}"",
            vals=Numbers(0.001, 10),
        )

        self.add_parameter(""user_number"", get_cmd=None, set_cmd=None, vals=Ints(1, 5))

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            get_parser=float,
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(
            ""auto_zero_enabled"",
            get_cmd=f"":SENSe:{self._proper_function}:AZERo?"",
            set_cmd=f"":SENSe:{self._proper_function}:AZERo {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""This command enables or disables automatic updates to""
            ""the internal reference measurements (autozero) of the""
            ""instrument."",
        )

        self.add_parameter(
            ""count"",
            get_cmd="":SENSe:COUNt?"",
            set_cmd="":SENSe:COUNt {}"",
            docstring=""The number of measurements to make when a measurement ""
            ""is requested."",
        )

    def _measure(self) -> Union[float, str]:
        if not self.parent.output_enabled():
            raise RuntimeError(""Output needs to be on for a measurement"")
        buffer_name = self.parent.buffer_name()
        return float(self.ask(f"":MEASure? '{buffer_name}'""))

    def _measure_sweep(self) -> np.ndarray:

        source = cast(Keithley2450Source, self.parent.source)
        source.sweep_start()
        buffer_name = self.parent.buffer_name()
        buffer = cast(
            Keithley2450Buffer, self.parent.submodules[f""_buffer_{buffer_name}""]
        )
        end_idx = self.parent.npts()
        raw_data = buffer.get_data(1, end_idx, readings_only=True)
        raw_data_with_extra = buffer.get_data(1, end_idx)
        self.parent.sense.sweep._user_selected_data = raw_data_with_extra
        # Clear the trace so we can be assured that a subsequent measurement
        # will not be contaminated with data from this run.
        buffer.clear_buffer()
        return np.array([float(i) for i in raw_data])

    def auto_zero_once(self) -> None:
        """"""
        This command causes the instrument to refresh the reference and zero
        measurements once.
        """"""
        self.write("":SENSe:AZERo:ONCE"")

    def clear_trace(self, buffer_name: str = ""defbuffer1"") -> None:
        """"""
        Clear the data buffer
        """"""
        self.write(f"":TRACe:CLEar '{buffer_name}'"")

    def _get_user_delay(self) -> str:
        get_cmd = f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return self.ask(get_cmd)

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SENSe:{self._proper_function}:DELay:USER"" f""{self.user_number()} {value}""
        )
        self.write(set_cmd)


class Keithley2450Source(InstrumentChannel):
    """"""
    The source module of the Keithley 2450 SMU.

    Args:
        parent
        name
        proper_function: This can be one of either ""current"" or ""voltage""
            All parameters and methods in this submodule should only be
            accessible to the user if
            self.parent.source_function.get() == self._proper_function. We
            ensure this through the 'source' property on the main driver class
            which returns the proper submodule for any given function mode
    """"""

    function_modes = {
        ""current"": {""name"": ""CURR"", ""unit"": ""A"", ""range_vals"": Numbers(-1, 1)},
        ""voltage"": {""name"": ""VOLT"", ""unit"": ""V"", ""range_vals"": Numbers(-200, 200)},
    }

    def __init__(self, parent: ""Keithley2450"", name: str, proper_function: str) -> None:
        super().__init__(parent, name)
        self._proper_function = proper_function
        range_vals = self.function_modes[self._proper_function][""range_vals""]
        unit = self.function_modes[self._proper_function][""unit""]

        self.function = self.parent.source_function
        self._sweep_arguments: Optional[_SweepDict] = None

        self.add_parameter(
            ""range"",
            set_cmd=f"":SOUR:{self._proper_function}:RANGe {{}}"",
            get_cmd=f"":SOUR:{self._proper_function}:RANGe?"",
            vals=range_vals,
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""auto_range"",
            set_cmd=f"":SOURce:{self._proper_function}:RANGe:AUTO {{}}"",
            get_cmd=f"":SOURce:{self._proper_function}:RANGe:AUTO?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        limit_cmd = {""current"": ""VLIM"", ""voltage"": ""ILIM""}[self._proper_function]
        self.add_parameter(
            ""limit"",
            set_cmd=f""SOUR:{self._proper_function}:{limit_cmd} {{}}"",
            get_cmd=f""SOUR:{self._proper_function}:{limit_cmd}?"",
            get_parser=float,
            unit=unit,
        )

        self.add_parameter(
            ""limit_tripped"",
            get_cmd=f"":SOUR:{self._proper_function}:{limit_cmd}:TRIPped?"",
            val_mapping={True: 1, False: 0},
        )

        self.add_parameter(
            self._proper_function,
            set_cmd=f""SOUR:{self._proper_function} {{}}"",
            get_cmd=f""SOUR:{self._proper_function}?"",
            get_parser=float,
            unit=unit,
            snapshot_value=False,
        )

        self.add_parameter(
            ""sweep_axis"",
            label=self._proper_function,
            get_cmd=self.get_sweep_axis,
            vals=Arrays(shape=(self.parent.npts,)),
            unit=unit,
        )

        self.add_parameter(
            ""delay"",
            get_cmd=f"":SOURce:{self._proper_function}:DELay?"",
            set_cmd=f"":SOURce:{self._proper_function}:DELay {{}}"",
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(""user_number"", get_cmd=None, set_cmd=None, vals=Ints(1, 5))

        self.add_parameter(
            ""user_delay"",
            get_cmd=self._get_user_delay,
            set_cmd=self._set_user_delay,
            vals=Numbers(0, 1e4),
        )

        self.add_parameter(
            ""auto_delay"",
            get_cmd=f"":SOURce:{self._proper_function}:DELay:AUTO?"",
            set_cmd=f"":SOURce:{self._proper_function}:DELay:AUTO {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""read_back_enabled"",
            get_cmd=f"":SOURce:{self._proper_function}:READ:BACK?"",
            set_cmd=f"":SOURce:{self._proper_function}:READ:BACK {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""This command determines if the instrument records the ""
            ""measured source value or the configured source value ""
            ""when making a measurement."",
        )

    def get_sweep_axis(self) -> np.ndarray:
        if self._sweep_arguments is None:
            raise ValueError(
                ""Please setup the sweep before getting values of this parameter""
            )
        return np.linspace(
            start=self._sweep_arguments[""start""],
            stop=self._sweep_arguments[""stop""],
            num=int(self._sweep_arguments[""step_count""]),
        )

    def sweep_setup(
        self,
        start: float,
        stop: float,
        step_count: int,
        delay: float = 0,
        sweep_count: int = 1,
        range_mode: str = ""AUTO"",
        fail_abort: str = ""ON"",
        dual: str = ""OFF"",
        buffer_name: str = ""defbuffer1"",
    ) -> None:

        self._sweep_arguments = _SweepDict(
            start=start,
            stop=stop,
            step_count=step_count,
            delay=delay,
            sweep_count=sweep_count,
            range_mode=range_mode,
            fail_abort=fail_abort,
            dual=dual,
            buffer_name=buffer_name,
        )

    def sweep_start(self) -> None:
        """"""
        Start a sweep and return when the sweep has finished.
        Note: This call is blocking
        """"""
        if self._sweep_arguments is None:
            raise ValueError(""Please call `sweep_setup` before starting a sweep."")
        cmd_args = dict(self._sweep_arguments)
        cmd_args[""function""] = self._proper_function

        cmd = (
            "":SOURce:SWEep:{function}:LINear {start},{stop},""
            ""{step_count},{delay},{sweep_count},{range_mode},""
            ""{fail_abort},{dual},'{buffer_name}'"".format(**cmd_args)
        )

        self.write(cmd)
        self.write("":INITiate"")
        self.write(""*WAI"")

    def sweep_reset(self) -> None:
        self._sweep_arguments = None

    def _get_user_delay(self) -> float:
        get_cmd = f"":SOURce:{self._proper_function}:DELay:USER"" f""{self.user_number()}?""
        return float(self.ask(get_cmd))

    def _set_user_delay(self, value: float) -> None:
        set_cmd = (
            f"":SOURce:{self._proper_function}:DELay:USER""
            f""{self.user_number()} {value}""
        )
        self.write(set_cmd)


class Keithley2450(VisaInstrument):
    """"""
    The QCoDeS driver for the Keithley 2450 SMU
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        if not self._has_correct_language_mode():
            self.log.warning(
                ""The instrument is in an unsupported language mode. ""
                ""Please run `instrument.set_correct_language()` and try to ""
                ""initialize the driver again after an instrument power cycle. ""
                ""No parameters/sub modules will be available on this driver ""
                ""instance""
            )
            return

        self.add_parameter(
            ""source_function"",
            set_cmd=self._set_source_function,
            get_cmd="":SOUR:FUNC?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley2450Source.function_modes.items()
            },
        )

        self.add_parameter(
            ""sense_function"",
            set_cmd=self._set_sense_function,
            get_cmd="":SENS:FUNC?"",
            val_mapping={
                key: value[""name""]
                for key, value in Keithley2450Sense.function_modes.items()
            },
        )

        self.add_parameter(
            ""terminals"",
            set_cmd=""ROUTe:TERMinals {}"",
            get_cmd=""ROUTe:TERMinals?"",
            vals=Enum(""rear"", ""front""),
        )

        self.add_parameter(
            ""output_enabled"",
            initial_value=""0"",
            set_cmd="":OUTP {}"",
            get_cmd="":OUTP?"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
        )

        self.add_parameter(
            ""line_frequency"",
            get_cmd="":SYSTem:LFRequency?"",
            unit=""Hz"",
            docstring=""returns the power line frequency setting that is used ""
            ""for NPLC calculations"",
        )

        self.add_parameter(
            ""buffer_name"",
            get_cmd=None,
            set_cmd=None,
            docstring=""name of the reading buffer in using"",
        )

        # Make a source module for every source function ('current' and 'voltage')
        for proper_source_function in Keithley2450Source.function_modes:
            self.add_submodule(
                f""_source_{proper_source_function}"",
                Keithley2450Source(self, ""source"", proper_source_function),
            )

        # Make a sense module for every sense function ('current', voltage' and 'resistance')
        for proper_sense_function in Keithley2450Sense.function_modes:
            self.add_submodule(
                f""_sense_{proper_sense_function}"",
                Keithley2450Sense(self, ""sense"", proper_sense_function),
            )

        self.buffer_name(""defbuffer1"")
        self.buffer(name=self.buffer_name())
        self.connect_message()

    def _set_sense_function(self, value: str) -> None:
        """"""
        Change the sense function. The property 'sense' will return the
        sense module appropriate for this function setting.

        We need to ensure that the setpoints of the sweep parameter in the
        active sense module is correctly set. Normally we would do that
        with 'self.sense.sweep.setpoints = (self.source.sweep_axis,)'

        However, we cannot call the property 'self.sense', because that property
        will call `get_latest` on the parameter for which this function
        (that is '_set_sense_function') is the setter
        """"""
        self.write(
            f"":SENS:FUNC {value}"",
        )
        sense_function = self.sense_function.inverse_val_mapping[value]
        sense = self.submodules[f""_sense_{sense_function}""]
        if not isinstance(sense, Keithley2450Sense):
            raise RuntimeError(
                f""Expect Sense Module to be of type ""
                f""Keithley2450Sense got {type(sense)}""
            )
        sense.sweep.setpoints = (self.source.sweep_axis,)

    def _set_source_function(self, value: str) -> None:
        """"""
        Change the source function. The property 'source' will return the
        source module appropriate for this function setting.

        We need to ensure that the setpoints of the sweep parameter in the
        active sense module reflects the change in the source module.
        Normally we would do that with
        'self.sense.sweep.setpoints = (self.source.sweep_axis,)'

        However, we cannot call the property 'self.source', because that property
        will call `get_latest` on the parameter for which this function
        (that is '_set_source_function') is the setter
        """"""

        if self.sense_function() == ""resistance"":
            raise RuntimeError(
                ""Cannot change the source function while sense function is in 'resistance' mode""
            )

        self.write(f"":SOUR:FUNC {value}"")
        source_function = self.source_function.inverse_val_mapping[value]
        source = self.submodules[f""_source_{source_function}""]
        self.sense.sweep.setpoints = (source.sweep_axis,)
        if not isinstance(source, Keithley2450Source):
            raise RuntimeError(
                f""Expect Source Module to be of type ""
                f""Keithley2450Source got {type(source)}""
            )
        # Once the source function has changed,
        # we cannot trust the sweep setup anymore
        source.sweep_reset()

    @property
    def source(self) -> Keithley2450Source:
        """"""
        We have different source modules depending on the source function, which can be
        'current' or 'voltage'

        Return the correct source module based on the source function
        """"""
        source_function = self.source_function.get_latest() or self.source_function()
        submodule = self.submodules[f""_source_{source_function}""]
        return cast(Keithley2450Source, submodule)

    @property
    def sense(self) -> Keithley2450Sense:
        """"""
        We have different sense modules depending on the sense function, which can be
        'current', 'voltage' or 'resistance'

        Return the correct source module based on the sense function
        """"""
        sense_function = self.sense_function.get_latest() or self.sense_function()
        submodule = self.submodules[f""_sense_{sense_function}""]
        return cast(Keithley2450Sense, submodule)

    def buffer(
        self, name: str, size: Optional[int] = None, style: str = """"
    ) -> Keithley2450Buffer:
        self.buffer_name(name)
        if f""_buffer_{name}"" in self.submodules:
            return cast(Keithley2450Buffer, self.submodules[f""_buffer_{name}""])
        new_buffer = Keithley2450Buffer(parent=self, name=name, size=size, style=style)
        self.add_submodule(f""_buffer_{name}"", new_buffer)
        return new_buffer

    def npts(self) -> int:
        """"""
        Get the number of points in the sweep axis
        """"""
        return len(self.source.get_sweep_axis())

    def set_correct_language(self) -> None:
        """"""
        The correct communication protocol is SCPI, make sure this is set
        """"""
        self.write(""*LANG SCPI"")
        self.log.warning(
            ""Please power cycle the instrument to make the change take effect""
        )
        # We want the user to be able to instantiate a driver with the same name
        self.close()

    def _has_correct_language_mode(self) -> bool:
        """"""
        Query if we have the correct language mode
        """"""
        return self.ask(""*LANG?"") == ""SCPI""

    def abort(self) -> None:
        """"""
        This command stops all trigger model commands on the instrument.
        """"""
        self.write("":ABORt"")

    def initiate(self) -> None:
        """"""
        This command starts the trigger model.
        """"""
        self.write("":INITiate"")

    def wait(self) -> None:
        """"""
        This command postpones the execution of subsequent commands until all
        previous overlapped commands are finished.
        """"""
        self.write(""*WAI"")

    def clear_event_register(self) -> None:
        """"""
        This function clears event registers.
        """"""
        self.write("":STATus:CLEar"")

    def clear_event_log(self) -> None:
        """"""
        This command clears the event log.
        """"""
        self.write("":SYSTem:CLEar"")

    def reset(self) -> None:
        """"""
        Returns instrument to default settings, cancels all pending commands.
        """"""
        self.write(""*RST"")
"
203,110.6,"Cleveland, Ohio, United States","The Keithley 2602A SourceMeter is used as either a bench-top I-V characterization tool or as a building block component of multi-channel I-V test systems. For bench-top use, the Keithley 2602A SourceMeter features an embedded TSP® Express Software Tool that allows users to quickly and easily perform common I-V tests without programming or installing software. For system level applications, the Keithley 2602A SourceMeter's Test Script Processor (TSP®) architecture along with new capabilities such as parallel test execution and precision timing provide the highest throughput in the industry to lower the cost of test.",Keithley 2602 A,245.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2602A Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2602A,https://www.testequipmenthq.com/datasheets/KEITHLEY-2602-Datasheet.pdf,"[OrderedDict([('id', 'attxb5H87MVStHqHs'), ('width', 275), ('height', 183), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZE6UL722FhiBLoc1VPssPg/5IW9n0_gCKXqtfryRMlp3CM64kHO9-4qJ1al2X_-pb-jw9Pt8x_Ybj_r2Qskp7Ugth9AjkpzgurSFmGr_LyvWcJXdjjmnjioLeSnjvK9AGk/fX5hN1RMgyk95vUZAk1zfrTF9Dju6TIqDaEcF4tGyOU'), ('filename', 'thd_Keithley_2602A.jpg'), ('size', 36918), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/lbOAE9K7fYkzFacu9w6quw/3bOmPDUqBlBWQEGrtN_kpS3kug3C2zfqw6K9dIGFUALGoyWZZCSAXKxCxN2BOdpNjNuX6Tdk5ZUN4gXulQoJFg/cWkZ1AiYuSd-Gki1cshZ6mHlChyJgxBeiRQTs-O3kC4'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YQ3m5_ZscuZgah3F_9GGcg/zGPczJylYjbe2frM0QPSZb9JpbEBN-CIE5DTXmjwm5R2Hg7gyLe19Jn30kBW65cM5HK8v1RYxMBlBlmkKevQBA/vDa_RfEd85JFWpD2YQuKlmCKS6imV8cGwrYbEGNDx4U'), ('width', 275), ('height', 183)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dXsaOJgNv-vjXPJHt0FX_Q/eTNrpb_AJxbrfwpa3SbUMN2I8MitDDqdiixybt6JuJ2b8xcq43Bq152bGNDpxksnljgfH2v8bpy2bGeNyCsycQ/E8QVyuKxD_L_ZNbyKHdelKrHcMDpozgmU1P8AybdadM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.axiomtest.com/Meters/SourceMeters/Keithley/2602A/SourceMeter%2C-3A-DC%2C-10A-Pulse-40W%2C-2-Ch./,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2602A,,,,,
204,5800.0,USA,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",Tektronix MSO 70000,577.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a MSO70000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",MSO70000,https://download.tek.com/document/55W-22447-9.pdf,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BZUCWIp3bGVS1QbZ69tILA/xlS7IOyu-hPw4hvbbEXxBjSMVtB-RyDDGTK8psI9gdiFm1ilDvG3lTJsTq5Xv8GM02yxIC9sHPq3uMr-H_cykFtDCxpQVZNaNcjS1PLDLsWl6L-5w4ztHLvHpZ44fiRwDYQlFGu4YJPlXBrwN3cGxg/EaV_SXGrD10R-lcDJZN1FKwd9XkjD5w4P-6YpijokGo'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GrDCvfgZka7Y7bRICTHHLA/TPy7CHCZe2b1EdHnoBoeViiHwr-akRrcPvAmJXN82B1-cbHDRxMq4DPOltKLqkOUbxWUCOfbYS738ZonY3vF59hZ5Zg8OBUrG0A6Hx1V78U/kepNPbg0x0S656JwazSNKnePVG0UrHqK6BspcsPJFo8'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HfRw6OUo3quQsk4IIMd_gQ/gJHLLzutGMhG_6rYylbAmWFi-1fxXKwVcbLqeJbRmUqNooRcUPFRNjyMqfIWRowlq0ABZnagcVfELSSWJLSu9_nHIQIjQCQwQz7MKO_pxsc/nrZsZsyHkgPsSesXVpegxEArjDr6A6CNeFsSdJalp0Y'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L8UILIYUmpKBuyt46bwRyg/wKLcKR8c6L2SyBlxuZy3Zn1jxkzKHM66SF84u5Hkaj26Q1igORZskxeMFl3snGZ_coOKfQNGvDJuMycpnn16BAEFjo7883LBJ1dBTC3dB9Q/SS2rGiw0bjerpaHbpVKTYQ2ak6rmuoUDDpSl4cSRhbI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixMSO70000,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
213,110.6,"Cleveland, Ohio, United States","The 2634B SourceMeter SMU instrument is a new dual-channel SMU instrument with best-in-class value and performance. Its tightly-integrated, four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The wide range of 1.5A DC, 10A pulse, 200V output and 1fA measurement resolution makes it suitable to test a wide range of lower current devices and materials. The Model 2634B is equipped with Keithley's high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2634B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2636B SourceMeter SMU Instrument that includes digital I/O, TSP-Link technology, and contact check function.",Keithley 2634 B,267.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2634B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2634B,https://www.testequipmenthq.com/datasheets/KEITHLEY-2636B-Datasheet.pdf,"[OrderedDict([('id', 'attNXpMbxk28rQ43W'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1IIk-Tz2xpWTspZ7Js-9iw/r0TZQoS5zhUxqXT0OT0XYQCycdwqTl2HTHE25_DMY9QD6c8ngA_iHcUQP7JkkXOm8vjjf0xV5mSocnnQSIdYNAs4hE6U5n2-xcw-5XIveYU/9rWBZgZzvwqgq6yJKaEFgs8KMMD943sOFovKFOck2a0'), ('filename', '2734b.webp'), ('size', 7242), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aX1CoNCh1cMFi-oAAfvn4g/CfbpCgsXW2h6Q8UnJgsCW96KTh7IECU_5XiFqWCkKQYVJnEnPRrYglo-FWgNv7Iuvv6RZC9asT9HDBZqud57-5dxGFVG3RFdVwblyqkHZ6s/bMp2U3mFPKvZDlna_yIBqAxW__6KEczFaMZ71PgBkGc'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_LhVwbg04Xgyfm3NqexZZA/DcHsB6m3Ot5ooZtha5pP8jTvqTeeFyV84NEkbC1JDTkK7TdhvQCUwlGUcIkrJEyrsk_Jj1yNJuazqUT1frr74srRFTD5yehurf2sNQyb5UA/31wcwL1EYx7ItgQBGIlHqiqN2DHYrDQXPVyTFeyX7xI'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Y0gk3efjbGMo8X3ACSk1CA/xOhNcJJVOBEPNQwV7F1Do510CNhouhvbHnV461RDEol3pUj-mj0UvRLCUo62-UEVaSqWFPE1HYHxllhW2Udu5L_UzusCw_Z-5fqzeeMjClI/Q12jDrWJr-0Mk4-y-DzPQ1pwz89uFw5nsj_g2aju5sI'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2634b/source-meter-voltage-current-30/dp/44W8039,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2634B,,,,,
216,5800.0,USA,"With the MSO/DPO5000 Mixed Signal Oscilloscope Series, you can analyze up to 20 analog and digital signals with a single instrument to quickly find and diagnose problems in complex designs. Bandwidths up to 2 GHz and sample rates up to 10 GS/s ensure you have the performance you need to see fast-changing signal details. To capture long windows of signal activity while maintaining fine timing resolution, the MSO/DPO5000 Series offers a deep record length of up to 12.5 M points standard on all channels and an optional record length of up to 250 M points on two channels.",Tektronix MSO 5000,574.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a MSO5000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",MSO5000,https://download.tek.com/datasheet/MSO5000-DPO5000-Mixed-Signal-Oscilloscope-Datasheet-9.pdf,"[OrderedDict([('id', 'attAo5PcYgEY4GCjq'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GDCIeCkzlN2wHHOgwkwunw/1Po0X0GysqT_sgOyFw5XGVQdCXT1GPx0PopE07DAavfOcDTZ1IuYgGZHNTeTwtDQ0LolCatSWaR9yejE_mbuujWNQozx5ziftuv86AgxqgI/eIJzgVa8F76vT3YMs3ebZJpIVto0NazDzYDbUtVCwVk'), ('filename', 'mso5000-front-view.webp'), ('size', 109264), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9yR7aUc5CMfU2WMG0p5sOA/-CU3IfcRyAkQWjVCB_HyuhDi3I7rp9iclIyjZDI6yVELaBrwjoVUG0bFfak4xWVspmbg_KrhylhsU-5lb7Qkq4X8bmTqbilGagEa55B-tLI/2DiXZdchYz28Ub3A2UbAkM1dmhqAu7vnGSIP_GNVH44'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rX6kf88x6YW5lVW7BiKkcg/Hez09XKpXkuBSKoikHERRgJgRCgFYx51d3PJCd0DvRqeRAzBLWGu8hsFjmCrKmT4YFp0qt6ULPttvs_N9Xuy2U_WJZhoyIU04sgdUIe2rKw/-LHfQipyj4jfCJo5SL-dfFcvPcINO_DDRrBJHLbT0iQ'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iLeKhum1njZgwOmSH1pRYw/xyJ0GuA-2mAJGeAz3czGo4HyiEiHLJYiTpQnilqIkK4sGeU7P9mE4TS0h_l7ptEKHAuD9EPc1xSOYtur8WOq1iXFk_32AXinBTabu7OWGs8/RO0IWevpJAW8gv_oPFSFeIqm10Mtz_h1YdsumynuDVw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/mso5000-dpo5000-series,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixMSO5000,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
220,4.0,CANADA - QC,"ATS9870 is the world's first Giga-sample waveform digitizer based on the 8-lane PCI Express interface

",ATS 9870,65.0,"Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",Qcodes,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h8yDC782gmJYILVwetqyNg/XNft-iYe6x8LEFTaoDNdcglx8uZWwUUbNf4oX-ErBZYvya3nvf9i0ao4jJp70hHk7oN7wtgcaboMWlcRtFbUeccPNbUJ0Ajzieb7_-0dOvY/M5yDXUl_TYlDiCuUg_-hevxefX_4ZGtn62x5xIZ0wso'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gmlldA7Zo_-OSPyZsu7mPQ/XKZDoQmgc3wi6TkdRJNKT5dYVGwmvfciyRHelmq94Fmnai7rVErHtEDREKJXu9_IHjQS7AeXExr0raP0i8qt9g/rKROdmQfR-K5ATu1ZN_qmcHLCXjquZ1AQFi7pM4PIRY'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-xGoEh8NzGkRqLzjthJ-1A/El2jn-9r8vkBM8mzLCyPAJp4mhEuwwyz-Mjkamgj3Nb-6HmhSMwQGCrm1aoGHp3LwUNAI6zroK3Xqc0OGV9org/tjN2cvTq9f28KHrk67tlaSmFHLwgdKOLL8IIa1-o5us'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t_PiUYdPzQjLjJU9vEarJQ/uVumfw7c89vOKsptIyuF2g3LBU5I8wWQSuR2hRnlrVTLECKdyi_DwwHGMI6y2EQRUFS6qlkmQtCh3GYKCuYvqg/FS3WfkFziiTlklsy7j-a1DSgE14IyXx9JDShkxKJwrQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,"Write a Python script that uses Qcodes to connect to a ATS9870 - 8 bit, 1 GS/s DAQ boards",https://en.wikipedia.org/wiki/Analog-to-digital_converter,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","ATS9870 - 8 bit, 1 GS/s",https://www.alazartech.com/en/download/product/9062/302/ats9870-datasheet-and-specifications/1-6l/,"[OrderedDict([('id', 'attovUpYKx63c3NTS'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M3ySvBZBdxPcFQFS5hiArA/15JC1ETxocpOhypHwjewjgoYA39K2DCUqI6k5A2Hh1i-_K6TEyLnI0PyoOxMp14DVGtyVxpH-4dlvKP4M9j30rzyrsi_2EgPpROo8myfosM/PjqdZINiadXOXTAAwIf14-kdAGYeQXfVQz7KbVP9wfg'), ('filename', 'ATS9870.jpg'), ('size', 594150), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ySrQ_rRueXEWXodazjpdJA/ADrFpvtO8gf1m8sluls7jR32eGZIVDFa14HOl-szYj274dogWraKrVDhll9drwug00IjTSWqHAAao8LbHpId8A/aiBzQ9LuBMd8hgAse8R9j8BWdIFd74ciDlyj9JUYwQs'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4li5zV0zWXZ9XK7WkP-jCw/PBR3qHphp-xhHzCmDdpKDeLvvbHkNv6TItB3lykweLquVsIn4wMZYJWJ0j5B9LhUV8rqwG4St6n63jK01Q9GRg/APvx87V3N32fJoQM4GyZk0z98rBFACEsdTIQR60fPTo'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/73elv31bmUTqDUV53kwuAA/5z4hhefdL0Ndj4EWpUlyeKCPRddpUCPrfd8UQ_rLfeoVAdtf1EiFFLEZW8cP4li1jRtW4yUOpjmbFFtMVh63Pw/5z2j3KYRNgfoQMIW10KSo08ICeOhNw5usR8xP9mR82s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/en/product/ats9870/5/,https://github.com/qnl/pyalazar/blob/master/scripts/do_acquire.py,,,"
",True,,"from alazar import Alazar
import alazar.processor as proc
import numpy as np

import matplotlib.pyplot as plt

def do_acquire():

    b = Alazar(1,1)

    board_model = b.get_board_model()

    b.setup_capture_clock(""internal"", ""100 MS/s"")

    if board_model == 'ATS9360':
        b.setup_input_channels(""400 mV"")

        b.setup_one_trigger('ext', ext_range='TTL')
    else:
        b.setup_input_channels(""1 V"")

        b.setup_one_trigger()

    raw_proc = proc.Raw('test raw')
    ave = proc.Average('test ave')

    procs = b.acquire(1024, 100, 10, processors=[raw_proc, ave])

    return procs

def stats(chan):
    cmin, cmax = chan.min(), chan.max()
    return chan.shape, cmin, cmax, cmax - cmin, np.mean(chan[:])

def main():
    procs = do_acquire()

    chA, chB = procs[0].get_result()

    stat_str = 'shape = {}, min = {}, max = {}, delta = {}, mean = {}'

    plt.plot(range(1024), chA[0,:], 'r-')
    plt.plot(range(1024), chB[0,:], 'g-')
    plt.show()

    print 'acquisition statistics:'
    print 'channel A:'
    print stat_str.format(*stats(chA))
    print 'channel B:'
    print stat_str.format(*stats(chB))

if __name__ == '__main__':
    main()"
221,5420.0,USA,"The Keysight 34934A module for the 34980A Multifunction Switch/Measure Unit offers the highest density matrix for connecting paths between your device under test and your test equipment, allowing for multiple instrument connections to multiple points on your device under test at the same time.",Keysight 34934 A,341.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34934A DAQ boards,https://www.keysight.com/us/en/product/34934A/quad-4x32-reed-matrix.html,['DAQ boards'],"The matrix modules can be expanded with the row expansion kit allowing for up to 4096 cross points in a single mainframe. And with the unique row disconnect feature, you don´t have to worry about the added capacitance when connecting multiple matrix modules.

",KEYSIGHT 34934A,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,"[OrderedDict([('id', 'attYKE1Yada4OvZGT'), ('width', 300), ('height', 169), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/25504Rz0bgiuvtbQJxGBaQ/8sTf-nmeaMpYZzphNNXW-Kf8c9-4q8iGys5pzX_1Vbcm11I7OkPPpw8JcNYgC2qQNMhxPiMHQ-EG8hKETO6jJ2Cn40OZfIn2NLMxCG7TZB-SozUvurINuiqJV6S7MdXm/JHfrLClchkfo_nxrQeSv3d7lZN324YIxUyzhUOjU5M4'), ('filename', '34934A-TRANSP-04_1600x900.jpeg'), ('size', 3295), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/496tyfaUFQ9Dnr3fNZJF5g/tbsj3_xBdI_oUhVvqDSCyP2B57Gso2tmUHCVj-ZQVX8rbT6uU8IGIhjH0wYdghLIRySPjvbpq1tyVdlZg9iKfw/D8CydUpAzMAf0YSTPpqPCtYUafbfdN3QUQRZUdIJxH8'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GeC6vIjwQCkvCFoHYPZI2w/hWAxo5g0AbUWTgunBPYPzGUyQ6BM5-g1MmQ3jVryM5aTFmqM9CbviUykr7tqjaVI2h0eYY8K3IdTqFjld0QUng/33VkYhLIZh3emZzLi0RqqymzuDIogmW_8tlsFvurxKo'), ('width', 300), ('height', 169)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cfoqTyK6W1U9Y2Q38hXTow/VeCfncwclqGK-oxJDP6Y-zbftUjz6cP0YsdM478GU2TGl0MyHo4TB5hpoQQ3-V86R2dADZUfuOanDa_ORHacJw/qGtAbSPgr6_y7ytLTe7FfPya7HzandXAyHAALvRlpNA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/34934A/quad-4x32-reed-matrix.html,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34934a.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34934A,8250.0,,,,"import logging
import re
from qcodes import VisaInstrument, InstrumentChannel, validators
from typing import Union, List, Tuple, Optional, Callable
from .keysight_34980a_submodules import KeysightSwitchMatrixSubModule


class Keysight34934A(KeysightSwitchMatrixSubModule):
    """"""
    Create an instance for module 34933A.
    Args:
        parent: the system which the module is installed on
        name: user defined name for the module
        slot: the slot the module is installed
    """"""
    def __init__(
            self,
            parent: Union[VisaInstrument, InstrumentChannel],
            name: str,
            slot: int
    ) -> None:

        super().__init__(parent, name, slot)

        self.add_parameter(name='protection_mode',
                           get_cmd=self._get_relay_protection_mode,
                           set_cmd=self._set_relay_protection_mode,
                           vals=validators.Enum('AUTO100',
                                                 'AUTO0',
                                                 'FIX',
                                                 'ISO'),
                           docstring='get and set the relay protection mode.'
                                     'The fastest switching speeds for relays'
                                     'in a given signal path are achieved using'
                                     'the FIXed or ISOlated modes, followed'
                                     'by the AUTO100 and AUTO0 modes.'
                                     'There may be a maximum of 200 Ohm of'
                                     'resistance, which can only be bypassed'
                                     'by ""AUTO0"" mode. See manual and'
                                     'programmer''s reference for detail.')

        layout = self.ask(f'SYSTEM:MODule:TERMinal:TYPE? {self.slot}')
        self._is_locked = (layout == 'NONE')
        if self._is_locked:
            logging.warning(f'For slot {slot}, no configuration module'
                            f'connected, or safety interlock jumper removed. '
                            ""Making any connection is not allowed"")
            config = self.ask(f'SYST:CTYP? {slot}').strip('""').split(',')[1]
            layout = config.split('-')[1]
        self.row, self.column = [
            int(num) for num in re.findall(r'\d+', layout)
        ]

    def write(self, cmd: str) -> None:
        """"""
        When the module is safety interlocked, users can not make any
        connections. There will be no effect when try to connect any channels.
        """"""
        if self._is_locked:
            logging.warning(""Warning: no configuration module connected, ""
                            ""or safety interlock enabled. ""
                            ""Making any connection is not allowed"")
        return self.parent.write(cmd)

    def validate_value(self, row: int, column: int) -> None:
        """"""
        to check if the row and column number is within the range of the
        module layout.

        Args:
            row: row value
            column: column value
        """"""
        if (row > self.row) or (column > self.column):
            raise ValueError('row/column value out of range')

    def _get_relay_protection_mode(self) -> str:
        return self.ask(f'SYSTem:MODule:ROW:PROTection? {self.slot}')

    def _set_relay_protection_mode(self, mode: str) -> None:
        self.write(f'SYSTem:MODule:ROW:PROTection {self.slot}, {mode}')

    def to_channel_list(
            self,
            paths: List[Tuple[int, int]],
            wiring_config: Optional[str] = ''
    ) -> str:
        """"""
        convert the (row, column) pair to a 4-digit channel number 'sxxx', where
        s is the slot number, xxx is generated from the numbering function.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
            wiring_config: for 1-wire matrices, values are 'MH', 'ML';
                                 for 2-wire matrices, values are 'M1H', 'M2H',
                                 'M1L', 'M2L'

        Returns:
            in the format of '(@sxxx, sxxx, sxxx, sxxx)', where sxxx is a
            4-digit channel number
        """"""
        numbering_function = self.get_numbering_function(
            self.row,
            self.column,
            wiring_config
        )

        channels = []
        for row, column in paths:
            channel = f'{self.slot}{numbering_function(row, column)}'
            channels.append(channel)
        channel_list = f""(@{','.join(channels)})""
        return channel_list

    @staticmethod
    def get_numbering_function(
            rows: int,
            columns: int,
            wiring_config: Optional[str] = ''
    ) -> Callable[[int, int], str]:
        """"""
        to select the correct numbering function based on the matrix layout.
        On P168 of the user's guide for Agilent 34934A High Density Matrix
        Module:
        http://literature.cdn.keysight.com/litweb/pdf/34980-90034.pdf
        there are eleven equations. This function here simplifies them to one.

        Args:
            rows: the total row number of the matrix module
            columns: the total column number of the matrix module
            wiring_config: wiring configuration for 1 or 2 wired matrices

        Returns:
            The numbering function to convert row and column in to a 3-digit
            number
        """"""
        layout = f'{rows}x{columns}'
        available_layouts = {
            ""4x32"": [""M1H"", ""M2H"", ""M1L"", ""M2L""],
            ""4x64"": [""MH"", ""ML""],
            ""4x128"": [''],
            ""8x32"": [""MH"", ""ML""],
            ""8x64"": [''],
            ""16x32"": ['']
        }

        if layout not in available_layouts:
            raise ValueError(f""Unsupported layout: {layout}"")

        if wiring_config not in available_layouts[layout]:
            raise ValueError(
                f""Invalid wiring config '{wiring_config}' for layout {layout}""
            )

        offsets = {
            ""M1H"": 0,
            ""M2H"": 1,
            ""M1L"": 2,
            ""M2L"": 3,
            ""MH"": 0,
            ""ML"": 1
        }

        offset = 0
        if wiring_config != '':
            offset = offsets[wiring_config] * columns

        channels_per_row = 800 / rows
        offset += 100 - int(channels_per_row)

        def numbering_function(row: int, col: int) -> str:
            return str(int(channels_per_row * row + col + offset))

        return numbering_function
"
224,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Single Output, 30V/3A, USB, RS232, LAN(LXI) and Analogue Interfaces
",AIM TTI PL 303 P,47.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL303-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL303-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'attiY3mADod6PkrWn'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jViEAPsI59GSaZYuPLj3jg/7QCSWI35Xvja3Z4VgQLmirxtrctKhyiw0vVXhJSd9xMFHgg_KOnp_d-qb3GssSgHC6SwFI2exMWFkmdLstEo_-o10GZ1lzOXFekhozw86EA/SiUTqJXUWlNxtu1IFaKHiu7EzSjWrMzssDNp__bBLnM'), ('filename', 'PL303P-1000px.jpg'), ('size', 159244), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xhHfONZt7OHvjLvM-BbWwg/evqTVW6hQzMUVSwTpZm2VslaBu2_1Ms-jRB2dsy2fM6UY8xgaIsuN6j08g48mU1YbHW9hzeQRN2HIza41gu9_Q/eZQn03bGLIlsmbD8ZMJQUEbYowvocYWT6xwSLeAi3WU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4e4NRW_xDfflgswzOoxJfA/iWOe3zYhWbMhdqxmGaliav9f2kSCAuMeSn9ER4gPYABi7E53prpbMxvxyyfcKJfPq4z_721jmotosEywB-X80A/V7u0-Q1t9UvryervoaGbhScCSFqceYbI5t7bMO3Kmq4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L75LK7SnNX6OTVtyFZ6xjA/d5Ow9u9LeP47mU0L4TslTUYTczt2i7swWZa7YlDlvSvAd6EK7oX7lDe5XuNNwA0PiTC5SGstBHqKRRV4Fwp3HA/P94O5rlQ3T5GEYS-3ZC4WLvhfovAauuxUoUuhbJvDoI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,700.0,,,,
228,23.0,"Beijing, China","The Rigol DP831 features a relative large (8.9 cm / 3.5"") and easy to read TFT monochrome display. In addition to the normal digital displays for voltage, current, and power, these values can also be displayed as signal curves.

",DP 831,448.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DP831 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Rigol DP831,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,"[OrderedDict([('id', 'attTcyLVieBJhRxag'), ('width', 2048), ('height', 1393), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LaPq9rpTMlPxThJLj5pg2Q/_wBn4wQ06267xuxfB-6PKCt8KBIbHTaDalo9uvYBIjE6DTpygUg5pTRHVg3ocNibmU3z7yW24PamI0wx4OG7gP2N_Oq6K4_ll0imDDgxkpg/KcgqJx1nTtMGL4RepEOs6Ya9T_qp01-DqKGMcelQJeI'), ('filename', '71pS35meVqL.jpg'), ('size', 248989), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZBE5-NNZwV2Q-495PnUxTg/WnE9dsPClX04IDyI95hklZIukRXHR1lxAaB9jyeXfxoyTWhc7eQ5m0NsFNij3mlxHJYDvmJ1BObh5FMfRqamVQ/CnAyKIX90TLoJUekUKMGmRQv18TgeU_6_-3bonUZ_8Y'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xoAF6g70kv2g1dvuWPpHyA/V191o7VmcElpHakdstBthHvHXsVd7hBIiRrzATSLbNWsY_jRv36WRTWMKPl_X8NPpEsKeUS1QLYWdov9QhFMWw/IDlZIUd88ZSXDSFPr7j94xJCrNtBVZPeMqZqh3xg--4'), ('width', 753), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1HHToYCZ5pKJKQcqE2vEAA/cEDjdngfNwcdZ5seid-W6wkQgqP0bra-mhtHPjMCyMZ1ACmDfOPEtRwgtfsy9cQImtcgrvP_M70DvQ3Va0399w/fP5MZJxzHlVXdPGpL4c91AZaZ9JIb2-Rs8qVwAApgZg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.batronix.com/shop/power-supplies/DP831.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP831.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP831,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP831(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP831(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [(8.0, 5.0), (30.0, 2.0), (-30.0, 2.0)]

        ovp_ranges_std = [(0.01, 8.8), (0.01, 33.0), (-0.01, -33.0)]
        ocp_ranges_std = [(0.001, 5.5), (0.001, 2.2), (0.001, 2.2)]

        ovp_ranges_precision = [(0.001, 8.8), (0.001, 33.0), (-0.001, -33.0)]
        ocp_ranges_precision = [(0.0001, 5.5), (0.0001, 2.2), (0.0001, 2.2)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
231,5420.0,USA,"The E4980A precision LCR meter provides the best combination of accuracy, speed, and versatility for a wide range of component measurements.",Keysight E 4980 A,335.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT E4980A Multimeters,https://www.keysight.com/us/en/products/lcr-meters-impedance-measurement-products/bench-top-lcr-meters.html,['Multimeters'],"An LCR meter is a type of electronic test equipment used to measure the inductance (L), capacitance (C), and resistance (R) of an electronic component.[1]",KEYSIGHT E4980A,https://www.keysight.com/us/en/assets/7018-01355/data-sheets/5989-4435.pdf,"[OrderedDict([('id', 'attuZHiWXbmDgcXF9'), ('width', 1156), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Xsicoa-lYWwIpXK5EvacNw/imVE58EJXSNqdpvh9C6qGu9DBOJ_d5ysqTPC4f6OirH2fpFJ2LtS6bmoU_jGkIK5L2VkNj_x8yoFvhenP_khUA/7kjq8RB2eh3q9d5IUx710wKIi4nH8_DmlhwYkSJlB5s'), ('filename', 'LCR.png'), ('size', 475849), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_wDJtpHYjqPBwVR7XrNUJw/FF3WVwyK3PqvCh1cnV1U7fISJZujIcShohQN1hStuoVx2r7nS2cFlibs5qXKuFZ11B58L53fpr_tEWSXGxr4fA/r0-xKjECnLliA_ontjXeFCg0qTtNMxjeNUoxAWQoegw'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YKiPIilsme352TJth0Nraw/IpWpqjOcwPzsTHn_wQAQYpIwId0Tb6rnege6XadYmzppgz40Ri9tmDz8w0-BgNWUkipMUe5HnKb8peR5zgS4kA/VoKfZvkJHxyfDij1nnuKCpktsrILgxS-r8CPSF4VAls'), ('width', 769), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4JDu0zvrF6lPQyu8tMdCJQ/z-4H2cnpXFJ53hSHwTh3-vSlzgN5cpWMGHBVR3Ir2Ga_htrEaJrtQxDVZwBSVFGySHEhZrFLXs5AOSha1a9eOw/JqV6DjRaKSLb3NkMBEn1gRMqXVoFinThXu8PAAJOmzw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/E4980A/precision-lcr-meter-20-hz-2-mhz.html,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_e4980a.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightE4980A,24253.0,,,,"from typing import Tuple, Sequence, cast, Any, Union
from distutils.version import LooseVersion
from pyvisa.errors import VisaIOError

from qcodes import VisaInstrument, InstrumentChannel
from qcodes.instrument.parameter import (MultiParameter, ParamRawDataType,
                                         ManualParameter)
from qcodes.utils.helpers import create_on_off_val_mapping
from qcodes.utils.validators import Enum, Numbers, Bool, Ints
from qcodes.instrument.group_parameter import GroupParameter, Group


class MeasurementPair(MultiParameter):
    """"""
    Data class for E4980A measurement, which will always return two items
    at once.

    The two items are for two different parameters, depending on the measurement
    function. Hence, the names of the two attributes are created from the
    ""names"" tuple of the measurement functions.

    Examples:
        To create a measurement data with capacitance=1.2, and
        dissipation_factor=3.4.

        >>> data = MeasurementPair(name=""CPD"",
                                    names=(""capacitance"", ""dissipation_factor""),
                                    units=(""F"", """"))
        >>> data.set((1.2, 3.4))
        >>> data.get()
        (1.2, 3.4)
    """"""
    value: Tuple[float, float] = (0., 0.)

    def __init__(self,
                 name: str,
                 names: Sequence[str],
                 units: Sequence[str],
                 **kwargs: Any):
        super().__init__(name=name,
                         names=names,
                         shapes=((), ()),
                         units=units,
                         setpoints=((), ()),
                         **kwargs)
        self.__dict__.update(
            {names[0]: 0,
             names[1]: 0}
        )

    def set_raw(self, value: Tuple[float, float]) -> None:
        self.value = value
        setattr(self, self.names[0], value[0])
        setattr(self, self.names[1], value[1])

    def get_raw(self) -> Tuple[ParamRawDataType, ...]:
        return self.value


class E4980AMeasurements:
    """"""
    All the measurement function for E4980A LCR meter. See user's guide P353
    https://literature.cdn.keysight.com/litweb/pdf/E4980-90230.pdf?id=789356
    """"""
    CPD = MeasurementPair(
        ""CPD"", (""capacitance"", ""dissipation_factor""), (""F"", """")
    )
    CPQ = MeasurementPair(
        ""CPQ"", (""capacitance"", ""quality_factor""), (""F"", """")
    )
    CPG = MeasurementPair(
        ""CPG"", (""capacitance"", ""conductance""), (""F"", ""S"")
    )
    CPRP = MeasurementPair(
        ""CPRP"", (""capacitance"", ""resistance""), (""F"", ""Ohm"")
    )
    CSD = MeasurementPair(
        ""CSD"", (""capacitance"", ""dissipation_factor""), (""F"", """")
    )
    CSQ = MeasurementPair(
        'CSQ', (""capacitance"", ""quality_factor""), (""F"", """")
    )
    CSRS = MeasurementPair(
        ""CSRS"", (""capacitance"", ""resistance""), (""F"", ""Ohm"")
    )
    LPD = MeasurementPair(
        ""LPD"", (""inductance"", ""dissipation_factor""), (""H"", """")
    )
    LPQ = MeasurementPair(
        ""LPQ"", (""inductance"", ""quality_factor""), (""H"", """")
    )
    LPG = MeasurementPair(
        ""LPG"", (""inductance"", ""conductance""), (""H"", ""S"")
    )
    LPRP = MeasurementPair(
        ""LPRP"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    LSD = MeasurementPair(
        ""LSD"", (""inductance"", ""dissipation_factor""), (""H"", """")
    )
    LSQ = MeasurementPair(
        ""LSQ"", (""inductance"", ""quality_factor""), (""H"", """")
    )
    LSRS = MeasurementPair(
        ""LSRS"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    LSRD = MeasurementPair(
        ""LSRD"", (""inductance"", ""resistance""), (""H"", ""Ohm"")
    )
    RX = MeasurementPair(
        ""RX"", (""resistance"", ""reactance""), (""Ohm"", ""Ohm"")
    )
    ZTD = MeasurementPair(
        ""ZTD"", (""impedance"", ""theta""), (""Ohm"", ""Degree"")
    )
    ZTR = MeasurementPair(
        ""ZTR"", (""impedance"", ""theta""), (""Ohm"", ""Radiant"")
    )
    GB = MeasurementPair(
        ""GB"", (""conductance"", ""susceptance""), (""S"", ""S"")
    )
    YTD = MeasurementPair(
        ""YTD"", (""admittance"", ""theta""), (""Y"", ""Degree"")
    )
    YTR = MeasurementPair(
        ""YTR"", (""admittance"", ""theta""), (""Y"", ""Radiant"")
    )
    VDID = MeasurementPair(
        ""VDID"", (""voltage"", ""current""), (""V"", ""A"")
    )


class Correction4980A(InstrumentChannel):
    """"""
    Module for correction settings.
    """"""
    def __init__(
            self,
            parent: VisaInstrument,
            name: str,
    ) -> None:
        super().__init__(parent, name)

        self.add_parameter(
            ""open"",
            set_cmd="":CORRection:OPEN"",
            docstring=""Executes OPEN correction based on all frequency points.""
        )

        self.add_parameter(
            ""open_state"",
            get_cmd="":CORRection:OPEN:STATe?"",
            set_cmd="":CORRection:OPEN:STATe {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enables or disable OPEN correction""
        )

        self.add_parameter(
            ""short"",
            set_cmd="":CORRection:SHORt"",
            docstring=""Executes SHORT correction based on all frequency points.""
        )

        self.add_parameter(
            ""short_state"",
            get_cmd="":CORRection:SHORt:STATe?"",
            set_cmd="":CORRection:SHORt:STATe {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0""),
            docstring=""Enables or disable SHORT correction.""
        )


class KeysightE4980A(VisaInstrument):
    """"""
    QCodes driver for E4980A Precision LCR Meter
    """"""
    def __init__(self,
                 name: str,
                 address: str,
                 terminator: str = '\n',
                 **kwargs: Any):
        """"""
        Create an instance of the instrument.

        Args:
            name: Name of the instrument instance
            address: Visa-resolvable instrument address.
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        idn = self.IDN.get()

        self.has_firmware_a_02_10_or_above = (
                LooseVersion(idn[""firmware""]) >= LooseVersion(""A.02.10"")
        )

        self.has_option_001 = '001' in self._options()
        self._dc_bias_v_level_range: Union[Numbers, Enum]
        if self.has_option_001:
            self._v_level_range = Numbers(0, 20)
            self._i_level_range = Numbers(0, 0.1)
            self._imp_range = Enum(0.1, 1, 10, 100, 300, 1000, 3000, 10000,
                                   30000, 100000)
            self._dc_bias_v_level_range = Numbers(-40, 40)
        else:
            self._v_level_range = Numbers(0, 2)
            self._i_level_range = Numbers(0, 0.02)
            self._imp_range = Enum(1, 10, 100, 300, 1000, 3000, 10000, 30000,
                                   100000)
            self._dc_bias_v_level_range = Enum(0, 1.5, 2)

        self._measurement_pair = MeasurementPair(
            ""CPD"",
            (""capacitance"", ""dissipation_factor""),
            (""F"", """")
        )

        self.add_parameter(
            ""frequency"",
            get_cmd="":FREQuency?"",
            set_cmd="":FREQuency {}"",
            get_parser=float,
            unit=""Hz"",
            vals=Numbers(20, 2E6),
            docstring=""Gets and sets the frequency for normal measurement.""
        )

        self.add_parameter(
            ""current_level"",
            get_cmd=self._get_current_level,
            set_cmd=self._set_current_level,
            unit=""A"",
            vals=self._i_level_range,
            docstring=""Gets and sets the current level for measurement signal.""
        )

        self.add_parameter(
            ""voltage_level"",
            get_cmd=self._get_voltage_level,
            set_cmd=self._set_voltage_level,
            unit=""V"",
            vals=self._v_level_range,
            docstring=""Gets and sets the AC bias voltage level for measurement ""
                      ""signal.""
        )

        self.add_parameter(
            ""measurement_function"",
            get_cmd="":FUNCtion:IMPedance?"",
            set_cmd=self._set_measurement
        )

        self.add_parameter(
            ""range"",
            get_cmd="":FUNCtion:IMPedance:RANGe?"",
            set_cmd=self._set_range,
            unit='Ohm',
            vals=self._imp_range,
            docstring=""Selects the impedance measurement range, also turns ""
                      ""the auto range function OFF.""
        )

        self.add_parameter(
            ""imp_autorange_enabled"",
            get_cmd="":FUNCtion:IMPedance:RANGe:AUTO?"",
            set_cmd="":FUNCtion:IMPedance:RANGe:AUTO {}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                  off_val=""0""),
            docstring=""Enables the auto-range for impedance measurement.""
        )

        self.add_parameter(
            ""dc_bias_enabled"",
            get_cmd="":BIAS:STATe?"",
            set_cmd="":BIAS:STATe {}"",
            vals=Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                  off_val=""0""),
            docstring=""Enables DC bias. DC bias is automatically turned ""
                      ""off after recalling the state from memory.""
        )

        self.add_parameter(
            ""dc_bias_voltage_level"",
            get_cmd="":BIAS:VOLTage:LEVel?"",
            set_cmd="":BIAS:VOLTage:LEVel {}"",
            get_parser=float,
            unit=""V"",
            vals=self._dc_bias_v_level_range,
            docstring=""Sets the DC bias voltage. Setting does not ""
                      ""implicitly turn the DC bias ON.""
        )

        self.add_parameter(
            ""meas_time_mode"",
            val_mapping={""short"": ""SHOR"", ""medium"": ""MED"", ""long"": ""LONG""},
            parameter_class=GroupParameter
        )

        self.add_parameter(
            ""averaging_rate"",
            vals=Ints(1, 256),
            parameter_class=GroupParameter,
            get_parser=int,
            docstring=""Averaging rate for the measurement.""
        )

        self._aperture_group = Group(
            [self.meas_time_mode,
             self.averaging_rate],
            set_cmd="":APERture {meas_time_mode},{averaging_rate}"",
            get_cmd="":APERture?""
        )

        if self.has_firmware_a_02_10_or_above:
            self.add_parameter(
                ""dc_bias_autorange_enabled"",
                get_cmd="":BIAS:RANGe:AUTO?"",
                set_cmd="":BIAS:RANGe:AUTO {}"",
                vals=Bool(),
                val_mapping=create_on_off_val_mapping(on_val=""1"",
                                                      off_val=""0""),
                docstring=""Enables DC Bias range AUTO setting. When DC bias ""
                          ""range is fixed (not AUTO), '#' is displayed in ""
                          ""the BIAS field of the display.""
            )

        self.add_parameter(
            ""signal_mode"",
            initial_value=None,
            vals=Enum(""Voltage"", ""Current"", None),
            parameter_class=ManualParameter,
            docstring=""This parameter tracks the signal mode which is being ""
                      ""set.""
        )

        self.add_submodule(
            ""_correction"",
            Correction4980A(self, ""correction"")
        )
        self._set_signal_mode_on_driver_initialization()
        self.connect_message()

    @property
    def correction(self) -> Correction4980A:
        submodule = self.submodules['_correction']
        return cast(Correction4980A, submodule)

    @property
    def measure_impedance(self) -> MeasurementPair:
        return self._get_complex_impedance()

    @property
    def measurement(self) -> MeasurementPair:
        return self._measurement()

    def _set_range(self, val: str) -> None:
        self.write(f"":FUNCtion:IMPedance:RANGe {val}"")
        self.imp_autorange_enabled.get()

    def _get_complex_impedance(self) -> MeasurementPair:
        """"""
        Returns the impedance in the format of (R, X), where R is the
        resistance, and X is the reactance.
        """"""
        measurement = self.ask("":FETCH:IMPedance:CORRected?"")
        r, x = [float(n) for n in measurement.split("","")]
        measurement_pair = MeasurementPair(
            name=""RX"",
            names=(""resistance"", ""reactance""),
            units=(""Ohm"", ""Ohm"")
        )
        measurement_pair.set((r, x))
        return measurement_pair

    def _measurement(self) -> MeasurementPair:
        """"""
        Returns a measurement result with the selected measurement function.
        """"""
        measurement = self.ask("":FETCH:IMPedance:FORMatted?"")
        val1, val2, _ = [float(n) for n in measurement.split("","")]
        measurement_pair = MeasurementPair(
            name=self._measurement_pair.name,
            names=self._measurement_pair.names,
            units=self._measurement_pair.units
        )
        measurement_pair.set((val1, val2))
        return measurement_pair

    def _set_measurement(self,
                         measurement_pair: MeasurementPair) -> None:
        """"""
        Selects the measurement function.
        """"""
        self._measurement_pair = measurement_pair
        self.write(f"":FUNCtion:IMPedance {measurement_pair.name}"")

    def _get_voltage_level(self) -> float:
        """"""
        Gets voltage level if signal is set with voltage level parameter
        otherwise raises an error.
        """"""
        if self.signal_mode() == ""Current"":
            raise RuntimeError(""Cannot get voltage level as signal is set ""
                               ""with current level parameter."")

        v_level = self.ask("":VOLTage:LEVel?"")

        return float(v_level)

    def _set_voltage_level(self, val: str) -> None:
        """"""
        Sets voltage level
        """"""
        self.signal_mode(""Voltage"")
        self.voltage_level.snapshot_exclude = False
        self.current_level.snapshot_exclude = True

        self.write(f"":VOLTage:LEVel {val}"")

    def _set_current_level(self, val: str) -> None:
        """"""
        Sets current level
        """"""
        self.signal_mode(""Current"")
        self.voltage_level.snapshot_exclude = True
        self.current_level.snapshot_exclude = False

        self.write(f"":CURRent:LEVel {val}"")

    def _get_current_level(self) -> float:
        """"""
        Gets current level if signal is set with current level parameter
        otherwise raises an error.
        """"""
        if self.signal_mode() == ""Voltage"":
            raise RuntimeError(""Cannot get current level as signal is set ""
                               ""with voltage level parameter."")

        i_level = self.ask("":CURRent:LEVel?"")

        return float(i_level)

    def _is_signal_mode_voltage_on_driver_initialization(self) -> bool:
        """"""
        Checks if signal is set with voltage_level param at instrument driver
        initialization
        """"""
        assert self.signal_mode() is None
        try:
            self.voltage_level()
            return True
        except VisaIOError:
            return False

    def _set_signal_mode_on_driver_initialization(self) -> None:
        """"""
        Sets signal mode on driver initialization
        """"""
        if self._is_signal_mode_voltage_on_driver_initialization():
            self.signal_mode(""Voltage"")
            self.voltage_level.snapshot_exclude = False
            self.current_level.snapshot_exclude = True
        else:
            self.signal_mode(""Current"")
            self.voltage_level.snapshot_exclude = True
            self.current_level.snapshot_exclude = False

    def _options(self) -> Tuple[str, ...]:
        """"""
        Returns installed options numbers. Combinations of different installed
        options are possible. Two of the possible options are Power/DC Bias
        Enhance (option 001) and Bias Current Interface (option 002).
        """"""
        options_raw = self.ask('*OPT?')
        return tuple(options_raw.split(','))

    def system_errors(self) -> str:
        """"""
        Returns the oldest unread error message from the event log and removes
        it from the log.
        """"""
        return self.ask("":SYSTem:ERRor?"")

    def clear_status(self) -> None:
        """"""
        Clears the following:
            Error Queue
            Status Byte Register
            Standard Event Status Register
            Operation Status Event Register
            Questionable Status Event Register (No Query)
        """"""
        self.write('*CLS')

    def reset(self) -> None:
        """"""
        Resets the instrument settings.
        """"""
        self.write('*RST')
"
233,38.0,Switzerland,The Zurich Instruments UHFLI is a digital lock-in amplifier that covers the frequency range from DC to 600 MHz. It offers a time constant of 30 ns for demodulation – resulting in a demodulation bandwidth that exceeds 5 MHz.,Uhfli,648.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a UHFLI Lockin Amplifiers,https://en.wikipedia.org/wiki/Lock-in_amplifier,['Lockin Amplifiers'],"A lock-in amplifier is a type of amplifier that can extract a signal with a known carrier wave from an extremely noisy environment. Depending on the dynamic reserve of the instrument, signals up to a million times smaller than noise components, potentially fairly close by in frequency, can still be reliably detected. It is essentially a homodyne detector followed by low-pass filter that is often adjustable in cut-off frequency and filter order.",UHFLI,https://docs.zhinst.com/pdf/ziUHF_UserManual.pdf,"[OrderedDict([('id', 'att081X3j2dpVqexI'), ('width', 1183), ('height', 387), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/giGN49hGy8n1NhaET0uC9g/tSSEluSBynaZpvF6DnXXKy2jMaw1YfrTW2uBO5C8I8aVKcl1Fxd2gVyqS-S3WdLVZh8w1Sjc-MadpsRCTwSBjuuDrfZpK7BVDRlitzMOyRw/lXmSp6ki1Z-7wvmXD4bVtE63idPv_GA9gxeyUPwyq8E'), ('filename', 'UHFLI_persp_0.png.webp'), ('size', 23318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5qDYk7tOo94vuy9-fLUxOQ/nUmSqjoazNpCnbtQ0E5dhuwoS5Jrl2g2zO04E32sfztBVro8PwkwteWkCWibufUyT6wlDwUlu84sP-yPwL2sFf6vPTSVCxrAYDr2J-g4YZQ/zh3MGmKusdRrYGZ_gCJpxieaWXt2dOvwlbmdJdZfsDw'), ('width', 110), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/r2Pee16ELBG06MsW0mxWkw/CLtx6FWgj_pNhvrmrqJhckNeftxKVKxgC45KVXoM6aRJyahY09iSe6QQLemjHp-qGxerVC82iMgQmMIyJ3QKpgvKZzbx71l03Bt1DV17gu8/GBanTvW66FdEZuguDO1j8ANk50u6LazLMf782trdtrk'), ('width', 1183), ('height', 387)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MgaKRuHCoWWnIEJkKR4A-Q/DFAhwpCXit7Cb1YYVVVPeHhQOaPGKxqQiAohRLKxJk974ZNbL4xtUlRuXGrI76wt6vu7EwRxGCXeCuIEMWvUBcjiZ3N9g1tHhtZE8v-4dEI/TyZ7uoK6u77Cy0aD9gfakmr4PBXacQLMmJ00nnK5I8U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/uhfli-lock-in-amplifier#introduction,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/uhfli.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.uhfli.html,,,,,"""""""Autogenerated module for the UHFLI QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWG(ZINode):
    """"""AWG node.

    This class implements the basic functionality for the device specific
    arbitrary waveform generator.
    Besides the upload/compilation of sequences it offers the upload of
    waveforms and command tables.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        session: Underlying session.
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        device_type: Device type
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, f""awg_{index}"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)


class UHFLI(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments UHFLI.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.awgs:

            channel_list = ZIChannelList(
                self,
                ""awgs"",
                AWG,
                zi_node=self._tk_object.awgs.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.awgs):
                channel_list.append(
                    AWG(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.awgs[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""awgs"", channel_list)
"
235,110.6,"Cleveland, Ohio, United States","The 2602B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (3A DC, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",Keithley 2602 B,246.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2602B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2602B,https://www.testequipmenthq.com/datasheets/KEITHLEY-2602-Datasheet.pdf,"[OrderedDict([('id', 'attSsHSNBdjGWVb61'), ('width', 320), ('height', 145), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B7q4STJsAbyrkbbsyAt7Dg/nLFerY6DHrffSYn-4fmN5Fwjh5SQK4r17H2shl12YLrDeNeDuIfxbkDzdiHs9no8SkQNei9pOJ9-wMC8_nS2zDWqaBDh6Z-GJ8467j4nC2I/XnnivTXifPoDX_iWOE9FDhUTD5b18WdfsjAwP6Ak4bA'), ('filename', '2602b.webp'), ('size', 7334), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XbT0084mXadswQkfPLp-dQ/Lp0W_Gj3mxo47lfUbqWMlGflPC9iYLl16-kNBurxnCdVAtbycszmv6RK1LdS5kAPmQN4RmJ0jDhDV30unjqI1iklIM84K-xF8f4Wp_rgTNA/3y5D1VZw10vOvj4etWnlwl-nO8_DHzg-OFSZYxEL8QI'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oo8uZ4jnvOoL3fF3yZVZiQ/jOXOsmfWkNwab0-5OPPNWTVKs3SvHzHDZrBEgTi8ClXigIKBA98mcCLCh9G9EznQZEBedCb0keM_TUhiMuHsJiA7T1osX-n7_KTcZWtz580/leXSNQsiaz3f4tdgsqytNPTvroLmEZ0jLK-zo3NX3KU'), ('width', 320), ('height', 145)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZXD06VdkAlSQ-Iml333rLw/Y8sBuR1Y3zmNsTBKaKEzyPwQkNv4Au7HtU7VK0BI29KN_U5S4Y2Vz5aN2NtUXkcBmLRsmwzMvNC62dUeVzR1rrnyWL7cY4XhDV7tGvJUTa8/hSRZT0Vb7GB6CcZ9xZCxmi0k5g6Hi0OfOF6BBQch_0M'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2602b/source-meter-voltage-current-40/dp/44W8034,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2602B,19738.0,,,,
240,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34411 A Submodules,271.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34411A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34411A Submodules,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,"[OrderedDict([('id', 'att8A288bkAJo0O7a'), ('width', 600), ('height', 336), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/y_COAQyy4fsh4A-91Pp38g/d1dYLI3Qq75KI-lUpbd1mgrzXDJZkRs9Hynfftm7hEG5fLwpDIPikc8Z9kl1R4yYr_00VxRojSZbdBbyGFDgdaIyvf_uJvGzRHrZKlcWOPA/2FZYpZpKYVcZz8rqSz3i9tO4y5eioli3pGIYLTeWdEo'), ('filename', 'agilent-34410a.jpg'), ('size', 171847), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OQ9t-cUBbNdiVtcZ7hAQtA/cnTpaSNlsz3DyLsQLR65XRBa2ngiEM27KA7GJd8E4Jkr_GHzuyNEym_Am3vzRSu8BezOQ0Xpp2lFir9ZzVXw8A/qACpgvZNDYcYnyifk7fTqOz9X73GOmfnE5xH2AOMwfs'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/K5Khwv7HFCS2dLVbKxp9pA/nAaVV_d6I5aKzmT-9WZjqla3hkmZSMxm1PQUweBHlJG2sUawh_ecbw6HiXXlN3BlkXUfr71MutqRvrhm_JCAVQ/45_Sa_zvLJ8xOnyTtpuj-gO7Aei98tW_XVyKsz8xgCQ'), ('width', 600), ('height', 336)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UDwU7qdcwUwX-iu4u1rF2A/rkBQemICLCJpJs1h0qDDZHTAs_TPGefuo-tUhlM0K-eFx5Ro-85d80qErIeyeYiRPfIA8dOLcVsCTPVrB4GdbA/2W9eRTWh1r6Vc3OOCW0az6nsenapPW4gK6MlMaPdFyg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_34411A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34411A,,,True,,"from typing import Any
from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight_34411A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34411A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)
"
243,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Single Output, 60V/1.5A, USB, RS232 & LAN Interfaces
",AIM TTI PL 601 P,46.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL601-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL601-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'att0l8FCdLOBPIm2n'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ObIN7mI8vQi_5wM6vFcOqQ/HvRc-PBtvNrHIR91QVOZTiC5UPaeUf2bIP3aKRpHOLAUwuQziJtdtw9MgFep2UrZaQMqA836b-dP0dKUnsPjrGiirq_gt78Phqz8MO87iSQ/P5HwSL47DYNKzqbeoQQtPH1nXFvR9tB8BUhWSb229CY'), ('filename', 'PL601P-1000px.jpg'), ('size', 159089), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eftAjomwjVJkx2DBMruLtQ/PCMMLIvnuqv56DxelyQ_WI3-Sh_0sWpZNue7v_bwwqzre6D9RdZ8m0sH_mZkwwFW6NxhXeZTJcigkZlrIgSgWg/_qr9ZUIX6v63v02zf1H8JUhFksUZoJI6pGNlvGujKnc'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/57QBM733AF-g6GGSuQlu2A/ncYFfdKPwH4pPtWk6G6MlW1WDa0taxK3ZzIA5OQBKrRsg4t2GpzlgRrNtrDZe2t-gVphOmhduv1smj5nnNwB0Q/GxDCCfzRAkNMR8TO9D74DAsJZq0DxnR14TsDauT3I14'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WBJzilMQs52lmBnxGLU_Nw/brGrVWkvGnZyKaWKKQ8pU1W9_kTRfFe2ciBjITwzfHPQozKhznBaVCn04mLAsQrYyjTM2Nk7l2LUdp5n7In41w/2t-0MHbvk7XcgURScqFXiLI6ziwTTWykptXtKAOJq5Y'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,700.0,"
",,,
244,13.0,US,The AMI Model 430 Power Supply Programmer is a sophisticated digital power supply controller that allows an operator to manage a superconducting magnet system with unprecedented accuracy and ease.,AMI 430,66.0,"American Magnetics - Excellence in Magnetics and Cryogenics, since 1968
",Qcodes,American Magnetics,"[OrderedDict([('id', 'attDjjOcnpupvKnu5'), ('width', 561), ('height', 90), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-llHkTlrulK0UwMT2NIK5g/BEByLxxI416NZnPY5OQoWi2Uuwnn-xNAYMojIDZasZvhQSUKECjvMc1w2CWqcVkQQxj74CVjCwFp5jkXwqt2Cg/xXB3A0lnl5XnwcYVUAK5hABtsVn9TIp6u1Iq1G56EyE'), ('filename', 'AMi.jpeg'), ('size', 10167), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/p3Sm0mH7K-Si2d9TtpUR3g/RfktIKCRHAa5tgGXPbRkbHPGbny1Wh9LmTOPAinOei9vdTCFsWuwsp4ccS6PI4DskpWWtnaUHRSlRBQzOt_Y8A/bOT3VxK4jBiIoQWzTpmrX9JrbXbelBvyDdQdzFKg4PA'), ('width', 224), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bvhybaG9suct01Ks0kytWQ/c_-a2qeMiYnYQyLvH-xgYQuWFCeGpjL1PoraW7zw5F86ZpzMxw98PTRkKsfnaXNjt8Lp6dSGOox4IO0t7FQMRQ/x8zO7Ut6sSuE1BBPi0dhwqTooKp2TMyAC58HR1p46gA'), ('width', 561), ('height', 90)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bw_X-c91vp-6dWTVekcZFg/Rr8bW-WvJqauNcSQX8RmV_i_iQazbImsm9R9mgjmfTAnZK2e8mrYKS9gjktpkbAbuD7VFphz93ar_63d6AhAhA/FLQRrOTfeb6L5wHuXxW4kfjDSGMA1_n4Pbe5lVgbnFc'), ('width', 3000), ('height', 3000)]))]))])]",http://www.americanmagnetics.com/index.php,Write a Python script that uses Qcodes to connect to a AMI 430 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. 
",AMI 430,http://www.americanmagnetics.com/brochures/model430.pdf,"[OrderedDict([('id', 'attSCyZigpnKCLrdu'), ('width', 495), ('height', 102), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aTrOWRxPX-gIvHQwH0ZYHg/sHTf_mc7VSU9r1HTkXrE_yIkoK80GkkcVIqQoW5ETXwYyBKMMXilpxJNBnqHXbxQ5JqWQHQUwdRFk2b3i5uERjMYQwlzm-0FiMgFWBp5yXU/SeUyw3K5c0h6Q61pXSV8_zyP0PbiXkM-1DcvzWzQ_fc'), ('filename', 'AMi430.jpeg'), ('size', 10117), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BEotirvOCX93N9SA22eikw/88OCtZ9TclWS3f6OJAc0RmYvm8w2W7PTze6bdAMnCv-0WXpif6mvTL3cLv5fWuIN4TtcdKncy16s1o64ba-Jsg/gJNOWYIDO2vtJoF7lJK0mpk7aR6P1L8MWSbZsJ9rQVc'), ('width', 175), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Vn-DIRxyaV4bgP1dWHA9Lw/_BvDCFfXraIZGR1bKqI3vaVTWKm1WBQTGXuQkZjYGrM5p728O0cABaj1nWxjaL_R9CDH_58WaZ5xUvw7zFTkbw/O-glZ4jbBU9kLYVIEduIMx0nkdbUceugmSDGezeiho4'), ('width', 495), ('height', 102)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/67nJjWWVEdTu5HmkZFsNLQ/yr2yiJrxd7hOqW8I6FCv2pmjSLiEvNVLFN-BGYMDsfH9XkViVvGZlnoBHas8fOVn4H5k8_8RgtdepsASuIE5gQ/BZNNpFxPpt6kjcjuP-ENVuF164bK1WfBgzRufL0LIsY'), ('width', 3000), ('height', 3000)]))]))])]",http://www.americanmagnetics.com/brochures/model430.pdf,https://github.com/pymeasure/pymeasure/blob/master/pymeasure/instruments/ami/ami430.py,https://pymeasure.readthedocs.io/en/latest/api/instruments/ami/ami430.html,,"
",,,"#
# This file is part of the PyMeasure package.
#
# Copyright (c) 2013-2023 PyMeasure Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from pymeasure.instruments import Instrument
from time import sleep, time

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


class AMI430(Instrument):
    """""" Represents the AMI 430 Power supply
    and provides a high-level for interacting with the instrument.

    .. code-block:: python

        magnet = AMI430(""TCPIP::web.address.com::7180::SOCKET"")


        magnet.coilconst = 1.182                 # kGauss/A
        magnet.voltage_limit = 2.2               # Sets the voltage limit in V

        magnet.target_current = 10               # Sets the target current to 10 A
        magnet.target_field = 1                  # Sets target field to 1 kGauss

        magnet.ramp_rate_current = 0.0357       # Sets the ramp rate in A/s
        magnet.ramp_rate_field = 0.0422         # Sets the ramp rate in kGauss/s
        magnet.ramp                             # Initiates the ramping
        magnet.pause                            # Pauses the ramping
        magnet.status                           # Returns the status of the magnet

        magnet.ramp_to_current(5)             # Ramps the current to 5 A

        magnet.shutdown()                     # Ramps the current to zero and disables output

    """"""

    def __init__(self, adapter, name=""AMI superconducting magnet power supply."", **kwargs):
        kwargs.setdefault('read_termination', '\n')
        super().__init__(
            adapter,
            name,
            includeSCPI=True,
            **kwargs
        )
        # Read twice in order to remove welcome/connect message
        self.read()
        self.read()

    maximumfield = 1.00
    maximumcurrent = 50.63

    coilconst = Instrument.control(
        ""COIL?"", ""CONF:COIL %g"",
        """""" A floating point property that sets the coil contant
        in kGauss/A. """"""
    )

    voltage_limit = Instrument.control(
        ""VOLT:LIM?"", ""CONF:VOLT:LIM %g"",
        """""" A floating point property that sets the voltage limit
        for charging/discharging the magnet. """"""
    )

    target_current = Instrument.control(
        ""CURR:TARG?"", ""CONF:CURR:TARG %g"",
        """""" A floating point property that sets the target current
        in A for the magnet. """"""
    )

    target_field = Instrument.control(
        ""FIELD:TARG?"", ""CONF:FIELD:TARG %g"",
        """""" A floating point property that sets the target field
        in kGauss for the magnet. """"""
    )

    ramp_rate_current = Instrument.control(
        ""RAMP:RATE:CURR:1?"", ""CONF:RAMP:RATE:CURR 1,%g"",
        """""" A floating point property that sets the current ramping
        rate in A/s. """"""
    )

    ramp_rate_field = Instrument.control(
        ""RAMP:RATE:FIELD:1?"", ""CONF:RAMP:RATE:FIELD 1,%g,1.00"",
        """""" A floating point property that sets the field ramping
        rate in kGauss/s. """"""
    )

    magnet_current = Instrument.measurement(""CURR:MAG?"",
                                            """""" Reads the current in Amps of the magnet.
        """"""
                                            )

    supply_current = Instrument.measurement(""CURR:SUPP?"",
                                            """""" Reads the current in Amps of the power supply.
        """"""
                                            )

    field = Instrument.measurement(""FIELD:MAG?"",
                                   """""" Reads the field in kGauss of the magnet.
        """"""
                                   )

    state = Instrument.measurement(""STATE?"",
                                   """""" Reads the field in kGauss of the magnet.
        """"""
                                   )

    def zero(self):
        """""" Initiates the ramping of the magnetic field to zero
        current/field with ramping rate previously set. """"""
        self.write(""ZERO"")

    def pause(self):
        """""" Pauses the ramping of the magnetic field. """"""
        self.write(""PAUSE"")

    def ramp(self):
        """""" Initiates the ramping of the magnetic field to set
        current/field with ramping rate previously set.
        """"""
        self.write(""RAMP"")

    def has_persistent_switch_enabled(self):
        """""" Returns a boolean if the persistent switch is enabled. """"""
        return bool(self.ask(""PSwitch?""))

    def enable_persistent_switch(self):
        """""" Enables the persistent switch. """"""
        self.write(""PSwitch 1"")

    def disable_persistent_switch(self):
        """""" Disables the persistent switch. """"""
        self.write(""PSwitch 0"")

    @property
    def magnet_status(self):
        STATES = {
            1: ""RAMPING"",
            2: ""HOLDING"",
            3: ""PAUSED"",
            4: ""Ramping in MANUAL UP"",
            5: ""Ramping in MANUAL DOWN"",
            6: ""ZEROING CURRENT in progress"",
            7: ""QUENCH!!!"",
            8: ""AT ZERO CURRENT"",
            9: ""Heating Persistent Switch"",
            10: ""Cooling Persistent Switch""
        }
        return STATES[self.state]

    def ramp_to_current(self, current, rate):
        """""" Heats up the persistent switch and
        ramps the current with set ramp rate.
        """"""
        self.enable_persistent_switch()

        self.target_current = current
        self.ramp_rate_current = rate

        self.wait_for_holding()

        self.ramp()

    def ramp_to_field(self, field, rate):
        """""" Heats up the persistent switch and
        ramps the current with set ramp rate.
        """"""
        self.enable_persistent_switch()

        self.target_field = field

        self.ramp_rate_field = rate

        self.wait_for_holding()

        self.ramp()

    def wait_for_holding(self, should_stop=lambda: False,
                         timeout=800, interval=0.1):
        """"""
        """"""
        t = time()
        while self.state != 2 and self.state != 3 and self.state != 8:
            sleep(interval)
            if should_stop():
                return
            if (time() - t) > timeout:
                raise Exception(""Timed out waiting for AMI430 switch to warm up."")

    def shutdown(self, ramp_rate=0.0357):
        """""" Turns on the persistent switch,
        ramps down the current to zero, and turns off the persistent switch.
        """"""
        self.enable_persistent_switch()
        self.wait_for_holding()
        self.ramp_rate_current = ramp_rate
        self.zero()
        self.wait_for_holding()
        self.disable_persistent_switch()
        super().shutdown()
"
255,38.0,Switzerland,"The Zurich Instruments SHFQA Quantum Analyzer integrates in a single instrument a full real-time readout setup for up to 64 superconducting and spin qubits. The SHFQA operates in a frequency range from 0.5 to 8.5 GHz with a clean analysis bandwidth of 1 GHz and without the need for mixer calibration. Each of its 2 or 4 readout channels can analyze up to 16 qubits, 8 qutrits or 5 ququads",Shfqa,644.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a SHFQA ,,,,SHFQA,https://docs.zhinst.com/pdf/ziSHFQA_UserManual.pdf,"[OrderedDict([('id', 'att7OJNJrUZgJN1xR'), ('width', 1183), ('height', 425), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0SqpaLjLAUjN-8UZZ6oanw/gsQF5IDxQw6DQszkYJ843wH4c4ZMMIOy5reoGYaw5KdK8zq7aaRCt0ag4urtMGpX1GWxwyDXfbnknHx1ClCP4pul-ugsx1ykwy3jS46XCFu3_ER5ANRE4bgqr11tAlQ2/FuXiHYelQBpPU8pnQ-NCm3Tk9l7rjQT04rcg_NtK0Fs'), ('filename', 'SHFQA_schraeg_2800.jpg.webp'), ('size', 36126), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/3L6ubAUqCnzDfBV0LLJhhQ/TOL1cfPWI6FIwmWNaAKXT_5gbwsR6q5BNvjc6BXzzIOYG0tH7ASDOAzh5o6h130nVsjZmBFtIA78UZsm4YXLoTICI3S3pfOXEFyo5F5e3KM/FC_DtvlBMrGCwX-9tnM_HroK4SEXODS0rK8NdQqocYE'), ('width', 100), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iGIutwE1OpLI8z2nw0dH-Q/o11A8jZsUhv7x5eY_1q6pKylQwCioxtLojdTsQB2D77BnX1CxxRLGP7hWU6ZApGhSZ2u3YhVVt5-7IsjBkvq0JnhPQlp0scEyf87YK-lt9Y/IaFOvd8lrLZ-UPZBq2QfVcQjFV2HS9bkGHuzPqzDLhs'), ('width', 1183), ('height', 425)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/O7kmbO2Wh2RQNDpIC_d9oQ/d8yArNNEQ-eiqVWbtAZUp8L1JoI5gcbtsZWty-sQCpWwngnUASuRPlcu3bJQGeYC3ev2yzq15yUHU5rVbC0aYW5PPDR2POp7lfawJGzA8Ns/wl-5mljrdMypVJ952uXX220xk7eaIoi4nhxuObnXnoY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/shfqa-quantum-analyzer,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfqa.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfqa.html,,,,,"""""""Autogenerated module for the SHFQA QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
import numpy as np
from zhinst.toolkit import Sequence, Waveforms
from zhinst.toolkit.interface import AveragingMode, SHFQAChannelMode
from zhinst.utils.shfqa.multistate import QuditSettings
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class Generator(ZINode):
    """"""Generator node.

    Implements basic functionality of the generator allowing the user to write
    and upload their *'.seqC'* code.

    In contrast to other AWG Sequencers, e.g. from the HDAWG, SHFSG
    it does not provide writing access to the Waveform Memories
    and hence does not come with predefined waveforms such as `gauss`
    or `ones`. Therefore, all waveforms need to be defined in Python
    and uploaded to the device using `upload_waveforms` method.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""generator"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, pulses: Union[Waveforms, dict], *, clear_existing: bool = True
    ) -> None:
        """"""Writes pulses to the waveform memory.

        Args:
            pulses: Waveforms that should be uploaded.
            clear_existing: Flag whether to clear the waveform memory before the
                present upload. (default = True)
        """"""
        return self._tk_object.write_to_waveform_memory(
            pulses=pulses, clear_existing=clear_existing
        )

    def read_from_waveform_memory(self, slots: List[int] = None) -> Waveforms:
        """"""Read pulses from the waveform memory.

        Args:
            slots: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Mutable mapping of the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(slots=slots)

    def configure_sequencer_triggering(
        self, *, aux_trigger: str, play_pulse_delay: float = 0.0
    ) -> None:
        """"""Configure the sequencer triggering.

        Args:
            aux_trigger: Alias for the trigger source used in the sequencer.
                For the list of available values, use `available_aux_trigger_inputs`
            play_pulse_delay: Delay in seconds before the start of waveform playback.
        """"""
        return self._tk_object.configure_sequencer_triggering(
            aux_trigger=aux_trigger, play_pulse_delay=play_pulse_delay
        )

    @property
    def available_aux_trigger_inputs(self) -> List:
        """"""List of available aux trigger sources for the generator.""""""
        return self._tk_object.available_aux_trigger_inputs


class Qudit(ZINode):
    """"""Single Qudit node.

    Implements basic functionality of a single qudit node, e.g applying the
    basic configuration.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        readout_channel: Index of the readout channel this qudit belongs to.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qudit_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def configure(self, qudit_settings: QuditSettings, enable: bool = True) -> None:
        """"""Compiles a list of transactions to apply the qudit settings to the device.

        Args:
            qudit_settings: The qudit settings to be configured.
            enable: Whether to enable the qudit. (default: True)

        """"""
        return self._tk_object.configure(qudit_settings=qudit_settings, enable=enable)


class MultiState(ZINode):
    """"""MultiState node.

    Implements basic functionality of the MultiState node.

    Args:
        root: Root of the nodetree.
        tree: Tree (node path as tuple) of the current node.
        serial: Serial of the device.
        index: Index of the corresponding readout channel.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""multistate"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.qudits:

            channel_list = ZIChannelList(
                self,
                ""qudits"",
                Qudit,
                zi_node=self._tk_object.qudits.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qudits):
                channel_list.append(
                    Qudit(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qudits[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qudits"", channel_list)

    def get_qudits_results(self) -> Dict[int, np.ndarray]:
        """"""Downloads the qudit results from the device and group them by qudit.

        This function accesses the multistate nodes to determine which
        integrators were used for which qudit to able to group the results by
        qudit.

        Returns:
            A dictionary with the qudit index keys and result vector values.
        """"""
        return self._tk_object.get_qudits_results()


class Readout(ZINode):
    """"""Readout node.

    Implements basic functionality of the readout, e.g allowing the user to
    write the integration weight.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
        max_qubits_per_channel: Max qubits per channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""readout"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.multistate:

            self.add_submodule(
                ""multistate"",
                MultiState(
                    self,
                    self._tk_object.multistate,
                    zi_node=self._tk_object.multistate.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_result_logger(
        self,
        *,
        result_source: str,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for readout mode.

        Args:
            result_source: String-based tag to select the result source in readout
                mode, e.g. ""result_of_integration"" or ""result_of_discrimination"".
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n
            averaging_mode: Select the averaging order of the result, with
                0 = cyclic and 1 = sequential.
        """"""
        return self._tk_object.configure_result_logger(
            result_source=result_source,
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Reset and enable the result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: The result logger could not been stopped within the
                given time.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until the readout is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Readout
                (default: 10).
            sleep_time: Sleep interval in seconds. (default = 0.05)

        Raises:
            TimeoutError: if the readout recording is not completed within the
                given time.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            Result logger data.
        """"""
        return self._tk_object.read(timeout=timeout)

    def write_integration_weights(
        self,
        weights: Union[Waveforms, dict],
        *,
        integration_delay: float = 0.0,
        clear_existing: bool = True,
    ) -> None:
        """"""Configures the weighted integration.

        Args:
            weights: Dictionary containing the complex weight vectors, where
                keys correspond to the indices of the integration units to be
                configured.
            integration_delay: Delay in seconds before starting the readout.
                (default = 0.0)
            clear_existing: Flag whether to clear the waveform memory before
                the present upload. (default = True)
        """"""
        return self._tk_object.write_integration_weights(
            weights=weights,
            integration_delay=integration_delay,
            clear_existing=clear_existing,
        )

    def read_integration_weights(self, slots: List[int] = None) -> Waveforms:
        """"""Read integration weights from the waveform memory.

        Args:
            slots: List of weight slots to read from the device. If not specified
                all available weights will be downloaded.

        Returns:
            Mutable mapping of the downloaded weights.
        """"""
        return self._tk_object.read_integration_weights(slots=slots)


class Spectroscopy(ZINode):
    """"""Spectroscopy node.

    Implements basic functionality of the spectroscopy, e.g allowing the user to
    read the result logger data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        serial: Serial of the device.
        index: Index of the corresponding awg channel
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""spectroscopy"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def configure_result_logger(
        self,
        *,
        result_length: int,
        num_averages: int = 1,
        averaging_mode: AveragingMode = AveragingMode.CYCLIC,
    ) -> None:
        """"""Configures the result logger for spectroscopy mode.

        Args:
            result_length: Number of results to be returned by the result logger
            num_averages: Number of averages, will be rounded to 2^n.
            averaging_mode: Averaging order of the result.
        """"""
        return self._tk_object.configure_result_logger(
            result_length=result_length,
            num_averages=num_averages,
            averaging_mode=averaging_mode,
        )

    def run(self) -> None:
        """"""Resets and enables the spectroscopy result logger.""""""
        return self._tk_object.run()

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Stop the result logger.

        Args:
            timeout: The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time: Time in seconds to wait between
                requesting Spectroscopy state
        Raises:
            TimeoutError: If the result logger could not been stopped within the
                given time.

        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.05) -> None:
        """"""Wait until spectroscopy is finished.

        Args:
            timeout (float): The maximum waiting time in seconds for the
                Spectroscopy (default: 10).
            sleep_time (float): Time in seconds to wait between
                requesting Spectroscopy state

        Raises:
            TimeoutError: if the spectroscopy recording is not completed within the
                given time.

        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def read(self, *, timeout: float = 10) -> np.array:
        """"""Waits until the logger finished recording and returns the measured data.

        Args:
            timeout: Maximum time to wait for data in seconds (default = 10s)

        Returns:
            An array containing the result logger data.

        """"""
        return self._tk_object.read(timeout=timeout)


class QAChannel(ZINode):
    """"""Quantum Analyzer Channel for the SHFQA.

    :class:`QAChannel` implements basic functionality to configure QAChannel
    settings of the :class:`SHFQA` instrument.
    Besides the :class:`Generator`, :class:`Readout` and :class:`Sweeper`
    modules it also provides an easy access to commonly used `QAChannel` parameters.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""qachannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.generator:

            self.add_submodule(
                ""generator"",
                Generator(
                    self,
                    self._tk_object.generator,
                    zi_node=self._tk_object.generator.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.readout:

            self.add_submodule(
                ""readout"",
                Readout(
                    self,
                    self._tk_object.readout,
                    zi_node=self._tk_object.readout.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

        if self._tk_object.spectroscopy:

            self.add_submodule(
                ""spectroscopy"",
                Spectroscopy(
                    self,
                    self._tk_object.spectroscopy,
                    zi_node=self._tk_object.spectroscopy.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self,
        *,
        input_range: int,
        output_range: int,
        center_frequency: float,
        mode: SHFQAChannelMode,
    ) -> None:
        """"""Configures the RF input and output of a specified channel.

        Args:
            input_range: Maximal range of the signal input power in dBm
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency of the analysis band [Hz]
            mode: Select between spectroscopy and readout mode.
        """"""
        return self._tk_object.configure_channel(
            input_range=input_range,
            output_range=output_range,
            center_frequency=center_frequency,
            mode=mode,
        )


class SHFScope(ZINode):
    """"""SHFQA Scope Node.

    Implements basic functionality of the scope node, e.g allowing the user to
    read the data.

    Args:
        root: Root of the nodetree
        tree: Tree (node path as tuple) of the current node
        daq_server: Instance of the ziDAQServer
        serial: Serial of the device.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""shfscope_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object

    def run(
        self, *, single: bool = True, timeout: float = 10, sleep_time: float = 0.005
    ) -> None:
        """"""Run the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not start within the specified
                timeout.
        """"""
        return self._tk_object.run(
            single=single, timeout=timeout, sleep_time=sleep_time
        )

    def stop(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Stop the scope recording.

        Args:
            timeout: The maximum waiting time in seconds for the scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not stop within the specified
                timeout.
        """"""
        return self._tk_object.stop(timeout=timeout, sleep_time=sleep_time)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the scope recording is finished.

        Args:
            timeout: The maximum waiting time in seconds for the Scope
                (default = 10).
            sleep_time: Time in seconds to wait between requesting the progress
                and records values (default = 0.005).

        Raises:
            TimeoutError: The scope did not finish within the specified
                timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def configure(
        self,
        *,
        input_select: Dict[int, str],
        num_samples: int,
        trigger_input: str,
        num_segments: int = 1,
        num_averages: int = 1,
        trigger_delay: float = 0,
    ) -> None:
        """"""Configures the scope for a measurement.

        Args:
            input_select: Map of a specific scope channel an their signal
                source, e.g. ""channel0_signal_input"". (For a list of available
                values use `available_inputs`)
            num_samples: Number samples to recorded in a scope shot.
            trigger_input: Specifies the trigger source of the scope
                acquisition - if set to None, the self-triggering mode of the
                scope becomes active, which is useful e.g. for the GUI.
                For a list of available trigger values use
                `available_trigger_inputs`.
            num_segments: Number of distinct scope shots to be returned after
                ending the acquisition.
            num_averages: Specifies how many times each segment should be
                averaged on hardware; to finish a scope acquisition, the number
                of issued triggers must be equal to num_segments * num_averages.
            trigger_delay: delay in samples specifying the time between the
                start of data acquisition and reception of a trigger.
        """"""
        return self._tk_object.configure(
            input_select=input_select,
            num_samples=num_samples,
            trigger_input=trigger_input,
            num_segments=num_segments,
            num_averages=num_averages,
            trigger_delay=trigger_delay,
        )

    def read(self, *, timeout: float = 10) -> tuple:
        """"""Read out the recorded data from the scope.

        Args:
            timeout: The maximum waiting time in seconds for the
                Scope (default: 10).

        Returns:
            (recorded_data, recorded_data_range, scope_time)

        Raises:
            TimeoutError: if the scope recording is not completed before
                timeout.
        """"""
        return self._tk_object.read(timeout=timeout)

    @property
    def available_trigger_inputs(self) -> List:
        """"""List of the available trigger sources for the scope.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_inputs(self) -> List:
        """"""List of the available signal sources for the scope channels.""""""
        return self._tk_object.available_inputs


class SHFQA(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFQA.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.qachannels:

            channel_list = ZIChannelList(
                self,
                ""qachannels"",
                QAChannel,
                zi_node=self._tk_object.qachannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.qachannels):
                channel_list.append(
                    QAChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.qachannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""qachannels"", channel_list)

        if self._tk_object.scopes:

            channel_list = ZIChannelList(
                self,
                ""scopes"",
                SHFScope,
                zi_node=self._tk_object.scopes.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.scopes):
                channel_list.append(
                    SHFScope(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.scopes[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""scopes"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)

    def start_continuous_sw_trigger(
        self, *, num_triggers: int, wait_time: float
    ) -> None:
        """"""Issues a specified number of software triggers.

        Issues a specified number of software triggers with a certain wait time
        in between. The function guarantees reception and proper processing of
        all triggers by the device, but the time between triggers is
        non-deterministic by nature of software triggering. Only use this
        function for prototyping and/or cases without strong timing requirements.

        Args:
            num_triggers: Number of triggers to be issued
            wait_time: Time between triggers in seconds
        """"""
        return self._tk_object.start_continuous_sw_trigger(
            num_triggers=num_triggers, wait_time=wait_time
        )

    @property
    def max_qubits_per_channel(self) -> int:
        """"""Maximum number of supported qubits per channel.""""""
        return self._tk_object.max_qubits_per_channel
"
257,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34460 A Submodules,272.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34460A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34460A Submodules,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,"[OrderedDict([('id', 'attTDYiHi8Rpe5jnV'), ('width', 3375), ('height', 1654), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/3I1IOBRJurQirchKNnLpfA/VNJZ9mc3wz9UZRJDLs1caLvQUeMcpVYLCXxUFsiN4TDNNEU-4GJgxptNaUW73OeEfEZlmx_pRQfVIB1mqfcvnfKW0Qg7KLt21A8RqNNbATM/c6QtKikGSqY14uUearEEdS_5NM4ykRgQ2c-z2957PIc'), ('filename', '5122197.jpg'), ('size', 372225), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ml5f4FkEEAuNi90Jo9YuiA/ZyXdyuHqqxODaNWU8auY0cXzojtzN_8_TLipNpoAsZEft7WjoAPUl3Shdyz6IjhPAHmh5v5ZA3y3PBMmxVcWVQ/dOEwRWi26XrEmJ62GwgMviQJ9vmQ8NdS9zgpQ-MEw3g'), ('width', 73), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EZ7bhepHm-BFDACoc52A8w/yDEa7ng6ZOpOevDTGf7D75YsEf65O68VvQoVbMfXUnUrpJFCLhKpVM0-pe5PG1n2yEHyMfa1FGUQxsxQbWHb3w/N2-jXQLdPiJSXr7mMEHqtrJt7fYdEev-gH-snpBtvBc'), ('width', 1045), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e_btkAR8cmiySI47fSujRQ/kSAN1KdZk_ah0rZ5ajPcrbrxHEfALW1opXHBeLV9_K0_dKdZ4hhlqBUm8uiJdJBDgcIzZehDfl6m6clB1nJMzg/BirBrFsnfEeFNXfHEZInQk5PZLjC-cGPkgqxgT9OpUk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_34411A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34411A,,,,,"from typing import Any
from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight_34411A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34411A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)
"
259,23.0,"Beijing, China","The Rigol DP821 is a dual channel, remote sense programmable DC Power Supply. It has excellent performance, including various analysis functions and has USB Host and Device with LXI option. All of this makes it suitable to meet a wide range of testing requirements.",DP 821,447.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DP821 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Rigol DP821,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,"[OrderedDict([('id', 'attsXnQPDRocpX3ki'), ('width', 306), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/x5NV7e6WHUo_KEKfkEXBWQ/uaUOojFZ-ra4KeV8x97gU-aTnxYeMQBG26EvNBjAeENiN5KQyicWzp-wTovdoCYFT9pS7ATK9sBhV6tQIobgm5zpvuCWK0POevQcNQCib-s/XO04h8ZewjuAt_IN9UWAnhP3rbtbpBURkyFK5oJPvcg'), ('filename', 'PH-DP821.jpg'), ('size', 32141), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hJj0ySRtPDQKr1x2PJkeMg/hSg-zVetZTOrHz2FxYXqpZ_KwCft0TsgpxQNmUw30O5Zyo1KPRJYZhUVh4ZQ_wSSQgvA028u8U-NeB7hrkMv8Q/qG0gpgGsm5Ij_hJrz37d9QhjewDQY9r08lNnFWCNdww'), ('width', 55), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wRL0A1wObmGEjZwKh5TYmQ/TFxZsuLxrLd4-DdMHoiPcgLul3ngUsXEiMyPP4DoRQySBTOn3POGc7gQyJlKBFjRZXksD_ziBQjUbcInY6P2Cg/whGa6Cu2SbHm1gYV3M04BjfgB5zqF4Zd24c36ljrJvs'), ('width', 306), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/f56y9siRVFbjhDoOmzxffg/8vagIRehSk1N3o_ILOM9kJzOus0Px_qFEP_MoD7jOYjw2NEKT4JD-9fQaUvmhXz5yGqajE3S2JN6nb_yqV88GA/wL83kpqip1h_C6NPa6w55bUTgoAWVGUchV1k8xBmOzU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lambdaphoto.co.uk/dp821-140w-dc-power-supply.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP821.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP821,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP821(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP821(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [
            (60.0, 1.0),
            (8.0, 10.0),
        ]

        ovp_ranges_std = [(0.01, 66.0), (0.01, 8.8)]
        ocp_ranges_std = [(0.01, 1.1), (0.01, 11)]

        ovp_ranges_precision = [(0.001, 66.0), (0.001, 8.8)]
        ocp_ranges_precision = [(0.001, 1.1), (0.001, 11)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
261,5420.0,USA,"The Keysight N5173B EXG microwave analog signal generator is the cost-effective choice when you need to balance budget and performance. It provides the essential signals that address parametric testing of broadband filters, amplifiers, receivers, and more. Perform basic LO upconversion or CW blocking with low-cost coverage to 13, 20, 31.8, or 40 GHz. Characterize broadband microwave components such as filters and amplifiers with the best combination of output power (+20 dBm at 20 GHz), low harmonics (≤ –55 dBc), and full step attenuation. Use as a high-stability system reference with standard high-performance OCXO at an aging rate of less than ± 5 parts per billion per day.",Keysight N 5173 B,277.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5173B EXG RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT N5173B EXG,https://www.keysight.com/us/en/assets/7018-04097/data-sheets/5991-3132.pdf,"[OrderedDict([('id', 'attcBHJrJvHu6fqnl'), ('width', 800), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ICXgUxyz0r18lcnvtUQqqw/kds1qQyi_JZZa95bHaxkp0mbue2mA2PNGWkwV4UC-aO_sNDzqFCqpeUkcbpH01H1TDYkGAFdf88IUL6CYbAesCr7D341SAjbiVEhea_IXcw4XlMKtpMMuzYRNLq4IqYjJK5gztC8pu_uWF8IpXSIV5f1bNbBLnfvfnS0SyTIyZJqOwJltkWM1MmsIYLcSdV9/5xOFo1nuGTL7-djCGjiJGbqJ8d12h6ZqKSNODpTlfME'), ('filename', '0005557_keysight-n5173b-exg-x-series-microwave-analog-signal-generator.png'), ('size', 160786), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7GC-zkKwYCruAAvPLAcvlw/JGg5zzoSJvFWApT2awQS9_8XyDGPNJTh3MiZxiUyHZL368KEY4-2ZPFLnDN4H5IniO1miZ7XxthEgMoi1iy65g/9ebXx2BNG2Asfy7D1eruuVFndl8EYw_Zj7eDlR8Ti3U'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kVZyA7LqOJPA7ZJWI5IwyQ/Fkwf-Uz6xin59_ofQ1KWFKB8siiF5w-K-xbOvd3A4zFoxB64_4G9f6ihuiamvrT-RrRtorW0sWZcuLbtT7F_-g/ktcq4qw_ScHUcKnYylVKVLK3LvTTrTA_RXPLXY2wzXo'), ('width', 800), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6h8lqf8A2eIK2JS8ZSlzXA/4nvUvhC1ldXhPL4XIfm2YDhgBKXKc8CnG6cdbMHyDGZUbPGT0-qa9oCtnBdzP0MdScgdvO460hZAu4HJU5DrBg/ZLX64oCiwkb8gWJ8jAuqM_0XHIjSb4uPQwU7yOM_uTY'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/N5173B/exg-x-series-microwave-analog-signal-generator-9-khz-40-ghz.html,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N51x1.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5173B,37065.0,,,,"from typing import Any, Dict, Optional

from qcodes import VisaInstrument
from qcodes.utils.validators import Numbers


class N51x1(VisaInstrument):
    """"""
    This is the qcodes driver for Keysight/Agilent scalar RF sources.
    It has been tested with N5171B, N5181A, N5171B, N5183B
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\n', **kwargs)

        self.add_parameter('power',
                           label='Power',
                           get_cmd='SOUR:POW?',
                           get_parser=float,
                           set_cmd='SOUR:POW {:.2f}',
                           unit='dBm',
                           vals=Numbers(min_value=-144,max_value=19))

        # Query the instrument to see what frequency range was purchased
        freq_dict = {'501':1e9, '503':3e9, '505':6e9, '520':20e9}

        max_freq = freq_dict[self.ask('*OPT?')]
        self.add_parameter('frequency',
                           label='Frequency',
                           get_cmd='SOUR:FREQ?',
                           get_parser=float,
                           set_cmd='SOUR:FREQ {:.2f}',
                           unit='Hz',
                           vals=Numbers(min_value=9e3,max_value=max_freq))

        self.add_parameter('phase_offset',
                           label='Phase Offset',
                           get_cmd='SOUR:PHAS?',
                           get_parser=float,
                           set_cmd='SOUR:PHAS {:.2f}',
                           unit='rad'
                           )

        self.add_parameter('rf_output',
                           get_cmd='OUTP:STAT?',
                           set_cmd='OUTP:STAT {}',
                           val_mapping={'on': 1, 'off': 0})

        self.connect_message()

    def get_idn(self) -> Dict[str, Optional[str]]:
        IDN_str = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDN_str.split(','))
        IDN: Dict[str, Optional[str]] = {
            'vendor': vendor, 'model': model,
            'serial': serial, 'firmware': firmware}
        return IDN
"
262,5420.0,USA,"P9374A Keysight Streamline USB Vector Network Analyzer, 20 GHz. Compact, faceless, USB vector network analyzer (VNA). Affordable full two-port VNA which dramatically reduces your size of test. Up to 20 GHz.",Keysight P 9374 A,338.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT P9374A Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT P9374A,https://www.keysight.com/us/en/assets/7018-06033/data-sheets/5992-2765.pdf,"[OrderedDict([('id', 'attSzJiFgDoctjaFu'), ('width', 2000), ('height', 1072), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tG8NNPIEF2BNl05GjRQygw/vA9lP546MN8D0R_b9w4kTS0wxLibBUpPHfMdoFxxgoF1foKq9H6oWUkO1LUDpWOTfaQqI-tfnjtOZUoWJsL_R8ZRIouc8_6oh3V2ScSV7JA/SweUp0d6qy4C0s0-XHmZrI65scAYCEDns3ttuyajODc'), ('filename', 'P9374A.jpeg'), ('size', 208353), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qYEGX8P0bBYdXKNC8nafHw/GZVcBsVH_ldtJrl3Z78lP1RoUnicffunTOJO7dmCy-OsiW_mvGJylgj0G3nTomgYzdraABKYr_RAm9G9V7WP5Q/_F7SJovxvJRYHVofISXZG4Ry4unn-O5C7tUK2G6sq1A'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vTcHO5yWeeyUVgeg4vZdzQ/oRfgz9Y5aUkAZgyx0o3fOrZP03-NQjsiicPXH_BF5XfYmPN6s07X8mFTjJ674-DSkXfQqXsBWEkqoRzJ-EV-uQ/givRsXYlfOmrM_FSDhjbT8EYjhSQGE6hu4V8JITwSTs'), ('width', 955), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tmzxWV6AbINmUi0evUkK3g/E0cxl-6O1ImmeFAocZaT0omyvRTXXKIfhwwGY5GNir-ps8ci439XWa9epo6owYpKbZ1hI8zMsaKbkSGPu0YW1w/fZe7SIRWKTTl-LzVTdLJ_XhwByXHZ2yAWKggqT5cjLo'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/P9374A/streamline-usb-vector-network-analyzer-20-ghz.html#:~:text=P9374A%20Keysight%20Streamline%20USB%20Vector%20Network%20Analyzer%2C%2020%20GHz,-Use%20%2B%20and%20%2D%20keys&text=Compact%2C%20faceless%2C%20USB%20vector%20network,Up%20to%2020%20GHz.",https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_P9374A.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightP9374A,33150.0,,,,"from typing import Any

from . import N52xx

#  This is not the same class of Keysight devices but seems to work well...


class KeysightP9374A(N52xx.PNAxBase):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(
            name,
            address,
            min_freq=300e6,
            max_freq=20e9,
            min_power=-43,
            max_power=20,
            nports=2,
            **kwargs
        )

        self.get_options()
"
270,2.0,"COPENHAGEN, DENMARK","The original and popular QDAC from QDevil is a high-precision low-noise computer-controlled voltage generator designed for DC and low-frequency control of high impedance devices, such as gates in quantum electronics and quantum computer qubits. It also comes in a “high-current” version which can source up to 10 mA, for example for flux biasing of superconducting qubits. In addition to precise and stable voltage output, the QDAC can measure output currents, for example, to detect leaking gates or shorted bonding wires. The QDAC originates from the laboratories of the Center for Quantum Devices at the University of Copenhagen, where it is used for quantum computing research. The QDAC has 24 channels and offers a cost-effective way of getting many high-quality D/A converter channels.",Qdevil Qdac,422.0,"Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",Qcodes,Qdevil,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Iaef-6NIciOWKsa10JxRkQ/2GD5HG7BPockb2ex1jGFrrTiU7BBCn-BUh4yFbVUC5HnbjZi95IkzXzO47AqXvh4ovR1NzYgfo7u3K7F-Iy8CnFqjwnWhHdoP_drQzUgyBk/oOtNVvCMSwDpcFzmES9UhD5dKEVKxrogflaoIXeeec8'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FEuZ28mowNgi5RsJVepsLA/nE8QsdJyxc7HF5HxYg-4FFyeNkCTIKwJqjAwoaeytJ-iQqogaf-JVLfsCMLSML3dXxikZxzR6Rup1FkWKPSsp6TdH_lwDt2uwXfZZObRFaw/Mr8sxOK6ErffdVcGCGd9Noq-q8_R0fFznaYT4z6B90Y'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bc9p_dlutAJiwDTZk-lRuA/xZRaVdQKhbsxI4GHc1mwsR36JbnSB5oSf8NvVCn4V_nuitBVHtQnG-gO3jON58ALpa1lVZoXLx1CboupbmfRHo3f8f4YYwqAuWrV1agWFVk/kFtddMZcEdyeo4wkQWKEZgqJAOXxNMFF7M0ly33iR-U'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZWUIK3fC6Wb-Ng9czNLYlA/m5_LISZrGWJewXrhSx_993pJ9dPAO2-JAj8Mg-w58KQZkiDxtbCozX6QJOc4ji80rHiwF-hC-y3R2Iq50RB-K7PdX7GbvFYACEcEIz4kCkg/5N7AzqvO5ZJj-aPr-dLGjU-y_oooID3NX9eRPyvp5zE'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,"Write a Python script that uses Qcodes to connect to a QDAC Power Supplies, Digital-Analog Converter",https://en.wikipedia.org/wiki/Electric_generator,"['Power Supplies', 'Digital-Analog Converter']","In electricity generation, a generator[1] is a device that converts motive power (mechanical energy) or fuel-based power (chemical energy) into electric power for use in an external circuit. Sources of mechanical energy include steam turbines, gas turbines, water turbines, internal combustion engines, wind turbines and even hand cranks. The first electromagnetic generator, the Faraday disk, was invented in 1831 by British scientist Michael Faraday. Generators provide nearly all of the power for electric power grids.",QDAC,,"[OrderedDict([('id', 'attJwDhnnFpXdEJS9'), ('width', 768), ('height', 512), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EJXj9qJB4ZiPzaXy_tPZxg/bnA6rl1BQ3r62xjjtumfNYOoW9v54Gr4oYt_Vft5y-0LcniaACdcFT-9TZDhrnLVqI7BDP4CqnPxOC-zNqi6nLsj9ip3BpvYLLGGeTsKPj4/D-WKi9MyLBwlJkcFvhZwGWX0LgwBhasoslmmhw_JcXQ'), ('filename', 'QDAC24_1024-768x512.png'), ('size', 70154), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AXGsoDAA55a0_ziJNTX8Cw/eUhfjH0s3MlSQ2uHrZcZt1PoDdEHLADYVUdZu0ghun1svzsOeqe-VFU2ceVdfPWsDYCAW8PrcLzXajaq4V4YMw/tm0YwyQTL9ahUPCMudDejn-44QvimqrF_zAShr9_yto'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/cOqExrHDx3NEP-VG2IbbBQ/a4_oPuNi8j3Z7LngE7MKZ2YAq_lyoaKLtKu4IaQNyQxRNopdVHX1cMMr-lSrryaOO_8PKK17rQhhWE_HGOnO9A/bVZLPNhOa4wEEPl4AMYGQ3CZdh6uzSfU8puCsQwKLoE'), ('width', 768), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rGIUR0ReZg_ks4iLR_ctLQ/wskVA2fHgc7dJTtM43FgRPKpb6nRUmnL2aNNpFOGX9TcuH-wzrnWv_fQxDcZhTSHpuihCaxixHPlQtOLXokJSQ/N6iiC_6gBAW_Tpg152O9PuXzhZNY4hyFu1nGhP5WcSE'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/qdac/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QDevil/QDevil_QDAC.py,https://qcodes.github.io/Qcodes/drivers_api/QDev.html#qcodes.instrument_drivers.QDev.QDevQDac,,,,,"# QCoDeS driver for the QDevil QDAC using channels
# Adapted by QDevil from ""qdev\QDac_channels.py"" in
# the instrument drivers package
# Version 2.1 QDevil 2020-02-10

import logging
import time
from collections import namedtuple
from collections.abc import Sequence
from enum import Enum
from functools import partial
from typing import Any, Optional, Union

import pyvisa
import pyvisa.constants
from pyvisa.resources.serial import SerialInstrument

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import MultiChannelInstrumentParameter, ParamRawDataType
from qcodes.utils import deprecate

LOG = logging.getLogger(__name__)


_ModeTuple = namedtuple('_ModeTuple', 'v i')


class Mode(Enum):
    """"""
    Enum type use as the mode parameter for channels
    defining the combined voltage and current range.

    get_label() returns a text representation of the mode.
    """"""
    vhigh_ihigh = _ModeTuple(v=0, i=1)
    vhigh_ilow = _ModeTuple(v=0, i=0)
    vlow_ilow = _ModeTuple(v=1, i=0)

    def get_label(self) -> str:
        _MODE_LABELS = {
                ""vhigh_ihigh"": ""V range high / I range high"",
                ""vhigh_ilow"": ""V range high / I range low"",
                ""vlow_ilow"": ""V range low / I range low""}
        return _MODE_LABELS[self.name]


class Waveform:
    # Enum-like class defining the built-in waveform types
    sine = 1
    square = 2
    triangle = 3
    staircase = 4
    all_waveforms = [sine, square, triangle, staircase]


class Generator:
    #  Class used in the internal book keeping of generators
    def __init__(self, generator_number: int):
        self.fg = generator_number
        self.t_end = 9.9e9


class QDacChannel(InstrumentChannel):
    """"""
    A single output channel of the QDac.

    Exposes chan.v, chan.i, chan.mode, chan.slope,
    chan.sync, chan.sync_delay, chan.sync_duration.\n
    NB: Set v to zero before changing mode if the
    mode_force lfag is False (default).
    """"""

    def __init__(self, parent: ""QDac"", name: str, channum: int):
        """"""
        Args:
            parent: The instrument to which the channel belongs.
            name: The name of the channel
            channum: The number of the channel (1-24 or 1-48)
        """"""
        super().__init__(parent, name)

        # Add the parameters
        self.add_parameter(name='v',
                           label=f'Channel {channum} voltage',
                           unit='V',
                           set_cmd=partial(self._parent._set_voltage, channum),
                           get_cmd=f'set {channum}',
                           get_parser=float,
                           # Initial range. Updated on init and during
                           # operation:
                           vals=vals.Numbers(-9.99, 9.99)
                           )

        self.add_parameter(name='mode',
                           label=f'Channel {channum} mode.',
                           set_cmd=partial(self._parent._set_mode, channum),
                           get_cmd=None,
                           vals=vals.Enum(*list(Mode))
                           )

        self.add_parameter(name='i',
                           label=f'Channel {channum} current',
                           get_cmd=f'get {channum}',
                           unit='A',
                           get_parser=self._parent._current_parser
                           )

        self.add_parameter(name='slope',
                           label=f'Channel {channum} slope',
                           unit='V/s',
                           set_cmd=partial(self._parent._setslope, channum),
                           get_cmd=partial(self._parent._getslope, channum),
                           vals=vals.MultiType(vals.Enum('Inf'),
                                               vals.Numbers(1e-3, 10000))
                           )

        self.add_parameter(name='sync',
                           label=f'Channel {channum} sync output',
                           set_cmd=partial(self._parent._setsync, channum),
                           get_cmd=partial(self._parent._getsync, channum),
                           vals=vals.Ints(0, 4)  # Updated at qdac init
                           )

        self.add_parameter(name='sync_delay',
                           label=f'Channel {channum} sync pulse delay',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Numbers(0, 10000),
                           initial_value=0
                           )

        self.add_parameter(
                        name='sync_duration',
                        label=f'Channel {channum} sync pulse duration',
                        unit='s',
                        get_cmd=None, set_cmd=None,
                        vals=vals.Numbers(0.001, 10000),
                        initial_value=0.01
                        )

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._parent._update_currents and update
        if update and not self._parent._get_status_performed:
            self._parent._update_cache(update_currents=update_currents)
        # call update_cache rather than getting the status individually for
        # each parameter. This is only done if _get_status_performed is False
        # this is used to signal that the parent has already called it and
        # no need to repeat.
        if params_to_skip_update is None:
            params_to_skip_update = ('v', 'i', 'mode')
        snap = super().snapshot_base(
                            update=update,
                            params_to_skip_update=params_to_skip_update)
        return snap


class QDacMultiChannelParameter(MultiChannelInstrumentParameter):
    """"""
    The class to be returned by __getattr__ of the ChannelList. Here customised
    for fast multi-readout of voltages.
    """"""
    def __init__(self, channels: Sequence[InstrumentChannel],
                 param_name: str,
                 *args: Any,
                 **kwargs: Any):
        super().__init__(channels, param_name, *args, **kwargs)

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        """"""
        Return a tuple containing the data from each of the channels in the
        list.
        """"""
        # For voltages, we can do something slightly faster than the naive
        # approach by asking the instrument for a channel overview.

        if self._param_name == 'v':
            qdac = self._channels[0]._parent
            qdac._update_cache(update_currents=False)
            output = tuple(chan.parameters[self._param_name].cache()
                           for chan in self._channels)
        else:
            output = tuple(chan.parameters[self._param_name].get()
                           for chan in self._channels)

        return output


@deprecate(alternative=""QDevil QDAC 1 driver in qcodes_contrib_drivers."")
class QDac(VisaInstrument):
    """"""
    Channelised driver for the QDevil QDAC voltage source.

    Exposes channels, temperature sensors and calibration output,
    and 'ramp_voltages' + 'ramp_voltages_2d' for multi channel ramping.

    In addition a 'mode_force' flag (default False) is exposed.
    'mode_force' (=True) is used to enable voltage range switching, via
    the channel 'mode' parameter, even at non-zero output voltages.

    Tested with Firmware Version: 1.07

    The driver assumes that the instrument is ALWAYS in verbose mode OFF
    and sets this as part of the initialization, so please do not change this.
    """"""

    # set nonzero value (seconds) to accept older status when reading settings
    max_status_age = 1

    def __init__(self,
                 name: str,
                 address: str,
                 update_currents: bool = False,
                 **kwargs: Any):
        """"""
        Instantiates the instrument.

        Args:
            name: The instrument name used by qcodes
            address: The VISA name of the resource
            update_currents: Whether to query all channels for their
                current sensor value on startup, which takes about 0.5 sec
                per channel. Default: False.

        Returns:
            QDac object
        """"""

        super().__init__(name, address, **kwargs)
        handle = self.visa_handle
        self._get_status_performed = False

        assert isinstance(handle, SerialInstrument)
        # Communication setup + firmware check
        handle.baud_rate = 460800
        handle.parity = pyvisa.constants.Parity(0)
        handle.data_bits = 8
        self.set_terminator('\n')
        handle.write_termination = '\n'
        self._write_response = ''
        firmware_version = self._get_firmware_version()
        if firmware_version < 1.07:
            LOG.warning(f""Firmware version: {firmware_version}"")
            raise RuntimeError('''
                No QDevil QDAC detected or the firmware version is obsolete.
                This driver only supports version 1.07 or newer. Please
                contact info@qdevil.com for a firmware update.
                ''')

        # Initialse basic information and internal book keeping
        self.num_chans = self._get_number_of_channels()
        num_boards = int(self.num_chans/8)
        self._output_n_lines = self.num_chans + 2
        self._chan_range = range(1, 1 + self.num_chans)
        self.channel_validator = vals.Ints(1, self.num_chans)
        self._reset_bookkeeping()

        # Add channels (and channel parameters)
        channels = ChannelList(self, ""Channels"", QDacChannel,
                               snapshotable=False,
                               multichan_paramclass=QDacMultiChannelParameter)

        for i in self._chan_range:
            channel = QDacChannel(self, f'chan{i:02}', i)
            channels.append(channel)
            self.add_submodule(f""ch{i:02}"", channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        # Updatechannel  sync port validator according to number of boards
        self._num_syns = max(num_boards-1, 1)
        for chan in self._chan_range:
            self.channels[chan-1].sync.vals = vals.Ints(0, self._num_syns)

        # Add non-channel parameters
        for board in range(num_boards):
            for sensor in range(3):
                label = f'Board {board}, Temperature {sensor}'
                self.add_parameter(name=f'temp{board}_{sensor}',
                                   label=label,
                                   unit='C',
                                   get_cmd=f'tem {board} {sensor}',
                                   get_parser=self._num_verbose)

        self.add_parameter(name='cal',
                           set_cmd='cal {}',
                           vals=vals.Ints(0, self.num_chans))

        self.add_parameter(name='mode_force',
                           label='Mode force',
                           get_cmd=None, set_cmd=None,
                           vals=vals.Bool(),
                           initial_value=False)

        # Due to a firmware bug in 1.07 voltage ranges are always reported
        # vebosely. So for future compatibility we set verbose True
        self.write('ver 1')
        self._update_voltage_ranges()
        # The driver require verbose mode off except for the above command
        self.write('ver 0')
        self._verbose = False  # Just so that the code can check the state
        self.connect_message()
        LOG.info('[*] Querying all channels for voltages and currents...')
        self._update_cache(update_currents=update_currents)
        self._update_currents = update_currents
        self._load_state()
        LOG.info('[+] Done')

    def _reset_bookkeeping(self) -> None:
        """"""
        Resets all internal variables used for ramping and
        synchronization outputs.
        """"""
        # Assigned slopes. Entries will eventually be {chan: slope}
        self._slopes: dict[int, Union[str, float]] = {}
        # Function generators and triggers (used in ramping)
        self._fgs = set(range(1, 9))
        self._assigned_fgs: dict[int, Generator] = {}  # {chan: fg}
        self._trigs = set(range(1, 10))
        self._assigned_triggers: dict[int, int] = {}  # {fg: trigger}
        # Sync channels
        self._syncoutputs: dict[int, int] = {}  # {chan: syncoutput}

    def _load_state(self) -> None:
        """"""
        Used as part of initiaisation. DON'T use _load_state() separately.\n
        Updates internal book keeping of running function generators.
        used triggers and active sync outputs.\n
        Slopes can not be read/updated as it is not possible to
        say if a generator is running because a slope has been assigned
        or because it is being ramped direcly (by e.g. ramp_voltages_2d()).
        """"""
        # Assumes that all variables and virtual
        # parameters have been initialised (and read)

        self.write('ver 0')  # Just to be on the safe side

        self._reset_bookkeeping()
        for ch_idx in range(self.num_chans):
            chan = ch_idx + 1
            # Check if the channels are being ramped
            # It is not possible to find out if it has a slope assigned
            # as it may be ramped explicitely by the user
            # We assume that generators are running, but we cannot know
            self.write(f'wav {chan}')
            fg_str, amplitude_str, offset_str = self._write_response.split(',')
            amplitude = float(amplitude_str)
            offset = float(offset_str)
            fg = int(fg_str)
            if fg in range(1, 9):
                voltage = self.channels[ch_idx].v.get()
                time_now = time.time()
                self.write(f'fun {fg}')
                response = self._write_response.split(',')
                waveform = int(response[0])
                # Probably this driver is involved if a stair case is assigned
                if waveform == Waveform.staircase:
                    if len(response) == 6:
                        step_length_ms, no_steps, rep, rep_remain_str, trigger \
                            = response[1:6]
                        rep_remain = int(rep_remain_str)
                    else:
                        step_length_ms, no_steps, rep, trigger = response[1:5]
                        rep_remain = int(rep)
                    ramp_time = 0.001 * float(step_length_ms) * int(no_steps)
                    ramp_remain = 0
                    if (amplitude != 0):
                        ramp_remain = (amplitude+offset-voltage)/amplitude
                    if int(rep) == -1:
                        time_end = time_now + 315360000
                    else:
                        time_end = (ramp_remain + max(0, rep_remain-1)) \
                                   * ramp_time + time_now + 0.001
                else:
                    if waveform == Waveform.sine:
                        period_ms, rep, rep_remain_str, trigger = response[1:5]
                    else:
                        period_ms, _, rep, rep_remain_str, trigger = response[1:6]
                    if int(rep) == -1:
                        time_end = time_now + 315360000  # 10 years from now
                    else:  # +1 is just a safe guard
                        time_end = time_now + 0.001 \
                                   * (int(rep_remain_str)+1) * float(period_ms)

                self._assigned_fgs[chan] = Generator(fg)
                self._assigned_fgs[chan].t_end = time_end
                if int(trigger) != 0:
                    self._assigned_triggers[fg] = int(trigger)
                for syn in range(1, self._num_syns+1):
                    self.write(f'syn {syn}')
                    syn_fg, delay_ms, duration_ms = \
                        self._write_response.split(',')
                    if int(syn_fg) == fg:
                        self.channels[ch_idx].sync.cache.set(syn)
                        self.channels[ch_idx].sync_delay(float(delay_ms)/1000)
                        self.channels[ch_idx].sync_duration(
                            float(duration_ms)/1000)

    def reset(self, update_currents: bool = False) -> None:
        """"""
        Resets the instrument setting all channels to zero output voltage
        and all parameters to their default values, including removing any
        assigned sync putputs, function generators, triggers etc.
        """"""
        # In case the QDAC has been switched off/on
        # clear the io buffer and set verbose False
        self.device_clear()
        self.write('ver 0')

        self.cal(0)
        # Resetting all slopes first will cause v.set() disconnect generators
        self.channels[0:self.num_chans].slope('Inf')
        self.channels[0:self.num_chans].v(0)
        self.channels[0:self.num_chans].mode(Mode.vhigh_ihigh)
        self.channels[0:self.num_chans].sync(0)
        self.channels[0:self.num_chans].sync_delay(0)
        self.channels[0:self.num_chans].sync_duration(0.01)

        if update_currents:
            self.channels[0:self.num_chans].i.get()
        self.mode_force(False)
        self._reset_bookkeeping()

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._update_currents and update is True
        if update:
            self._update_cache(update_currents=update_currents)
            self._get_status_performed = True
        # call _update_cache rather than getting the status individually for
        # each parameter. We set _get_status_performed to True
        # to indicate that each update channel does not need to call this
        # function as opposed to when snapshot is called on an individual
        # channel
        snap = super().snapshot_base(
                                update=update,
                                params_to_skip_update=params_to_skip_update)
        self._get_status_performed = False
        return snap

    #########################
    # Channel gets/sets
    #########################

    def _set_voltage(self, chan: int, v_set: float) -> None:
        """"""
        set_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
            v_set: The target voltage

        If a finite slope has been assigned, a function generator will
        ramp the voltage.
        """"""

        slope = self._slopes.get(chan, None)
        if slope:
            # We need .get and not cache/get_latest in case a ramp
            # was interrupted
            v_start = self.channels[chan-1].v.get()
            duration = abs(v_set-v_start)/slope
            LOG.info(f'Slope: {slope}, time: {duration}')
            # SYNCing happens inside ramp_voltages
            self.ramp_voltages([chan], [v_start], [v_set], duration)
        else:  # Should not be necessary to wav here.
            self.write('wav {ch} 0 0 0;set {ch} {voltage:.6f}'
                       .format(ch=chan, voltage=v_set))

    def _set_mode(self, chan: int, new_mode: Mode) -> None:
        """"""
        set_cmd for the QDAC's mode (combined voltage and current sense range).
        It is not possible to switch from voltage range without setting the
        the volage to zero first or set the global mode_force parameter True.
        """"""
        def _clipto(value: float, min_: float, max_: float) -> float:
            errmsg = (""Voltage is outside the bounds of the new voltage range""
                      "" and is therefore clipped."")
            if value > max_:
                LOG.warning(errmsg)
                return max_
            elif value < min_:
                LOG.warning(errmsg)
                return min_
            else:
                return value

        # It is not possible ot say if the channel is connected to
        # a generator, so we need to ask.
        def wav_or_set_msg(chan: int, new_voltage: float) -> str:
            self.write(f'wav {chan}')
            fw_str = self._write_response
            gen, _, _ = fw_str.split(',')
            if int(gen) > 0:
                # The amplitude must be set to zero to avoid potential overflow
                # Assuming that voltage range is not changed during a ramp
                return 'wav {} {} {:.6f} {:.6f}'\
                        .format(chan, int(gen), 0, new_voltage)
            else:
                return f'set {chan} {new_voltage:.6f}'

        old_mode = self.channels[chan-1].mode.cache()
        new_vrange = new_mode.value.v
        old_vrange = old_mode.value.v
        new_irange = new_mode.value.i
        old_irange = old_mode.value.i
        message = ''
        max_zero_voltage = {0: 20e-6, 1: 3e-6}
        NON_ZERO_VOLTAGE_MSG = (
                'Please set the voltage to zero before changing the voltage'
                ' range in order to avoid jumps or spikes.'
                ' Or set mode_force=True to allow voltage range change for'
                ' non-zero voltages.')

        if old_mode == new_mode:
            return

        # If the voltage range is going to change we have to take care of
        # setting the voltage after the switch, and therefore read it first
        # We also need to make sure than only one of the voltage/current
        # relays is on at a time (otherwise the firmware will enforce it).

        if (new_irange != old_irange) and (new_vrange == old_vrange == 0):
            # Only the current sensor relay has to switch:
            message += f'cur {chan} {new_irange}'
        # The voltage relay (also) has to switch:
        else:
            # Current sensor relay on->off before voltage relay off->on:
            if new_irange < old_irange and new_vrange > old_vrange:
                message += f'cur {chan} {new_irange};'
            old_voltage = self.channels[chan-1].v.get()
            # Check if voltage is non-zero and mode_force is off
            if ((self.mode_force() is False) and
                    (abs(old_voltage) > max_zero_voltage[old_vrange])):
                raise ValueError(NON_ZERO_VOLTAGE_MSG)
            new_voltage = _clipto(
                    old_voltage, self.vranges[chan][new_vrange]['Min'],
                    self.vranges[chan][new_vrange]['Max'])
            message += f'vol {chan} {new_vrange};'
            message += wav_or_set_msg(chan, new_voltage)
            # Current sensor relay off->on after voltage relay on->off:
            if new_irange > old_irange and new_vrange < old_vrange:
                message += f';cur {chan} {new_irange}'
            self.channels[chan-1].v.vals = self._v_vals(chan, new_vrange)
            self.channels[chan-1].v.cache.set(new_voltage)

        self.write(message)

    def _v_vals(self, chan: int, vrange_int: int) -> vals.Numbers:
        """"""
        Returns the validator for the specified voltage range.
        """"""
        return vals.Numbers(self.vranges[chan][vrange_int]['Min'],
                            self.vranges[chan][vrange_int]['Max'])

    def _update_v_validators(self) -> None:
        """"""
        Command for setting all 'v' limits ('vals') of all channels to the
        actual calibrated output limits for the range each individual channel
        is currently in.
        """"""
        for chan in range(1, self.num_chans+1):
            vrange = self.channels[chan-1].mode.value.v
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange)

    def _num_verbose(self, s: str) -> float:
        """"""
        Turns a return value from the QDac into a number.
        If the QDac is in verbose mode, this involves stripping off the
        value descriptor.
        """"""
        if self._verbose:
            s = s.split(': ')[-1]
        return float(s)

    def _current_parser(self, s: str) -> float:
        """"""
        Parser for chXX_i parameter (converts from uA to A)
        """"""
        return 1e-6*self._num_verbose(s)

    def _update_cache(self, update_currents: bool = False) -> None:
        """"""
        Function to query the instrument and get the status of all channels.
        Takes a while to finish.

        The `status` call generates 27 or 51 lines of output. Send the command
        and read the first one, which is the software version line
        the full output looks like:
        Software Version: 1.07\r\n
        Channel\tOut V\t\tVoltage range\tCurrent range\n
        \n
        8\t  0.000000\t\tX 1\t\tpA\n
        7\t  0.000000\t\tX 1\t\tpA\n
        ... (all 24/48 channels like this)
        (no termination afterward besides the \n ending the last channel)
        """"""
        irange_trans = {'hi cur': 1, 'lo cur': 0}
        vrange_trans = {'X 1': 0, 'X 0.1': 1}

        # Status call, check the
        version_line = self.ask('status')
        if version_line.startswith('Software Version: '):
            self.version = version_line.strip().split(': ')[1]
        else:
            self._wait_and_clear()
            raise ValueError('unrecognized version line: ' + version_line)

        # Check header line
        header_line = self.read()
        headers = header_line.lower().strip('\r\n').split('\t')
        expected_headers = ['channel', 'out v', '', 'voltage range',
                            'current range']
        if headers != expected_headers:
            raise ValueError('unrecognized header line: ' + header_line)

        chans_left = set(self._chan_range)
        while chans_left:
            line = self.read().strip()
            if not line:
                continue
            chanstr, v, _, vrange, _, irange = line.split('\t')
            chan = int(chanstr)
            vrange_int = int(vrange_trans[vrange.strip()])
            irange_int = int(irange_trans[irange.strip()])
            mode = Mode((vrange_int, irange_int))
            self.channels[chan-1].mode.cache.set(mode)
            self.channels[chan-1].v.cache.set(float(v))
            self.channels[chan-1].v.vals = self._v_vals(chan, vrange_int)
            chans_left.remove(chan)

        if update_currents:
            for chan in self._chan_range:
                self.channels[chan-1].i.get()

    def _setsync(self, chan: int, sync: int) -> None:
        """"""
        set_cmd for the chXX_sync parameter.

        Args:
            chan: The channel number (1-48 or 1-24)
            sync: The associated sync output (1-3 on 24 ch units
            or 1-5 on 48 ch units). 0 means 'unassign'
        """"""

        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                    f'Channel number must be 1-{self.num_chans}.')

        if sync == 0:
            oldsync = self.channels[chan-1].sync.cache()
            # try to remove the sync from internal bookkeeping
            self._syncoutputs.pop(chan, None)
            # free the previously assigned sync
            if oldsync is not None:
                self.write(f'syn {oldsync} 0 0 0')
            return

        # Make sure to clear hardware an _syncoutpus appropriately
        if chan in self._syncoutputs:
            # Changing SYNC port for a channel
            oldsync = self.channels[chan-1].sync.cache()
            if sync != oldsync:
                self.write(f'syn {oldsync} 0 0 0')
        elif sync in self._syncoutputs.values():
            # Assigning an already used SYNC port to a different channel
            oldchan = [ch for ch, sy in self._syncoutputs.items()
                       if sy == sync]
            self._syncoutputs.pop(oldchan[0], None)
            self.write(f'syn {sync} 0 0 0')

        self._syncoutputs[chan] = sync
        return

    def _getsync(self, chan: int) -> int:
        """"""
        get_cmd of the chXX_sync parameter
        """"""
        return self._syncoutputs.get(chan, 0)

    def print_syncs(self) -> None:
        """"""
        Print assigned SYNC ports, sorted by channel number
        """"""
        for chan, sync in sorted(self._syncoutputs.items()):
            print(f'Channel {chan}, SYNC: {sync} (V/s)')

    def _setslope(self, chan: int, slope: Union[float, str]) -> None:
        """"""
        set_cmd for the chXX_slope parameter, the maximum slope of a channel.
        With a finite slope the channel will be ramped using a generator.

        Args:
            chan: The channel number (1-24 or 1-48)
            slope: The slope in V/s.
            Write 'Inf' to release the channelas slope channel and to release
            the associated function generator. The output rise time will now
            only depend on the analog electronics.
        """"""
        if chan not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')

        if slope == 'Inf':
            # Set the channel in DC mode
            v_set = self.channels[chan-1].v.get()
            self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                       .format(ch=chan, voltage=v_set))

            # Now release the function generator and fg trigger (if possible)
            try:
                fg = self._assigned_fgs[chan]
                self._assigned_fgs[chan].t_end = 0
                self._assigned_triggers.pop(fg.fg)
            except KeyError:
                pass

            # Remove a sync output, if one was assigned
            if chan in self._syncoutputs:
                self.channels[chan-1].sync.set(0)
            # Now clear the assigned slope
            self._slopes.pop(chan, None)
        else:
            self._slopes[chan] = slope

    def _getslope(self, chan: int) -> Union[str, float]:
        """"""
        get_cmd of the chXX_slope parameter
        """"""
        return self._slopes.get(chan, 'Inf')

    def print_slopes(self) -> None:
        """"""
        Print the finite slopes assigned to channels, sorted by channel number
        """"""
        for chan, slope in sorted(self._slopes.items()):
            print(f'Channel {chan}, slope: {slope} (V/s)')

    def _get_minmax_outputvoltage(
        self, channel: int, vrange_int: int
    ) -> dict[str, float]:
        """"""
        Returns a dictionary of the calibrated Min and Max output
        voltages of 'channel' for the voltage given range (0,1) given by
        'vrange_int'
        """"""
        # For firmware 1.07 verbose mode and nn verbose mode give verbose
        # result, So this is designed for verbose mode
        if channel not in range(1, self.num_chans+1):
            raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
        if vrange_int not in range(0, 2):
            raise ValueError('Range must be 0 or 1.')

        self.write(f'rang {channel} {vrange_int}')
        fw_str = self._write_response
        return {'Min': float(fw_str.split('MIN:')[1].split('MAX')[0].strip()),
                'Max': float(fw_str.split('MAX:')[1].strip())}

    def _update_voltage_ranges(self) -> None:
        # Get all calibrated min/max output values, requires verbose on
        # in firmware version 1.07
        self.write('ver 1')
        self.vranges = {}
        for chan in self._chan_range:
            self.vranges.update(
                {chan: {0: self._get_minmax_outputvoltage(chan, 0),
                        1: self._get_minmax_outputvoltage(chan, 1)}})
        self.write('ver 0')

    def write(self, cmd: str) -> None:
        """"""
        QDac always returns something even from set commands, even when
        verbose mode is off, so we'll override write to take this out
        if you want to use this response, we put it in self._write_response
        (but only for the very last write call)

        In this method we expect to read one termination char per command. As
        commands are concatenated by `;` we count the number of concatenated
        commands as count(';') + 1 e.g. 'wav 1 1 1 0;fun 2 1 100 1 1' is two
        commands. Note that only the response of the last command will be
        available in `_write_response`
        """"""

        LOG.debug(f""Writing to instrument {self.name}: {cmd}"")
        self.visa_handle.write(cmd)
        for _ in range(cmd.count(';')+1):
            self._write_response = self.visa_handle.read()

    def read(self) -> str:
        return self.visa_handle.read()

    def _wait_and_clear(self, delay: float = 0.5) -> None:
        time.sleep(delay)
        self.visa_handle.clear()

    def connect_message(self,
                        idn_param: str = 'IDN',
                        begin_time: Optional[float] = None) -> None:
        """"""
        Override of the standard Instrument class connect_message.
        Usually, the response to `*IDN?` is printed. Here, the
        software version is printed.
        """"""
        self.visa_handle.write('version')
        LOG.info('Connected to QDAC on {}, {}'.format(
                                    self._address, self.visa_handle.read()))

    def _get_firmware_version(self) -> float:
        """"""
        Check if the ""version"" command reponds. If so we probbaly have a QDevil
        QDAC, and the version number is returned. Otherwise 0.0 is returned.
        """"""
        self.write('version')
        fw_str = self._write_response
        if (""Unrecognized command"" not in fw_str) and (""Software Version: "" in fw_str):
            fw_version = float(self._write_response.replace(""Software Version: "", """"))
        else:
            fw_version = 0.0
        return fw_version

    def _get_number_of_channels(self) -> int:
        """"""
        Returns the number of channels for the instrument
        """"""
        self.write('boardNum')
        fw_str = self._write_response
        return 8*int(fw_str.strip(""numberOfBoards:""))

    def print_overview(self, update_currents: bool =  False) -> None:
        """"""
        Pretty-prints the status of the QDac
        """"""

        self._update_cache(update_currents=update_currents)

        for ii in range(self.num_chans):
            line = f""Channel {ii+1} \n""
            line += ""    Voltage: {} ({}).\n"".format(
                self.channels[ii].v.cache(), self.channels[ii].v.unit
            )
            line += ""    Current: {} ({}).\n"".format(
                self.channels[ii].i.cache.get(get_if_invalid=False),
                self.channels[ii].i.unit,
            )
            line += f""    Mode: {self.channels[ii].mode.cache().get_label()}.\n""
            line += ""    Slope: {} ({}).\n"".format(
                self.channels[ii].slope.cache(), self.channels[ii].slope.unit
            )
            if self.channels[ii].sync.cache() > 0:
                line += '    Sync Out: {}, Delay: {} ({}), '\
                        'Duration: {} ({}).\n'.format(
                            self.channels[ii].sync.cache(),
                            self.channels[ii].sync_delay.cache(),
                            self.channels[ii].sync_delay.unit,
                            self.channels[ii].sync_duration.cache(),
                            self.channels[ii].sync_duration.unit,
                        )

            print(line)

    def _get_functiongenerator(self, chan: int) -> int:
        """"""
        Function for getting a free generator (of 8 available) for a channel.
        Used as helper function for ramp_voltages, but may also be used if the
        user wants to use a function generator for something else.
        If there are no free generators this function will wait for up to
        fgs_timeout for one to be ready.

        To mark a function generator as available for others set
        self._assigned_fgs[chan].t_end = 0

        Args:
            chan: (1..24/48) the channel for which a function generator is
                  requested.
        """"""
        fgs_timeout = 2  # Max time to wait for next available generator

        if len(self._assigned_fgs) < 8:
            fg = min(self._fgs.difference(
                        {g.fg for g in self._assigned_fgs.values()}))
            self._assigned_fgs[chan] = Generator(fg)
        else:
            # If no available fgs, see if one is soon to be ready
            # Nte, this does not handle if teh user has assigned the
            # same fg to multiple channels cheating the driver
            time_now = time.time()
            available_fgs_chans = []
            fgs_t_end_ok = [g.t_end for chan, g
                            in self._assigned_fgs.items()
                            if g.t_end < time_now+fgs_timeout]
            if len(fgs_t_end_ok) > 0:
                first_ready_t = min(fgs_t_end_ok)
                available_fgs_chans = [chan for chan, g
                                       in self._assigned_fgs.items()
                                       if g.t_end == first_ready_t]
                if first_ready_t > time_now:
                    LOG.warning('''
                    Trying to ramp more channels than there are generators.\n
                    Waiting for ramp generator to be released''')
                    time.sleep(first_ready_t - time_now)

            if len(available_fgs_chans) > 0:
                oldchan = available_fgs_chans[0]
                fg = self._assigned_fgs[oldchan].fg
                self._assigned_fgs.pop(oldchan)
                self._assigned_fgs[chan] = Generator(fg)
                # Set the old channel in DC mode
                v_set = self.channels[oldchan-1].v.cache()
                self.write('set {ch} {voltage:.6f};wav {ch} 0 0 0'
                           .format(ch=oldchan, voltage=v_set))
            else:
                raise RuntimeError('''
                Trying to ramp more channels than there are generators
                available. Please insert delays allowing channels to finish
                ramping before trying to ramp other channels, or reduce the
                number of ramped channels. Or increase fgs_timeout.''')
        return fg

    def ramp_voltages(
            self,
            channellist: Sequence[int],
            v_startlist: Sequence[float],
            v_endlist: Sequence[float],
            ramptime: float) -> float:
        """"""
        Function for smoothly ramping one channel or more channels
        simultaneously (max. 8). This is a shallow interface to
        ramp_voltages_2d. Function generators and triggers are
        are assigned automatically.

        Args:
            channellist:    List (int) of channels to be ramped (1 indexed)\n
            v_startlist:    List (int) of voltages to ramp from.
                            MAY BE EMPTY. But if provided, time is saved by
                            NOT reading the present values from the instrument.

            v_endlist:      List (int) of voltages to ramp to.\n
            ramptime:       Total ramp time in seconds (min. 0.002). Has
                            to be an integer number of 0.001 secs).\n
        Returns:
            Estimated time of the excecution of the 2D scan.

        NOTE: This function returns as the ramps are started. So you need
        to wait for 'ramptime' until measuring....
        """"""

        if ramptime < 0.002:
            LOG.warning('Ramp time too short: {:.3f} s. Ramp time set to 2 ms.'
                        .format(ramptime))
            ramptime = 0.002
        steps = int(ramptime*1000)
        return self.ramp_voltages_2d(
                            slow_chans=[], slow_vstart=[], slow_vend=[],
                            fast_chans=channellist, fast_vstart=v_startlist,
                            fast_vend=v_endlist, step_length=0.001,
                            slow_steps=1, fast_steps=steps)

    def ramp_voltages_2d(
            self,
            slow_chans: Sequence[int],
            slow_vstart: Sequence[float],
            slow_vend: Sequence[float],
            fast_chans: Sequence[int],
            fast_vstart: Sequence[float],
            fast_vend: Sequence[float],
            step_length: float,
            slow_steps: int,
            fast_steps: int) -> float:
        """"""
        Function for smoothly ramping two channel groups simultaneously with
        one slow (x) and one fast (y) group. used by 'ramp_voltages' where x is
        empty. Function generators and triggers are assigned automatically.

        Args:
            slow_chans:   List of channels to be ramped (1 indexed) in
                          the slow-group\n
            slow_vstart:  List of voltages to ramp from in the
                          slow-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            slow_vend:    list of voltages to ramp to in the slow-group.

            fast_chans:   List of channels to be ramped (1 indexed) in
                          the fast-group.\n
            fast_vstart:  List of voltages to ramp from in the
                          fast-group.
                          MAY BE EMPTY. But if provided, time is saved by NOT
                          reading the present values from the instrument.\n
            fast_vend:    list of voltages to ramp to in the fast-group.

            step_length:  Time spent at each step in seconds
                          (min. 0.001) multiple of 1 ms.\n
            slow_steps:   number of steps in the slow direction.\n
            fast_steps:   number of steps in the fast direction.\n

        Returns:
            Estimated time of the excecution of the 2D scan.\n
        NOTE: This function returns as the ramps are started.
        """"""
        channellist = [*slow_chans, *fast_chans]
        v_endlist = [*slow_vend, *fast_vend]
        v_startlist = [*slow_vstart, *fast_vstart]
        step_length_ms = int(step_length*1000)

        if step_length < 0.001:
            LOG.warning('step_length too short: {:.3f} s. \nstep_length set to'
                        .format(step_length_ms) + ' minimum (1ms).')
            step_length_ms = 1

        if any([ch in fast_chans for ch in slow_chans]):
            raise ValueError(
                    'Channel cannot be in both slow_chans and fast_chans!')

        no_channels = len(channellist)
        if no_channels != len(v_endlist):
            raise ValueError(
                    'Number of channels and number of voltages inconsistent!')

        for chan in channellist:
            if chan not in range(1, self.num_chans+1):
                raise ValueError(
                        f'Channel number must be 1-{self.num_chans}.')
            if chan not in self._assigned_fgs:
                self._get_functiongenerator(chan)

        # Voltage validation
        for i in range(no_channels):
            self.channels[channellist[i]-1].v.validate(v_endlist[i])
        if v_startlist:
            for i in range(no_channels):
                self.channels[channellist[i]-1].v.validate(v_startlist[i])

        # Get start voltages if not provided
        if not slow_vstart:
            slow_vstart = [self.channels[ch-1].v.get() for ch in slow_chans]
        if not fast_vstart:
            fast_vstart = [self.channels[ch-1].v.get() for ch in fast_chans]

        v_startlist = [*slow_vstart, *fast_vstart]
        if no_channels != len(v_startlist):
            raise ValueError(
                'Number of start voltages do not match number of channels!')

        # Find trigger not aleady uses (avoid starting other
        # channels/function generators)
        if no_channels == 1:
            trigger = 0
        else:
            trigger = int(min(self._trigs.difference(
                                    set(self._assigned_triggers.values()))))

        # Make sure any sync outputs are configured
        for chan in channellist:
            if chan in self._syncoutputs:
                sync = self._syncoutputs[chan]
                sync_duration = int(
                                1000*self.channels[chan-1].sync_duration.get())
                sync_delay = int(1000*self.channels[chan-1].sync_delay.get())
                self.write('syn {} {} {} {}'.format(
                                            sync, self._assigned_fgs[chan].fg,
                                            sync_delay, sync_duration))

        # Now program the channel amplitudes and function generators
        msg = ''
        for i in range(no_channels):
            amplitude = v_endlist[i]-v_startlist[i]
            ch = channellist[i]
            fg = self._assigned_fgs[ch].fg
            if trigger > 0:  # Trigger 0 is not a trigger
                self._assigned_triggers[fg] = trigger
            msg += f""wav {ch} {fg} {amplitude} {v_startlist[i]}""
            # using staircase = function 4
            nsteps = slow_steps if ch in slow_chans else fast_steps
            repetitions = slow_steps if ch in fast_chans else 1

            delay = step_length_ms \
                if ch in fast_chans else fast_steps*step_length_ms
            msg += ';fun {} {} {} {} {} {};'.format(
                        fg, Waveform.staircase, delay, int(nsteps),
                        repetitions, trigger)
            # Update latest values to ramp end values
            # (actually not necessary when called from _set_voltage)
            self.channels[ch-1].v.cache.set(v_endlist[i])
        self.write(msg[:-1])  # last semicolon is stripped

        # Fire trigger to start generators simultaneously, saving communication
        # time by not using triggers for single channel ramping
        if trigger > 0:
            self.write(f'trig {trigger}')

        # Update fgs dict so that we know when the ramp is supposed to end
        time_ramp = slow_steps * fast_steps * step_length_ms / 1000
        time_end = time_ramp + time.time()
        for chan in channellist:
            self._assigned_fgs[chan].t_end = time_end
        return time_ramp
"
272,110.6,"Cleveland, Ohio, United States","The 2612B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",Keithley 2612 B,249.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2612B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2612B,https://www.testequipmenthq.com/datasheets/KEITHLEY-2612B-Datasheet.pdf,"[OrderedDict([('id', 'attZwqOigLxiH7ADe'), ('width', 320), ('height', 144), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L5PqX3ZVMC1uqS90kI4dLA/RIvBTGMkBzoYh4p4XVNqGyIWecLhH4e929U40CJC3z-Q7k9cDK1bS1cqx2BzVnAwyPnRLoyKO3vROip8D4efYHwVILiQjXk_ldf3F97hgyc/3RnpFG-EaQi8O9f2QTjAvANYaaiJfsfw3HrBK92VhSg'), ('filename', '2612b.webp'), ('size', 7496), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uRJxmoFHQc-N2PDUcf5hAQ/67XkQr23LU5VNHkCZrvuarUVSwmg8n4OVLpaC2Od9ML-pyzxA-s3v7h01PjgJm_UMbFfrY7TA_8sPy9K710Gow-0__PLYv70TvZEO9qVNSQ/WZAHb_lbjpy6VM-3D1BnzK9G3c0L-Px4FuVBMEfrMuo'), ('width', 80), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/K1SoaxTihs3MqV1HHnQgbw/ntv3Um_Ikk56yPRXvY9oEZc_C315Y2La-sykrSis5cwW0ffmwPxiasOEAREGzvPT_5BYj8ozkZ7mUsrfeQuApm2Lgz19a7tKDp6LZPLsfjQ/yuR0wAuaZs85KlmpzDsyiacTO_5tn06xggyIuBNI9sU'), ('width', 320), ('height', 144)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XyG3PL3keK_9S-s2mrIU-w/X28oiLX5imdS69RbXnWj9CT6PTSsYZIeS4cpq3fnRsJuM9aMtUNplWPEm2EjkjAuJXOeJ7SjESvSApsgzj2MfpHYBxVNWEbQ-f0r1pUTWSE/x6a4nvHoEMzWc_lZl4_ltu1fO1h9c-tIBEjybjjE8w8'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2612b/source-meter-voltage-current-30/dp/44W8037,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_2612B.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2612B,20155.0,,,,"from ._Keithley_2600 import Keithley2600


class Keithley2612B(Keithley2600):
    """"""
    QCoDeS driver for the Keithley 2612B Source-Meter
    """"""

    pass
"
278,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Triple Ouput, 2 x 30V/3A plus 6V/6A, USB, RS232 & LAN Interfaces
",AIM TTI PL 303 QMT P,48.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL303QMT-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL303QMT-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'attPKDhoPPKd5xfBs'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qa93O7RFgvJpTEbCzgnwSQ/hYMyzZb8F8khBmR-wNKbAs419EdhOjNmHhyms9K3Mq_H7C6tpQTCvl0cXWmMleUXgG9r020ymb3nVd-CzC2ESGiMvE6qjlrDF2sMjS756c4/ts6-qhXbQnhcB2GInzg41tPt1nS2lrTqynbY02UxFm8'), ('filename', 'PL303QMT-1000px.jpg'), ('size', 160347), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZcMglzdz5szm6GK1kDt6hA/IFgCfuZjE2I0pCDt_6T-G_yFqEsZRh0Ha45VhsvtvOIqNF6xYrWDzPB0UKDr1K6WgXQlmzVbafPspCn_6AtCDA/wevBnKiZnD4TtSS2dS9HPq0mVHe4tFWjWLLzLD_N8DU'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/u3_vyCM4RjvR14-Ysk2yGQ/723M1kh__824f7P0hLKy1scMyFBwcSWhT5hLxZVQbiAX9P0gPdcPOTQRq6yi75pDcJlCEcpdrcUBAj4OZfqyxQ/6T4dY3GlPdWvZk6e6EwjuuA98FxJmFnD3CrXGWatqC4'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xNlY_IfB1OkuHfu1XGJxqQ/wy0bBhbwIWWzl7aW3GOcEerR-_Q-74NeoLofu3eyb9PXGVtxd3OE_hTDlh2FVVbe14KqzEENDfRwGeOBiRoRdg/BjKvLrc4zX7CYgfstb5jnVdFfIHS4pVhC6AVOJys2zo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,1500.0,"
",,,
279,5420.0,USA,"The Keysight Technologies, Inc. 34411A multimeter gives you the performance you need for fast, accurate bench and system testing. The 34411A provides a combination of resolution, accuracy and speed that rivals DMMs costing many times more. 6½ digits of resolution",Agilent 34411 A,29.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT - 34411A Multimeters,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.",KEYSIGHT - 34411A,https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,"[OrderedDict([('id', 'attypss1A43JfXIOU'), ('width', 1164), ('height', 544), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FUaTNCtRs5XVwDrWEgmD6g/HeQy8b23vJyvB3ktNF3pnMHpPYYAsWe-yX_NhaUXCkx7WVl5zRClUc0kJIJRr6lVU0Y-f8dPCFZOSBf5zQLTrF49IxF3WWTY9oh4yzTwLxI/YNYagI8WJio6AL5sREGegr_WgJyLB356FN0Fhx-r_IU'), ('filename', '34411A.png'), ('size', 603251), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1OBaqDh9TnxFBipppP9g0g/E_YLIo7dWDlX9Lp_rZ94uPYQYlXDosZghjVlrnuJqsMTxy_2ZebIUvdX4xOEANtw3tQHBRkDRSHJeAnnYHgVvg/5CvaXGmJbjrsaJ35G0DnlBVlag3WVgyv2RmUySMiygk'), ('width', 77), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hZziQZ60SMQWxOdeCnmtGw/0ZKtKN4Tazv5zBsck7nb8DS34d8AIM0-PE3ABRGbTdHZjWPmEcA_ynlpLuAeSkYcbV3CAD0kZ-6xPOPRv6VtZw/Lv7S_RgOFtyh8CtJfRdq4gsRJK3IKOhywSuL276R4BA'), ('width', 1096), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q-PehRIvGdYXvzxulSqdcg/bBoEovvdxlaLla9aydK2CUnJp9KGOi21Ldp0XW0DAbMOwzcdQukJQaNyWZYGtRjViKYW6PTY58lbdB0Ccq075g/Rr83Y0fFlgZl8G_wi_080uEFQ1X8GL9os_03nMLPZ84'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/34411A/digital-multimeter-6-digit.html,https://github.com/JoshuaCurry/python-agilent-34411a/blob/master/scope.py,,,"
",True,,"# Agilent SCPI Data Utility
# Josh Curry 2017
#
# Set up your instrument and run this program to read data 
# as fast as possible to file.


import socket
from datetime import datetime
import atexit
import time

HOST = '192.168.1.10'
PORT = 5025
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

def readout():
	print ""Writing data to file...""
	f.write('\n'.join(dat))
	print ""Closing File. Data stored in "" + thefile
	f.close()
	exit()

atexit.register(readout)
datestring = str(datetime.now()).replace("" "", ""-"")
datestring = datestring.replace(""/"", ""-"")

thefile = ""reading-""+datestring+"".csv""
print ""Opening "" + thefile

f = open(thefile, ""w"")
i = 0

dat = []

print ""Reading from instrument to RAM...""
print ""Press CTRL-C to stop""

start = time.time()
while 1:
	s.sendall(""READ?\r\n"")
	data = s.recv(1024)
	i = i + 1	
	thedata = data.rstrip()
	thedata = thedata.replace(""+"", """")
	dat.append(str(time.time()-start)+"",""+thedata)
s.close()
"
281,4.0,CANADA - QC,"ATS9440 is a 4-channel, 14-bit, 125 MS/s waveform digitizer based on the 8-lane PCI Express interface

",ATS 9440,64.0,"Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",Qcodes,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h8yDC782gmJYILVwetqyNg/XNft-iYe6x8LEFTaoDNdcglx8uZWwUUbNf4oX-ErBZYvya3nvf9i0ao4jJp70hHk7oN7wtgcaboMWlcRtFbUeccPNbUJ0Ajzieb7_-0dOvY/M5yDXUl_TYlDiCuUg_-hevxefX_4ZGtn62x5xIZ0wso'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gmlldA7Zo_-OSPyZsu7mPQ/XKZDoQmgc3wi6TkdRJNKT5dYVGwmvfciyRHelmq94Fmnai7rVErHtEDREKJXu9_IHjQS7AeXExr0raP0i8qt9g/rKROdmQfR-K5ATu1ZN_qmcHLCXjquZ1AQFi7pM4PIRY'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-xGoEh8NzGkRqLzjthJ-1A/El2jn-9r8vkBM8mzLCyPAJp4mhEuwwyz-Mjkamgj3Nb-6HmhSMwQGCrm1aoGHp3LwUNAI6zroK3Xqc0OGV9org/tjN2cvTq9f28KHrk67tlaSmFHLwgdKOLL8IIa1-o5us'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t_PiUYdPzQjLjJU9vEarJQ/uVumfw7c89vOKsptIyuF2g3LBU5I8wWQSuR2hRnlrVTLECKdyi_DwwHGMI6y2EQRUFS6qlkmQtCh3GYKCuYvqg/FS3WfkFziiTlklsy7j-a1DSgE14IyXx9JDShkxKJwrQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,"Write a Python script that uses Qcodes to connect to a ATS9440 - 14 bit, 125 MS/s, 4 ch DAQ boards",https://en.wikipedia.org/wiki/Analog-to-digital_converter,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","ATS9440 - 14 bit, 125 MS/s, 4 ch",https://www.alazartech.com/en/download/product/9057/307/ats9440-datasheet-and-specifications/1-4k/,"[OrderedDict([('id', 'attrPtY0K7DINPWdi'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hGZMz_zNf8txdWSUe3okVQ/zJmBS8o0lOCNDF0CzMT_RTalzY76gPoM9qRJOzoUqVAl8HSDot0oHSXTpBSxYeSSL2IJpO3OaRPPnR1DLKtNcT5WLz2rgTyJxuOig2qOk3s/tiKsoLcszFjlzccybOt1_-abaMOS1tgaJAyGk6ILWpQ'), ('filename', 'ATS9440.jpg'), ('size', 572486), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/M6x8bPSaaZSSzJrP5JElGQ/sCwUFfDNHCw89-GTQgcTf2HlsyOWmpxBf5WQ0n5qWVaiD3wE9MVgxCdw3y2ymWxvCZoMV9Fi-n-nRGpGipja-A/uvMXmtubQeJ9JKxzu926kfgLTN9Oz7cVmXurm00Mnls'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pVOX7oAZ42eYCTUpXRwYtQ/qBi20gFqI10SxqDnkXyXqYE4JLC6pq7e0Hh3jhpVYr60xybKNtvTSgcPGXrCVTl7BCQsqxzSRWat0Q8izydeyw/wQIFKEkpgb_L28JQ9BKtQKj-MhaHcM-_A_-t4WYDGUs'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DinBOkuDAxo44eo3GvMxMw/t_NZQVd3rMfn_my80w5LpyNIcIXDoLIVxXeT4m94ApPZ2g-x58H5mvWHmZn02CdJK4bLPfPgI1zH0MZOtElnDA/o24iQbUJLr1RxY9Zk66w9t3xmitYMkAV4zQC_otPeZ0'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/en/product/ats9440/16/,https://github.com/Exopy/exopy_hqc_legacy/blob/main/exopy_hqc_legacy/instruments/drivers/dll/atsapi.py,https://github.com/jyr-king/PyQCLab/blob/master/Instrument/atsapi.py,,"
",,,"# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# This file comes AlazarTech SDK and was edited by ExopyHqcLegacy Authors
# see AUTHORS for more details.
#
# -----------------------------------------------------------------------------
""""""Python interface to the AlazarTech SDK.

This module provides a thin wrapper on top of the AlazarTech C
API. All the exported methods directly map to underlying C
functions. Please see the ATS-SDK Guide for detailed specification of
these functions. In addition, this module provides a few classes for
convenience.

Attributes:

  Board: Represents a digitizer. Provides methods for configuration
  and data acquisition

  DMABuffer: Holds a memory buffer suitable for data transfer with
  digitizers.

""""""

# ExopyHqcLegacy modifications:
# - use numpy for memory allocation in DMABuffer
# - remove tk WaitBar
# - delay the loading of the ats library

from ctypes import (CDLL, byref, c_byte, c_int, c_long, c_float, c_uint32,
                    c_int64, c_void_p, c_char_p)
import numpy as np
import os

'''Types of clocks that a board can use for acquiring data.
Note: Available sources for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.
'''
INTERNAL_CLOCK = 0x1
EXTERNAL_CLOCK = 0x2
FAST_EXTERNAL_CLOCK = 0x2
MEDIUM_EXTERNAL_CLOCK = 0x3
SLOW_EXTERNAL_CLOCK = 0x4
EXTERNAL_CLOCK_AC = 0x5
EXTERNAL_CLOCK_DC = 0x6
EXTERNAL_CLOCK_10MHz_REF = 0x7
INTERNAL_CLOCK_10MHz_REF = 0x8
EXTERNAL_CLOCK_10MHz_PXI = 0xA
INTERNAL_CLOCK_DIV_4 = 0xF
INTERNAL_CLOCK_DIV_5 = 0x10
MASTER_CLOCK = 0x11
INTERNAL_CLOCK_SET_VCO = 0x12

'''Sample rates that the internal clock of a board can generate.

Note: Available sample rates for a given board form a subset of
this class' members. Please see your board's specification as well
as the ATS-SDK manual for more information.

'''
SAMPLE_RATE_1KSPS = 0x1
SAMPLE_RATE_2KSPS = 0x2
SAMPLE_RATE_5KSPS = 0x5
SAMPLE_RATE_10KSPS = 0x8
SAMPLE_RATE_20KSPS = 0xA
SAMPLE_RATE_50KSPS = 0xC
SAMPLE_RATE_100KSPS = 0xE
SAMPLE_RATE_200KSPS = 0x10
SAMPLE_RATE_500KSPS = 0x12
SAMPLE_RATE_1MSPS = 0x14
SAMPLE_RATE_2MSPS = 0x18
SAMPLE_RATE_5MSPS = 0x1A
SAMPLE_RATE_10MSPS = 0x1C
SAMPLE_RATE_20MSPS = 0x1E
SAMPLE_RATE_25MSPS = 0x21
SAMPLE_RATE_50MSPS = 0x22
SAMPLE_RATE_100MSPS = 0x24
SAMPLE_RATE_125MSPS = 0x25
SAMPLE_RATE_160MSPS = 0x26
SAMPLE_RATE_180MSPS = 0x27
SAMPLE_RATE_200MSPS = 0x28
SAMPLE_RATE_250MSPS = 0x2B
SAMPLE_RATE_400MSPS = 0x2D
SAMPLE_RATE_500MSPS = 0x30
SAMPLE_RATE_800MSPS = 0x32
SAMPLE_RATE_1000MSPS = 0x35
SAMPLE_RATE_1200MSPS = 0x37
SAMPLE_RATE_1500MSPS = 0x3A
SAMPLE_RATE_1600MSPS = 0x3B
SAMPLE_RATE_1800MSPS = 0x3D
SAMPLE_RATE_2000MSPS = 0x3F
SAMPLE_RATE_2400MSPS = 0x6A
SAMPLE_RATE_3000MSPS = 0x75
SAMPLE_RATE_3600MSPS = 0x7B
SAMPLE_RATE_4000MSPS = 0x80
SAMPLE_RATE_USER_DEF = 0x40

'''Direction of the edge from the external clock signal that the board
syncrhonises with.'''
CLOCK_EDGE_RISING = 0
CLOCK_EDGE_FALLING = 1

'''Board input channel identifiers

Note: The channels available for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.

'''
CHANNEL_A = 0x1
CHANNEL_B = 0x2
CHANNEL_C = 0x4
CHANNEL_D = 0x8
CHANNEL_E = 0x16
CHANNEL_F = 0x32
CHANNEL_G = 0x64
CHANNEL_H = 0x128
CHANNEL_I = 0x256
CHANNEL_J = 0x512
CHANNEL_K = 0x1024
CHANNEL_L = 0x2048
CHANNEL_M = 0x4096
CHANNEL_N = 0x8192
CHANNEL_O = 0x16384
CHANNEL_P = 0x32768

channels = [
    CHANNEL_A,
    CHANNEL_B,
    CHANNEL_C,
    CHANNEL_D,
    CHANNEL_E,
    CHANNEL_F,
    CHANNEL_G,
    CHANNEL_H,
    CHANNEL_I,
    CHANNEL_J,
    CHANNEL_K,
    CHANNEL_L,
    CHANNEL_M,
    CHANNEL_N,
    CHANNEL_O,
    CHANNEL_P
]

'''AutoDMA acquisitions flags

Note: Not all AlazarTech devices are capable of dual-ported
acquisitions. Please see your board's specification for more
information.
'''
ADMA_TRADITIONAL_MODE = 0
ADMA_NPT = 0x200
ADMA_CONTINUOUS_MODE = 0x100
ADMA_TRIGGERED_STREAMING = 0x400
ADMA_EXTERNAL_STARTCAPTURE = 0x1
ADMA_ENABLE_RECORD_HEADERS = 0x8
ADMA_ALLOC_BUFFERS = 0x20
ADMA_FIFO_ONLY_STREAMING = 0x800
ADMA_INTERLEAVE_SAMPLES = 0x1000
ADMA_GET_PROCESSED_DATA = 0x2000

'''Boards'''
ATS850  = 1
ATS310  = 2
ATS330  = 3
ATS855  = 4
ATS315  = 5
ATS335  = 6
ATS460  = 7
ATS860  = 8
ATS660  = 9
ATS665  = 10
ATS9462 = 11
ATS9434 = 12
ATS9870 = 13
ATS9350 = 14
ATS9325 = 15
ATS9440 = 16
ATS9410 = 17
ATS9351 = 18
ATS9310 = 19
ATS9461 = 20
ATS9850 = 21
ATS9625 = 22
ATG6500 = 23
ATS9626 = 24
ATS9360 = 25
AXI9870 = 26
ATS9370 = 27
ATU7825 = 28
ATS9373 = 29
ATS9416 = 30

boardNames = {
    ATS850 : ""ATS850"" ,
    ATS310 : ""ATS310"" ,
    ATS330 : ""ATS330"" ,
    ATS855 : ""ATS855"" ,
    ATS315 : ""ATS315"" ,
    ATS335 : ""ATS335"" ,
    ATS460 : ""ATS460"" ,
    ATS860 : ""ATS860"" ,
    ATS660 : ""ATS660"" ,
    ATS665 : ""ATS665"" ,
    ATS9462: ""ATS9462"",
    ATS9434: ""ATS9434"",
    ATS9870: ""ATS9870"",
    ATS9350: ""ATS9350"",
    ATS9325: ""ATS9325"",
    ATS9440: ""ATS9440"",
    ATS9410: ""ATS9410"",
    ATS9351: ""ATS9351"",
    ATS9310: ""ATS9310"",
    ATS9461: ""ATS9461"",
    ATS9850: ""ATS9850"",
    ATS9625: ""ATS9625"",
    ATG6500: ""ATG6500"",
    ATS9626: ""ATS9626"",
    ATS9360: ""ATS9360"",
    AXI9870: ""AXI9870"",
    ATS9370: ""ATS9370"",
    ATU7825: ""ATU7825"",
    ATS9373: ""ATS9373"",
    ATS9416: ""ATS9416""
}


'''Board input ranges (amplitudes) identifiers. PM stands for
plus/minus.

Note: Available input ranges for a given board _and_ a given
configuration form a subset of this class' members. Please see
your board's specification as well as the ATS-SDK manual for more
information.

'''
INPUT_RANGE_PM_40_MV = 0x2
INPUT_RANGE_PM_50_MV = 0x3
INPUT_RANGE_PM_80_MV = 0x4
INPUT_RANGE_PM_100_MV = 0x5
INPUT_RANGE_PM_200_MV = 0x6
INPUT_RANGE_PM_400_MV = 0x7
INPUT_RANGE_PM_500_MV = 0x8
INPUT_RANGE_PM_800_MV = 0x9
INPUT_RANGE_PM_1_V = 0xA
INPUT_RANGE_PM_2_V = 0xB
INPUT_RANGE_PM_4_V = 0xC
INPUT_RANGE_PM_5_V = 0xD
INPUT_RANGE_PM_8_V = 0xE
INPUT_RANGE_PM_10_V = 0xF
INPUT_RANGE_PM_20_V = 0x10
INPUT_RANGE_PM_40_V = 0x11
INPUT_RANGE_PM_16_V = 0x12
INPUT_RANGE_HIFI = 0x20
INPUT_RANGE_PM_1_V_25 = 0x21
INPUT_RANGE_PM_2_V_5  = 0x25
INPUT_RANGE_PM_125_MV = 0x28
INPUT_RANGE_PM_250_MV = 0x30

'''Coupling types identifiers for all boards input'''
AC_COUPLING = 1
DC_COUPLING = 2

'''Trigger engine identifiers.'''
TRIG_ENGINE_J = 0
TRIG_ENGINE_K = 1

'''Trigger engine operation identifiers.'''
TRIG_ENGINE_OP_J = 0
TRIG_ENGINE_OP_K = 1
TRIG_ENGINE_OP_J_OR_K = 2
TRIG_ENGINE_OP_J_AND_K = 3
TRIG_ENGINE_OP_J_XOR_K = 4
TRIG_ENGINE_OP_J_AND_NOT_K = 5
TRIG_ENGINE_OP_NOT_J_AND_K = 6

'''Types of input that the board can trig on.'''
TRIG_CHAN_A = 0
TRIG_CHAN_B = 1
TRIG_CHAN_C = 4
TRIG_CHAN_D = 5
TRIG_EXTERNAL = 2
TRIG_DISABLE = 3

'''Edge of the external trigger signal that the board syncrhonises with.'''
TRIGGER_SLOPE_POSITIVE = 1
TRIGGER_SLOPE_NEGATIVE = 2

'''Impedance identifiers for the board inputs.

Note: Available parameters for a given board form a subset of this
class' members. Please see your board's specification as well as
the ATS-SDK manual for more information.

'''
IMPEDANCE_1M_OHM = 1
IMPEDANCE_50_OHM = 2
IMPEDANCE_75_OHM = 4
IMPEDANCE_300_OHM = 8

'''External trigger range identifiers.'''
ETR_5V = 0
ETR_1V = 1
ETR_TTL = 2
ETR_2V5 = 3

'''LED State'''
LED_OFF = 0
LED_ON = 1

'''LSB Values'''
LSB_DEFAULT = 0
LSB_EXT_TRIG = 1
LSB_AUX_IN_0 = 2
LSB_AUX_IN_1 = 3

'''Operating modes for the auxiliary input/output port.'''
AUX_OUT_TRIGGER = 0
AUX_IN_TRIGGER_ENABLE = 1
AUX_OUT_PACER = 2
AUX_IN_AUXILIARY = 13
AUX_OUT_SERIAL_DATA = 14

'''Parameters for setParameter'''
SETGET_ASYNC_BUFFCOUNT = 0x10000040
SET_DATA_FORMAT        = 0x10000041
ECC_MODE               = 0x10000048

'''Parameters that apply to some modes of the auxiliary input/output
port.'''
TRIGGER_SLOPE_POSITIVE = 1
TRIGGER_SLOPE_NEGATIVE = 2

'''Record average options'''
CRA_MODE_DISABLE = 0
CRA_MODE_ENABLE_FPGA_AVE = 1
CRA_OPTION_UNSIGNED = 0
CRA_OPTION_SIGNED = 1

'''Reset timestamp'''
TIMESTAMP_RESET_FIRSTTIME_ONLY = 0
TIMESTAMP_RESET_ALWAYS = 1

'''Sleep State'''
POWER_OFF = 0
POWER_ON = 1


class DMABuffer(object):
    '''Buffer suitable for DMA transfers.

    AlazarTech digitizers use direct memory access (DMA) to transfer
    data from digitizers to the computer's main memory. This class
    abstracts a memory buffer on the host, and ensures that all the
    requirements for DMA transfers are met.

    DMABuffers export a 'buffer' member, which is a NumPy array view
    of the underlying memory buffer

    Args:

      bytes_per_sample (int): The number of bytes per samples of the
      data. This varies with digitizer models and configurations.

      size_bytes (int): The size of the buffer to allocate, in bytes.

    '''
    def __init__(self, bytes_per_sample, size_bytes):
        self.size_bytes = size_bytes

        np_sample_type = np.uint8
        if bytes_per_sample > 1:
            np_sample_type = np.uint16

        self.buffer = np.empty(size_bytes//bytes_per_sample, np_sample_type)
        self.addr = self.buffer.ctypes.data_as(c_void_p)


#: Global variable used to store the dynamically loaded library
ats = None

# C types used by Alazar
U32 = c_uint32
U8 = c_byte


def load_library():
    """"""Load the ATS library and register the c signatures.

    """"""
    global ats
    if os.name == 'nt':
        ats = CDLL(""ATSApi.dll"")
    elif os.name == 'posix':
        ats = CDLL(""libATSApi.so"")
    else:
        raise Exception(""Unsupported OS"")

    # Registering c signature for ctypes to perform automatic conversions
    ats.AlazarErrorToText.restype = c_char_p
    ats.AlazarErrorToText.argtypes = [U32]

    ats.AlazarGetBoardBySystemID.restype = U32
    ats.AlazarGetBoardBySystemID.argtypes = [U32, U32]

    ats.AlazarGetBoardKind.restype = U32
    ats.AlazarGetBoardKind.argtypes = [U32]

    ats.AlazarAbortAsyncRead.restype = U32
    ats.AlazarAbortAsyncRead.argtypes = [U32]
    ats.AlazarAbortAsyncRead.errcheck = returnCodeCheck

    ats.AlazarAbortCapture.restype = U32
    ats.AlazarAbortCapture.argtypes = [U32]
    ats.AlazarAbortCapture.errcheck = returnCodeCheck

    ats.AlazarBeforeAsyncRead.restype = U32
    ats.AlazarBeforeAsyncRead.argtypes = [U32, U32, c_long, U32, U32, U32, U32]
    ats.AlazarBeforeAsyncRead.errcheck = returnCodeCheck

    ats.AlazarBusy.restype = U32
    ats.AlazarBusy.argtypes = [U32]

    ats.AlazarConfigureAuxIO.restype = U32
    ats.AlazarConfigureAuxIO.argtypes = [U32, U32, U32]
    ats.AlazarConfigureAuxIO.errcheck = returnCodeCheck

    ats.AlazarConfigureLSB.restype = U32
    ats.AlazarConfigureLSB.argtypes = [U32, U32, U32]
    ats.AlazarConfigureLSB.errcheck = returnCodeCheck

    ats.AlazarConfigureRecordAverage.restype = U32
    ats.AlazarConfigureRecordAverage.argtypes = [U32, U32, U32, U32, U32]
    ats.AlazarConfigureRecordAverage.errcheck = returnCodeCheck

    ats.AlazarForceTrigger.restype = U32
    ats.AlazarForceTrigger.argtypes = [U32]
    ats.AlazarForceTrigger.errcheck = returnCodeCheck

    ats.AlazarForceTriggerEnable.restype = U32
    ats.AlazarForceTriggerEnable.argtypes = [U32]
    ats.AlazarForceTriggerEnable.errcheck = returnCodeCheck

    ats.AlazarGetChannelInfo.restype = U32
    ats.AlazarGetChannelInfo.argtypes = [U32, c_void_p, c_void_p]

    ats.AlazarInputControl.restype = U32
    ats.AlazarInputControl.argtypes = [U32, U8, U32, U32, U32]
    ats.AlazarInputControl.errcheck = returnCodeCheck

    ats.AlazarNumOfSystems.restype = U32
    ats.AlazarNumOfSystems.argtypes = []

    ats.AlazarPostAsyncBuffer.restype = U32
    ats.AlazarPostAsyncBuffer.argtypes = [U32, c_void_p, U32]
    ats.AlazarPostAsyncBuffer.errcheck = returnCodeCheck

    ats.AlazarReadEx.restype = U32
    ats.AlazarReadEx.argtypes = [U32, U32, c_void_p, c_int, c_long,
                                 c_int64, U32]
    ats.AlazarReadEx.errcheck = returnCodeCheck

    ats.AlazarResetTimeStamp.restype = U32
    ats.AlazarResetTimeStamp.argtypes = [U32, U32]
    ats.AlazarResetTimeStamp.errcheck = returnCodeCheck

    ats.AlazarSetBWLimit.restype = U32
    ats.AlazarSetBWLimit.argtypes = [U32, U32, U32]
    ats.AlazarSetBWLimit.errcheck = returnCodeCheck

    ats.AlazarSetCaptureClock.restype = U32
    ats.AlazarSetCaptureClock.argtypes = [U32, U32, U32, U32, U32]
    ats.AlazarSetCaptureClock.errcheck = returnCodeCheck

    ats.AlazarSetExternalClockLevel.restype = U32
    ats.AlazarSetExternalClockLevel.argtypes = [U32, c_float]
    ats.AlazarSetExternalClockLevel.errcheck = returnCodeCheck

    ats.AlazarSetExternalTrigger.restype = U32
    ats.AlazarSetExternalTrigger.argtypes = [U32, U32, U32]
    ats.AlazarSetExternalTrigger.errcheck = returnCodeCheck

    ats.AlazarSetLED.restype = U32
    ats.AlazarSetLED.argtypes = [U32, U32]
    ats.AlazarSetLED.errcheck = returnCodeCheck

    ats.AlazarSetParameter.restype = U32
    ats.AlazarSetParameter.argtypes = [U32, U8, U32, c_long]
    ats.AlazarSetParameter.errcheck = returnCodeCheck

    ats.AlazarSetParameterUL.restype = U32
    ats.AlazarSetParameterUL.argtypes = [U32, U8, U32, c_long]
    ats.AlazarSetParameterUL.errcheck = returnCodeCheck

    ats.AlazarSetRecordCount.restype = U32
    ats.AlazarSetRecordCount.argtypes = [U32, U32]
    ats.AlazarSetRecordCount.errcheck = returnCodeCheck

    ats.AlazarSetRecordSize.restype = U32
    ats.AlazarSetRecordSize.argtypes = [U32, U32, U32]
    ats.AlazarSetRecordSize.errcheck = returnCodeCheck

    ats.AlazarSetTriggerDelay.restype = U32
    ats.AlazarSetTriggerDelay.argtypes = [U32, U32]
    ats.AlazarSetTriggerDelay.errcheck = returnCodeCheck

    ats.AlazarSetTriggerOperation.restype = U32
    ats.AlazarSetTriggerOperation.argtypes = [U32, U32, U32, U32, U32, U32,
                                              U32, U32, U32, U32]
    ats.AlazarSetTriggerOperation.errcheck = returnCodeCheck

    ats.AlazarSetTriggerTimeOut.restype = U32
    ats.AlazarSetTriggerTimeOut.argtypes = [U32, U32]
    ats.AlazarSetTriggerTimeOut.errcheck = returnCodeCheck

    ats.AlazarSleepDevice.restype = U32
    ats.AlazarSleepDevice.argtypes = [U32, U32]
    ats.AlazarSleepDevice.errcheck = returnCodeCheck

    ats.AlazarStartCapture.restype = U32
    ats.AlazarStartCapture.argtypes = [U32]
    ats.AlazarStartCapture.errcheck = returnCodeCheck

    ats.AlazarTriggered.restype = U32
    ats.AlazarTriggered.argtypes = [U32]

    ats.AlazarWaitAsyncBufferComplete.restype = U32
    ats.AlazarWaitAsyncBufferComplete.argtypes = [U32, c_void_p, U32]
    ats.AlazarWaitAsyncBufferComplete.errcheck = returnCodeCheck


def returnCodeCheck(result, func, arguments):
    '''Function used internally to check the return code of the C ATS-SDK
    functions.'''
    if (result != 512):
        raise Exception(""Error calling function %s with arguments %s : %s"" %
                        (func.__name__,
                         str(arguments),
                         str(ats.AlazarErrorToText(result))))


class Board(object):
    """"""Interface to an AlazarTech digitizer.

    The Board class represents an acquisition device on the local
    system. It can be used to control configuration parameters, to
    start acquisitions and to retrieve the acquired data.

    Args:

      systemId (int): The board system identifier of the target
      board. Defaults to 1, which is suitable when there is only one
      board in the system.

      boardId (int): The target's board identifier in it's
      system. Defaults to 1, which is suitable when there is only one
      board in the system.

    """"""
    def __init__(self, systemId=1, boardId=1):
        if ats is None:
            load_library()
        self.systemId = systemId
        self.boardId = boardId
        self.handle = ats.AlazarGetBoardBySystemID(systemId, boardId)
        if self.handle == 0:
            raise Exception(""Board %d.%d not found"" % (systemId, boardId))

        self.type = ats.AlazarGetBoardKind(self.handle)

    def abortAsyncRead(self):
        """"""Cancels any asynchronous acquisition running on a board.

        """"""
        ats.AlazarAbortAsyncRead(self.handle)

    def abortCapture(self):
        """"""Abort an acquisition to on-board memory.

        """"""
        ats.AlazarAbortCapture(self.handle)

    def beforeAsyncRead(self, channels, transferOffset, samplesPerRecord,
                        recordsPerBuffer, recordsPerAcquisition, flags):
        """"""Prepares the board for an asynchronous acquisition.

        """"""
        ats.AlazarBeforeAsyncRead(self.handle, channels, transferOffset,
                                  samplesPerRecord, recordsPerBuffer,
                                  recordsPerAcquisition, flags)

    def busy(self):
        """"""Determine if an acquisition to on-board memory is in progress.

        """"""
        return True if (ats.AlazarBusy(self.handle) > 0) else False

    def configureAuxIO(self, mode, parameter):
        """"""Configures the auxiliary output.

        """"""
        ats.AlazarConfigureAuxIO(self.handle, mode, parameter)

    def configureLDB(self, valueLSB0, valueLSB1):
        """"""Change unused bits to digital outputs.

        """"""
        ats.AlazarConfigureLSB(self.handle, valueLSB0, valueLSB1)

    def configureRecordAverage(self, mode, samplesPerRecord, recordsPerAverage,
                               options):
        """"""Co-add ADC samples into accumulator record.

        """"""
        ats.AlazarConfigureRecordAverage(self.handle, mode, samplesPerRecord,
                                         recordsPerAverage, options)

    def forceTrigger(self):
        """"""Generate a software trigger event.

        """"""
        ats.AlazarForceTrigger(self.handle)

    def forceTriggerEnable(self):
        """"""Generate a software trigger enable event.

        """"""
        ats.AlazarForceTriggerEnable(self.handle)

    def getChannelInfo(self):
        """"""Get the on-board memory in samples per channel and sample size in
        bits per sample.

        """"""
        memorySize_samples = U32(0)
        bitsPerSample = U8(0)
        ats.AlazarGetChannelInfo(self.handle, byref(memorySize_samples),
                                 byref(bitsPerSample))
        return (memorySize_samples, bitsPerSample)

    def inputControl(self, channel, coupling, inputRange, impedance):
        """"""Configures one input channel on a board.

        """"""
        ats.AlazarInputControl(self.handle, channel, coupling, inputRange,
                               impedance)

    def numOfSystems():
        """"""Returns the number of board systems installed.

        """"""
        ats.AlazarNumOfSystems()

    def postAsyncBuffer(self, buffer, bufferLength):
        """"""Posts a DMA buffer to a board.

        """"""
        ats.AlazarPostAsyncBuffer(self.handle, buffer, bufferLength)

    def read(self, channelId, buffer, elementSize, record, transferOffset,
             transferLength):
        """"""Read all or part of a record from on-board memory.

        """"""
        ats.AlazarReadEx(self.handle, channelId, buffer, elementSize, record,
                         transferOffset, transferLength)

    def resetTimeStamp(self, option):
        """"""Control record timestamp counter reset.

        """"""
        ats.AlazarResetTimeStamp(self.handle, option)

    def setBWLimit(self, channel, enable):
        """"""Activates or deactivates the low-pass filter on a given channel.

        """"""
        ats.AlazarSetBWLimit(self.handle, channel, enable)

    def setCaptureClock(self, source, rate, edge, decimation):
        """"""Configures the board's acquisition clock.

        """"""
        ats.AlazarSetCaptureClock(self.handle,
                                  int(source),
                                  int(rate),
                                  int(edge),
                                  decimation)

    def setExternalClockLevel(self, level_percent):
        """"""Set the external clock comparator level.

        """"""
        ats.AlazarSetExternalClockLevel(self.handle, level_percent)

    def setExternalTrigger(self, coupling, range):
        """"""Configure the external trigger.

        """"""
        ats.AlazarSetExternalTrigger(self.handle, coupling, range)

    def setLED(self, ledState):
        """"""Control LED on a board's mounting bracket.

        """"""
        ats.AlazarSetLED(self.handle, ledState)

    def setParameter(self, channelId, parameterId, value):
        """"""Set a device parameter as a signed long value.

        """"""
        ats.AlazarSetParameter(self.handle, channelId, parameterId, value)

    def setParameterUL(self, channelId, parameterId, value):
        """"""Set a device parameter as a signed long value.

        """"""
        ats.AlazarSetParameterUL(self.handle, channelId, parameterId, value)

    def setRecordCount(self, count):
        """"""Configure the record count for single ported acquisitions.

        """"""
        ats.AlazarSetRecordCount(self.handle, count)

    def setRecordSize(self, preTriggerSamples, postTriggerSamples):
        """"""Configures the acquisition records size.

        """"""
        ats.AlazarSetRecordSize(self.handle, preTriggerSamples,
                                postTriggerSamples)

    def setTriggerDelay(self, delay_samples):
        """"""Configures the trigger delay.

        """"""
        ats.AlazarSetTriggerDelay(self.handle, delay_samples)

    def setTriggerOperation(self, operation,
                            engine1, source1, slope1, level1,
                            engine2, source2, slope2, level2):
        """"""Set trigger operation.

        """"""
        ats.AlazarSetTriggerOperation(
            self.handle, operation,
            engine1, source1, slope1, level1,
            engine2,
            source2,
            slope2,
            level2)

    def setTriggerTimeOut(self, timeout_clocks):
        """"""Configures the trigger timeout.

        """"""
        ats.AlazarSetTriggerTimeOut(self.handle, timeout_clocks)

    def sleepDevice(self, sleepState):
        """"""Control power to ADC devices.

        """"""
        ats.AlazarSleepDevice(self.handle, sleepState)

    def startCapture(self):
        """"""Starts the acquisition.

        """"""
        ats.AlazarStartCapture(self.handle)

    def triggered(self):
        """"""Determine if a board has triggered during the current acquisition.

        """"""
        return ats.AlazarTriggered(self.handle)

    def waitAsyncBufferComplete(self, buffer, timeout_ms):
        """"""Blocks until the board confirms that buffer is filled with data.

        """"""
        ats.AlazarWaitAsyncBufferComplete(self.handle, buffer, timeout_ms)
"
283,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34465 A Submodules,274.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34465A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34465A Submodules,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,"[OrderedDict([('id', 'attKNoonyjcAjx8df'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gf91ex_usjD_2YjXAXmawA/6YsiOk0Pf-sSO9eCNlCvmPyH3LfDl9eNOzlglpAlt_MJTnTtkIwgltpkIRDrk21n5kbfHHX-A4q34C_y_VqXywXinStjB6HUphZRIweoHF4cT4W_N3CZ_LFteOdOwEKe/IoClL6Kj5yD6XtWV1_zI5YaCR6uR6yrUq_K6baMzJo4'), ('filename', '34465A-TRANSP-01_1600x900.png'), ('size', 1368787), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mABnCK4zcSX7mKxQt6MDSA/3XoDVbfmQ41Ie54Cwhxgfy6xdtNpqs5Ayma1XfFS4cg-1tB6V_8AWf3YzGLIUq8IDnvywgHEfwAzSwlTb1VK7g/GyyWWtsGkt_mudI6YcCh-W8BsS5TSzKKVkQdOSDXc38'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fPB7EfQEdnX_auKuLKfCaQ/Lw2DK-vLykDYOfGMaxZjK7RwEaCjo6IaVGS8zp6nerrd6IM43XhgeRhyWU6aSI7ACXxN9q7HB9uNfFpO95m2ag/ypCINQcXux7z7gzCqobHf3kl-6gfnxblhgqPZPUVZpg'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vYTDEVfQQd_iqc-IagzBUw/8h6Qb84-2OANysgLocRCKIN4PvgCNE2ZPuPH4iYwdjj6PDar2daO_WYtM34SwUsphlSbzMtAt_gVDNiv1ITRfg/qEs3CM7pEZm_kOMRhmfr3wVaiW7BuSTDDUACa7nxR6o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34465A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34465A,1863.0,,True,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34465A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34465A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34465A(Keysight34465A):
    """"""
    Alias for backwards compatibility.
    """"""
"
284,367.3,"Abingdon, United Kingdom",,Triton,403.0,"Oxford Instruments plc is a United Kingdom manufacturing and research company that designs and manufactures tools and systems for industry and research. The company is headquartered in Abingdon, Oxfordshire, England, with sites in the United Kingdom, United States, Europe, and Asia.[2] It is listed on the London Stock Exchange and is a constituent of the FTSE 250 Index.[3]
",Qcodes,Oxford Instruments,"[OrderedDict([('id', 'attlP8b4ZXQRqQBKm'), ('width', 119), ('height', 41), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L40kknza-cq9NhsYZ_dxRA/X7-tAyMECMdzvktYW1Kl9_wKs3wsykQuO0IZcUkIUzd1B_SdZpcWdwl9ire2dJ4mn_NIUCi-fXkE9trZOQYGNZcnMFjuTh1vvVGqKQD84dU/VrmXwTzIYFMM9z1rDroBhvlRqvT8XcH2PaS_F3-DBVs'), ('filename', 'download (5).png'), ('size', 1521), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_iwpStMuWtl-rSHbrkzUAQ/EgBTs4xZ7Dzht1W2XWHZwA1IGIJgHbD9WzrjaY4JDkCpRuPRMJlEgH9kAtbBEv3RD3HgMi1bApV67Fl2XLSdRA/eqNmVJzdrw5n0i3TmwADh2OeVb_TzPLbJdyK-fKB4Js'), ('width', 104), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2KWjy__chX3lYbHxvvzC7A/oCguq8sGx6ptCIX60qNDU4zX3wcA7m3tHoFRlXkYelctl7EqLrPQoNCeIqY22MErR36kQ4F_3tKFWxOX6I_cew/mOJ13fJh8O9VXyMA8OvTyOiIwyNW4KVH-IsgIVcfDb0'), ('width', 119), ('height', 41)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DvsxvVsG2-FCGVv7Wp2EOQ/iepJ_ZVF6MEjfwH-AhuZOXTSsXAle_ZKdHBsg8p6sS1bjnYOipyCEkWYxvdPihG5eqYM44AUH9GOoLigHgnrew/5THJTVgjyS9Y6CAHL_n4U7QQVgBcQOwU25PKU6DxVzQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.oxinst.com/,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,,,,,,
286,5800.0,USA,"The MSO/DPO70000 Series oscilloscope delivers exceptional signal acquisition performance and analysis capability. Discover your real signals and capture more signal details with the industry's highest waveform capture capability. Automate setup, acquisition and analysis of high-speed serial data signals with a toolset engineered to deliver faster design and compliance testing.",Tektronix DPO 70000,582.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a DPO70000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",DPO70000,https://download.tek.com/document/55W-22447-9.pdf,"[OrderedDict([('id', 'attFjQAcYvzQS5GFO'), ('width', 480), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BZUCWIp3bGVS1QbZ69tILA/xlS7IOyu-hPw4hvbbEXxBjSMVtB-RyDDGTK8psI9gdiFm1ilDvG3lTJsTq5Xv8GM02yxIC9sHPq3uMr-H_cykFtDCxpQVZNaNcjS1PLDLsWl6L-5w4ztHLvHpZ44fiRwDYQlFGu4YJPlXBrwN3cGxg/EaV_SXGrD10R-lcDJZN1FKwd9XkjD5w4P-6YpijokGo'), ('filename', 'dpo-dsa-mso70000-series-sample-rate-performance.webp'), ('size', 17878), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/GrDCvfgZka7Y7bRICTHHLA/TPy7CHCZe2b1EdHnoBoeViiHwr-akRrcPvAmJXN82B1-cbHDRxMq4DPOltKLqkOUbxWUCOfbYS738ZonY3vF59hZ5Zg8OBUrG0A6Hx1V78U/kepNPbg0x0S656JwazSNKnePVG0UrHqK6BspcsPJFo8'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HfRw6OUo3quQsk4IIMd_gQ/gJHLLzutGMhG_6rYylbAmWFi-1fxXKwVcbLqeJbRmUqNooRcUPFRNjyMqfIWRowlq0ABZnagcVfELSSWJLSu9_nHIQIjQCQwQz7MKO_pxsc/nrZsZsyHkgPsSesXVpegxEArjDr6A6CNeFsSdJalp0Y'), ('width', 480), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/L8UILIYUmpKBuyt46bwRyg/wKLcKR8c6L2SyBlxuZy3Zn1jxkzKHM66SF84u5Hkaj26Q1igORZskxeMFl3snGZ_coOKfQNGvDJuMycpnn16BAEFjo7883LBJ1dBTC3dB9Q/SS2rGiw0bjerpaHbpVKTYQ2ak6rmuoUDDpSl4cSRhbI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.vicom.com.au/page/88/vicom-tektronix-mso70000-dpo70000-oscilloscopes,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO70000,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
292,5800.0,USA,"The industry-leading AWG70000A Series arbitrary waveform generator (AWG) provides you with unparalleled performance at the cutting edge for sample rate, signal fidelity, and waveform memory. In order to engineer the world's most complex data communications systems, the ability to create ideal, distorted and ""real life"" signals is essential. The AWG70000A Series of AWGs delivers this, giving you the industry's best signal stimulus solution for ever-increasing measurement challenges. With up to 50 GS/s and 10-bit vertical resolution, it offers easy generation of very complex signals and complete control over signal characteristics",AWG 70000 A,572.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG70000A RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG70000A,https://download.tek.com/datasheet/AWG70000A-Arbitrary-Waveform-Generator-Datasheet-76W283808.pdf,"[OrderedDict([('id', 'attjBjCeEspyu9dpX'), ('width', 294), ('height', 220), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/D48aE1qVEKY6EKW-DSgWcQ/BQ9jbu-pFYbd_AfNxp01TQYamS6wAKLvGq4rK0ZZ4I2lHB3qoVIWfVDIO3utiqPLkl2XNsAG4yubzsiDPHJbNbJl_E9I3T-Pk1M1QWgBJEOb4YTlvOyX4M5PDSXRvbi_-PVT8xDDsbuwEPpSj-kOSA/zi4gLS8S5MRcpDLzr_o1Fwg1kpmj9ebGLW6QHjpVwNE'), ('filename', '02aadca4ffd655cc627bb76eb7983ba7_1490966598.webp'), ('size', 4594), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/buWXQUva-hBjC37qCZ-yyw/XITITce8vXSw_xAXRLjztM8Bl6cvws_BVfmiHXpuJ56Gv7baJsHAhk32sS851fFevVmd1fQBygTf9QTeDwG3ABhqOWrhhZw4WD7xJX4nYEw/2aBgmwoCnFx2B9YJo96eaA2WniZ0kHwrpqO0p6-p3F8'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/K1igZ2sTIkFYYvZe2y-p4g/9JXVOyxOcbbrLuMPKTaHGRCg9Vott8iMfWK82aTio83aSn7sfTAHwO3ABHbGCHFRfhVyLxS98_xibhc-Tkymojzah8wPWw-LG1FjCFRgpNs/w6nQiloB2F7otBP-CUC2bOR6SuwWWQzy5hymBfWeb1o'), ('width', 294), ('height', 220)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4ctxMxjDi5GnCEeFS1O17Q/a6J165idjH3bgcwZNkjJC0oeNTOEdxXFBXPgaRoNmoNAjxIq7tlxxl2-DaWGyc6bHAahOQVk6sfsezJ9KCHwmMAZE3-ynEFiCmAVtqWNric/mK7jl_W0fsXo_cwxlqmWFHuciB8Y-s5Ifa2I40pYkEE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/arbitrary-waveform-generators-1,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70001A,,,True,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
298,5420.0,USA,"The 33512B provides Keysight’s exclusive Trueform technology which offers unmatched capabilities for generating a full range of signals for your most demanding measurements. The 33512B can be easily upgraded to 30 MHz as your needs change.

",Keysight 33512 B,291.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33512B RF Signal Generator,https://en.wikipedia.org/wiki/Arbitrary_waveform_generator,['RF Signal Generator'],An arbitrary waveform generator (AWG) is a piece of electronic test equipment used to generate electrical waveforms. These waveforms can be either repetitive or single-shot (once only) in which case some kind of triggering source is required (internal or external).,KEYSIGHT 33512B,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,"[OrderedDict([('id', 'attpW6fjxWdbx7J2i'), ('width', 1418), ('height', 741), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ug_RYjMm0MSSVEyOqqqMmg/L4ZliOXIs4-o5VjNuUdulAQ9fDaV71b0Z6xT1y7SdgVWHMNIBre-YNQlz-LUAy8WbaGjwOZStWD_VEepyxCC4TjxcBDpIf2nRXdyZMS_sdQ/98gU2Y8szwzy0wdpC67y-NYEeNy7sJ2_KnRe4eRBS78'), ('filename', '94T6987-40.jpg'), ('size', 99871), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t_t8rPNTeH0nuyboe8_UwA/bRlmGrcQD2wwA8lcL4a7HYJFqUQ2zZJaf0LxqSu8DvRhnc3Zda2iPVDdEiaAtYYVVLmb5W8e5bdkD5Ejj5H5dw/b6_hkp1to-daQPvLbIlA49kzPRQnr3jL_IsG28SJweM'), ('width', 69), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/umDe4WdbPpIt_OYyFIDz5Q/lLAguw0J9j21EVrl_EQRb2fbrwYZrJFh24JlAN0MC1Npt7HvYvSfz0qtnhQHXVkqpqvFZINMGkLIFRMcVKWWOw/vXPylXoO911s3PkJXzkfNRKaF9n_P6p4QEcQimoXZeo'), ('width', 980), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/B6E6pBGNxiv8U5lzJjibWw/2MC9asY4rbV8h0XGFEmIuphIeBwLUUCzapQcB_V6gIf7OBVZOiJLT0wCJgUstkeJiez60kzGPJ80SBqRSOg5BQ/-ro9Kl61_hoEOIPe5CM3AZPGnZxyDNF3CFI8IaxYweI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/33512B/waveform-generator-20-mhz-2-channel-arb.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_33512b.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight33512B,4187.0,,,,"from .KeysightAgilent_33XXX import WaveformGenerator_33XXX


class Keysight33512B(WaveformGenerator_33XXX):
    """"""
    QCoDeS driver for the Keysight 33512B waveform generator.
    """"""
"
301,110.6,"Cleveland, Ohio, United States","The Model 2601B SourceMeter SMU instrument, is a new and improved one channel SMU instrument with a tightly integrated four-quadrant design that allows it to simultaneously source and measure both voltage and current to boost productivity in applications ranging from R&D to automated production test. In addition to retaining all the features of the Model 2601A, the Model 2601B has 6½-digit resolution, USB 2.0 connectivity, and software command emulation of the Model 2400 SourceMeter SMU Instrument that enables easy migration of legacy test code. The Model 2601B model is equipped with Keithley's high speed TSP technology (over 190% faster than traditional PC-to-instrument communication techniques,) which dramatically improves the system-level speed to lower the cost of test.",Keithley 2601 B,244.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2601B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2601B,https://www.testequipmenthq.com/datasheets/KEITHLEY-2601-Datasheet.pdf,"[OrderedDict([('id', 'att4qoFB6Y2hcqftg'), ('width', 800), ('height', 428), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/N_khh5nTwHR1pUfFXfH0hA/tmpHOJjkFrOtfpBdZ3Ai77buBD82q5-75R58cEzhSXjfF1-rOwha0pX_Qr53vRkugB1hp8omaK1q-Iz8oxuTqN1PnrIUoUXh23Lql8DwXhE/AA8IhVGCkFflHpbgwo0QCRFG84cDTZyBVXgmduo5Vbg'), ('filename', '2601b.webp'), ('size', 29670), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6hwU1n60uD22QNfhEK13pA/hAmAKdwCYMXGZX5g-7DinO5htySoJVEYH-TaSjnElIE1sGLD01CYeMODyPCdRxYKVucE0R0BhmGIlRljV9qp7SFKYoj3HhOE45bII0RwBUY/9-FpEnHCOPbjUpXUjko4Fsf31QuP0-scECztC7FQGKo'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/C6E8FfS2hsl6uBCXArUJzA/elbVMIpOWFnp4yTMrgMsTeo2p5IqpyPPfwdHNZ8aoHpWFomZWqzttcZvM1XKYG3Q1nqVFnUjMrixQxkW3mI6yKPiRc9iJlSPHRnFJG7gwY0/TYk3dLqkYNOaJYW0o8dZ0e8JZzkNb2MuwicwpHZ0-Zo'), ('width', 800), ('height', 428)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2MYiK5uVmfc3vR8hMMd_hA/k8cH4-aMsONbcde3S-0Sk2A46ZeubcKcLKDdU-lnrCwK4vmtFBc-ACwKwOKZePsfjn3l_l4IgT75BX_QpYs22-Ks-nTMI2IYdpswXo8RWgM/wED2LRGzZw9OWq7xle5BE44xhlC7kRKCDdXM0pwvmHU'), ('width', 3000), ('height', 3000)]))]))])]",https://canada.newark.com/keithley/2601b/source-meter-voltage-current-40/dp/44W8033,,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2601B,20700.0,,,,
303,38.0,Switzerland,"The Zurich Instruments PQSC Programmable Quantum System Controller brings together the instrumentation required for quantum computers with up to 100 qubits. Its ZSync low-latency, real-time communication links are designed specifically for quantum computing: the PQSC overcomes the practical limitations of traditional control methods, making automated and rapid qubit calibration routines a reality. Programming access to the powerful Xilinx UltraScale+ FPGA is the basis for developing new and optimized processing solutions for rapid tune-up and error correction adapted to the specific algorithm and computer architecture in use.",Pqsc,642.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a PQSC ,https://www.zhinst.com/americas/en/quantum-computing-systems/qccs,,"A Quantum Computing Control System (QCCS) is designed to control more than 100 superconducting and spin qubits. Each component of the QCCS is conceived to play a specific role in qubit control, readout and feedback, and operates in a fully synchronized manner with the other parts of the system.",PQSC,https://docs.zhinst.com/pdf/ziPQSC_UserManual.pdf,"[OrderedDict([('id', 'att6goJYKFtx2hmvC'), ('width', 1183), ('height', 309), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/waqoCHgHzWJXbwRDpdCUlg/ivjiOfmhxmqjI7X_bt704jwEoAhd-AkibbACU8vjHtqA-oBKMPYvlzkSGZPtf7Me2SJpaFuNZ8p-wnNwACI_B3jcMi4j6o10fg0-8oFYWQuGG0PtKvBcNaYu4A63-gFE/JAEdFadnieghRTjr6Pr5ObDsPnRGB5EcgqPyyWq-woM'), ('filename', 'PQSC_front_rackmounts_1800.png.webp'), ('size', 20698), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rXWTLN-X8QgkdKBrJI-pGg/jBoFZCIPMGeYaC3OISYJeyAE07gziE1olDylFTCChT93neBtsZGlodZW2SL-R-bLU9jijMNsfop3q4nFuUewXF71vNbtJxw3NwQMAS2UAjk/cBJD7pWxAn91YCWnawY-Kja6cIWCAX0hotmpOfcLMfM'), ('width', 138), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kVo0LoLCI2kAi_j6Vf-HYQ/K3vj9SkUVcfB0mEIhCuhUKX6qoRgtRcOAx2OFy_BY_tHFjeN2Nd_2K9uwJuYQtu4xuhQ75ppsW3BbYTlfCk3QXM6DXPsxMc9WohAKE1zItM/1FXIre31F_RZwVj6raXruJ2HbAjD4cQKodnIgI14r7w'), ('width', 1183), ('height', 309)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OPOafBkCgnyx8djhaQuYJg/Fk-VAIDFdeRKJbrKJt-mjBMDoh-aa2ybBBGemeaTrMhIW99klq4kpNiO2BUP_dCIC9DG1eysDPlO8dcznzBd3aKz65fzwkxwrZN6zggQe5I/47oL_lGsCNzGA28GDvEO7L-ug0cdbjSklIzqmDzYVwQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/pqsc-programmable-quantum-system-controller,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/pqsc.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.pqsc.html,,,,,"""""""Autogenerated module for the PQSC QCoDeS driver.""""""
from typing import List, Union
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument


class PQSC(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments PQSC.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""

    def arm(self, *, deep=True, repetitions: int = None, holdoff: float = None) -> None:
        """"""Prepare PQSC for triggering the instruments.

        This method configures the execution engine of the PQSC and
        clears the register bank. Optionally, the *number of triggers*
        and *hold-off time* can be set when specified as keyword
        arguments. If they are not specified, they are not changed.

        Note that the PQSC is disabled at the end of the hold-off time
        after sending out the last trigger. Therefore, the hold-off time
        should be long enough such that the PQSC is still enabled when
        the feedback arrives. Otherwise, the feedback cannot be processed.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after stopping the PQSC and clearing the
                register bank (default: True).
            repetitions: If specified, the number of triggers sent
                over ZSync ports will be set (default: None).
            holdoff: If specified, the time between repeated
                triggers sent over ZSync ports will be set. It has a
                minimum value and a granularity of 100 ns
                (default: None).

        """"""
        return self._tk_object.arm(deep=deep, repetitions=repetitions, holdoff=holdoff)

    def run(self, *, deep: bool = True) -> None:
        """"""Start sending out triggers.

        This method activates the trigger generation to trigger all
        connected instruments over ZSync ports.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after enabling the PQSC (default: True).

        """"""
        return self._tk_object.run(deep=deep)

    def arm_and_run(self, *, repetitions: int = None, holdoff: float = None) -> None:
        """"""Arm the PQSC and start sending out triggers.

        Simply combines the methods arm and run. A synchronization
        is performed between the device and the data server after
        arming and running the PQSC.

        Args:
            repetitions: If specified, the number of triggers sent
                over ZSync ports will be set (default: None).
            holdoff: If specified, the time between repeated
                triggers sent over ZSync ports will be set. It has a
                minimum value and a granularity of 100 ns
                (default: None).

        """"""
        return self._tk_object.arm_and_run(repetitions=repetitions, holdoff=holdoff)

    def stop(self, *, deep: bool = True) -> None:
        """"""Stop the trigger generation.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after disabling the PQSC (default: True).

        """"""
        return self._tk_object.stop(deep=deep)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until trigger generation and feedback processing is done.

        Args:
            timeout: The maximum waiting time in seconds for the
                PQSC (default: 10).
            sleep_time: Time in seconds to wait between
                requesting PQSC state

        Raises:
            TimeoutError: If the PQSC is not done sending out all
                triggers and processing feedback before the timeout.
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def check_ref_clock(self, *, timeout: int = 30, sleep_time: int = 1) -> bool:
        """"""Check if reference clock is locked successfully.

        Args:
            timeout: Maximum time in seconds the program waits
                (default: 30).
            sleep_time: Time in seconds to wait between
                requesting the reference clock status (default: 1)

        Raises:
            TimeoutError: If the process of locking to the reference clock
                exceeds the specified timeout.
        """"""
        return self._tk_object.check_ref_clock(timeout=timeout, sleep_time=sleep_time)

    def check_zsync_connection(
        self,
        ports: Union[List[int], int] = 0,
        *,
        timeout: int = 30,
        sleep_time: int = 1,
    ) -> Union[List[bool], bool]:
        """"""Check if the ZSync connection on the given port(s) is established.

        This function checks the current status of the instrument connected to
        the given ports.

        Args:
            ports: The port numbers to check the ZSync connection for.
                It can either be a single port number given as integer or a list
                of several port numbers. (default: 0)
            timeout: Maximum time in seconds the program waits (default: 30).
            sleep_time: Time in seconds to wait between requesting the reference
                clock status (default: 1)

        Raises:
            TimeoutError: If the process of establishing a ZSync connection on
                one of the specified ports exceeds the specified timeout.
        """"""
        return self._tk_object.check_zsync_connection(
            ports=ports, timeout=timeout, sleep_time=sleep_time
        )

    def find_zsync_worker_port(self, device: ZIBaseInstrument) -> int:
        """"""Find the ID of the PQSC ZSync port connected to a given device.

        Args:
            pqsc: PQSC device over whose ports the research shall be done.
            device: device for which the connected ZSync port shall be found.

        Returns:
            Integer value represent the ID of the searched PQSC Zsync port.

        Raises:
            ToolkitError: If the given device doesn't appear to be connected
                to the PQSC via ZSync.

        .. versionadded:: 0.5.1
        """"""
        return self._tk_object.find_zsync_worker_port(device=device._tk_object)
"
305,5420.0,USA,,"Ktmawg
",285.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KtMAwg IVI-C RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"An arbitrary waveform generator (AWG or ARB) is a sophisticated signal generator that generates arbitrary waveforms within published limits of frequency range, accuracy, and output level. Unlike a function generator that produces a small set of specific waveforms, an AWG allows the user to specify a source waveform in a variety of different ways.",KtMAwg IVI-C,,"[OrderedDict([('id', 'atts4XZWkT4pxuTR4'), ('width', 300), ('height', 166), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/kgqmhQDWvddN6A2c0K4Bzw/oE6Nqv0IfUiTk2RtXhN08IywLflMQ0UYkQNMakKWBjrlL6HpVny7CxvB7ocbeHEihi6E3x6k8AUmDW_TER1AwdRECWQY-yVmKozlRCL-dkU/EEH9NEeCrLy9m4VurjdvYvkLXQC-6_GlK1mGYNI7F6g'), ('filename', 'PROD-2917039-01.jpeg'), ('size', 7332), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hPLvhsh_I6n7eg8MiEXVPw/EtduQHaNViCMztoBfcNVGzdlIlM_0HSNgqsfVZFtKW3d4FIRkDIv0SoxzkMD8KGCFg-SIZqGfCsucpblbXX6Pg/qKfDJKd4WR4izF9KWnqKcsNczbbKn7DDzNNGyO_3GME'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HXUIv_n0ZC00eZwHpyNVAA/ZdkLSmc5CEoJ7glbPYxKDtlCvmUNIlB9vXPrTkgqDKHdUMcKeYYcBLzimJBnBaiM5EZffUce09XqJfQ2xWhnnQ/rR2J99GHLvpr5iBA4tTe2jWvTgPRjI0VqUFRoN_f73A'), ('width', 300), ('height', 166)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zjgZY80oZlrsBSjmQPp_Kg/HJwswloDTm5FrNax3_5NfYFFC4mLgli4n2Ty08nQLbFzrlDpT8V6RAP7miZoPMpvId-PuQDNyWpcprQX6lw6vg/YbIOjenmGQKesxifZq7nWSZje3d0svKYMF8incnxBf0'), ('width', 3000), ('height', 3000)]))]))])]",,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/KtMAwg.py,https://qcodes.github.io/Qcodes/_modules/qcodes/instrument_drivers/Keysight/KtMAwg.html,,,,,"from .KtMAwgDefs import *

import ctypes
from functools import partial
from typing import Dict, Optional, Any

from qcodes.instrument.base import Instrument
from qcodes.instrument.channel import InstrumentChannel
from qcodes.utils.validators import Numbers
from qcodes.utils.helpers import create_on_off_val_mapping


class KtMAWGChannel(InstrumentChannel):
    """"""
    Represent the three channels of the Keysight KTM Awg driver.
    The channels can be independently controlled and programmed with
    seperate waveforms.
    """"""

    def __init__(self, parent: 'KtMAwg', name: str, chan: int) -> None:

        # Sanity Check inputs
        if name not in [""ch1"", ""ch2"", ""ch3""]:
            raise ValueError(f""Invalid channel: {name}, expecting ch1:ch3"")
        if chan not in [1, 2, 3]:
            raise ValueError(f""Invalid channel: {chan}, expecting ch1:ch3"")

        super().__init__(parent, name)
        self._channel = ctypes.create_string_buffer(
            f""Channel{chan}"".encode(""ascii"")
        )

        # Used to access waveforms loaded into the driver
        self._awg_handle: Optional[ctypes.c_int32] = None

        self._catch_error = self.root_instrument._catch_error

        self.add_parameter(
            ""output_term_config"",
            label=""Output Terminal Configuration"",
            get_cmd=partial(
                self.root_instrument._get_vi_int,
                KTMAWG_ATTR_TERMINAL_CONFIGURATION,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_int,
                KTMAWG_ATTR_TERMINAL_CONFIGURATION,
                ch=self._channel
            ),
            val_mapping={
                ""differential"": KTMAWG_VAL_TERMINAL_CONFIGURATION_DIFFERENTIAL,
                ""single"": KTMAWG_VAL_TERMINAL_CONFIGURATION_SINGLE_ENDED,
            },
        )

        self.add_parameter(
            ""operation"",
            label=""Operating Mode"",
            get_cmd=partial(
                self.root_instrument._get_vi_int,
                KTMAWG_ATTR_OPERATION_MODE,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_int,
                KTMAWG_ATTR_OPERATION_MODE,
                ch=self._channel
            ),
            val_mapping={
                ""continuous"": KTMAWG_VAL_OPERATE_CONTINUOUS,
                ""burst"": KTMAWG_VAL_OPERATE_BURST,
            },
        )

        self.add_parameter(
            ""output"",
            label=""Output Enable"",
            get_cmd=partial(
                self.root_instrument._get_vi_bool,
                KTMAWG_ATTR_OUTPUT_ENABLED,
                ch=self._channel
            ),
            set_cmd=partial(
                self.root_instrument._set_vi_bool,
                KTMAWG_ATTR_OUTPUT_ENABLED,
                ch=self._channel
            ),
            val_mapping=create_on_off_val_mapping(on_val=1, off_val=0),
        )

        self.add_parameter(
            ""gain_config"",
            label=""AWG Gain Control Mode"",
            set_cmd=self._set_gain_control,
            get_cmd=self._get_gain_control,
            val_mapping={
                ""composite"": KTMAWG_VAL_GAIN_CONTROL_COMPOSITE,
                ""component"": KTMAWG_VAL_GAIN_CONTROL_COMPONENT,
            },
        )
        self.add_parameter(""gain"",
                           label=""Composite Output Gain"",
                           set_cmd=self._set_gain,
                           vals=Numbers(0, 0.7999),
                           get_cmd=None)

        self.add_parameter(
            ""analog_gain"",
            label=""Analog Output Gain"",
            vals=Numbers(0, 1.32),
            set_cmd=self._set_analog_gain,
            get_cmd=self._get_analog_gain,
        )

        self.add_parameter(
            ""digital_gain"",
            label=""Digital Output Gain"",
            vals=Numbers(0, 1.0),
            set_cmd=self._set_digital_gain,
            get_cmd=self._get_digital_gain,
        )

    def load_waveform(self, filename: str) -> None:
        path = ctypes.create_string_buffer(filename.encode(""ascii""))
        self._awg_handle = ctypes.c_int32(-1)
        status = self.root_instrument._dll.\
            KtMAwg_WaveformCreateChannelWaveformFromFile(
                self.root_instrument._session,
                self._channel,
                b""SineWaveform"",
                0, path,
                ctypes.byref(self._awg_handle),
            )
        self.root_instrument._catch_error(status)

    def clear_waveform(self) -> None:
        if self._awg_handle is not None:
            status = self.root_instrument._dll.KtMAwg_ClearArbWaveform(
                self.root_instrument._session, self._awg_handle
            )
            self._catch_error(status)
            self._awg_handle = None

    def play_waveform(self) -> None:
        if self._awg_handle is None:
            raise ValueError(""Waveform has not been loaded!"")

        status = self.root_instrument._dll.KtMAwg_ArbitrarySetHandle(
            self.root_instrument._session, self._channel, self._awg_handle
        )

        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_Resolve(
            self.root_instrument._session
        )
        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_Apply(
            self.root_instrument._session
        )
        self._catch_error(status)

        status = self.root_instrument._dll.KtMAwg_InitiateGenerationByChannel(
            self.root_instrument._session, self._channel
        )
        self._catch_error(status)

    def stop_waveform(self) -> None:
        status = self.root_instrument._dll.KtMAwg_AbortGenerationByChannel(
            self.root_instrument._session, self._channel
        )
        self._catch_error(status)

    def _set_gain_control(self, val: int) -> None:
        self.root_instrument._dll.KtMAwg_ArbitrarySetGainControl(
            self.root_instrument._session, self._channel, val
        )

    def _get_gain_control(self) -> int:
        res = ctypes.c_int32(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetGainControl(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_analog_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetAnalogGain(
            self.root_instrument._session, self._channel, v
        )

    def _get_analog_gain(self) -> float:
        res = ctypes.c_double(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetAnalogGain(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_digital_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetDigitalGain(
            self.root_instrument._session, self._channel, v
        )

    def _get_digital_gain(self) -> float:
        res = ctypes.c_double(0)
        self.root_instrument._dll.KtMAwg_ArbitraryGetDigitalGain(
            self.root_instrument._session, self._channel, ctypes.byref(res)
        )
        return res.value

    def _set_gain(self, val: float) -> None:
        v = ctypes.c_double(val)
        self.root_instrument._dll.KtMAwg_ArbitrarySetGain(
            self.root_instrument._session, self._channel, v
        )


class KtMAwg(Instrument):
    """"""
    AWG Driver for the Keysight M9336A PXIe I/Q Arbitrary Waveform
    Generator. This driver provides a simple wrapper around the
    IVI-C drivers from Keysight. The output configuration, gain
    can be controlled and a waveform can be loaded from a file.
    """"""
    _default_buf_size = 256

    def __init__(self,
                 name: str,
                 address: str,
                 options: str = """",
                 dll_path: str = r""C:\Program Files\IVI ""
                                 r""Foundation\IVI\Bin\KtMAwg_64.dll"",
                 **kwargs: Any) -> None:
        super().__init__(name, **kwargs)

        self._address = bytes(address, ""ascii"")
        self._options = bytes(options, ""ascii"")
        self._session = ctypes.c_int(0)
        self._dll_loc = dll_path
        self._dll = ctypes.cdll.LoadLibrary(self._dll_loc)
        self._channel = ctypes.create_string_buffer(b""Channel1"")

        for ch_num in [1, 2, 3]:
            ch_name = f""ch{ch_num}""
            channel = KtMAWGChannel(
                self,
                ch_name,
                ch_num,
            )
            self.add_submodule(ch_name, channel)

        self._get_driver_desc = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_DESCRIPTION
        )
        self._get_driver_prefix = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_PREFIX
        )
        self._get_driver_revision = partial(
            self._get_vi_string, KTMAWG_ATTR_SPECIFIC_DRIVER_REVISION
        )
        self._get_firmware_revision = partial(
            self._get_vi_string, KTMAWG_ATTR_INSTRUMENT_FIRMWARE_REVISION
        )
        self._get_model = partial(self._get_vi_string,
                                  KTMAWG_ATTR_INSTRUMENT_MODEL)
        self._get_serial_number = partial(
            self._get_vi_string, KTMAWG_ATTR_MODULE_SERIAL_NUMBER
        )
        self._get_manufacturer = partial(
            self._get_vi_string, KTMAWG_ATTR_INSTRUMENT_MANUFACTURER
        )

        self._connect()

        self.connect_message()

    def _connect(self) -> None:
        status = self._dll.KtMAwg_InitWithOptions(
            self._address, 1, 1, self._options, ctypes.byref(self._session)
        )
        if status:
            raise SystemError(f""connection to device failed! error: {status}"")

    def get_idn(self) -> Dict[str, Optional[str]]:
        """"""generates the ``*IDN`` dictionary for qcodes""""""

        id_dict: Dict[str, Optional[str]] = {
            ""firmware"": self._get_firmware_revision(),
            ""model"": self._get_model(),
            ""serial"": self._get_serial_number(),
            ""vendor"": self._get_manufacturer(),
            ""driver desc"": self._get_driver_desc(),
            ""driver prefix"": self._get_driver_prefix(),
            ""driver revision"": self._get_driver_revision()
        }
        return id_dict

    def _catch_error(self, status: int) -> None:
        if status == 0:
            # No error
            return

        err = ctypes.c_int32(0)
        err_msg = ctypes.create_string_buffer(256)

        self._dll.KtMAwg_GetError(self._session,
                                  ctypes.byref(err),
                                  255,
                                  err_msg)

        raise ValueError(f""Got dll error num {err.value}""
                         f""msg {err_msg.value.decode('ascii')}"")

    # Query the driver for errors

    def get_errors(self) -> Dict[int, str]:
        error_code = ctypes.c_int(-1)
        error_message = ctypes.create_string_buffer(256)
        error_dict = dict()
        while error_code.value != 0:
            status = self._dll.KtMAwg_error_query(
                self._session, ctypes.byref(error_code), error_message
            )
            assert status == 0
            error_dict[error_code.value] = error_message.value.decode('utf-8')

        return error_dict

    # Generic functions for reading/writing different attributes
    def _get_vi_string(self, attr: int, ch: bytes = b"""") -> str:
        s = ctypes.create_string_buffer(self._default_buf_size)
        status = self._dll.KtMAwg_GetAttributeViString(
            self._session, ch, attr, self._default_buf_size, s
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return s.value.decode(""utf-8"")

    def _get_vi_bool(self, attr: int, ch: bytes = b"""") -> bool:
        s = ctypes.c_uint16(0)
        status = self._dll.KtMAwg_GetAttributeViBoolean(
            self._session, ch, attr, ctypes.byref(s)
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return bool(s)

    def _set_vi_bool(self, attr: int, value: bool, ch: bytes = b"""") -> None:
        v = ctypes.c_uint16(1) if value else ctypes.c_uint16(0)
        status = self._dll.KtMAwg_SetAttributeViBoolean(self._session,
                                                        ch,
                                                        attr,
                                                        v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_real64(self, attr: int, ch: bytes = b"""") -> float:
        s = ctypes.c_double(0)
        status = self._dll.KtMAwg_GetAttributeViReal64(
            self._session, ch, attr, ctypes.byref(s)
        )

        if status:
            raise ValueError(f""Driver error: {status}"")
        return float(s.value)

    def _set_vi_real64(self, attr: int, value: float, ch: bytes = b"""") -> None:
        v = ctypes.c_double(value)
        status = self._dll.KtMAwg_SetAttributeViReal64(self._session,
                                                       ch,
                                                       attr,
                                                       v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _set_vi_int(self, attr: int, value: int, ch: bytes = b"""") -> None:
        v = ctypes.c_int32(value)
        status = self._dll.KtMAwg_SetAttributeViInt32(self._session,
                                                      ch,
                                                      attr,
                                                      v)
        if status:
            raise ValueError(f""Driver error: {status}"")

    def _get_vi_int(self, attr: int, ch: bytes = b"""") -> int:
        v = ctypes.c_int32(0)
        status = self._dll.KtMAwg_GetAttributeViInt32(
            self._session, ch, attr, ctypes.byref(v)
        )
        if status:
            raise ValueError(f""Driver error: {status}"")
        return int(v.value)

    def close(self) -> None:
        self._dll.KtMAwg_close(self._session)
        super().close()
"
310,21.4,"Westerville, Ohio, USA","The Model 336 supports the industry’s most advanced line of cryogenic temperature sensors as manufactured by Lake Shore, including diodes, resistance temperature detectors (RTDs), and thermocouples. The controller’s zone tuning feature allows you to measure and control temperatures seamlessly from 300 mK to over 1,500 K by automatically switching temperature sensor inputs when your temperature range goes beyond the usable range of a given sensor. ",Lakeshore Model 336,357.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Qcodes,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,https://www.lakeshore.com/docs/default-source/product-downloads/336_manual0ebc9b06cbbb456491c65cf1337983e4.pdf?sfvrsn=2e8633a3_1,"[OrderedDict([('id', 'attwqg6J12YoieGX3'), ('width', 505), ('height', 147), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2dv6fwxzLxelR-Y-r6OZGQ/tsdzC9cVtywIaun157Md6EbId_4RijhkTMGpBs8NhUD-j-iAKlWEwwufJpZrPwxHCPsWwyjnoc4e-W_Yg-7wzw/66RQEtuVmzMKvbxj8krMdX43kTsiBy7FzqksE_JSrto'), ('filename', '336.png'), ('size', 105341), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rc0oWHZg4SPR6jdD2kdNcg/x-mMjPk77vrNrpWxnBzFBmqlvpL4VHjNPlYMumkx-o_fwIRWAswxCYl5QrnauDFwzJyHwr60w1T8H3z_uEDo6w/gK5yDSFcf8RxxuAKZ-2cLXa9r6B29XM4UOIMoyu7pZc'), ('width', 124), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QBfdLZeVNjrshv4ncjJeSg/xOLCwKQyNx2CdRj0kKXZwvtC_fZ_VNN5xb2WJ5drzcUWK1NH8LYfuICaZfAQqOu0WqOrCzfXijX-YjyEHdgHpw/CfOIqDH8BTCrfaYQbt1CYNk2iTEUUshsNYSnT_xNp_U'), ('width', 505), ('height', 147)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/D3e6maGiL2sscmZKZ612wg/ySnskXpOBPcFp_fulGf1RycA4qN9HY2Bb1o2lINvMQ8plbg2W59Dp7qi6F-BQD6zldo63CstfpIPSDtTjFlsJg/oiPBJvvRii4D6dNi4_TtP1yIcS44L2znaaFeILSiq9o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-336-cryogenic-temperature-controller,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_325.py,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel325,5188.0,,,,"from collections.abc import Iterable
from enum import IntFlag
from itertools import takewhile
from typing import Any, Optional, TextIO, cast

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import Group, GroupParameter
from qcodes.validators import Enum, Numbers


def _read_curve_file(curve_file: TextIO) -> dict[Any, Any]:
    """"""
    Read a curve file with extension .330
    The file format of this file is shown in test_lakeshore_file_parser.py
    in the test module

    The output is a dictionary with keys: ""metadata"" and ""data"".
    The metadata dictionary contains the first n lines of the curve file which
    are in the format ""item: value"". The data dictionary contains the actual
    curve data.
    """"""

    def split_data_line(line: str, parser: type = str) -> list[Any]:
        return [parser(i) for i in line.split(""  "") if i != """"]

    def strip(strings: Iterable[str]) -> tuple[str, ...]:
        return tuple(s.strip() for s in strings)

    lines = iter(curve_file.readlines())
    # Meta data lines contain a colon
    metadata_lines = takewhile(lambda s: "":"" in s, lines)
    # Data from the file is collected in the following dict
    file_data: dict[str, dict[str, Any]] = dict()
    # Capture meta data
    parsed_lines = [strip(line.split("":"")) for line in metadata_lines]
    file_data[""metadata""] = {key: value for key, value in parsed_lines}
    # After meta data we have a data header
    header_items = strip(split_data_line(next(lines)))
    # After that we have the curve data
    data: list[list[float]] = [
        split_data_line(line, parser=float) for line in lines if line.strip() != """"
    ]
    file_data[""data""] = dict(zip(header_items, zip(*data)))

    return file_data


def _get_sanitize_data(file_data: dict[Any, Any]) -> dict[Any, Any]:
    """"""
    Data as found in the curve files are slightly different from
    the dictionary as expected by the 'upload_curve' method of the
    driver
    """"""
    data_dict = dict(file_data[""data""])
    # We do not need the index column
    del data_dict[""No.""]
    # Rename the 'Units' column to the appropriate name
    # Look up under the 'Data Format' entry to find what units we have
    data_format = file_data[""metadata""][""Data Format""]
    # This is a string in the form '4      (Log Ohms/Kelvin)'
    data_format_int = int(data_format.split()[0])
    correct_name = LakeshoreModel325Curve.valid_sensor_units[data_format_int - 1]
    # Rename the column
    data_dict[correct_name] = data_dict[""Units""]
    del data_dict[""Units""]

    return data_dict


class LakeshoreModel325Status(IntFlag):
    """"""
    IntFlag that defines status codes for Lakeshore Model 325
    """"""
    sensor_units_overrang = 128
    sensor_units_zero = 64
    temp_overrange = 32
    temp_underrange = 16
    invalid_reading = 1


class LakeshoreModel325Curve(InstrumentChannel):
    """"""
    An InstrumentChannel representing a curve on a Lakeshore Model 325
    """"""

    valid_sensor_units = [""mV"", ""V"", ""Ohm"", ""log Ohm""]
    temperature_key = ""Temperature (K)""

    def __init__(self, parent: ""LakeshoreModel325"", index: int) -> None:

        self._index = index
        name = f""curve_{index}""
        super().__init__(parent, name)

        self.add_parameter(""serial_number"", parameter_class=GroupParameter)

        self.add_parameter(
            ""format"",
            val_mapping={
                f""{unt}/K"": i + 1 for i, unt in enumerate(self.valid_sensor_units)
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(""limit_value"", parameter_class=GroupParameter)

        self.add_parameter(
            ""coefficient"",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )

        self.add_parameter(""curve_name"", parameter_class=GroupParameter)

        Group(
            [
                self.curve_name,
                self.serial_number,
                self.format,
                self.limit_value,
                self.coefficient,
            ],
            set_cmd=f""CRVHDR {self._index}, {{curve_name}}, ""
            f""{{serial_number}}, {{format}}, {{limit_value}}, ""
            f""{{coefficient}}"",
            get_cmd=f""CRVHDR? {self._index}"",
        )

    def get_data(self) -> dict[Any, Any]:
        curve = [
            float(a)
            for point_index in range(1, 200)
            for a in self.ask(f""CRVPT? {self._index}, {point_index}"").split("","")
        ]

        d = {self.temperature_key: curve[1::2]}
        sensor_unit = self.format().split(""/"")[0]
        d[sensor_unit] = curve[::2]

        return d

    @classmethod
    def validate_datadict(cls, data_dict: dict[Any, Any]) -> str:
        """"""
        A data dict has two keys, one of which is 'Temperature (K)'. The other
        contains the units in which the curve is defined and must be one of:
        'mV', 'V', 'Ohm' or 'log Ohm'

        This method validates this and returns the sensor unit encountered in
        the data dict
        """"""
        if cls.temperature_key not in data_dict:
            raise ValueError(
                f""At least {cls.temperature_key} needed in the "" f""data dictionary""
            )

        sensor_units = [i for i in data_dict.keys() if i != cls.temperature_key]

        if len(sensor_units) != 1:
            raise ValueError(
                ""Data dictionary should have one other key, other then ""
                ""'Temperature (K)'""
            )

        sensor_unit = sensor_units[0]

        if sensor_unit not in cls.valid_sensor_units:
            raise ValueError(
                f""Sensor unit {sensor_unit} invalid. This needs to be one of ""
                f""{', '.join(cls.valid_sensor_units)}""
            )

        data_size = len(data_dict[cls.temperature_key])
        if data_size != len(data_dict[sensor_unit]) or data_size > 200:
            raise ValueError(
                ""The length of the temperature axis should be ""
                ""the same as the length of the sensor axis and ""
                ""should not exceed 200 in size""
            )

        return sensor_unit

    def set_data(
        self, data_dict: dict[Any, Any], sensor_unit: Optional[str] = None
    ) -> None:
        """"""
        Set the curve data according to the values found the the dictionary.

        Args:
            data_dict (dict): See `validate_datadict` to see the format of this
                                dictionary
            sensor_unit (str): If None, the data dict is validated and the
                                units are extracted.
        """"""
        if sensor_unit is None:
            sensor_unit = self.validate_datadict(data_dict)

        temperature_values = data_dict[self.temperature_key]
        sensor_values = data_dict[sensor_unit]

        for value_index, (temperature_value, sensor_value) in enumerate(
            zip(temperature_values, sensor_values)
        ):

            cmd_str = (
                f""CRVPT {self._index}, {value_index + 1}, ""
                f""{sensor_value:3.3f}, {temperature_value:3.3f}""
            )

            self.write(cmd_str)


class LakeshoreModel325Sensor(InstrumentChannel):
    """"""
    InstrumentChannel for a single sensor of a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        inp (str): Either ""A"" or ""B""
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, inp: str) -> None:

        if inp not in [""A"", ""B""]:
            raise ValueError(""Please either specify input 'A' or 'B'"")

        super().__init__(parent, name)
        self._input = inp

        self.add_parameter(
            ""temperature"",
            get_cmd=f""KRDG? {self._input}"",
            get_parser=float,
            label=""Temperature"",
            unit=""K"",
        )

        self.add_parameter(
            ""status"",
            get_cmd=f""RDGST? {self._input}"",
            get_parser=lambda status: self.decode_sensor_status(int(status)),
            label=""Sensor_Status"",
        )

        self.add_parameter(
            ""type"",
            val_mapping={
                ""Silicon diode"": 0,
                ""GaAlAs diode"": 1,
                ""100 Ohm platinum/250"": 2,
                ""100 Ohm platinum/500"": 3,
                ""1000 Ohm platinum"": 4,
                ""NTC RTD"": 5,
                ""Thermocouple 25mV"": 6,
                ""Thermocouple 50 mV"": 7,
                ""2.5 V, 1 mA"": 8,
                ""7.5 V, 1 mA"": 9,
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""compensation"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        Group(
            [self.type, self.compensation],
            set_cmd=f""INTYPE {self._input}, {{type}}, {{compensation}}"",
            get_cmd=f""INTYPE? {self._input}"",
        )

        self.add_parameter(
            ""curve_index"",
            set_cmd=f""INCRV {self._input}, {{}}"",
            get_cmd=f""INCRV? {self._input}"",
            get_parser=int,
            vals=Numbers(min_value=1, max_value=35),
        )

    @staticmethod
    def decode_sensor_status(sum_of_codes: int) -> str:
        total_status = LakeshoreModel325Status(sum_of_codes)
        if sum_of_codes == 0:
            return ""OK""
        status_messages = [
            st.name.replace(""_"", "" "")
            for st in LakeshoreModel325Status
            if st in total_status and st.name is not None
        ]
        return "", "".join(status_messages)

    @property
    def curve(self) -> LakeshoreModel325Curve:
        parent = cast(LakeshoreModel325, self.parent)
        return LakeshoreModel325Curve(parent, self.curve_index())


class LakeshoreModel325Heater(InstrumentChannel):
    """"""
    InstrumentChannel for heater control on a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        loop (int): Either 1 or 2
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, loop: int) -> None:

        if loop not in [1, 2]:
            raise ValueError(""Please either specify loop 1 or 2"")

        super().__init__(parent, name)
        self._loop = loop

        self.add_parameter(
            ""control_mode"",
            get_cmd=f""CMODE? {self._loop}"",
            set_cmd=f""CMODE {self._loop},{{}}"",
            val_mapping={
                ""Manual PID"": ""1"",
                ""Zone"": ""2"",
                ""Open Loop"": ""3"",
                ""AutoTune PID"": ""4"",
                ""AutoTune PI"": ""5"",
                ""AutoTune P"": ""6"",
            },
        )

        self.add_parameter(
            ""input_channel"", vals=Enum(""A"", ""B""), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""unit"",
            val_mapping={""Kelvin"": ""1"", ""Celsius"": ""2"", ""Sensor Units"": ""3""},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""powerup_enable"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""output_metric"",
            val_mapping={
                ""current"": ""1"",
                ""power"": ""2"",
            },
            parameter_class=GroupParameter,
        )

        Group(
            [self.input_channel, self.unit, self.powerup_enable, self.output_metric],
            set_cmd=f""CSET {self._loop}, {{input_channel}}, {{unit}}, ""
            f""{{powerup_enable}}, {{output_metric}}"",
            get_cmd=f""CSET? {self._loop}"",
        )

        self.add_parameter(
            ""P"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""I"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""D"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        Group(
            [self.P, self.I, self.D],
            set_cmd=f""PID {self._loop}, {{P}}, {{I}}, {{D}}"",
            get_cmd=f""PID? {self._loop}"",
        )

        if self._loop == 1:
            valid_output_ranges = Enum(0, 1, 2)
        else:
            valid_output_ranges = Enum(0, 1)

        self.add_parameter(
            ""output_range"",
            vals=valid_output_ranges,
            set_cmd=f""RANGE {self._loop}, {{}}"",
            get_cmd=f""RANGE? {self._loop}"",
            val_mapping={""Off"": ""0"", ""Low (2.5W)"": ""1"", ""High (25W)"": ""2""},
        )

        self.add_parameter(
            ""setpoint"",
            vals=Numbers(0, 400),
            get_parser=float,
            set_cmd=f""SETP {self._loop}, {{}}"",
            get_cmd=f""SETP? {self._loop}"",
        )

        self.add_parameter(
            ""ramp_state"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""ramp_rate"",
            vals=Numbers(0, 100 / 60 * 1e3),
            unit=""mK/s"",
            parameter_class=GroupParameter,
            get_parser=lambda v: float(v) / 60 * 1e3,  # We get values in K/min,
            set_parser=lambda v: v * 60 * 1e-3,  # Convert to K/min
        )

        Group(
            [self.ramp_state, self.ramp_rate],
            set_cmd=f""RAMP {self._loop}, {{ramp_state}}, {{ramp_rate}}"",
            get_cmd=f""RAMP? {self._loop}"",
        )

        self.add_parameter(""is_ramping"", get_cmd=f""RAMPST? {self._loop}"")

        self.add_parameter(
            ""resistance"",
            get_cmd=f""HTRRES? {self._loop}"",
            set_cmd=f""HTRRES {self._loop}, {{}}"",
            val_mapping={
                25: 1,
                50: 2,
            },
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""heater_output"",
            get_cmd=f""HTR? {self._loop}"",
            get_parser=float,
            label=""Heater Output"",
            unit=""%"",
        )


class LakeshoreModel325(VisaInstrument):
    """"""
    QCoDeS driver for Lakeshore Model 325 Temperature Controller.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\r\n"", **kwargs)

        sensors = ChannelList(
            self, ""sensor"", LakeshoreModel325Sensor, snapshotable=False
        )

        for inp in [""A"", ""B""]:
            sensor = LakeshoreModel325Sensor(self, f""sensor_{inp}"", inp)
            sensors.append(sensor)
            self.add_submodule(f""sensor_{inp}"", sensor)

        self.add_submodule(""sensor"", sensors.to_channel_tuple())

        heaters = ChannelList(
            self, ""heater"", LakeshoreModel325Heater, snapshotable=False
        )

        for loop in [1, 2]:
            heater = LakeshoreModel325Heater(self, f""heater_{loop}"", loop)
            heaters.append(heater)
            self.add_submodule(f""heater_{loop}"", heater)

        self.add_submodule(""heater"", heaters.to_channel_tuple())

        curves = ChannelList(self, ""curve"", LakeshoreModel325Curve, snapshotable=False)

        for curve_index in range(1, 35):
            curve = LakeshoreModel325Curve(self, curve_index)
            curves.append(curve)

        self.add_submodule(""curve"", curves)

        self.connect_message()

    def upload_curve(
        self, index: int, name: str, serial_number: str, data_dict: dict[Any, Any]
    ) -> None:
        """"""
        Upload a curve to the given index

        Args:
             index: The index to upload the curve to. We can only use
                            indices reserved for user defined curves, 21-35
             name
             serial_number
             data_dict: A dictionary containing the curve data
        """"""
        if index not in range(21, 36):
            raise ValueError(""index value should be between 21 and 35"")

        sensor_unit = LakeshoreModel325Curve.validate_datadict(data_dict)

        curve = self.curve[index - 1]
        curve.curve_name(name)
        curve.serial_number(serial_number)
        curve.format(f""{sensor_unit}/K"")
        curve.set_data(data_dict, sensor_unit=sensor_unit)

    def upload_curve_from_file(self, index: int, file_path: str) -> None:
        """"""
        Upload a curve from a curve file. Note that we only support
        curve files with extension .330
        """"""
        if not file_path.endswith("".330""):
            raise ValueError(""Only curve files with extension .330 are supported"")

        with open(file_path) as curve_file:
            file_data = _read_curve_file(curve_file)

        data_dict = _get_sanitize_data(file_data)
        name = file_data[""metadata""][""Sensor Model""]
        serial_number = file_data[""metadata""][""Serial Number""]

        self.upload_curve(index, name, serial_number, data_dict)
"
312,38.0,Switzerland,"The Zurich Instruments SHFSG Signal Generator produces qubit control signals in the frequency range from DC to 8.5 GHz with a spurious-free modulation bandwidth of 1 GHz. The SHFSG uses a double superheterodyne technique for frequency up-conversion, which eliminates the need for mixer calibration and saves time on system tune-up. Each SHFSG comes with 4 or 8 analog output channels with 14-bit vertical resolution. Controlled by LabOne, its APIs or the LabOne Q Software, the SHFSG supports quantum computing projects with sizes ranging from a few to several hundred qubits.",Shfsg,643.0,"Zurich Instruments Ltd. is a privately owned company developing and selling advanced test and measurement instruments equipped with software for dynamic signal analysis. 
",Qcodes,Zurich Instruments,"[OrderedDict([('id', 'attFUxuoeXBIspDuo'), ('width', 204), ('height', 228), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-aJZerh44NENOuc71uHbVA/mykVIYXi0ZNzJ6Ax23WvcMKdKEBIuq50kx6OYCOXv74UoACIkPS0rPAjd06U-37Ra1sC_1NpDuZUdNfddQyp3kywG2LzHS6Py3DtF0B6a3j7MaDLwtAUqILQ1FA4jN_V/a5DaVbBTWufeEgt6gkn-N7hGLk7kQFTztq5f8OUn8r4'), ('filename', 'Zurich_Instruments(logo).png'), ('size', 3655), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tTH3_exZDRca7ndOG1GTkg/M3jvNvXPxKcHtyOk_L9xyIbunn0LpzohY1wWW8mraDCCOZEksE_A1dDjUqq0mTBTXcU0B3ICcyESSIesw318BA/qEXexaHoGoZKSK3_R-6efbwMUT3t_p5xYx2GPiGuI4o'), ('width', 32), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9Eonia4x7RaM-shc9mMbfQ/ZaqlbP76_rirAnk1bNGXXDXGc6_-gQNEzHyuqg9Mmhf-bbJGdm_BQlXdvot6wtF9q4W3UTRun_mOyQCS8csXbA/nzrc_d9PEvSIejxBRybqARZ1iLQgxqXeUFsvBMtpIpw'), ('width', 204), ('height', 228)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-mAPS_esAWs4FWXEc9JtCw/NptxydPBHQjtgt9K4DY5XDErIfRGAM-hoZAiA76YTcWlTmv0CARtgGMCiViSdJeAEKbbeOieqV8Zu6hSRI2WSw/V7cmuByL29KqOrDTgsRiGTG7SH67rKFKdUv3TmJt0iw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en,Write a Python script that uses Qcodes to connect to a SHFSG RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",SHFSG,https://docs.zhinst.com/pdf/ziSHFSG_UserManual.pdf,"[OrderedDict([('id', 'attH2Nr7uLKfb0QK7'), ('width', 1183), ('height', 401), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZxLLg_TY_emUxoJU1pq_5w/yRZiIhSlHN9Dv41J36a45PVloXVO9YtFXtjY1dpVw7l7_4AQ4FWPUsODxM4BDAtmeIpCoKFC_GUVB-w0gLJCVeOn4RF4TLMyi58WYkD8UC2_Urpm1KQryaa9xRoiuuYp/4MGmBXWQAVnzy-cl0VdeOsxYF2O8Xvbkjh5tKWoL_h8'), ('filename', 'SHFSG_8_schraeg_cropped_website.jpg.webp'), ('size', 37700), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YpjdGd-TxHiI_NtULRyr6g/HmTcJb6dm2U7njAXp3tAUgIsRXi5JXb4922_bozAUvGpeea3jyxXn-JSoBDQGW9SnF4OoeqTUreUz8J0zReyeLioORMV2N95c5I50i7FgBc/Jw6DonVBxNKJgLrqKd8vNG9v7lbBaAuRq5J6AneHD-M'), ('width', 106), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OXVOKSk2GjXsihL5EPWEoQ/pYk4lLhF5S9hL-DMkCA7RmcigSLoLl9AKiLVJ1WYVO8RfbbiscNaD4XFMVPoz6Tsnmob-iSb0fMll0whj5gbeaywtJDuj76iEJroOc4z_xE/p_T6DrikEUmwvkK4xDKf7UBmxqBNIbE_vIuLeyR_vfA'), ('width', 1183), ('height', 401)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/m3mA-JQYwD8ey15BXyGksQ/Vc0Giwapfb3mRIodJWPFbf_ZdhuANxKZcUhO__g9C-Arf9oZByrQ7cP3YJ1gx22Z-mUIzXXopWtdAp_xqcZ_vIjmFPL6EKzLMCmbCYJA0po/o_73lMDn7P8tT2uQU5pynfO3lr1PilAnyhOuRJ-ApKc'), ('width', 3000), ('height', 3000)]))]))])]",https://www.zhinst.com/americas/en/products/shfsg-signal-generator,https://github.com/zhinst/zhinst-qcodes/blob/main/src/zhinst/qcodes/driver/devices/shfsg.py,https://docs.zhinst.com/zhinst-qcodes/en/latest/_autosummary/zhinst.qcodes.driver.devices.shfsg.html,,,,,"""""""Autogenerated module for the SHFSG QCoDeS driver.""""""
from typing import Any, Dict, List, Tuple, Union
from zhinst.toolkit import CommandTable, Waveforms, Sequence
from zhinst.qcodes.driver.devices.base import ZIBaseInstrument
from zhinst.qcodes.qcodes_adaptions import ZINode, ZIChannelList


class CommandTableNode(ZINode):
    """"""CommandTable node.

    This class implements the basic functionality of the command table allowing
    the user to load and upload their own command table.

    A dedicated class called ``CommandTable`` exists that is the preferred way
    to create a valid command table. For more information about the
    ``CommandTable`` refer to the corresponding example or the documentation
    of that class directly.

    Args:
        root: Node used for the upload of the command table
        tree: Tree (node path as tuple) of the current node
        device_type: Device type.
    """"""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""commandtable"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object

    def check_status(self) -> bool:
        """"""Check status of the command table.

        Returns:
            Flag if a valid command table is loaded into the device.

        Raises:
            RuntimeError: If the command table upload into the device failed.
        """"""
        return self._tk_object.check_status()

    def load_validation_schema(self) -> Dict[str, Any]:
        """"""Load device command table validation schema.

        Returns:
            JSON validation schema for the device command tables.
        """"""
        return self._tk_object.load_validation_schema()

    def upload_to_device(
        self,
        ct: Union[CommandTable, str, dict],
        *,
        validate: bool = False,
        check_upload: bool = True,
    ) -> None:
        """"""Upload command table into the device.

        The command table can either be specified through the dedicated
        ``CommandTable`` class or in a raw format, meaning a json string or json
        dict. In the case of a json string or dict the command table is
        validated by default against the schema provided by the device.

        Args:
            ct: Command table.
            validate: Flag if the command table should be validated. (Only
                applies if the command table is passed as a raw json string or
                json dict)
            check_upload: Flag if the upload should be validated by calling
                `check_status`. This is not mandatory bat strongly recommended
                since the device does not raise an error when it rejects the
                command table. This Flag is ignored when called from within a
                transaction.

        Raises:
            RuntimeError: If the command table upload into the device failed.
            zhinst.toolkit.exceptions.ValidationError: Incorrect schema.

        .. versionchanged:: 0.4.2

            New Flag `check_upload` that makes the upload check optional.
            `check_status` is only called when not in a ongoing transaction.
        """"""
        return self._tk_object.upload_to_device(
            ct=ct, validate=validate, check_upload=check_upload
        )

    def load_from_device(self) -> CommandTable:
        """"""Load command table from the device.

        Returns:
            command table.
        """"""
        return self._tk_object.load_from_device()


class AWGCore(ZINode):
    """"""AWG Core Node.""""""

    def __init__(self, parent, tk_object, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self, parent, ""awg"", snapshot_cache=snapshot_cache, zi_node=zi_node
        )
        self._tk_object = tk_object
        if self._tk_object.commandtable:

            self.add_submodule(
                ""commandtable"",
                CommandTableNode(
                    self,
                    self._tk_object.commandtable,
                    zi_node=self._tk_object.commandtable.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def enable_sequencer(self, *, single: bool) -> None:
        """"""Starts the sequencer of a specific channel.

        Warning:
            This function is synchronous and blocks until the sequencer is enabled.
            When working with multiple instruments this function is the wrong
            approach and the sequencer should be enabled asynchronously.
            (For more information please take a look at the awg example in the
            toolkit documentation.)

        Args:
            single: Flag if the sequencer should be disabled after finishing
            execution.

        Raises:
            RuntimeError: If the sequencer could not be enabled.

        .. versionchanged:: 0.5.0

            Check the acknowledged value instead of using `wait_for_state_change`.
        """"""
        return self._tk_object.enable_sequencer(single=single)

    def wait_done(self, *, timeout: float = 10, sleep_time: float = 0.005) -> None:
        """"""Wait until the AWG is finished.

        Args:
            timeout: The maximum waiting time in seconds for the generator
                (default: 10).
            sleep_time: Time in seconds to wait between requesting generator
                state

        Raises:
            RuntimeError: If continuous mode is enabled
            TimeoutError: If the sequencer program did not finish within
                the specified timeout time
        """"""
        return self._tk_object.wait_done(timeout=timeout, sleep_time=sleep_time)

    def compile_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Tuple[bytes, Dict[str, Any]]:
        """"""Compiles a sequencer program for the specific device.

        Args:
            sequencer_program: The sequencer program to compile.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Returns:
            elf: Binary ELF data for sequencer.
            extra: Extra dictionary with compiler output.

        Examples:
            >>> elf, compile_info = device.awgs[0].compile_sequencer_program(seqc)
            >>> device.awgs[0].elf.data(elf)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the compilation failed.

        .. versionadded:: 0.4.0
        """"""
        return self._tk_object.compile_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def load_sequencer_program(
        self, sequencer_program: Union[str, Sequence], **kwargs: Union[str, int]
    ) -> Dict[str, Any]:
        """"""Compiles the given sequencer program on the AWG Core.

        Warning:
            After uploading the sequencer program one needs to wait before for
            the awg core to become ready before it can be enabled.
            The awg core indicates the ready state through its `ready` node.
            (device.awgs[0].ready() == True)

        Args:
            sequencer_program: Sequencer program to be uploaded.

        Keyword Args:
            samplerate: Target sample rate of the sequencer. Only allowed/
                necessary for HDAWG devices. Must correspond to the samplerate
                used by the device (device.system.clocks.sampleclock.freq()).
                If not specified the function will get the value itself from
                the device. It is recommended passing the samplerate if more
                than one sequencer code is uploaded in a row to speed up the
                execution time.
            wavepath: path to directory with waveforms. Defaults to path used
                by LabOne UI or AWG Module.
            waveforms: waveform CSV files separated by ';'
            output: name of embedded ELF filename.

        Examples:
            >>> compile_info = device.awgs[0].load_sequencer_program(seqc)
            >>> device.awgs[0].ready.wait_for_state_change(1)
            >>> device.awgs[0].enable(True)

        Raises:
            RuntimeError: `sequencer_program` is empty.
            RuntimeError: If the upload or compilation failed.

        .. versionadded:: 0.3.4

            `sequencer_program` does not accept empty strings

        .. versionadded:: 0.4.0

            Use offline compiler instead of AWG module to compile the sequencer
            program. This speeds of the compilation and also enables parallel
            compilation/upload.
        """"""
        return self._tk_object.load_sequencer_program(
            sequencer_program=sequencer_program, **kwargs
        )

    def write_to_waveform_memory(
        self, waveforms: Waveforms, indexes: list = None
    ) -> None:
        """"""Writes waveforms to the waveform memory.

        The waveforms must already be assigned in the sequencer program.

        Args:
            waveforms: Waveforms that should be uploaded.
            indexes: Specify a list of indexes that should be uploaded. If
                nothing is specified all available indexes in waveforms will
                be uploaded. (default = None)

        .. versionchanged:: 0.4.2

            Removed `validate` flag and functionality. The validation check is
            now done in the `Waveforms.validate` function.
        """"""
        return self._tk_object.write_to_waveform_memory(
            waveforms=waveforms, indexes=indexes
        )

    def read_from_waveform_memory(self, indexes: List[int] = None) -> Waveforms:
        """"""Read waveforms from the waveform memory.

        Args:
            indexes: List of waveform indexes to read from the device. If not
                specified all assigned waveforms will be downloaded.

        Returns:
            Waveform object with the downloaded waveforms.
        """"""
        return self._tk_object.read_from_waveform_memory(indexes=indexes)

    def configure_marker_and_trigger(
        self, *, trigger_in_source: str, trigger_in_slope: str, marker_out_source: str
    ) -> None:
        """"""Configures the trigger inputs and marker outputs of the AWG.

        Args:
            trigger_in_source: Alias for the trigger input used by the
                sequencer. For a list of available values use:
                `available_trigger_inputs`
            trigger_in_slope: Alias for the slope of the input trigger
                used by sequencer. For a list of available values use
                `available_trigger_inputs`
            marker_out_source: Alias for the marker output source used by
                the sequencer. For a list of available values use
                `available_trigger_slopes`
        """"""
        return self._tk_object.configure_marker_and_trigger(
            trigger_in_source=trigger_in_source,
            trigger_in_slope=trigger_in_slope,
            marker_out_source=marker_out_source,
        )

    @property
    def available_trigger_inputs(self) -> List:
        """"""List the available trigger sources for the sequencer.""""""
        return self._tk_object.available_trigger_inputs

    @property
    def available_trigger_slopes(self) -> List:
        """"""List the available trigger slopes for the sequencer.""""""
        return self._tk_object.available_trigger_slopes

    @property
    def available_marker_outputs(self) -> List:
        """"""List the available trigger marker outputs for the sequencer.""""""
        return self._tk_object.available_marker_outputs


class SGChannel(ZINode):
    """"""Signal Generator Channel for the SHFSG.

    :class:`SGChannel` implements basic functionality to configure SGChannel
    settings of the :class:`SHFSG` instrument.

    Args:
        device: SHFQA device object.
        session: Underlying session.
        tree: Node tree (node path as tuple) of the corresponding node.
    """"""

    def __init__(self, parent, tk_object, index, snapshot_cache=None, zi_node=None):
        ZINode.__init__(
            self,
            parent,
            f""sgchannel_{index}"",
            snapshot_cache=snapshot_cache,
            zi_node=zi_node,
        )
        self._tk_object = tk_object
        if self._tk_object.awg:

            self.add_submodule(
                ""awg"",
                AWGCore(
                    self,
                    self._tk_object.awg,
                    zi_node=self._tk_object.awg.node_info.path,
                    snapshot_cache=self._snapshot_cache,
                ),
            )

    def configure_channel(
        self, *, enable: bool, output_range: int, center_frequency: float, rf_path: bool
    ) -> None:
        """"""Configures the RF input and output.

        Args:
            enable: Flag if the signal output should be enabled.
            output_range: Maximal range of the signal output power in dBm
            center_frequency: Center frequency before modulation
            rf_path: Flag if the RF(True) or LF(False) path should be
                configured.
        """"""
        return self._tk_object.configure_channel(
            enable=enable,
            output_range=output_range,
            center_frequency=center_frequency,
            rf_path=rf_path,
        )

    def configure_pulse_modulation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        global_amp: float = 0.5,
        gains: tuple = (1.0, -1.0, 1.0, 1.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configure the pulse modulation.

        Configures the sine generator to digitally modulate the AWG output, for
        generating single sideband AWG signals

        Args:
            enable: Flag if the modulation should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used to modulate the AWG
                outputs. (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            global_amp: Global scale factor for the AWG outputs. (default = 0.5)
            gains: Sets the four amplitudes used for single sideband generation.
                Default values correspond to upper sideband with a positive
                oscillator frequency. (default = (1.0, -1.0, 1.0, 1.0))
            sine_generator_index: Selects which sine generator to use on a
                given channel.
        """"""
        return self._tk_object.configure_pulse_modulation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            global_amp=global_amp,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    def configure_sine_generation(
        self,
        *,
        enable: bool,
        osc_index: int = 0,
        osc_frequency: float = 100000000.0,
        phase: float = 0.0,
        gains: tuple = (0.0, 1.0, 1.0, 0.0),
        sine_generator_index: int = 0,
    ) -> None:
        """"""Configures the sine generator output.

        Configures the sine generator output of a specified channel for generating
        continuous wave signals without the AWG.

        Args:
            enable: Flag if the sine generator output should be enabled.
            osc_index: Selects which oscillator to use
            osc_frequency: Oscillator frequency used by the sine generator
                (default = 100e6)
            phase: Sets the oscillator phase. (default = 0.0)
            gains: Sets the four amplitudes used for single sideband
                generation. Default values correspond to upper sideband with a
                positive oscillator frequency.
                Gains are set in the following order I/sin, I/cos, Q/sin, Q/cos.
                (default = (0.0, 1.0, 1.0, 0.0))
            sine_generator_index: Selects which sine generator to use on a given
                channel
        """"""
        return self._tk_object.configure_sine_generation(
            enable=enable,
            osc_index=osc_index,
            osc_frequency=osc_frequency,
            phase=phase,
            gains=gains,
            sine_generator_index=sine_generator_index,
        )

    @property
    def awg_modulation_freq(self) -> float:
        """"""Modulation frequency of the AWG.

        Depends on the selected oscillator.
        """"""
        return self._tk_object.awg_modulation_freq


class SHFSG(ZIBaseInstrument):
    """"""QCoDeS driver for the Zurich Instruments SHFSG.""""""

    def _init_additional_nodes(self):
        """"""Init class specific modules and parameters.""""""
        if self._tk_object.sgchannels:

            channel_list = ZIChannelList(
                self,
                ""sgchannels"",
                SGChannel,
                zi_node=self._tk_object.sgchannels.node_info.path,
                snapshot_cache=self._snapshot_cache,
            )
            for i, x in enumerate(self._tk_object.sgchannels):
                channel_list.append(
                    SGChannel(
                        self,
                        x,
                        i,
                        zi_node=self._tk_object.sgchannels[i].node_info.path,
                        snapshot_cache=self._snapshot_cache,
                    )
                )
            # channel_list.lock()
            self.add_submodule(""sgchannels"", channel_list)

    def factory_reset(self, *, deep: bool = True) -> None:
        """"""Load the factory default settings.

        Args:
            deep: A flag that specifies if a synchronization
                should be performed between the device and the data
                server after loading the factory preset (default: True).
        """"""
        return self._tk_object.factory_reset(deep=deep)
"
313,6.6,USA,"Spectrum Control's Weinschel brand Model 8320 Series Multi-channel Programmable Attenuator systems allow for multiple attenuator channels to be controlled across a variety of interfaces, or via a front panel.",Weinschel 8320,630.0,"Weinschel Associates designs and manufactures high-quality Broadband RF and Microwave products for commercial and military markets domestically and internationally. Core technologies originated by founder Bruno Weinschel are leveraged using modern design, production, delivery, and service techniques to provide the best product at the best price to our customers.
",Qcodes,Weinschel,"[OrderedDict([('id', 'atts7Cn0Ro6caXagZ'), ('width', 375), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_y-5TImlqQuTpSY-HLfBwg/rD1BMOr4weeFAB0hFEB80Ybft0Z3P7eTZXlrzzQWknvWk7lqpsSvbtuHRQnPY4npObpZXPcnwBK4yjEHBRTw1z6vtZVl0ZKO1_CgH5z5o5w/zC-7f8NvyFBlrETzKV5zx4c_bYm1WIJ6vH3_XAgAO8Q'), ('filename', 'weinschel.png'), ('size', 27908), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q-skplZOFlHpP7OBvdwhvw/2PhQxiZEgekR0IlZdqixiuHaP0PmjzNhf7Jh8U_i9dW6hBxgeeFA3nzNR9UrHdWtTUNd4n_gDG83oG1AhQ1GtQ/H4rmSNMvS7Xwm8sZHRlplObsSYVDIVjRo20lB_GvwNs'), ('width', 113), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Aej34g-BprDRXO4POVscUA/Ag32yJYq1wWkkuCxBP8iIrDI6DJoa4UiWN0Znrh5yDCJWZfS6FESjtv7sCDRfAGwesNA9VP7i-xAIadOWi_wHA/IdUAXTs5kfS1Xd_s4E2mvM75LOCFy-ESjpnlB9sRvaE'), ('width', 375), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JD8pFYm_Y7ys3sgZr7sijA/tayxNZlSEiUmITj2PIEvxkN4LH02owPfIbMGTtV_5yklmlp1Pugk-9FF2u38cWlr_5-o0qPCNZ6DPkj6fnx3hQ/3KInOZt7zBKEq-EZr6C94ScAfv07iPSk_H4N8xSJ01o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.weinschelassociates.com/,Write a Python script that uses Qcodes to connect to a {Device name} ,https://en.wikipedia.org/wiki/Attenuator_(electronics),,"An attenuator is an electronic device that reduces the power of a signal without appreciably distorting its waveform.

An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.",,https://www.spectrumcontrol.com/globalassets/documents/i--w/wmod8320_8321_8331.pdf,"[OrderedDict([('id', 'attCDvCoMwd5HRGlw'), ('width', 503), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wXm72x3EDX2KtUvVP8tvfw/q474yr0CvcSAnn2kKsrnXR4OlCDL7ue67Flt8KFOIpNEyz9vuWKD7tsvGJN8zxm_GY0xl_3GYVjeaWrD64oR9qQ9LnuGSrb0mfFc0R6bbeg/97LYflwsM2sMr1cN0VfX_FqhnVsa2lDhdts_nGnryk0'), ('filename', 'aw-8320-w-software.webp'), ('size', 6318), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/z2YlccdFmbA6QOvTxUYbUg/EQgyG4aBQTy8D7yIsljreSYvHzmGdDnoOQ1t6IJqR8MHEBA7ynQggvn7FI88zFwDWh8t5WoNt-nHw0AhLxWSsaQJvvbQkWCVVhGtqr8T4zY/WCDeelsDqVM-HJMx8IM4XUiRcszHixB9WUgY7dbdyb4'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QAXKDJL4WkT9vEGwOTuIoA/_nX5YDAfs4raPcAtQ_b9vWAueA8TD49x2fzUORWOVytF_TkdONRuCz4ZDqF6oB8nzH9VW-QH4hqYqzsIxiREAjJuFun2xOmOyqKDDjBR2dM/Oeje-_GC1kAd2lQdsB_AfvIdot-Rcm4TFRRkqFrzifY'), ('width', 503), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Qs7XvNe9_4wPog-yBkG3Yg/qorz5RIY_R_kGdofM0GNmKyQ1rmV4JwocT1CCvDv3wVdQydLkeMZ-sCxkMBnbqlqoiuuojzNUb-YIXlk0hlDGGDDWNCf2tflqvz0o32HUkg/tiI4nfbyFNIFUENu7fEuzPfQPAoGQ7QT4zrvLfwIvvk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.spectrumcontrol.com/products/subsystems/rf-distribution/programmable-switches--attenuators/attenuator-subsystems/8320-multi-atten-system/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/weinschel/Weinschel_8320.py,https://qcodes.github.io/Qcodes/drivers_api/Weinschel.html,809.99,,,,"from typing import Any

import numpy as np

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import Parameter


class Weinschel8320(VisaInstrument):
    """"""
    QCodes driver for the Weinschel 8320 stepped attenuator.

    Weinschel is formerly known as Aeroflex/Weinschel
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator='\r', **kwargs)
        self.attenuation = Parameter(
            ""attenuation"",
            unit=""dB"",
            set_cmd=""ATTN ALL {0:0=2d}"",
            get_cmd=""ATTN? 1"",
            vals=vals.Enum(*np.arange(0, 60.1, 2).tolist()),
            instrument=self,
            get_parser=float,
        )
        """"""Control the attenuation""""""

        self.connect_message()


class Weinschel_8320(Weinschel8320):
    """"""
    Alias for Weinschel8320 will eventually be deprecated and removed.
    """"""
"
317,5420.0,USA,"The Keysight N5245A Network Analyzer provides a wide range of measurement applications for amplifiers, converters, antennas, or mixers with a single connection.",Keysight n 5245 a,280.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attr6ueXCjaoUkuEr'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sz6IF0J1YWrvesiyGaDnxQ/1htno4lLFnhOD3MBQqZeSqZ8Je41v8CCzswkpQWH_yGn74P9glmYKhn_QjOrnPBc8PxUn_1rk2fIUnKakaw8NlPpEF9FTKjRaFVj4T6L_B0/vIRAhvmmRJvTCoz81DxwEn_UcmE35-bejLCT_uvbnx0'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1ykYQNB7HL9xdLiSxjRoYA/Am-7kcuGMU8G5qCLN7OEbR8zBzaUjvC282JhGCUmZBwqsVPlRHhYwadzxo-ydPzWJBPjjqEQe-OAWrjC8d4AWR5xqvtgNmoGlrz3EHDpaUM/u6SQr6VeUMFcoffe7q6x8KBnVOdUR3H49Fmrv2Mlk0o'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JpRvr4WBkEJw2FyXKvKdHg/MOVbJRUPlvor9GiV31tpOe539tfTVmn-r_NlClTz-e7_HzH50Zjt4A_2n5XEO8si_eM9W4jEDQdoMPar0rSezOZyTWNalcWhCC9TN_j3lk4/Q61y9tLTn79-nQzZxJ30-mZfGTz9uyt38CfKqg1REfc'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ltnqle9czLNvNuljefaBFA/HTdZ-rwH5DuRL3iWAcNIfA7J5kmFFZcHiHSp3ntXw4-ea-y-ny2QgiSvZnonWld2cShDR7AcA0xcmR9zPTlPIUnk-zTzQC5YnFUmMr1V8Wk/AEQrcMxbO4FZq2GKJ7BfUBO-pyoezq8Jfs26I7jxVSg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5245A Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT N5245A,https://xdevs.com/doc/HP_Agilent_Keysight/N5245-90001%20Service%20Guide%2C%20N5244A%20and%20N5245A%202-Port%20and%204-Port%20PNA-X%20Microwave%20Network%20Analyzers%20%5B456%5D.pdf,"[OrderedDict([('id', 'attStMPoe9umMRnBo'), ('width', 539), ('height', 340), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Hi_SMPnvUxFnGZaWqYKEHA/nP1K7TXZ6soSGMv8GMgjStzMs93AGUg1TNnDCAoWGFtHFdgcOpEcmbqs6qP-xbsECVcsyTxk-dDnDMg1ruxu8X55A_jWe-p7qcZLGXd-dbY/w5CnfvT_OJqKdNMq8l0WcYDKPeYfnVysv8fdu1AxAHg'), ('filename', 'N5245A.webp'), ('size', 160074), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/pi44CsXSPZ9UcAJawH6pGw/43lb1rRPo-0jNPJ2ApQFbfce68Lj6t48uvBAp1db4JYMWYi7PI3UjMFKVShmTQj6xejCFbDe4TPDKd0oyrbi5H8lW6Xcnaw696Q278J7rS4/7rrKw2tdsSctQKGkRaIEy-rT_SXzHIJM16MvPRo1ydg'), ('width', 57), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HO2uyPGeN9BXQJnB6nOjbQ/XGNYUfU13LxvH8gTLMHoXdNl1Pt99HDZ9tpQjnktB856UIYLKC1BZrzPvdekqeJUd6QzHoC2ub0Efc6RM1ba_0BmB1fIdLdbtfqBAe-6NTQ/thjP476V__VZ9bIfUM52uk_IG9VRJ4hcTfgwSodMhzs'), ('width', 539), ('height', 340)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0rjZ5YoBKLvUsKTr7x31_Q/tgc35L5hJMWDvsVh1plnmiPGPHFamfisFtUKPP1Pz1_wmZWwkEnHz1oAJVJtg_BwoPTjK4OxfSUCAVCzWWw0zuVeoLqbC5_XC5P8gF18XHs/Q8iDifBlPo2D7GnSwdT3VjTjaNG5XB7078irXzwDwGQ'), ('width', 3000), ('height', 3000)]))]))])]","https://www.axiomtest.com/Network-Analyzers/More-than-40-GHz/Keysight-..-Agilent/N5245A/PNA_X-Network-Analyzer,-10-MHz-to-50-GHz/#:~:text=The%20Keysight%20N5245A%20Network%20Analyzer,mixers%20with%20a%20single%20connection.",https://github.com/qcodes/qcodes/blob/master/docs/examples/driver_examples/Qcodes%20example%20with%20Keysight%20Network%20Analyzer.ipynb,https://qcodes.github.io/Qcodes/examples/driver_examples/Qcodes%20example%20with%20Keysight%20Network%20Analyzer.html,,,,,"{
 ""cells"": [
  {
   ""cell_type"": ""markdown"",
   ""metadata"": {},
   ""source"": [
    ""# QCoDeS Example with Keysight Network Analyzers\n"",
    ""\n"",
    ""This notebook is indendet to give an overview over the functions implemented in the QCoDeS driver for the Keysight network analyzers. The driver is implemented to be generic as possible, with individual instrument drivers filling in only the hardware limits of the instrument, so although this example uses the N5245A, the concepts and code should work for any keysight network analyzer.""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 1,
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""%matplotlib inline""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 2,
   ""metadata"": {},
   ""outputs"": [
    {
     ""name"": ""stdout"",
     ""output_type"": ""stream"",
     ""text"": [
      ""Experiment loaded. Last ID no: 16\n""
     ]
    }
   ],
   ""source"": [
    ""# Import Dependencies\n"",
    ""\n"",
    ""import logging\n"",
    ""\n"",
    ""import matplotlib.pyplot as plt\n"",
    ""\n"",
    ""# qcodes imports\n"",
    ""import qcodes as qc\n"",
    ""from qcodes.dataset import (\n"",
    ""    Measurement,\n"",
    ""    load_experiment_by_name,\n"",
    ""    new_experiment,\n"",
    ""    plot_by_id,\n"",
    "")\n"",
    ""from qcodes.instrument_drivers.Keysight import KeysightN5245A\n"",
    ""\n"",
    ""#setup\n"",
    ""logger = logging.getLogger()\n"",
    ""logger.setLevel(logging.DEBUG)\n"",
    ""\n"",
    ""# Start experiment\n"",
    ""exp_name = 'PNA_Example'\n"",
    ""sample_name = 'Thru_Coax'\n"",
    ""try:\n"",
    ""    exp = load_experiment_by_name(exp_name, sample=sample_name)\n"",
    ""    print('Experiment loaded. Last ID no:', exp.last_counter)\n"",
    ""except ValueError:\n"",
    ""    exp = new_experiment(exp_name, sample_name)\n"",
    ""    print('Starting new experiment.')""
   ]
  },
  {
   ""cell_type"": ""markdown"",
   ""metadata"": {},
   ""source"": [
    ""## Connect to the instrument\n"",
    ""\n"",
    ""You will have to insert the correct VISA address for your PNA below. On my PC, the PNA has IP address `192.168.0.10`. You can generally use NI MAX or Agilent IO Toolkit to figure out what the VISA address of your instrument is, particularly for USB or GPIB connections.""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 3,
   ""metadata"": {},
   ""outputs"": [
    {
     ""name"": ""stdout"",
     ""output_type"": ""stream"",
     ""text"": [
      ""Connected to: Agilent Technologies N5245A (serial:MY52451750, firmware:A.10.49.08) in 0.21s\n""
     ]
    }
   ],
   ""source"": [
    ""pna = KeysightN5245A('pna', 'TCPIP::192.168.0.10::inst0::INSTR')""
   ]
  },
  {
   ""cell_type"": ""markdown"",
   ""metadata"": {},
   ""source"": [
    ""## Simple Measurements\n"",
    ""\n"",
    ""We can very easily set up measurements and pull, for example, magnitude data off the PNA.""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 4,
   ""metadata"": {},
   ""outputs"": [
    {
     ""name"": ""stdout"",
     ""output_type"": ""stream"",
     ""text"": [
      ""Starting experimental run with id: 17\n""
     ]
    },
    {
     ""data"": {
      ""text/plain"": [
       ""([<matplotlib.axes._subplots.AxesSubplot at 0x1ba0bf174a8>], [None])""
      ]
     },
     ""execution_count"": 4,
     ""metadata"": {},
     ""output_type"": ""execute_result""
    },
    {
     ""data"": {
      ""image/png"": ""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"",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    }
   ],
   ""source"": [
    ""# Set up a frequency sweep from 100 MHz to 1 GHz, with 1001 points, at a power of -40dBm\n"",
    ""pna.power(-40)\n"",
    ""pna.start(100e6)\n"",
    ""pna.stop(1e9)\n"",
    ""pna.points(1001)\n"",
    ""pna.trace(\""S21\"")\n"",
    ""\n"",
    ""# Enable 2 averages, and set IF BW to 1kHz\n"",
    ""pna.if_bandwidth(1e3)\n"",
    ""pna.averages_enabled(True)\n"",
    ""pna.averages(2)\n"",
    ""\n"",
    ""# Run a measurement\n"",
    ""meas = Measurement()\n"",
    ""meas.register_parameter(pna.magnitude)\n"",
    ""\n"",
    ""with meas.run() as datasaver:\n"",
    ""    mag = pna.magnitude()\n"",
    ""    datasaver.add_result((pna.magnitude, mag))\n"",
    ""    dataid = datasaver.run_id\n"",
    ""plot_by_id(dataid)\n"",
    ""\n"",
    ""# Other valid parameter types are:\n"",
    ""# pna.linear_magnitude()\n"",
    ""# pna.phase()\n"",
    ""# pna.unwrapped_phase()\n"",
    ""# pna.group_delay()\n"",
    ""# pna.real()\n"",
    ""# pna.imaginary()""
   ]
  },
  {
   ""cell_type"": ""markdown"",
   ""metadata"": {},
   ""source"": [
    ""## Reading multiple parameters in one measurement\n"",
    ""\n"",
    ""If we want to read out multiple parameters in a single loop, we can disable auto-sweep and manually tell the PNA to take new data for each setpoint. Otherwise, each time we get a measured parameter of the PNA (e.g. magnitude and phase) a new trace will be taken.""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 5,
   ""metadata"": {},
   ""outputs"": [
    {
     ""name"": ""stdout"",
     ""output_type"": ""stream"",
     ""text"": [
      ""Starting experimental run with id: 18\n""
     ]
    },
    {
     ""data"": {
      ""text/plain"": [
       ""([<matplotlib.axes._subplots.AxesSubplot at 0x1ba0d6cab00>,\n"",
       ""  <matplotlib.axes._subplots.AxesSubplot at 0x1ba0e6fe668>],\n"",
       "" [None, None])""
      ]
     },
     ""execution_count"": 5,
     ""metadata"": {},
     ""output_type"": ""execute_result""
    },
    {
     ""data"": {
      ""image/png"": ""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"",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    },
    {
     ""data"": {
      ""image/png"": ""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"",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    }
   ],
   ""source"": [
    ""# Disable automatic sweeping\n"",
    ""pna.auto_sweep(False)\n"",
    ""\n"",
    ""# Run a measurement\n"",
    ""meas = Measurement()\n"",
    ""meas.register_parameter(pna.magnitude)\n"",
    ""meas.register_parameter(pna.phase)\n"",
    ""\n"",
    ""with meas.run() as datasaver:\n"",
    ""    pna.traces.tr1.run_sweep() # Ask the PNA to take a measurement\n"",
    ""    mag = pna.magnitude()\n"",
    ""    phase = pna.unwrapped_phase()\n"",
    ""    datasaver.add_result((pna.magnitude, mag),\n"",
    ""                         (pna.phase, phase))\n"",
    ""    dataid = datasaver.run_id\n"",
    ""plot_by_id(dataid)""
   ]
  },
  {
   ""cell_type"": ""markdown"",
   ""metadata"": {},
   ""source"": [
    ""## Multiple Traces\n"",
    ""\n"",
    ""We can also read multiple traces off the PNA at once. For example if the PNA is set up such that:\n"",
    "" - Trace 1 is S11\n"",
    "" - Trace 2 is S12\n"",
    "" - Trace 3 is S21\n"",
    "" - Trace 4 is S22\n"",
    "" \n"",
    ""we can read these off simultaneously as follows:""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 7,
   ""metadata"": {},
   ""outputs"": [
    {
     ""name"": ""stdout"",
     ""output_type"": ""stream"",
     ""text"": [
      ""Starting experimental run with id: 20\n""
     ]
    },
    {
     ""data"": {
      ""text/plain"": [
       ""([<matplotlib.axes._subplots.AxesSubplot at 0x1ba0d6aca58>,\n"",
       ""  <matplotlib.axes._subplots.AxesSubplot at 0x1ba0e9b90f0>,\n"",
       ""  <matplotlib.axes._subplots.AxesSubplot at 0x1ba0e976a90>,\n"",
       ""  <matplotlib.axes._subplots.AxesSubplot at 0x1ba0e8b3470>],\n"",
       "" [None, None, None, None])""
      ]
     },
     ""execution_count"": 7,
     ""metadata"": {},
     ""output_type"": ""execute_result""
    },
    {
     ""data"": {
      ""image/png"": ""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"",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    },
    {
     ""data"": {
      ""image/png"": ""iVBORw0KGgoAAAANSUhEUgAAAZQAAAEKCAYAAAA1qaOTAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMi4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvhp/UCwAAIABJREFUeJzt3XeYVOX1wPHv2b6UpZelF1FEpMiiYIkoYOwl9lgwsURN0/w0YktiEiO2GDWJihrFJBqNGjWxICIoioggqIggvfe6sGw/vz/und27s1N36u6ez/PMs3dumfsy7M6Zt51XVBVjjDEmVhmpLoAxxpimwQKKMcaYuLCAYowxJi4soBhjjIkLCyjGGGPiwgKKMcaYuLCAYowxJi4soBhjjIkLCyjGGGPiIivVBUimjh07ap8+fVJdDGOMaVTmz5+/XVU7hTuvWQWUPn36MG/evFQXwxhjGhURWRPJeSlp8hKR9iIyTUSWuT/bBTint4jMF5GFIvK1iFzrOTZTRJa6xxaKSOfk/guMMcb4S1UfykRguqoOAKa7z/1tAo5W1WHAUcBEEenmOX6Jqg5zH1sTX2RjjDGhpCqgnAVMcbenAGf7n6Cq5apa5j7NxQYQGGNMWkvVh3QXVd0E4P4M2GQlIj1F5EtgHXCvqm70HH7Gbe66U0Qk8UU2xhgTSsI65UXkPaBrgEO3R/oaqroOGOI2db0mIi+r6hac5q4NItIaeAW4DHguSDmuAa4B6NWrV5T/CmOMMZFKWEBR1XHBjonIFhEpVNVNIlIIhOwDUdWNIvI1cBzwsqpucPcXi8jzwJEECSiqOhmYDFBUVGSriRljTIKkqsnrDWCCuz0BeN3/BBHpISL57nY74BhgqYhkiUhHd382cDqwKCmlNsYYE1SqAsokYLyILAPGu88RkSIReco951DgUxH5AvgAeEBVv8LpoJ/q9q0sBDYATyaysHsOVPD6wg2JvIUxxjR6KZnYqKo7gLEB9s8DrnK3pwFDApyzHxiR6DJ6/fLlL5j69RYGFRYwoEvrZN7aGGMaDRuKG4HNe53Ry8VllSkuiTHGpC8LKBHIznBGJVdVW5++McYEYwElApluQKmoqk5xSYwxJn1ZQIlAdqbzNlVUWQ3FGGOCsYASgaxMp4ZSaTUUY4wJygJKBLIynLepvLKaeat3sn1fWZgrjDGm+bGAEoFst4ZyoKKK8x7/hHMfm53iEhljTPqxgBKBnCznbVq9fT8Aa3aUpLI4xhiTliygRKBNfjYAj7y/vGbfN5v2pqo4xhiTliygREADDO465eFZyS+IMcakMQsoEaisDjy6q8/EN7ntP19RWVXNrv3lSS6VMcakl5Tk8mpsKkPMP3n+07WUV1bz8vz1rPjDqTWTII0xprmxGkoEwqVcefXz9YDNpDfGNG8WUCJQUa20a5Ed9Lgv3lRari9jTDNmASUCVdXVdGyVy0mDuoQ8r6LSaijGmObLAkoEKqqUzAwhNzsz5HlTv96cpBIZY0z6sYASgapqJTszg7ys0G/XxFe/SlKJjDEm/dgorwicfFhX9pdXsmLbvoiv2VdWSW5WRk2mYmOMaepS9mknIu1FZJqILHN/tgtxboGIbBCRP3v2jRCRr0RkuYg8IiIJG697wcie/OCYvgzu1qZm34jeQYsLwOBfT+Xq5+bV2Xfynz7kVJsQaYxpolL59XkiMF1VBwDT3efB/A74wG/fY8A1wAD3cXIiCul14cieNds5IWoe1e5or5lLt9XZv2RzMYs37eWdRZts9UdjTJOTyoByFjDF3Z4CnB3oJBEZAXQB3vXsKwQKVPUTVVXguWDXx5OIcESvtgBkhHjnwq09f+0/Pue5T1YD8K+5azn/8dmUVlTFqZTGGJMaqQwoXVR1E4D7s7P/CSKSATwI3Ox3qDuw3vN8vbsv4XxrowTJxgLA3gMVtdulFcxfs4tvtxTXOWfL3jJUlYmvfsVnq3fx4mfrElJeY4xJloR2yovIe0DXAIduj/AlrgfeUtV1fl0kgfpLArYhicg1OE1j9OrVK8LbBuermVQHyhjp2l1SG1DOePQj1uwo4fDubeqck5UhbPMs1JW4HiBjjEmOhAYUVR0X7JiIbBGRQlXd5DZhbQ1w2mjgOBG5HmgF5IjIPuBhoIfnvB7AxiBlmAxMBigqKoq54yIvzFwUgD2eGopv7ZQ1O/bXOefPM5bz1qJNNc9D9ckYY0xjkMpPsTeACe72BOB1/xNU9RJV7aWqfYCbgOdUdaLbRFYsIqPc0V2XB7o+Ee49dwhXHN2Ho/t3DHh82uItXPr0p/X27y2t36+yclttkMkJM8fFGGPSXSo/xSYB40VkGTDefY6IFInIUxFcfx3wFLAcWAG8naiCenUpyOM3Zx5GdlbgNir/ocKRsjxgxpjGLmUTG1V1BzA2wP55wFUB9j8LPOt33uDElTC0ljnxfevKbJSXMaaRs5nyDXTxkb3YVVLOtcf3p7yqmjcWbuSO1xaFvObIPu2Zu3pnwGP3vrOUy0b3SUBJjTEmOazhvoFysjK4YdzB5GVnUpCXHXLUl0/ngtygx/aVVXL3m4vZvKc0nsU0xpiksYASJ965J8F0ah08oAA8OWsVJzwwkwffXRqvYhljTNJYQImTdi1zAHjg/KFBz+nXsWXA/YO7F9RsH6io4tH3l8e3cK7lW/fRZ+KbzFgSaIS2McbExgJKnFw0sheTLxvBuUcEn7B/2pBuXHVsX449qO6Q41evO6beuX+ZsZxvNu2NaxnnrnL6b2zdFmNMIlhAiZPMDOGkw7oiIjx+6RG8fO3oeue0ys3ijtMH8cjFw/nhMX1r9udkZdQLMvdPXcopccxMXFxawWsLNwCRTc40xphoWUBJgJMHF1LUpz1//v5wJn3v8Jr92ZnO3JX2LXP41RmDACjIcwba/eOqo7jrzMPqvdarn6+vt68hbnnly5oaSm62/bcbY+LPhg0n0OlDugG1Kzn6L9ny1W9OIjOjdl+LnPo1h1+89AXfO6JHvf3R8qWAAcjLshqKMSb+7KtqErTJzw64v3VeNi08EySzMhOXIdIby6yGYoxJBPtkSYJ3b/wO/7n+6LDn7StL3Gx58SRoDlVDmb9mFyPvfo89JeGHQRtjjJcFlCToUpDH8F6hlwyG2mHF9503hMI2eXEtg7eGkh2iJvTw9GVsKy7j83W74np/Y0zTZwEljRxzUEdm3DSGC4p6cnCX1jX7d+0vj+t9qqqVeat38lmANDDqzvi35VmMMdGygJJm+rq1lAPltc1fP31hQcyv613DvkrhvMc/4fzHP6l3ni+DjP8AAmOMCccCSpraWlyb0+uj5dujunb+mp30mfgmizfWToz0BqiqUOsXuyycGGOiZQElTf3xwmEcN6B2smNxaeSd5O8scmbCz1q2rWZfx1a1ecSqQsQTdVdSrowg6BhjjJcFlDR1RK92POjJC+adR9IQIjC8V1sgeA1l9fb9fLx8BwClFRZQjDHRsYCSxlrk1s5RWe23Jn0k7nl7CQCfrd7Jp6t20tadD+OtocxYupWpX29m1fb9fO+x2TX7yyptwS9jTHRspnwaa+HJubV+14EGv46v8711nhNQvMHiB898FvCaMquhGGOilJIaioi0F5FpIrLM/Rl0koaIFIjIBhH5s2ffTBFZKiIL3Ufn5JQ8uTIyhKP6tgdgTwTrrYTT0q3x/HXmirDnllUmL6DMXLqVq5+bx844D482xiRXqpq8JgLTVXUAMN19HszvgA8C7L9EVYe5jya7wMeLPxpNh5Y5DQ4oT3wQPngE8us3vqYiVO99nBwor+KKZz5j2uItTJm9OuH3M8YkTqoCylnAFHd7CnB2oJNEZATQBXg3SeVKS23ysyMOKBVV1Tw5a1XNc18/CkBOBLnCvLPodyc4/cpnq3fWGb32+AcrrO/GmEYsVQGli6puAnB/1muyEpEM4EHg5iCv8Yzb3HWnhJiFJyLXiMg8EZm3bdu2YKeltTYtsiOeLf/WV5uCHrv4qF4B9596eNea7XGHdqnZTmQN5dOVOzj/8U946L1lNfvKKqt54dO1CbunMSaxEhZQROQ9EVkU4HFWhC9xPfCWqq4LcOwSVT0cOM59XBbsRVR1sqoWqWpRp06dov+HpIHB3drw+dpdlIfp11BVJnlqJF7d2uQxsGtBwGPe/RmedPpHT3qfdTtL2LSn4QMCgtm2rwyAuat21NmfmZnBo9OXsXlPaaDLjDFpLGEBRVXHqergAI/XgS0iUgjg/gzUBzIa+ImIrAYeAC4XkUnua29wfxYDzwNHJurfkQ76d2pJaUU1u0tC11K+2VTMpiAfxKUhgpE3LUumCJd4ajLH3TeD0fe8z76ySjbsjl9gWbfTeS1fU9733Xt+s2kvD077lp/FId2MMSa5UtXk9QYwwd2eALzuf4KqXqKqvVS1D3AT8JyqThSRLBHpCCAi2cDpwKLkFDs1ct3hw0f+YTqzA6RheemzdcxYupVq1XrHfMoqgvdNeK8b3b8DYw+tP2juvMdmc8yk96Mpdkj3vuPUpLbvc4LkmIOd2qOvaW9/eWXc7mWMSY5UzUOZBLwkIlcCa4HzAUSkCLhWVa8KcW0uMNUNJpnAe8CTCS5vSuVm1cb9OSt3cLTf+vO/fOVLwFlaOJhwNZSFvxrPpj2lDOzamk9W7Kh3zpLNxdEWO6gZS+pXSNvkZ5OTmcHbbtoYy01pwOnH276vjOzMDDq2yqWkvLLOonQmvaTkf0ZVdwBjA+yfB9QLJqr6LPCsu70fGJHYEqaXHE9Ayff7Y7r27/NrtkPN4/A2a9U7pkrbFjm0beEEpESv6Pin6U5HfG5WRs18l7zsTMo9gwAkBekpd+wro1VeFrm2RHLauOzpT5mz0llmYUDnVizbuo+XfjSaI935WSa9WOqVRsD7AZfv92H/ztebg153boRr0Y8d2KXO81AfqNUhAlOkfCOTB3UroF0LZ/a+//LHqaihjPj9e3UCtEk9XzABWLZ1HwAXPPEJ+8usSTQdWUBpBLxNXlmZtdurtwfP79W/U0sevGBovf1nDu1Ws33dmP5MvmxEvW972ZnBfy0q4pCFuKLKCUpZGcJvzjwMgK4FdVeoTPZ6LL5AOWNp4xxa3hRVhhi2ftivp4Yd9WiSzxojGwFvQPH9Ef3vy4385PngI6He/NlxAfc/fNEwHr5oGNUKmRmBP7R7d2jBiQM7c8lRvbhyyrw6x8orq2NuEureNp+vNuzhgfOH0rtDS84c2q1eAEl2BSWZqWZMaKUVVQy8852w563dWcJBnVsloUQmUlZDaQS8fSil7kzyL9fvCXlNnjsybOIpAwHo0S4fcL75i0jQYOK79m9XjGRE7/op1uLxrXDbvjJG9WtP7w4ta8rkz/tvToZvt8Rv0IGJTaDM2heN7MnArq3r7NtnzV5px2oojUClp9+irKKab7cUM/nDlRFde+3x/TnhkM50ap0b/mQ/edn1ayK+5qqGqKyq5rlP1vDtlmJOHVxY7/igwgIWb9rLNd/px1OzVlJeWZ2UwPLy/PXc9O8vEn4fE97W4lJeW7Cx5vn5I3rwy5MH0r5lDpkZQp+Jb9aeu9cmv6Ybq6E0At4+jTkrd3DSQx/WO+f2Uw8Nev0hXVuHHFIcTG5WRr1vhbsPlFPSwDki732zld/+bzHFpZUUts2rd/yV647m8zvHU9gmj2qFR6YvC/Aq8ffpyrrDpB+dviwugw9M9M589GMe9yQ0/cmJB9GpdW7AGvV732xJZtFMBCygNALDerbl0YuHA/Dpqp0Bz/nBMX341zWjePNnxzL3tnojshtERHj753X7Yk7+0ywuf3pug16vZa53tFr92k9+TibtW+bQyk2z/+cZy9mT4ASVvvt6PTjtW6Yv2craHSUs21LMzv3lXPeP+UkpS3O32a/W4V+zvuO02i9OvmwLJn2EbfJy1xo5BugGHMCZlT5PVa0XM4nOGNqNVz9fH3AU0tMTisjKzGBUvw5xv6+I0DInk/3ltTPt563Z1aDX8jbd5YZoyvItBAYwd/VOxg/qEvTcRLn6udrBCNeN6c/bizZzWLcCfnLigKSXpTnzn8R4wcie/P7NbwDYFSYVkUm+oH/VInKCiEwF3gROAQqBQcAdwFcicpeIBM42aBLiqQkjA+7v3aFFQu+bEachvN4O/ZwQI8Va59V+iFz93LyEzTn4ZtNeduwrC7s6pS+Nf3kM/UdNxYHyqogzX0dru5swFGBUv/bMuGlMvXMK8rLp4/6+L9lczA+fDbziqEmNUE1epwJXq+pIVb1GVe9Q1ZtU9UxgKLAAGJ+UUhrAGebrnUfi07djYodOnh7gng3hTYcfqobia/LySVRb+SkPz+Lkh2fVjJwLxlfuZCw4lu7O+evHDP/dtIS8dtHv36vZHtqzLX07tgx43vv/N4Ybxx3sbAdI42NSJ+hftarerKoBF6dQ1UpVfU1VX0lc0Uwg/jPKIfh8knj57VmH1dunIRJRBqKq/P2TNTXPQ43eOqRray4s6lnz3JdAMhG2FZdRWlHFIV1a11kLxss3wa6iGc5V2b6vjC/W7eadRZsY8pupcc3pFspFIwOv3QPOEgtXf6cvpx3ujBS0QJ8+QnbKi8jxIjLE3b5ARP4sIjeKSPRjUE1cHCiv+216ZoBmgXjLzszgs9vH1S1HiOzFgXy7ZV+dAQWhaih52Znce94QBriT1krKKlHVuI68evqj2lUtS8qryMvOqEkD4++1hc4w1ub4wTXy7vc46y8fc8/bS9hbWtv0uGBtw/rRgnlvcW0t9HtHdA9aO/FpkZPFUf2cDA8NXR7bxF+oPpS/AL8HnhKRfwDfx+mQHw78LTnFM/58H+QnDerC8rtPoU+YP7x48f+wLQ3T7+Cv1C8ABapp+fvvT48FnFFXF02eQ7/b3orqnqH87n+La7ZnLduOAneeMYhfnzEo6DWLN+2N2/0jtaekIqV5q3wV0TU7Surs/95js+N6n0ffrx0i3qt9ZH2CvmSmW2w+StoIVUM5QVWPA76D0yl/rqo+jrN+yZBkFM7U58safNqQwjp5vRLN/17Rrv3uP6u5vDJ8bcM7sTLYcOl4+XL9HgrysvnBMX2DnrNiW/DcaYmwYO0uhv72XQ779VQG3P5WQlbObKgoWzzD8lY++3eKrE9weM+2tMjJ5GcvLKj3hcWkRqhPpFIAVS0F1qhqlftcAatjpojvDzlUk1EyhBsZ5e+leXVXco42IPn8e16gFaFjd+WxtYHk39eODnjOzv3lIRMWxts5f62tBVRUaco7oLMS2FfnnSzra8oKp2f7Flw/pj8rtu1n7c6S8BeYhAv1qdRZRH4hIv/n2fY9b5yLszcBvhpKqtfsGPPAzIiDws795by+cGOdff7ZhSN188tf1rnvaws28NGy+qtYhhKoL2a0Zw7PyD7tOXtY4JFtP3l+QdQDEhrCm2LEJ9ogHiv/96mX3/D0F+aupbSiir2lsX2/rK7WmtpfblYGnVtH/rsxorcTfLYXl4U50yRDqIDyJNAaaOXZ9j1/KvFFM4H4lutNdvJEqB8EHp8ZWT6xzX7r3L/+42M4KoZJmEs21Y40uuHFhVz69KdRXR9omHBLv6HKf7poOJ/fWX9U/Dtfb+Yfc9bU2x9PwQYfJDMjclW11ht44d8ceOurXzHwzncY8pt3G3yfHfvKKPZ09g/oEt0Q+E6tnX6UbfssoKSDoDPlVfWuZBbERMYXUEKtWZIor15/ND9+/nMWrN0NwLZ9kXWGbimuPe+c4d0Z2rNtTOWoDlBDOFBexbw1OzluQPjK84Zd9fsi8gKsUtk2P/Cor4+Wb+ey0X3CF7SB9gfJldbQZsJoqSr9b3urXnqcnu3yufjIXrwwt/5sAlWNeg2bdTtLOO6+GXUyIUS73E5hm3wyM4SlSRrObEILGlBE5JFQF6rqzxp6UxFpD7wI9AFWAxeoar1xiCJSBXzlPl3rTqpERPoC/wLaA58Dl6lqs8jD4GvySkE8oVvbfG45eSAXTZ4DRN4Es9OdRzLjpjFhh4NGItByxr/939e8MHcdZw3rxu/PHlwnfYu/N77YWG9foA/DDE+fwdLfn8whdzhrdCRyXgzUHcBw26kD+cNbS4D4LB0QCV9NyFdDue3UgVRUKd8Z0Im3vwq8QuieAxU1o64itWG3E9ineYYMB/qyEErL3CwO796m5kuOSa1QH0vz3UcecASwzH0MA2L9qjQRmK6qA4Dp7vNADqjqMPdxpmf/vcBD7vW7gCtjLE+j4cv+kewVDX28kygXrIvsj9j3ARUoIWQ4HQJkSS4pr//rt2Kr0wb/+sKN3PfO0pCvmZVR+2t//Zj+QO16McF4+6zmr9nFim37Qp7fUOt2ltSZV3HCIZ1rtpPV5OU/YqpLQR4/PuEgMjKEG8YPYNyhnenWpm7z55a9ZRwor4p5rs4FngmtkerWNo+txTZ0OB2Emik/RVWnAANwhhA/qqqPAmNxgkoszgKmuNtTgLMjvVCcT9ITgZcbcn1j5+sQzkxRQKn05LNavjWyD9U/vfct0LB+nzm3jWVojzZ19gVKn5/nyRgcKOB4eftQbhx/MMvuPoWOrQLP1Z31yxOYc6uTvfnecw+vSec/9sEPIvsHRGHr3lKOu28Gd/xnEQAtczLrdFAnq8nLf45Rgae2V9gmn6cmjOSJy4rqnPP1xj0c+qt36q3wGcq+0rr/j3NvG8sPjukTdXk7tcplW3FZ0t4fE1wkf+HdcDrjfVq5+2LRRVU3Abg/Owc5L09E5onIHBHxBY0OwG5V9f02rge6B7uRiFzjvsa8bdsa/3rhvhaBeCVsjFalXyP3+0tC59l6dPoytrojcBoy1Dk7M4NnfnBknX3X/uNzHpr2LQ++W1sT8U7+828O3Lj7AKu3OzWYNTv289hMZ72NRy4eTnZmRsj+qJ7tW9DV/TZ+4chePOuWpXvb0DWahtjt1kx82Zxfuf5oCvJrW6XDBcp48a+hBKq9dS6oG4B/8ZKzQNmH30b+N+Zt2nvh6lF0LshrUM27c0Eee0srOeSOd5jfwEzYJj4iWbFxErBARGa4z48HfhPuIhF5D+ga4NDtEZcOeqnqRhHpB7wvIl8BgaYrB214VdXJwGSAoqKiRp8u9uGLhvHkrFUM6paaRM8j+9SdI/DDZ+exetJp9c6rqlY27y3lwWnf1uxr6NyZQE1lD/stvrXDM8rHF2y/2bSXUx6eVbN/9aTTeHJW7ci0QIk2w+naJo+TBnVh0YY9cV9R0ts3dOxBHRnYte7/cXFp4mfMqypj/1i39tU9QEAJVqOLRrE73Hju7WOjGirsr5OnLHNX7Qy4dLVJjrABRVWfEZG3gaPcXRNVNXDPXN3rxgU7JiJbRKRQVTeJSCEQcMaWqm50f64UkZk4aV9eAdqKSJZbS+kB1O9lbaL6dWrFPd87PGX3D7QscCAPvLu0pibg09CZ/ZEEIu/CTC/PX8+Vx/atNz9lzsodcanZHXdwJ95dvIW/fbyKa4/vH/Pr+XhrIIf7NfNB7QdwIq3Ytq8msD14/lAO79Gm3pokEHtCUlXlqw17AGibH/1qol7eRbgSOfnShBcql1cf37aqblbV193HZve4iEiPBt73DZwULrg/Xw9w/3a+JJQi0hFnka/F7kz9GcB5oa43ifPSj0aH/Rb47tdhv3NELCOCDwlvu39ltXLaox/Vu+6iyXPqJCFsqMtG9SY7U9i0O76pULyJPwPNRZmzcifLtyZ2eOzWvbU1vcI2eRzcpXXQcw+LoZb8zMereWneeiD2OVVdPQMEUtQSbFyh/ifvF5FXRORyETlMRDqLSC8ROVFEfgd8DARfyDy0ScB4EVmGs6bKJAARKRIR36TJQ4F5IvIFTgCZpKq+jH63AL8QkeU4fSpPN7AcpgGO7NueB88fWvM80MzxaJNHRuKIXm0jXr2xvLK6Th+Lz8Y98RkN1KNdC3aWVMRlZJOPd7CBd/b5784eXLN944tfxOVewXhX5gw3A/6V645u8H1+60nOGauBXVvT3h0NmKx+JhNYqImN54vIIOAS4Ic4KzaWAN8AbwF3u3m+oqaqO3BGi/nvnwdc5W7PBgK27ajqSuDIQMdMcnibGfre+hbL7j6F7MwM/vvFRl6aty7uyfrm3zGOlrlZ5GRmRJx1ONSHy2OXHBFTeXKznH/rf7/YSFHvdrwcw4erj3dm+imDC2u2LxvVm3/OWcOSzcURZWmOhTeoHdk3dDaDSJs//cV7xUcRYe5tYzno9rfZa6nsUypkH4pbI4imE900E/6pSs57/BNuGDuAn76wAIAWOfHNNdYhDp3AXqccXhj+pBDae+bHzIvTyCLfqKdPbxtLF780N75+pAVrd1NaUdXgD/Nw9pc5QW3OrWPr/BuDue+8IUz/ZgtTv65tSrzrv19zx2mDgvazrN5Rm7X5kBBNatHIysyga0FezHnFTGxSm7LWNGr/vOqomu0v1u3mB571vb21g17tWzQ4GWQ0nrq8iP8bf3DC7wMw+fKi8CdFadGGPWRmSNgRVDOXJi7rsK+G0iI3soB1QVFP/nrJCBbcOZ6j+jojAJ/5eDXPfbI66DU7PTWUv18Zv4aGNvnZLFi7O+H9TCY4CyimwYr61O2YDzSrHeC5Hx7JnNvqtXDGrLcn+21+diaDu7fh+hMOCnjuRSN7csvJA4H6i4U1RKvcrID5vxpqX1klL8xdR1W1Bvxm7x31de0/Pmd3SWLSv/hqSS2iqAFlZgjtWubUSex4138X85cZy+udu3H3AVa5c4LeueE4Osfxi8bSLcUs27qPcX/8MG6vaaITyTwUYwLK8RsGvCNI23i8m798/nXNKEbf8z6PXjyc04cU1kyK69Ayp15Z7j7ncDIzhL4dW8Y0OsnLSeESnw75z1Y7C4hdGCT1yJ2nD+Ifc2qTMj4/dy3XjwkcPBuqpLySF+aupU+HFg0a4u0/NuP+qUv5sV+AP3rS+zXbbYIk3zSNV9jfGnd48KUi8iv3eS8RsQ5xE/Gs5vw4B5SnJxRx1bF9KWyTz+pJp3HG0G51yvLQhbWZgXy1CN+3/pMHd6VnhEvMhnP8IbWZjWNdI2WbO1z3p2MDBwn/9W9mLol/1oeV2/azZW8Z/3e/spDeAAAgAElEQVTSIQ26PlDW/VDvi38/XKyO9Ey6DbYEgEmsSL6G/BUYDVzsPi8G/pKwEpkmJ9DEuFiMPbQLd5wefO33bm1rm1Fm3DSG//7k2Lje3+fuswdzdH9nJNSuktg6g301qg4tIxt8MHd1fJdEnr9mF3//xFnnJdDM+EgECh4Vntxv326p27fRMs6/F784qbb/LFht2SRWJAHlKFX9MbVLAu8CYpvaapqcQYV1m5Ha5Gez4g+n8vVd3415VnW02rlp1Pt1bElhm/yAs87joW2LHC4b1Rsg5vXed5WUk5edEbI25wteiXDuY7N50V1euVMDR9T54skdpx3KBUXOnGdvIs6b/113Dk28fy+8KXq27LXsw6kQSUCpEJFM3HxZItKJeDUcmybjqQl1Rz3lZGWQmSFxb9aIRIdWufzhnMN5/upRCb9XoZskctPu2D7AdpeUh01B8vzVo+jfqXY9mUDrwsSDd45RNNRNqdcyN4vDeziLqM1duZOxD87knre+oSrBSyd7g7EFlNSIJKA8AvwHZ135u4GPgD8ktFSm0Slsk8cN4wbUPI9H8sBYfP+oXnVSciSKb12QTTF+gJVWVEfU1/Taj4+p2U5Ubq+GznG56aRDOH1IIWcO7VZTW7jquXms2LafJz5cyaINtXldZ940Jh5FrcNbQ/li/Z64v74JL2xAUdV/Ar8E7gE2AWer6r8TXTDTuIgIN4yrbcP+6YnxHYGUrjq0yiUrI/a8XmWVVRElwWydl12T9mbe6vhMqJy7Kj79MZ0L8vjz94+gZZgh1U9eXkSfOKzc6c/7/n1uaexTItQSwN485VuBF7zHVDW+vYKmSfjOwZ0YVFjAqTHORG8sMjOEti1yYu6UL6usjji9/yi3L+Wq5+Yx745xMdcGL3jik5rtkX3ik/o92AJwsyeeSLcErCUDkOupoazbVZKQe5jQQjVwz8fpNxGgF85SuwK0BdYCfRNeOpP2LizqSduWtfMJnvth8xtR3iY/K6YcUqUVVcxcuq3ewIZgvIt7rdi6L27Ni5eO6sXvzhoc/sQI+C/A5ZOoYALOQJAXrh7F/7508smpasqWym6uQi0B3FdV+wFTgTNUtaOqdgBOB15NVgFNerv3vCHcekpDk043DW1b5LD7QMOHqf5jjjNcd/GmQGvHhbZmZ/y+iWdnZsTtA3hE7/bMvX0sfdxsBvnZmXUGFCTK6P4d6NuxJRVVyt4kLEhm6oqkjj1SVWvSu6rq2zirNhpjcL4Z74mhhtKQEUk/PMZpIIg1u653pFg8V58E6Nw6jycvL+IHx/Rh/p3jePfG5Hxs+JJa7rS5KEkXyW/QdhG5Q0T6iEhvEbkd2JHoghnTWLTNz2Z3DH0oDVna9/bTnFrhtn1lMeX18qar90+lEw8DurTm12ccRoucrKTNR6oNKGVhzjTxFslv0MVAJ5yhw68BnamdNW9Ms1cQYw2lugHzMzIzhFa5WTzxwUqG/XZag+/9yPRlNdvxzmiQKr6JrbEEedMwkawpvxP4eRLKYkyj1LZFNsWllWzdW9qg7LkNXWWwIC+rJjtwQz05a1XN9oSje8f0WunCl4zUVm9MvkiSQ84Qkff9H7HcVETai8g0EVnm/gw4VlFEqkRkoft4w7P/WRFZ5Tk2LND1xiSDL2vukX+YHvW1O/eX878vNwHw8EXR/Rq3bVE7s768smHJK44b0BGAJy4b0WRqKC3c7AwvfrYu5qSdJjqRNHndBNzsPu4EFgLzYrzvRGC6qg4AprvPAzmgqsPcx5l+x272HFsYY3mMabBIVjYMZsnm2pFdZw3rHtW1Pzq+X812Q5rcdu0vZ+6qnWRlCN89rGvU16cr31ouHy3fzrTFW8KcbeIpkiav+X67PhaRD2K871nAGHd7CjATuCXG1zQmJQZ3b3jyyV37nUDQkLkkYw/tQtsWzoCAPQfKo87B9as3vqasgTWbdOZNYRNL35aJXiRNXu09j44i8l0g1q8zXVR1E4D7s3OQ8/JEZJ6IzBGRs/2O3S0iX4rIQyKS2sRRplnr56YRadWARJi+IcNTbzgu6mtb5Wbx0AVOM1lDRoolKhdYqnkzDmRl2sTGZIrkL8A7Y74SWAVcGe4iEXmPwIHn9ijK10tVN4pIP+B9EflKVVcAtwKbcdLoT8ap3fw2SDmuAa4B6NWrVxS3NiYyIsI5w7vXrLoYjf1up3pBA1cv9H0bP1ARfQd0QV7TXDHROznzQHnTq4Gls0gCyqGqWmfmVSQ1AlUdF+yYiGwRkUJV3SQihTi5wgK9xkb350oRmQkMB1b4ajdAmYg8g9PPE6wck3GCDkVFRdZDZxIiJzOD9bsOMH/NTkb0bh/+AmD2iu08OO1bwJml3hC+EU0HohjRVFlVjYjEfSJjOvneEd159fMNNhclySL5jZodYN8nAfZF4w1ggrs9AXjd/wQRaecLXCLSETgGWOw+L3R/CnA2sCjG8hgTE9+H87mPRf6nMfnDlTHf15eyPZohsgfd/jaj75nOy/PXx3z/dPXg+UPp1iaPGUvjv1SyCS5UtuGuQHcgX0SG4zR5ARQAsS7KPQl4SUSuxEk0eb57zyLgWlW9CjgUeEJEqnEC3yRVXexe/093oS/BGXV2bYzlMSYmpQ1ocooHX5PX3ij7Q7YWN+1v7iLCqP4d+HSlJUVPplBNXt8FrgB6AH/07C8Gbovlpqq6AxgbYP884Cp3ezZweJDrT4zl/sbE2/Z9qfmA9s0duf0/izhvRA9ysxq2OFZT1K5FTkxpaUz0QmUbnqKqJwBXqOoJnseZqmrZho3x8I6ySuZkuhaeIbJ/fPfbBr3GjZ6F0ZqSNvnZ7C+vYlsTr42lk6ABRUQudTf7iMgv/B9JKp8xjYI3oCRzbod3iOwTH66ksiq6e/ft2JKfe5Zubop+9sKCVBeh2QjVKe9bvKAV0DrAwxjjOqpf7ciu/RHm14rH0rsiwrK7T6l5/v0nP43q+heuHhVzGdLVpaOc3GRllZbTK1mC9qGo6hPuz7uSVxxjGqc7ThtEuxY5PDx9Gdf/83Ne/NHosNf4RmbFuqaVd8jx3NU7WbJ5LwO7Bl790VuDGd2vA13bRJ/MsrFo3zKHkwZ1Yc0OWw44WcLOQ3FHU10N9PGer6o/TFyxjGlccrIyOKSrU3H/NIKah7efJdK15CN18p9mseqeUwOuvuhrjpt4ykCuPb5/XO+bjlrnZbN6x34WbdgTU4ocE5lIfpNfB9oA7wFveh7GGA9vB3k43n6WvOz4j8xav+sAv//fYt7zS47ou29+Au6ZjgrysyirrOb0Rz9KdVGahUgCSgtVvUVVX1LVV3yPhJfMmEamZRS5vLwBxZePKxaTLxtRZ832XSXlPPXRKq56rm5i8FXb9wHxrxWlqzaelDaWyj7xIvmt+p+InJrwkhjTyLX1fHhVhBlt5eso/v3ZgzlhYLDcqJE76bCuTP+/Mfz5+8MBOPPPHwc8751FmwFndFdzcO4RPWq2y6McAWeiF0lA+TlOUDkgIntFpFhE9oa9yphmxrsuSri5D2UVzodbvGsK/Tq2Cnn8i/V7OKRLa47q1yGu901XPdu34NdnDAKgpMxGeyVa2N9mVW2tqhmqmq+qBe7zwENIjGnGvCsoXvHM3JDnfrF+NwC5ce7LaJ0XvNltf1klc1ft5MRDY68RNSYt3WwCJSlKj9OcRDLK64gAu/cAa1Q1tgWtjWlCMjNqR1V9u2VfyHN/8rwz2S6ngVmGg/EPKN6MwvvLnT/X7m3z43rPdOfLd1YS4fwg03CR/Db/FZgDPOk+5gD/Ar4VkZMSWDZjGp0zhnaL6vx4J5Vs2yKHB88fyoje7QBnrfnlW53g5mtmay4jvHx8o+8+XLY9xSVJjWmLtzDqD9Nrfg8SKZKAshoYrqojVHUEMAwnXfw44L4Els2YRufcI5x14TMzhNkrtlNVHXpkUSKSF547ogf/vOooLh/tzBQf90dnxW5fRuJEDFNOZwd1dvqVfve/xWzdWxrm7KblgalLufq5eWzeW0q7FolfUC2SgDJQVb/2PXFTyA9X1dgXczCmiRlzSGd+NnYAVdXK95/8lMc/WFHvnCWba8e0nB5ljSZSedmZHN2/Y83zOSt3cNojzlyM/JzmMWTYp3eHltzzPSdx+Za9zStR5FMf1X5MeweNJEokv1lLReQxETneffwVp7krF2iai1IbE4Mit7kJYEWAZoaT/zQLgGu+04+OrcIuftpg4w7tzODuzviZiybPqdnf3GooAL3bO0s4+fqRmos+HWqHhwfKnBBvkQSUK4DlwA3AjcBKd18FcEKiCmZMYzWwa23uVG9HfUl5JTs866a0imIiZENkZWZw4sAu9fY3tz4UqJ10OrOZreDYzh156P09TKSwv9GqegB40H34S3wvjzGNjLdpwful8Ht/nc2SzcU1zxMdUILJjyJFTFPhCyiPf7CCK4/tS6fWiasZpovlW4v5dovz+/bOz49Lyj3D1lBEZICIvCwii0Vkpe+RjMIZ0xhleYYCr95eUjMr3htMAFqFmDMSL1ce25fvDe9ee8/cLLq0broZhoNpmVsbRKNdLrmxGvfHD9mxv5xTBndlQJfkrDgSSZPXM8BjQCVOE9dzwN9juamItBeRaSKyzP3ZLsh5vUTkXRH5xg1ofdz9fUXkU/f6F0Uk8b1NxjTA3NU7uWrKvIDHCpIQUNrkZ3PjeGdFxrvPGcyCX42nXRI6Z9ONtza450DzCCg+yayNRRJQ8lV1OiCqukZVfwPEuqb7RGC6qg4AprvPA3kOuF9VDwWOBLa6++8FHnKv3wVcGWN5jEmYWUHmP/Ro1yIp9+/ZvgWL7voulxzVu87aKc1J67zaIbN7SppXQDmyb/vwJ8VJJL9dpSKSASwTkZ+IyDlArLkbzgKmuNtTgLP9TxCRQUCWqk4DUNV9qloizlCFE4GXQ11vTCp99ZuTGBcmxUmvDskJKJC6/pp0ct4IJ1Hkzv3xn/uTzo7qm7y8bZEElBuAFsDPgBHAZcCEGO/bRVU3Abg/A/3lHQzsFpFXRWSBiNwvIplAB2C3J+3LeqB7gOuNSZnWedk1I2yg/rfi68b0pyAv8RPNTK3fnz0YEWetmKbO16x33ICOSW3yimSU12fu5j7gB5G+sIi8B3QNcOj2CF8iCzgOGA6sBV7EGa78RqBihijHNcA1AL169Yrw1sbELje79vva0N++W+fYmQma0GiCy8vOpLAgjzU79qe6KAn3u/8tTsl9gwYUEQn0wV1DVc8Mc3xciNfeIiKFqrpJRAqp7RvxWg8s8M3IF5HXgFHA34C2IpLl1lJ6ABtDlGMyMBmgqKjIVtgxSZObFXx4bvd2zStBY7ro2DqXnQlId5NuDpQ7Iwsrq5L7kReqyWs0zof1LOABaueiBJuTEo03qG02m4CzzLC/z4B27pr24PSbLFZn2bUZwHlhrjcmpS4a2bPevoO7tOKdG46z5q4U2VVSzsyl2/hi3e5UFyWhBnRx8pfdf/6QpN43VEDpCtwGDAYeBsYD21X1A1X9IMb7TgLGi8gy93UnAYhIkYg8BaCqVcBNwHQR+QoQnGzHALcAvxCR5Th9Kk/HWB5j4m5Al9a8/uNjap53Lcjj6QkjGdjVlhNKlXU7nf6TybOa9lS63SUVZGVI0kYS+gRt8nI/0N8B3nHzdl0MzBSR36rqo7HcVFV3AGMD7J8HXOV5Pg2oF2LdZrAjYymDMcnQoVVtx/zsiSeSkaQUGCYwEVCFnfuabrPXngMVPDt7dUruHbJT3g0kp+EEkz7AI8CriS+WMU2DN/mjBZPUU7dLwTtgoqkZete74U9KkFCd8lNwmrveBu5S1UVJK5UxTURediZ3nzOYLAsmaaF1XhbFpZXMXLqNTXsOUNimaQ2OiPeCbdEKFaYvw5kL8nNgtojsdR/FIrI3xHXGGI9LjurNhSNtyHo6+M/1tX1ar36+IYUlSYxNe2oXEMvNSn4tLFQfStOtExpjmiXf6o1Ak1y98cXP1gFOxuuZN49J+v0taBhjmqWyyuqor9lfVkmfiW/y5pebElCi2GzcfYDHP1hBp9a5zL9jXEqGpltAMcY0S8Vl0a/eePPLXwDwx2lL412cmO120/v8+oxBSVmdMRALKMaYZinQ8szhvPXVZgCqqpU1O/azeGP6dCef+oiztHTLnNQlArWAYoxpVmbeNIYuBbks2VzM2h0lEV2zrbiMEx6YWfN89Y4Sjr9/Jqc+Moslm1MfVFRrU6zkpXCJZwsoxphmpU/Hljx1+Ugg8qar1xZsYNX2wEklN6RB9uJ9nua7Filc4tkCijGm2RnUrYCDu7TitYUbKSkP3peiqmzYfYDK6uBJFlPUXVHHZU/PrdnOt4BijDHJk5khTDi6DwB7DwQPKM98vJpjJr3PN5uCN2uVV6Y2iXllVTULPcku80JkuU40CyjGmGbJtyxwcWnwJYE/XLYNgNUh1lC5b+qS+BYsSrsP1C1/KmtMFlCMMc1SQZ4zGmpviIBS5TZ1fbl+T82+T249kUcuHk5ndyXEldtSu2DXDf9aWLM9ql97eqRwrR0LKMaYZqkg36mh7C0N3uRVrXWbs56/6igK2+Rz5tBuzLrlhJr9f5mxPDGFjMBHy7fXbP/q9MNSNgcFLKAYY5qpTm4m6Le+3MT+IJMcq/w6448+qGPNdm5WJse6z++fmrqJjsN6tgXg1MO70q9Ty5SVAyygGGOaqe5tnaahf89fz2G/nhrwHP+A4q+y2knfkp2ZmlrBog17WLhuN6ce3pW/XjIipXNQwAKKMaaZysgQDu/epub5/rLKOunfK6qq+Wz1rprnj196RL3XuPdcZ/2/VKXBv+6f8wFS2szlZQHFGNNs/d9JB9dsH/brqQy88x3KK6spraji2Y9X1xxbfvcpnDy4sN71vTu05PLRvUN27CfKc5+srlnSeFS/Dkm/fyApSfoiIu2BF3FWgVwNXKCquwKc1wt4CugJKHCqqq4WkWeB4wHf0IsrVHWh//XGGBNK7w71+xxuffUrXvl8fZ19WZnBv3t3Kchjz4EKdpeU07ZFTtDz4u1Xr39ds33pUemx3k6qaigTgemqOgCY7j4P5DngflU9FGcN+a2eYzer6jD3YcHEGBM1Xz+Kl38wCaeodztUYcHa3eFPToC87Ixm3+R1FjDF3Z4CnO1/gogMArJUdRqAqu5T1cgyuRljTARysjI4fUj9piyvv195ZMjjfTs6tZw1O/azbEtx3MoWqT4BalmpkqqA0kVVNwG4PzsHOOdgYLeIvCoiC0TkfhHxDmG4W0S+FJGHRCQ3GYU2xjQ9D5w/lEtH9aqZ6OgztIfTYX/cgE4hr+/oDj/+zX8XM/6hD1m3M/Hfe0srqmpmxE++rCjh94tUwgKKiLwnIosCPM6K8CWygOOAm4CRQD/gCvfYrcBAd3974JYQ5bhGROaJyLxt27Y19J9jjGmi8rIz+f3ZhzP71rE1+3531mG8cM0oZk88Mez1GRl1m5t8C10l0juLNqMKT11eRK8OLRJ+v0glrFNeVccFOyYiW0SkUFU3iUghdftGfNYDC1R1pXvNa8Ao4Glf7QYoE5FncIJOsHJMBiYDFBUVpTaLmzEmbbXKrf04vHRUb0SEFg1YrKq0sir8STG6950lDCos4NgBHcOfnESpavJ6A5jgbk8AXg9wzmdAOxHx1TdPBBYDuEEIcXqizgYWJbS0xphmYcoPj+SWkwdG3cn9sacm86O/z09os5eqsrW4jBMGdkr5REZ/qQook4DxIrIMGO8+R0SKROQpAFWtwql5TBeRrwABnnSv/6e77yugI/D7JJffGNMEHX9wJ64b0z/q67q3zefm7x4CwM795Rx334x4F63G2p0lVFUrbdxcZOkkJfNQVHUHMDbA/nnAVZ7n04AhAc4L37BpjDFJdOHIngnP6bW/rJLj758JQE6IuTGpkn4lMsaYRqhjq1x6tU9sB/kLc9fWbBeHyJKcKhZQjDEmTg7q3Cqhr+/NNXbZ6N4JvVdDWEAxxpg4Ka+srtl+8bO1Ic5smP3lTkCZfNmIpKZ5iZQFFGOMiZO7zjqsZvuWV76K62v3mfgmj81cQUFeFicd1jWurx0vFlCMMSZO+ndqxXF+c0NUlcv/Npdpi7c0+HWrPeuytMxNyViqiKRvyYwxphEqq6iu83x3SQUffruND791MnUsv/uUkNmLA9lfXtsBv7W4LPZCJogFFGOMiaOK6tqAMn/NLuas3FHn+N7SStq3jK7/Y59nieJwq0imkjV5GWNMHPlWcQQ497HZ9eam7DkQfa4v75r3Pz3xoIYXLsGshmKMMXF0cJfWIY83JKD45pw884ORnHBIoOTs6cFqKMYYE2et/TrOuxTUrrDRkICy1w0o/q+bbiygGGNMnL318+PqPPfOoI82oLyzaDPX/2M+QFrOPfGygGKMMXHWs30LhvZsW/N8cPc23Hee07eyeOPeqF7r2n/Mr5nQ2K5F+iWE9LKAYowxCZCb5Xy8di3I45ffHciZQ7sB8PgHK1Bt2EitdMww7GUBxRhjEiDTXVPlllMOIT8ns87aJRv3lDboNaOdv5Js6V06Y4xppFq7a9QPKmxT79iqbfsjeg3vnJNpN34nPgVLIAsoxhiTAHefczj3nTeEg7vUZiD2zSHZsDuyFR2LS2s78NtFORkyFSygGGNMAnRqncsFRT3rLCf8s7EDACdx5Odrd4V9De+IsFZpPmQYLKAYY0zSZGdmkJnhBJiLnpgT9DxfMkhfQLnjtEPTbv34QFISUESkvYhME5Fl7s92Ac45QUQWeh6lInK2e6yviHzqXv+iiKR/XdAYY4A8d/RXeVV1wOOb95TS77a3eGneupqAMqRH24DnpptU1VAmAtNVdQAw3X1eh6rOUNVhqjoMOBEoAd51D98LPORevwu4MjnFNsaY2LTKC910tWq702H/q9cX8bePVgHpP1zYJ1UB5Sxgirs9BTg7zPnnAW+raok4DZInAi9Hcb0xxqSFX4w/OORxX5NYaUU1M5Y6Ke+9qVvSWaoCShdV3QTg/gyX7ewi4AV3uwOwW1V96TfXA92DXSgi14jIPBGZt23bthiLbYwxsblwZK+aznlvFmEf//T0fzjn8LRPueKTsGEDIvIeEGidytujfJ1C4HBgqm9XgNOCTjtV1cnAZICioqL0XUjAGNNsDCp0MhJ/u6WYwd3bkO1OWPxo2Xaenb2qzrlH9Wuf9PI1VMICiqqOC3ZMRLaISKGqbnIDxtYQL3UB8B9V9Y2f2w60FZEst5bSA9gYt4IbY0yCDexaAMA5f50NwOpJpwFw2d8+xT8rS5eCvKSWLRapavJ6A5jgbk8AXg9x7sXUNnehThKcGTj9KpFcb4wxaaWwbd0goaq8+eWmesEEGsf8E59UBZRJwHgRWQaMd58jIkUi8pTvJBHpA/QEPvC7/hbgFyKyHKdP5ekklNkYY+IiNyuTfM+8kg+XbefHz3+ewhLFR0pCn6ruAMYG2D8PuMrzfDUBOtxVdSVwZAKLaIwxCXWgoqpme8Lf5gY8p0MjSLfi1XjqUsYY04y894vv0KFl4xgu7GMBxRhj0sSE0b0Z0qMtRx/UgcI2+akuTtQsoBhjTAr86Ph+PPHByprn3dvmc9dZg1NYothZckhjjEmBW085lNWTTuNnbkr7jCbwadwE/gnGGNN4De/l5MbNlEBzthsXCyjGGJNC+TnO8GGxgGKMMSYWLXOcruwmEE8soBhjTCrlZjsfw00gnlhAMcaYVHKz1dMqr3GseRKKDRs2xpgU6t+pFT8fO4Dzi3qkuigxs4BijDEpJCLcGGbRrcbCmryMMcbEhQUUY4wxcWEBxRhjTFxYQDHGGBMXFlCMMcbEhQUUY4wxcWEBxRhjTFxYQDHGGBMXoqqpLkPSiMg2YE2qyxGjjsD2VBciTdh7UZe9H3XZ+1Er1veit6p2CndSswooTYGIzFPVolSXIx3Ye1GXvR912ftRK1nvhTV5GWOMiQsLKMYYY+LCAkrjMznVBUgj9l7UZe9HXfZ+1ErKe2F9KMYYY+LCaijGGGPiwgJKmhKRk0VkqYgsF5GJAY7/QkQWi8iXIjJdRHqnopzJEO698Jx3noioiDTpkT2RvB8icoH7+/G1iDyf7DImUwR/K71EZIaILHD/Xk5NRTmTQUT+JiJbRWRRkOMiIo+479WXInJEXAugqvZIsweQCawA+gE5wBfAIL9zTgBauNvXAS+mutypei/c81oDHwJzgKJUlzvFvxsDgAVAO/d551SXO8Xvx2TgOnd7ELA61eVO4PvxHeAIYFGQ46cCb+MsYT8K+DSe97caSno6EliuqitVtRz4F3CW9wRVnaGqJe7TOUDjXz80sLDvhet3wH1AaTILlwKRvB9XA39R1V0Aqro1yWVMpkjeDwUK3O02wMYkli+pVPVDYGeIU84CnlPHHKCtiBTG6/4WUNJTd2Cd5/l6d18wV+J862iKwr4XIjIc6Kmq/0tmwVIkkt+Ng4GDReRjEZkjIicnrXTJF8n78RvgUhFZD7wF/DQ5RUtL0X62RMXWlE9PEmBfwOF4InIpUAQcn9ASpU7I90JEMoCHgCuSVaAUi+R3Iwun2WsMTs11logMVtXdCS5bKkTyflwMPKuqD4rIaODv7vtRnfjipZ2IP1sawmoo6Wk90NPzvAcBqukiMg64HThTVcuSVLZkC/detAYGAzNFZDVOu/AbTbhjPpLfjfXA66paoaqrgKU4AaYpiuT9uBJ4CUBVPwHycHJbNUcRfbY0lAWU9PQZMEBE+opIDnAR8Ib3BLeZ5wmcYNKU28hDvhequkdVO6pqH1Xtg9OfdKaqzktNcRMu7O8G8BrOoA1EpCNOE9jKpJYyeSJ5P9YCYwFE5FCcgLItqaVMH28Al7ujvUYBe1R1U7xe3Jq80pCqVorIT4CpOKNY/qaqX4vIb4F5qvoGcPNbOI0AAATFSURBVD/QCvi3iACsVdUzU1boBInwvWg2Inw/pgInichioAq4WVV3pK7UiRPh+/F/wJMiciNO884V6g55ampE5AWcps6Obp/Rr4FsAFV9HKcP6VRgOVAC/CCu92+i76sxxpgksyYvY4wxcWEBxRhjTFxYQDHGGBMXFlCMMcbEhQUUY4xposIli/Q7t7ebaPZLEZkpIlGnc7KAYpodEakSkYWeR59UlymeRGS4iDzlbl8hIn/2Oz4z1MRPEfmXiDTViZDNzbNApKl3HsDJ8zUE+C1wT7Q3s4BimqMDqjrM81jtPSgijX1+1m3AozFc/xjwyziVxaRQoGSRItJfRN4RkfkiMktEBrqHBgHT3e0ZBE7CGpIFFGOo+Sb/bxH5L/Cuu+9mEfnMbQK4y3Pu7e76G++JyAsicpO7v+abv4h0dFPBICKZInK/57V+5O4f417zsogsEZF/ijtLVURGishsEflCROaKSGv3j3+Ypxwfi8gQv39Ha2CIqn4Rwb/5TE8tbamIrHIPzQLGNYHAagKbDPxUVUcANwF/dfd/AZzrbp8DtBaRDtG8sP3CmOYoX0QWuturVPUcd3s0zofxThE5CSf/1ZE4CfXeEJHvAPtx0nsMx/n7+RyYH+Z+V+KkuBgpIrnAxyLyrntsOHAYTj6lj4FjRGQu8CJwoap+JiIFwAHgKZwkmDeIyMFArqp+6XevIsC/vfxCETnW8/wgAHcW+RsAIvIS8IG7v1pElgNDI/i3mUZERFoBR1ObYQMg1/15E/BnEbkCZ22hDUBlNK9vAcU0RwdUdViA/dNU1dc8cJL7WOA+b4UTYFoD//GtRSMikaR+OQkYIiLnuc/buK9VDsxV1fXuay0E+gB7gE2q+hmAqu51j/8buFNEbgZ+iNM+7q+Q+nmqXlTVn/ieiMhM70ER+SXOe/IXz+6tQDcsoDQ1GcDuQL//qroR+B7UBJ5zVXVPNC9uAcWYWvs92wLco6pPeE8QkRsInu67ktpm5Dy/1/qpqk71e60xgDdLdBXO36QEuoeqlojINJy27QtwaiP+DvjdOyQRGQucj7PSn1ee+1qmCVHVvSKySkTOV9V/u02sQ1T1CzeR6E43rf+twN+ifX3rQzEmsKnAD91vaohIdxHpjNMUcI6I5Lv9FWd4rlkNjHC3z/N7retEJNt9rYNFpGWIey8BuonISPf81p7+jKeAR4DPPLUpr29wm7TCEZHeOO3nF6iqf/A4GPg6ktcx6ctNFvkJcIiIrBeRK4FLgCtF5Auc/2Nf5/sYYKmIfAt0Ae6O9n5WQzEmAFV9V5xU55+4bc37gEtV9XMReRFYCKzB6cD2eQB4SUQuA9737H8Kpynrc/cb4Tbg7BD3LheRC4FHRSQfp6YwDtinqvNFZC/wTJBrl4hIGxFprarFYf6ZVwAdgP+4/8aNqnqqiHTBaQKLW1pzkxqqenGQQ/WGEqvqy8DLsdzPsg0bEwMR+Q3OB/0DSbpfN2AmMDDYioPipGkvVtWnGniPG4G9qvp0gwtqmiVr8jKmkRCRy4FPgdvDLF/7GHX7ZqK1G5gSw/WmmbIaijHGmLiwGooxxpi4sIBijDEmLiygGGOMiQsLKMYYY+LCAooxxpi4sIBijDEmLv4fusbJuScAWIIAAAAASUVORK5CYII="",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    },
    {
     ""data"": {
      ""image/png"": ""iVBORw0KGgoAAAANSUhEUgAAAZQAAAEKCAYAAAA1qaOTAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMi4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvhp/UCwAAIABJREFUeJzt3Xd4leX5wPHvnU2AACEsgRBA9oYwLYooLhw460JRkVq7tHXgat3Sqr9aR60IFWxr6xZbF4KgiKwgUxBBCBD2DCM7eX5/vO85OSc5K8mZyf25rnPlXec9Tw7h3OdZ9yPGGJRSSqm6iot0AZRSStUPGlCUUkoFhQYUpZRSQaEBRSmlVFBoQFFKKRUUGlCUUkoFhQYUpZRSQaEBRSmlVFBoQFFKKRUUCZEuQDhlZGSYrKysSBdDKaViysqVKw8aY1r5u65BBZSsrCxycnIiXQyllIopIrI9kOu0yUsppVRQaEBRSikVFBpQlFJKBYUGFKWUUkGhAUUppVRQaEBRSikVFBpQlFJKBYUGlDr46ocD7DhUEOliKKVUVGhQExuD7Ya/LydOYOtT4yNdFKWUijitodRRhYl0CZRSKjpoDaUGyisMn2/Yyzsr80iIq4zFpeUVPPPZJm4fcyrNUhMjWEKllIocDSg18I8luTz83w3Vjv9v7W5e+Worx4vLePLSfuEvmFJKRQFt8qqBfceLPR4vKq0AoLxc27+UUg2XBpQaSIwTj8fL7I6U+HjP55VSqiHQgBKggyeKef6LLR7PVTgCimhAUUo1XBpQAvDNjwfJfnye1/PljoDipQajlFINgQaUANz99lqf5x0BJUEDilKqAdOAEoCURN9vU5nWUJRSSgNKIMRP38iXP+wHNKAopRo2DSgB8Bcmlm49DHgOKGt2HqW4rDwEpVJKqeiiASUAcQGO3nJct/9YEWOfXcjXmw9yyUuLedSeDFlWXkFZeUXIyqmUUpGkASUAgY4Gdkxr/HDNbrYeOMkzczcB8L+1ezh8soRhT85nxFPzQ1NIpZSKsIgFFBFJF5HPRWSz/bOFj2vTRGSXiLzocmyIiKwTkS0i8rz46+iog8GdvBbNjaP2kZxgva2rdx4FIL+wlDOeXsDhkyUcPFESmkIqpVSERbKGMhWYb4zpBsy39715DPiyyrGXgSlAN/txXigKCfCHi3rz1s9G+r3OMdorOSG+2rnjRWVBL5dSSkWTSAaUS4DZ9vZsYIKni0RkCNAGmOtyrB2QZoxZYowxwOvenh8MyQnxDMps7ve6MjuXV7KfYcZKKVUfRfKTr40xZg+A/bN11QtEJA54Fri7yqn2QJ7Lfp59rBoRmSIiOSKSc+DAgVoXNpBJi2UVVpNXYrwGFKVUwxPS9PUiMg9o6+HUAwHe4nbgY2PMzipdJJ4+3T2m+jXGTAemA2RnZ9c6HXDVLprLB3egvKKCD1bvdh5bm5dPfkGps+lLKaUakpAGFGPM2d7Oicg+EWlnjNljN2Ht93DZSGC0iNwONAGSROQE8Begg8t1HYDdHp4fMs9eNcA5HNhh9c6jnPvcV+w9VhTOoiilVFSIZNvMh8CN9vaNwJyqFxhjrjPGZBpjsoC7gNeNMVPtJrLjIjLCHt11g6fnh1pWRmq1YxpMlFINVSQDyjRgnIhsBsbZ+4hItojMCOD5PwdmAFuAH4FPQlVQbzq1bFyr5y3echBrLIFSStUfEVsC2BhzCDjLw/EcYLKH47OAWVWu6xu6EvrX2SWgJMXHURLgLPjrZizjkYv7cMPITn7zhCmlVKzQ4Ui18MPj5wNwSvMU57GHL+7DeX08jT+odNc53Z3bK3IPM/SJ+bwwfzOLtxwka+pHHD6pkx6VUrFLA0oNtGycxE+zO5Jkz4RPcBkefO3wTJ/zTyb/pDMpiZUTHnccLuDgiWKe/fwHXl74IwDrd+WHqORKKRV6EWvyikUrHxpX7VhyQhzFZVZTV0Kc94Aytldrtuw/4dzfm1/Zea8rPiql6gMNKHW08qFxVNgd7EkJ3gNCs0aJJLnUaPYfL3ZuL9l6CAg8CaVSSkUjDSh11CS58i30VUNJS0n0m5LFUdNRSqlYpH0oQeQr5Upao0SS4qsnjXT18sIfdTixUipmaUAJokQvTV7xcULT5ARnZ743y7cdJu9IIfM27GP884soLPG90uPGPcfILyytdXmVUiqYNKAEUbyXTpAfn7yAuDjxG1AAZn69jcmv5/Dd7mO8vXKnz2vP/8sifvrKklqVVSmlgk0DShD5ywnpLeC4emP5Duf27+d85/f67/ce93uNUkqFgwaUICq309dfOqg9X997Jmf1bM1rk4Y6zxvPCZHdlHjomD9wvJgDLqPClFIqGukoryAqKrWCwYAOzejQIpWZLsEE/NdgvBn6xDwAcqeNr7yXpshXSkUZraEEUVGp1YnuOiPeVYWHEVyNvFwL0LNtU6/ndM0VpVS00YASREV2c5W3gDKkUws6pjfi3Z+PokVqIgBzfnkayx+oliMTsPpHhj85z+M5T8FJKaUiSZu8gqiyhuI5TqelJLLonrEALLnvLNbm5dO9jVULGdOjFQs3VV+ieN+xyr6Tk8VlNLYnUpZrDUUpFWW0hhJEgzNbANA5o4nfa1MS4xnWOd25P+umYXRMb+TzOSeLy5zb2uSllIo2WkMJop+d3oXz+7YlK6N2C295GuHl6nBBCS2bJBMfJ9opr5SKOlpDCaK4OKl1MAH8zow/77lF/OwfKwGtoSiloo8GlCji6NT3NaN+3sZ9HDlZop3ySqmoowElijiavObecTq508bzp8v7e7zuxteWk3ekIJxFU0opvzSgRKGMpskAdGqZ6vH82rx87nhzdTiLpJRSfmlAiSJXDukAQOMkax5L42TvYyb8deA7GGP4ZsvBamnxi8t899copVRNaUCJItMu78/GR89D7CSSTXwEFG9rr3y0dg8LNu137n+6fi/XzljGP5dVJp18O2cnPR78lB2HtNlMKRU8GlCiSHyc0CipcpZ9arL3tCyuAcU1ceQv3viWm15b4dzfY69d/6PLevafrt8LwKZ9mqlYKRU8EQkoIpIuIp+LyGb7Zwsf16aJyC4RedHl2EIR2SQiq+1H6/CUPLxcaygd0xsxuluGc991kuPQJ+ZRVFrO8SL3xbYKS8rZuOcYAKXllU1kCfFWDaisXJccVkoFT6RqKFOB+caYbsB8e9+bx4AvPRy/zhgz0H7s93A+5rkmjkyIi+PJS/s59/dXSWefk3uEfg/Pde4bY+j1+095e2UeAJv3nXDOc0mwazelPuaylJVXMGPRVu1rUUoFLFIB5RJgtr09G5jg6SIRGQK0AeZ6Ol/fiQhn9bQqX40S40n2MT/l+pnL3Pa//ME9L9jy3MM8NGc9AIlx/msob+bs5PGPNvLKl1trVXalVMMTqYDSxhizB8D+Wa3JSkTigGeBu73c4zW7ueshkQCWQoxRMycN5cHxvZh+wxCSE7z3qVQ1yaUfxeG73VbzV3yc9c9eVu69huJoUjt8soSp765li0sfjFJKeRKyXF4iMg9o6+HUAwHe4nbgY2PMTg/x4jpjzC4RaQq8C0wEXvdSjinAFIDMzMwAXzq6TB7dBfCfmsWfpnafTKLdh1ISQB/KitzDfLf7GF/9cIDfX9Sb8/q2q1MZlFL1V8hqKMaYs40xfT085gD7RKQdgP3TUx/ISOCXIpILPAPcICLT7Hvvsn8eB94Ahvkox3RjTLYxJrtVq1ZB/R3DzVeTF8AjF/fh9jFdvZ4vtgOIo1PekW7fF8cosd35Rdz2z28DLapSqgGKVJPXh8CN9vaNwJyqFxhjrjPGZBpjsoC7gNeNMVNFJEFEMgBEJBG4EFgfnmJHVlycsOYP53g93zQlgSvsyZGelNqTIRPsJq+CAGo8RwpKalhKpVRDFamAMg0YJyKbgXH2PiKSLSIz/Dw3GfhMRNYCq4FdwKuhLGw0adYokZ+d0cXjufg4oUmKj9n1VZq4fAUUwarFVM1BqQt7KaW8ich6KMaYQ0C1dW+NMTnAZA/HZwGz7O2TwJDQljC63Xd+L+4+pwdr8o5y+ctLABia1YLsrHSfs+sd6VqK7Z+FJWUer3t3ZR4HThR7PHfnm6t5/ppBdSm+Uqqe0gW2YlRCfByZ6dbaKy0bJ/H2baMAquXscrXjcAHvr8pzTnL0VEM5cLyY3729xus9PlyzWwOKUsojTb0Sw5LsCYqDO1UmGvA3gvrON9dwyK59FLh0yh84XsyAR+by7Y4jfl/3/L8sAqzgNWvxNg56qc0opRoWDSgxrFlqIu/dPoq/XD2w2rnGSfH8a/Jwj8/78cBJwEok6RjptWjzAfILS5n+lf+JjI50Lj/sO8HD/93AHf/RVPpKKQ0oMW9wZgtSk9xbLr+8ewxf3zuW5qmJHp+z43BlluEnPtoIWB36EHhafKhMgX+0UEeCKaW0D6Ve6tTS6lvx1rHuak9+Iet35TsDSmEAc1PAmsPiGPAVV38TFSilakBrKPVYWornGoqreRv3c+ELX7Ni22Eg8Nn4S7Ye4uZZVnqX2mS+2Xm4gLdW7Kzx85RS0UsDSj3WtlkKS++rNjrbo60HrX4VTzWU4Z3Tqx276bUVHD5pNXXVpn5yy+wV3PPuWvILS/1frJSKCX4Dioi0FpFLReQXInKziAyzEzeqGNC2WUpA1zk65z3VUC4Z2N7nc1fvPMo/l25n097AF+w6WWy9zv5jRRw6Ucx/1+wO+LlKqejktQ9FRM7EWqckHViFlW8rBSvVfFcReQd41hhzLBwFVaG1ItcaLly1hjK6WwZeVht28+AH62nZOImVD40L6PXSGyex62ghu/OLuP/9dazIPcLwzum0TgssACqloo+vTvkLgFuNMTuqnhCRBKwcWuOwsv2qeurvk4bywapdzv0zureqttaKQyDZix0a28sbHy0oYfdRKwFlcQ1GmLlavfMopzRL0WCkVIR5/e5pjLnbUzCxz5UZYz4wxmgwiSEbHj23Rtf3a9+MxPg4Tu9emaU5Ncn7miwDOjQP6L7zNuxj6VZrEMCxojLnzP0KH7P8fZnw0mLGPutpUU+lVDj5bMwQkTNEpL+9fZWIvCgid4pIcniKp4IpNSmBiSM6AXD/BT39Xn+GHUjapKXws9OthJS+BnQFOuR48us5zu2HPljvXM64LnknTxR7zkumlAofX30oLwH9gWQR+QFoAnwKjAL+DlwXlhKqoHpsQl/uOLsbLZsk8+TH3/u8Nsll/RXHZ32/9s1JjI9jzurqnei7jxZijPE6jLigpIx/LNnu9fX25BfSOaOx/19CKRWVfPWhnGmM6S0iKVgp4lsbY8pF5BVgbXiKp0KhZZPAKpiuAeW2M7qy60gh143IJC0lkYsHnMIts3Pcrt+TX0TekUI6pqdWu1dJWQWX/fUbvvcxEuzaV5eRO218gL+FUira+GryKgIwxhQB240x5fa+AXTyQAw5o3tgK1VmNEly2090Gd6V3jiJl64b7JwsedqpGW7XOhJVHivy/Kdx//vrfAYTpVTs81VDaS0iv8Wat+bYxt6P7bV0G5hZNw2ttlCWJy1Skzh4ojIv13EvwQGs5Ygnjcqy7v9NLo2S4ikprGDGom08ckmfarP0PY0Ma9csxbnEsFIq9vmqobwKNMXqO3FsO/b9raqoooiIEBfnez77S9cOZvP+E27H9hz1/mEvIjx8cR8GZVojuxyjv95ftYsn/rex2vUVHnrc+7Vv5rfs/ni6r1IqMrzWUIwxj4SzICqyxvdvxy/ecD/Wt4P/D3xHzcd1OPHSbYecnfMrtx9h9c6jlHn44P/l2FOZu2Gf27GKCuM3+Lkqr+VQY6VU8Pka5fW8rycaY34d/OKoaHLdsEy/1xh7/JdrCv3thwp4OyePq4Z25PKXv/H4vL9dP8TjiK7HPtrA1UMz6dG2aUBl1DXulYoevpq8VtqPFGAwsNl+DAQCm3CgYsp/poxwbn9975kB1RQ81VAA7nl3LVe9ssTjc343rjvn9W1LSmL1SZKvLc7l3Oe+CrjMrgEl+/F5FJTofBSlIsXXTPnZxpjZQDesIcQvGGNeAM7CCioqxr1/+yi3/YEdK2e6d2hRfeivJy1SrZFhp7ZuUu3ccjslvqs+p6Txq7O6Ae6jyKradyywznrXJq+DJ4qZ+90+rp6+RJclVioCAskafApWZ7xDE/uYinGDMlu47Sfb804GZwaWQgVgTI9WvHjtIP5wUR+mnu9/9n3VxbieuLSvx+sOHA8sIJSXuzd53f3OGpZuPcy6vPyAnu8wb8M+7n9/HYdPlnBIg5FStRLIio3TgFUissDePwN4OGQlUmH19b1nOocKiwjzf3cGrZsGnllHRLiwv/X94rYzujLtE9+z76u2ol03vBMPvL++ZoV2sTrvqNt+qR1gSgNIVFlUWk5xaQUG40wH88YyK33dhkfPJSk+joRAUi0rpYAAAoox5jUR+QQYbh+aaozZG9piqXDp0CLVrXmra6vqTVfBFOgIrkAzD9/02gqPxwt8rDy5/3gRw56Y79zv2z6t2jW9f/8Zp3dvxes3DwuoHEopH01eIpLl2DbG7DXGzLEfe+3zIiIdavOiIpIuIp+LyGb7Zwsv15WLyGr78aHL8c4issx+/psikuTp+Sr8bjoty+f5QNefv/zlb+o0guuk3Tl/6V8X8+pXW93Obaky32b9Ls9L+nz1wwE+XLObeVWGNiulPPNVn39aRN4VkRtEpI+9cmOmiIwVkceAxUCvWr7uVGC+MaYbMN/e96TQGDPQflzscvyPwJ/t5x8BbqllOVSQ/eGiPj7zcdVgigknimo/YuuknX141Y6jPPGx+0RLT6PLvPn1v1cx+fUccnIPsze/iN1HC2tdJqXqO1+jvK4EHgJ6AC8Bi4A5wGRgEzDWGPN5LV/3EmC2vT0baxXIgIiVynYs8E5tnq8i47WbhgJ4zUTsibe8YIE4WVzu7A8Jhiv+toQRT81n1LQvyC/QVHZKeeKzD8UYswF4IASv28YYs8d+jT0i0trLdSkikgOUAdOMMR8ALYGjxhjH19c8wPei5yriEuyqib8aikjl3BZ/AcX4mCVfUFLG/e+vc+4/+fFG0lIS+OXYbpTUcmVIh8MFJTRLTfR/oVINTCCjvGpFROYBbT2cqkmAyjTG7BaRLsAXIrIO8NTg7fWTRUSmAFMAMjP9z/xWoSFYkSTeQ0Tp0KIReUespqQbR2bx7rd5HC8qI/dgAWkpiZwoLmNF7mEmjuiEMZUd+6Xl3gPKySqd8tPtfpStB07SonHdutyKAlxITKmGJmQBxRhztrdzIrJPRNrZtZN2wH4v99ht/9wqIguBQVhr2DcXkQS7ltIBqL7aU+U9pgPTAbKzszVPR5j8fVI2N8+qXC/FEUcaJVb/k/v63rHsP17ExBnLueUnnbl8cAcuevFrfvHGt27XCfDQnO/49qFxpDdOoqjM+we7t+au91btqvkvU4XOxlfKs0gNsv8QuNHevhGrb8aNiLRwLDUsIhnAacAGez2WBcAVvp6vImtszzZuywwP79KS28d05anL+nm8vnXTFD6783Q6pqeS1sjz95y/LvwRgL12yvtI1RSO1WGwgFL1md+AYg8Pvl5Efm/vZ4pIXQfnTwPGichmYJy9j4hki4gjNX4vIEdE1mAFkGl2nw7AvcBvRWQLVp/KzDqWR4XAlNO78qfL+3N2r9bExwn3nNeTVgFMmmya4rl/wjF7vrDU+kAvKqlbX0hVPdo05VdjT/V73fEYCygVFYatB04w4aXFzmCsVCgE0uT1V6ACa2TVo8BxrGanobV9UWPMIaycYFWP52CNIsMY8w3g8eusMWYroDPOYsBVQzty1dCONXpO0xTPf5aOFPg/7DvB4MwWzN3gPr/2qcv68cL8zeyu5Ydmk5QE2qSl+L0u1vpQnv18Ey8tsGp3byzfwW/Hdfd5vWPpAaVqKpAmr+HGmF9QuSTwEUAnEqqQ8ZU0EuC+99bR+b6Pefwj9/klcQLf3Ffte4pPp53a0rmdFB8XUNqZe95ZW6PXiJRdRwu59fUcZn+z3Xns+fmb2X/ce8B94qMNdL7vY58j6JTyJpCAUioi8dgjqUSkFVaNRamocMPITgDO2sW/Jg/3dbmb7E7pDOucDkByYhyndw9sdetoX4flwQ/Wcdq0L/h8wz5OFLs30W3YfYz9x4so9JCe5tVF2wA4onNtVC0EElCeB97HWlf+CeBr4MmQlkqpGrj/gl7845ZhjOlhTWdyBIhApCTGc9OoLMCqoaQkxjvnzPgy4JG5tSpruPxzqfdJnfFxwrAn5nPlK9UXP0uyM05rRgBVG34DijHmX8A9wFPAHmCCMebtUBdMKU8S44U/Xt6PN26trIWkJMYzulsrl2vimD5xSED3S0mMc/bNOBYJa9vMfz9K1W/90WTrgRPVjg3LqgyyjrlArjnMSsoqyJr6kXPSp69mMaW88ZUcMt3xwJon8m/gDWCffUypsJlyehcAKgz8dGgmo7pm+Lw+0CSU5RWGc/q04foRmTx4YW8A/n3rCJ65coDzmjE9PDeDzVld9zktoXDnm6urHevfoZlz21P3SH6hexPXscLKgFlWXuFxsTSlqvK3BHCO/fMA8APWEsAH7GNKhU2fU9I4u1cbZt6Y7Tz20+yOXDbYc9aduABnWBWVlpOcEM/jE/qR0cTqkO+Ynsplg6z7XpXdgV+NtVaYfOySPm7P/c1/qn9wB8uzczfV+kO8zEP/ztXDKrNEzN9YOY/48ElrLZw/fuq+jk1+Yamz2evpuZu46pUlrK2y9oxSVflKDtnZGNMF+Ay4yBiTYYxpCVwIvBeuAqqG6c8/HeC237ppCjNuzHb2kwD88Yr+/N9Vnlej9lRD+cct1UeaF5V6Hl8SFyes+cM5PHlpP4Z0akHutPFMHJlV7TrHB3IwGWN44YstXPXKkho/d+fhAr7bXT07kesSzX9fvM25veNwAQDvrMxzu/4PH37HqGlfcOhEMa98aaWtca21KOVJIN/jhhpjPnbsGGM+wVq1UamQuXSQ+1I7rdMCX0USoH8Haxnjf00ezg+Pn887t41kdLdWtKvSP5LuI69Xs0aJfldsPFoQ3ICSd6TAbXGxW2atYOCjc9my/3hAz7/19Zxqx64Z5j2H3X+W7/C55PFri3Od244Oe6W8CeQv5KCIPCgiWSLSSUQeAA6FumBKTTm9C43sUVdVA4E/6Y2TyJ02ntNOzSApIY5su1PadSXHF64ZxI32CK+aOsUuz7WvLgvanI2DJ4r5yR8XMHHmMuex+d/v52hBqc9RW64cNQ6HNyYP5/EJfQFI9hAQ/rNiJ0Men+f1fi8u2OLcLvaRO00pCCygXAO0who6/AHQ2j6mVEjdf0Ev1j9yLisfHEdqUnDymLrOvbhowCkesx8HIq2RlR5m77Einpm7KShlcywKtiL3SLVzFQEGrdJy9ya8YZ3Tnb/jR78eXafyTZy5nDOeXuBxFJlSENiw4cPGmN8YYwbZj98YY3TIhwqL+DgJ6tojJeV1m5M7qqs1sz7NJd+YI61JXVUNBq48dbR7vkfldT8+eYFbk51jWHRdbD9UEHBtSTU8gSSHXCAiX1R9hKNwSkUbx4ivM3u6rwkXjGYvbwMEAMp9rP3iTdXal7+UNuA+X8WbhHjrvuvy8vnn0u0UlpRz9fQlbNobWD+Pqr8CafK6C7jbfjwErMYaTqxUzHFMeExJrF0H88iuLVn+wFlcN8K9o9tXMAiUr6ST/1u7m6ypH/lcxXJnlf6Tqvy17t19bg/eum2k74uwFis7WVzGRS9+zYMfrOfFBZtZuvUwT3680e9zG7rvduezJ7/+ZiHw2zBtjKk652SxiHwZovIoFVLn9GnL94+dV6d7tG5qdcg/99OB3GFPIiwoKaNRHZuUfAUlxwqU2w6cZEDH5h6v2bDH02KmlZo1SqR7myb8sM9zH4jr5Ed/1ublO7cdTX46Csy7krIK1u06yuUvW0PBc6eNj3CJQiOQJq90l0eGiJyL56V9lYoJKYnxpCTWvT+hfYtGzu0CD4kWa8oximpgx+ZsePRcXptUfYWI7/ceI2vqRx6HEbvOifGUjywhPo65d57hlmE5NSme39sZAjq2SHW7fkQXq/lrdLeMavnRPK2WqQHFu6nvrXUGk/oskKEzK7EyDQtQBmwDbglloZSKBU2SK//7FAZhjRRHDeWPl/cnNSnB47owH6yyVrv+7Lt9nNq6KcYYnvrkey7o14773lsHwPIHziI5wXvAfPWGbA6dKOGT9XsY06M13ds0ZdKoLOKqBKF7zuvJZX/9hjN7tGZNlVnys1zmpzgkB9BH01B9EISlp2NBIAGllzHGLVOcY2lepRqyHm2a0iYtmX3HioOSLHJFrjV40tG/U+qhI94RuByJAErKK5j+1Vamf7XVeY2jSc6b1KQEUtMTmHJ6V+cx12Dy2CV9WLrtMIMzW/D5nadzausm5B4qYM7q3c5rvvzhQLX7JiXEsS4vn04ZqW6j4JSVg64hCOQrRfUc11D/625K+REXJ7w5xerErmvyxL35Rcz6Jhew+jpcf7pydNwLVgCouqaJo5mqLiaOzOKlawcD0K1NU0SErJapfp5ljSK76MWvuWXWCsAaBj36T1/w6fo9dS6Tig2+sg23FZEhQCMRGSQig+3HGMD/X5dSDUBWRmPSUhLqvFb7u99aubSuGNKB5qlWOpjep6Tx5pQRbqlTHDWhvCMFHD5ZUq3v5rw+oeneDGRJ4K+3HAQqJ2YeLShl5+FCHvxgfUjKpKKPrxrKucAzQAfg/4Bn7cdvgftDXzSlYkNqUgIFJbVv8pr59Tae/mwTTZMT+OPl/d3ODe/SktHdKlP15x2xhpz+a9kOzvjTAo5WWVmxhY/cZMHQu10af5+U7fHctoMn3fYdq1o29NWEqyYQ9VTzrC+89qEYY2YDs0XkcmPMu2Esk1IxpVFSfJ1GeT32vw0AdGvTxGMqmAv6tSMzPbVanq7jxWVc8Pwit2MjurQkVDY9fh5xIqze6T+N/ZMfb3Tr12nIvt1u1djeuW0kbyzfwXvf1t8Oel9NXtfbm1ki8tuqjzCVT6mo1ygx3uekxEC1SPVeu3hi8JSrAAAf7klEQVTv9lEB3aNNWs2SaNZEckI8ifFxAXW4ewomwUqiGWscAymaNUrkv2usgQ3f/HgwkkUKGV9NXo3tn02Aph4eSimsuRzBmIfSxMMwYYdgzJsJlqrlfMfP7HoRa1RY5/s+bpDpWRzLESQnxHOmvZ5P7kHfWQ1ila8mr1fsn4+ErzhKxZ6yCkPOj4coK6/wu36KLwk+lplMiaJJg6c0S2Hq+T2ZMLA9bQNYVuDgiRJ+/k8r4cY3Px6kR9uG9X20xBFQEuN46brBdHvgk3qbfsXvPBQRaQXcCmS5Xm+Mubm2L2qvSf+mfc9c4CpjTLWc3SJSDqyzd3cYYy62j8/CWuTLkf9hkjEmdOuxKuWDo0/hvVW7uCq7Y63v4ysW+QtU43q34c6zu9f6tWtCRLjtjK5ux4Z3Tsfgffi0owYXjJpcrLn/fesjLDkhzpmg84UvtnDaqRkh7fOKhEC+9swBmgHzgI9cHnUxFZhvjOkGzLf3PSk0xgy0HxdXOXe3yzkNJipinr3SWq7YMQKrJkpcVmes7dosYM1+731KWq2fX1dv/mwkb/1spN8cVSeDMAE0lpS7zGismr3g6ulLw12ckAskoKQaY+41xrxljHnX8ajj614CzLa3ZwMT6ng/pSLm8iEdSEtJ4Fih90zA3uw+WhmEApnr4fDHy/s5t/u2j1wg8WTCwFO8nnv5yx+rrV9fn7kOGXbkOrtscHvnsf3H6jZ/KdoEElD+JyIXBPl12xhj9gDYP1t7uS5FRHJEZKmIVA06T4jIWhH5s6aCUZGWlBDHP5duZ6OfjL9VuSZZDLSC8uD4XpzVqw0AT13WzzlbP1o8d/UgrzUVY+Cut9eQW2XOSn21zyVgOGqgN5/W2XnsUXvIeH0RSED5DVZQKRSRYyJyXET8/q8RkXkist7D45IalC/TGJMNXAs8JyKOhtv7gJ7AUCAduNdHOabYQSnnwIHq+YeUCoaDJ0ooqzCc/5dF5NegpnLX22uc2/EB1lAmj+5CRpNkcqeN55phmTRODs7yyKHiWIPG1ZhnFjJvw74IlCa8VnmYs+M67NpTVuhYFsgSwE2NMXHGmEbGmDR7328d2xhztjGmr4fHHGCfiLQDsH/u93KP3fbPrcBCYJC9v8dYioHXgGE+yjHdGJNtjMlu1aqVv2IrVWcDHpnL/I37AkoYuX5X5Xezqtl+6wvXNP+uApkgGesWb64+38R13ZxQZzYIt0DWQxns4dFVROrytehD4EZ7+0asjv+qr9vC0ZQlIhnAacAGe98RjASr/0WTBamImnGDezqSW2bn8MD767xc7dmQTi18nv/o1z9h3m9Pr3HZIuWaYR05tXUTerdL48lL+zFpVJbb+WCk/I9mi7cc5NPv9lY7nt44iZH26K7NXhY7i1WBBIW/AoOpHL7bD1gDtBSR24wxc2vxutOAt0TkFmAHcCWAiGQDtxljJgO9gFdEpAIr8E0zxjgaHP9lD2cWrCWJb6tFGZQKGk+LS+2qwaivv10/mPP6tvN5TZ9TAl9RMRo8dVllXrJrh1sJLlfkHua73VatLBjZBaLZdTOWATCmRytm3VTZiBIfJ/x7ygiypn7E11sOsmnvcdq3aOS2vk6sCqQPJRcYZIwZYowZAgzEqhGcDfypNi9qjDlkjDnLGNPN/nnYPp5jBxOMMd8YY/oZYwbYP2e6PH+sfayvMeZ6Y0z9CvMq5iR7CCipNfiA6JzRJJjFiVqPXNzHuV1UWsEf5qxnxqL6mfMrMd5qwrxscAef15373Ff85t+rwlGkkAvkL76nMeY7x44xZoOIDDLGbK3JMEel6rNhndO5dngmbyzb4TzW2M8a84dOFDu3PQWk+qhv+8paliNlP1gDDeqTsvIKKgz8fExXLh7gfRi1w8od1eZ1x6RA/oo3icjLInKG/fgr8IPdv1HzgfdK1UMiwh1nd3M71shP/q0znl7o3G4o67FHU06yUDpSUEp5haGdj9Q0ruvcpNeTzvlA/oonAVuAO4A7ga32sVLgzFAVTKlY0zjJvcLvb+a76yiwhpmHt/5yDB33tfbJ2b0qp991yWjs9bpY4rfJyxhTSOXiWlVp34VStqo1krgaNAm3aapzc+uT/EJrhryvgOLaCV9aXj++UgQybLibiLwjIhtEZKvjEY7CKRVLqs4jWbcrn7dW7Kx2XXFZuVvKlQV3jalTluJYdemg9v4vilGB1FC6tanMuhzInKVYEMhf8WvAy0AZVhPX68A/QlkopWLVmT0qJ89u2HOMe95dW+2ax/+3kVHTviA+Tpg4ohOd60lzR03Vh2Gynpz5zEJunpUDQMvG3mue6Y2T+NPl/enepgkrtx9hbV7sT/QMJKA0MsbMB8QYs90Y8zAwNrTFUio2vXaT16QNTmvsD47yCkOL1Pq7vrg/F/avnHfzxff1Iw3LF9/vY5tLnjJvWQIcrhrakb9cPQjwnvo/lgQSUIpEJA7YLCK/FJFL8Z7MUSlVRWl5hdt+p5aVNZI0H00i9d2wzumc28dKcun4Rh/rqv4egSxJcGpraw5SYT1YKyaQgHIHkAr8GhgCTKQybYpSyo8f9lnL3hpj2LT3OEku/SW+2tjrOxHhwv6VczT+9On3ESxN8P3hot4BXedYdGvhD7GfvDaQ5JArjDEnjDF5xpibjDGXGWPq38owSgXJZ3ecTgeXpo7xz3/Nht3H+MkfF3Duc1+5TehryAEF4KIBpzhnz/914Y9UVNSP0U4AqX4mtla1cvuRmF+AzGuvmIh86OuJHlZQVEoBPdo2ZXS3Vvx7eeWs+QueX+Tx2owGOFy4Z9umfL/3uHP/xlFZxMUJD32wnt35hXRokRrB0gVPo6SaDzo4dKIk6pcj8MVXyUcCO4F/A8uwEjEqpQLgr+bRJDmBP/90IAM7NA9TiaLHOz8fxRGXlQwB2qZZM8qPnCylfXOrlhJLqZ1W5B7myr8tcTuWWousAAdOFJPZMnYDqq8mr7bA/UBf4C/AOOCgMeZLY8yX4SicUrHKX0Bp37wR43q3qbdroPjSJDmBjunuH5qO0W6rdx6h830fc//7sbUixf/W7K52rFENm7zASnkfy7wGFGNMuTHmU2PMjcAIrPQrC0XkV2ErnVIxqkmK72aLhpK7K1COhaYemmPlof338h2siqGEiVWbqW4f05XBmb7Xt3H1qr2ezv99/kNM9yP5/KsWkWQRuQz4J/AL4HngvXAUTKlYlmjXPLwFDg0o7lqkVk+OOHl2bAwlzi8oZeuByrknU07vwj3n9axRDeWM7pUTYs98dmEwixdWvjrlZ2M1d30CPGKMia06qFIR5GjK6pLR2K0D2uFIQUm1Yw1ZLI92u37mMtbtynfuHz5Z839b1y8Y2w8VUF5hAprDEm18fU2aCHQHfgN8IyLH7MdxETnm43lKNXiOD8g2aZ7Tl8fyB2goxOKHp4NrMIHaBRSAXu3SnNtPf7apTmWKFF99KHHGmKb2I83l0dQYk+bteUopGNerDY9N6Mt9F/Ssdu6iAac428xV/XO0lrXPd38+snLbZa5SLNGGXKVCIM5O/JiWUr0mckb3VmQ0aXjzT/xp39x33qto9G2VgQNXDOnAtMv71+peqS7zVmK1vqYBRakQSmyAaelra/HUsfRwSeleVBr9ua2e/Gij2/4zVw6gu8vvUFNv3DocgP4dmvm5MjrpX7tSIeToGuiS0ZjLBlvrfxgTu8NCQ61r68rEmRWGqB5Cm19YSs724A5tHtU1g04tU2M2tb8GFKVCqGWTZB4c34vZNw9D7IaM6P2IjLxHL+nLhIGn8NiEvhSWlrPwh/2RLpJXQx+fF5L7niwu54PV1SdKxgINKEqF2OTRXeiYnkpTe7Jjss5B8SqjSTLPXT2Ic3pbae3nbYzegFLisixB73Zp3PKTzkG578ETxQDsP1YUlPuFU2zWq5SKQXef24OWjZPcUrYrzxyTAt9YtoMnL+0X4dK423GogNOfXuB27OPfjA7a/QdnNufbHUfZf7yY1l6GnUeriHxVEpF0EflcRDbbPz3mKBCRTBGZKyIb7TXts+zjnUVkmf38N0Wk+jRbpaJM4+QEfnVWt5iecxEujVwSK9Z2XkeorNoZ2pQwD4zvBVTWVGJJpOreU4H5xphuwHx735PXgaeNMb2AYYCj/vtH4M/2848At4S4vEqpMHIdHXf6nxaweV/1bAPR4hdndg3q/RxDyv+5dDtlVVb7jHaRCiiXALPt7dnAhKoXiEhvIMEY8zmAvchXgVg5rccC7/h6vlKqfjhRXMa4P3/F9kMn/V8cAef3bRfU+zkCyryN+3l9yfag3jvUIhVQ2hhj9gDYPz2tUd8dOCoi74nIKhF5WkTigZbAUWOMY2mzPKB9WEqtlIqYPfnR10k9vl87+rYP7pwR18zFsdbsFbJOeRGZh7WmSlUPBHiLBGA0MAjYAbwJTAI8rSTpdSSmiEwBpgBkZmYG+NJKqWhTXBYdzT+uC39NGBTa77KNarFIVySFrIZijDnbGNPXw2MOsE9E2gHYPz2NDcwDVhljttq1kQ+AwcBBoLmIOIJhB8DroG1jzHRjTLYxJrtVq1beLlNKRbkTRdGx3vrxolLn9jh7eHOwvTZpKGA198WSSDV5fQjcaG/fCMzxcM0KoIWIOKLAWGCDsaYZLwCu8PN8pVQMe/ii3m770z7d6OXK8HogDKtJntmzNRlNkjnmErxiQaQCyjRgnIhsxlpaeBqAiGSLyAywVowE7gLmi8g6rHxpr9rPvxf4rYhswepTmRnm8iulQuzMnu5dqzsPF1JQEtlv7PkF4fuAT0mMo7g0Opr5AhWRiY3GmEPAWR6O5wCTXfY/B6ql7jTGbMUaRqyUqqc6tWxM7rTxZE39yHmsuLQCD4s7hs22MI40S0mMp6gs+hNkutIcEEqpqHbPeT2c25H+gHUduvzmlBEhfa3khDjmbdjPgeOxM9JLA4pSKqrdPuZU5/a/lu6IYElgbV4+SQlxbHr8PIZ3aRny1yspr+CW2StC/jrBogFFKRX1bh1tJV58ccGWiJWhosLw1oqddG/ThOSE0A/ndaScWZuX7+fK6KEBRSkV9UZ1zXBuR2qNlFnf5HK8uIz1u46F5fVcJzXGSuZhDShKqajnmtvrZIRGem3efyKsr1daXhk4Y2X4sAYUpVTUc10OuKAkMh3zifGRyxJdUhYby7JpQFFKRT3X/FaRmj3uWHYgKUwLpI3vX5l0MtLzbwKlAUUpFfVGdm3JtcOtXHwb9xzjuXk/YCXNCI+c3MO8tjgXgLd+NjIsr/niNYN449bhAFzxtyVhec260oCilIoJEwZaiRh/+cYqnpu3mX3Hwjc/4/GPKtO+DOzYPCyvKSKkJsXWoroaUJRSMaF102S3/bKK8KUlSQ5TM1dVKYmVrxvOGlltaUBRSsWE1mnuAcW1oz7UUiKURj7FZb7LjEXbIlKGmtCAopSKCVWbf4rCmDgxUiO8XOskT3wcHdmWfdGAopSKSYVhrKE4XuvC/sFd7tefrJapYX29utKAopSKGUvvq0xSfjyMk/1OFpdz2qkteeGaQWF7TbA65jOaVKZXvvSvi8P6+jWlAUUpFTPaNkvhL1cPBODmWTlhm5NysriMtJREt+V/w6XEZenjVTuOsvNwQdjLECgNKEqpmNK3fTPn9orcwyF/vYkzl7F5/4mIDeG9dngnt/38wuhNw6IBRSkVU1q5DB8OxzrzizYfBKBxcmRGet17Xg/uO7+nc784ihfd0oCilIopaSmJzu1H/vtd2F63UYSGDosITV1+53CObqspDShKqZgzfeIQAA6eKAlpJl7Xjv9wjiqrynViZWGEkmMGQgOKUirmjO3Z2rm9cvuRkL3OU59879w+WhC5vgtHYkqI/DLIvmhAUUrFnASX9VHW7Dwastc5WlDi3I5k4hPXjnitoSilVIgcOlHi/6JaSoir/Ih86MJeIXsdf1zzeBWVaR+KUkoF1aJ7ziSjSRJvLN/BxJnLQrI0cIX9Qb769+No3TQl6PcP1DXDM/nlmacCsDe/MGLl8EcDilIqJnVMT6VjeirlFYZFmw+GZGngA8eLGZrVguapSf4vDqHkhHh+d053Tm3dhCU/HopoWXyJSEARkXQR+VxENts/W3i5LlNE5orIRhHZICJZ9vFZIrJNRFbbj4HhLL9SKjoUuwyhXR2CvpSDJ4rd5r1EkojQo01T1u8+FpLaWDBEqoYyFZhvjOkGzLf3PXkdeNoY0wsYBux3OXe3MWag/Vgd2uIqpaKR68fqxJnLg3rvb7Yc5McDJ2nVJDoCCsCBE8WUlFXQ5w+fRbooHkUqoFwCzLa3ZwMTql4gIr2BBGPM5wDGmBPGmOhNYqOUCrvmjRLd9oM10dEYw7UzlgGQEUUBxTHqrLC0nC37jwf0nLnf7WXYE/PYdvBkKIsGRC6gtDHG7AGwf7b2cE134KiIvCciq0TkaRFxnar6hIisFZE/i0j0/IsrpcLm6Sv70yWjsXPfse67w/pd+Tzx0YYar3a491iRcztamrwAXH+Ns//vK77fe8zvc44XlbH/eDHxYUhsGbKAIiLzRGS9h8clAd4iARgN3AUMBboAk+xz9wE97ePpwL0+yjFFRHJEJOfAgQO1/XWUUlGoQ4tUfndOD+d+1WWCr56+lFcXbeOkPXdjXV4+Ly3Y4ve+o6Z94dxObxzZDnlXE0e6J4o8ctL/ZMtie5hxcmLo6w8hS59pjDnb2zkR2Sci7Ywxe0SkHe59Iw55wCpjzFb7OR8AI4CZjtoNUCwir2EFHW/lmA5MB8jOzo7OniylVK31c8k+nF9YypzVu7hkYHugMpHiqh1HEITrZ1rNWCO6tOTIyRLSGiUyrHN6tXu61gQGZjYPYelr5oaRWbRv3oj/rtnNB6t3BzRr3rFUsmv6llCJVJPXh8CN9vaNwBwP16wAWohIK3t/LLABwA5CiLU4wQRgfUhLq5SKWpktU8mdNp4urRpTXFbBb/6zmgJ7CLFjMNTEmcudwQTg8pe/YfLrOVz1yhI+37CPgY/O5b1v8wBYsKny++2bU0ZEdP6JJ2f1asNtY7oC7jP5qyopq2Dn4QJe+epHwBp6HGqRCijTgHEishkYZ+8jItkiMgPAGFOOVfOYLyLrAAFetZ//L/vYOiADeDzM5VdKRZkkl3QsvX//GZ+s20N5AMNrb309h6MFpUx9dx0AN722wnkuOUIZhv1JTbQal+58c43Xa+59dy2j/7SAfceKgfDUUCKyYowx5hBwlofjOcBkl/3Pgf4erhsb0gIqpWJOYrz7B+bP//VtjZ5fUl7B+l35bsdSwtDvUBuNkioD3bwN+3j32zyevWqAcxGw9bvyeX/VLrfnxMWFvlM+MkuQKaVUkK2rEgxq48IXvnbbD0czUW2kugSUya/nANZKlr+w07NU/T3CJTrDr1JKhdjgADrbw9FMVBueFvs6WRz61Sv9ic53SymlQmDSqCwAxvdrx8MX9/F7fUqU9qHExQnPXzPI7VhZFKRj0YCilKrX/vernzi3e7dLI3faeF66bjD9OzTny7vH+HxuUpTWUAAu7NfObT8n93C1QQiukz7DIXrfLaWUqoGPfz2a128eVu143/bNOL9vW8C9MxugU8vG9GjTtNpzHhxvrX2SEsUBJS5OuN0ePgzw7Y6jPPnxRue8E4BnrhrAr8/qxvePnReWMmmnvFKqXuh9ShoAvx57KumNk3j4vxuc524clcUn6/cyvEv1SYyeZsJPHt2FyaO7hK6wQVK1SW7m19uY+fU2AAZ0bM7gzBYMzvSYzD0kNKAopeqV39qpWLYcOMHFA6wZ8yO6tCR32niP1z9+aV/OevbLsJUvmHwNax7fr20YS2LRgKKUqpcen9AvoOu6tmpCp5apbD9kJTMf7iEVS7TyNWigaUqi13OhogFFKdXgOZb6ff/2UfRqlxbh0gTOMaz5iiEdeGdlntu5Jsnh/3iP3h4npZQKk1+P7QZAz7ZpUTtU2JN2zRrZP1OqZVoOQ7b6arSGopRq8K7M7siV2R0jXYwaG90tg1cmDuHMHq35fMM+9h8vdp4LJI9ZsGlAUUqpGCUinNvH6nyfPjGb91blMb5fO979dhfn923n59khKE9NVzKLZdnZ2SYnJyfSxVBKqZgiIiuNMdn+rtM+FKWUUkGhAUUppVRQaEBRSikVFBpQlFJKBYUGFKWUUkGhAUUppVRQaEBRSikVFBpQlFJKBUWDmtgoIgeA7ZEuRx1lAAcjXYgooe+FO30/3On7Uamu70UnY0wrfxc1qIBSH4hITiAzVhsCfS/c6fvhTt+PSuF6L7TJSymlVFBoQFFKKRUUGlBiz/RIFyCK6HvhTt8Pd/p+VArLe6F9KEoppYJCayhKKaWCQgNKlBKR80Rkk4hsEZGpHs7/VkQ2iMhaEZkvIp0iUc5w8PdeuFx3hYgYEanXI3sCeT9E5Cr77+M7EXkj3GUMpwD+r2SKyAIRWWX/f7kgEuUMBxH5u4jsF5H1Xs6LiDxvv1drRWRwUAtgjNFHlD2AeOBHoAuQBKwBele55kwg1d7+OfBmpMsdqffCvq4p8BWwFMiOdLkj/LfRDVgFtLD3W0e63BF+P6YDP7e3ewO5kS53CN+P04HBwHov5y8APgEEGAEsC+braw0lOg0DthhjthpjSoD/AJe4XmCMWWCMKbB3lwIdwlzGcPH7XtgeA/4EFIWzcBEQyPtxK/CSMeYIgDFmf5jLGE6BvB8GSLO3mwG7w1i+sDLGfAUc9nHJJcDrxrIUaC4iQVsrWANKdGoP7HTZz7OPeXML1reO+sjveyEig4COxpj/hbNgERLI30Z3oLuILBaRpSJyXthKF36BvB8PA9eLSB7wMfCr8BQtKtX0s6VGEoJ1IxVU4uGYx+F4InI9kA2cEdISRY7P90JE4oA/A5PCVaAIC+RvIwGr2WsMVs11kYj0NcYcDXHZIiGQ9+MaYJYx5lkRGQn8w34/KkJfvKgT8GdLbWgNJTrlAR1d9jvgoZouImcDDwAXG2OKw1S2cPP3XjQF+gILRSQXq134w3rcMR/I30YeMMcYU2qM2QZswgow9VEg78ctwFsAxpglQApWbquGKKDPltrSgBKdVgDdRKSziCQBVwMful5gN/O8ghVM6nMbuc/3whiTb4zJMMZkGWOysPqTLjbG5ESmuCHn928D+ABr0AYikoHVBLY1rKUMn0Dejx3AWQAi0gsroBwIaymjx4fADfZorxFAvjFmT7Burk1eUcgYUyYivwQ+wxrF8ndjzHci8iiQY4z5EHgaaAK8LSIAO4wxF0es0CES4HvRYAT4fnwGnCMiG4By4G5jzKHIlTp0Anw/fge8KiJ3YjXvTDL2kKf6RkT+jdXUmWH3Gf0BSAQwxvwNqw/pAmALUADcFNTXr6fvq1JKqTDTJi+llFJBoQFFKaVUUGhAUUopFRQaUJRSSgWFBhSllKqn/CWLrHJtJzvR7FoRWSgiNU7npAFFNTgiUi4iq10eWZEuUzCJyCARmWFvTxKRF6ucX+hr4qeI/EdE6utEyIZmFhBo6p1nsPJ89QceBZ6q6YtpQFENUaExZqDLI9f1pIjE+vys+4EX6vD8l4F7glQWFUGekkWKSFcR+VREVorIIhHpaZ/qDcy3txfgOQmrTxpQlML5Tf5tEfkvMNc+dreIrLCbAB5xufYBe/2NeSLybxG5yz7u/OYvIhl2KhhEJF5Enna518/s42Ps57wjIt+LyL/EnqUqIkNF5BsRWSMiy0Wkqf2ff6BLORaLSP8qv0dToL8xZk0Av/PFLrW0TSKyzT61CDi7HgRW5dl04FfGmCHAXcBf7eNrgMvt7UuBpiLSsiY31j8Y1RA1EpHV9vY2Y8yl9vZIrA/jwyJyDlb+q2FYCfU+FJHTgZNY6T0GYf3/+RZY6ef1bsFKcTFURJKBxSIy1z43COiDlU9pMXCaiCwH3gR+aoxZISJpQCEwAysJ5h0i0h1INsasrfJa2UDV9vKfishPXPZPBbBnkX8IICJvAV/axytEZAswIIDfTcUQEWkCjKIywwZAsv3zLuBFEZmEtbbQLqCsJvfXgKIaokJjzEAPxz83xjiaB86xH6vs/SZYAaYp8L5jLRoRCST1yzlAfxG5wt5vZt+rBFhujMmz77UayALygT3GmBUAxphj9vm3gYdE5G7gZqz28araUT1P1ZvGmF86dkRkoetJEbkH6z15yeXwfuAUNKDUN3HAUU9//8aY3cBl4Aw8lxtj8mtycw0oSlU66bItwFPGmFdcLxCRO/Ce7ruMymbklCr3+pUx5rMq9xoDuGaJLsf6PymeXsMYUyAin2O1bV+FVRupqrDKa/skImcBV2Kt9Ocqxb6XqkeMMcdEZJuIXGmMedtuYu1vjFljJxI9bKf1vw/4e03vr30oSnn2GXCz/U0NEWkvIq2xmgIuFZFGdn/FRS7PyQWG2NtXVLnXz0Uk0b5XdxFp7OO1vwdOEZGh9vVNXfozZgDPAytcalOuNmI3afkjIp2w2s+vMsZUDR7dge8CuY+KXnayyCVADxHJE5FbgOuAW0RkDda/saPzfQywSUR+ANoAT9T09bSGopQHxpi5YqU6X2K3NZ8ArjfGfCsibwKrge1YHdgOzwBvichE4AuX4zOwmrK+tb8RHgAm+HjtEhH5KfCCiDTCqimcDZwwxqwUkWPAa16e+72INBORpsaY435+zUlAS+B9+3fcbYy5QETaYDWBBS2tuYoMY8w1Xk5VG0psjHkHeKcur6fZhpWqAxF5GOuD/pkwvd4pwEKgp7cVB8VK037cGDOjlq9xJ3DMGDOz1gVVDZI2eSkVI0TkBmAZ8ICf5Wtfxr1vpqaOArPr8HzVQGkNRSmlVFBoDUUppVRQaEBRSikVFBpQlFJKBYUGFKWUUkGhAUUppVRQaEBRSikVFP8Pp5GEBSCmkWoAAAAASUVORK5CYII="",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    },
    {
     ""data"": {
      ""image/png"": ""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"",
      ""text/plain"": [
       ""<Figure size 432x288 with 1 Axes>""
      ]
     },
     ""metadata"": {},
     ""output_type"": ""display_data""
    }
   ],
   ""source"": [
    ""# Disable automatic sweeping\n"",
    ""pna.auto_sweep(False)\n"",
    ""\n"",
    ""# Update the list of traces\n"",
    ""traces = pna.traces\n"",
    ""\n"",
    ""# Run a measurement\n"",
    ""meas = Measurement()\n"",
    ""meas.register_parameter(traces.tr1.magnitude)\n"",
    ""meas.register_parameter(traces.tr2.magnitude)\n"",
    ""meas.register_parameter(traces.tr3.magnitude)\n"",
    ""meas.register_parameter(traces.tr4.magnitude)\n"",
    ""\n"",
    ""with meas.run() as datasaver:\n"",
    ""    traces.tr1.run_sweep() # Ask the PNA to take a measurement\n"",
    ""    data = []\n"",
    ""    for trace in traces:\n"",
    ""        mag = trace.magnitude()\n"",
    ""        data.append((trace.magnitude, mag))\n"",
    ""    datasaver.add_result(*data)\n"",
    ""    dataid = datasaver.run_id\n"",
    ""plot_by_id(dataid)""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 8,
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""# Set the PNA back into continuous sweep mode\n"",
    ""pna.sweep_mode(\""CONT\"")""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": null,
   ""metadata"": {},
   ""outputs"": [],
   ""source"": []
  }
 ],
 ""metadata"": {
  ""kernelspec"": {
   ""display_name"": ""qcodespip310"",
   ""language"": ""python"",
   ""name"": ""python3""
  },
  ""language_info"": {
   ""codemirror_mode"": {
    ""name"": ""ipython"",
    ""version"": 3
   },
   ""file_extension"": "".py"",
   ""mimetype"": ""text/x-python"",
   ""name"": ""python"",
   ""nbconvert_exporter"": ""python"",
   ""pygments_lexer"": ""ipython3"",
   ""version"": ""3.10.8 | packaged by conda-forge | (main, Nov 24 2022, 14:07:00) [MSC v.1916 64 bit (AMD64)]""
  },
  ""nbsphinx"": {
   ""execute"": ""never""
  },
  ""vscode"": {
   ""interpreter"": {
    ""hash"": ""480e2684b5b9c0b152312e183acc2ddad9e1afa91d8000727e55ac37395ea398""
   }
  }
 },
 ""nbformat"": 4,
 ""nbformat_minor"": 2
}
"
318,23.0,"Beijing, China","4 analog channels, Upgradable to 16 digital channels (requires optional RPL1116 logic probe to operate)
Built in 2 channel 25MHz waveform generator
",Rigol DS 1074 Z,459.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DS1074Z Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,Rigol DS1074Z,,"[OrderedDict([('id', 'attPCVdBSDuDWmdDl'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/N0p1bC2xe2lKdifhMT2KdA/uxPLEhc9-DxI2-mmsKaSnKk42O7NCG1jJJNwG6pqStScGNbwJ3Qw9SQpWxYjZV1g7mEAa_uXAX60hW-P-u49JogPOZHa_3s91TwSV7Te-7qxdFXS6TcT2iSM8ErKy4qM/Hy6znmbqi4ncSdITRdUVzku9jN87SyphM5UIGaq8drM'), ('filename', 'ds1074z-plus-front-1200x735-White-b.jpg'), ('size', 134546), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/l9jr9n-36tk7Nd09RqOQ1w/U4t7PMFO8rz7_MhUldLdzOglHCpOnLyn3p6zQMnWLHvJt3oWsIDIompfsdQH2lyOuRJKhHO84UQits9mUHDQ3Q/MLMrP75r5sctqL9HATHLdDRZbhn3lrR9zbyLma0UhI0'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oyffCeh6vXDy4fwR3eGZ-A/cOb7Nz1DCxbF7OtYupM__N7NI3oiyziJpqAP8SEI0jG1RDA1L4hZeTXosChuzMwz4cAhnp48t-qenqAchYePUA/5OknGQurX-uNcj9im4l_KjL0TnNhqXes5CVE7gH9bqI'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0QoSwNwzT4c57-z6yJxFRQ/mWehsVxF3IXmhefMKPBt5ERDbGdDqD7UEp0OE9SJR7Xf0Y0Q6xB-zrh7bkq52kpjVxXsiVFwNqRO108XB_ESNg/7vocKXNkS4Abl0fn4CHKzHZMdkxlLILCdonDfbfbl1c'), ('width', 3000), ('height', 3000)]))]))])]",https://www.batronix.com/shop/oscilloscopes/Rigol-DS1074Z.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DS1074Z.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDS1074Z,,,,,"from typing import Any

import numpy as np

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ParameterWithSetpoints
from qcodes.validators import Arrays, Enum, Numbers


class RigolDS1074ZChannel(InstrumentChannel):
    """"""
    Contains methods and attributes specific to the Rigol
    oscilloscope channels.

    The output trace from each channel of the oscilloscope
    can be obtained using 'trace' parameter.
    """"""

    def __init__(self, parent: ""RigolDS1074Z"", name: str, channel: int):
        super().__init__(parent, name)
        self.channel = channel

        self.add_parameter(
            ""vertical_scale"",
            get_cmd=f"":CHANnel{channel}:SCALe?"",
            set_cmd="":CHANnel{}:SCALe {}"".format(channel, ""{}""),
            get_parser=float,
        )

        self.add_parameter(
            ""trace"",
            get_cmd=self._get_full_trace,
            vals=Arrays(shape=(self.parent.waveform_npoints,)),
            setpoints=(self.parent.time_axis,),
            unit=""V"",
            parameter_class=ParameterWithSetpoints,
            snapshot_value=False,
        )

    def _get_full_trace(self) -> np.ndarray:
        y_ori = self.root_instrument.waveform_yorigin()
        y_increm = self.root_instrument.waveform_yincrem()
        y_ref = self.root_instrument.waveform_yref()
        y_raw = self._get_raw_trace()
        y_raw_shifted = y_raw - y_ori - y_ref
        full_data = np.multiply(y_raw_shifted, y_increm)
        return full_data

    def _get_raw_trace(self) -> np.ndarray:
        # set the out type from oscilloscope channels to WORD
        self.root_instrument.write("":WAVeform:FORMat WORD"")

        # set the channel from where data will be obtained
        self.root_instrument.data_source(f""ch{self.channel}"")

        # Obtain the trace
        raw_trace_val = self.root_instrument.visa_handle.query_binary_values(
            ""WAV:DATA?"", datatype=""h"", is_big_endian=False, expect_termination=False
        )
        return np.array(raw_trace_val)


class RigolDS1074Z(VisaInstrument):
    """"""
    The QCoDeS drivers for Oscilloscope Rigol DS1074Z.

    Args:
        name: name of the instrument.
        address: VISA address of the instrument.
        timeout: Seconds to allow for responses.
        terminator: terminator for SCPI commands.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        terminator: str = ""\n"",
        timeout: float = 5,
        **kwargs: Any,
    ):
        super().__init__(
            name, address, terminator=terminator, timeout=timeout, **kwargs
        )

        self.add_parameter(
            ""waveform_xorigin"", get_cmd=""WAVeform:XORigin?"", unit=""s"", get_parser=float
        )

        self.add_parameter(
            ""waveform_xincrem"",
            get_cmd="":WAVeform:XINCrement?"",
            unit=""s"",
            get_parser=float,
        )

        self.add_parameter(
            ""waveform_npoints"",
            get_cmd=""WAV:POIN?"",
            set_cmd=""WAV:POIN {}"",
            unit=""s"",
            get_parser=int,
        )

        self.add_parameter(
            ""waveform_yorigin"", get_cmd=""WAVeform:YORigin?"", unit=""V"", get_parser=float
        )

        self.add_parameter(
            ""waveform_yincrem"",
            get_cmd="":WAVeform:YINCrement?"",
            unit=""V"",
            get_parser=float,
        )

        self.add_parameter(
            ""waveform_yref"", get_cmd="":WAVeform:YREFerence?"", unit=""V"", get_parser=float
        )

        self.add_parameter(
            ""trigger_mode"",
            get_cmd="":TRIGger:MODE?"",
            set_cmd="":TRIGger:MODE {}"",
            unit=""V"",
            vals=Enum(""edge"", ""pulse"", ""video"", ""pattern""),
            get_parser=str,
        )

        # trigger source
        self.add_parameter(
            ""trigger_level"",
            unit=""V"",
            get_cmd=self._get_trigger_level,
            set_cmd=self._set_trigger_level,
            vals=Numbers(),
        )

        self.add_parameter(
            ""trigger_edge_source"",
            label=""Source channel for the edge trigger"",
            get_cmd="":TRIGger:EDGE:SOURce?"",
            set_cmd="":TRIGger:EDGE:SOURce {}"",
            val_mapping={
                ""ch1"": ""CHAN1"",
                ""ch2"": ""CHAN2"",
                ""ch3"": ""CHAN3"",
                ""ch4"": ""CHAN4"",
            },
        )

        self.add_parameter(
            ""trigger_edge_slope"",
            label=""Slope of the edge trigger"",
            get_cmd="":TRIGger:EDGE:SLOPe?"",
            set_cmd="":TRIGger:EDGE:SLOPe {}"",
            vals=Enum(""positive"", ""negative"", ""neither""),
        )

        self.add_parameter(
            ""data_source"",
            label=""Waveform Data source"",
            get_cmd="":WAVeform:SOURce?"",
            set_cmd="":WAVeform:SOURce {}"",
            val_mapping={
                ""ch1"": ""CHAN1"",
                ""ch2"": ""CHAN2"",
                ""ch3"": ""CHAN3"",
                ""ch4"": ""CHAN4"",
            },
        )

        self.add_parameter(
            ""time_axis"",
            unit=""s"",
            label=""Time"",
            set_cmd=False,
            get_cmd=self._get_time_axis,
            vals=Arrays(shape=(self.waveform_npoints,)),
            snapshot_value=False,
        )

        channels = ChannelList(
            self, ""channels"", RigolDS1074ZChannel, snapshotable=False
        )

        for channel_number in range(1, 5):
            channel = RigolDS1074ZChannel(self, f""ch{channel_number}"", channel_number)
            channels.append(channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())

        self.connect_message()

    def _get_time_axis(self) -> np.ndarray:
        xorigin = self.waveform_xorigin()
        xincrem = self.waveform_xincrem()
        npts = self.waveform_npoints()
        xdata = np.linspace(xorigin, npts * xincrem + xorigin, npts)
        return xdata

    def _get_trigger_level(self) -> str:
        trigger_level = self.root_instrument.ask(
            f"":TRIGger:{self.trigger_mode()}:LEVel?""
        )
        return trigger_level

    def _set_trigger_level(self, value: str) -> None:
        self.root_instrument.write(f"":TRIGger:{self.trigger_mode()}:LEVel {value}"")
"
319,9000.0,UK,"Bench/System Precision Linear Regulated DC Power Supply 35V/3A or 15V/5A, USB/RS232/GPIB/LAN
",AIMTTI QL 355 TP,45.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a QL335P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-qlseries,['Power Supplies'],"Bench/System Precision Linear Regulated DC Power Supply with digital control, single or triple Outputs, 105 to 242 watts, with/without Remote Interfaces",QL335P,https://resources.aimtti.com/datasheets/AIM-QL_series_II_DC_power_supplies_data_sheet-Iss3.pdf,"[OrderedDict([('id', 'attYuTwh3uVeGqHgQ'), ('width', 330), ('height', 226), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gSxkSQOXZf6A-qDUuNGjaA/SDVtQc0FD5IsTh6gGJgZ4tzPUt1upitozugmK85hVBOdNgXjE4dZOl_eIUGY96PpZauAW8_xJcnKt0icqDlVkPjQJWMJC2D8AfNkR5O7kCk/qCCysDz5n2Uq3Hgy8hT54Qx-rv4E9-jAfV9sQ1r4cd8'), ('filename', 'AIM-QL355TP.jpeg'), ('size', 42776), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QDDO5vCcTedpj9vxifFpaw/mlxFQqJaXPrlCcl8axbEFnaIwrP3LGh_iRnoo6plw8lxFIhuYk1yP19PWdvKxMmyVtvOgJBYAD6L60dFm4cc2Q/D6RSjjMAHvkyrW_dxQ_7Y2Q6JF9dLc-CdcwO2OCRtL0'), ('width', 53), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/MVUtd0jXSwCVXIAvYMNV7g/im2IzVOAIEXG1osZx69QThqx5Ji5vqr37IgSf-IVOepT8mHsjdq7OS1Vm63aVisP5LBDhJHeUJWjijRMGVJrxg/Ty0m4_uhbJfutk3VHwlH38GxZWEW06WxeGyWVHJ7U08'), ('width', 330), ('height', 226)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NCGE7DrV_HRAbWZUnMGxZA/Uw29EgJMBd3Ae3sPWhjWOCWe5qNQEC3BZUhcru3wVGy1aQ2K8JeVQb3mYp7xv7Sn9krOH0yHKsU_6pA8utE9eA/8cON5TRwC6C5uhj6YMlKUSw3QnKNcjyIOvZkAFo-kQE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-qlseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,900.0,"
",,,
327,5420.0,USA,"The N6705B is a 4-slot mainframe that accepts up to 4 DC Power Modules, and up to 600 W total DC Power Module output power. The modules are ordered separately. 

N6705B accepts the same modules as N6700 Modular Power System, with over 30 modules to choose from",Keysightn 6705b,279.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,"Write a Python script that uses Qcodes to connect to a KEYSIGHT N6705B Power Supplies, Multimeters, Oscilloscopes, RF Signal Generator",https://en.wikipedia.org/wiki/Electrometer,"['Power Supplies', 'Multimeters', 'Oscilloscopes', 'RF Signal Generator']","An electrometer is an electrical instrument for measuring electric charge or electrical potential difference.[1] There are many different types, ranging from historical handmade mechanical instruments to high-precision electronic devices. Modern electrometers based on vacuum tube or solid-state technology can be used to make voltage and charge measurements with very low leakage currents, down to 1 femtoampere. A simpler but related instrument, the electroscope, works on similar principles but only indicates the relative magnitudes of voltages or charges.",KEYSIGHT N6705B,https://www.keysight.com/us/en/assets/7018-01522/data-sheets/5989-6319.pdf,"[OrderedDict([('id', 'atti5naQVvdQNiY7q'), ('width', 300), ('height', 134), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6ZhcMqDMJb4yIWSMYMbQJA/8G99LgNXP_3g3l2hWSfHJQlQ0OxB8QuAMNzQ-jpvZpu2Vh8PN_kaH4ZaBKLRzODS5d4X0ysW7dNvJ1hsXNeQEaTX4EkmsPbw8vRNnnC0czA/hsboko_vBq4C41W3oNgZVxizp0FZxDhzpUxXbsEHH94'), ('filename', 'PROD-1842303-6_0.png'), ('size', 10166), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oIQYVYK94s1JRROlaCCRpQ/wfrvMpBClSCTWhB45y-6q0GQ_FDyFV9QFE89GAteYi_533Bh31MJE20D-DSqTUrv4uRtPC_wykhugSBrTtmvJQ/RWlT9_0aUPzlS60wgxuj-SYO6LnVoOCtPKzsKvYhwFY'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KXCtoddGp4hmVdWNoaNI8w/_iegTwN-H5eE0dPjDKQG9EcRfsQdi9v6zB5TWLQwWspA2i0qNn1TQOUssZKxDt3WNUXh3i06BxNJUIyx8PsEbA/YiJzpU4fEg4G0HmlsUY6ziA1dgAQjkEZvxAepgsyoUE'), ('width', 300), ('height', 134)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/PE5WCrSCjb-xqy1DbBDNSQ/Dy_tGIdhu54VJ_iRBX5ukbxvOEIpQ2zSkdcISNbm8LHAPXMRCsK9bQYphZ9VP7mLNQgc-1sTfIMjuxjto4pMfQ/FFEzMEo_WT4DeV5_IhNXVWGbbWl2DHZxbS0Xr_0rPec'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/N6705B/dc-power-analyzer-modular-600-w-4-slots.html#:~:text=The%20N6705B%20is%20a%204,30%20modules%20to%20choose%20from.",https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/Keysight_N6705B.py,https://qcodes.github.io/Qcodes/drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN6705B,,,True,,"from typing import Any

from qcodes import VisaInstrument
from qcodes import Instrument
from qcodes.instrument.channel import InstrumentChannel
from typing import List, Dict, Optional


class N6705BChannel(InstrumentChannel):
    def __init__(self, parent: Instrument, name: str, chan: int) -> None:
        if chan not in [1, 2, 3, 4]:
            raise ValueError('Invalid channel specified')

        super().__init__(parent, name)

        self.add_parameter('source_voltage',
                           label=f""Channel {chan} Voltage"",
                           get_cmd=f'SOURCE:VOLT? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOURCE:VOLT {{:.8G}}, (@{chan})',
                           unit='V')

        self.add_parameter('source_current',
                           label=f""Channel {chan} Current"",
                           get_cmd=f'SOURCE:CURR? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOURCE:CURR {{:.8G}}, (@{chan})',
                           unit='A')

        self.add_parameter('voltage_limit',
                           get_cmd=f'SOUR:VOLT:PROT? (@{chan})',
                           get_parser=float,
                           set_cmd=f'SOUR:VOLT:PROT {{:.8G}}, @({chan})',
                           label=f'Channel {chan} Voltage Limit',
                           unit='V')

        self.add_parameter('voltage',
                           get_cmd=f'MEAS:VOLT? (@{chan})',
                           get_parser=float,
                           label=f'Channel {chan} Voltage',
                           unit='V')

        self.add_parameter('current',
                           get_cmd=f'MEAS:CURR? (@{chan})',
                           get_parser=float,
                           label=f'Channel {chan} Current',
                           unit='A')

        self.add_parameter('enable',
                           get_cmd=f'OUTP:STAT? (@{chan})',
                           set_cmd=f'OUTP:STAT {{:d}}, (@{chan})',
                           val_mapping={'on':  1, 'off': 0})

        self.add_parameter('source_mode',
                           get_cmd=f':OUTP:PMOD? (@{chan})',
                           set_cmd=f':OUTP:PMOD {{:s}}, (@{chan})',
                           val_mapping={'current': 'CURR', 'voltage': 'VOLT'})

        self.channel = chan
        self.ch_name = name


class N6705B(VisaInstrument):
    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)
        self.channels:  List[N6705BChannel] = []
        for ch_num in [1, 2, 3, 4]:
            ch_name = f""ch{ch_num}""
            channel = N6705BChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            self.channels.append(channel)

        self.connect_message()

    def get_idn(self) -> Dict[str, Optional[str]]:
        IDNstr = self.ask_raw('*IDN?')
        vendor, model, serial, firmware = map(str.strip, IDNstr.split(','))
        IDN: Dict[str, Optional[str]] = {'vendor': vendor, 'model': model,
                                         'serial': serial, 'firmware': firmware}
        return IDN
"
330,5800.0,USA,"Bandwidths up to 3.5 GHz and sampling rates up to 40 GS/s make the DPO7000C Series a natural choice for analyzing critical, high-speed signals. Over 30 analysis packages provide in-depth measurements for communications standards, jitter analysis, memory bus standards, vector analysis and more. Plus, the Windows operating system lets you run your own analysis software right on the instruments.",Tektronix DPO 7000,571.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a DPO7000 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",DPO7000,https://download.tek.com/datasheet/DPO7000C-Oscilloscope-Datasheet-48W2654321.pdf,"[OrderedDict([('id', 'attwmBix2AQZwu6pL'), ('width', 500), ('height', 375), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/T4_2uUnQ5MTbz6GWRdw3Mg/EZcD_ufE84F9hhS93_29n7V2-cSHSDXCetS2ov5x6OkN5aGWgYSkIOzgQcnN_aQi7kqEta_vhW_JmOIPP1yzvVusORMsPNE4fa_q-N4VzxA/I88oX7kQu9i22OfxyOHEioFQgWlvHZRnCtE97P6Dghw'), ('filename', 'DPO7000C-Series-1.jpg'), ('size', 37983), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/b17xqDAbdg7da6nI-vmEpA/Ojs6MzC211iN9QyqYEIe4Lru-TrIqaWr4DjQVUF3gXydrvt3yP-oJ3BxsyeDYly9BJvznVAEImxLwaRlghmI5w/M6z06mdUrN2USj6xemqI2ZiREOYQ_cmlTPLKowC3sFc'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NoLel9-DjCnSwYitApc09A/K_z9BYvl--xCyZxGJzi9tlr1WBobF62JS-PEGbjj0HJgSZ-__ynA9T7anRwZnUvWb7SdmupRh-a7_DB7Jl60GA/xgOHK_ZsKz8bJwI6i75iTu5U-b16MwKrLy0DSO9MDus'), ('width', 500), ('height', 375)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0W5ka7k8v5PI6JncmvdzhA/vpARxq3Os-WRh7bhAUrJe3LILyOS5dOlV63j5ZYYGSzcG3DmCVNXhvvFICPLfJ6pHzbgiGgfxRicfyZRLMiGpA/eY2Dm2-Sn4ehv7SbFuHFZ6_tNC4d0zjzqbp-qw1bqLo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/oscilloscopes/dpo7000-digital-phosphor-oscilloscope,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/DPO7200xx.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixDPO7000,,,True,,"""""""
QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
MSO70000/C/DX Series Digital Oscilloscopes
""""""
import textwrap
import time
from functools import partial
from typing import Any, Callable, Union, cast

import numpy as np

from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    Parameter,
    ParameterWithSetpoints,
    create_on_off_val_mapping,
)
from qcodes.validators import Arrays, Enum


def strip_quotes(string: str) -> str:
    """"""
    This function is used as a get_parser for various
    parameters in this driver
    """"""
    return string.strip('""')


class TektronixDPOModeError(Exception):
    """"""
    Raise this exception if we are in a wrong mode to
    perform an action
    """"""
    pass


ModeError = TektronixDPOModeError
""""""
Alias for backwards compatibility
""""""


class TektronixDPO7000xx(VisaInstrument):
    """"""
    QCoDeS driver for the MSO/DPO5000/B, DPO7000/C,
    DPO70000/B/C/D/DX/SX, DSA70000/B/C/D, and
    MSO70000/C/DX Series Digital Oscilloscopes
    """"""
    number_of_channels = 4
    number_of_measurements = 8  # The number of available
    # measurements does not change.

    def __init__(
            self,
            name: str,
            address: str,
            **kwargs: Any
    ) -> None:

        super().__init__(name, address, terminator=""\n"", **kwargs)

        self.add_submodule(
            ""horizontal"",
            TektronixDPOHorizontal(self, ""horizontal"")
        )

        self.add_submodule(
            ""data"",
            TektronixDPOData(self, ""data"")
        )

        self.add_submodule(
            ""waveform"",
            TektronixDPOWaveformFormat(
                self, ""waveform""
            )
        )

        measurement_list = ChannelList(
            self, ""measurement"", TektronixDPOMeasurement
        )
        for measurement_number in range(1, self.number_of_measurements):

            measurement_name = f""measurement{measurement_number}""
            measurement_module = TektronixDPOMeasurement(
                self,
                measurement_name,
                measurement_number
            )

            self.add_submodule(measurement_name, measurement_module)
            measurement_list.append(measurement_module)

        self.add_submodule(""measurement"", measurement_list)
        self.add_submodule(
            ""statistics"",
            TektronixDPOMeasurementStatistics(
                self, ""statistics""
            )
        )

        channel_list = ChannelList(self, ""channel"", TektronixDPOChannel)
        for channel_number in range(1, self.number_of_channels + 1):

            channel_name = f""channel{channel_number}""
            channel_module = TektronixDPOChannel(
                self,
                channel_name,
                channel_number,
            )

            self.add_submodule(channel_name, channel_module)
            channel_list.append(channel_module)

        self.add_submodule(""channel"", channel_list)

        self.add_submodule(
            ""trigger"",
            TekronixDPOTrigger(self, ""trigger"")
        )

        self.add_submodule(
            ""delayed_trigger"",
            TekronixDPOTrigger(self, ""delayed_trigger"", delayed_trigger=True)
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response


class TektronixDPOData(InstrumentChannel):
    """"""
    This submodule sets and retrieves information regarding the
    data source for the ""CURVE?"" query, which is used when
    retrieving waveform data.
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)
        # We can choose to retrieve data from arbitrary
        # start and stop indices of the buffer.
        self.add_parameter(
            ""start_index"",
            get_cmd=""DATa:STARt?"",
            set_cmd=""DATa:STARt {}"",
            get_parser=int
        )

        self.add_parameter(
            ""stop_index"",
            get_cmd=""DATa:STOP?"",
            set_cmd=""DATa:STOP {}"",
            get_parser=int
        )

        self.add_parameter(
            ""source"",
            get_cmd=""DATa:SOU?"",
            set_cmd=""DATa:SOU {}"",
            vals=Enum(*TekronixDPOWaveform.valid_identifiers)
        )

        self.add_parameter(
            ""encoding"",
            get_cmd=""DATa:ENCdg?"",
            set_cmd=""DATa:ENCdg {}"",
            get_parser=strip_quotes,
            vals=Enum(
                ""ASCIi"",
                ""FAStest"",
                ""RIBinary"",
                ""RPBinary"",
                ""FPBinary"",
                ""SRIbinary"",
                ""SRPbinary"",
                ""SFPbinary"",
            ),
            docstring=textwrap.dedent(""""""
            For a detailed explanation of the
            set arguments, please consult the
            programmers manual at page 263/264.

            http://download.tek.com/manual/077001022.pdf
            """""")
        )


class TekronixDPOWaveform(InstrumentChannel):
    """"""
    This submodule retrieves data from waveform sources, e.g.
    channels.
    """"""
    valid_identifiers = [
        f""{source_type}{i}""
        for source_type in [""CH"", ""MATH"", ""REF""]
        for i in range(1, TektronixDPO7000xx.number_of_channels + 1)
    ]

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            identifier: str,
    ) -> None:

        super().__init__(parent, name)

        if identifier not in self.valid_identifiers:
            raise ValueError(
                f""Identifier {identifier} must be one of ""
                f""{self.valid_identifiers}""
            )

        self._identifier = identifier

        self.add_parameter(
            ""raw_data_offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YOFF?""),
            get_parser=float,
            docstring=textwrap.dedent(""""""
                Raw acquisition values range from min to max.
                For instance, for unsigned binary values of one
                byte, min=0 and max=255. The data offset specifies
                the center of this range
                """""")
        )

        self.add_parameter(
            ""x_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:XUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""x_increment"",
            get_cmd=self._get_cmd(""WFMOutPRE:XINCR?""),
            unit=self.x_unit(),
            get_parser=float
        )

        self.add_parameter(
            ""y_unit"",
            get_cmd=self._get_cmd(""WFMOutpre:YUNit?""),
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""offset"",
            get_cmd=self._get_cmd(""WFMOutPRE:YZERO?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""scale"",
            get_cmd=self._get_cmd(""WFMOutPRE:YMULT?""),
            get_parser=float,
            unit=self.y_unit()
        )

        self.add_parameter(
            ""length"",
            get_cmd=self._get_cmd(""WFMOutpre:NR_Pt?""),
            get_parser=int
        )

        hor_unit = self.x_unit()
        hor_label = ""Time"" if hor_unit == ""s"" else ""Frequency""

        self.add_parameter(
            ""trace_axis"",
            label=hor_label,
            get_cmd=self._get_trace_setpoints,
            vals=Arrays(shape=(self.length,)),
            unit=hor_unit
        )

        ver_unit = self.y_unit()
        ver_label = ""Voltage"" if ver_unit == ""s"" else ""Amplitude""

        self.add_parameter(
            ""trace"",
            label=ver_label,
            get_cmd=self._get_trace_data,
            vals=Arrays(shape=(self.length,)),
            unit=ver_unit,
            setpoints=(self.trace_axis,),
            parameter_class=ParameterWithSetpoints
        )

    def _get_cmd(self, cmd_string: str) -> Callable[[], str]:
        """"""
        Parameters defined in this submodule require the correct
        data source being selected first.
        """"""
        def inner() -> str:
            self.root_instrument.data.source(self._identifier)
            return self.ask(cmd_string)

        return inner

    def _get_trace_data(self) -> np.ndarray:

        self.root_instrument.data.source(self._identifier)
        waveform = self.root_instrument.waveform

        if not waveform.is_binary():
            raw_data = self.root_instrument.visa_handle.query_ascii_values(
                ""CURVE?"",
                container=np.array
            )
        else:
            bytes_per_sample = waveform.bytes_per_sample()
            data_type = {1: ""b"", 2: ""h"", 4: ""f"", 8: ""d""}[
                bytes_per_sample
            ]

            if waveform.data_format() == ""unsigned_integer"":
                data_type = data_type.upper()

            is_big_endian = waveform.is_big_endian()

            raw_data = self.root_instrument.visa_handle.query_binary_values(
                ""CURVE?"",
                datatype=data_type,
                is_big_endian=is_big_endian,
                container=np.array
            )

        return (raw_data - self.raw_data_offset()) * self.scale() \
            + self.offset()

    def _get_trace_setpoints(self) -> np.ndarray:
        """"""
        Infer the set points of the waveform
        """"""
        sample_count = self.length()
        x_increment = self.x_increment()
        return np.linspace(0, x_increment * sample_count, sample_count)


class TektronixDPOWaveformFormat(InstrumentChannel):
    """"""
    With this sub module we can query waveform
    formatting data. Please note that parameters
    defined in this submodule effects all
    waveform sources, whereas parameters defined in the
    submodule 'TekronixDPOWaveform' apply to
    specific waveform sources (e.g. channel1 or math2)
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""data_format"",
            get_cmd=""WFMOutpre:BN_Fmt?"",
            set_cmd=""WFMOutpre:BN_Fmt {}"",
            val_mapping={
                ""signed_integer"": ""RI"",
                ""unsigned_integer"": ""RP"",
                ""floating_point"": ""FP""
            }
        )

        self.add_parameter(
            ""is_big_endian"",
            get_cmd=""WFMOutpre:BYT_Or?"",
            set_cmd=""WFMOutpre:BYT_Or {}"",
            val_mapping={
                False: ""LSB"",
                True: ""MSB""
            }
        )

        self.add_parameter(
            ""bytes_per_sample"",
            get_cmd=""WFMOutpre:BYT_Nr?"",
            set_cmd=""WFMOutpre:BYT_Nr {}"",
            get_parser=int,
            vals=Enum(1, 2, 4, 8)
        )

        self.add_parameter(
            ""is_binary"",
            get_cmd=""WFMOutpre:ENCdg?"",
            set_cmd=""WFMOutpre:ENCdg {}"",
            val_mapping={
                True: ""BINARY"",
                False: ""ASCII""
            }
        )


class TektronixDPOChannel(InstrumentChannel):
    """"""
    The main channel module for the oscilloscope. The parameters
    defined here reflect the waveforms as they are displayed on
    the instrument display.
    """"""
    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str,
            channel_number: int,
    ) -> None:

        super().__init__(parent, name)
        self._identifier = f""CH{channel_number}""

        self.add_submodule(
            ""waveform"",
            TekronixDPOWaveform(
                self, ""waveform"", self._identifier
            )
        )

        self.add_parameter(
            ""scale"",
            get_cmd=f""{self._identifier}:SCA?"",
            set_cmd=f""{self._identifier}:SCA {{}}"",
            get_parser=float,
            unit=""V/div""
        )

        self.add_parameter(
            ""offset"",
            get_cmd=f""{self._identifier}:OFFS?"",
            set_cmd=f""{self._identifier}:OFFS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""position"",
            get_cmd=f""{self._identifier}:POS?"",
            set_cmd=f""{self._identifier}:POS {{}}"",
            get_parser=float,
            unit=""V""
        )

        self.add_parameter(
            ""termination"",
            get_cmd=f""{self._identifier}:TER?"",
            set_cmd=f""{self._identifier}:TER {{}}"",
            vals=Enum(50, 1E6),
            get_parser=float,
            unit=""Ohm""
        )

        self.add_parameter(
            ""analog_to_digital_threshold"",
            get_cmd=f""{self._identifier}:THRESH?"",
            set_cmd=f""{self._identifier}:THRESH {{}}"",
            get_parser=float,
            unit=""V"",
        )

        self.add_parameter(
            ""termination_voltage"",
            get_cmd=f""{self._identifier}:VTERm:BIAS?"",
            set_cmd=f""{self._identifier}:VTERm:BIAS {{}}"",
            get_parser=float,
            unit=""V""
        )

    def set_trace_length(self, value: int) -> None:
        """"""
        Set the trace length when retrieving data
        through the 'waveform' interface

        Args:
            value: The requested number of samples in the trace
        """"""
        if self.root_instrument.horizontal.record_length() < value:
            raise ValueError(
                ""Cannot set a trace length which is larger than ""
                ""the record length. Please switch to manual mode ""
                ""and adjust the record length first""
            )

        self.root_instrument.data.start_index(1)
        self.root_instrument.data.stop_index(value)

    def set_trace_time(self, value: float) -> None:
        """"""
        Args:
            value: The time over which a trace is desired.
        """"""
        sample_rate = self.root_instrument.horizontal.sample_rate()
        required_sample_count = int(sample_rate * value)
        self.set_trace_length(required_sample_count)


class TektronixDPOHorizontal(InstrumentChannel):
    """"""
    This module controls the horizontal axis of the scope
    """"""

    def __init__(
            self,
            parent: Union[Instrument, InstrumentChannel],
            name: str
    ) -> None:

        super().__init__(parent, name)

        self.add_parameter(
            ""mode"",
            get_cmd=""HORizontal:MODE?"",
            set_cmd=""HORizontal:MODE {}"",
            vals=Enum(""auto"", ""constant"", ""manual""),
            get_parser=str.lower,
            docstring=""""""
            Auto mode attempts to keep record length
            constant as you change the time per division
            setting. Record length is read only.

            Constant mode attempts to keep sample rate
            constant as you change the time per division
            setting. Record length is read only.

            Manual mode lets you change sample mode and
            record length. Time per division or Horizontal
            scale is read only.
            """"""
        )

        self.add_parameter(
            ""unit"",
            get_cmd=""HORizontal:MAIn:UNIts?"",
            get_parser=strip_quotes
        )

        self.add_parameter(
            ""record_length"",
            get_cmd=""HORizontal:MODE:RECOrdlength?"",
            set_cmd=self._set_record_length,
            get_parser=float
        )

        self.add_parameter(
            ""sample_rate"",
            get_cmd=""HORizontal:MODE:SAMPLERate?"",
            set_cmd=""HORizontal:MODE:SAMPLERate {}"",
            get_parser=float,
            unit=f""sample/{self.unit()}""
        )

        self.add_parameter(
            ""scale"",
            get_cmd=""HORizontal:MODE:SCAle?"",
            set_cmd=self._set_scale,
            get_parser=float,
            unit=f""{self.unit()}/div""
        )

        self.add_parameter(
            ""position"",
            get_cmd=""HORizontal:POSition?"",
            set_cmd=""HORizontal:POSition {}"",
            get_parser=float,
            unit=""%"",
            docstring=textwrap.dedent(""""""
            The horizontal position relative to a
            received trigger. E.g. a value of '10'
            sets the trigger position of the waveform
            such that 10% of the display is to the
            left of the trigger position.
            """""")
        )

        self.add_parameter(
            ""roll"",
            get_cmd=""HORizontal:ROLL?"",
            set_cmd=""HORizontal:ROLL {}"",
            vals=Enum(""Auto"", ""On"", ""Off""),
            docstring=textwrap.dedent(""""""
            Use Roll Mode when you want to view data at
            very slow sweep speeds.
            """""")
        )

    def _set_record_length(self, value: int) -> None:
        if self.mode() != ""manual"":
            raise TektronixDPOModeError(
                ""The record length can only be changed in manual mode""
            )

        self.write(f""HORizontal:MODE:RECOrdlength {value}"")

    def _set_scale(self, value: float) -> None:
        if self.mode() == ""manual"":
            raise TektronixDPOModeError(""The scale cannot be changed in manual mode"")

        self.write(f""HORizontal:MODE:SCAle {value}"")


class TekronixDPOTrigger(InstrumentChannel):
    """"""
    Submodule for trigger setup.

    You can trigger with the A (Main) trigger system alone
    or combine the A (Main) trigger with the B (Delayed) trigger
    to trigger on sequential events. When using sequential
    triggering, the A trigger event arms the trigger system, and
    the B trigger event triggers the instrument when the B
    trigger conditions are met.

    A and B triggers can (and typically do) have separate sources.
    The B trigger condition is based on a time delay or a specified
    number of events.

    See page75, Using A (Main) and B (Delayed) triggers.
    https://download.tek.com/manual/MSO70000C-DX-DPO70000C-DX-MSO-DPO7000C-MSO-DPO5000B-Oscilloscope-Quick-Start-User-Manual-071298006.pdf
    """"""
    def __init__(
            self,
            parent: Instrument,
            name: str,
            delayed_trigger: bool = False
    ):
        super().__init__(parent, name)
        self._identifier = ""B"" if delayed_trigger else ""A""

        trigger_types = [""edge"", ""logic"", ""pulse""]
        if self._identifier == ""A"":
            trigger_types.extend([
                ""video"", ""i2c"", ""can"", ""spi"", ""communication"", ""serial"", ""rs232""
            ])

        self.add_parameter(
            ""type"",
            get_cmd=f""TRIGger:{self._identifier}:TYPE?"",
            set_cmd=self._trigger_type,
            vals=Enum(*trigger_types),
            get_parser=str.lower
        )

        edge_couplings = [""ac"", ""dc"", ""hfrej"", ""lfrej"", ""noiserej""]
        if self._identifier == ""B"":
            edge_couplings.append(""atrigger"")

        self.add_parameter(
            ""edge_coupling"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:COUPling {{}}"",
            vals=Enum(*edge_couplings),
            get_parser=str.lower
        )

        self.add_parameter(
            ""edge_slope"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SLOpe {{}}"",
            vals=Enum(""rise"", ""fall"", ""either""),
            get_parser=str.lower
        )

        trigger_sources = [
            f""CH{i}"" for i in range(1, TektronixDPO7000xx.number_of_channels)
        ]

        trigger_sources.extend([
            f""D{i}"" for i in range(0, 16)
        ])

        if self._identifier == ""A"":
            trigger_sources.append(""line"")

        self.add_parameter(
            ""source"",
            get_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce?"",
            set_cmd=f""TRIGger:{self._identifier}:EDGE:SOUrce {{}}"",
            vals=Enum(*trigger_sources)
        )

    def _trigger_type(self, value: str) -> None:
        if value != ""edge"":
            raise NotImplementedError(
                ""We currently only support the 'edge' trigger type""
            )
        self.write(f""TRIGger:{self._identifier}:TYPE {value}"")


class TektronixDPOMeasurementParameter(Parameter):
    """"""
    A measurement parameter does not only return the instantaneous value
    of a measurement, but can also return some statistics. The accumulation
    time over which these statistics are gathered can be controlled through
    the 'time_constant' parameter on the submodule
    'TektronixDPOMeasurementStatistics'. Here we also find the method 'reset'
    to reset the values over which the statistics are gathered.
    """"""
    # pylint: disable=method-hidden
    def _get(self, metric: str) -> float:

        measurement_channel = cast(TektronixDPOMeasurement, self.instrument)
        if measurement_channel.type.get_latest() != self.name:
            measurement_channel.type(self.name)

        measurement_channel.state(1)
        measurement_channel.wait_adjustment_time()
        measurement_number = measurement_channel.measurement_number

        str_value = measurement_channel.ask(
            f""MEASUrement:MEAS{measurement_number}:{metric}?""
        )

        return float(str_value)

    def mean(self) -> float:
        return self._get(""MEAN"")

    def max(self) -> float:
        return self._get(""MAX"")

    def min(self) -> float:
        return self._get(""MINI"")

    def stdev(self) -> float:
        return self._get(""STDdev"")

    def get_raw(self) -> float:
        return self._get(""VALue"")

    def set_raw(self, value: Any) -> None:
        raise ValueError(""A measurement cannot be set"")


class TektronixDPOMeasurement(InstrumentChannel):
    """"""
    The measurement submodule
    """"""
    # It was found by trial and error that adjusting
    # the measurement type and source takes some time
    # to reflect properly on the value of the
    # measurement. Wait a minimum of ...
    _minimum_adjustment_time = 0.1
    # seconds after setting measurement type/source before
    # calling the measurement value SCPI command.

    measurements = [
        ('amplitude', 'V'), ('area', 'Vs'), ('burst', 's'), ('carea', 'Vs'),
        ('cmean', 'V'), ('crms', 'V'), ('delay', 's'), ('distduty', '%'),
        ('extinctdb', 'dB'), ('extinctpct', '%'), ('extinctratio', ''),
        ('eyeheight', 'V'), ('eyewidth', 's'), ('fall', 's'),
        ('frequency', 'Hz'), ('high', 'V'), ('hits', 'hits'), ('low', 'V'),
        ('maximum', 'V'), ('mean', 'V'), ('median', 'V'), ('minimum', 'V'),
        ('ncross', 's'), ('nduty', '%'), ('novershoot', '%'), ('nwidth', 's'),
        ('pbase', 'V'), ('pcross', 's'), ('pctcross', '%'), ('pduty', '%'),
        ('peakhits', 'hits'), ('period', 's'), ('phase', '°'), ('pk2pk', 'V'),
        ('pkpkjitter', 's'), ('pkpknoise', 'V'), ('povershoot', '%'),
        ('ptop', 'V'), ('pwidth', 's'), ('qfactor', ''), ('rise', 's'),
        ('rms', 'V'), ('rmsjitter', 's'), ('rmsnoise', 'V'), ('sigma1', '%'),
        ('sigma2', '%'), ('sigma3', '%'), ('sixsigmajit', 's'), ('snratio', ''),
        ('stddev', 'V'), ('undefined', ''), ('waveforms', 'wfms')
    ]

    def __init__(
            self,
            parent: Instrument,
            name: str,
            measurement_number: int
    ) -> None:

        super().__init__(parent, name)
        self._measurement_number = measurement_number
        self._adjustment_time = time.perf_counter()

        self.add_parameter(
            ""state"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe?"",
            set_cmd=f""MEASUrement:MEAS{self._measurement_number}:STATe {{}}"",
            val_mapping=create_on_off_val_mapping(on_val=""1"", off_val=""0"")
        )

        self.add_parameter(
            ""type"",
            get_cmd=f""MEASUrement:MEAS{self._measurement_number}:TYPe?"",
            set_cmd=self._set_measurement_type,
            get_parser=str.lower,
            vals=Enum(*(m[0] for m in self.measurements)),
            docstring=textwrap.dedent(
                ""Please see page 566-569 of the programmers manual ""
                ""for a detailed description of these arguments. ""
                ""http://download.tek.com/manual/077001022.pdf""
            )
        )

        for measurement, unit in self.measurements:
            self.add_parameter(
                name=measurement,
                unit=unit,
                parameter_class=TektronixDPOMeasurementParameter
            )

        for src in [1, 2]:
            self.add_parameter(
                f""source{src}"",
                get_cmd=f""MEASUrement:MEAS{self._measurement_number}:SOUrce""
                        f""{src}?"",
                set_cmd=partial(self._set_source, src),
                vals=Enum(
                    *(TekronixDPOWaveform.valid_identifiers + [""HISTogram""])
                )
            )

    @property
    def measurement_number(self) -> int:
        return self._measurement_number

    def _set_measurement_type(self, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:TYPe {value}""
        )

    def _set_source(self, source_number: int, value: str) -> None:
        self._adjustment_time = time.perf_counter()
        self.write(
            f""MEASUrement:MEAS{self._measurement_number}:SOUrce{source_number} ""
            f""{value}""
        )

    def wait_adjustment_time(self) -> None:
        """"""
        Wait until the minimum time after adjusting the measurement source or
        type has elapsed
        """"""
        time_since_adjust = time.perf_counter() - self._adjustment_time
        if time_since_adjust < self._minimum_adjustment_time:
            time_remaining = self._minimum_adjustment_time - time_since_adjust
            time.sleep(time_remaining)


class TektronixDPOMeasurementStatistics(InstrumentChannel):
    def __init__(self, *args: Any, **kwargs: Any):
        super().__init__(*args, **kwargs)

        self.add_parameter(
            ""mode"",
            get_cmd=""MEASUrement:STATIstics:MODe?"",
            set_cmd=""MEASUrement:STATIstics:MODe {}"",
            vals=Enum(
                ""OFF"", ""ALL"", ""VALUEMean"", ""MINMax"",
                ""MEANSTDdev""
            ),
            docstring=textwrap.dedent(
                ""This command controls the operation and display of measurement ""
                ""statistics. ""
                ""1. OFF turns off all measurements. This is the default value ""
                ""2. ALL turns on statistics and displays all statistics for ""
                ""each measurement. ""
                ""3. VALUEMean turns on statistics and displays the value and the ""
                ""mean (μ) of each measurement. ""
                ""4. MINMax turns on statistics and displays the min and max of ""
                ""each measurement. ""
                ""5. MEANSTDdev turns on statistics and displays the mean and ""
                ""standard deviation of each measurement.""
            )
        )

        self.add_parameter(
            ""time_constant"",
            get_cmd=""MEASUrement:STATIstics:WEIghting?"",
            set_cmd=""MEASUrement:STATIstics:WEIghting {}"",
            get_parser=int,
            docstring=textwrap.dedent(
                ""This command sets or queries the time constant for mean and ""
                ""standard deviation statistical accumulations, which is equivalent ""
                ""to selecting Measurement Setup from the Measure menu, clicking ""
                ""the Statistics button and entering the desired Weight n= value.""
            )
        )

    def reset(self) -> None:
        self.write(""MEASUrement:STATIstics:COUNt RESEt"")
"
331,5420.0,USA,"The Keysight 33622A function/arbitrary waveform generators offer the standard signals and features you expect, such as modulation, sweep, and burst. However, it also provides features that give you the capabilities and flexibility you need to get your job done quickly, no matter how complex. An intuitive front-panel user interface, for example, can be quickly and easily relearned when your attention has been focused elsewhere.",Keysight 33622A,289.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 33622A Function Generators,https://en.wikipedia.org/wiki/Function_generator#Function_generator,['Function Generators'],"A function generator is electronic test equipment that generates standard waveforms, such as sine, square, ramp, or sawtooth waves, to a device under test (DUT).",KEYSIGHT 33622A,https://www.keysight.com/us/en/assets/7018-05928/data-sheets/5992-2572.pdf,"[OrderedDict([('id', 'attChmw20anhGegZx'), ('width', 1492), ('height', 770), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vj8uuPdt8ue8qCTYkX50HA/whqRM8M4UD67I97PDHQMUt_KWFoiMekgrnEp-NqlIz4prHJhRI-wf0-rZ_W2jHGB0IpHy8jk00z3ht86uZZAnEXT-b4ZueVHpW2c8MtAmFY/yk1yA9VqoRObirTpd1MMSDIS-hxDko_d4zDyjGT--Qs'), ('filename', '29X7419-40.jpg'), ('size', 120092), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/x58WchqynRwkkRBjpdL8UQ/N-jyedvITomaYzrW3WTQass7HjLJh6dwPQ_Ceyle76Xd9g9L56k_WxnPZPAVJZ9UAfvlm21t38Y-LlvowPIUmQ/GloC4O9ki237BFvyu7oQIICV8NipD8gaEM-3X13Reis'), ('width', 70), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gnGL91qyijhARSY9mQPyqQ/yQldqsrKWfznOLv3saNiCd2rWspVn0N-oHDIMqOFWWCOecs-FWaDRqDkCI3aK21MekHePypYmJsjXzJWgPAF5Q/pMYQq9YcqyDKQpaMrIM1SUPKXUDAHQdFQTBX_tsd_MQ'), ('width', 992), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7IYHgKBjG0WnJhAGxn-2tQ/BtvB4wLKEs_TrMr4tkptdbzVSkmdplveDh07cQGluEgY7EZecFd3xaj5tTniuyv59XOznTFXfpiCUeKeq9RV2g/PrkbR8YNIFExATT5Bq3o9KEFq2qvwq0DOXyuAdIJFvw'), ('width', 3000), ('height', 3000)]))]))])]","https://www.batronix.com/shop/waveform-generator/Keysight-33622A.html#:~:text=2%20channel%20function%20%2F%20arbitrary%20waveform,cm%20(4.3%E2%80%9D)%20display.",https://github.com/charkster/keysight_33600a/blob/main/keysight_33600a.py,https://instrumentkit.readthedocs.io/en/latest/_modules/instruments/agilent/agilent33220a.html,12412.7,,,,"import pyvisa

class keysight_33600a():

	def __init__(self, pyvisa_resource):
		self.key33600a = pyvisa_resource

	def get_all_scpi_dict(self):
		result_dict = {}
		for command in self.scpi_cmd_dict:
			result = (self.key33600a.query(command.format(""?""))).rstrip('\r\n')
#			print(""'"" + command.format("" "") + str(result) + ""',"")
			result = "" "" + result
			result_dict[command.format(""?"")] = result
		return result_dict

	def get_all_scpi_list(self):
		result_list = []
		for command in self.scpi_cmd_dict:
#			print(str(command) + ""\n"")
			result = (self.key33600a.query(command.format(""?""))).rstrip('\r\n')
			result = "" "" + result
			result_list.append(command.format(result))
		return result_list

	def get_unique_scpi_list(self):
		unique_scpi_list = []
		inst_settings_list = self.get_all_scpi_list()
		for setting in inst_settings_list:
			if (setting not in self.settings_por_scpi_list):
				unique_scpi_list.append(setting)
		return unique_scpi_list
	
	scpi_cmd_dict = { 
	                  ""SOURce1:AM:DEPTh{0}""                          : ""<depth_in_percent>|MINimum|MAXimum"",
	                  ""SOURce1:AM:DSSC{0}""                           : ""ON|1|OFF|0"",
	                  ""SOURce1:AM:INTernal:FREQuency{0}""             : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:AM:INTernal:FUNCtion{0}""              : ""SINusoid|SQUare|RAMP|NRAMp|TRIangle|NOISe|PRBS|ARB"",
	                  ""SOURce1:AM:SOURce{0}""                         : ""INTernal|EXTernal|CH1|CH2"",
	                  ""SOURce1:BPSK:SOURce{0}""                       : ""INTernal|EXTernal"",
	                  ""SOURce1:FM:SOURce{0}""                         : ""INTernal|EXTernal|CH1|CH2"",
	                  ""SOURce1:FSKey:SOURce{0}""                      : ""INTernal|EXTernal"",
	                  ""SOURce1:PM:SOURce{0}""                         : ""INTernal|EXTernal|CH1|CH2"",
	                  ""SOURce1:PWM:SOURce{0}""                        : ""INTernal|EXTernal|CH1|CH2"",
	                  ""SOURce1:AM:STATe{0}""                          : ""ON|1|OFF|0"",
	                  ""SOURce1:BPSK:STATe{0}""                        : ""ON|1|OFF|0"",
	                  ""SOURce1:FM:STATe{0}""                          : ""ON|1|OFF|0"",
	                  ""SOURce1:FSKey:STATe{0}""                       : ""ON|1|OFF|0"",
	                  ""SOURce1:PM:STATe{0}""                          : ""ON|1|OFF|0"",
	                  ""SOURce1:PWM:STATe{0}""                         : ""ON|1|OFF|0"",
#	                  ""SOURce1:APPLy:{0}""                            : ""function> [<frequency> [,<amplitude> [,<offset>]]]"",
                      ""SOURce1:BPSK:INTernal:RATE{0}""                : ""<modulating_frequency>|MINimum|MAXimum|DEFault"",
                      ""SOURce1:BPSK:PHASe{0}""                        : ""<angle>|MINimum|MAXimum|DEFault"",
                      ""SOURce1:BURSt:GATE:POLarity{0}""               : ""NORMal|INVerted"",
                      ""SOURce1:BURSt:INTernal:PERiod{0}""             : ""<seconds>|MINimum|MAXimum"",
                      ""SOURce1:BURSt:MODE{0}""                        : ""TRIGgered|GATed"",
                      ""SOURce1:BURSt:NCYCles{0}""                     : ""<num_cycles>|INFinity|MINimum|MAXimum"",
                      ""SOURce1:BURSt:PHASe{0}""                       : ""<angle>|MINimum|MAXimum"",
                      ""SOURce1:BURSt:STATe{0}""                       : ""ON|1|OFF|0"",
#	                  ""SOURce1:COMBine:FEED{0}""                      : ""CH1|CH2|NONE"",
                      ""DISPlay{0}""                                   : ""ON|1|OFF|0"",
                      ""SOURce1:FM:DEViation{0}""                      : ""<peak_deviation_in_Hz>|MINimum|MAXimum|DEFault"",
                      ""SOURce1:FM:INTernal:FREQuency{0}""             : ""<frequency>|MINimum|MAXimum|DEFault"",
                      ""SOURce1:FM:INTernal:FUNCtion{0}""              : ""SINusoid|SQUare|RAMP|NRAMp|TRIangle|NOISe|PRBS|ARB"",
                      ""FORMat:BORDer{0}""                             : ""NORMal|SWAPped"",
                      ""SOURce1:FREQuency{0}""                         : ""<frequency>|MINimum|MAXimum|DEFault"",
                      ""SOURce1:FREQuency:CENTer{0}""                  : ""<frequency>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:FREQuency:COUPle:STATe{0}""            : ""ON|1|OFF|0"",
#	                  ""SOURce1:FREQuency:COUPle:MODE{0}""             : ""OFFSet|RATio"",
#	                  ""SOURce1:FREQuency:COUPle:OFFSet{0}""           : ""<frequency>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:FREQuency:COUPle:RATio{0}""            : ""<ratio>"",
	                  ""SOURce1:FREQuency:MODE{0}""                    : ""CW|LIST|SWEep|FIXed"",
	                  ""SOURce1:FREQuency:SPAN{0}""                    : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FREQuency:STARt{0}""                   : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FREQuency:STOP{0}""                    : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FSKey:FREQuency{0}""                   : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FSKey:INTernal:RATE{0}""               : ""<rate_in_Hz>|MINimum|MAXimum"",
	                  ""SOURce1:FUNCtion{0}""                          : ""SINusoid|SQUare|TRIangle|RAMP|PULSe|PRBS|NOISe|ARB|DC"",
	                  ""SOURce1:FUNCtion:ARBitrary{0}""                : ""<filename>"",
	                  ""SOURce1:FUNCtion:ARBitrary:ADVance{0}""        : ""TRIGger|SRATe"",
	                  ""SOURce1:FUNCtion:ARBitrary:FILTer{0}""         : ""NORMal|STEP|OFF"",
	                  ""SOURce1:FUNCtion:ARBitrary:FREQuency{0}""      : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:ARBitrary:PERiod{0}""         : ""<period>|MINimum|MAXimum}DEFault"",
	                  ""SOURce1:FUNCtion:ARBitrary:PTPeak{0}""         : ""<voltage>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:ARBitrary:SRATe{0}""          : ""<sample_rate>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:NOISe:BANDwidth{0}""          : ""<bandwidth>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PRBS:BRATe{0}""               : ""<bit_rate>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PRBS:DATA{0}""                : ""PN3 through PN32"",
	                  ""SOURce1:FUNCtion:PRBS:TRANsition:BOTH{0}""     : ""<seconds>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:FUNCtion:PULSe:DCYCle{0}""             : ""<percent>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PULSe:HOLD{0}""               : ""WIDTh|DCYCle"",
	                  ""SOURce1:FUNCtion:PULSe:PERiod{0}""             : ""<seconds>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PULSe:TRANsition:LEADing{0}"" : ""<seconds>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PULSe:TRANsition:TRAiling{0}"": ""<seconds>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:PULSe:WIDTh{0}""              : ""<seconds>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:RAMP:SYMMetry{0}""            : ""<percent>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:FUNCtion:SQUare:DCYCle{0}""            : ""<percent>|MINimum|MAXimum"",
	                  ""SOURce1:FUNCtion:SQUare:PERiod{0}""            : ""<seconds>|MINimum|MAXimum|DEFault"",
	                  ""FUNCtion:ARBitrary:BALance:STATe{0}""          : ""ON|1|OFF|0"",
	                  ""FUNCtion:ARBitrary:BALance:GAIN{0}""           : ""<percent>|MINimum|MAXimum|DEFine"",
	                  ""FUNCtion:ARBitrary:BALance:OFFSet1{0}""        : ""<volts>|MINimum|MAXimum|DEFault"",
	                  ""FUNCtion:ARBitrary:BALance:OFFSet2{0}""        : ""<volts>|MINimum|MAXimum|DEFault"",
	                  ""FUNCtion:ARBitrary:SKEW:STATe{0}""             : ""ON|1|OFF|0"",
	                  ""FUNCtion:ARBitrary:SKEW:TIME{0}""              : ""<time>|MINimum|MAXimum|DEFault"",
	                  ""INITiate1:CONTinuous{0}""                      : ""ON|1|OFF|0"",
	                  ""INPut:ATTenuation:STATe{0}""                   : ""ON|1|OFF|0"",
	                  ""SOURce1:LIST:DWELl{0}""                        : ""<seconds>|MINimum|MAXimum"",
	                  ""SOURce1:LIST:FREQuency{0}""                    : ""<freq1>[, <freq2>, etc.]"",
	                  ""SOURce1:MARKer:CYCle{0}""                      : ""<cycle_num>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:MARKer:FREQuency{0}""                  : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:MARKer:POINt{0}""                      : ""<sample_number>|MINimum|MAXimum"",
	                  ""OUTPut1:LOAD{0}""                              : ""<ohms>|INFinity|MINimum|MAXimum|DEFault"",
	                  ""OUTPut1:MODE{0}""                              : ""NORMal|GATed"",
	                  ""OUTPut1:POLarity{0}""                          : ""NORMal|INVerted"",
	                  ""OUTPut:SYNC{0}""                               : ""ON|1|OFF|0"",
	                  ""OUTPut1:SYNC:MODE{0}""                         : ""NORMal|CARRier|MARKer"",
	                  ""OUTPut1:SYNC:POLarity{0}""                     : ""NORMal|INVerted"",
	                  ""OUTPut:SYNC:SOURce{0}""                        : ""CH1|CH2"",
	                  ""OUTPut:TRIGger{0}""                            : ""ON|1|OFF|0"",
	                  ""OUTPut:TRIGger:SLOPe{0}""                      : ""POSitive|NEGative"",
	                  ""OUTPut:TRIGger:SOURce{0}""                     : ""CH1|CH2"",
	                  ""SOURce1:PHASe:ARBitrary{0}""                   : ""<angle>|MINimum|MAXimum"",
	                  ""SOURce1:PHASe:MODulation{0}""                  : ""<angle>|MINimum|MAXimum"",
	                  ""SOURce1:PM:DEViation{0}""                      : ""<deviation in degrees>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:PM:INTernal:FREQuency{0}""             : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:PM:INTernal:FUNCtion{0}""              : ""SINusoid|SQUare|RAMP|NRAMp|TRIangle|NOISe|PRBS|ARB"",
	                  ""SOURce1:PWM:DEViation{0}""                     : ""<deviation>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:PWM:DEViation:DCYCle{0}""              : ""<deviation_in_pct>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:PWM:INTernal:FREQuency{0}""            : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:PWM:INTernal:FUNCtion{0}""             : ""SINusoid|SQUare|RAMP|NRAMp|TRIangle|NOISe|PRBS|ARB"",
#	                  ""SOURce1:RATE:COUPle:STATe{0}""                 : ""ON|1|OFF|0"",
#	                  ""SOURce1:RATE:COUPle:MODE{0}""                  : ""OFFSet|RATio"",
#	                  ""SOURce1:RATE:COUPle:OFFSet{0}""                : ""<sample_rate>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:RATe:COUPle:RATio{0}""                 : ""<ratio>|MINimum|MAXimum"",
	                  ""ROSCillator:SOURce{0}""                        : ""INTernal|EXTernal"",
	                  ""ROSCillator:SOURce:AUTO{0}""                   : ""ON|OFF"",
	                  ""SOURce1:SUM:AMPLitude{0}""                     : ""<amplitude>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:SUM:INTernal:FREQuency{0}""            : ""<frequency>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:SUM:INTernal:FUNCtion{0}""             : ""SINusoid|SQUare|RAMP|NRAMp|TRIangle|NOISe|PRBS|ARB"",
	                  ""SOURce1:SUM:SOURce{0}""                        : ""INTernal|EXTernal|CH1|CH2"",
	                  ""SOURce1:SWEep:HTIMe{0}""                       : ""<hold_time>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:SWEep:RTIMe{0}""                       : ""<return_time>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:SWEep:SPACing{0}""                     : ""LINear|LOGarithmic"",
	                  ""SOURce1:SWEep:STATe{0}""                       : ""ON|1|OFF|0"",
	                  ""SOURce1:SWEep:TIME{0}""                        : ""<seconds>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:TRACk{0}""                             : ""ON|OFF|INVerted"",
	                  ""TRIGger1:COUNt{0}""                            : ""<number>MINimum|MAXimum|DEFault"",
	                  ""TRIGger1:DELay{0}""                            : ""<seconds>|MINimum|MAXimum"",
	                  ""TRIGger1:LEVel{0}""                            : ""<level>|MINimum|MAXimum"",
	                  ""TRIGger1:SLOPe{0}""                            : ""POSitive|NEGative"",
	                  ""TRIGger1:SOURce{0}""                           : ""IMMediate|EXTernal|TIMer|BUS"",
	                  ""TRIGger1:TIMer{0}""                            : ""<seconds>|MINimum|MAXimum"",
	                  ""UNIT:ANGLe{0}""                                : ""DEGree|RADian|SECond|DEFault"",
	                  ""UNIT:ARBitrary:ANGLe{0}""                      : ""EGree|RADian|SECond|SAMPle|DEFault"",
	                  ""SOURce1:VOLTage{0}""                           : ""<amplitude>|MINimum|MAXimum|DEFault"",
#	                  ""SOURce1:VOLTage:COUPle:STATe{0}""              : ""ON|1|OFF|0"",
	                  ""SOURce1:VOLTage:HIGH{0}""                      : ""<voltage>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:VOLTage:LOW{0}""                       : ""<voltage>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:VOLTage:LIMit:HIGH{0}""                : ""<voltage>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:VOLTage:LIMit:LOW{0}""                 : ""<voltage>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:VOLTage:LIMit:STATe{0}""               : ""ON|1|OFF|0"",
	                  ""SOURce1:VOLTage:OFFSet{0}""                    : ""<offset>|MINimum|MAXimum|DEFault"",
	                  ""SOURce1:VOLTage:RANGe:AUTO{0}""                : ""OFF|0|ON|1|ONCE"",
	                  ""SOURce1:VOLTage:UNIT{0}""                      : ""VPP|VRMS|DBM"",
	                  ""OUTPut1:LOAD{0}""                              : ""<ohms>|INFinity|MINimum|MAXimum|DEFault"",
                          ""OUTPUT1:MODE{0}""i                             : ""NORMal|GATed"",
                          ""OUTPut1:POLarity{0}""                          : ""NORMal|INVerted"",
                          ""OUTPut:SYNC{0}""                               : ""ON | 1 | OFF | 0"",
                          ""OUTPut1:SYNC:MODE{0}""                         : ""NORMal|CARRier|MARKer"",
                          ""OUTPut1:SYNC:POLarity{0}""                     : ""NORMal|INVerted"",
                          ""OUTPut:TRIGger{0}""                            : ""ON|1|OFF|0"",
                          ""OUTPut:TRIGger:SLOPe{0}""                      : ""POSitive|NEGative"",
                          ""OUTPut{0}""                                    : ""ON|1|OFF|0"" }

	settings_por_scpi_list = [ 'SOURce1:AM:STATe 0',
	                           'OUTPut1:SYNC:POLarity NORM',
	                           'SOURce1:PWM:STATe 0',
	                           'SOURce1:FUNCtion:PULSe:TRANsition:LEADing +4.000000000000000E-09',
	                           'SOURce1:FUNCtion:SQUare:PERiod +1.000000000000000E-03',
	                           'SOURce1:BURSt:INTernal:PERiod +1.000000000000000E-02',
	                           'SOURce1:PWM:INTernal:FREQuency +1.000000000000000E+01',
	                           'UNIT:ANGLe DEG',
	                           'UNIT:ARBitrary:ANGLe DEG',
	                           'SOURce1:PM:INTernal:FREQuency +1.000000000000000E+01',
	                           'SOURce1:FUNCtion:ARBitrary:FREQuency +1.600000000000000E+02',
	                           'SOURce1:FREQuency:SPAN +9.000000000000000E+02',
	                           'OUTPut1:MODE NORM',
	                           'TRIGger1:SLOPe POS',
	                           'FUNCtion:ARBitrary:BALance:GAIN +0.00000000E+000',
	                           'SOURce1:FUNCtion:NOISe:BANDwidth +1.000000000000000E+05',
	                           'SOURce1:BURSt:NCYCles +1.000000000000000E+00',
	                           'SOURce1:VOLTage:HIGH +5.000000000000000E-02',
	                           'OUTPut:TRIGger:SOURce CH1',
	                           'SOURce1:FUNCtion:ARBitrary:PTPeak +1.000000000000000E-01',
	                           'TRIGger1:SOURce IMM',
	                           'SOURce1:FSKey:SOURce INT',
	                           'SOURce1:FUNCtion:ARBitrary:SRATe +4.000000000000000E+04',
	                           'SOURce1:FUNCtion:PULSe:HOLD WIDT',
	                           'SOURce1:FREQuency:CENTer +5.500000000000000E+02',
	                           'SOURce1:SUM:SOURce INT',
	                           'INITiate1:CONTinuous 1',
	                           'SOURce1:FUNCtion SIN',
	                           'SOURce1:SWEep:HTIMe +0.000000000000000E+00',
	                           'SOURce1:FSKey:STATe 0',
	                           'TRIGger1:COUNt +1.000000000000000E+00',
	                           'SOURce1:BPSK:STATe 0',
	                           'SOURce1:SWEep:SPACing LIN',
	                           'SOURce1:FUNCtion:ARBitrary:ADVance SRAT',
	                           'SOURce1:FREQuency:STARt +1.000000000000000E+02',
	                           'SOURce1:BPSK:SOURce INT',
	                           'SOURce1:VOLTage +1.0000000000000E-01',
	                           'SOURce1:LIST:FREQuency +1.00000000E+002,+1.00000000E+003,+5.50000000E+002',
	                           'TRIGger1:LEVel +3.300000000000000E+00',
	                           'OUTPut1:SYNC:MODE NORM',
	                           'SOURce1:FUNCtion:PULSe:WIDTh +1.000000000000000E-04',
	                           'SOURce1:MARKer:POINt +1.00000000E+001',
	                           'OUTPut:TRIGger:SLOPe POS',
	                           'FUNCtion:ARBitrary:BALance:OFFSet1 +0.00000000E+000',
	                           'SOURce1:BURSt:GATE:POLarity NORM',
	                           'SOURce1:SUM:AMPLitude +1.000000000000000E-01',
	                           'SOURce1:FUNCtion:RAMP:SYMMetry +1.000000000000000E+02',
	                           'SOURce1:FUNCtion:PULSe:DCYCle +1.000000000000000E+01',
	                           'OUTPut:SYNC:SOURce CH1',
	                           'SOURce1:BURSt:MODE TRIG',
	                           'FUNCtion:ARBitrary:SKEW:STATe 0',
	                           'SOURce1:PWM:DEViation:DCYCle +1.000000000000000E+00',
	                           'SOURce1:LIST:DWELl +1.000000000000000E+00',
	                           'SOURce1:BPSK:INTernal:RATE +1.000000000000000E+01',
	                           'SOURce1:SWEep:STATe 0',
	                           'FUNCtion:ARBitrary:BALance:STATe 0',
	                           'SOURce1:VOLTage:LIMit:HIGH +5.000000000000000E+00',
	                           'SOURce1:FM:DEViation +1.000000000000000E+02',
	                           'SOURce1:FUNCtion:ARBitrary ""INT:\BUILTIN\EXP_RISE.ARB""',
	                           'SOURce1:FREQuency:MODE CW',
	                           'SOURce1:FM:INTernal:FREQuency +1.000000000000000E+01',
	                           'SOURce1:AM:INTernal:FREQuency +1.000000000000000E+02',
	                           'TRIGger1:TIMer +1.000000000000000E+00',
	                           'SOURce1:PWM:SOURce INT',
	                           'SOURce1:FUNCtion:SQUare:DCYCle +5.000000000000000E+01',
	                           'SOURce1:VOLTage:UNIT VPP',
	                           'SOURce1:BURSt:STATe 0',
	                           'SOURce1:VOLTage:LIMit:STATe 0',
	                           'SOURce1:AM:INTernal:FUNCtion SIN',
	                           'FUNCtion:ARBitrary:BALance:OFFSet2 +0.00000000E+000',
	                           'SOURce1:BURSt:PHASe +0.0000000000000E+00',
	                           'SOURce1:MARKer:CYCle +2.000000000000000E+00',
	                           'SOURce1:PWM:INTernal:FUNCtion SIN',
	                           'ROSCillator:SOURce INT',
	                           'SOURce1:FUNCtion:ARBitrary:PERiod +6.250000000000000E-03',
	                           'SOURce1:FUNCtion:PULSe:TRANsition:TRAiling +4.000000000000000E-09',
	                           'SOURce1:FSKey:FREQuency +1.000000000000000E+02',
	                           'SOURce1:AM:SOURce INT',
	                           'SOURce1:SWEep:TIME +1.000000000000000E+00',
	                           'FUNCtion:ARBitrary:SKEW:TIME +0.00000000E+000',
	                           'SOURce1:BPSK:PHASe +1.800000000000000E+02',
	                           'SOURce1:AM:DSSC 0',
	                           'SOURce1:SUM:INTernal:FREQuency +1.000000000000000E+02',
	                           'SOURce1:FSKey:INTernal:RATE +1.000000000000000E+01',
	                           'SOURce1:FUNCtion:PRBS:TRANsition:BOTH +4.000000000000000E-09',
	                           'SOURce1:FM:SOURce INT',
	                           'SOURce1:VOLTage:OFFSet +0.0000000000000E+00',
	                           'TRIGger1:DELay +0.000000000000000E+00',
	                           'SOURce1:MARKer:FREQuency +5.000000000000000E+02',
	                           'OUTPut1:LOAD +5.000000000000000E+01',
	                           'OUTPut:TRIGger 0',
	                           'FORMat:BORDer NORM',
	                           'SOURce1:VOLTage:LOW -5.000000000000000E-02',
	                           'SOURce1:PHASe:MODulation +0.0000000000000E+00',
	                           'SOURce1:FUNCtion:PRBS:BRATe +1.000000000000000E+03',
	                           'SOURce1:FUNCtion:PRBS:DATA PN7',
	                           'ROSCillator:SOURce:AUTO ON',
	                           'SOURce1:VOLTage:RANGe:AUTO 1',
	                           'SOURce1:FREQuency:STOP +1.000000000000000E+03',
	                           'SOURce1:FM:INTernal:FUNCtion SIN',
	                           'OUTPut:SYNC 1',
	                           'SOURce1:VOLTage:LIMit:LOW -5.000000000000000E+00',
	                           'OUTPut1:POLarity NORM',
	                           'SOURce1:PHASe:ARBitrary +0.0000000000000E+00',
	                           'SOURce1:SWEep:RTIMe +0.000000000000000E+00',
	                           'SOURce1:AM:DEPTh +1.000000000000000E+02',
	                           'INPut:ATTenuation:STATe 1',
	                           'SOURce1:PM:SOURce INT',
	                           'DISPlay 1',
	                           'SOURce1:FREQuency +1.000000000000000E+03',
	                           'SOURce1:PM:STATe 0',
	                           'SOURce1:FM:STATe 0',
	                           'SOURce1:FUNCtion:PULSe:PERiod +1.000000000000000E-03',
	                           'SOURce1:SUM:INTernal:FUNCtion SIN',
	                           'SOURce1:PM:DEViation +1.800000000000000E+02',
	                           'SOURce1:FUNCtion:ARBitrary:FILTer STEP',
	                           'SOURce1:PWM:DEViation +1.000000000000000E-05',
	                           'SOURce1:PM:INTernal:FUNCtion SIN' 
				   'OUTPut1:LOAD +5.000000000000000E+01',
                                   'OUTPut1:MODE NORM',
                                   'OUTPut1:POLarity NORM',
                                   'OUTPut:SYNC 1',
                                   'OUTPut1:SYNC:MODE NORM',
                                   'OUTPut1:SYNC:POLarity NORM',
                                   'OUTPut:TRIGger 0',
                                   'OUTPut:TRIGger:SLOPe POS',
                                   'OUTPut 0' ]
"
334,5800.0,USA,"AWG5000 Series models, with a 14
bits DA converter based sample rate
from 600 MS/s to 1.2 GS/s, two to four output channels, synchronized four to eight digital marker outputs, and 28-channels of digital data outputs, easilysolve the toughest measurement challenges in wireless base band I/Q communications, digital consumer product design such as imaging devices, data conversion equipment and semiconductor design and test",AWG 5014,556.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG5014 RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG5014,https://download.tek.com/datasheet/76W-20381-3.pdf,"[OrderedDict([('id', 'attGNiWvU4zCyvSrE'), ('width', 1200), ('height', 1024), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qDHCBHoVAK2OBkxsJtOEVg/mgaQJuuUSEVn2gIEIzliOHuM14HAb0Pj3NexiDOL_SxxY9mQTrY4wnrnXgJfUZ8eOk4HAbOyrDYA7T1SsVuEOdsxHeE7sOJJdH-EygnJ5ZI/rFFoOyIA5ZQssWiDa2AIXC4b0nHnazuPhMZxGNdtuYI'), ('filename', '0002359_TEK_AWG5014.jpg'), ('size', 205214), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Qswn_jppObaOMc7GB787Hw/m_bsCTRBplFNUwZnzG9LlNAHOGsHtsrYpTn4pUgqx0MwpCfpJdk-zxIEQzx6yYuau7_L-ds51jixc9uHal3AZw/h6ehnNkwmk5woxKpZUZwt7IdQp877JKgLTmveyqGlmY'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/YZszefYKEhgpiCa3ksLRWg/HNULTFIDeycw0KkvuqeDLnv0fDeaaxZdXXKm1jvxTgIrPke2XsRGC0V6p0lJG7MSKAOKTV64iOsq5WJ5LLJlDQ/gSWBpYZQ98WmSEHIq4Py9ZupUwbXxzjp3uTiZ_vQ2AI'), ('width', 600), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HG57E3YMUEQxgtYX9cUxuw/70gZ4O2zTmimIvBexWQ2uby9WmzSw4LGRx9v8PXZVwAmGjFmpncnoVSc5SlmkctVFx4777H-ZFbZkntZd2sHfQ/vfrNzkkVdSMR8vPr4_DG-DlV7_-aCMIbyOhDJlitAHw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/datasheet/awg5000-series,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG5014.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG5014,,,True,,"import array as arr
import logging
import re
import struct
from collections import abc
from collections.abc import Sequence
from io import BytesIO
from time import localtime, sleep
from typing import Any, Literal, NamedTuple, Optional, Union, cast

import numpy as np
from pyvisa.errors import VisaIOError

from qcodes import validators as vals
from qcodes.instrument import VisaInstrument

log = logging.getLogger(__name__)


class _MarkerDescriptor(NamedTuple):
    marker: int
    channel: int


def parsestr(v: str) -> str:
    return v.strip().strip('""')


class TektronixAWG5014(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Tektronix AWG5014
    Arbitrary Waveform Generator.

    The driver makes some assumptions on the settings of the instrument:

        - The output channels are always in Amplitude/Offset mode
        - The output markers are always in High/Low mode

    TODO:
        - Implement support for cable transfer function compensation
        - Implement more instrument functionality in the driver
        - Remove double functionality
        - Remove inconsistensies between the name of a parameter and
          the name of the same variable in the tektronix manual

    In the future, we should consider the following:

        * Removing test_send??
        * That sequence element (SQEL) parameter functions exist but no
          corresponding parameters.

    """"""
    AWG_FILE_FORMAT_HEAD = {
        'SAMPLING_RATE': 'd',    # d
        'REPETITION_RATE': 'd',    # # NAME?
        'HOLD_REPETITION_RATE': 'h',    # True | False
        'CLOCK_SOURCE': 'h',    # Internal | External
        'REFERENCE_SOURCE': 'h',    # Internal | External
        'EXTERNAL_REFERENCE_TYPE': 'h',    # Fixed | Variable
        'REFERENCE_CLOCK_FREQUENCY_SELECTION': 'h',
        'REFERENCE_MULTIPLIER_RATE': 'h',    #
        'DIVIDER_RATE': 'h',   # 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256
        'TRIGGER_SOURCE': 'h',    # Internal | External
        'INTERNAL_TRIGGER_RATE': 'd',    #
        'TRIGGER_INPUT_IMPEDANCE': 'h',    # 50 ohm | 1 kohm
        'TRIGGER_INPUT_SLOPE': 'h',    # Positive | Negative
        'TRIGGER_INPUT_POLARITY': 'h',    # Positive | Negative
        'TRIGGER_INPUT_THRESHOLD': 'd',    #
        'EVENT_INPUT_IMPEDANCE': 'h',    # 50 ohm | 1 kohm
        'EVENT_INPUT_POLARITY': 'h',    # Positive | Negative
        'EVENT_INPUT_THRESHOLD': 'd',
        'JUMP_TIMING': 'h',    # Sync | Async
        'INTERLEAVE': 'h',    # On |  This setting is stronger than .
        'ZEROING': 'h',    # On | Off
        'COUPLING': 'h',    # The Off | Pair | All setting is weaker than .
        'RUN_MODE': 'h',    # Continuous | Triggered | Gated | Sequence
        'WAIT_VALUE': 'h',    # First | Last
        'RUN_STATE': 'h',    # On | Off
        'INTERLEAVE_ADJ_PHASE': 'd',
        'INTERLEAVE_ADJ_AMPLITUDE': 'd',
    }
    AWG_FILE_FORMAT_CHANNEL = {
        # Include NULL.(Output Waveform Name for Non-Sequence mode)
        'OUTPUT_WAVEFORM_NAME_N': 's',
        'CHANNEL_STATE_N': 'h',  # On | Off
        'ANALOG_DIRECT_OUTPUT_N': 'h',  # On | Off
        'ANALOG_FILTER_N': 'h',  # Enum type.
        'ANALOG_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'ANALOG_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'ANALOG_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'ANALOG_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'ANALOG_LOW_N': 'd',
        'MARKER1_SKEW_N': 'd',
        'MARKER1_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'MARKER1_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'MARKER1_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER1_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER1_LOW_N': 'd',
        'MARKER2_SKEW_N': 'd',
        'MARKER2_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'MARKER2_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'MARKER2_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER2_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'MARKER2_LOW_N': 'd',
        'DIGITAL_METHOD_N': 'h',  # Amplitude/Offset, High/Low
        # When the Input Method is High/Low, it is skipped.
        'DIGITAL_AMPLITUDE_N': 'd',
        # When the Input Method is High/Low, it is skipped.
        'DIGITAL_OFFSET_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'DIGITAL_HIGH_N': 'd',
        # When the Input Method is Amplitude/Offset, it is skipped.
        'DIGITAL_LOW_N': 'd',
        'EXTERNAL_ADD_N': 'h',  # AWG5000 only
        'PHASE_DELAY_INPUT_METHOD_N':   'h',  # Phase/DelayInme/DelayInints
        'PHASE_N': 'd',  # When the Input Method is not Phase, it is skipped.
        # When the Input Method is not DelayInTime, it is skipped.
        'DELAY_IN_TIME_N': 'd',
        # When the Input Method is not DelayInPoint, it is skipped.
        'DELAY_IN_POINTS_N': 'd',
        'CHANNEL_SKEW_N': 'd',
        'DC_OUTPUT_LEVEL_N': 'd',  # V
    }

    def __init__(
            self,
            name: str,
            address: str,
            timeout: int = 180,
            num_channels: int = 4,
            **kwargs: Any):
        """"""
        Initializes the AWG5014.

        Args:
            name: name of the instrument
            address: GPIB or ethernet address as used by VISA
            timeout: visa timeout, in secs. long default (180)
                to accommodate large waveforms
            num_channels: number of channels on the device

        """"""
        super().__init__(name, address, timeout=timeout, **kwargs)

        self._address = address
        self.num_channels = num_channels

        self._values: dict[
            str, dict[str, dict[str, Union[np.ndarray, float, None]]]
        ] = {}
        self._values[""files""] = {}

        self.add_function('reset', call_cmd='*RST')

        self.add_parameter('state',
                           get_cmd=self.get_state)
        self.add_parameter('run_mode',
                           get_cmd='AWGControl:RMODe?',
                           set_cmd='AWGControl:RMODe ' + '{}',
                           vals=vals.Enum('CONT', 'TRIG', 'SEQ', 'GAT'),
                           get_parser=self.newlinestripper
                           )
        self.add_parameter('clock_source',
                           label='Clock source',
                           get_cmd='AWGControl:CLOCk:SOURce?',
                           set_cmd='AWGControl:CLOCk:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        self.add_parameter('ref_source',
                           label='Reference source',
                           get_cmd='SOURce1:ROSCillator:SOURce?',
                           set_cmd='SOURce1:ROSCillator:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        self.add_parameter('DC_output',
                           label='DC Output (ON/OFF)',
                           get_cmd='AWGControl:DC:STATe?',
                           set_cmd='AWGControl:DC:STATe {}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        # sequence parameter(s)
        self.add_parameter('sequence_length',
                           label='Sequence length',
                           get_cmd='SEQuence:LENGth?',
                           set_cmd='SEQuence:LENGth ' + '{}',
                           get_parser=int,
                           vals=vals.Ints(0, 8000),
                           docstring=(
                               """"""
                               This command sets the sequence length.
                               Use this command to create an
                               uninitialized sequence. You can also
                               use the command to clear all sequence
                               elements in a single action by passing
                               0 as the parameter. However, this
                               action cannot be undone so exercise
                               necessary caution. Also note that
                               passing a value less than the
                               sequence’s current length will cause
                               some sequence elements to be deleted at
                               the end of the sequence. For example if
                               self.get_sq_length returns 200 and you
                               subsequently set sequence_length to 21,
                               all sequence elements except the first
                               20 will be deleted.
                               """""")
                           )

        self.add_parameter('sequence_pos',
                           label='Sequence position',
                           get_cmd='AWGControl:SEQuencer:POSition?',
                           set_cmd='SEQuence:JUMP:IMMediate {}',
                           vals=vals.PermissiveInts(1),
                           set_parser=lambda x: int(round(x))
                           )

        # Trigger parameters #
        # Warning: `trigger_mode` is the same as `run_mode`, do not use! exists
        # solely for legacy purposes
        self.add_parameter('trigger_mode',
                           get_cmd='AWGControl:RMODe?',
                           set_cmd='AWGControl:RMODe ' + '{}',
                           vals=vals.Enum('CONT', 'TRIG', 'SEQ', 'GAT'),
                           get_parser=self.newlinestripper)
        self.add_parameter('trigger_impedance',
                           label='Trigger impedance',
                           unit='Ohm',
                           get_cmd='TRIGger:IMPedance?',
                           set_cmd='TRIGger:IMPedance ' + '{}',
                           vals=vals.Enum(50, 1000),
                           get_parser=float)
        self.add_parameter('trigger_level',
                           unit='V',
                           label='Trigger level',
                           get_cmd='TRIGger:LEVel?',
                           set_cmd='TRIGger:LEVel ' + '{:.3f}',
                           vals=vals.Numbers(-5, 5),
                           get_parser=float)
        self.add_parameter('trigger_slope',
                           get_cmd='TRIGger:SLOPe?',
                           set_cmd='TRIGger:SLOPe ' + '{}',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=self.newlinestripper)

        self.add_parameter('trigger_source',
                           get_cmd='TRIGger:SOURce?',
                           set_cmd='TRIGger:SOURce ' + '{}',
                           vals=vals.Enum('INT', 'EXT'),
                           get_parser=self.newlinestripper)

        # Event parameters
        self.add_parameter('event_polarity',
                           get_cmd='EVENt:POL?',
                           set_cmd='EVENt:POL ' + '{}',
                           vals=vals.Enum('POS', 'NEG'),
                           get_parser=self.newlinestripper)
        self.add_parameter('event_impedance',
                           label='Event impedance',
                           unit='Ohm',
                           get_cmd='EVENt:IMPedance?',
                           set_cmd='EVENt:IMPedance ' + '{}',
                           vals=vals.Enum(50, 1000),
                           get_parser=float)
        self.add_parameter('event_level',
                           label='Event level',
                           unit='V',
                           get_cmd='EVENt:LEVel?',
                           set_cmd='EVENt:LEVel ' + '{:.3f}',
                           vals=vals.Numbers(-5, 5),
                           get_parser=float)
        self.add_parameter('event_jump_timing',
                           get_cmd='EVENt:JTIMing?',
                           set_cmd='EVENt:JTIMing {}',
                           vals=vals.Enum('SYNC', 'ASYNC'),
                           get_parser=self.newlinestripper)

        self.add_parameter('clock_freq',
                           label='Clock frequency',
                           unit='Hz',
                           get_cmd='SOURce:FREQuency?',
                           set_cmd='SOURce:FREQuency ' + '{}',
                           vals=vals.Numbers(1e6, 1.2e9),
                           get_parser=float)

        self.add_parameter('setup_filename',
                           get_cmd='AWGControl:SNAMe?')

        # Channel parameters #
        for i in range(1, self.num_channels+1):
            amp_cmd = f'SOURce{i}:VOLTage:LEVel:IMMediate:AMPLitude'
            offset_cmd = f'SOURce{i}:VOLTage:LEVel:IMMediate:OFFS'
            state_cmd = f'OUTPUT{i}:STATE'
            waveform_cmd = f'SOURce{i}:WAVeform'
            directoutput_cmd = f'AWGControl:DOUTput{i}:STATE'
            filter_cmd = f'OUTPut{i}:FILTer:FREQuency'
            add_input_cmd = f'SOURce{i}:COMBine:FEED'
            dc_out_cmd = f'AWGControl:DC{i}:VOLTage:OFFSet'

            # Set channel first to ensure sensible sorting of pars
            self.add_parameter(f'ch{i}_state',
                               label=f'Status channel {i}',
                               get_cmd=state_cmd + '?',
                               set_cmd=state_cmd + ' {}',
                               vals=vals.Ints(0, 1),
                               get_parser=int)
            self.add_parameter(f'ch{i}_amp',
                               label=f'Amplitude channel {i}',
                               unit='Vpp',
                               get_cmd=amp_cmd + '?',
                               set_cmd=amp_cmd + ' {:.6f}',
                               vals=vals.Numbers(0.02, 4.5),
                               get_parser=float)
            self.add_parameter(f'ch{i}_offset',
                               label=f'Offset channel {i}',
                               unit='V',
                               get_cmd=offset_cmd + '?',
                               set_cmd=offset_cmd + ' {:.3f}',
                               vals=vals.Numbers(-2.25, 2.25),
                               get_parser=float)
            self.add_parameter(f'ch{i}_waveform',
                               label=f'Waveform channel {i}',
                               get_cmd=waveform_cmd + '?',
                               set_cmd=waveform_cmd + ' ""{}""',
                               vals=vals.Strings(),
                               get_parser=parsestr)
            self.add_parameter(f'ch{i}_direct_output',
                               label=f'Direct output channel {i}',
                               get_cmd=directoutput_cmd + '?',
                               set_cmd=directoutput_cmd + ' {}',
                               vals=vals.Ints(0, 1))
            self.add_parameter(f'ch{i}_add_input',
                               label='Add input channel {}',
                               get_cmd=add_input_cmd + '?',
                               set_cmd=add_input_cmd + ' {}',
                               vals=vals.Enum('""ESIG""', '""ESIGnal""', '""""'),
                               get_parser=self.newlinestripper)
            self.add_parameter(f'ch{i}_filter',
                               label=f'Low pass filter channel {i}',
                               unit='Hz',
                               get_cmd=filter_cmd + '?',
                               set_cmd=filter_cmd + ' {}',
                               vals=vals.Enum(20e6, 100e6,
                                              float('inf'),
                                              'INF', 'INFinity'),
                               get_parser=self._tek_outofrange_get_parser)
            self.add_parameter(f'ch{i}_DC_out',
                               label=f'DC output level channel {i}',
                               unit='V',
                               get_cmd=dc_out_cmd + '?',
                               set_cmd=dc_out_cmd + ' {}',
                               vals=vals.Numbers(-3, 5),
                               get_parser=float)

            # Marker channels
            for j in range(1, 3):
                m_del_cmd = f'SOURce{i}:MARKer{j}:DELay'
                m_high_cmd = ('SOURce{}:MARKer{}:VOLTage:' +
                              'LEVel:IMMediate:HIGH').format(i, j)
                m_low_cmd = ('SOURce{}:MARKer{}:VOLTage:' +
                             'LEVel:IMMediate:LOW').format(i, j)

                self.add_parameter(
                    f'ch{i}_m{j}_del',
                    label=f'Channel {i} Marker {j} delay',
                    unit='ns',
                    get_cmd=m_del_cmd + '?',
                    set_cmd=m_del_cmd + ' {:.3f}e-9',
                    vals=vals.Numbers(0, 1),
                    get_parser=float)
                self.add_parameter(
                    f'ch{i}_m{j}_high',
                    label=f'Channel {i} Marker {j} high level',
                    unit='V',
                    get_cmd=m_high_cmd + '?',
                    set_cmd=m_high_cmd + ' {:.3f}',
                    vals=vals.Numbers(-0.9, 2.7),
                    get_parser=float)
                self.add_parameter(
                    f'ch{i}_m{j}_low',
                    label=f'Channel {i} Marker {j} low level',
                    unit='V',
                    get_cmd=m_low_cmd + '?',
                    set_cmd=m_low_cmd + ' {:.3f}',
                    vals=vals.Numbers(-1.0, 2.6),
                    get_parser=float)

        self.set('trigger_impedance', 50)
        if self.get('clock_freq') != 1e9:
            log.info('AWG clock freq not set to 1GHz')

        self.connect_message()

    # Convenience parser
    def newlinestripper(self, string: str) -> str:
        if string.endswith('\n'):
            return string[:-1]
        else:
            return string

    def _tek_outofrange_get_parser(self, string: str) -> float:
        val = float(string)
        # note that 9.9e37 is used as a generic out of range value
        # in tektronix instruments
        if val >= 9.9e37:
            val = float('INF')
        return val

    # Functions
    def get_state(self) -> Literal['Idle', 'Waiting for trigger', 'Running']:
        """"""
        This query returns the run state of the arbitrary waveform
        generator or the sequencer.

        Returns:
            Either 'Idle', 'Waiting for trigger', or 'Running'.

        Raises:
            ValueError: if none of the three states above apply.
        """"""
        state = self.ask('AWGControl:RSTATe?')
        if state.startswith('0'):
            return 'Idle'
        elif state.startswith('1'):
            return 'Waiting for trigger'
        elif state.startswith('2'):
            return 'Running'
        else:
            raise ValueError(__name__ + (' : AWG in undefined ' +
                                         'state ""{}""').format(state))

    def start(self) -> str:
        """"""Convenience function, identical to self.run()""""""
        return self.run()

    def run(self) -> str:
        """"""
        This command initiates the output of a waveform or a sequence.
        This is equivalent to pressing Run/Stop button on the front panel.
        The instrument can be put in the run state only when output waveforms
        are assigned to channels.

        Returns:
            The output of self.get_state()
        """"""
        self.write('AWGControl:RUN')
        return self.get_state()

    def stop(self) -> None:
        """"""This command stops the output of a waveform or a sequence.""""""
        self.write('AWGControl:STOP')

    def force_trigger(self) -> None:
        """"""
        This command generates a trigger event. This is equivalent to
        pressing the Force Trigger button on front panel.
        """"""
        self.write('*TRG')

    def get_folder_contents(self, print_contents: bool = True) -> str:
        """"""
        This query returns the current contents and state of the mass storage
        media (on the AWG Windows machine).

        Args:
            print_contents: If True, the folder name and the query
                output are printed. Default: True.

        Returns:
            str: A comma-seperated string of the folder contents.
        """"""
        contents = self.ask('MMEMory:CATalog?')
        if print_contents:
            print('Current folder:', self.get_current_folder_name())
            print(contents
                  .replace(',""$', '\n$').replace('"",""', '\n')
                  .replace(',', '\t'))
        return contents

    def get_current_folder_name(self) -> str:
        """"""
        This query returns the current directory of the file system on the
        arbitrary waveform generator. The current directory for the
        programmatic interface is different from the currently selected
        directory in the Windows Explorer on the instrument.

        Returns:
            A string with the full path of the current folder.
        """"""
        return self.ask('MMEMory:CDIRectory?')

    def set_current_folder_name(self, file_path: str) -> int:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator. The current directory for the programmatic
        interface is different from the currently selected directory in the
        Windows Explorer on the instrument.

        Args:
            file_path: The full path.

        Returns:
            The number of bytes written to instrument
        """"""
        writecmd = 'MMEMory:CDIRectory ""{}""'
        return self.visa_handle.write(writecmd.format(file_path))

    def change_folder(self, folder: str) -> int:
        """"""Duplicate of self.set_current_folder_name""""""
        writecmd = r'MMEMory:CDIRectory ""{}""'
        return self.visa_handle.write(writecmd.format(folder))

    def goto_root(self) -> None:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator to C: (the 'root' location in Windows).
        """"""
        self.write('MMEMory:CDIRectory ""c:\\..""')

    def create_and_goto_dir(self, folder: str) -> str:
        """"""
        Set the current directory of the file system on the arbitrary
        waveform generator. Creates the directory if if doesn't exist.
        Queries the resulting folder for its contents.

        Args:
            folder: The path of the directory to set as current.
                Note: this function expects only root level directories.

        Returns:
            A comma-seperated string of the folder contents.
        """"""

        dircheck = '%s, DIR' % folder
        if dircheck in self.get_folder_contents():
            self.change_folder(folder)
            log.debug('Directory already exists')
            log.warning(('Directory already exists, ' +
                         'changed path to {}').format(folder))
            log.info('Contents of folder is ' +
                     '{}'.format(self.ask('MMEMory:cat?')))
        elif self.get_current_folder_name() == f'""\\{folder}""':
            log.info('Directory already set to ' +
                     f'{folder}')
        else:
            self.write('MMEMory:MDIRectory ""%s""' % folder)
            self.write('MMEMory:CDIRectory ""%s""' % folder)

        return self.get_folder_contents()

    def all_channels_on(self) -> None:
        """"""
        Set the state of all channels to be ON. Note: only channels with
        defined waveforms can be ON.
        """"""
        for i in range(1, self.num_channels+1):
            self.set(f'ch{i}_state', 1)

    def all_channels_off(self) -> None:
        """"""Set the state of all channels to be OFF.""""""
        for i in range(1, self.num_channels+1):
            self.set(f'ch{i}_state', 0)

    #####################
    # Sequences section #
    #####################

    def force_trigger_event(self) -> None:
        """"""
        This command generates a trigger event. Equivalent to
        self.force_trigger.
        """"""
        self.write('TRIGger:IMMediate')

    def force_event(self) -> None:
        """"""
        This command generates a forced event. This is used to generate the
        event when the sequence is waiting for an event jump. This is
        equivalent to pressing the Force Event button on the front panel of the
        instrument.
        """"""
        self.write('EVENt:IMMediate')

    def set_sqel_event_target_index(self, element_no: int, index: int) -> None:
        """"""
        This command sets the target index for
        the sequencer’s event jump operation. Note that this will take
        effect only when the event jump target type is set to
        INDEX.

        Args:
            element_no: The sequence element number
            index: The index to set the target to
        """"""
        self.write('SEQuence:' +
                   f'ELEMent{element_no}:JTARGet:INDex {index}')

    def set_sqel_goto_target_index(
            self,
            element_no: int,
            goto_to_index_no: int
    ) -> None:
        """"""
        This command sets the target index for the GOTO command of the
        sequencer.  After generating the waveform specified in a
        sequence element, the sequencer jumps to the element specified
        as GOTO target. This is an unconditional jump. If GOTO target
        is not specified, the sequencer simply moves on to the next
        element. If the Loop Count is Infinite, the GOTO target which
        is specified in the element is not used. For this command to
        work, the goto state of the squencer must be ON and the
        sequence element must exist.
        Note that the first element of a sequence is taken to be 1 not 0.


        Args:
            element_no: The sequence element number
            goto_to_index_no: The target index number

        """"""
        self.write('SEQuence:' +
                   'ELEMent{}:GOTO:INDex {}'.format(element_no,
                                                    goto_to_index_no))

    def set_sqel_goto_state(self, element_no: int, goto_state: int) -> None:
        """"""
        This command sets the GOTO state of the sequencer for the specified
        sequence element.

        Args:
            element_no: The sequence element number
            goto_state: The GOTO state of the sequencer. Must be either
                0 (OFF) or 1 (ON).
        """"""
        allowed_states = [0, 1]
        if goto_state not in allowed_states:
            log.warning(('{} not recognized as a valid goto' +
                         ' state. Setting to 0 (OFF).').format(goto_state))
            goto_state = 0
        self.write('SEQuence:ELEMent{}:GOTO:STATe {}'.format(element_no,
                                                             int(goto_state)))

    def set_sqel_loopcnt_to_inf(self,
                                element_no: int,
                                state: int = 1) -> None:
        """"""
        This command sets the infinite looping state for a sequence
        element. When an infinite loop is set on an element, the
        sequencer continuously executes that element. To break the
        infinite loop, issue self.stop()

        Args:
            element_no (int): The sequence element number
            state (int): The infinite loop state. Must be either 0 (OFF) or
                1 (ON).
        """"""
        allowed_states = [0, 1]
        if state not in allowed_states:
            log.warning(('{} not recognized as a valid loop' +
                         '  state. Setting to 0 (OFF).').format(state))
            state = 0

        self.write('SEQuence:ELEMent{}:LOOP:INFinite {}'.format(element_no,
                                                                int(state)))

    def get_sqel_loopcnt(self, element_no: int = 1) -> str:
        """"""
        This query returns the loop count (number of repetitions) of a
        sequence element. Loop count setting for an element is ignored
        if the infinite looping state is set to ON.

        Args:
            element_no: The sequence element number. Default: 1.
        """"""
        return self.ask(f'SEQuence:ELEMent{element_no}:LOOP:COUNt?')

    def set_sqel_loopcnt(self, loopcount: int, element_no: int = 1) -> None:
        """"""
        This command sets the loop count. Loop count setting for an
        element is ignored if the infinite looping state is set to ON.

        Args:
            loopcount: The number of times the sequence is being output.
                The maximal possible number is 65536, beyond that: infinity.
            element_no: The sequence element number. Default: 1.
        """"""
        self.write('SEQuence:ELEMent{}:LOOP:COUNt {}'.format(element_no,
                                                             loopcount))

    def set_sqel_waveform(
            self,
            waveform_name: str,
            channel: int,
            element_no: int = 1
    ) -> None:
        """"""
        This command sets the waveform for a sequence element on the specified
        channel.

        Args:
            waveform_name: Name of the waveform. Must be in the waveform
                list (either User Defined or Predefined).
            channel: The output channel (1-4)
            element_no: The sequence element number. Default: 1.
        """"""
        self.write('SEQuence:ELEMent{}:WAVeform{} ""{}""'.format(element_no,
                                                               channel,
                                                               waveform_name))

    def get_sqel_waveform(
            self,
            channel: int,
            element_no: int = 1
    ) -> str:
        """"""
        This query returns the waveform for a sequence element on the
        specified channel.

        Args:
            channel: The output channel (1-4)
            element_no: The sequence element number. Default: 1.

        Returns:
            The name of the waveform.
        """"""
        return self.ask('SEQuence:ELEMent{}:WAVeform{}?'.format(element_no,
                                                                channel))

    def set_sqel_trigger_wait(
            self,
            element_no: int,
            state: int = 1) -> str:
        """"""
        This command sets the wait trigger state for an element. Send
        a trigger signal in one of the following ways:

          * By using an external trigger signal.
          * By pressing the “Force Trigger” button on the front panel
          * By using self.force_trigger or self.force_trigger_event

        Args:
            element_no: The sequence element number.
            state: The wait trigger state. Must be either 0 (OFF)
                or 1 (ON). Default: 1.

        Returns:
            The current state (after setting it).

        """"""
        self.write(f'SEQuence:ELEMent{element_no}:TWAit {state}')
        return self.get_sqel_trigger_wait(element_no)

    def get_sqel_trigger_wait(self, element_no: int) -> str:
        """"""
        This query returns the wait trigger state for an element. Send
        a trigger signal in one of the following ways:

          * By using an external trigger signal.
          * By pressing the “Force Trigger” button on the front panel
          * By using self.force_trigger or self.force_trigger_event

        Args:
            element_no: The sequence element number.

        Returns:
            The current state. Example: '1'.
        """"""
        return self.ask(f'SEQuence:ELEMent{element_no}:TWAit?')

    def set_sqel_event_jump_target_index(self,
                                         element_no: int,
                                         jtar_index_no: int) -> None:
        """"""Duplicate of set_sqel_event_target_index""""""
        self.write('SEQuence:ELEMent{}:JTARget:INDex {}'.format(element_no,
                                                                jtar_index_no))

    def set_sqel_event_jump_type(
            self,
            element_no: int,
            jtar_state: str
    ) -> None:
        """"""
        This command sets the event jump target type for the jump for
        the specified sequence element.  Generate an event in one of
        the following ways:

        * By connecting an external cable to instrument rear panel
          for external event.
        * By pressing the Force Event button on the
          front panel.
        * By using self.force_event

        Args:
            element_no: The sequence element number
            jtar_state: The jump target type. Must be either 'INDEX',
                'NEXT', or 'OFF'.
        """"""
        self.write('SEQuence:ELEMent{}:JTARget:TYPE {}'.format(element_no,
                                                               jtar_state))

    def get_sq_mode(self) -> str:
        """"""
        This query returns the type of the arbitrary waveform
        generator's sequencer. The sequence is executed by the
        hardware sequencer whenever possible.

        Returns:
            str: Either 'HARD' or 'SOFT' indicating that the instrument is in\
              either hardware or software sequencer mode.
        """"""
        return self.ask('AWGControl:SEQuence:TYPE?')

    ######################
    # AWG file functions #
    ######################

    def _pack_record(
            self,
            name: str,
            value: Union[float, str, Sequence[Any], np.ndarray],
            dtype: str
    ) -> bytes:
        """"""
        packs awg_file record into a struct in the folowing way:
            struct.pack(fmtstring, namesize, datasize, name, data)
        where fmtstring = '<IIs""dtype""'

        The file record format is as follows:
        Record Name Size:        (32-bit unsigned integer)
        Record Data Size:        (32-bit unsigned integer)
        Record Name:             (ASCII) (Include NULL.)
        Record Data
        For details see ""File and Record Format"" in the AWG help

        < denotes little-endian encoding, I and other dtypes are format
        characters denoted in the documentation of the struct package

        Args:
            name: Name of the record (Example: 'MAGIC' or 'SAMPLING_RATE')
            value: The value of that record.
            dtype: String specifying the data type of the record.
                Allowed values: 'h', 'd', 's'.
        """"""
        if len(dtype) == 1:
            record_data = struct.pack('<' + dtype, value)
        else:
            if dtype[-1] == 's':
                assert isinstance(value, str)
                record_data = value.encode('ASCII')
            else:
                assert isinstance(value, (abc.Sequence, np.ndarray))
                if dtype[-1] == 'H' and isinstance(value, np.ndarray):
                    # numpy conversion is fast
                    record_data = value.astype('<u2').tobytes()
                else:
                    # argument unpacking is slow
                    record_data = struct.pack('<' + dtype, *value)

        # the zero byte at the end the record name is the ""(Include NULL.)""
        record_name = name.encode('ASCII') + b'\x00'
        record_name_size = len(record_name)
        record_data_size = len(record_data)
        size_struct = struct.pack('<II', record_name_size, record_data_size)
        packed_record = size_struct + record_name + record_data

        return packed_record

    def generate_sequence_cfg(self) -> dict[str, float]:
        """"""
        This function is used to generate a config file, that is used when
        generating sequence files, from existing settings in the awg.
        Querying the AWG for these settings takes ~0.7 seconds
        """"""
        log.info('Generating sequence_cfg')

        AWG_sequence_cfg = {
            'SAMPLING_RATE': self.get('clock_freq'),
            'CLOCK_SOURCE': (1 if self.clock_source().startswith('INT')
                             else 2),  # Internal | External
            'REFERENCE_SOURCE': (1 if self.ref_source().startswith('INT')
                                 else 2),  # Internal | External
            'EXTERNAL_REFERENCE_TYPE':   1,  # Fixed | Variable
            'REFERENCE_CLOCK_FREQUENCY_SELECTION': 1,
            # 10 MHz | 20 MHz | 100 MHz
            'TRIGGER_SOURCE':   1 if
            self.get('trigger_source').startswith('EXT') else 2,
            # External | Internal
            'TRIGGER_INPUT_IMPEDANCE': (1 if self.get('trigger_impedance') ==
                                        50. else 2),  # 50 ohm | 1 kohm
            'TRIGGER_INPUT_SLOPE': (1 if self.get('trigger_slope').startswith(
                                    'POS') else 2),  # Positive | Negative
            'TRIGGER_INPUT_POLARITY': (1 if self.ask('TRIGger:' +
                                                     'POLarity?').startswith(
                                       'POS') else 2),  # Positive | Negative
            'TRIGGER_INPUT_THRESHOLD':  self.get('trigger_level'),  # V
            'EVENT_INPUT_IMPEDANCE':   (1 if self.get('event_impedance') ==
                                        50. else 2),  # 50 ohm | 1 kohm
            'EVENT_INPUT_POLARITY':  (1 if self.get('event_polarity').startswith(
                                      'POS') else 2),  # Positive | Negative
            'EVENT_INPUT_THRESHOLD':   self.get('event_level'),  # V
            'JUMP_TIMING':   (1 if
                              self.get('event_jump_timing').startswith('SYNC')
                              else 2),  # Sync | Async
            'RUN_MODE':   4,  # Continuous | Triggered | Gated | Sequence
            'RUN_STATE':  0,  # On | Off
        }
        return AWG_sequence_cfg

    def generate_channel_cfg(self) -> dict[str, Optional[float]]:
        """"""
        Function to query if the current channel settings that have
        been changed from their default value and put them in a
        dictionary that can easily be written into an awg file, so as
        to prevent said awg file from falling back to default values.
        (See :meth:`~make_awg_file` and :meth:`~AWG_FILE_FORMAT_CHANNEL`)
        NOTE: This only works for settings changed via the corresponding
        QCoDeS parameter.

        Returns:
            A dict with the current setting for each entry in
            AWG_FILE_FORMAT_HEAD iff this entry applies to the
            AWG5014 AND has been changed from its default value.
        """"""
        log.info('Getting channel configurations.')

        dirouts = [self.ch1_direct_output.get_latest(),
                   self.ch2_direct_output.get_latest(),
                   self.ch3_direct_output.get_latest(),
                   self.ch4_direct_output.get_latest()]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        filtertrans = {20e6: 1, 100e6: 3, 9.9e37: 10,
                       'INF': 10, 'INFinity': 10,
                       float('inf'): 10, None: None}
        filters = [filtertrans[self.ch1_filter.get_latest()],
                   filtertrans[self.ch2_filter.get_latest()],
                   filtertrans[self.ch3_filter.get_latest()],
                   filtertrans[self.ch4_filter.get_latest()]]

        amps = [self.ch1_amp.get_latest(),
                self.ch2_amp.get_latest(),
                self.ch3_amp.get_latest(),
                self.ch4_amp.get_latest()]

        offsets = [self.ch1_offset.get_latest(),
                   self.ch2_offset.get_latest(),
                   self.ch3_offset.get_latest(),
                   self.ch4_offset.get_latest()]

        mrk1highs = [self.ch1_m1_high.get_latest(),
                     self.ch2_m1_high.get_latest(),
                     self.ch3_m1_high.get_latest(),
                     self.ch4_m1_high.get_latest()]

        mrk1lows = [self.ch1_m1_low.get_latest(),
                    self.ch2_m1_low.get_latest(),
                    self.ch3_m1_low.get_latest(),
                    self.ch4_m1_low.get_latest()]

        mrk2highs = [self.ch1_m2_high.get_latest(),
                     self.ch2_m2_high.get_latest(),
                     self.ch3_m2_high.get_latest(),
                     self.ch4_m2_high.get_latest()]

        mrk2lows = [self.ch1_m2_low.get_latest(),
                    self.ch2_m2_low.get_latest(),
                    self.ch3_m2_low.get_latest(),
                    self.ch4_m2_low.get_latest()]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        addinptrans = {'""ESIG""': 1, '""""': 0, None: None}
        addinputs = [addinptrans[self.ch1_add_input.get_latest()],
                     addinptrans[self.ch2_add_input.get_latest()],
                     addinptrans[self.ch3_add_input.get_latest()],
                     addinptrans[self.ch4_add_input.get_latest()]]

        # the return value of the parameter is different from what goes
        # into the .awg file, so we translate it
        def mrkdeltrans(x: Optional[float]) -> Optional[float]:
            if x is None:
                return None
            else:
                return x * 1e-9
        mrk1delays = [mrkdeltrans(self.ch1_m1_del.get_latest()),
                      mrkdeltrans(self.ch2_m1_del.get_latest()),
                      mrkdeltrans(self.ch3_m1_del.get_latest()),
                      mrkdeltrans(self.ch4_m1_del.get_latest())]
        mrk2delays = [mrkdeltrans(self.ch1_m2_del.get_latest()),
                      mrkdeltrans(self.ch2_m2_del.get_latest()),
                      mrkdeltrans(self.ch3_m2_del.get_latest()),
                      mrkdeltrans(self.ch4_m2_del.get_latest())]

        AWG_channel_cfg: dict[str, Optional[float]] = {}

        for chan in range(1, self.num_channels+1):
            if dirouts[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_DIRECT_OUTPUT_{chan}':
                                        int(dirouts[chan - 1])})
            if filters[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_FILTER_{chan}':
                                        filters[chan - 1]})
            if amps[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_AMPLITUDE_{chan}':
                                        amps[chan - 1]})
            if offsets[chan - 1] is not None:
                AWG_channel_cfg.update({f'ANALOG_OFFSET_{chan}':
                                        offsets[chan - 1]})
            if mrk1highs[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_HIGH_{chan}':
                                        mrk1highs[chan - 1]})
            if mrk1lows[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_LOW_{chan}':
                                        mrk1lows[chan - 1]})
            if mrk2highs[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_HIGH_{chan}':
                                        mrk2highs[chan - 1]})
            if mrk2lows[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_LOW_{chan}':
                                        mrk2lows[chan - 1]})
            if mrk1delays[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER1_SKEW_{chan}':
                                        mrk1delays[chan - 1]})
            if mrk2delays[chan - 1] is not None:
                AWG_channel_cfg.update({f'MARKER2_SKEW_{chan}':
                                        mrk2delays[chan - 1]})
            if addinputs[chan - 1] is not None:
                AWG_channel_cfg.update({f'EXTERNAL_ADD_{chan}':
                                        addinputs[chan - 1]})

        return AWG_channel_cfg

    @staticmethod
    def parse_marker_channel_name(name: str) -> _MarkerDescriptor:
        """"""
        returns from the channel index and marker index from a marker
        descriptor string e.g. '1M1'->(1,1)
        """"""
        res = re.match(r'^(?P<channel>\d+)M(?P<marker>\d+)$',
                       name)
        assert res is not None

        return _MarkerDescriptor(marker=int(res.group('marker')),
                                 channel=int(res.group('channel')))

    def _generate_awg_file(
        self,
        packed_waveforms: dict[str, np.ndarray],
        wfname_l: np.ndarray,
        nrep: Sequence[int],
        trig_wait: Sequence[int],
        goto_state: Sequence[int],
        jump_to: Sequence[int],
        channel_cfg: dict[str, Any],
        sequence_cfg: Optional[dict[str, float]] = None,
        preservechannelsettings: bool = False,
    ) -> bytes:
        """"""
        This function generates an .awg-file for uploading to the AWG.
        The .awg-file contains a waveform list, full sequencing information
        and instrument configuration settings.

        Args:
            packed_waveforms: dictionary containing packed waveforms
                with keys wfname_l

            wfname_l: array of waveform names, e.g.
                array([[segm1_ch1,segm2_ch1..], [segm1_ch2,segm2_ch2..],...])

            nrep: list of len(segments) of integers specifying the
                no. of repetions per sequence element.
                Allowed values: 1 to 65536.

            trig_wait: list of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_state: list of len(segments) of integers specifying the
                goto state of each sequence element. Allowed values: 0 to 65536
                (0 means next)

            jump_to: list of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channel_cfg: dictionary of valid channel configuration
                records. See self.AWG_FILE_FORMAT_CHANNEL for a complete
                overview of valid configuration parameters.

            preservechannelsettings: If True, the current channel
                settings are queried from the instrument and added to
                channel_cfg (does not overwrite). Default: False.

            sequence_cfg: dictionary of valid head configuration records
                     (see self.AWG_FILE_FORMAT_HEAD)
                     When an awg file is uploaded these settings will be set
                     onto the AWG, any parameter not specified will be set to
                     its default value (even overwriting current settings)

        for info on filestructure and valid record names, see AWG Help,
        File and Record Format (Under 'Record Name List' in Help)
        """"""
        if preservechannelsettings:
            channel_settings = self.generate_channel_cfg()
            for setting in channel_settings:
                if setting not in channel_cfg:
                    channel_cfg.update({setting: channel_settings[setting]})

        timetuple = tuple(np.array(localtime())[[0, 1, 8, 2, 3, 4, 5, 6, 7]])

        # general settings
        head_str = BytesIO()
        bytes_to_write = (self._pack_record('MAGIC', 5000, 'h') +
                          self._pack_record('VERSION', 1, 'h'))
        head_str.write(bytes_to_write)
        # head_str.write(string(bytes_to_write))

        if sequence_cfg is None:
            sequence_cfg = self.generate_sequence_cfg()

        for k in list(sequence_cfg.keys()):
            if k in self.AWG_FILE_FORMAT_HEAD:
                head_str.write(self._pack_record(k, sequence_cfg[k],
                                                 self.AWG_FILE_FORMAT_HEAD[k]))
            else:
                log.warning('AWG: ' + k +
                            ' not recognized as valid AWG setting')
        # channel settings
        ch_record_str = BytesIO()
        for k in list(channel_cfg.keys()):
            ch_k = k[:-1] + 'N'
            if ch_k in self.AWG_FILE_FORMAT_CHANNEL:
                pack = self._pack_record(k, channel_cfg[k],
                                         self.AWG_FILE_FORMAT_CHANNEL[ch_k])
                ch_record_str.write(pack)

            else:
                log.warning('AWG: ' + k +
                            ' not recognized as valid AWG channel setting')

        # waveforms
        ii = 21

        wf_record_str = BytesIO()
        wlist = list(packed_waveforms.keys())
        wlist.sort()
        for wf in wlist:
            wfdat = packed_waveforms[wf]
            lenwfdat = len(wfdat)

            wf_record_str.write(
                self._pack_record(f'WAVEFORM_NAME_{ii}', wf + '\x00',
                                  '{}s'.format(len(wf + '\x00'))) +
                self._pack_record(f'WAVEFORM_TYPE_{ii}', 1, 'h') +
                self._pack_record(f'WAVEFORM_LENGTH_{ii}',
                                  lenwfdat, 'l') +
                self._pack_record(f'WAVEFORM_TIMESTAMP_{ii}',
                                  timetuple[:-1], '8H') +
                self._pack_record(f'WAVEFORM_DATA_{ii}', wfdat,
                                  f'{lenwfdat}H'))
            ii += 1

        # sequence
        kk = 1
        seq_record_str = BytesIO()

        for segment in wfname_l.transpose():

            seq_record_str.write(
                self._pack_record(f'SEQUENCE_WAIT_{kk}',
                                  trig_wait[kk - 1], 'h') +
                self._pack_record(f'SEQUENCE_LOOP_{kk}',
                                  int(nrep[kk - 1]), 'l') +
                self._pack_record(f'SEQUENCE_JUMP_{kk}',
                                  jump_to[kk - 1], 'h') +
                self._pack_record(f'SEQUENCE_GOTO_{kk}',
                                  goto_state[kk - 1], 'h'))
            for wfname in segment:
                if wfname is not None:
                    # TODO (WilliamHPNielsen): maybe infer ch automatically
                    # from the data size?
                    ch = wfname[-1]
                    seq_record_str.write(
                        self._pack_record('SEQUENCE_WAVEFORM_NAME_CH_' + ch
                                          + f'_{kk}', wfname + '\x00',
                                          '{}s'.format(len(wfname + '\x00')))
                    )
            kk += 1

        awg_file = (head_str.getvalue() + ch_record_str.getvalue() +
                    wf_record_str.getvalue() + seq_record_str.getvalue())
        return awg_file

    def send_awg_file(
            self,
            filename: str,
            awg_file: bytes,
            verbose: bool = False) -> None:
        """"""
        Writes an .awg-file onto the disk of the AWG.
        Overwrites existing files.

        Args:
            filename: The name that the file will get on
                the AWG.
            awg_file: A byte sequence containing the awg_file.
                Usually the output of self.make_awg_file.
            verbose: A boolean to allow/suppress printing of messages
                about the status of the filw writing. Default: False.
        """"""
        if verbose:
            print('Writing to:',
                  self.ask('MMEMory:CDIRectory?').replace('\n', '\\ '),
                  filename)
        # Header indicating the name and size of the file being send
        name_str = f'MMEMory:DATA ""{filename}"",'.encode('ASCII')
        size_str = ('#' + str(len(str(len(awg_file)))) +
                    str(len(awg_file))).encode('ASCII')
        mes = name_str + size_str + awg_file
        self.visa_handle.write_raw(mes)

    def load_awg_file(self, filename: str) -> None:
        """"""
        Loads an .awg-file from the disc of the AWG into the AWG memory.
        This may overwrite all instrument settings, the waveform list, and the
        sequence in the sequencer.

        Args:
            filename: The filename of the .awg-file to load.
        """"""
        s = f'AWGControl:SREStore ""{filename}""'
        b = s.encode(encoding=""ASCII"")
        log.debug(f'Loading awg file using {s}')
        self.visa_handle.write_raw(b)
        # we must update the appropriate parameter(s) for the sequence
        self.sequence_length.set(self.sequence_length.get())

    def make_awg_file(
            self,
            waveforms: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            m1s: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            m2s: Union[Sequence[Sequence[np.ndarray]], Sequence[np.ndarray]],
            nreps: Sequence[int],
            trig_waits: Sequence[int],
            goto_states: Sequence[int],
            jump_tos: Sequence[int],
            channels: Optional[Sequence[int]] = None,
            preservechannelsettings: bool = True) -> bytes:
        """"""
        Args:
            waveforms: A list of the waveforms to be packed. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetitions per sequence element.  Allowed values: 0 to
                65536. O corresponds to Infinite repetitions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels (list): List of channels to send the waveforms to.
                Example: [1, 3, 2]

            preservechannelsettings (bool): If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are not written in the
                file and will be reset to factory default when the file is
                loaded. Default: True.
            """"""
        packed_wfs = {}
        waveform_names = []
        if not isinstance(waveforms[0], abc.Sequence):
            waveforms_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], waveforms)]
            m1s_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], m1s)]
            m2s_int: Sequence[Sequence[np.ndarray]] = [cast(Sequence[np.ndarray], m2s)]
        else:
            waveforms_int = cast(Sequence[Sequence[np.ndarray]], waveforms)
            m1s_int = cast(Sequence[Sequence[np.ndarray]], m1s)
            m2s_int = cast(Sequence[Sequence[np.ndarray]], m2s)

        for ii in range(len(waveforms_int)):
            namelist = []
            for jj in range(len(waveforms_int[ii])):
                if channels is None:
                    thisname = f""wfm{jj + 1:03d}ch{ii + 1}""
                else:
                    thisname = f""wfm{jj + 1:03d}ch{channels[ii]}""
                namelist.append(thisname)

                package = self._pack_waveform(waveforms_int[ii][jj],
                                              m1s_int[ii][jj],
                                              m2s_int[ii][jj])

                packed_wfs[thisname] = package
            waveform_names.append(namelist)

        wavenamearray = np.array(waveform_names, dtype='str')

        channel_cfg: dict[str, Any] = {}

        return self._generate_awg_file(
            packed_wfs, wavenamearray, nreps, trig_waits, goto_states,
            jump_tos, channel_cfg,
            preservechannelsettings=preservechannelsettings)

    def make_send_and_load_awg_file(
            self,
            waveforms: Sequence[Sequence[np.ndarray]],
            m1s: Sequence[Sequence[np.ndarray]],
            m2s: Sequence[Sequence[np.ndarray]],
            nreps: Sequence[int],
            trig_waits: Sequence[int],
            goto_states: Sequence[int],
            jump_tos: Sequence[int],
            channels: Optional[Sequence[int]] = None,
            filename: str = 'customawgfile.awg',
            preservechannelsettings: bool = True
    ) -> None:
        """"""
        Makes an .awg-file, sends it to the AWG and loads it. The .awg-file
        is uploaded to C:\\\\Users\\\\OEM\\\\Documents. The waveforms appear in
        the user defined waveform list with names wfm001ch1, wfm002ch1, ...

        Args:
            waveforms: A list of the waveforms to upload. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetions per sequence element.  Allowed values: 0 to
                65536. 0 corresponds to Infinite repetions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels: List of channels to send the waveforms to.
                Example: [1, 3, 2]

            filename: The name of the .awg-file. Should end with the .awg
                extension. Default: 'customawgfile.awg'

            preservechannelsettings: If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are reset to the factory
                default values. Default: True.
        """"""

        # waveform names and the dictionary of packed waveforms
        awg_file = self.make_awg_file(
            waveforms, m1s, m2s, nreps, trig_waits,
            goto_states, jump_tos, channels=channels,
            preservechannelsettings=preservechannelsettings)

        # by default, an unusable directory is targeted on the AWG
        self.visa_handle.write('MMEMory:CDIRectory ' +
                               '""C:\\Users\\OEM\\Documents""')

        self.send_awg_file(filename, awg_file)
        currentdir = self.visa_handle.query('MMEMory:CDIRectory?')
        currentdir = currentdir.replace('""', '')
        currentdir = currentdir.replace('\n', '\\')
        loadfrom = f'{currentdir}{filename}'
        self.load_awg_file(loadfrom)

    def make_and_save_awg_file(self,
                               waveforms: Sequence[Sequence[np.ndarray]],
                               m1s: Sequence[Sequence[np.ndarray]],
                               m2s: Sequence[Sequence[np.ndarray]],
                               nreps: Sequence[int],
                               trig_waits: Sequence[int],
                               goto_states: Sequence[int],
                               jump_tos: Sequence[int],
                               channels: Optional[Sequence[int]] = None,
                               filename: str = 'customawgfile.awg',
                               preservechannelsettings: bool = True) -> None:
        """"""
        Makes an .awg-file and saves it locally.

        Args:
            waveforms: A list of the waveforms to upload. The list
                should be filled like so:
                [[wfm1ch1, wfm2ch1, ...], [wfm1ch2, wfm2ch2], ...]
                Each waveform should be a numpy array with values in the range
                -1 to 1 (inclusive). If you do not wish to send waveforms to
                channels 1 and 2, use the channels parameter.

            m1s: A list of marker 1's. The list should be filled
                like so:
                [[elem1m1ch1, elem2m1ch1, ...], [elem1m1ch2, elem2m1ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            m2s: A list of marker 2's. The list should be filled
                like so:
                [[elem1m2ch1, elem2m2ch1, ...], [elem1m2ch2, elem2m2ch2], ...]
                Each marker should be a numpy array containing only 0's and 1's

            nreps: List of integers specifying the no. of
                repetions per sequence element.  Allowed values: 0 to
                65536. O corresponds to Infinite repetions.

            trig_waits: List of len(segments) of integers specifying the
                trigger wait state of each sequence element.
                Allowed values: 0 (OFF) or 1 (ON).

            goto_states: List of len(segments) of integers
                specifying the goto state of each sequence
                element. Allowed values: 0 to 65536 (0 means next)

            jump_tos: List of len(segments) of integers specifying
                the logic jump state for each sequence element. Allowed values:
                0 (OFF) or 1 (ON).

            channels: List of channels to send the waveforms to.
                Example: [1, 3, 2]

            preservechannelsettings: If True, the current channel
                settings are found from the parameter history and added to
                the .awg file. Else, channel settings are not written in the
                file and will be reset to factory default when the file is
                loaded. Default: True.

            filename: The full path of the .awg-file. Should end with the
                .awg extension. Default: 'customawgfile.awg'
        """"""
        awg_file = self.make_awg_file(
            waveforms, m1s, m2s, nreps, trig_waits,
            goto_states, jump_tos, channels=channels,
            preservechannelsettings=preservechannelsettings)
        with open(filename, 'wb') as fid:
            fid.write(awg_file)

    def get_error(self) -> str:
        """"""
        This function retrieves and returns data from the error and
        event queues.

        Returns:
            String containing the error/event number, the error/event
            description.
        """"""
        return self.ask('SYSTEM:ERRor:NEXT?')

    def _pack_waveform(
            self,
            wf: np.ndarray,
            m1: np.ndarray,
            m2: np.ndarray
    ) -> np.ndarray:
        """"""
        Converts/packs a waveform and two markers into a 16-bit format
        according to the AWG Integer format specification.
        The waveform occupies 14 bits and the markers one bit each.
        See Table 2-25 in the Programmer's manual for more information

        Since markers can only be in one of two states, the marker input
        arrays should consist only of 0's and 1's.

        Args:
            wf: A numpy array containing the waveform. The
                data type of wf is unimportant.
            m1: A numpy array containing the first marker.
            m2: A numpy array containing the second marker.

        Returns:
            An array of unsigned 16 bit integers.

        Raises:
            Exception: if the lengths of w, m1, and m2 don't match
            TypeError: if the waveform contains values outside (-1, 1)
            TypeError: if the markers contain values that are not 0 or 1
        """"""

        # Input validation
        if (not((len(wf) == len(m1)) and (len(m1) == len(m2)))):
            raise Exception('error: sizes of the waveforms do not match')
        if np.min(wf) < -1 or np.max(wf) > 1:
            raise TypeError('Waveform values out of bonds.' +
                            ' Allowed values: -1 to 1 (inclusive)')
        if not np.all(np.in1d(m1, np.array([0, 1]))):
            raise TypeError('Marker 1 contains invalid values.' +
                            ' Only 0 and 1 are allowed')
        if not np.all(np.in1d(m2, np.array([0, 1]))):
            raise TypeError('Marker 2 contains invalid values.' +
                            ' Only 0 and 1 are allowed')

        # Note: we use np.trunc here rather than np.round
        # as it is an order of magnitude faster
        packed_wf = np.trunc(16384 * m1 + 32768 * m2
                             + wf * 8191 + 8191.5).astype(np.uint16)

        if len(np.where(packed_wf == -1)[0]) > 0:
            print(np.where(packed_wf == -1))
        return packed_wf

    ###########################
    # Waveform file functions #
    ###########################

    def _file_dict(
        self, wf: np.ndarray, m1: np.ndarray, m2: np.ndarray, clock: Optional[float]
    ) -> dict[str, Union[np.ndarray, float, None]]:
        """"""
        Make a file dictionary as used by self.send_waveform_to_list

        Args:
            wf: A numpy array containing the waveform. The
                data type of wf is unimportant.
            m1: A numpy array containing the first marker.
            m2: A numpy array containing the second marker.
            clock: The desired clock frequency

        Returns:
            dict: A dictionary with keys 'w', 'm1', 'm2', 'clock_freq', and
                'numpoints' and corresponding values.
        """"""

        outdict = {
            'w': wf,
            'm1': m1,
            'm2': m2,
            'clock_freq': clock,
            'numpoints': len(wf)
        }

        return outdict

    def delete_all_waveforms_from_list(self) -> None:
        """"""
        Delete all user-defined waveforms in the list in a single
        action. Note that there is no “UNDO” action once the waveforms
        are deleted. Use caution before issuing this command.

        If the deleted waveform(s) is (are) currently loaded into
        waveform memory, it (they) is (are) unloaded. If the RUN state
        of the instrument is ON, the state is turned OFF. If the
        channel is on, it will be switched off.
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    def get_filenames(self) -> str:
        """"""Duplicate of self.get_folder_contents""""""
        return self.ask('MMEMory:CATalog?')

    def send_DC_pulse(self,
                      DC_channel_number: int,
                      set_level: float,
                      length: float) -> None:
        """"""
        Sets the DC level on the specified channel, waits a while and then
        resets it to what it was before.

        Note: Make sure that the output DC state is ON.

        Args:
            DC_channel_number (int): The channel number (1-4).
            set_level (float): The voltage level to set to (V).
            length (float): The time to wait before resetting (s).
        """"""
        DC_channel_number -= 1
        chandcs = [self.ch1_DC_out, self.ch2_DC_out, self.ch3_DC_out,
                   self.ch4_DC_out]

        restore = chandcs[DC_channel_number].get()
        chandcs[DC_channel_number].set(set_level)
        sleep(length)
        chandcs[DC_channel_number].set(restore)

    def is_awg_ready(self) -> bool:
        """"""
        Assert if the AWG is ready.

        Returns:
            True, irrespective of anything.
        """"""
        try:
            self.ask('*OPC?')
        # makes the awg read again if there is a timeout
        except Exception as e:
            log.warning(e)
            log.warning('AWG is not ready')
            self.visa_handle.read()
        return True

    def send_waveform_to_list(
            self,
            w: np.ndarray,
            m1: np.ndarray,
            m2: np.ndarray,
            wfmname: str) -> None:
        """"""
        Send a single complete waveform directly to the ""User defined""
        waveform list (prepend it). The data type of the input arrays
        is unimportant, but the marker arrays must contain only 1's
        and 0's.

        Args:
            w: The waveform
            m1: Marker1
            m2: Marker2
            wfmname: waveform name

        Raises:
            Exception: if the lengths of w, m1, and m2 don't match
            TypeError: if the waveform contains values outside (-1, 1)
            TypeError: if the markers contain values that are not 0 or 1
        """"""
        log.debug(f'Sending waveform {wfmname} to instrument')
        # Check for errors
        dim = len(w)

        # Input validation
        if (not((len(w) == len(m1)) and (len(m1) == len(m2)))):
            raise Exception('error: sizes of the waveforms do not match')
        if min(w) < -1 or max(w) > 1:
            raise TypeError('Waveform values out of bonds.' +
                            ' Allowed values: -1 to 1 (inclusive)')
        if (list(m1).count(0) + list(m1).count(1)) != len(m1):
            raise TypeError('Marker 1 contains invalid values.' +
                            ' Only 0 and 1 are allowed')
        if (list(m2).count(0) + list(m2).count(1)) != len(m2):
            raise TypeError('Marker 2 contains invalid values.' +
                            ' Only 0 and 1 are allowed')

        self._values['files'][wfmname] = self._file_dict(w, m1, m2, None)

        # if we create a waveform with the same name but different size,
        # it will not get over written
        # Delete the possibly existing file (will do nothing if the file
        # doesn't exist
        s = f'WLISt:WAVeform:DEL ""{wfmname}""'
        self.write(s)

        # create the waveform
        s = f'WLISt:WAVeform:NEW ""{wfmname}"",{dim:d},INTEGER'
        self.write(s)
        # Prepare the data block
        number = ((2**13 - 1) + (2**13 - 1) * w + 2**14 *
                  np.array(m1) + 2**15 * np.array(m2))
        number = number.astype('int')
        ws_array = arr.array('H', number)

        ws = ws_array.tobytes()
        s1_str = f'WLISt:WAVeform:DATA ""{wfmname}"",'
        s1 = s1_str.encode('UTF-8')
        s3 = ws
        s2_str = '#' + str(len(str(len(s3)))) + str(len(s3))
        s2 = s2_str.encode('UTF-8')

        mes = s1 + s2 + s3
        self.visa_handle.write_raw(mes)

    def clear_message_queue(self, verbose: bool = False) -> None:
        """"""
        Function to clear up (flush) the VISA message queue of the AWG
        instrument. Reads all messages in the queue.

        Args:
            verbose: If True, the read messages are printed.
                Default: False.
        """"""
        original_timeout = self.visa_handle.timeout
        self.visa_handle.timeout = 1000  # 1 second as VISA counts in ms
        gotexception = False
        while not gotexception:
            try:
                message = self.visa_handle.read()
                if verbose:
                    print(message)
            except VisaIOError:
                gotexception = True
        self.visa_handle.timeout = original_timeout


class Tektronix_AWG5014(TektronixAWG5014):
    """"""
    Alias with non-conformant name left for backwards compatibility
    """"""

    pass
"
339,110.6,"Cleveland, Ohio, United States","The 2636B from Keithley is a 2600B series dual channel system SourceMeter® (SMU) instrument (0.1fA, 10A pulse). It is an industry’s leading current/voltage source and measure solutions. This dual channel model combines the capabilities of a precision power supply, true current source, 6 1/2 digit DMM, arbitrary waveform generator, pulse generator and electronic load all into one tightly integrated instrument. The result is a powerful solution that significantly boosts productivity in applications ranging from bench-top I-V characterization through highly automated production test. It has 100mV to 40V voltage, 100nA to 10A current measurement range (source). This is tightly integrated, 4-quadrant voltage/current source and measure instrument which offers best in class performance with 6 1/2digit resolution. Built-in web browser based software enables remote control through any browser, on any computer, from anywhere in the world.",Keithley 2636 B,265.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2636B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2636B,https://www.testequipmenthq.com/datasheets/KEITHLEY-2636B-Datasheet.pdf,"[OrderedDict([('id', 'attWTucviVCSlbPmo'), ('width', 320), ('height', 145), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IQLIBs-PpCmgoWxCSJ88TQ/2HT1vcrBUnhtqGeMWbi1XTjma9xRBW5_qPny3UKtOm7v-UnE6nETbbV1PIxMO8idgy1GbIbmzdMs2rmlisfOJrHLDEIm9FG6_CpymZME4DU/6QVqBm3NFl4QUKxJjCc_xXUCI-nPBFveTBiqk2DCKA4'), ('filename', '2636b.webp'), ('size', 7332), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KGF_Yojgl8iDuac4STDQRQ/D6fwyzf6q8xbFiGmH-nSoQFlkXUH8CVMeJ2Hene6vCArBFCa4kYYeB6Q9GMLfyX11cah09mBqLVyEXXMx8uep_73pxvoGe6Dted45zzC6ss/MjnQBxSYr6jMNs4Ws7uPpIEcY2WNKvr0DIqp9n770KA'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/fEFCVZCTBUPcdWO_QFb46Q/cs8cJcgyaNTRk3ei5p0hT3CGcYnQp8Xj6vaDZErJOEse_iIGGXCPL0CYuwGmw_q4IEizQAnRzrOSbe55hxiuTmzSxxngEkMg26YYFVNpafg/_eOWo2VZYgfROpqp8xdlLoEciUxAqSp8kOMwddrItcI'), ('width', 320), ('height', 145)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h-UbYqBSIGcq6IT06OwSzg/Ooe-mpulaImFQsZwBxeYTEJM7WaaF5N4Xof1-u8xAMT6MhBzCqDEojkLhlbpx5IltC70_SAFaHHIxhfWIeqQCqRCnd634TKbmlFtow2enEc/VMz-LljJGgNtkmGFWHAQjaNlrhGOLsEWX-2lAcxotho'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newark.com/keithley/2636b/source-meter-voltage-current-30/dp/44W8041,https://github.com/AFMD/keithley-2636/blob/master/k2636.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2636B,23900.0,,,,"""""""
Module for interacting with the Keithley 2636B SMU.

Author:  Ross <peregrine dot warren at physics dot ox dot ac dot uk>
""""""

import visa
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.style as style
import time
from serial import SerialException


class K2636():
    """"""Class for Keithley control.""""""

    def __init__(self, address='ASRL/dev/ttyUSB0', read_term='\n',
                 baudrate=57600):
        """"""Make instrument connection instantly on calling class.""""""
        rm = visa.ResourceManager('@py')  # use py-visa backend
        self.makeConnection(rm, address, read_term, baudrate)

    def makeConnection(self, rm, address, read_term, baudrate):
        """"""Make initial connection to instrument.""""""
        try:
            if 'ttyS' or 'ttyUSB' in str(address):
                # Connection via SERIAL
                self.inst = rm.open_resource(address)
                self.inst.read_termination = str(read_term)
                self.inst.baud_rate = baudrate

            if 'GPIB' in str(address):
                # Connection via GPIB
                print('No GPIB support. Please use serial')

        except SerialException:
            print(""CONNECTION ERROR: Check instrument address."")
            raise ConnectionError

    def closeConnection(self):
        """"""Close connection to keithley.""""""
        try:
            self.inst.close()

        except(NameError):
            print('CONNECTION ERROR: No connection established.')

        except(AttributeError):
            print('CONNECTION ERROR: No connection established.')

    def _write(self, m):
        """"""Write to instrument.""""""
        try:
            assert type(m) == str
            self.inst.write(m)
        except AttributeError:
            print('CONNECTION ERROR: No connection established.')

    def _read(self):
        """"""Read instrument.""""""
        r = self.inst.read()
        return r

    def _query(self, s):
        """"""Query instrument.""""""
        try:
            r = self.inst.query(s)
            return r
        except SerialException:
            return ('Serial port busy, try again.')
        except FileNotFoundError:
            return ('CONNECTION ERROR: No connection established.')
        except AttributeError:
            print('CONNECTION ERROR: No connection established.')
            return ('CONNECTION ERROR: No connection established.')

    def loadTSP(self, tsp):
        """"""Load an anonymous TSP script into the K2636 nonvolatile memory.""""""
        try:
            tsp_dir = 'TSP-scripts/'  # Put all tsp scripts in this folder
            self._write('loadscript')
            line_count = 1
            for line in open(str(tsp_dir + tsp), mode='r'):
                self._write(line)
                line_count += 1
            self._write('endscript')
            print('----------------------------------------')
            print('Uploaded TSP script: ', tsp)

        except FileNotFoundError:
            print('ERROR: Could not find tsp script. Check path.')
            raise SystemExit

    def runTSP(self):
        """"""Run the anonymous TSP script currently loaded in the K2636 memory.""""""
        self._write('script.anonymous.run()')
        print('Measurement in progress...')

    def readBuffer(self):
        """"""Read buffer in memory and return an array.""""""
        try:
            vg = [float(x) for x in self._query('printbuffer' +
                  '(1, smub.nvbuffer1.n, smub.nvbuffer1.sourcevalues)').split(',')]
            ig = [float(x) for x in self._query('printbuffer' +
                  '(1, smub.nvbuffer1.n, smub.nvbuffer1.readings)').split(',')]
            vd = [float(x) for x in self._query('printbuffer' +
                  '(1, smua.nvbuffer1.n, smua.nvbuffer1.sourcevalues)').split(',')]
            c = [float(x) for x in self._query('printbuffer' +
                 '(1, smua.nvbuffer1.n, smua.nvbuffer1.readings)').split(',')]

            df = pd.DataFrame({'Gate Voltage [V]': vg,
                               'Channel Voltage [V]': vd,
                               'Channel Current [A]': c,
                               'Gate Leakage [A]': ig})
            return df

        except SerialException:
            print('Cannot read buffer.')
            return

    def readBufferIV(self):
        """"""Read specified buffer in keithley memory and return an array.""""""
        vd = [float(x) for x in self._query('printbuffer' +
              '(1, smua.nvbuffer1.n, smua.nvbuffer1.sourcevalues)').split(',')]
        c = [float(x) for x in self._query('printbuffer' +
             '(1, smua.nvbuffer1.n, smua.nvbuffer1.readings)').split(',')]
        df = pd.DataFrame({'Channel Voltage [V]': vd, 'Channel Current [A]': c})
        return df
    
    def readBufferInverter(self):
        """"""Read specified buffer for inverter measurement.""""""
        SMUAsrc = [float(x) for x in self._query('printbuffer' +
              '(1, smua.nvbuffer1.n, smua.nvbuffer1.sourcevalues)').split(',')]
        SMUAread = [float(x) for x in self._query('printbuffer' +
             '(1, smua.nvbuffer1.n, smua.nvbuffer1.readings)').split(',')]
        SMUBsrc = [float(x) for x in self._query('printbuffer' +
             '(1, smub.nvbuffer1.n, smub.nvbuffer1.sourcevalues)').split(',')]
        SMUBread = [float(x) for x in self._query('printbuffer' +
             '(1, smub.nvbuffer1.n, smub.nvbuffer1.readings)').split(',')]        
        df = pd.DataFrame({'Voltage In [V]': SMUAread, 'Voltage Out [V]': SMUBread, 'SMUA source': SMUAsrc, 'SMUB source': SMUBsrc})
        return df    

    def DisplayMeasurement(self, sample):
        """"""Show graphs of measurements.""""""
        try:
            style.use('ggplot')
            fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2, 2, figsize=(20, 10),
                                                         dpi=80, facecolor='w',
                                                         edgecolor='k')

            df1 = pd.read_csv(str(sample+'-iv-sweep.csv'), '\t')
            ax1.plot(df1['Channel Voltage [V]'],
                     df1['Channel Current [A]'], '.')
            ax1.set_title('I-V sweep')
            ax1.set_xlabel('Channel Voltage [V]')
            ax1.set_ylabel('Channel Current [A]')

            df2 = pd.read_csv(str(sample+'-output.csv'), '\t')
            ax2.plot(df2['Channel Voltage [V]'],
                     df2['Channel Current [A]'], '.')
            ax2.set_title('Output curves')
            ax2.set_xlabel('Channel Voltage [V]')
            ax2.set_ylabel('Channel Current [A]')

            df3 = pd.read_csv(str(sample+'-transfer.csv'), '\t')
            ax3.plot(df3['Gate Voltage [V]'],
                     df3['Channel Current [A]'], '.')
            ax3.set_title('Transfer Curves')
            ax3.set_xlabel('Gate Voltage [V]')
            ax3.set_ylabel('Channel Current [A]')

            df4 = pd.read_csv(str(sample+'-transfer.csv'), '\t')
            ax4.plot(df4['Gate Voltage [V]'],
                     df4['Gate Leakage [A]'], '.')
            ax4.set_title('Gate leakage current')
            ax4.set_xlabel('Gate Voltage [V]')
            ax4.set_ylabel('Gate Leakage [A]')

            fig.tight_layout()
            fig.savefig(sample)
            plt.show()

        except(FileNotFoundError):
            print('Sample name not found.')

    def IVsweep(self, sample):
        """"""K2636 IV sweep.""""""
        try:
            begin_time = time.time()
            self.loadTSP('iv-sweep.tsp')
            self.runTSP()
            df = self.readBufferIV()
            output_name = str(sample + '-iv-sweep.csv')
            df.to_csv(output_name, sep='\t', index=False)
            finish_time = time.time()
            print('IV sweep complete. Elapsed time %.2f mins.'
                  % ((finish_time - begin_time)/60))

        except(AttributeError):
            print('Cannot perform IV sweep: no keithley connected.')

    def Output(self, sample):
        """"""K2636 Output sweeps.""""""
        try:
            begin_time = time.time()
            self.loadTSP('output-charact.tsp')
            self.runTSP()
            df = self.readBuffer()
            output_name = str(sample + '-output.csv')
            df.to_csv(output_name, sep='\t', index=False)
            finish_time = time.time()
            print('Output sweeps complete. Elapsed time %.2f mins.'
                  % ((finish_time - begin_time) / 60))

        except(AttributeError):
            print('Cannot perform output sweep: no keithley connected.')

    def Transfer(self, sample):
        """"""K2636 Transfer sweeps.""""""
        try:
            begin_time = time.time()
            self.loadTSP('transfer-charact.tsp')
            self.runTSP()
            df = self.readBuffer()
            output_name = str(sample + '-neg-pos-transfer.csv')
            df.to_csv(output_name, sep='\t', index=False)

            # transfer reverse scan
            self.loadTSP('transfer-charact-2.tsp')
            self.runTSP()
            df = self.readBuffer()
            output_name = str(sample + '-pos-neg-transfer.csv')
            df.to_csv(output_name, sep='\t', index=False)

            finish_time = time.time()
            print('Transfer curves measured. Elapsed time %.2f mins.'
                  % ((finish_time - begin_time) / 60))

        except(AttributeError):
            print('Cannot perform transfer sweep: no keithley connected.')

    def Inverter(self, sample):
        """"""K2636 inverter measurement.""""""
        try:
            begin_time = time.time()
            self.loadTSP('inverter.tsp')
            self.runTSP()
            df = self.readBufferInverter()
            output_name = str(sample + '-neg-pos-inverter.csv')
            df.to_csv(output_name, sep='\t', index=False)
            
            # inverter reverse scan
            self.loadTSP('inverter-reverse.tsp')
            self.runTSP()
            df = self.readBufferInverter()
            output_name = str(sample + '-pos-neg-inverter.csv')
            df.to_csv(output_name, sep='\t', index=False)            
            
            finish_time = time.time()
            print('Inverter measurement complete. Elapsed time %.2f mins.'
                  % ((finish_time - begin_time) / 60))

        except(AttributeError):
            print('Cannot perform output sweep: no keithley connected.')
########################################################################


if __name__ == '__main__':
    """"""For testing methods in the K2636 class.""""""
    keithley = K2636(address='ASRL/dev/ttyUSB0', read_term='\n', baudrate=57600)
    sample = 'blank-20-1'
    keithley.IVsweep(sample)
    # keithley.Output(sample)
    # keithley.Transfer(sample)
    # keithley.DisplayMeasurement(sample)
    keithley.closeConnection()
"
340,,,,Stahl,528.0,,Qcodes,Stahl,,,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stahl/stahl.py,https://qcodes.github.io/Qcodes/drivers_api/Stahl.html#qcodes.instrument_drivers.stahl.Stahl,,,,,"""""""
This is a driver for the Stahl power supplies
""""""

import logging
import re
from collections import OrderedDict
from collections.abc import Iterable
from functools import partial
from typing import Any, Callable, Optional

import numpy as np
from pyvisa.resources.serial import SerialInstrument

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.validators import Numbers

logger = logging.getLogger()


def chain(*functions: Callable[..., Any]) -> Callable[..., Any]:
    """"""
    The output of the first callable is piped to the input of the second, etc.

    Example:
        >>> def f():
        >>>   return ""1.2""
        >>> chain(f, float)()  # return 1.2 as float
    """"""

    def make_iter(args: Any) -> Iterable[Any]:
        if not isinstance(args, Iterable) or isinstance(args, str):
            return args,
        return args

    def inner(*args: Any) -> Any:
        result = args
        for fun in functions:
            new_args = make_iter(result)
            result = fun(*new_args)

        return result

    return inner


class StahlChannel(InstrumentChannel):
    """"""
    A Stahl source channel

    Args:
        parent
        name
        channel_number
    """"""

    acknowledge_reply = chr(6)

    def __init__(self, parent: VisaInstrument, name: str, channel_number: int):
        super().__init__(parent, name)

        self._channel_string = f""{channel_number:02d}""
        self._channel_number = channel_number

        self.add_parameter(
            ""voltage"",
            get_cmd=f""{self.parent.identifier} U{self._channel_string}"",
            get_parser=chain(
                re.compile(r""^([+\-]\d+,\d+) V$"").findall,
                partial(re.sub, "","", "".""),
                float
            ),
            set_cmd=self._set_voltage,
            unit=""V"",
            vals=Numbers(
                -self.parent.voltage_range,
                self.parent.voltage_range
            )
        )

        self.add_parameter(
            ""current"",
            get_cmd=f""{self.parent.identifier} I{self._channel_string}"",
            get_parser=chain(
                re.compile(r""^([+\-]\d+,\d+) mA$"").findall,
                partial(re.sub, "","", "".""),
                lambda ma: float(ma) / 1000  # Convert mA to A
            ),
            unit=""A"",
        )

        self.add_parameter(
            ""is_locked"",
            get_cmd=self._get_lock_status
        )

    def _set_voltage(self, voltage: float) -> None:
        """"""
        Args:
            voltage
        """"""
        # Normalize the voltage in the range 0 to 1, where 0 is maximum negative
        # voltage and 1 is maximum positive voltage
        voltage_normalized = np.interp(
            voltage,
            self.parent.voltage_range * np.array([-1, 1]),
            [0, 1]
        )

        send_string = f""{self.parent.identifier} CH{self._channel_string} "" \
            f""{voltage_normalized:.5f}""
        response = self.ask(send_string)

        if response != self.acknowledge_reply:
            self.log.warning(
                f""Command {send_string} did not produce an acknowledge reply"")

    def _get_lock_status(self) -> bool:
        """"""
        A lock occurs when an output is overloaded

        Return:
            lock_status: True when locked
        """"""
        send_string = f""{self.parent.identifier} LOCK""

        response = self.parent.visa_handle.query_binary_values(
            send_string,
            datatype='B',
            header_fmt=""empty""
        )

        channel_index = self._channel_number - 1
        channel_group = channel_index // 4
        lock_code_group = response[channel_group]
        return format(lock_code_group, ""b"")[channel_index % 4 + 1] == ""1""


class Stahl(VisaInstrument):
    """"""
    Stahl driver.

    Args:
        name
        address: A serial port address
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, terminator=""\r"", **kwargs)
        assert isinstance(self.visa_handle, SerialInstrument)

        self.visa_handle.baud_rate = 115200

        instrument_info = self.parse_idn_string(
            self.ask(""IDN"")
        )

        for key, value in instrument_info.items():
            setattr(self, key, value)

        channels = ChannelList(
            self, ""channel"", StahlChannel, snapshotable=False
        )

        for channel_number in range(1, self.n_channels + 1):
            name = f""channel{channel_number}""
            channel = StahlChannel(
                self,
                name,
                channel_number
            )
            self.add_submodule(name, channel)
            channels.append(channel)

        self.add_submodule(""channel"", channels)

        self.add_parameter(
            ""temperature"",
            get_cmd=f""{self.identifier} TEMP"",
            get_parser=chain(
                re.compile(""^TEMP (.*)°C$"").findall,
                float
            ),
            unit=""C""
        )

        self.connect_message()

    def ask_raw(self, cmd: str) -> str:
        """"""
        Sometimes the instrument returns non-ascii characters in response
        strings manually adjust the encoding to latin-1
        """"""
        self.visa_log.debug(f""Querying: {cmd}"")
        self.visa_handle.write(cmd)
        response = self.visa_handle.read(encoding=""latin-1"")
        self.visa_log.debug(f""Response: {response}"")
        return response

    @staticmethod
    def parse_idn_string(idn_string: str) -> dict[str, Any]:
        """"""
        Return:
             dict: The dict contains the following keys ""model"",
             ""serial_number"", ""voltage_range"",""n_channels"", ""output_type""
        """"""
        result = re.search(
            r""(HV|BS)(\d{3}) (\d{3}) (\d{2}) ([buqsm])"",
            idn_string
        )

        if result is None:
            raise RuntimeError(
                ""Unexpected instrument response. Perhaps the model of the ""
                ""instrument does not match the drivers expectation or a ""
                ""firmware upgrade has taken place. Please get in touch ""
                ""with a QCoDeS core developer""
            )

        converters: dict[str, Callable[..., Any]] = OrderedDict(
            {
                ""model"": str,
                ""serial_number"": str,
                ""voltage_range"": float,
                ""n_channels"": int,
                ""output_type"": {
                    ""b"": ""bipolar"",
                    ""u"": ""unipolar"",
                    ""q"": ""quadrupole"",
                    ""s"": ""steerer"",
                    ""m"": ""bipolar milivolt"",
                }.get,
            }
        )

        return {
            name: converter(value)
            for (name, converter), value in zip(converters.items(), result.groups())
        }

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        The Stahl sends a uncommon IDN string which does not include a
        firmware version.
        """"""
        return {
            ""vendor"": ""Stahl"",
            ""model"": self.model,
            ""serial"": self.serial_number,
            ""firmware"": None
        }

    @property
    def identifier(self) -> str:
        return f""{self.model}{self.serial_number}""
"
342,110.6,"Cleveland, Ohio, United States","The 2614B SourceMeter SMU Instrument is a new dual-channel SMU instrument with best-in-class value and performance. Its tightly integrated, four-quadrant design allows it to simultaneously source and measure both voltage and current to boost productivity in R&D and bench-top applications. The Model 2614B is equipped with Keithley's high speed TSP technology, which is over 190% faster than traditional PC-to-instrument communication techniques. The Model 2614B is designed for bench-top applications and, therefore, does not have the high-end, system-level automation features of the Model 2612B SourceMeter SMU Instrument, which includes digital I/O, TSP-Link technology, and contact check function.",Keithley 2614 B,268.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 2614B Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Keithley 2614B,https://download.tek.com/datasheet/1KW-60906-0_Series_2600BDatasheet_112718.pdf,"[OrderedDict([('id', 'atteZ4wUgdO693Swh'), ('width', 320), ('height', 143), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qVs21GM8TXlgzN-K9zXPiA/6Wm2aJdAa5n0CUwtZMHMewiGTjTOYlJjXi6phdwqeAQVMTqzOeuIsCUoUkFbG46cu7EBwHdELAnK12zk63oSAMXwi1VdlYhb4Z9fWWCHYzE/9OjQmk4R2rkuFZ6J4gaP_Mhfpw2oBfklBXErLo7o050'), ('filename', '2614b.webp'), ('size', 7384), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xzfDVQLR2FyWiSB-tEGbqw/2l_UUX2mx6-_O2Ou86_2_o5mNaLmiEmuoJFvjFqQCr-lKDzIgq0LLkOZe7zbpMPbe3MkngjCdGJiruY-CGBbgnhUHoH7F88zdeqJP947uzM/vrPR7-ICF4fRXT2FMSwhYNAjisaiHG7dS5yleDNeyAI'), ('width', 81), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/tfRd-m9oPW_5pZATZseqKA/8M8GuTRcwwra7mAyp1O3Mdn8Lgv4YMh08ENyC2__0b8j4nihQL8zGvhSmKfPxuaJu-ExIb5d12LAjXEnl0ZW8Y65oZBeSwWQo9LFnORgnEs/86NHrFsecH-xTifSvIvL7XtbUzbrcPANRE0UB8Q0lqw'), ('width', 320), ('height', 143)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sChrZqgYbn6-x3ro2RhT4w/UtdDHNMNQXrYvJE0GXypE59Iew7ceYmIgPC4Y7KQTxqXjrrZawDAVOzCXrmNa6GGQq26FT2_FgsM74aPb9xDj-NorRUB3xRtHoBhmoWmI9w/qkZeCWLXUO5yXr_bvYxuC3t7agYYSsUBGfUbx-3a9Q8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.newark.com/keithley/2614b/source-meter-voltage-current-30/dp/44W8038,https://github.com/sdungs/E4control/blob/master/e4control/devices/K2614.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley2614B,13800.0,,,,"# -*- coding: utf-8 -*-

from time import sleep

from .device import Device
import warnings


class K2614(Device):
    rampSpeed_step = 10
    rampSpeed_delay = 1  # s

    def __init__(self, connection_type, host, port):
        super(K2614, self).__init__(
            connection_type=connection_type, host=host, port=port)
        self.trm = '\n'

    def initialize(self, iChannel='all'):
        if iChannel == 'all':
            self.setVoltageRange('AUTO', 1)
            self.setVoltageRange('AUTO', 2)
        else:
            self.setVoltageRange('AUTO', iChannel)
        pass

    def convert_iChannel(self, iChannel):
        one = [1, '1', 'one']
        two = [2, '2', 'two']
        if iChannel in one:
            iChannel = 'a'
        elif iChannel in two:
            iChannel = 'b'
        return iChannel

    def setCurrentAutoRange(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        self.write(f'smu{iChannel}.source.autorangei = smu{iChannel}.AUTORANGE_ON')

    def setVoltageRange(self, sRange, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        if isinstance(sRange, int):
            self.write(f'smu{iChannel}.source.rangev = {sRange}')
        elif sRange == 'AUTO':
            self.write(f'smu{iChannel}.source.autorangev = smu{iChannel}.AUTORANGE_ON')
        else:
            print('Unknown Range')

    def setCurrentLimit(self, fIlim, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        self.write(f'smu{iChannel}.source.limiti = {fIlim}')

    def setVoltageLimit(self, fVlim, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        self.write(f'smu{iChannel}.source.limitv = {fVlim}')

    def setVoltage(self, fVset, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        self.write(f'smu{iChannel}.source.levelv = {fVset}')

    def setOutput(self, bEnable, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        if bEnable:
            self.write(f'smu{iChannel}.source.output = smu{iChannel}.OUTPUT_ON')
        else:
            self.write(f'smu{iChannel}.source.output = smu{iChannel}.OUTPUT_OFF')

    def getOutput(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        bPower = float(self.ask(f'print(smu{iChannel}.source.output)'))
        if bPower == 0:
            return False
        if bPower == 1:
            return True

    def getVoltage(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        sValue = self.ask(f'print(smu{iChannel}.measure.v())')
        return float(sValue)

    def getCurrent(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        sValue = self.ask(f'print(smu{iChannel}.measure.i())')
        return float(sValue)

    def getCurrentLimit(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        sCurrLim = self.ask(f'print(smu{iChannel}.source.limiti)')
        return float(sCurrLim)

    def getVoltageLimit(self, iChannel):
        iChannel = self.convert_iChannel(iChannel)
        sVoltLim = self.ask(f'print(smu{iChannel}.source.rangev)')
        return float(sVoltLim)

    def setRampSpeed(self, iRampSpeed, iDelay):
        if iRampSpeed < 1 or iRampSpeed > 255:
            print('Set RampSpeed size is out of range!')
        else:
            self.rampSpeed_step = iRampSpeed
        if iDelay < 0:
            print('No negativ Delay is possible!')
        else:
            self.rampSpeed_delay = iDelay

    def getRampSpeed(self):
        return([int(self.rampSpeed_step), int(self.rampSpeed_delay)])

    def rampVoltage(self, fVnew, iChannel):
        V = self.getVoltage(iChannel)
        V = round(V, 4)
        if abs(fVnew - V) <= self.rampSpeed_step:
            self.setVoltage(fVnew, iChannel)
            print('Voltage reached: %.2f V' % fVnew)
        else:
            self.setVoltage(V + self.rampSpeed_step *
                            (fVnew - V) / abs(fVnew - V), iChannel)
            print('Ramp Voltage: %.2f V' %
                  (V + self.rampSpeed_step * (fVnew - V) / abs(fVnew - V)))
            sleep(self.rampSpeed_delay)
            self.rampVoltage(fVnew, iChannel)
            pass

    def reset(self):
        self.write('reset()')

    def output(self, show=True):
        bPower_CH1 = self.getOutput(1)
        bPower_CH2 = self.getOutput(2)
        fILimit_CH1 = self.getCurrentLimit(1) * 1E6
        fILimit_CH2 = self.getCurrentLimit(2) * 1E6


        if bPower_CH1:
            fVoltage_CH1 = self.getVoltage(1)
            fCurrent_CH1 = self.getCurrent(1) * 1E6
        else:
            fVoltage_CH1 = 0
            fCurrent_CH1 = 0

        if bPower_CH2:
            fVoltage_CH2 = self.getVoltage(2)
            fCurrent_CH2 = self.getCurrent(2) * 1E6
        else:
            fVoltage_CH2 = 0
            fCurrent_CH2 = 0

        if show:
            self.printOutput('K2614:')
            if bPower_CH1:
                self.printOutput('Output CH1 \033[32m ON \033[0m')
                self.printOutput('Currentlimit = %0.3f uA' % fILimit_CH1)
                self.printOutput('Voltage = %0.1f V' % fVoltage_CH1)
                self.printOutput('Current = %0.3f uA' % fCurrent_CH1)
            else:
                self.printOutput('Output CH1 \033[31m OFF \033[0m')
                self.printOutput('Currentlimit = %0.3f uA' % fILimit_CH1)
                self.printOutput('Voltage = ---- V')
                self.printOutput('Current = ---- uA')
            if bPower_CH2:
                self.printOutput('Output CH2 \033[32m ON \033[0m')
                self.printOutput('Currentlimit = %0.3f uA' % fILimit_CH2)
                self.printOutput('Voltage = %0.1f V' % fVoltage_CH2)
                self.printOutput('Current = %0.3f uA' % fCurrent_CH2)
            else:
                self.printOutput('Output CH2 \033[31m OFF \033[0m')
                self.printOutput('Currentlimit = %0.3f uA' % fILimit_CH2)
                self.printOutput('Voltage = ---- V')
                self.printOutput('Current = ---- uA')

        return([['Output_CH1', 'Output_CH2', 'U_CH1[V]', 'I_CH1[uA]', 'U_CH2[V]', 'I_CH2[uA]'], [str(bPower_CH1), str(bPower_CH2), str(fVoltage_CH1), str(fCurrent_CH1), str(fVoltage_CH2), str(fCurrent_CH2)]])

    def interaction(self, gui=False):
        if gui:
            device_dict = {
            'channel': 2,
			'toogleOutput': True,
			'rampVoltage': True,
			'setCurrent': True,
            'setCurrentLimit': True,
			}
            return device_dict
        else:
            print(
                'Select a channel!'
                )
            iChannel = input('Possible inputs: 1 or 2\n')
            while not iChannel in ['1', '2']:
                iChannel = input('Possible Inputs: 1 or 2! \n')
            print(f'Channel {iChannel} choosen.')
            print(
                '0: Continue dcs mode without any changes\n'
                '1: Toggle output\n'
                '2: Set voltage (enables the output if its off)\n'
                '3: Set currentlimit'
                )

            x = input('Number? \n')
            while not (x in ['0','1','2','3']):
                x = input('Possible Inputs: 0, 1, 2 or 3! \n')

            if x == '0':
                pass
            elif x == '1':
                if self.getOutput(iChannel):
                    self.rampVoltage(0, iChannel)
                    self.setOutput(False, iChannel)
                else:
                    self.setOutput(True, iChannel)
            elif x == '2':
                fV = input('Please enter new Voltage in V \n')
                if not self.getOutput(iChannel) == '1':
                    print('Enabled output. Now ramping...')
                    self.setOutput(True, iChannel)
                self.rampVoltage(float(fV), iChannel)
            elif x == '3':
                fIlim = input('Please enter new current limit in uA \n')
                self.setCurrentLimit(float(fIlim)/1E6, iChannel)
"
344,25.0,USA,,SR 865,531.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} ,,,,,,,,,,,,,,
352,23.0,"Beijing, China","The Rigol DG1062Z is a two channel Function / Arbitrary Waveform Generator to create high quality signals up to 60 MHz (Sine) with very low jitter (200 ps) and the new SiFi (SIgnal FIdelity) technology. Beside the two analog outputs, the device includes an USB-Host- and an USB-device interface.

",Rigol DG 1062,452.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DG1062Z Function Generators,https://en.wikipedia.org/wiki/Function_generator,['Function Generators'],"In electrical engineering, a function generator is usually a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave and sawtooth shapes. These waveforms can be either repetitive or single-shot (which requires an internal or external trigger source).[1] Another feature included on many function generators is the ability to add a DC offset. Integrated circuits used to generate waveforms may also be described as function generator ICs.",Rigol DG1062Z,,"[OrderedDict([('id', 'att7O8kQA6F5OfhRY'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bi4DWj3OVX9ieSJClxrS9w/4NjP3Xh0Zs9SKxAceHZydX-bEUzjWqogDQOjyPYJbtNzzoHZpTjARZfc8ExhdhchkRW-BE_yuSK85GoEICpJoFroAI7SSOdt_SjnBfHltBF_yDJvMiE2HA4RitpDP8zF/P59QXVrQ-CGco9x00IShRtXexkqKhuagQaGuAYUwxD0'), ('filename', 'dg1062z-front-1200x735-White-b.jpg'), ('size', 129264), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AFkLJ_cE8-UArumSGlP0xw/c1Ychw0HIwwUVHlVtqunBlSVoMDDAOYbzG3C_5kaCkhrdYH1h-MgJ9Chv4U3DqRPYOnPrNWV4bbgJVdfTYA79Q/HpCiOv1gzSn5yht6tBTkZ_4FhF2gMQh3A6dajRBl-us'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/szu3huGMEFcoiknU0NgzbQ/3M6mEriEWZKGbDO2C3UW4oXaqGjqzTgKBrLVEe-C4QyoLxPeqy8sW5ZvVTPMdltYwfXwp71lqixVjNoAedpPfQ/Up8xei9VguPM_Sz_sSu8XFdSV2yiM8699xx8nm7Xq9g'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AGN5N64iaVUEZEh7MIcaQQ/rP5iyPaSCWjSoN1ODfJCqjdK4a09drr2LurIagGRdhwAThQJMeTvyjX4csglkBSDEybaxlvykrO-5l_lhM7omQ/-NfGf0rEhFa8itGz0ETe8Z121ArazaU3xNZk5lO0Q0Y'), ('width', 3000), ('height', 3000)]))]))])]",https://www.batronix.com/shop/waveform-generator/Rigol-DG1062Z.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DG1062.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDG1062,,,,,"import logging
from functools import partial
from typing import Any, Union, cast

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.utils import partial_with_docstring

log = logging.getLogger(__name__)


class RigolDG1062Burst(InstrumentChannel):
    """"""
    Burst commands for the DG1062. We make a separate channel for these to
    group burst commands together.
    """"""

    def __init__(self, parent: ""RigolDG1062"", name: str, channel: int):
        super().__init__(parent, name)
        self.channel = channel

        self.add_parameter(
            ""on"",
            get_cmd=f"":SOUR{channel}:BURS?"",
            set_cmd=f"":SOUR{channel}:BURS {{}}"",
            vals=vals.Enum(0, 1, ""ON"", ""OFF""),
        )

        self.add_parameter(
            ""polarity"",
            get_cmd=f"":SOUR{channel}:BURS:GATE:POL?"",
            set_cmd=f"":SOUR{channel}:BURS:GATE:POL {{}}"",
            vals=vals.Enum(""NORM"", ""INV""),
        )

        self.add_parameter(
            ""period"",
            get_cmd=f"":SOUR{channel}:BURS:INT:PER?"",
            set_cmd=f"":SOUR{channel}:BURS:INT:PER {{}}"",
            vals=vals.MultiType(
                vals.Numbers(min_value=3e-6, max_value=500), vals.Enum(""MIN"", ""MAX"")
            ),
        )

        self.add_parameter(
            ""mode"",
            get_cmd=f"":SOUR{channel}:BURS:MODE?"",
            set_cmd=f"":SOUR{channel}:BURS:MODE {{}}"",
            vals=vals.Enum(""TRIG"", ""INF"", ""GAT""),
        )

        self.add_parameter(
            ""ncycles"",
            get_cmd=f"":SOUR{channel}:BURS:NCYC?"",
            set_cmd=f"":SOUR{channel}:BURS:NCYC {{}}"",
            vals=vals.Numbers(min_value=1, max_value=500000),
        )

        self.add_parameter(
            ""phase"",
            get_cmd=f"":SOUR{channel}:BURS:PHAS?"",
            set_cmd=f"":SOUR{channel}:BURS:PHAS {{}}"",
            vals=vals.Numbers(min_value=0, max_value=360),
        )

        self.add_parameter(
            ""time_delay"",
            get_cmd=f"":SOUR{channel}:BURS:TDEL?"",
            set_cmd=f"":SOUR{channel}:BURS:TDEL {{}}"",
            vals=vals.Numbers(min_value=0),
        )

        self.add_parameter(
            ""trigger_slope"",
            get_cmd=f"":SOUR{channel}:BURS:TRIG:SLOP?"",
            set_cmd=f"":SOUR{channel}:BURS:TRIG:SLOP {{}}"",
            vals=vals.Enum(""POS"", ""NEG""),
        )

        self.add_parameter(
            ""source"",
            get_cmd=f"":SOUR{channel}:BURS:TRIG:SOUR?"",
            set_cmd=f"":SOUR{channel}:BURS:TRIG:SOUR {{}}"",
            vals=vals.Enum(""INT"", ""EXT"", ""MAN""),
        )

        self.add_parameter(
            ""idle"",
            get_cmd=f"":SOUR{channel}:BURST:IDLE?"",
            set_cmd=f"":SOUR{channel}:BURST:IDLE {{}}"",
            vals=vals.MultiType(
                vals.Enum(""FPT"", ""TOP"", ""BOTTOM"", ""CENTER""), vals.Numbers()  # DIY
            ),
        )

    def trigger(self) -> None:
        """"""
        Send a software trigger to the instrument. This only works if the
        trigger source is set to manual.
        """"""
        self.parent.write_raw(f"":SOUR{self.channel}:BURS:TRIG"")


class RigolDG1062Channel(InstrumentChannel):

    min_impedance = 1
    max_impedance = 10000

    waveform_params = {
        waveform: [""freq"", ""ampl"", ""offset"", ""phase""]
        for waveform in [""HARM"", ""NOIS"", ""RAMP"", ""SIN"", ""SQU"", ""TRI"", ""USER"", ""PULS""]
    }

    waveform_params[""DC""] = [""freq"", ""ampl"", ""offset""]
    waveform_params[""ARB""] = [""sample_rate"", ""ampl"", ""offset""]

    """"""
    Responses from the machine don't always match
    the name to set the function, hence a translater
    """"""
    waveform_translate = {
        ""HARM"": ""HARM"",
        ""NOISE"": ""NOIS"",
        ""RAMP"": ""RAMP"",
        ""SIN"": ""SIN"",
        ""SQU"": ""SQU"",
        ""TRI"": ""TRI"",
        ""USER"": ""USER"",
        ""PULSE"": ""PULS"",
    }

    waveforms = list(waveform_params.keys())

    def __init__(self, parent: ""RigolDG1062"", name: str, channel: int):
        """"""
        Args:
            parent: The instrument this channel belongs to
            name (str)
            channel (int)
        """"""

        super().__init__(parent, name)
        self.channel = channel

        for param, unit in [
            (""freq"", ""Hz""),
            (""ampl"", ""V""),
            (""offset"", ""V""),
            (""phase"", ""deg""),
            (""sample_rate"", ""1/s""),
        ]:
            self.add_parameter(
                param,
                unit=unit,
                get_cmd=partial(self._get_waveform_param, param),
                set_cmd=partial(self._set_waveform_param, param),
            )

        self.add_parameter(
            ""waveform"", get_cmd=partial(self._get_waveform_param, ""waveform"")
        )

        self.add_parameter(
            ""impedance"",
            get_cmd=f"":OUTPUT{channel}:IMP?"",
            set_cmd=f"":OUTPUT{channel}:IMP {{}}"",
            unit=""Ohm"",
            vals=vals.MultiType(
                vals.Ints(
                    min_value=RigolDG1062Channel.min_impedance,
                    max_value=RigolDG1062Channel.max_impedance,
                ),
                vals.Enum(""INF"", ""MIN"", ""MAX"", ""HighZ""),
            ),
            get_parser=(
                lambda value: ""HighZ""
                if float(value) > RigolDG1062Channel.max_impedance
                else float(value)
            ),
            set_parser=lambda value: ""INF"" if value == ""HighZ"" else value,
        )

        self.add_parameter(
            ""sync"",
            get_cmd=f"":OUTPUT{channel}:SYNC?"",
            set_cmd=f""OUTPUT{channel}:SYNC {{}}"",
            vals=vals.Enum(0, 1, ""ON"", ""OFF""),
        )

        self.add_parameter(
            ""polarity"",
            get_cmd=f"":OUTPUT{channel}:GAT:POL?"",
            set_cmd=f"":OUTPUT{channel}:GAT:POL {{}}"",
            vals=vals.OnOff(),
            val_mapping={1: ""POSITIVE"", 0: ""NEGATIVE""},
        )

        self.add_parameter(
            ""state"",
            get_cmd=f""OUTPUT{channel}:STATE?"",
            set_cmd=f""OUTPUT{channel}:STATE {{}}"",
        )

        self.add_parameter(
            ""duty_cycle"",
            get_cmd=self._get_duty_cycle,
            set_cmd=self._set_duty_cycle,
            unit=""%"",
            vals=vals.Numbers(min_value=1, max_value=99),
            docstring=(
                ""This functions reads/sets the duty ""
                ""cycle for a square and pulse wave ""
                ""since these inherit a duty cycle.\n""
                ""For other waveforms it will give ""
                ""the user an error""
            ),
        )

        burst = RigolDG1062Burst(cast(RigolDG1062, self.parent), ""burst"", self.channel)
        self.add_submodule(""burst"", burst)

        # We want to be able to do the following:
        # >>> help(gd.channels[0].sin)
        # >>> gd.channels[0].sin(freq=2E3, ampl=1.0, offset=0, phase=0)
        # We do not use add_function as it is more cumbersome to use.
        for waveform in self.waveforms:
            f = partial_with_docstring(
                self.apply,
                docstring=""Args: "" + "", "".join(self.waveform_params[waveform]),
                waveform=waveform,
            )
            setattr(self, waveform.lower(), f)

        # Retrieve current waveform from device
        self.waveform()

    def apply(self, **kwargs: Any) -> None:
        """"""
        Public interface to apply a waveform on the channel
        Example:
        >>> gd = RigolDG1062(""gd"", ""TCPIP0::169.254.187.99::inst0::INSTR"")
        >>> gd.channels[0].apply(waveform=""SIN"", freq=1E3, ampl=1.0, offset=0, phase=0)
        Valid waveforms are: HARM, NOIS, RAMP, SIN, SQU, TRI, USER, DC, ARB
        To find the correct arguments of each waveform we can e.g. do:
        >>> help(gd.channels[0].sin)
        Notice the lower case when accessing the waveform through convenience
        functions.
        If not kwargs are given a dictionary with the current waveform
        parameters are returned.
        """"""
        self._set_waveform_params(**kwargs)

    def current_waveform(self) -> dict[Any, Any]:
        """"""Public interface to get the current waveform""""""
        return self._get_waveform_params()

    def _get_waveform_param(self, param: str) -> float:
        """"""
        Get a parameter of the current waveform. Valid param names are
        dependent on the waveform type (e.g. ""DC"" does not have a ""phase"")
        """"""
        params_dict = self._get_waveform_params()
        return params_dict.get(param, None)

    def _get_waveform_params(self) -> dict[Any, Any]:
        """"""
        Get all the parameters of the current waveform and
        """"""

        def to_float(string: str) -> Union[float, str]:
            try:
                return float(string)
            except ValueError:
                return string

        waveform_str = self.parent.ask_raw(f"":SOUR{self.channel}:APPL?"")
        parts = waveform_str.strip('""').split("","")

        current_waveform = self.waveform_translate[parts[0]]
        param_vals: list[Union[str, float]] = [current_waveform]
        param_vals += [to_float(i) for i in parts[1:]]
        param_names = [""waveform""] + self.waveform_params[current_waveform]
        params_dict = dict(zip(param_names, param_vals))

        return params_dict

    def _set_waveform_param(self, param: str, value: float) -> None:
        """"""
        Set a particular waveform param to the given value.
        """"""
        params_dict = self._get_waveform_params()

        if param in params_dict:
            params_dict[param] = value
        else:
            log.warning(
                f""Warning, unable to set '{param}' for the current "" f""waveform""
            )
            return

        return self._set_waveform_params(**params_dict)

    def _set_waveform_params(self, **params_dict: Union[int, float]) -> None:
        """"""
        Apply a waveform with values given in a dictionary.
        """"""
        if ""waveform"" not in params_dict:
            raise ValueError(""At least 'waveform' argument needed"")

        waveform = str(params_dict[""waveform""])
        if waveform not in self.waveform_params:
            raise ValueError(
                f""Unknown waveform '{waveform}'. Options are ""
                f""{self.waveform_params.keys()}""
            )

        param_names = self.waveform_params[waveform]

        if not set(param_names).issubset(params_dict.keys()):
            raise ValueError(
                f""Waveform {waveform} needs at least parameters "" f""{param_names}""
            )

        string = f"":SOUR{self.channel}:APPL:{waveform} ""
        values = [f""{params_dict[param]:7e}"" for param in param_names]
        string += "","".join(values)
        self.parent.write_raw(string)

    def _get_duty_cycle(self) -> float:
        """"""
        Reads the duty cycle after checking waveform
        """"""
        wf = self.waveform()

        if wf in [""PULS"", ""SQU""]:
            duty_cycle = self.parent.ask_raw(f"":SOUR{self.channel}:FUNC:{wf}:DCYC?"")
        else:
            raise ValueError(
                f""Current function does not contain duty cycle. Current function: {wf}""
            )

        return duty_cycle

    def _set_duty_cycle(self, duty_cycle: float) -> None:
        """"""
        Sets the duty cycle after checking waveform
        """"""
        wf = self.waveform()

        if wf in [""PULS"", ""SQU""]:
            self.parent.write_raw(f"":SOUR{self.channel}:FUNC:{wf}:DCYC {duty_cycle}"")
        else:
            raise ValueError(
                f""Current function does not have duty cycle""
                f"" hence can not set. Current function: {wf}""
            )


class RigolDG1062(VisaInstrument):
    """"""
    Instrument driver for the Rigol DG1062
    """"""

    waveforms = RigolDG1062Channel.waveforms

    def __init__(self, name: str, address: str, **kwargs: Any):

        super().__init__(name, address, terminator=""\n"", **kwargs)

        channels = ChannelList(self, ""channel"", RigolDG1062Channel, snapshotable=False)

        for ch_num in [1, 2]:
            ch_name = f""ch{ch_num}""
            channel = RigolDG1062Channel(self, ch_name, ch_num)
            channels.append(channel)
            self.add_submodule(ch_name, channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())
        self.connect_message()
"
357,25.0,USA,"The new SR860 Lock-in Amplifier is the latest in a line of innovative lock-ins from SRS. With unparalleled analog performance, sophisticated new digital signal processing features, a thoroughly modern, intuitive user interface, and a wide range of computer connectivity options, the SR860 is the ideal choice for any synchronous detection application.",SR 860,532.0,"Stanford Research Systems is a maker of general test and measurement instruments. The company was founded in 1980, is privately held, and is not affiliated with Stanford University.
",Qcodes,Stanford Research,"[OrderedDict([('id', 'att1qiEpAFySo3642'), ('width', 200), ('height', 133), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iqW0Fh4ByY2Me90hbivB1w/t9fQxPzzwRirPM2Vld6yS7INdesehYFajDDSz2Kud9kYRhJfh1iBy_p1I_0kkb9ecw8nREIXJM9P1TILybVjA8FBP8eN-SVIzFIItEFgOZa-xlvukiP32_j7VuY_tQ8t/zvRl7KPE8sTKfrO7oQk2gQyeN0ILZCnGxc9IxCNdJAE'), ('filename', 'ImageForSupplier_4969.webp'), ('size', 3136), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iKzY_usE6iQv7g9N9f7pRQ/aV_SlGzJC5vboHoKCu9elrn7cs4_VFU5DiOz7miSm7l9Qcjma-1mh7ipxOQpWogLm20mzMHxAF8wblRnRHIW6H2Uk4y7Z4OB14Jet9pUIQ8/mMZJDheCe5DEJkRey_b5phM7bOquC7dgEDgZrrBO-As'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SHyg1EzK-gh4xaugRAHi4g/Yo-gr9gdZ9wbcNpRiCwk-cK4H4diV_8AHS3DWb7BhBDUR8kufeweO860vjNTOhMoKDRNtKNHNyb5Cuv7Rmi6H53F7XhkJue4XB0857emhpE/sIZzgO12dnQeRMmXcwqXL5Vtbsgl36cVH8gHi_JUnME'), ('width', 200), ('height', 133)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E3_s-labqA9rNFHc1pP3VA/FXqsZztqDD_O0fhT_a-obUp-wXRNMPOMW_KMxlfsSM3iAy2I6lk2I9q6myNIf9o4TX-Q85X-Uhd_ymODe9DiCqnAJoQRFemVRSCRSqIBxTc/pvF3e2nZJPMQlxSdjDTlQGJNtp9u7ddL_tRPxv_oWCo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/,Write a Python script that uses Qcodes to connect to a {Device name} Lockin Amplifiers,https://www.thinksrs.com/downloads/pdfs/applicationnotes/AboutLIAs.pdf,['Lockin Amplifiers'],"An attenuator is effectively the opposite of an amplifier, though the two work by different methods. While an amplifier provides gain, an attenuator provides loss, or gain less than 1.",,https://www.thinksrs.com/downloads/pdfs/catalog/SR860c.pdf,"[OrderedDict([('id', 'attWlGoBv9Sises3P'), ('width', 4428), ('height', 2540), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NULN2DuWhXJEujjB7cC18Q/Hz3_oS5nQTXKcXfXl45cEZqWSYFsgPJQ6Ly3xWyAamHmEl7iJYL7Xkc-doaEhwIz_pOHfXme2-h8BeYpYZujikvfuSvADMYbviE5TN13LEA/gxXJPkmt8jU5r-ztI8gZmXaWUg-uNtOb7i1KkMUZ5qc'), ('filename', 'SR860_Lt_Wide (1).jpg'), ('size', 2290334), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1XIY2s5zxbisQgp12vYBjQ/QJNzhz7JkelN74GtyLy9NvdHa2DN3O80oWiABh99OGfS3kwsYvbnd-aTYVEUBdQmLfh0r3cflrdb6sT6gbSn9g/4qcwIJ159DnNSq7pRwipyrbOUCAIb8aZOcWrKfJT_dU'), ('width', 63), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iLXq5jzvc1ZPDhyhnd5P1g/O9dRYxF78h3NWjJmkJOSsJUOOd-hG7DKJzKO2SONZyj9gtVnZjX-Sqz0MFsgQljWH-bgL6iSdKwksgm0lq32xg/CSYk9lqG27AanrF7wsRtjGlgbs2IXNOkqSuxfpzkd_U'), ('width', 893), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OxGGhg3CmAAkBKTjaM7pQA/Vck6YYLt0tV-DtujbuVzMYvP0k7-MKgr43W61nfKgOAzfh7zYyvjItaXj1fSeI6PSJFfHuHsDre4ZPFVnW36vw/-tovmpIJQ_XrMCZ7LghwFRPmkGXty4wdinZpwgV_Wy4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.thinksrs.com/products/sr860.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/stanford_research/SR860.py,https://qcodes.github.io/Qcodes/drivers_api/SRS.html#qcodes.instrument_drivers.stanford_research.SR860,6495.0,,True,,"from qcodes.instrument_drivers.stanford_research.SR86x import SR86x


class SR860(SR86x):
    """"""
    QCoDeS driver for the Stanford Research Systems SR860 Lock-in Amplifier.

    The SR860 instrument is almost equal to the SR865, except for the max frequency
    """"""

    def __init__(
        self, name: str, address: str, reset: bool = False, **kwargs: str
    ) -> None:
        super().__init__(name, address, max_frequency=500e3, reset=reset, **kwargs)
"
358,23.0,"Beijing, China","The Rigol DS4000 series consists of 8 high level Oscilloscopes for professional operation, which come off very well compared to higher prices models of other brands.",Rigol DS 4000,457.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DS4000 (Series) Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time.,Rigol DS4000 (Series),,,https://www.batronix.com/shop/rigol/DS4000.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DS4000.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDG4000,,,,,"from __future__ import annotations

import logging
import re
import time
import warnings
from collections import namedtuple
from typing import Any

import numpy as np
from packaging import version

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, ParamRawDataType

log = logging.getLogger(__name__)


class RigolDS4000TraceNotReady(Exception):
    pass


class ScopeArray(ArrayParameter):
    def __init__(
        self,
        name: str,
        instrument: RigolDS4000Channel,
        channel: int,
        raw: bool = False,
    ):
        super().__init__(
            name=name,
            shape=(1400,),
            label=""Voltage"",
            unit=""V"",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""holds an array from scope"",
            instrument=instrument,
        )
        self.channel = channel
        self.raw = raw
        self.max_read_step = 50
        self.trace_ready = False

    def prepare_curvedata(self) -> None:
        """"""
        Prepare the scope for returning curve data
        """"""
        assert isinstance(self.instrument, RigolDS4000Channel)
        if self.raw:
            self.instrument.write("":STOP"")  # Stop acquisition
            self.instrument.write("":WAVeform:MODE RAW"")  # Set RAW mode
        else:
            self.instrument.write("":WAVeform:MODE NORM"")  # Set normal mode

        self.get_preamble()
        p = self.preamble

        # Generate time axis data
        xdata = np.linspace(p.xorigin, p.xorigin + p.xincrement * p.points, p.points)
        self.setpoints = (tuple(xdata),)
        self.shape = (p.points,)

        self.trace_ready = True

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, RigolDS4000Channel)
        assert isinstance(self.root_instrument, RigolDS4000)
        if not self.trace_ready:
            raise RigolDS4000TraceNotReady(
                ""Please run prepare_curvedata to prepare ""
                ""the scope for giving a trace.""
            )
        else:
            self.trace_ready = False

        # Set the data type for waveforms to ""BYTE""
        self.instrument.write("":WAVeform:FORMat BYTE"")
        # Set read channel
        self.instrument.write(f"":WAVeform:SOURce CHAN{self.channel}"")

        data_bin = bytearray()
        if self.raw:
            log.info(""Readout of raw waveform started, %g points"", self.shape[0])
            # Ask for the right number of points
            self.instrument.write(f"":WAVeform:POINts {self.shape[0]}"")
            # Resets the waveform data reading
            self.instrument.write("":WAVeform:RESet"")
            # Starts the waveform data reading
            self.instrument.write("":WAVeform:BEGin"")

            for i in range(self.max_read_step):
                status = self.instrument.ask("":WAVeform:STATus?"").split("","")[0]

                # Ask and retrieve waveform data
                # It uses .read_raw() to get a byte
                # string since our data is binary
                self.instrument.write("":WAVeform:DATA?"")
                data_chunk = self.root_instrument.visa_handle.read_raw()
                data_chuck = self._validate_strip_block(data_chunk)
                data_bin.extend(data_chuck)

                if status == ""IDLE"":
                    self.instrument.write("":WAVeform:END"")
                    break
                else:
                    # Wait some time to have the buffer re-filled
                    time.sleep(0.3)
                log.info(
                    ""chucks read: %d, last chuck points: "" ""%g, total read size: %g"",
                    i,
                    len(data_chuck),
                    len(data_bin),
                )
            else:
                raise ValueError(""Communication error"")
        else:
            # Ask and retrieve waveform data
            # It uses .read_raw() to get a byte string since our data is binary
            log.info(""Readout of display waveform started, %d points"", self.shape[0])
            self.instrument.write("":WAVeform:DATA?"")  # Query data
            data_chunk = self.root_instrument.visa_handle.read_raw()
            data_bin.extend(self._validate_strip_block(data_chunk))

        log.info(""Readout ended, total read size: %g"", len(data_bin))

        log.info(""Data conversion"")
        # Convert data to byte array
        data_raw = np.frombuffer(data_bin, dtype=np.uint8).astype(float)

        # Convert byte array to real data
        p = self.preamble
        data = (data_raw - p.yreference - p.yorigin) * p.yincrement
        log.info(""Data conversion done"")

        return data

    @staticmethod
    def _validate_strip_block(block: bytes) -> bytes:
        """"""
        Given a block of raw data from the instrument, validate and
        then strip the header with
        size information. Raise ValueError if the sizes don't match.

        Args:
            block: The data block
        Returns:
            The stripped data
        """"""
        # Validate header
        header = block[:11].decode(""ascii"")
        match = re.match(r""#9(\d{9})"", header)
        if match:
            size = int(match[1])
            block_nh = block[11:]  # Strip header
            block_nh = block_nh.strip()  # Strip \n

            if size == len(block_nh):
                return block_nh

        raise ValueError(""Malformed data"")

    def get_preamble(self) -> None:
        assert isinstance(self.instrument, RigolDS4000Channel)
        preamble_nt = namedtuple(
            ""preamble_nt"",
            [
                ""format"",
                ""mode"",
                ""points"",
                ""count"",
                ""xincrement"",
                ""xorigin"",
                ""xreference"",
                ""yincrement"",
                ""yorigin"",
                ""yreference"",
            ],
        )

        def conv(x: str) -> float:
            return int(x) if x.isdigit() else float(x)

        preamble_raw = self.instrument.ask("":WAVeform:PREamble?"")
        preamble_num = [conv(x) for x in preamble_raw.strip().split("","")]
        self.preamble = preamble_nt(*preamble_num)


class RigolDS4000Channel(InstrumentChannel):
    def __init__(self, parent: RigolDS4000, name: str, channel: int):
        super().__init__(parent, name)

        self.add_parameter(
            ""amplitude"", get_cmd=f"":MEASure:VAMP? chan{channel}"", get_parser=float
        )
        self.add_parameter(
            ""vertical_scale"",
            get_cmd=f"":CHANnel{channel}:SCALe?"",
            set_cmd="":CHANnel{}:SCALe {}"".format(channel, ""{}""),
            get_parser=float,
        )

        # Return the waveform displayed on the screen
        self.add_parameter(
            ""curvedata"", channel=channel, parameter_class=ScopeArray, raw=False
        )

        # Return the waveform in the internal memory
        self.add_parameter(
            ""curvedata_raw"", channel=channel, parameter_class=ScopeArray, raw=True
        )


class RigolDS4000(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Rigol DS4000 series oscilloscopes.
    """"""

    def __init__(self, name: str, address: str, timeout: float = 20, **kwargs: Any):
        """"""
        Initialises the DS4000.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: visa timeout, in secs. long default (180)
                to accommodate large waveforms
        """"""

        # Init VisaInstrument. device_clear MUST NOT be issued, otherwise communications hangs
        # due a bug in firmware
        super().__init__(name, address, device_clear=False, timeout=timeout, **kwargs)
        self.connect_message()

        self._check_firmware_version()

        # functions
        self.add_function(""run"", call_cmd="":RUN"", docstring=""Start acquisition"")
        self.add_function(""stop"", call_cmd="":STOP"", docstring=""Stop acquisition"")
        self.add_function(
            ""single"", call_cmd="":SINGle"", docstring=""Single trace acquisition""
        )
        self.add_function(
            ""force_trigger"", call_cmd=""TFORce"", docstring=""Force trigger event""
        )
        self.add_function(
            ""auto_scale"", call_cmd="":AUToscale"", docstring=""Perform autoscale""
        )

        # general parameters
        self.add_parameter(
            ""trigger_type"",
            label=""Type of the trigger"",
            get_cmd="":TRIGger:MODE?"",
            set_cmd="":TRIGger:MODE {}"",
            vals=vals.Enum(
                ""EDGE"",
                ""PULS"",
                ""RUNT"",
                ""NEDG"",
                ""SLOP"",
                ""VID"",
                ""PATT"",
                ""RS232"",
                ""IIC"",
                ""SPI"",
                ""CAN"",
                ""FLEX"",
                ""USB"",
            ),
        )
        self.add_parameter(
            ""trigger_mode"",
            label=""Mode of the trigger"",
            get_cmd="":TRIGger:SWEep?"",
            set_cmd="":TRIGger:SWEep {}"",
            vals=vals.Enum(""AUTO"", ""NORM"", ""SING""),
        )
        self.add_parameter(
            ""time_base"",
            label=""Horizontal time base"",
            get_cmd="":TIMebase:MAIN:SCALe?"",
            set_cmd="":TIMebase:MAIN:SCALe {}"",
            get_parser=float,
            unit=""s/div"",
        )
        self.add_parameter(
            ""sample_point_count"",
            label=""Number of the waveform points"",
            get_cmd="":WAVeform:POINts?"",
            set_cmd="":WAVeform:POINts {}"",
            get_parser=int,
            vals=vals.Ints(min_value=1),
        )
        self.add_parameter(
            ""enable_auto_scale"",
            label=""Enable or disable autoscale"",
            get_cmd="":SYSTem:AUToscale?"",
            set_cmd="":SYSTem:AUToscale {}"",
            get_parser=bool,
            vals=vals.Bool(),
        )

        channels = ChannelList(self, ""Channels"", RigolDS4000Channel, snapshotable=False)

        for channel_number in range(1, 5):
            channel = RigolDS4000Channel(self, f""ch{channel_number}"", channel_number)
            channels.append(channel)

        self.add_submodule(""channels"", channels.to_channel_tuple())

    def _check_firmware_version(self) -> None:
        # Require version 00.02.03

        idn = self.get_idn()
        verstr = idn[""firmware""]
        if verstr is None:
            raise RuntimeError(""Could not determine firmware version of DS4000."")
        ver = version.parse(verstr)
        if ver < version.parse(""00.02.03""):
            warnings.warn(
                ""Firmware version should be at least 00.02.03,""
                ""data transfer may not work correctly""
            )
"
360,2500.0,"Munich, Germany","The R&S®SGS100A is an RF source designed to meet the requirements of automated test systems. It is available as a CW source or as a vector signal generator with an integrated I/Q modulator. With its frequency range of up to 12.75 GHz, the vector signal generation version covers the essential digital signals. The CW version can be used as a flexible local oscillator and for interference testing against mobile radio standards.

",SGS 100 A,461.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a R&S SGS100A RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",R&S SGS100A,hhttps://www.axiomtest.com/documents/models/RS%20SGS100A%20Datasheet.pdf,"[OrderedDict([('id', 'attOOcfzLHctI1oDv'), ('width', 2880), ('height', 1620), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Cmvyo1EbHuZTbAWVOv80dg/JyHlIC7BvZ3jC0PrlaDRdWCx3Veo1dYZYBkfjT2ZZcsrlMA8q_jcpt7IGK9VIc4bjNxrJamvNlwXgumXxsWwxygokRO0dIcQjGuz8dpsfh8-TYC96gCsMQmqTIC3MTNHxg65VRdMNoOQSb-Ep_UhO6WZs5QAzK02dE76OqMKHB4/IqGA-2zCr66hV7DL0iEUM9lOJ07ujeK0rb41jvQE2pA'), ('filename', 'sgs100a-sgma-rf-source-front-view-rohde-schwarz_200_1102_2880_1620_2.jpg'), ('size', 208002), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ztqM4elum2miCf6qwQh7lA/eqS-0TB-RyRsvN0HIEk-ev9nm_0-4qGlqHKgfgZETX1LU_UqOw-LCqlgsSZxeYizV6Ar5-FPmRbefuFk5doq0g/lmdgOxm9knU4OfX9Ih4_6AxnvqGWr0TRyv3dcoP-XTI'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/a9GWw8TumMVAD2eXLK35lg/dw5rlPlINizbchB5jGv8wHSryhejLU2nWQpASqTtv4xAP_gtnMlNjPg6tUjbG8gUo09-29rY-36lG-1AOa5Xkw/xBfUnqZWht-xT0D4kp1s-7BQUIqFJQ20hVw-ZlrQ6f4'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/iaJfoDVlLgTS_NBfgnAr-Q/fEJGgGfOKOg4CXNVSJVGtWZzmKPKsDQo2GUTYXLuz3gtZWuqlV4yiDAauh4OD5_AdbSiTAEJD6uXLBAxcRg4FQ/iBRa7xYltWIsabS9gHJ8NcmgKMZbEAesIT6qtwXBDKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/us/products/test-and-measurement/analog-signal-generators/rs-sgs100a-sgma-rf-source_63493-9030.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/SGS100A.py,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzSGS100A,,,,,"from typing import Any

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class RohdeSchwarzSGS100A(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Rohde & Schwarz SGS100A signal generator.

    Status: beta-version.

    .. todo::

        - Add all parameters that are in the manual
        - Add test suite
        - See if there can be a common driver for RS mw sources from which
          different models inherit

    This driver will most likely work for multiple Rohde & Schwarz sources.
    it would be a good idea to group all similar RS drivers together in one
    module.

    Tested working with

    - RS_SGS100A

    This driver does not contain all commands available for the RS_SGS100A but
    only the ones most commonly used.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator='\n', **kwargs)

        self.add_parameter(name='frequency',
                           label='Frequency',
                           unit='Hz',
                           get_cmd='SOUR:FREQ?',
                           set_cmd='SOUR:FREQ {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(1e6, 20e9))
        self.add_parameter(name='phase',
                           label='Phase',
                           unit='deg',
                           get_cmd='SOUR:PHAS?',
                           set_cmd='SOUR:PHAS {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(0, 360))
        self.add_parameter(name='power',
                           label='Power',
                           unit='dBm',
                           get_cmd='SOUR:POW?',
                           set_cmd='SOUR:POW {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-120, 25))
        self.add_parameter('status',
                           label='RF Output',
                           get_cmd=':OUTP:STAT?',
                           set_cmd=':OUTP:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('IQ_state',
                           label='IQ Modulation',
                           get_cmd=':IQ:STAT?',
                           set_cmd=':IQ:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('pulsemod_state',
                           label='Pulse Modulation',
                           get_cmd=':SOUR:PULM:STAT?',
                           set_cmd=':SOUR:PULM:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('pulsemod_source',
                           label='Pulse Modulation Source',
                           get_cmd='SOUR:PULM:SOUR?',
                           set_cmd='SOUR:PULM:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        self.add_parameter('ref_osc_source',
                           label='Reference Oscillator Source',
                           get_cmd='SOUR:ROSC:SOUR?',
                           set_cmd='SOUR:ROSC:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        # Define LO source INT/EXT (Only with K-90 option)
        self.add_parameter('LO_source',
                           label='Local Oscillator Source',
                           get_cmd='SOUR:LOSC:SOUR?',
                           set_cmd='SOUR:LOSC:SOUR {}',
                           vals=vals.Enum('INT', 'EXT', 'int', 'ext'))
        # Define output at REF/LO Output (Only with K-90 option)
        self.add_parameter('ref_LO_out',
                           label='REF/LO Output',
                           get_cmd='CONN:REFL:OUTP?',
                           set_cmd='CONN:REFL:OUTP {}',
                           vals=vals.Enum('REF', 'LO', 'OFF', 'ref', 'lo',
                                          'off', 'Off'))
        # Frequency mw_source outputs when used as a reference
        self.add_parameter('ref_osc_output_freq',
                           label='Reference Oscillator Output Frequency',
                           get_cmd='SOUR:ROSC:OUTP:FREQ?',
                           set_cmd='SOUR:ROSC:OUTP:FREQ {}',
                           vals=vals.Enum('10MHz', '100MHz', '1000MHz'))
        # Frequency of the external reference mw_source uses
        self.add_parameter('ref_osc_external_freq',
                           label='Reference Oscillator External Frequency',
                           get_cmd='SOUR:ROSC:EXT:FREQ?',
                           set_cmd='SOUR:ROSC:EXT:FREQ {}',
                           vals=vals.Enum('10MHz', '100MHz', '1000MHz'))

        # IQ impairments
        self.add_parameter('IQ_impairments',
                           label='IQ Impairments',
                           get_cmd=':SOUR:IQ:IMP:STAT?',
                           set_cmd=':SOUR:IQ:IMP:STAT {}',
                           val_mapping=create_on_off_val_mapping(on_val='1',
                                                                 off_val='0'))
        self.add_parameter('I_offset',
                           label='I Offset',
                           get_cmd='SOUR:IQ:IMP:LEAK:I?',
                           set_cmd='SOUR:IQ:IMP:LEAK:I {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-10, 10))
        self.add_parameter('Q_offset',
                           label='Q Offset',
                           get_cmd='SOUR:IQ:IMP:LEAK:Q?',
                           set_cmd='SOUR:IQ:IMP:LEAK:Q {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-10, 10))
        self.add_parameter('IQ_gain_imbalance',
                           label='IQ Gain Imbalance',
                           get_cmd='SOUR:IQ:IMP:IQR?',
                           set_cmd='SOUR:IQ:IMP:IQR {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-1, 1))
        self.add_parameter('IQ_angle',
                           label='IQ Angle Offset',
                           get_cmd='SOUR:IQ:IMP:QUAD?',
                           set_cmd='SOUR:IQ:IMP:QUAD {:.2f}',
                           get_parser=float,
                           vals=vals.Numbers(-8, 8))

        self.add_function('reset', call_cmd='*RST')
        self.add_function('run_self_tests', call_cmd='*TST?')

        self.connect_message()

    def on(self) -> None:
        self.status('on')

    def off(self) -> None:
        self.status('off')


class RohdeSchwarz_SGS100A(RohdeSchwarzSGS100A):
    pass
"
368,5420.0,USA,"The Keysight B1500A semiconductor parameter analyzer is an all-in-one device characterization analyzer supporting IV, CV, pulse/dynamic IV and more.",Keysightb 1500,327.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT B1500A Spectrum Analyzers,https://www.atecorp.com/category/semiconductor-parameter-analyzers,['Spectrum Analyzers'],"The semiconductor parameter analyzer is an all-in-one unit, that consists of a power supplies, voltage meters, current meters, switching matrices and LCR meters to test semiconductors",KEYSIGHT B1500A,https://www.keysight.com/us/en/assets/7018-01289/data-sheets/5989-2785.pdf,"[OrderedDict([('id', 'attXqVnDukWaMVFsj'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7mqsfCrZ5UqSo3jlppRCkA/iWJpXEaxpLnMafV0RzV2kuFZWaGwvSounnpOuPg5SGaH_pUcvT9Fnd3WsjwBGjsch5QXu3ISH95tbNbtlKQ2HvVlTuMBIir79SCjBqFn7S_3FMnI8qS0Ek2lvUqysN88/6c96agehXDBC77JnzoVrkw2L2Jqk-sNBdiOem91t9TU'), ('filename', 'B1500_FL_TRANS_SHAD_2016April13.png'), ('size', 1136027), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-LLTUyw2n27XeebL3pQcKA/SAWtB1cdtoYKDexxptfKtS9_koidSWkSQwj_izEQ8ow1UiM7v3KQJOnnrnUWoBQ08QcrMESc3YMZiot6e4fQ9g/P06BRLC-27r9SfxrQx0rZDJTn_rFXRu7wI9-tezWd1Y'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/k4DrkXyJgW3v-DmmWp0a7w/hmwOvjBygxQBltJ37gcR-iXOOeX-m4iROcaF5-lN0ozdeyYxQvNsa_mzKdwS4cjhHXDpEH5UG2tq-2BbBXFN_w/pcmyOTrHo0cycFnr8wpD789ajyazrGZJ3AU-7OYu38c'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JQqe8Sz7yQnelsfmBhMgMw/xaqlY1L0xTjCi-ScSgAwkQc5lVX-W9YIISlGQr8jJyjtIvQeP0qIhU0lPbkOkEscOkD-QPMggW0dac-fF7ywhA/HM65PbMzzErcLofBsQlGIT9Hb788FcY07cGagFJAncY'), ('width', 3000), ('height', 3000)]))]))])]","https://www.keysight.com/us/en/product/B1500A/semiconductor-device-parameter-analyzer-system-mainframe.html#:~:text=The%20Keysight%20B1500A%20semiconductor%20parameter,%2C%20and%20active%20%2F%20passive%20components.",https://github.com/QCoDeS/Qcodes/tree/v0.25.0/qcodes/instrument_drivers/Keysight/keysightb1500,https://qcodes.github.io/Qcodes/examples/driver_examples/Qcodes%20example%20with%20Keysight%20B1500%20Parameter%20Analyzer.html,,,,,
370,23.0,"Beijing, China","3 Outputs; total power up to 195W
Low Ripple Noise <350 uVrms/2mVpp
Fast transient response time: <50 us
Channel isolation: CH1 || CH2,CH3
OVP/OCP/OTP protection functions
Built in V, A, W measurements and waveform display",DP 832,449.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DP832 Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Rigol DP832,https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,"[OrderedDict([('id', 'attbuXPs6Pc510cXh'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oEqp1mRyXwPosKK8w2L6hQ/Bz-KEgiPMOLEwBI0zy8SyrtcaaJg9jH6CGgGWxbjKpFdKHSsslH-shptHr7tqOudHvqJibOrMyFK3R9B3Wyx-lst79V9bXlYspclbGiBQ-QuETJTTCn05MkAhau79D2t/z_IOPQMka6MdAVxAs4Kt9MtoHfOE-37_08xkuS12_rE'), ('filename', 'dp832-oblique-1200x735-White-b.jpg'), ('size', 120933), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wJCgffSPvdzQRvd59QwbAw/18imk0pHmYaoYJNQFa7u54RfdyRFO7uegYt20RkXajlk78a5OTns_ZL6xIzqsa106jOSqFY_CYsTT5UGQU5GSQ/HHBmO1S3V7COQP-5w-1aHecbXXGptOBkjq7G8jmx0vE'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g0tW1o7dAiS7hkg1np18HQ/IZncFqh1WrHIVoeLJSSN0kW-FdREAvKsFfo99lqOR90mAmpvQoOZcwZ23F4J-FA_GaVO9Rbcdxu1eOAl0uKoPA/lVAj-3nogcSlpkKkTjVy2Pnmv5JbhM6DZDM80hP_Qgg'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/AjrxJljV2lUnLaKNiz8l1Q/h-JzchJv2JQ9Zg_R-zIL9gOfDbD2v4YpDLDt7rYpbgavWnq85Y-IeV04T4VnKQxD47J9iCRfWI0pUBqqorSJPA/fcGrtMWumaXf0GSEhGHxIX2UugxPTJlR8SOlzWfLY0o'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tequipment.net/RigolDP832.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/Rigol_DP832.py,https://qcodes.github.io/Qcodes/drivers_api/Rigol.html#qcodes.instrument_drivers.rigol.RigolDP831,,,,,"from typing import Any

from .private.DP8xx import _RigolDP8xx


class RigolDP832(_RigolDP8xx):
    """"""
    This is the qcodes driver for the Rigol DP832(A) Power Supply
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any):
        channel_ranges = [(30.0, 3.0), (30.0, 3.0), (5.0, 3.0)]

        ovp_ranges_std = [(0.01, 33.0), (0.01, 33.0), (0.01, 5.5)]
        ocp_ranges_std = [(0.001, 3.3), (0.001, 3.3), (0.001, 3.3)]

        ovp_ranges_precision = [(0.001, 33.0), (0.001, 33.0), (0.001, 5.5)]
        ocp_ranges_precision = [(0.001, 3.3), (0.001, 3.3), (0.001, 3.3)]

        ovp = (ovp_ranges_std, ovp_ranges_precision)
        ocp = (ocp_ranges_std, ocp_ranges_precision)

        super().__init__(name, address, channel_ranges, ovp, ocp, **kwargs)
"
376,4.0,CANADA - QC,"ATS9360 is a fast, 12-bit waveform digitizer based on the 8-lane PCI Express Gen2 interface.
",ATS 9360,62.0,"Alazar Technologies Inc. (AlazarTech) was founded in 2003 with the goal of serving the test and measurement market, in general, and the embedded waveform digitizer (OEM) market segment, in particular, by providing highly differentiated, high performance instrumentation products at affordable prices.
",Qcodes,Alazartech,"[OrderedDict([('id', 'atteyQ7TDuN6pwRdY'), ('width', 300), ('height', 150), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h8yDC782gmJYILVwetqyNg/XNft-iYe6x8LEFTaoDNdcglx8uZWwUUbNf4oX-ErBZYvya3nvf9i0ao4jJp70hHk7oN7wtgcaboMWlcRtFbUeccPNbUJ0Ajzieb7_-0dOvY/M5yDXUl_TYlDiCuUg_-hevxefX_4ZGtn62x5xIZ0wso'), ('filename', 'AlazarTech-PW13-Logo.png'), ('size', 19339), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gmlldA7Zo_-OSPyZsu7mPQ/XKZDoQmgc3wi6TkdRJNKT5dYVGwmvfciyRHelmq94Fmnai7rVErHtEDREKJXu9_IHjQS7AeXExr0raP0i8qt9g/rKROdmQfR-K5ATu1ZN_qmcHLCXjquZ1AQFi7pM4PIRY'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-xGoEh8NzGkRqLzjthJ-1A/El2jn-9r8vkBM8mzLCyPAJp4mhEuwwyz-Mjkamgj3Nb-6HmhSMwQGCrm1aoGHp3LwUNAI6zroK3Xqc0OGV9org/tjN2cvTq9f28KHrk67tlaSmFHLwgdKOLL8IIa1-o5us'), ('width', 300), ('height', 150)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/t_PiUYdPzQjLjJU9vEarJQ/uVumfw7c89vOKsptIyuF2g3LBU5I8wWQSuR2hRnlrVTLECKdyi_DwwHGMI6y2EQRUFS6qlkmQtCh3GYKCuYvqg/FS3WfkFziiTlklsy7j-a1DSgE14IyXx9JDShkxKJwrQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/,"Write a Python script that uses Qcodes to connect to a ATS9360 - 12bit, 1.8GS/s DAQ boards",https://en.wikipedia.org/wiki/Analog-to-digital_converter,['DAQ boards'],"In electronics, an analog-to-digital converter (ADC, A/D, or A-to-D) is a system that converts an analog signal, such as a sound picked up by a microphone or light entering a digital camera, into a digital signal","ATS9360 - 12bit, 1.8GS/s",http://www.octsources.com/otcadmin/document/pdf/20180815/1534322934.pdf,"[OrderedDict([('id', 'attTCX5gifGPnLbsx'), ('width', 1000), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jqnuy5jsqEktZPteRz0iFQ/A0wvDRu59ERRoy5mAfKnXLYu7D5zAjaMrXHnHVTZoHhrumKpAru3I9-6It3m-d0GpwJURsRsTUxnPCmXiwrVFCiGHVtTiIkXcMCABkIlHps/hxFCTvdjN19nuKbzPj3wspBMJTHUsqomkYc0rYeM8LE'), ('filename', 'ATS9360.jpg'), ('size', 525306), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/G0lI_te329OoMCXNoYxFsw/1SwNrIYv6BjDe5MGnOGLFRHCiIsyy_MyXxKuK_HuW0MVNa8_rFDwYR0dcU01uQufT3E33c6VFE6u_FxDr9aOgA/OTdKkSz-CqkKNPW_dUS41HnN5UN60ZO2m_-l62fORYk'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mrMSO8_HE6SIjqk1SqLaTw/y15BXAePoO8JFJxlGmbuywnfAbv965_ynT6CdZ1ReCoKGhc5tkE21Lpnf8ORS27554lwtK1IYKpyqk1Um5aUlA/oAJJTes-rGW_rJ6_V5AhNWt-qvv4VPi9s-f3T8dqG_Q'), ('width', 640), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/en5eN1u-y6L2Jav2OSPUmg/53iHHp0QYsIK-eNT-4HQuuF_4cWTUhn27dpkVGm23IeF0KnnTBqvM1mPI0wjUKLEWOZ4UjQ7KME_goZWWbw83g/EUHZ72Kcfz-2JiRB8-M5kmHLLB4WepZZ2u27qzfFeYs'), ('width', 3000), ('height', 3000)]))]))])]",https://www.alazartech.com/en/product/ats9360/3/,https://github.com/QCoherence/python_drivers/blob/master/ATS9360_NPT.py,https://qcodes.github.io/Qcodes/_modules/qcodes/instrument_drivers/AlazarTech/ATS9360.html,,"
",,,"# This Python file uses the following encoding: utf-8
# ATS9360_NPT.py driver for The aquisition board Alzar ATS9360
# Etienne Dumur <etienne.dumur@neel.cnrs.fr> 2015
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from instrument import Instrument
import numpy as np
import logging
import types
import time
import multiprocessing as mp

from ATS9360 import atsapi as ats
from ATS9360.DataAcquisition import DataAcquisition
data_acquisition = DataAcquisition()

class ATS9360_NPT(Instrument):



    def __init__(self, name):

        logging.debug(__name__ + ' : Initializing instrument')
        Instrument.__init__(self, name, tags=['measure'])

        self.add_parameter('clock_source',
            type        = types.StringType,
            flags       = Instrument.FLAG_GETSET,
            option_list = ('internal', 'external', 'fast_external')
            )

        self.add_parameter('clock_edge',
            type        = types.StringType,
            flags       = Instrument.FLAG_GETSET,
            option_list = ('rising', 'falling')
            )

        self.add_parameter('samplerate',
            type        = types.FloatType ,
            flags       = Instrument.FLAG_GETSET,
            units       = 'MS/s'
            )

        self.add_parameter('trigger_range',
            type        = types.FloatType ,
            flags       = Instrument.FLAG_GETSET,
            option_list = (5., 2.5, 1.),
            units       = 'V'
            )

        self.add_parameter('trigger_level',
            type        = types.FloatType ,
            flags       = Instrument.FLAG_GETSET,
            units       = 'V'
            )

        self.add_parameter('trigger_delay',
            type        = types.FloatType ,
            flags       = Instrument.FLAG_GETSET,
            units       = 'ns'
            )

        self.add_parameter('trigger_slope',
            type        = types.StringType ,
            flags       = Instrument.FLAG_GETSET,
            option_list = ('positive', 'negative')
            )

        self.add_parameter('acquisition_time',
            type        = types.FloatType,
            flags       = Instrument.FLAG_GET_AFTER_SET | Instrument.FLAG_GETSET,
            units       = 'ns'
            )

        self.add_parameter('averaging',
            type        = types.IntType,
            flags       = Instrument.FLAG_GETSET
            )

        self.add_parameter('nb_sequence',
            type        = types.IntType,
            flags       = Instrument.FLAG_GETSET
            )

        self.add_parameter('completed_acquisition',
            type        = types.FloatType,
            flags       = Instrument.FLAG_GET,
            units       = '%'
            )

        self.add_parameter('mode',
            type        = types.StringType,
            flags       = Instrument.FLAG_GETSET,
            option_list = ('CHANNEL_AB','CHANNEL_A','CHANNEL_B','FFT')
            )

        self.allow_samplerates = {1e-3   : ats.SAMPLE_RATE_1KSPS,
                                  2e-3   : ats.SAMPLE_RATE_2KSPS,
                                  5e-3   : ats.SAMPLE_RATE_5KSPS,
                                  10e-3  : ats.SAMPLE_RATE_10KSPS,
                                  20e-3  : ats.SAMPLE_RATE_20KSPS,
                                  50e-3  : ats.SAMPLE_RATE_50KSPS,
                                  100e-3 : ats.SAMPLE_RATE_100KSPS,
                                  200e-3 : ats.SAMPLE_RATE_200KSPS,
                                  500e-3 : ats.SAMPLE_RATE_500KSPS,
                                  1.     : ats.SAMPLE_RATE_1MSPS,
                                  2.     : ats.SAMPLE_RATE_2MSPS,
                                  5.     : ats.SAMPLE_RATE_5MSPS,
                                  10.    : ats.SAMPLE_RATE_10MSPS,
                                  20.    : ats.SAMPLE_RATE_20MSPS,
                                  50.    : ats.SAMPLE_RATE_50MSPS,
                                  100.   : ats.SAMPLE_RATE_100MSPS,
                                  200.   : ats.SAMPLE_RATE_200MSPS,
                                  500.   : ats.SAMPLE_RATE_500MSPS,
                                  800.   : ats.SAMPLE_RATE_800MSPS,
                                  1e3    : ats.SAMPLE_RATE_1000MSPS,
                                  1.2e3  : ats.SAMPLE_RATE_1200MSPS,
                                  1.5e3  : ats.SAMPLE_RATE_1500MSPS,
                                  1.8e3  : ats.SAMPLE_RATE_1800MSPS}


        self.allow_clock_edges = {'rising'  : ats.CLOCK_EDGE_RISING,
                                  'falling' : ats.CLOCK_EDGE_FALLING}


        self.allow_clock_sources = {'internal' : ats.INTERNAL_CLOCK,
                                    'external' : ats.EXTERNAL_CLOCK_10MHz_REF,
                                    'fast_external' : ats.FAST_EXTERNAL_CLOCK}

        # By default, we don't take into account the TTL mode for the trigger
        self.allow_trigger_ranges = {5   : ats.ETR_5V,
                                     2.5 : ats.ETR_2V5,
                                     1   : ats.ETR_1V}
                                        #    'TTL' : ats.ETR_TTL}


        self.allow_trigger_slopes = {'positive' : ats.TRIGGER_SLOPE_POSITIVE,
                                    'negative' : ats.TRIGGER_SLOPE_NEGATIVE}

        self.allow_modes = {'CHANNEL_AB',
                            'CHANNEL_A',
                            'CHANNEL_B',
                            'FFT'}

        # Attributes of the clock
        self.samplerate   = 1000. # In [MS/s], float
        self.clock_source = 'external' #  fast_external
        self.clock_edge   = 'rising'

        # Attributes of the trigger
        self.trigger_range = 5. # In [V]
        self.trigger_slope = 'positive'
        self.trigger_level = 0.5 # In [V]
        self.trigger_delay = 0. # In [ns]

        # Attributes of the acquisition
        self.samplesPerRecord           = 128*80 # In S. Must be integer
        self.acquisition_time           = self.samplesPerRecord/(self.samplerate*1e-3) # In ns, float
        self.default_records_per_buffer = 250 # Must be integer and even

        # The current records per buffer is equal to the default one at the
        # initialization of the board.
        self.records_per_buffer         = self.default_records_per_buffer
        self.nb_buffer_allocated        = 4 # Must be integer
        self.buffers_per_acquisition    = 200 # Must be integer
        self.averaging                  = 100 # Must be integer
        self.nb_sequence                = 2 # Must be integer and even

        # Keep trace of the number of buffers acquired by the board.
        # If a measurement is well executed, this number becomes equal to the
        # number of sequences times the number of averaging
        self._acquired_sequences = 0.

        # Attributes of the display of the acquisition
        self.T_display = 1

        # Mode of the digitizer.
        self.mode = 'CHANNEL_AB'

        # For the display, we get all parameters at the end of the
        # initialization
        self.get_all()



    def get_all(self):
        """"""
            Get all parameters of the board.
            Normally executed at the initialization of the instrument
        """"""

        logging.info(__name__ + ' : get all')

        self.get_clock_edge()
        self.get_clock_source()
        self.get_samplerate()

        self.get_trigger_level()
        self.get_trigger_range()
        self.get_trigger_slope()
        self.get_trigger_delay()

        self.get_acquisition_time()
        self.get_averaging()
        self.get_nb_sequence()

        self.get_completed_acquisition()

        self.get_mode()



    #########################################################################
    #
    #
    #                           Methods about the parameters of the board
    #
    #
    #########################################################################



    def _get_parameters(self):
        """"""
            Create a Manager for the multiprocessing containing all parameters
            needed to tune the board.
            The method returns the manager as pickable variable.
        """"""

        manager    = mp.Manager()
        parameters = manager.dict()

        # Clock parameters
        parameters['samplerate']   = self.samplerate
        parameters['clock_source'] = self.clock_source
        parameters['clock_edge']   = self.clock_edge

        # Trigger parameters
        parameters['trigger_range'] = self.trigger_range
        parameters['trigger_slope'] = self.trigger_slope
        parameters['trigger_level'] = self.trigger_level
        parameters['trigger_delay'] = self.trigger_delay

        # Acquisition parameters
        parameters['samplesPerRecord']        = self.samplesPerRecord
        parameters['records_per_buffer']      = self.records_per_buffer
        parameters['nb_buffer_allocated']     = self.nb_buffer_allocated
        parameters['buffers_per_acquisition'] = self.buffers_per_acquisition
        parameters['nb_sequence']             = self.nb_sequence

        # Correspondence between user parameters and board command
        parameters['allow_samplerates']    = self.allow_samplerates
        parameters['allow_clock_edges']    = self.allow_clock_edges
        parameters['allow_clock_sources']  = self.allow_clock_sources
        parameters['allow_trigger_ranges'] = self.allow_trigger_ranges
        parameters['allow_trigger_slopes'] = self.allow_trigger_slopes

        # Communication parameters to end correctly the measurement
        parameters['measuring']        = True # True means measuring
        parameters['safe_acquisition'] = False # True means the board has been closed properly
        parameters['safe_treatment']  = [False, False] # True means the treatment is finished
        parameters['measured_buffers'] = None

        # Mode of the digitizer
        parameters['mode'] = self.mode

        return parameters



    #########################################################################
    #
    #
    #                           Method to perform asynchroneous measurement
    #
    #
    #########################################################################



    def measurement_initialization(self, processor):
        """"""
            Initialize the board and launch a measurement.

            Input:
                - processor (obj instance): Instance of class coming from the
                  file DataTreatment with the class DataTreatment as parent.

            Output:
                - None
        """"""
        if self.mode == 'CHANNEL_AB':

            # In case operation mode is 'CHANNEL_AB',
            # two data treatment processed are required

            queue_data=[None, None]
            self.queue_treatment=[None, None]
            self.worker_treat_data=[None, None]

            # We create shared memory to share data between processes
            queue_data[0]       = mp.Queue() # Contains measured data cha channel
            queue_data[1]       = mp.Queue() # Contains measured data chb channel

            self.queue_treatment[0] = mp.Queue() # Contains treated data
            self.queue_treatment[1] = mp.Queue() # Contains treated data

            # Obtain all the parameters to set the board
            self.parameters      = self._get_parameters()

            # We create the data treatment process
            self.worker_treat_data[0] = mp.Process(target = processor.treat_data,
                                                    args   = (queue_data[0],
                                                              self.queue_treatment[0],
                                                              self.parameters))

            self.worker_treat_data[1] = mp.Process(target = processor.treat_data,
                                                    args   = (queue_data[1],
                                                              self.queue_treatment[1],
                                                              self.parameters))

            # We create the data acquisition process
            self.worker_acquire_data = mp.Process(target = data_acquisition.get_data,
                                                  args   = (queue_data,
                                                            self.parameters))

            # At this point the process is started
            # Consequently, the measurement is launched.
            self.worker_acquire_data.start()
            self.worker_treat_data[0].start()
            self.worker_treat_data[1].start()

            # The share memories are not used anymore in this process
            queue_data[0].close()
            queue_data[1].close()

            # Initialize the number of acquired sequence to zero
            self._acquired_sequences = 0.

        elif self.mode in {'CHANNEL_A', 'CHANNEL_B', 'FFT'}:

            # In case operation mode is 'CHANNEL_A' or 'CHANNEL_B' or 'FFT',
            # only one data treatment process is required

            # We create shared memory to share data between processes
            queue_data       = mp.Queue() # Contains measured data cha channel

            self.queue_treatment = mp.Queue() # Contains treated data


            # Obtain all the parameters to set the board
            self.parameters      = self._get_parameters()

            # We create the data treatment process
            self.worker_treat_data = mp.Process(target = processor.treat_data,
                                                    args   = (queue_data,
                                                              self.queue_treatment,
                                                              self.parameters))

            # We create the data acquisition process
            self.worker_acquire_data = mp.Process(target = data_acquisition.get_data,
                                                  args   = (queue_data,
                                                            self.parameters))

            # At this point the process is started
            # Consequently, the measurement is launched.
            self.worker_acquire_data.start()
            self.worker_treat_data.start()

            # The share memories are not used anymore in this process
            queue_data.close()

            # Initialize the number of acquired sequence to zero
            self._acquired_sequences = 0
        else:

            raise ValueError('mode of the digitizer must be ""CHANNEL_AB"" or \
                             ""CHANNEL_A"" or ""CHANNEL_B"" or ""FFT""')

    def measurement(self):
        """"""
            Return the data treated with the processor given in the
            measurement_initialization method.

            Since plotting is a slow operation, treated data are returned every T_display.
            The while loop is here to ensure that the treatment queue is emptied as fast as possible.

            Input:
                - None
            Output:
                - None
        """"""

        start_meas = time.clock() # Keep track of when the measurement started

        while time.clock()-start_meas< self.T_display and self.get_completed_acquisition() != 100.:
            # Each times the treatment buffer memory is loaded means a  new
            # averaging has been treated

            if self.mode == 'CHANNEL_AB':
                # In case operation mode is 'CHANNEL_AB',
                # two data treatment processed are required
                result = self.queue_treatment[0].get(), self.queue_treatment[1].get()
            elif self.mode in {'CHANNEL_A', 'CHANNEL_B', 'FFT'}:
                # In case operation mode is 'CHANNEL_A' or 'CHANNEL_B' or 'FFT',
                # only one data treatment process is required
                result = self.queue_treatment.get()
            else:
                raise ValueError('mode of the digitizer must be ""CHANNEL_AB"" or \
                                 ""CHANNEL_A"" or ""CHANNEL_B"" or ""FFT""')

            self._acquired_sequences += 1.

        # We update the percentage of the measurement
        self.get_completed_acquisition()

        # We return the data of the buffer memory
        return result


    def measurement_close(self, transfert_info=False):
        """"""
            Finish properly the measurement
            First inform the board that the measurement is finished and next
            wait until the board as properly ""close"" the board.

            Input:
                - transfert_info (booleen): If True return the transfert rate
                information
            Output:
                - transfert_info (str): If requested the transfert info
        """"""

        # We inform child process that the measurement is finished
        self.parameters['measuring'] = False

        # While the child process doesn't ""close"" properly the board and the
        # data treatment is finished, we wait
        while not self.parameters['safe_acquisition'] and not all(self.parameters['safe_treatment']):

            pass

        # Once the board is ""close"" properly, we close the FIFO memory and
        # we close the child processes and the share memory

        if self.mode == 'CHANNEL_AB':
            # In case operation mode is 'CHANNEL_AB',
            # two data treatment processed are required
            self.queue_treatment[0].close()
            self.queue_treatment[1].close()
            self.worker_acquire_data.terminate()
            self.worker_treat_data[0].terminate()
            self.worker_treat_data[1].terminate()
        elif self.mode in {'CHANNEL_A', 'CHANNEL_B', 'FFT'}:
            # In case operation mode is 'CHANNEL_A' or 'CHANNEL_B' or 'FFT',
            # only one data treatment process is required
            self.queue_treatment.close()
            self.worker_acquire_data.terminate()
            self.worker_treat_data.terminate()
        else:
            raise ValueError('mode of the digitizer must be ""CHANNEL_AB"" or \
                             ""CHANNEL_A"" or ""CHANNEL_B"" or ""FFT""')


        self._acquired_sequences = 0.
        self.get_completed_acquisition()

        if transfert_info:
            return self.parameters['message']



    #########################################################################
    #
    #
    #                           Acquisition
    #
    #
    #########################################################################



    def do_set_acquisition_time(self, acquisition_time):
        '''Set the acquisition time in [ns]

            Input:
                - acquisition_time (float): The acquisition time in [ns].
                 The minimum number of sample being 256.
                 The minimum acquisition time is then 256/samplerate.
                 The acquisition time will be round the closest value reachable
                 considering the samplerate.

                 The number of acquired sample must be a multiple of 128.
                 The number of acquired sample will be round the closest value
                 reachable.


            Output:
                - None

                # - acquisition_time (float): The acquisition time in [ns] set
                #  in the board.
                #  - acquisition_samples (int): The number of acquired sample set
                #   in the board.
            '''

        if acquisition_time >= 256./self.samplerate*1e3:

            samplesPerRecord      = round(self.samplerate*acquisition_time*1e-3)
            self.samplesPerRecord = int(round(samplesPerRecord/128)*128)
            self.acquisition_time = self.samplesPerRecord/self.samplerate*1e3

            # To display the new value of acquired sample of get it
            # self.get_samplesPerRecord()
        else:

            raise ValueError('The acquisition time must be longer than '\
                             +str(round(256./self.samplerate*1e3,2))+' ns.')



    def do_get_acquisition_time(self):
        '''Get the acquisition time in [ns]

            Input:
                - None.

            Output:
                - acquisition_time (float): The acquisition time in [ns].
        '''

        return self.acquisition_time



    def do_set_averaging(self, nb_averaging, output=False):
        '''
            Set the number of averaging.
            It should be even.
            When nb_averaging x nb_sequence >100, nb_averaging must be a
            multiple of 100

            Input:
                - nb_averaging (int): number of averaging
                - output (booleen): To obtain information about the card
                    parameters

            Output:
                - None.
        '''

        if nb_averaging%2:
            raise ValueError('The number of averaging should be even')

        if nb_averaging*self.nb_sequence < self.default_records_per_buffer:
            self.buffers_per_acquisition = 1
            self.records_per_buffer      = int(nb_averaging*self.nb_sequence)
        else:
            self.buffers_per_acquisition = int(np.ceil(float(nb_averaging*self.nb_sequence)/self.records_per_buffer))

        if output:
            m  = 'buffer per acquisition:', self.buffers_per_acquisition
            m += 'records per buffer:', self.records_per_buffer
            m += 'number of sequence:', self.nb_sequence
            m += 'averaging:', self.get_averaging()
            m += 'tot:', self.buffers_per_acquisition*self.records_per_buffer

            return m

    def do_get_averaging(self):
        '''
            Get the number of averaging

            Input:
                - None.

            Output:
                - number_of_averaging (int): number of averaging
        '''

        return self.buffers_per_acquisition*self.records_per_buffer/self.nb_sequence


    def do_set_nb_sequence(self, nb_sequence, output=False):
        '''
            Set the number of nb_sequence.
            It should be an even number.

            Input:
                - nb_sequence (int): number of sequence
                - output (booleen): To obtain information about the card
                    parameters

            Output:
                - None.
        '''

        if nb_sequence<(self.default_records_per_buffer +1):
            self.records_per_buffer         = int(nb_sequence)
            self.nb_sequence = int(nb_sequence)
        else:
            self.records_per_buffer         = self.default_records_per_buffer
            self.nb_sequence = int(nb_sequence)

        if output:
            m  = 'buffer per acquisition:', self.buffers_per_acquisition
            m += 'records per buffer:', self.records_per_buffer
            m += 'number of sequence:', self.nb_sequence
            m += 'averaging:', self.get_averaging()
            m += 'tot:', self.buffers_per_acquisition*self.records_per_buffer

            return m


    def do_get_nb_sequence(self):
        '''
            Get the number of sequence

            Input:
                - None.

            Output:
                - number_of_sequence (int): number of sequence
        '''

        return self.nb_sequence



    #########################################################################
    #
    #
    #                           The trigger
    #
    #
    #########################################################################



    def do_set_trigger_delay(self, trigger_delay):
        '''
            Set the waitting time after which the board has received a trigger
            event before capturing a record in [ns]

            Input:
                - trigger_delay (float): Triger delay in [ns]

            Output:
                - None.
        '''

        self.trigger_delay = trigger_delay



    def do_get_trigger_delay(self):
        '''
            Get the trigger delay in [ns]

            Input:
                - None.

            Output:
                - trigger_delay (float): Triger delay in [ns]
        '''

        return self.trigger_delay



    def do_set_trigger_level(self, trigger_level):
        '''
            Set the level that the trigger source must rise above, or fall
            below, for the selected trigger to become active.

            Input:
                - trigger_level (float): Triger level in [V]
                Must be in the limit of the trigger range.

            Output:
                - None.
        '''

        # If the trigger level is in the trigger range, we accept it
        if trigger_level <  self.trigger_range and \
            trigger_level > -self.trigger_range :

            self.trigger_level = trigger_level
        else:
            raise ValueError('The trigger level must be in the input range\
                             of the trigger, here '+str(self.trigger_range)\
                             +' V.')



    def do_get_trigger_level(self):
        '''
            Get the trigger level in [V]

            Input:
                - None.

            Output:
                - trigger_level (float): Triger level in [V]
        '''

        return self.trigger_level



    def do_set_trigger_range(self, trigger_range):
        '''Set the input range of the trigger channel in [V].

            Input:
                - trigger_range (float|int): Select input range of the
                 trigger channel. Must be [5, 2.5, 1] [V].
                 The new trigger range has to contain the trigger level

            Output:
                - None.
        '''

        if trigger_range > self.trigger_level :

            self.trigger_range = trigger_range
        else:

            raise ValueError('The trigger range must contain the trigger level')



    def do_get_trigger_range(self):
        '''Get the input range of the trigger channel.

            Input:
                - None.

            Output:
                - trigger_range (float|int): Input range of the
                 trigger channel [5, 2.5, 1].
        '''

        return self.trigger_range



    def do_set_trigger_slope(self, trigger_slope):
        '''
            Set the sign of the rate of change of the trigger signal
            with time when it crosses the trigger voltage level that is
            required to generate a trigger event.

            Input:
                - trigger_range (string): ['positive', 'negative'].

            Output:
                - None.
        '''
        self.trigger_slope = trigger_slope.lower()



    def do_get_trigger_slope(self):
        '''
            Get the sign of the rate of change of the trigger signal
            with time when it crosses the trigger voltage level that is
            required to generate a trigger event.

            Input:
                - None.

            Output:
                - trigger_range (string): ['positive', 'negative'].
        '''

        return self.trigger_slope



    #########################################################################
    #
    #
    #                           The clock
    #
    #
    #########################################################################



    def do_set_clock_edge(self, clock_edge):
        '''Set the clock edge of the board.

            Input:
                - clock_edge (string): Select the external clock edge on which
                                       to latch samples data. Must be either
                                       ""rising"" or ""failing"".

            Output:
                - None.
        '''

        if clock_edge.lower() in self.allow_clock_edges:

            self.clock_edge = clock_edge.lower()
        else:
            raise ValueError('Samplerate not allowed by the board')



    def do_get_clock_edge(self):
        '''Get the clock edge of the board.

            Input:
                - None.

            Output:
                - clock_edge (string): The external clock edge on which
                                       to latch samples data. Either
                                       ""rising"" or ""failing"".
        '''

        return self.clock_edge



    def do_set_samplerate(self, samplerate):
        '''Set the samplerate of the board.

            Input:
                - samplerate (float): If the clock source is internal
                  the samplerate must be one of the following string: 1e-3,
                  2e-3, 5e-3, 10e-3, 20e-3, 50e-3, 100e-3, 200e-3, 500e-3, 1.,
                  2., 5., 10., 20., 50., 100., 200., 500., 800., 1e3, 1.2e3,
                  1.5e3, 1.8e3.

                  If the clock is set to be external (assumed 10MHz external
                  clock) or fast_external, all samplerates greater than 300MHz and smaller than
                  1800MHZ being a multiple of 1 MHz are allowed [should be
                  given in MS/s].

            Output:
                - None.
        '''

        # If the board uses its internal clock, only certains samplerate are
        # allowed, see dictionnary self.samplerates.

        # If the board uses its external clock, all samplerates greater than
        # 300MHz and smaller than 1800MHZ being a multiple of 1 MHz are
        # allowed.

        if self.clock_source == 'internal':

            if samplerate in self.allow_samplerates:

                self.samplerate = float(samplerate)

                # To display the new value of acquisition time
                self.set_acquisition_time(self.samplesPerRecord/self.samplerate*1e3)
            else:

                raise ValueError('Samplerate not allowed by the board')

        elif self.clock_source == 'external':

            if samplerate >= 300. and samplerate <= 1800.:

                self.samplerate = float(samplerate)

                # To display the new value of acquisition time
                self.set_acquisition_time(self.samplesPerRecord/self.samplerate*1e3)
            else:

                raise ValueError('Samplerate not allowed by the board')

        elif self.clock_source == 'fast_external':

            if samplerate >= 300. and samplerate <= 1800.:

                self.samplerate = float(samplerate)

                # To display the new value of acquisition time
                self.set_acquisition_time(self.samplesPerRecord/self.samplerate*1e3)
            else:

                raise ValueError('Samplerate not allowed by the board')

        else:

            raise ValueError('The clock source must be set to ""internal""\
                              or ""external"" or ""fast_external"".')



    def do_get_samplerate(self):
        '''Get the samplerate of the board.

            Input:
                -

            Output:
                -
        '''

        return self.samplerate



    def do_set_clock_source(self, clock_source):
        '''Set the clock source of the board.

            Input:
                - clock_source (string): Must be either ""internal"" or
                 ""external"" or fast_external.

            Output:
                - None.
        '''

        if clock_source.lower() in self.allow_clock_sources:

            self.clock_source = clock_source.lower()
        else:

            raise ValueError('clock_source argument must be ""internal"" or \
                             ""external"" or ""fast_external"".')



    def do_get_clock_source(self):
        '''Get the clock source of the board.

            Input:
                -

            Output:
                -
        '''

        return self.clock_source



    #########################################################################
    #
    #
    #                           Status of the acquisition
    #
    #
    #########################################################################



    def do_get_completed_acquisition(self):
        """"""
            Return the percentage of completed acquisition.

            Input:
                - None

            Output:
                - percentage (float)
        """"""


        return round(self._acquired_sequences*100./self.get_averaging(), 2)


    #########################################################################
    #
    #
    #                           Mode of the digitizer
    #
    #
    #########################################################################

    def do_set_mode(self, mode):
        '''Set the working mode of the digitizer.

            Input:
                - mode (string): Must be ""CHANNEL_AB"" or
                                 ""CHANNEL_A"" or ""CHANNEL_B"" or ""FFT""

            Output:
                - None.
        '''
        if mode in self.allow_modes:

            self.mode = mode
        else:

            raise ValueError('mode of the digitizer must be ""CHANNEL_AB"" or \
                             ""CHANNEL_A"" or ""CHANNEL_B"" or ""FFT""')


    def do_get_mode(self):
        '''Get the working mode of the digitizer

            Input:
                -

            Output:
                - mode (string)
        '''

        return self.mode
"
377,5420.0,USA,"The Keysight Technologies, Inc. 34401A multimeter gives you the performance you need for fast, accurate bench and system testing. The 34401A provides a combination of resolution, accuracy and speed that rivals DMMs costing many times more. 6½ digits of resolution",Agilent 34401 A,31.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software

",Qcodes,Agilent,"[OrderedDict([('id', 'attV1ibS9mYuQPXiE'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WIzfYB_JTBkg_VBmMIv-Gg/y2R1e-mUreDX7Hd-v5T-NI_BE-z5-gpqXGiBI2nsvm5ehqdf9pNShiO_BJQpJw7AtOqIarrd9EbL3NjCevu0Q1LdjtM0MnjS-YFQUrcmzqI/7jPVUphFr8JHn3s-bEvNNc-gwEDmM7Os4tgd6lMpEv8'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FACHfBvLQAb25RAdxtVw5A/jEWx_oYg0PfeSnGImEzDTgTa0KxyDO3GkKZsjzm6p6a4fYonhtYKOMNaVNBeKT1_teTE-5a_9v15rBr0lc7mOJiE82WUmnnie--M60xYYXY/rWGCdS7jf12PeuCmFaRehRPE3aaP77USN6xJdJQQiQI'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/vaGOLxc-NmRZIaUTjD7Zjw/i0NHBpckB1OEtpeUVjdVfrcFpyiCjP7jkpObXwhP_ceauColYZHm7gdW17bz2T-Pn0R6Y0Zj-3Uu5O8fS7W6jjzQdYDClnhq63rdYzGJ8IU/UMg4RtxK0MukT0sytOSgY6Q_09CixaU4rb86iQso8mM'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JAuv7ioqCoQNOAhHI_5xTw/hont5c_z1R5U8_ELG6PyAGEbwVz3SaT--HTXlRTzVc1SFxOy3ozCxHEM0A5QUnuqD0Wqg3dPiNJsofYSVdYuSn3PBjS8eKB0AZ8wMoZhzOI/5nCAoU_76tB5FRRS69G_B2tSo-fPOQsAw0EAeod7NKw'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT - 34401A Multimeters,https://www.keysight.com/us/en/products/digital-multimeters-dmm.html,['Multimeters'],"Keysight's digital multimeter family offers exceptional performance and reliability from 3.5 to 8.5 digits resolution with measurement speeds up to 100,000 readings/sec, and available in handheld or bench applications.",KEYSIGHT - 34401A,https://www.keysight.com/us/en/assets/7018-06774/data-sheets/5968-0162.pdf,"[OrderedDict([('id', 'att9b4fdU88PPuq2T'), ('width', 1164), ('height', 628), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yiXeNk2sPBptp60ZIG1hWg/Yc8qYRjsfI2kDHivbjYY7CdjjIFImYT_kSFtVJllqc3DLG9aJNLSM6yI7m6eOIh7QVSuSEtc1qeYrM2DINdr3mQpWBRtF59W1RcKsxqM7-I/MhwmN1iZKiaEPqjINxQPiDHPoZyYJnpmxZibJgHi6Xk'), ('filename', '34401A.png'), ('size', 394318), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_YlaMMXGQ_hjZ3O_YFLnGQ/jOOiI99OCHM1Lurs5TsjyXjQiv4sdqSEe7IDZcqtWhu5deK54LMSipZ_42GJpTJaQGdLdumcFMEs4O1LBMkOJw/rGsxv9dhcQbQ1Rx6Xpusxu14KsTex0v0_quTN1ruPAo'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IAIx8OjI_A-5BzXvf2jBbA/q2aXtG-NlnjuTC-IHEnvupqRDSmtlEpKF3k_atKLLxKdGrCF3h3evl5Rjt4crdkI2wt4b85eBCKLpSLUVMQUuA/dIOOn_GjG5EKhOfbNgB3MoAKa5YVR4LtHByJmFpJCP0'), ('width', 949), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/5UJovzNuXIMiBeLJ17xXOw/goxBbx_K6odqmnw9rs1WOe3EzPmaeBgDkiwoxQ81k79rZY0MqKVGRdcKTEmKZ8MYT9phsdGpd0UAWain93FsXA/gT7uHJXiMywff3syTWo3AjBJI5LJaobMFEHWHmdbbIg'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/34401A/digital-multimeter-6-digit.html,https://github.com/PY1CX/HP-34401A-Python,https://pymeasure.readthedocs.io/en/latest/api/instruments/hp/hp34401A.html,,"
",True,,
381,5420.0,USA,"The Keysight 34980A Multifunction Switch/Measure unit is designed for R&D and
manufacturing test engineers who are working in design verification, automated
test or data acquisition and are either looking to upgrade their existing systems or
are in need of a new, cost-effective alternative",Keysight 34980 A Submodules,340.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,"Write a Python script that uses Qcodes to connect to a KEYSIGHT 34980A Submodules DAQ boards, Multimeters",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,"['DAQ boards', 'Multimeters']","With 19 different plug-in modules in low frequency, RF and microwave switching to
20GHz, digital I/O, D/A converters, and counter/totalizer functionality, the 34980A
has the core switch/measure functionality needed for most automated test and
data acquisition applications. The 34980A can accommodate up to 560 2-wire
MUX or 1024 2-wire matrix crosspoints in one mainframe.",KEYSIGHT 34980A Submodules,https://www.keysight.com/us/en/assets/7018-01247/data-sheets/5989-1437.pdf,"[OrderedDict([('id', 'attep8JPM5PjAYEs7'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mb5C2yklE5HVreUbteeFRA/nTCFY1v8dDOvMsTkWDmP99VT89yzx0dB0V3rrPSYrne8QErKTs0QYL8E4w24LMN5Zwp20fdq9fHzTh5uKkevu53dpyDhe-DQtzj-3PjSsdiShfN_w7P6-BOwyuqtGwC1/s5OFBgadwUmqv7IP3sJPF5mqDKfU296KeGIdil_j7ww'), ('filename', '34980A-FRONT-TRANSP-01-20190415.png'), ('size', 891966), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wuLUGOr7_9iHae3fKdQAhw/kMs_HN9I5anpN0hp3b-JcvN57c2fZMpFeKPd-00v5QfcdVbcmWtS5zAreR9sLqf4QnLCJkUGj5cArbpmD1agCQ/gD3JL7VkNHlgqagDfbyEriyklDrvWKnS9Ri-UvRACyY'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CSsgSevVRewVhbB-boT37A/UCMNTOJDT97X5PLZsjhxOOw4GN1nuWl9upN-W0Ebg-e65b4KTC-S85srUE_idV7OjpTcP96PVqoiagiLnt9uUg/emdk6yfso3D8rAycxj0EJkPoLOkOvwmBneRRk1diTL0'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/e1ML_kS_AjII3MwxapWXPw/lMrhgSIwQZqiE9p0QQj3ep2zTX6ugimb7sTl9qffw1QViiqSH6_lpriOzThZsVSij69MOwWvhOmHlxyN8_Hofg/O01U6lPj7KIokJT7KjqkPEgWPPuM9SJLQ04_ngtvTao'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01269/flyers/5989-1874.pdf,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/keysight_34980a_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34980ASwitchMatrixSubModule,4167.0,,,,"from qcodes import VisaInstrument, InstrumentChannel
from typing import Union, List, Tuple, Optional


class KeysightSubModule(InstrumentChannel):
    """"""
    A base class for submodules for the 34980A systems.

    Args:
        parent: the system which the module is installed on
        name: user defined name for the module
        slot: the slot the module is installed
    """"""
    def __init__(
            self,
            parent: Union[VisaInstrument, InstrumentChannel],
            name: str,
            slot: int
    ) -> None:

        super().__init__(parent, name)

        self.slot = slot


class KeysightSwitchMatrixSubModule(KeysightSubModule):
    """"""
    A base class for **Switch Matrix** submodules for the 34980A systems.
    """"""
    def validate_value(self, row: int, column: int) -> None:
        """"""
        to check if the row and column number is within the range of the module
        layout.

        Args:
            row: row value
            column: column value
        """"""
        raise NotImplementedError(""Please subclass this"")

    def to_channel_list(
            self,
            paths: List[Tuple[int, int]],
            wiring_config: Optional[str] = None
    ) -> str:
        """"""
        convert the (row, column) pair to a 4-digit channel number 'sxxx', where
        s is the slot number, xxx is generated from the numbering function.
        This may be different for different modules.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
            wiring_config: for 1-wire matrices, values are 'MH', 'ML';
                                 for 2-wire matrices, values are 'M1H', 'M2H',
                                 'M1L', 'M2L'

        Returns:
            in the format of '(@sxxx, sxxx, sxxx, sxxx)', where sxxx is a
            4-digit channel number
        """"""
        raise NotImplementedError(""Please subclass this"")

    def is_open(self, row: int, column: int) -> bool:
        """"""
        to check if a channel is open/disconnected

        Args:
            row: row number
            column: column number

        Returns:
            True if the channel is open/disconnected
            False if it's closed/connected.
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        message = self.ask(f'ROUT:OPEN? {channel}')
        return bool(int(message))

    def is_closed(self, row: int, column: int) -> bool:
        """"""
        to check if a channel is closed/connected

        Args:
            row: row number
            column: column number

        Returns:
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        message = self.ask(f'ROUT:CLOSe? {channel}')
        return bool(int(message))

    def connect(self, row: int, column: int) -> None:
        """"""
        to connect/close the specified channels

        Args:
            row: row number
            column: column number
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        self.write(f'ROUT:CLOSe {channel}')

    def disconnect(self, row: int, column: int) -> None:
        """"""
        to disconnect/open the specified channels

        Args:
            row: row number
            column: column number
        """"""
        self.validate_value(row, column)
        channel = self.to_channel_list([(row, column)])
        self.write(f'ROUT:OPEN {channel}')

    def connect_paths(self, paths: List[Tuple[int, int]]) -> None:
        """"""
        to connect/close the specified channels.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        self.write(f""ROUTe:CLOSe {channel_list_str}"")

    def disconnect_paths(self, paths: List[Tuple[int, int]]) -> None:
        """"""
        to disconnect/open the specified channels.

        Args:
            paths: list of channels to connect [(r1, c1), (r2, c2), (r3, c3)]
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        self.write(f""ROUTe:OPEN {channel_list_str}"")

    def are_closed(self, paths: List[Tuple[int, int]]) -> List[bool]:
        """"""
        to check if a list of channels is closed/connected

        Args:
            paths: list of channels [(r1, c1), (r2, c2), (r3, c3)]

        Returns:
            a list of True and/or False
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        messages = self.ask(f""ROUTe:CLOSe? {channel_list_str}"")
        return [bool(int(message)) for message in messages.split(',')]

    def are_open(self, paths: List[Tuple[int, int]]) -> List[bool]:
        """"""
        to check if a list of channels is open/disconnected

        Args:
            paths: list of channels [(r1, c1), (r2, c2), (r3, c3)]

        Returns:
            a list of True and/or False
            True if the channel is closed/connected
            False if it's open/disconnected.
        """"""
        for row, column in paths:
            self.validate_value(row, column)
        channel_list_str = self.to_channel_list(paths)
        messages = self.ask(f""ROUTe:OPEN? {channel_list_str}"")
        return [bool(int(message)) for message in messages.split(',')]
"
384,5420.0,USA,"The Keysight N5230C PNA-L is a microwave network analyzer made to test amplifiers, passive parts, and frequency converters using S-parameters and basic nonlinearity. The Keysight N5230C has a 110 dB system / 122 dB receiver dynamic range. The N5230C has a 300 kHz to 20 GHz frequency range and has 2 or 4 ports with built-in sources. ",Keysight N 5230 C,312.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5230C Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"Vector network analyzers are crucial for the characterization of the devices and components used in radio frequency and microwave systems. This includes network testing for wifi, computer networks, cell phone coverage, and much more. These powerful devices are used in various stages of product development and can be used to verify the performance of various components such as antennas, amplifiers, cables, and many other active or passive devices. We use network analyzers to test these components to verify specifications of building blocks for more complex RF systems. Testing these systems ensures distortion-free transmission of communication signals and ensures a good match when absorbing power.",KEYSIGHT N5230C,https://www.keysight.com/us/en/assets/7018-01701/data-sheets/5989-7607.pdf,"[OrderedDict([('id', 'attPtUSwhI8DGuduQ'), ('width', 300), ('height', 200), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/jJcL7QnGH4JEPL7IqE5SYg/qwZS5JoXppcjKOjavFIPbEGpvOUoaOo6iz12JlLR7e1zTkzqA0sdMLPPooAYdjPkLRjWjtCsLCRUQrSFz1p1cVdy9U8bMXdDxgIjQyNzV7g/4KO3O6NNg2BOWY_abplcfCS1hHKl9ogWrgbfKjGxaTw'), ('filename', 'PROD-2813653-01.jpeg'), ('size', 8794), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rPcIK81QHA_mCyCebVUuTw/xF7MqjVWog8HySV3K0atpZI2JmGr03uERySZVaag_o442R84GmwlxHNgaTTcCvy9ybQgJHPW5zJml1J5ifnsIg/A2Pi8wtUYRegBGvs-JzHzJqY1v5JvsYFsgj6qRk64PQ'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-5eaI6FK0y7SPZmK-gBmeg/J49XTfNOduCJp4dn-XOY9v0FQPFTLz84bf_Pb2tyCa15Qn_Ww77F1ZD6779xT3aGTmupwGfJGlB2W45xt1qHbQ/2WJTYBoDj_ak_h8oDKDMRk_c-3M4veYGRfk_JP-8TN4'), ('width', 300), ('height', 200)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/gSwepX8XZhKolTtYH3beaw/zurMqXJBYIQwCoFl_KEp85-FRwaeVUdiKadVZl3am-Z2kZIe0ycCFhEJMCTysvK19-7Lfop5jq7WDzka1sJJkg/cM1py6CmvBflcejuw14H16zL_lS_x5B6RIoPzBPoLwQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.atecorp.com/products/keysight-technologies/n5230c?utm_campaign=15209129943&utm_source=google&utm_medium=cpc&utm_content=561353703737&utm_term=n5230c&adgroupid=133315120241&gclid=CjwKCAjwkeqkBhAnEiwA5U-uM_jEyq6KdRiHb-ejDqCOp_dmY1vg0I-730tGgDsNF7YH_L9dfrCPORoCRWIQAvD_BwE,https://github.com/QCoDeS/Qcodes/blob/v0.25.0/qcodes/instrument_drivers/Keysight/N5230C.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5230C,19995.0,,True,,"from typing import Any

from . import N52xx

class N5230C(N52xx.PNABase):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address,
                         min_freq=300e3, max_freq=13.5e9,
                         min_power=-90, max_power=13,
                         nports=2,
                         **kwargs)
"
385,110.6,"Cleveland, Ohio, United States","The Model 3706A system switch with high performance DMM contains six slots for plug-in cards in a compact 2U high enclosure that easily accommodates the needs of medium to high channel count applications. When fully loaded, a mainframe can support up to 576 two-wire multiplexer channels for unrivaled density and economical per channel costs. The result is a tightly integrated switch and measurement solution that’s equally at home on the bench or in the rack.",Keithley 3706 A,264.0,"Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",Qcodes,Keithley,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/NeO02HKgoFPV3DNb9vOFuQ/oUOnoE3G5-QeCMyfgXyg8FqsnOeauIly5GBoFYr9Za8Zrr0680YSs6QaLZbjSLo7PoMQ00w0RPeo8KNMcbYt2atP2MKHb0B4-GyFD_CU3NjI0vDcK8LLowKujulyPoKADY3pAVNPMgBCEnKshd91bg/0TQRCCKsz0gJy1NFGfGsJsjM3QdRGQ8MoPDdSPPJdCA'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZnO_WGoJzGnSlUctBDqWew/3IevGml9FN4w1wC95p0SxkWfy9Or2KbV9QY3D0d1q_Sej0Zp6VH3gJgIsG75z_GB4Ob04GciukrNLZqRSkqxUA/uTVK9YUV68keAgFRR7IKhzRM4i5JrKr9C0Qtw0T9sOo'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qLTzFSMkPTLA6g9lkPJmsg/zyqBAfflKt_8lvw15arx51Xd9fYqp17v4WFX71buJSr6egMKaBsN1l-whDpCpYtjxp2PsM9RQH8m8m3yxtquXw/52L-EUk-XUGAnw0eN3grANao1iKKOIuxmavJUlgreXQ'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/DD76F3FSvA0sLYAXfST7DA/Y9vIBAtL1_Fy2BC2SLgyVwDmN2BpqCN-RepHfRd6uBzNVwzsKrLvHbBvYJti5ZoIf_VLDikmzoIRrzQ6Veuw7g/bIGTWhsUS3UoKan-BcRmMtd0TCP2TPvDoZpnD5k1pXQ'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a Keithley 3706A Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",Keithley 3706A,https://download.tek.com/datasheet/1KW-61232-0_Series_3700A_System_Switch_Multimeter_Datasheet_051122.pdf,"[OrderedDict([('id', 'att5DpqBAEQuD5qpR'), ('width', 320), ('height', 171), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/W6ZtZz1kZS1cjMLa86tyvA/xENUs4DPFqBRzAMUIPP6McZJyGLhvBAnlty2cUrlf9rZuuXDfaM7mDjI77FfJbZhYvnYHt3UfBLKajBa3-HQteAblNdQ5Ru3_PnHjQSxKFI/M3VI5MiQ15myJBR0QoIikuL06ibEJZ9CAC2YYjjPIic'), ('filename', '3706a.webp'), ('size', 2692), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/KQa8_QGiL2RnYFfWAKrEAA/b8uYOWKmfsgEGb3EDUKDn1TxRwTSNO0O4bQRDgG65tMvYIkiZmN2UyiB5wPedybCOR4XUCsfQ0h2KUZklW-j5-mgfYlOGuMsXECNVbnR0-k/tJvoYk-p7Y2aZpXC2YmebVjY7QkNPBocjuhpxGeO6c0'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/yw46IUP53e4sMuCBdI4UBQ/OJtCqfMZFsYuN9khj2yJVGk9ku_Addxl21se0CfBBTvtG-GqzArxKEEne8WfgKWCgc9bBfrHExQXvIS18QADVLyaEu6wHVHEmQs2dnLpxNI/PXpa-EkvuExCek5QJUrNJcReyfYOzHitb_GBR_v8BT8'), ('width', 320), ('height', 171)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-fuP9DP6LtPklAaP38HG-A/vjmJ4V_aTzme-B02RgPVgnUqkyKYyUDbDAyIssBBln5F2r7Oyvv8TSwEAvT0gvoVsFLvOGLHopGuvzMumtbGkNOz2t1sFNlDwotfcztj3wM/2SPlRjQ3MIts43E6HdAOw4V4VDZiHJ-2NaVmKpiFD90'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/keithley/switching-and-data-acquisition-systems/3700a-systems-switch-multimeter,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keithley/Keithley_3706A.py,https://qcodes.github.io/Qcodes//drivers_api/Keithley.html#qcodes.instrument_drivers.Keithley.Keithley3706A,5000.0,,,,"import itertools
import textwrap
import warnings
from typing import Any, Optional, Union

import qcodes.validators as vals
from qcodes.instrument import VisaInstrument
from qcodes.parameters import create_on_off_val_mapping


class Keithley3706AUnknownOrEmptySlot(Exception):
    pass


class Keithley3706AInvalidValue(Exception):
    pass


class Keithley3706A(VisaInstrument):
    """"""
    This is the QCoDeS instrument driver for the Keithley 3706A-SNFP
    System Switch.
    """"""

    def __init__(
        self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any
    ) -> None:
        """"""
        Args:
            name: Name to use internally in QCoDeS
            address: VISA resource address
        """"""
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""channel_connect_rule"",
            get_cmd=self._get_channel_connect_rule,
            set_cmd=self._set_channel_connect_rule,
            docstring=textwrap.dedent(
                """"""\
                                    Controls the connection rule for closing
                                    and opening channels when using
                                    `exclusive_close` and `exclusive_slot_close`
                                    parameters.

                                    If it is set to break before make,
                                    it is ensured that all channels open
                                    before any channels close.

                                    If it is set to make before break, it is
                                    ensured that all channels close before any
                                    channels open.

                                    If it is off, channels open and close
                                    simultaneously.""""""
            ),
            vals=vals.Enum(""BREAK_BEFORE_MAKE"", ""MAKE_BEFORE_BREAK"", ""OFF""),
        )

        self.add_parameter(
            ""gpib_enabled"",
            get_cmd=self._get_gpib_status,
            set_cmd=self._set_gpib_status,
            docstring=""Enables or disables GPIB connection."",
            val_mapping=create_on_off_val_mapping(on_val=""true"", off_val=""false""),
        )

        self.add_parameter(
            ""gpib_address"",
            get_cmd=self._get_gpib_address,
            get_parser=int,
            set_cmd=self._set_gpib_address,
            docstring=""Sets and gets the GPIB address."",
            vals=vals.Ints(1, 30),
        )

        self.add_parameter(
            ""lan_enabled"",
            get_cmd=self._get_lan_status,
            set_cmd=self._set_lan_status,
            docstring=""Enables or disables LAN connection."",
            val_mapping=create_on_off_val_mapping(on_val=""true"", off_val=""false""),
        )

        self.connect_message()

    def reset_channel(self, val: str) -> None:
        """"""
        Resets the specified channels to factory default settings.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays, slots or channel patterns to be queried.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.reset('{val}')"")

    def open_channel(self, val: str) -> None:
        """"""
        Opens the specified channels and backplane relays.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays, slots or channel patterns to be queried.
        """"""

        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.open('{val}')"")

    def close_channel(self, val: str) -> None:
        """"""
        Closes the channels and backplane relays.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        forbidden_channels = self.get_forbidden_channels(""allslots"")
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be closed all together."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        if val in forbidden_channels.split("",""):
            warnings.warn(
                ""You are attempting to close channels that are forbidden to close."",
                UserWarning,
                2,
            )

        self._warn_on_disengaged_interlocks(val)

        self.write(f""channel.close('{val}')"")

    def _warn_on_disengaged_interlocks(self, val: str) -> None:
        """"""
        Checks if backplance channels among the given specifiers can be
        energized dependening on respective hardware interlocks being
        engaged, and raises a warning for those backplane channels which
        cannot be energized.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays.
        """"""
        states = self.get_interlock_state()
        val_specifiers = val.split("","")
        for channel in val_specifiers:
            if self._is_backplane_channel(channel):
                slot = channel[0]
                interlock_state = [
                    state for state in states if state[""slot_no""] == slot
                ][0]
                if (
                    interlock_state[""state""]
                    == ""Interlocks 1 and 2 are disengaged on the card""
                ):
                    warnings.warn(
                        f""The hardware interlocks in Slot ""
                        f'{interlock_state[""slot_no""]} are disengaged. '
                        f""The analog backplane relay {channel} ""
                        ""cannot be energized."",
                        UserWarning,
                        2,
                    )

    def _is_backplane_channel(self, channel_id: str) -> bool:
        if len(channel_id) != 4:
            raise Keithley3706AInvalidValue(f""{channel_id} is not a valid channel id"")
        if channel_id[1] == ""9"":
            return True
        return False

    def exclusive_close(self, val: str) -> None:
        """"""
        Closes the specified channels such that any presently closed channels
        opens if they are not in the specified by the parameter.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be exclusively closed."")
        if val == """":
            raise Keithley3706AInvalidValue(
                ""An empty string may cause all channels and ""
                ""associated backplane relays to open. Use ""
                '""open_channel"" parameter instead.'
            )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        self.write(f""channel.exclusiveclose('{val}')"")

    def exclusive_slot_close(self, val: str) -> None:
        """"""
        Closes the specified channels on the associated slots abd opens any
        other channels if they are not specified by the parameter.

        Args:
            val: A string representing the channels, channel ranges,
                backplane relays to be queried.
        """"""
        slots = [""allslots"", *self._get_slot_names()]
        if val in slots:
            raise Keithley3706AInvalidValue(""Slots cannot be exclusively closed."")
        if val == """":
            raise Keithley3706AInvalidValue(""Argument cannot be an empty string."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels or channel ""
                ""ranges and associated backplane relays.""
            )
        self.write(f""channel.exclusiveslotclose('{val}')"")

    def _get_channel_connect_rule(self) -> str:
        connect_rule = {1: ""BREAK_BEFORE_MAKE"", 2: ""MAKE_BEFORE_BREAK"", 0: ""OFF""}
        rule = self.ask(""channel.connectrule"")
        return connect_rule[int(float(rule))]

    def _set_channel_connect_rule(self, val: str) -> None:
        self.write(f""channel.connectrule = channel.{val}"")

    def _get_gpib_status(self) -> str:
        return self.ask(""comm.gpib.enable"")

    def _set_gpib_status(self, val: Union[str, bool]) -> None:
        self.write(f""comm.gpib.enable = {val}"")

    def _get_lan_status(self) -> str:
        return self.ask(""comm.lan.enable"")

    def _set_lan_status(self, val: Union[str, bool]) -> None:
        self.write(f""comm.lan.enable = {val}"")

    def _get_gpib_address(self) -> int:
        return int(float(self.ask(""gpib.address"")))

    def _set_gpib_address(self, val: int) -> None:
        self.write(f""gpib.address = {val}"")

    def get_closed_channels(self, val: str) -> Optional[list[str]]:
        """"""
        Queries for the closed channels.

        Args:
            val: A string representing the channels,
                backplane relays or channel patterns to be queried.
        """"""
        if val == """":
            raise Keithley3706AInvalidValue(""Argument cannot be an empty string."")
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        data = self.ask(f""channel.getclose('{val}')"")
        if data == ""nil"":
            return None
        return data.split("";"")

    def set_forbidden_channels(self, val: str) -> None:
        """"""
        Prevents the closing of specified channels and backplane
        relays.

        Args:
            val: A string representing channels and backplane relays
                to make forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.setforbidden('{val}')"")

    def get_forbidden_channels(self, val: str) -> str:
        """"""
        Returns a string that lists the channels and backplane relays
        that are forbidden to close.

        Args:
            val: A string representing the channels,
                backplane relays or channel patterns to be queried to see
                if they are forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        return self.ask(f""channel.getforbidden('{val}')"")

    def clear_forbidden_channels(self, val: str) -> None:
        """"""
        Clears the list of channels that are forbidden to close.

        Args:
            val: A string representing the channels that will no longer
                be listed as forbidden to close.
        """"""
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, backplane relays or ""allslots"".'
            )
        self.write(f""channel.clearforbidden('{val}')"")

    def set_delay(self, val: str, delay_time: float) -> None:
        """"""
        Sets an additional delay time for the specified channels.

        Args:
            val: A string representing the channels for which there will
                be an additional delay time.
            delay_time: Delay time for the specified channels in seconds.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    ""Additional delay times cannot be set for ""
                    ""analog backplane relays.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        self.write(f""channel.setdelay('{val}', {delay_time})"")

    def get_delay(self, val: str) -> list[float]:
        """"""
        Queries for the delay times.

        Args:
            val: A string representing the channels to query for
                additional delay times.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    ""Additional delay times cannot be set for ""
                    ""analog backplane relays.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        delay_times = [
            float(x) for x in self.ask(f""channel.getdelay('{val}')"").split("","")
        ]
        return delay_times

    def set_backplane(self, val: str, backplane: str) -> None:
        """"""
        Sets the analog backplane relays to use with given channels
        when they are used in switching applications.

        Args:
            val: A string representing the list of channels to change.
            backplane: A string representing the list of analog backplane
                relays to set for the channels specified.
        """"""
        states = self.get_interlock_state()
        backplanes = self.get_analog_backplane_specifiers()
        plane_specifiers = backplane.split("","")
        val_specifiers = val.split("","")
        for element in states:
            if element[""state""] == ""Interlocks 1 and 2 are disengaged on the card"":
                warnings.warn(
                    f""The hardware interlocks in Slot ""
                    f'{element[""slot_no""]} are disengaged. '
                    ""The corresponding analog backplane relays ""
                    ""cannot be energized."",
                    UserWarning,
                    2,
                )
        for elem in val_specifiers:
            if elem in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{val} is not a valid specifier. ""
                    ""The specifier cannot be analog ""
                    ""backplane relay.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        for plane in plane_specifiers:
            if plane not in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{backplane} is not a valid specifier. ""
                    ""The specifier should be analog ""
                    ""backplane relay.""
                )
        self.write(f""channel.setbackplane('{val}', '{backplane}')"")

    def get_backplane(self, val: str) -> str:
        """"""
        Lists the backplane relays that are controlled in switching
        applications for specified channels.

        Args:
            val: A string representing the channels being queried.
        """"""
        backplanes = self.get_analog_backplane_specifiers()
        specifiers = val.split("","")
        for element in specifiers:
            if element in backplanes:
                raise Keithley3706AInvalidValue(
                    f""{val} cannot be a analog backplane relay.""
                )
        if not self._validator(val):
            raise Keithley3706AInvalidValue(
                f""{val} is not a valid specifier. ""
                ""The specifier should be channels, channel ""
                'ranges, slots, or ""allslots"".'
            )
        return self.ask(f""channel.getbackplane('{val}')"")

    def _get_slot_ids(self) -> list[str]:
        """"""
        Returns the slot ids of the installed cards.
        """"""
        cards = self.get_switch_cards()
        slot_id = [f""{card['slot_no']}"" for card in cards]
        return slot_id

    def _get_slot_names(self) -> list[str]:
        """"""
        Returns the names of the slots as ""slotX"",
        where ""X"" is the slot id.
        """"""
        slot_id = self._get_slot_ids()
        slot_names = [f""slot{x}"" for x in slot_id]
        return slot_names

    def _get_number_of_rows(self) -> list[int]:
        """"""
        Returns the total number of rows of the installed cards.
        """"""
        slot_id = self._get_slot_ids()
        total_number_of_rows = [
            int(float(self.ask(f""slot[{i}].rows.matrix""))) for i in slot_id
        ]
        return total_number_of_rows

    def _get_number_of_columns(self) -> list[int]:
        """"""
        Returns the total number of columns of the installed cards.
        """"""
        slot_id = self._get_slot_ids()
        total_number_of_columns = [
            int(float(self.ask(f""slot[{i}].columns.matrix""))) for i in slot_id
        ]
        return total_number_of_columns

    def _get_rows(self) -> list[list[str]]:
        """"""
        Returns the elements of each row.
        """"""
        total_number_of_rows = self._get_number_of_rows()
        row_list = []
        for item in total_number_of_rows:
            rows_in_each_slot = [str(i) for i in range(1, item + 1)]
            row_list.append(rows_in_each_slot)
        return row_list

    def _get_columns(self) -> list[list[str]]:
        """"""
        Returns the elements of each column.
        """"""
        total_number_of_columns = self._get_number_of_columns()
        column_list = []
        for item in total_number_of_columns:
            columns_in_each_slot = []
            for i in range(1, item + 1):
                if i < 10:
                    columns_in_each_slot.append(""0"" + str(i))
                else:
                    columns_in_each_slot.append(str(i))
            column_list.append(columns_in_each_slot)
        return column_list

    def _get_channel_ranges(self) -> list[str]:
        """"""
        A helper function that gets two channel names from the available
        channels list and join them via a colon to define a channel range.
        """"""
        range_list = []
        for i in self._get_slot_ids():
            channel = self.get_channels_by_slot(int(i))
            for element in itertools.combinations(channel, 2):
                range_list.append("":"".join(element))
        return range_list

    def get_channels(self) -> list[str]:
        """"""
        This function returns the name of the matrix channels.
        User can call this function to see the names of the available
        channels, in case he/she is not familiar with the naming convention.
        However, note that, this is a standalone helper function and
        the usage of channel attributes of the instrument driver does
        not depend on the functionality of this method.
        """"""
        slot_id = self._get_slot_ids()
        row_list = self._get_rows()
        column_list = self._get_columns()
        matrix_channels = []
        for i, slot in enumerate(slot_id):
            for element in itertools.product(slot, row_list[i], column_list[i]):
                matrix_channels.append("""".join(element))
        return matrix_channels

    def get_channels_by_slot(self, slot_no: int) -> list[str]:
        """"""
        Returns the channel names of a given slot.

        Args:
            slot_no: An integer value specifying the slot number.
        """"""
        slot_id = self._get_slot_ids()
        if str(slot_no) not in slot_id:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slot_id}.""
            )
        row_list = self._get_rows()
        column_list = self._get_columns()
        matrix_channels_by_slot = []
        for element in itertools.product(str(slot_no), row_list[0], column_list[0]):
            matrix_channels_by_slot.append("""".join(element))
        return matrix_channels_by_slot

    def get_analog_backplane_specifiers(self) -> list[str]:
        """"""
        Returns a list of comma separated strings representing available analog
        backplane relays. This function should not be mixed with the
        `get_backplane` method. The latter returns backplane relays which are
        associated with a channel by using `set_backplane` method.
        """"""
        backplane_common_number = ""9""
        backplane_relay_common_numbers = [""11"", ""12"", ""13"", ""14"", ""15"", ""16""]
        slot_id = self._get_slot_ids()
        analog_backplane_relays = []
        for element in itertools.product(
            slot_id, backplane_common_number, backplane_relay_common_numbers
        ):
            analog_backplane_relays.append("""".join(element))
        return analog_backplane_relays

    def _connect_or_disconnect_row_to_columns(
        self, action: str, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A private function that connects or (disconnects) given columns
        to (from) a row of a slot and opens (closes) the formed channels.
        """"""
        if action not in [""connect"", ""disconnect""]:
            raise ValueError(
                ""The action should be identified as either ""
                ""'connect' or 'disconnect'.""
            )
        slots = self._get_slot_ids()
        slot = str(slot_id)
        if slot not in slots:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slots}.""
            )
        row = str(row_id)
        columns_list = []
        for i in columns:
            if i < 10:
                columns_list.append(""0"" + str(i))
            else:
                columns_list.append(str(i))
        channels_to_connect_or_disconnect = []
        for element in itertools.product(slot, row, columns_list):
            channels_to_connect_or_disconnect.append("""".join(element))
        for channel in channels_to_connect_or_disconnect:
            if action == ""connect"":
                self.open_channel(channel)
            else:
                self.close_channel(channel)
        return channels_to_connect_or_disconnect

    def _connect_or_disconnect_column_to_rows(
        self, action: str, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A private function that connects (disconnects) given rows
        to (from) a column of a slot and opens (closes) the formed channels.
        """"""
        if action not in [""connect"", ""disconnect""]:
            raise ValueError(
                ""The action should be identified as either ""
                ""'connect' or 'disconnect'.""
            )
        slots = self._get_slot_ids()
        slot = str(slot_id)
        if slot not in slots:
            raise Keithley3706AUnknownOrEmptySlot(
                ""Please provide a valid slot identifier. ""
                f""Available slots are {slots}.""
            )
        column = []
        if column_id < 10:
            column.append(""0"" + str(column_id))
        else:
            column.append(str(column_id))
        rows_list = [str(x) for x in rows]
        channels_to_connect_or_disconnect = []
        for element in itertools.product(slot, rows_list, column):
            channels_to_connect_or_disconnect.append("""".join(element))
        for channel in channels_to_connect_or_disconnect:
            if action == ""connect"":
                self.open_channel(channel)
            else:
                self.close_channel(channel)
        return channels_to_connect_or_disconnect

    def connect_row_to_columns(
        self, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A convenient function that connects given columns to a row of a
        slot and opens the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            row_id: The specifier for the row to which the provided columns
                will be connected.
            columns: The specifiers of the columns will be connected to the
                provided row.
        """"""
        return self._connect_or_disconnect_row_to_columns(
            ""connect"", slot_id, row_id, columns
        )

    def disconnect_row_from_columns(
        self, slot_id: int, row_id: int, columns: list[int]
    ) -> list[str]:
        """"""
        A convenient function that disconnects given columns to a row of a
        slot and closes the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            row_id: The specifier for the row to which the provided columns
                will be disconnected.
            columns: The specifiers of the columns will be disconnected from the
                provided row.
        """"""
        return self._connect_or_disconnect_row_to_columns(
            ""disconnect"", slot_id, row_id, columns
        )

    def connect_column_to_rows(
        self, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A convenient function that connects given rows to a column of a
        slot and opens the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            column_id: The specifier for the column to which the provided rows
                will be connected.
            rows: The specifiers of the rows will be connected to the
                provided column.
        """"""
        return self._connect_or_disconnect_column_to_rows(
            ""connect"", slot_id, column_id, rows
        )

    def disconnect_column_from_rows(
        self, slot_id: int, column_id: int, rows: list[int]
    ) -> list[str]:
        """"""
        A convenient function that disconnects given rows to a column of a
        slot and closes the formed channels.

        Args:
            slot_id: The specifier for the slot from which the row and columns
                will be selected.
            column_id: The specifier for the column to which the provided rows
                will be disconnected.
            rows: The specifiers of the rows will be disconnected from the
                provided column.
        """"""
        return self._connect_or_disconnect_column_to_rows(
            ""disconnect"", slot_id, column_id, rows
        )

    def get_idn(self) -> dict[str, Optional[str]]:
        """"""
        Overwrites the generic QCoDeS get IDN method. Returns
        a dictionary including the vendor, model, serial number and
        firmware version of the instrument.
        """"""
        idnstr = self.ask_raw(""*IDN?"")
        vendor, model, serial, firmware = map(str.strip, idnstr.split("",""))
        model = model[6:]

        idn: dict[str, Optional[str]] = {
            ""vendor"": vendor,
            ""model"": model,
            ""serial"": serial,
            ""firmware"": firmware,
        }
        return idn

    def get_switch_cards(self) -> tuple[dict[str, str], ...]:
        """"""
        Returns a list of dictionaries listing the properties of the installed
        switch cards including the slot number tha it is installed, model,
        firmware version and serial number.
        """"""
        switch_cards: list[dict[str, str]] = []
        for i in range(1, 7):
            scard = self.ask(f""slot[{i}].idn"")
            if scard != ""Empty Slot"":
                model, mtype, firmware, serial = map(str.strip, scard.split("",""))
                sdict = {
                    ""slot_no"": str(i),
                    ""model"": model,
                    ""mtype"": mtype,
                    ""firmware"": firmware,
                    ""serial"": serial,
                }
                switch_cards.append(sdict)
        return tuple(switch_cards)

    def get_available_memory(self) -> dict[str, Optional[str]]:
        """"""
        Returns the amount of memory that is currently available for
        storing scripts, configurations and channel patterns.
        """"""
        memstring = self.ask(""memory.available()"")
        system_memory, script_memory, pattern_memory, config_memory = map(
            str.strip, memstring.split("","")
        )

        memory_available: dict[str, Optional[str]] = {
            ""System Memory  (%)"": system_memory,
            ""Script Memory  (%)"": script_memory,
            ""Pattern Memory (%)"": pattern_memory,
            ""Config Memory  (%)"": config_memory,
        }
        return memory_available

    def get_interlock_state(self) -> tuple[dict[str, str], ...]:
        """"""
        A function that collects the interlock status of the installed cards.
        The channel relays can continue to operate even if the interlock
        in the corresponding slot is disengaged, one cannot perform
        measurements through the switching card, as the analog backplanes
        cannot be energized.
        """"""
        slot_id = self._get_slot_ids()
        interlock_status = {
            None: (
                ""No card is installed or the installed card does ""
                ""not support interlocks""
            ),
            0: ""Interlocks 1 and 2 are disengaged on the card"",
            1: ""Interlock 1 is engaged, interlock 2 (if it exists) is disengaged"",
            2: ""Interlock 2 in engaged, interlock 1 is disengaged"",
            3: ""Both interlock 1 and 2 are engaged"",
        }
        states: list[dict[str, str]] = []
        for i in slot_id:
            state = self.get_interlock_state_by_slot(i)
            states.append({""slot_no"": i, ""state"": interlock_status[state]})
        return tuple(states)

    def get_interlock_state_by_slot(self, slot: Union[str, int]) -> Union[int, None]:
        state = self.ask(f""slot[{int(slot)}].interlock.state"")
        if state == ""nil"":
            return None
        else:
            return int(float(state))

    def get_ip_address(self) -> str:
        """"""
        Returns the current IP address of the instrument.
        """"""
        return self.ask(""lan.status.ipaddress"")

    def reset_local_network(self) -> None:
        """"""
        Resets the local network (LAN).
        """"""
        self.write(""lan.reset()"")

    def save_setup(self, val: Optional[str] = None) -> None:
        """"""
        Saves the present setup.

        Args:
            val: An optional string representing the path and the file name
                to which the setup shall be saved on a USB flash drive. If not
                provided, the setup will be saved to the nonvolatile memory
                of the instrument, any previous saves will be overwritten.
        """"""
        if val is not None:
            self.write(f""setup.save('{val}')"")
        else:
            self.write(""setup.save()"")

    def load_setup(self, val: Union[int, str]) -> None:
        """"""
        Loads the settings from a saved setup.

        Args:
            val: An integer or a string that specifies the location of saved
                setup. If it is `0`, factory defaults load. If it is `1`,
                the saved setup from the nonvolatile memory is recalled.
                Otherwise, a string specifying the relative path to the saved
                setup on a USB drive should be passed in.
        """"""
        self.write(f""setup.recall('{val}')"")

    def _validator(self, val: str) -> bool:
        """"""
        Instrument specific validator. As the number of validation points
        are around 15k, to avoid QCoDeS parameter validation to print them all,
        we shall raise a custom exception.
        """"""
        ch = self.get_channels()
        ch_range = self._get_channel_ranges()
        slots = [""allslots"", *self._get_slot_names()]
        backplanes = self.get_analog_backplane_specifiers()
        specifier = val.split("","")
        for element in specifier:
            if element not in (*ch, *ch_range, *slots, *backplanes):
                return False
        return True

    def connect_message(
        self, idn_param: str = ""IDN"", begin_time: Optional[float] = None
    ) -> None:
        """"""
        Overwrites the generic QCoDeS instrument connect message.
        Here, additionally, we provide information about
        which slots of the system switch is occupied with what
        kind of matrix, as well.
        """"""
        idn = self.get_idn()
        cards = self.get_switch_cards()
        states = self.get_interlock_state()

        con_msg = (
            ""Connected to: {vendor} {model} SYSTEM SWITCH ""
            ""(serial:{serial}, firmware:{firmware})"".format(**idn)
        )
        print(con_msg)
        self.log.info(f""Connected to instrument: {idn}"")

        for _, item in enumerate(cards):
            card_info = (
                ""Slot {slot_no}- Model:{model}, Matrix Type:{mtype}, ""
                ""Firmware:{firmware}, Serial:{serial}"".format(**item)
            )
            print(card_info)
            self.log.info(f""Switch Cards: {item}"")

        for _, item in enumerate(states):
            state_info = ""{state} in Slot {slot_no}."".format(**item)
            print(state_info)

    def ask(self, cmd: str) -> str:
        """"""
        Override of normal ask. This is important, since queries to the
        instrument must be wrapped in 'print()'
        """"""
        return super().ask(f""print({cmd:s})"")
"
386,318.0,Japan,"The GS200 is a low voltage/current DC source with high accuracy, high stability, and high resolution. With its excellent traceability, stability, and 5 1/2-digit resolution, the GS200 generates extremely low-noise DC voltage and current signals that are required for many applications. Additionally, the optional monitoring feature turns the GS200 into a voltage and current measuring instrument.",Yokogawa GS 200,635.0,"Yokogawa is a leading provider of Industrial Automation and Test and Measurement solutions. Combining superior technology with engineering services, project management, and maintenance, Yokogawa delivers field proven operational efficiency, safety, quality, and reliability.
",Qcodes,Yokogawa,"[OrderedDict([('id', 'attYj6XdvrjZcf0eD'), ('width', 526), ('height', 526), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_UaAsDYNLAOdUQ4cG-gVBw/NTY986xzNYwKbonHbWwWC4LeHEHqycOQeXYwRbRUCHdcuhOKGAvrvBoatXQsD5bpSMp051hQO8G6Z1_BiSG1VC6MM2RwFw-JgfT3HK4pXZo/cdsfM51bauCXQpD2o4jMtv4J_4Pc6fMk_dJlEKX20e0'), ('filename', 'trademark.jpg'), ('size', 17680), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0FZ2eqXGORQw7KhD8ggQhA/54nn9VVUA8rLZTUqpQNJJRRABVqmHyYpr39PgVnaWermrd9uQk4oKjA-U_ElbfbtDYyDeyOy0wUoLtc2W5106g/xl6wqD05nzCPSKrDuCKrzZgEG0XSnoQSadmaYKdpFJM'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/HaEWyRlZBthPGsYttIxnHQ/Dg6dnKGNXLv3Mh6hmw3-ew1Frbuj6oI01Vn3HH6YZCGh51cSS68iCmPrXpZJPdTo-4wfWlWjjSEU4Ca-zmtRlQ/eXk6rUTl5KsnGehm3vQUBE5QCuNLX-D5bbpf0_IxIrM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IbzTBl4xKhTim-kj9IZJWw/jqTaszS54GnOhLIRvMV0S3ODA6kF-CfXSMb2hQnB7aSuYMsMIsRnYenR7US3v50OI9A0DzAtFvhKHusA-qJEaw/o46lbBXBsIcuUNQKSTjhxI0hmLRfL48B90X8oBZ96jI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.yokogawa.com/,Write a Python script that uses Qcodes to connect to a {Device name} Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. ",,https://cdn.tmi.yokogawa.com/1/7543/files/BUGS200-01EN.pdf,"[OrderedDict([('id', 'attVoxpUxYSQ6kk0I'), ('width', 800), ('height', 366), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/hk0VJxBmbRexUhpKO_-l4w/pnchoYJrmCRD1X-YAkeK9hIZy5ACFC8o-BbenCOSXF0rtbp5CcHj7qGXuJYF8LIgdWa7tJj9tqPGab5_wgmnQzJGeUiBj3kJPo6NPkUjxEw/Ry7cxR0UNMV3aw-MqAr3wawDNKoxjNIp0nmWPbf_HQw'), ('filename', 'gs200_4.jpg'), ('size', 54439), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aRydi7OJi5TxDJNQ4sNgaw/pGFLlqfTkuqSG89ToWd-9P1vna7mElQ5o-g8s_Rp0aH67f6lUEdlyR-6Lx6PhRyEEQ2a3tZYION2Oa4syijD1A/h5-Imre2PMwCYNOE6feE8Xvy52_nic-9-dHO54nhuWs'), ('width', 79), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BlZKe0UB2ATqHQoLcLScHw/hiCyQOrNn7tadTBH4RvkYIDUVBBIvHkdBQyYd0KeEpGFYXRNIEGMxSewgN1jBsBFbA5XSrxv0LSzWyid5j98AA/QPW2hzu1Oo6zJ_QlSPILlZJZxbii8VnsjOOdh0DpmcQ'), ('width', 800), ('height', 366)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/eH2rP8rLO5MhZClD6I37RA/TyWYIZa7BHf2CkaipW1705XTqJUtzr4vt-azifWxgfDOXbZ6UXngMfHBX9TbTq7mew8byvTfvhxJor36gCotZA/MokrZQZToDfxgVUh8TG3o_6OOawjGHSG_5x4HpboTbI'), ('width', 3000), ('height', 3000)]))]))])]",https://tmi.yokogawa.com/ca/solutions/products/generators-sources/source-measure-units/gs200/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/yokogawa/Yokogawa_GS200.py,https://qcodes.github.io/Qcodes/drivers_api/Yokogawa.html,,,,,"from functools import partial
from typing import Any, Literal, Optional, Union

from qcodes.instrument import InstrumentChannel, VisaInstrument
from qcodes.parameters import DelegateParameter
from qcodes.validators import Bool, Enum, Ints, Numbers

ModeType = Literal[""CURR"", ""VOLT""]


def _float_round(val: float) -> int:
    """"""
    Rounds a floating number

    Args:
        val: number to be rounded

    Returns:
        Rounded integer
    """"""
    return round(float(val))


class YokogawaGS200Exception(Exception):
    pass


class YokogawaGS200Monitor(InstrumentChannel):
    """"""
    Monitor part of the GS200. This is only enabled if it is
    installed in the GS200 (it is an optional extra).

    The units will be automatically updated as required.

    To measure:
    `GS200.measure.measure()`

    Args:
        parent (GS200)
        name: instrument name
        present
    """"""

    def __init__(self, parent: ""YokogawaGS200"", name: str, present: bool) -> None:
        super().__init__(parent, name)

        self.present = present

        # Start off with all disabled
        self._enabled = False
        self._output = False

        # Set up mode cache. These will be filled in once the parent
        # is fully initialized.
        self._range: Union[None, float] = None
        self._unit: Union[None, str] = None

        # Set up monitoring parameters
        if present:
            self.add_parameter(
                ""enabled"",
                label=""Measurement Enabled"",
                get_cmd=self.state,
                set_cmd=lambda x: self.on() if x else self.off(),
                val_mapping={
                    ""off"": 0,
                    ""on"": 1,
                },
            )

            # Note: Measurement will only run if source and
            # measurement is enabled.
            self.add_parameter(
                ""measure"",
                label=""<unset>"",
                unit=""V/I"",
                get_cmd=self._get_measurement,
                snapshot_get=False,
            )

            self.add_parameter(
                ""NPLC"",
                label=""NPLC"",
                unit=""1/LineFreq"",
                vals=Ints(1, 25),
                set_cmd="":SENS:NPLC {}"",
                set_parser=int,
                get_cmd="":SENS:NPLC?"",
                get_parser=_float_round,
            )
            self.add_parameter(
                ""delay"",
                label=""Measurement Delay"",
                unit=""ms"",
                vals=Ints(0, 999999),
                set_cmd="":SENS:DEL {}"",
                set_parser=int,
                get_cmd="":SENS:DEL?"",
                get_parser=_float_round,
            )
            self.add_parameter(
                ""trigger"",
                label=""Trigger Source"",
                set_cmd="":SENS:TRIG {}"",
                get_cmd="":SENS:TRIG?"",
                val_mapping={
                    ""READY"": ""READ"",
                    ""READ"": ""READ"",
                    ""TIMER"": ""TIM"",
                    ""TIM"": ""TIM"",
                    ""COMMUNICATE"": ""COMM"",
                    ""IMMEDIATE"": ""IMM"",
                    ""IMM"": ""IMM"",
                },
            )
            self.add_parameter(
                ""interval"",
                label=""Measurement Interval"",
                unit=""s"",
                vals=Numbers(0.1, 3600),
                set_cmd="":SENS:INT {}"",
                set_parser=float,
                get_cmd="":SENS:INT?"",
                get_parser=float,
            )

    def off(self) -> None:
        """"""Turn measurement off""""""
        self.write("":SENS 0"")
        self._enabled = False

    def on(self) -> None:
        """"""Turn measurement on""""""
        self.write("":SENS 1"")
        self._enabled = True

    def state(self) -> int:
        """"""Check measurement state""""""
        state = int(self.ask("":SENS?""))
        self._enabled = bool(state)
        return state

    def _get_measurement(self) -> float:
        if self._unit is None or self._range is None:
            raise YokogawaGS200Exception(""Measurement module not initialized."")
        if self._parent.auto_range.get() or (self._unit == ""VOLT"" and self._range < 1):
            # Measurements will not work with autorange, or when
            # range is <1V.
            self._enabled = False
            raise YokogawaGS200Exception(
                ""Measurements will not work when range is <1V""
                ""or when in auto range mode.""
            )
        if not self._output:
            raise YokogawaGS200Exception(""Output is off."")
        if not self._enabled:
            raise YokogawaGS200Exception(""Measurements are disabled."")
        # If enabled and output is on, then we can perform a measurement.
        return float(self.ask("":MEAS?""))

    def update_measurement_enabled(self, unit: ModeType, output_range: float) -> None:
        """"""
        Args:
            unit
            output_range
        """"""
        # Recheck measurement state next time we do a measurement
        self._enabled = False

        # Update units
        self._range = output_range
        self._unit = unit
        if self._unit == ""VOLT"":
            self.measure.label = ""Source Current""
            self.measure.unit = ""I""
        else:
            self.measure.label = ""Source Voltage""
            self.measure.unit = ""V""


class YokogawaGS200Program(InstrumentChannel):
    """""" """"""

    def __init__(self, parent: ""YokogawaGS200"", name: str) -> None:
        super().__init__(parent, name)
        self._repeat = 1
        self._file_name = None

        self.add_parameter(
            ""interval"",
            label=""the program interval time"",
            unit=""s"",
            vals=Numbers(0.1, 3600.0),
            get_cmd="":PROG:INT?"",
            set_cmd="":PROG:INT {}"",
        )

        self.add_parameter(
            ""slope"",
            label=""the program slope time"",
            unit=""s"",
            vals=Numbers(0.1, 3600.0),
            get_cmd="":PROG:SLOP?"",
            set_cmd="":PROG:SLOP {}"",
        )

        self.add_parameter(
            ""trigger"",
            label=""the program trigger"",
            get_cmd="":PROG:TRIG?"",
            set_cmd="":PROG:TRIG {}"",
            vals=Enum(""normal"", ""mend""),
        )

        self.add_parameter(
            ""save"",
            set_cmd="":PROG:SAVE '{}'"",
            docstring=""save the program to the system memory "" ""(.csv file)"",
        )

        self.add_parameter(
            ""load"",
            get_cmd="":PROG:LOAD?"",
            set_cmd="":PROG:LOAD '{}'"",
            docstring=""load the program (.csv file) from the "" ""system memory"",
        )

        self.add_parameter(
            ""repeat"",
            label=""program execution repetition"",
            get_cmd="":PROG:REP?"",
            set_cmd="":PROG:REP {}"",
            val_mapping={""OFF"": 0, ""ON"": 1},
        )
        self.add_parameter(
            ""count"",
            label=""step of the current program"",
            get_cmd="":PROG:COUN?"",
            set_cmd="":PROG:COUN {}"",
            vals=Ints(1, 10000),
        )

        self.add_function(
            ""start"", call_cmd="":PROG:EDIT:STAR"", docstring=""start program editing""
        )
        self.add_function(
            ""end"", call_cmd="":PROG:EDIT:END"", docstring=""end program editing""
        )
        self.add_function(
            ""run"",
            call_cmd="":PROG:RUN"",
            docstring=""run the program"",
        )


class YokogawaGS200(VisaInstrument):
    """"""
    QCoDeS driver for the Yokogawa GS200 voltage and current source.

    Args:
      name: What this instrument is called locally.
      address: The GPIB or USB address of this instrument
      kwargs: kwargs to be passed to VisaInstrument class
      terminator: read terminator for reads/writes to the instrument.
    """"""

    def __init__(
        self, name: str, address: str, terminator: str = ""\n"", **kwargs: Any
    ) -> None:
        super().__init__(name, address, terminator=terminator, **kwargs)

        self.add_parameter(
            ""output"",
            label=""Output State"",
            get_cmd=self.state,
            set_cmd=lambda x: self.on() if x else self.off(),
            val_mapping={
                ""off"": 0,
                ""on"": 1,
            },
        )

        self.add_parameter(
            ""source_mode"",
            label=""Source Mode"",
            get_cmd="":SOUR:FUNC?"",
            set_cmd=self._set_source_mode,
            vals=Enum(""VOLT"", ""CURR""),
        )

        # We need to get the source_mode value here as we cannot rely on the
        # default value that may have been changed before we connect to the
        # instrument (in a previous session or via the frontpanel).
        self.source_mode()

        self.add_parameter(
            ""voltage_range"",
            label=""Voltage Source Range"",
            unit=""V"",
            get_cmd=partial(self._get_range, ""VOLT""),
            set_cmd=partial(self._set_range, ""VOLT""),
            vals=Enum(10e-3, 100e-3, 1e0, 10e0, 30e0),
            snapshot_exclude=self.source_mode() == ""CURR"",
        )

        self.add_parameter(
            ""current_range"",
            label=""Current Source Range"",
            unit=""I"",
            get_cmd=partial(self._get_range, ""CURR""),
            set_cmd=partial(self._set_range, ""CURR""),
            vals=Enum(1e-3, 10e-3, 100e-3, 200e-3),
            snapshot_exclude=self.source_mode() == ""VOLT"",
        )

        self.add_parameter(""range"", parameter_class=DelegateParameter, source=None)

        # The instrument does not support auto range. The parameter
        # auto_range is introduced to add this capability with
        # setting the initial state at False mode.
        self.add_parameter(
            ""auto_range"",
            label=""Auto Range"",
            set_cmd=self._set_auto_range,
            get_cmd=None,
            initial_cache_value=False,
            vals=Bool(),
        )

        self.add_parameter(
            ""voltage"",
            label=""Voltage"",
            unit=""V"",
            set_cmd=partial(self._get_set_output, ""VOLT""),
            get_cmd=partial(self._get_set_output, ""VOLT""),
            snapshot_exclude=self.source_mode() == ""CURR"",
        )

        self.add_parameter(
            ""current"",
            label=""Current"",
            unit=""I"",
            set_cmd=partial(self._get_set_output, ""CURR""),
            get_cmd=partial(self._get_set_output, ""CURR""),
            snapshot_exclude=self.source_mode() == ""VOLT"",
        )

        self.add_parameter(
            ""output_level"", parameter_class=DelegateParameter, source=None
        )

        # We need to pass the source parameter for delegate parameters
        # (range and output_level) here according to the present
        # source_mode.
        if self.source_mode() == ""VOLT"":
            self.range.source = self.voltage_range
            self.output_level.source = self.voltage
        else:
            self.range.source = self.current_range
            self.output_level.source = self.current

        self.add_parameter(
            ""voltage_limit"",
            label=""Voltage Protection Limit"",
            unit=""V"",
            vals=Ints(1, 30),
            get_cmd="":SOUR:PROT:VOLT?"",
            set_cmd="":SOUR:PROT:VOLT {}"",
            get_parser=_float_round,
            set_parser=int,
        )

        self.add_parameter(
            ""current_limit"",
            label=""Current Protection Limit"",
            unit=""I"",
            vals=Numbers(1e-3, 200e-3),
            get_cmd="":SOUR:PROT:CURR?"",
            set_cmd="":SOUR:PROT:CURR {:.3f}"",
            get_parser=float,
            set_parser=float,
        )

        self.add_parameter(
            ""four_wire"",
            label=""Four Wire Sensing"",
            get_cmd="":SENS:REM?"",
            set_cmd="":SENS:REM {}"",
            val_mapping={
                ""off"": 0,
                ""on"": 1,
            },
        )

        # Note: The guard feature can be used to remove common mode noise.
        # Read the manual to see if you would like to use it
        self.add_parameter(
            ""guard"",
            label=""Guard Terminal"",
            get_cmd="":SENS:GUAR?"",
            set_cmd="":SENS:GUAR {}"",
            val_mapping={""off"": 0, ""on"": 1},
        )

        # Return measured line frequency
        self.add_parameter(
            ""line_freq"",
            label=""Line Frequency"",
            unit=""Hz"",
            get_cmd=""SYST:LFR?"",
            get_parser=int,
        )

        # Check if monitor is present, and if so enable measurement
        monitor_present = ""/MON"" in self.ask(""*OPT?"")
        measure = YokogawaGS200Monitor(self, ""measure"", monitor_present)
        self.add_submodule(""measure"", measure)

        # Reset function
        self.add_function(""reset"", call_cmd=""*RST"")

        self.add_submodule(""program"", YokogawaGS200Program(self, ""program""))

        self.add_parameter(
            ""BNC_out"",
            label=""BNC trigger out"",
            get_cmd="":ROUT:BNCO?"",
            set_cmd="":ROUT:BNCO {}"",
            vals=Enum(""trigger"", ""output"", ""ready""),
            docstring=""Sets or queries the output BNC signal"",
        )

        self.add_parameter(
            ""BNC_in"",
            label=""BNC trigger in"",
            get_cmd="":ROUT:BNCI?"",
            set_cmd="":ROUT:BNCI {}"",
            vals=Enum(""trigger"", ""output""),
            docstring=""Sets or queries the input BNC signal"",
        )

        self.add_parameter(
            ""system_errors"",
            get_cmd="":SYSTem:ERRor?"",
            docstring=""returns the oldest unread error message from the event ""
            ""log and removes it from the log."",
        )

        self.connect_message()

    def on(self) -> None:
        """"""Turn output on""""""
        self.write(""OUTPUT 1"")
        self.measure._output = True

    def off(self) -> None:
        """"""Turn output off""""""
        self.write(""OUTPUT 0"")
        self.measure._output = False

    def state(self) -> int:
        """"""Check state""""""
        state = int(self.ask(""OUTPUT?""))
        self.measure._output = bool(state)
        return state

    def ramp_voltage(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the voltage from the current level to the specified output.

        Args:
            ramp_to: The ramp target in Volt
            step: The ramp steps in Volt
            delay: The time between finishing one step and
                starting another in seconds.
        """"""
        self._assert_mode(""VOLT"")
        self._ramp_source(ramp_to, step, delay)

    def ramp_current(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the current from the current level to the specified output.

        Args:
            ramp_to: The ramp target in Ampere
            step: The ramp steps in Ampere
            delay: The time between finishing one step and starting
                another in seconds.
        """"""
        self._assert_mode(""CURR"")
        self._ramp_source(ramp_to, step, delay)

    def _ramp_source(self, ramp_to: float, step: float, delay: float) -> None:
        """"""
        Ramp the output from the current level to the specified output

        Args:
            ramp_to: The ramp target in volts/amps
            step: The ramp steps in volts/ampere
            delay: The time between finishing one step and
                starting another in seconds.
        """"""
        saved_step = self.output_level.step
        saved_inter_delay = self.output_level.inter_delay

        self.output_level.step = step
        self.output_level.inter_delay = delay
        self.output_level(ramp_to)

        self.output_level.step = saved_step
        self.output_level.inter_delay = saved_inter_delay

    def _get_set_output(
        self, mode: ModeType, output_level: Optional[float] = None
    ) -> Optional[float]:
        """"""
        Get or set the output level.

        Args:
            mode: ""CURR"" or ""VOLT""
            output_level: If missing, we assume that we are getting the
                current level. Else we are setting it
        """"""
        self._assert_mode(mode)
        if output_level is not None:
            self._set_output(output_level)
            return None
        return float(self.ask("":SOUR:LEV?""))

    def _set_output(self, output_level: float) -> None:
        """"""
        Set the output of the instrument.

        Args:
            output_level: output level in Volt or Ampere, depending
                on the current mode.
        """"""
        auto_enabled = self.auto_range()

        if not auto_enabled:
            self_range = self.range()
            if self_range is None:
                raise RuntimeError(
                    ""Trying to set output but not in auto mode and range is unknown.""
                )
        else:
            mode = self.source_mode.get_latest()
            if mode == ""CURR"":
                self_range = 200e-3
            else:
                self_range = 30.0

        # Check we are not trying to set an out of range value
        if self.range() is None or abs(output_level) > abs(self_range):
            # Check that the range hasn't changed
            if not auto_enabled:
                self_range = self.range.get_latest()
                if self_range is None:
                    raise RuntimeError(
                        ""Trying to set output but not in""
                        "" auto mode and range is unknown.""
                    )
            # If we are still out of range, raise a value error
            if abs(output_level) > abs(self_range):
                raise ValueError(
                    ""Desired output level not in range""
                    "" [-{self_range:.3}, {self_range:.3}]"".format(self_range=self_range)
                )

        if auto_enabled:
            auto_str = "":AUTO""
        else:
            auto_str = """"
        cmd_str = f"":SOUR:LEV{auto_str} {output_level:.5e}""
        self.write(cmd_str)

    def _update_measurement_module(
        self,
        source_mode: Optional[ModeType] = None,
        source_range: Optional[float] = None,
    ) -> None:
        """"""
        Update validators/units as source mode/range changes.

        Args:
            source_mode: ""CURR"" or ""VOLT""
            source_range
        """"""
        if not self.measure.present:
            return

        if source_mode is None:
            source_mode = self.source_mode.get_latest()
        # Get source range if auto-range is off
        if source_range is None and not self.auto_range():
            source_range = self.range()

        self.measure.update_measurement_enabled(source_mode, source_range)

    def _set_auto_range(self, val: bool) -> None:
        """"""
        Enable/disable auto range.

        Args:
            val: auto range on or off
        """"""
        self._auto_range = val
        # Disable measurement if auto range is on
        if self.measure.present:
            # Disable the measurement module if auto range is enabled,
            # because the measurement does not work in the
            # 10mV/100mV ranges.
            self.measure._enabled &= not val

    def _assert_mode(self, mode: ModeType) -> None:
        """"""
        Assert that we are in the correct mode to perform an operation.

        Args:
            mode: ""CURR"" or ""VOLT""
        """"""
        if self.source_mode.get_latest() != mode:
            raise ValueError(
                f""Cannot get/set {mode} settings while in {self.source_mode.get_latest()} mode""
            )

    def _set_source_mode(self, mode: ModeType) -> None:
        """"""
        Set output mode and change delegate parameters' source accordingly.
        Also, exclude/include the parameters from snapshot depending on the
        mode. The instrument does not support 'current', 'current_range'
        parameters in ""VOLT"" mode and 'voltage', 'voltage_range' parameters
        in ""CURR"" mode.

        Args:
            mode: ""CURR"" or ""VOLT""

        """"""
        if self.output() == ""on"":
            raise YokogawaGS200Exception(""Cannot switch mode while source is on"")

        if mode == ""VOLT"":
            self.range.source = self.voltage_range
            self.output_level.source = self.voltage
            self.voltage_range.snapshot_exclude = False
            self.voltage.snapshot_exclude = False
            self.current_range.snapshot_exclude = True
            self.current.snapshot_exclude = True
        else:
            self.range.source = self.current_range
            self.output_level.source = self.current
            self.voltage_range.snapshot_exclude = True
            self.voltage.snapshot_exclude = True
            self.current_range.snapshot_exclude = False
            self.current.snapshot_exclude = False

        self.write(f""SOUR:FUNC {mode}"")
        # We set the cache here since `_update_measurement_module`
        # needs the current value which would otherwise only be set
        # after this method exits
        self.source_mode.cache.set(mode)
        # Update the measurement mode
        self._update_measurement_module(source_mode=mode)

    def _set_range(self, mode: ModeType, output_range: float) -> None:
        """"""
        Update range

        Args:
            mode: ""CURR"" or ""VOLT""
            output_range: Range to set. For voltage, we have the ranges [10e-3,
                100e-3, 1e0, 10e0, 30e0]. For current, we have the ranges [1e-3,
                10e-3, 100e-3, 200e-3]. If auto_range = False, then setting the
                output can only happen if the set value is smaller than the
                present range.
        """"""
        self._assert_mode(mode)
        output_range = float(output_range)
        self._update_measurement_module(source_mode=mode, source_range=output_range)
        self.write(f"":SOUR:RANG {output_range}"")

    def _get_range(self, mode: ModeType) -> float:
        """"""
        Query the present range.

        Args:
            mode: ""CURR"" or ""VOLT""

        Returns:
            range: For voltage, we have the ranges [10e-3, 100e-3, 1e0, 10e0,
                30e0]. For current, we have the ranges [1e-3, 10e-3, 100e-3,
                200e-3]. If auto_range = False, then setting the output can only
                happen if the set value is smaller than the present range.
        """"""
        self._assert_mode(mode)
        return float(self.ask("":SOUR:RANG?""))
"
387,5800.0,USA,"The TPS2000 Series easily addresses the unique challenges that plague industrial power designers and technicians. You regularly confront high voltages and currents, and must often make potentially hazardous floating measurements. With the TPS2000 Series' power bundle (TPS2PBND), which includes the P5120 passive, high-voltage probes and TPS2PWR1 power measurement and analysis software, you can use a single instrument to make a broad range of measurements.

Easily evaluate these high voltages and currents, or debug power electronics control circuits, with differential voltages up to 600 VRMS CAT II (or 300 VRMS CAT III) floating. Accurately measure three-phase power and circuits with different low levels or ground references.

Quickly perform a broad range of power-specific measurements, such as switching loss, harmonic distortion measurements to the 50th harmonic, and dv/dt and di/dt cursor measurements.",TPS 2012,560.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a TSP2012 Oscilloscopes,https://en.wikipedia.org/wiki/Oscilloscope,['Oscilloscopes'],"An oscilloscope is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument.[1] Modern digital instruments may calculate and display these properties directly.",TSP2012,https://www.testequipmenthq.com/datasheets/TEKTRONIX-TPS2012-Datasheet.pdf,"[OrderedDict([('id', 'attATDSb8uCvGo2o8'), ('width', 500), ('height', 255), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/sIou0gOO-uy_QhoNLBhu5A/acelcm9uE5TDpOhkyF011SGt9Px5dyweL88t2Z6lGRv6fI8fOb_AFaNbtcUszi18d1qbej4qK72ALZYqEFy3EeNObxYg4CVpZKrY9dDMRg8/K6f-mpghgkxfjpLCPeX77rJgJ8Z1yHyyrozOOM-BnSg'), ('filename', 'tektro_tps2012.jpg'), ('size', 30645), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WYknkXP_IfsmszfbsOz6w/R2QnCKv3Refd7nyL-_NNPz7MuNLL24VtKR99jXTgY-qkZp7JcghIwT1G735XdcM-cPgha4q9s_jBXWCWW7v9jw/JD2MZ9a_z7qcOgYT0yb2fd3dd2ZmV63gFO7-ZALMvu0'), ('width', 71), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/JN5FDg3yQoffj4w_h3wl6w/RW1A9RtkEAanWNG7F7pOBcdXyvM5MpaCW-gYbfuqv5xvqwpZXNwWXhQNcXaOXuGrnP2HuBENB0VKc0lEHVO3Dg/PU7x2oD8N1LwsP56wMJrzPjv5Da-uMtIuBE2pCk_BeM'), ('width', 500), ('height', 255)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/XayyWyuBlYLER59oDAMrKQ/7hyzDEh8ewUQ7zKfDVqXxOiduHki8iC625NVcrLJDnm6JRDrE9V21PK5bKWpRraXbJ5SQr8vR9dM6czg-ySRdA/ktiWeWUPu5csO7wsDHuY5qDFv1B06QCDliFigylkurA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.valuetronics.com/product/tps2012-tektronix-digital-oscilloscope-used,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/TPS2012.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixTPS2012,4540.0,,True,"The price is taken from Farnell, second hand","import binascii
import logging
from functools import partial
from typing import Any

import numpy as np
from pyvisa.errors import VisaIOError
from typing_extensions import TypedDict

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import ArrayParameter, ParamRawDataType

log = logging.getLogger(__name__)


class TraceNotReady(Exception):
    pass


class OutputDict(TypedDict):
    no_of_bytes: int
    no_of_bits: int
    encoding: str
    binary_format: str
    byte_order: str
    no_of_points: int
    waveform_ID: str
    point_format: str
    x_incr: float
    x_zero: float
    x_unit: str
    y_multiplier: float
    y_zero: float
    y_offset: float
    y_unit: str


class ScopeArray(ArrayParameter):
    def __init__(
        self,
        name: str,
        instrument: ""TektronixTPS2012Channel"",
        channel: int,
        **kwargs: Any,
    ):
        super().__init__(
            name=name,
            shape=(2500,),
            label=""Voltage"",
            unit=""V "",
            setpoint_names=(""Time"",),
            setpoint_labels=(""Time"",),
            setpoint_units=(""s"",),
            docstring=""holds an array from scope"",
            instrument=instrument,
            **kwargs,
        )
        self.channel = channel

    def calc_set_points(self) -> tuple[np.ndarray, int]:
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        message = self.instrument.ask('WFMPre?')
        preamble = self._preambleparser(message)
        xstart = preamble['x_zero']
        xinc = preamble['x_incr']
        no_of_points = preamble['no_of_points']
        xdata = np.linspace(xstart, no_of_points * xinc + xstart, no_of_points)
        return xdata, no_of_points

    def prepare_curvedata(self) -> None:
        """"""
        Prepare the scope for returning curve data
        """"""
        # To calculate set points, we must have the full preamble
        # For the instrument to return the full preamble, the channel
        # in question must be displayed
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        assert isinstance(self.root_instrument, TektronixTPS2012)
        self.instrument.parameters['state'].set('ON')
        self.root_instrument.data_source(f'CH{self.channel}')

        xdata, no_of_points = self.calc_set_points()
        self.setpoints = (tuple(xdata), )
        self.shape = (no_of_points, )

        self.root_instrument.trace_ready = True

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.root_instrument, TektronixTPS2012)
        if not self.root_instrument.trace_ready:
            raise TraceNotReady('Please run prepare_curvedata to prepare '
                                'the scope for giving a trace.')
        message = self._curveasker(self.channel)
        _, ydata, _ = self._curveparameterparser(message)
        # Due to the limitations in the current api the below solution
        # to change setpoints does nothing because the setpoints have
        # already been copied to the dataset when get is called.

        # self.setpoints = (tuple(xdata),)
        # self.shape = (npoints,)
        return ydata

    def _curveasker(self, ch: int) -> str:
        assert isinstance(self.instrument, TektronixTPS2012Channel)
        self.instrument.write(f'DATa:SOURce CH{ch}')
        message = self.instrument.ask('WAVFrm?')
        self.instrument.write('*WAI')
        return message

    @staticmethod
    def _binaryparser(curve: str) -> np.ndarray:
        """"""
        Helper function for parsing the curve data

        Args:
            curve: the return value of 'CURVe?' when
              DATa:ENCdg is set to RPBinary.
              Note: The header and final newline character
              must be removed.

        Returns:
            The curve in units where the digitisation range
            is mapped to (-32768, 32767).
        """"""
        # TODO: Add support for data width = 1 mode?
        output = np.zeros(int(len(curve)/2))  # data width 2
        # output = np.zeros(int(len(curve)))  # data width 1
        for ii, _ in enumerate(output):
            # casting FTWs
            temp_1 = curve[2*ii:2*ii+1].encode('latin-1')  # data width 2
            temp_2 = binascii.b2a_hex(temp_1)
            temp_3 = (int(temp_2, 16)-128)*256  # data width 2 (1)
            output[ii] = temp_3
        return output

    @staticmethod
    def _preambleparser(response: str) -> OutputDict:
        """"""
        Parser function for the curve preamble

        Args:
            response: The response of WFMPre?

        Returns:
            A dictionary containing the following keys:
              no_of_bytes, no_of_bits, encoding, binary_format,
              byte_order, no_of_points, waveform_ID, point_format,
              x_incr, x_zero, x_unit, y_multiplier, y_zero, y_offset, y_unit
        """"""
        response_list = response.split(';')

        outdict: OutputDict = {
            'no_of_bytes': int(response_list[0]),
            'no_of_bits': int(response_list[1]),
            'encoding':  response_list[2],
            'binary_format': response_list[3],
            'byte_order': response_list[4],
            'no_of_points': int(response_list[5]),
            'waveform_ID':  response_list[6],
            'point_format': response_list[7],
            'x_incr': float(response_list[8]),
            # outdict['point_offset'] = response_list[9]  # Always zero
            'x_zero': float(response_list[10]),
            'x_unit': response_list[11],
            'y_multiplier': float(response_list[12]),
            'y_zero': float(response_list[13]),
            'y_offset': float(response_list[14]),
            'y_unit': response_list[15]
        }
        return outdict

    def _curveparameterparser(
        self, waveform: str
    ) -> tuple[np.ndarray, np.ndarray, int]:
        """"""
        The parser for the curve parameter. Note that WAVFrm? is equivalent
        to WFMPre?; CURVe?

        Args:
            waveform: The return value of WAVFrm?

        Returns:
            Two numpy arrays with the time axis in units
            of s and curve values in units of V; (time, voltages) and
            the number of points as an integer
        """"""
        fulldata = waveform.split(';')
        preamblestr = ';'.join(fulldata[:16])
        curvestr = ';'.join(fulldata[16:])

        preamble = self._preambleparser(preamblestr)
        # the raw curve data starts with a header containing the char #
        # followed by on digit giving the number of digits in the len of the
        # array in bytes
        # and the length of the array. I.e. the string #45000 is 5000 bytes
        # represented by 4 digits.
        total_number_of_bytes = preamble['no_of_bytes']*preamble['no_of_points']
        raw_data_offset = 2 + len(str(total_number_of_bytes))
        curvestr = curvestr[raw_data_offset:-1]
        rawcurve = self._binaryparser(curvestr)

        yoff = preamble['y_offset']
        yoff -= 2**15  # data width 2
        ymult = preamble['y_multiplier']
        ydata = ymult*(rawcurve-yoff)
        assert len(ydata) == preamble['no_of_points']
        xstart = preamble['x_zero']
        xinc = preamble['x_incr']
        xdata = np.linspace(xstart, len(ydata)*xinc+xstart, len(ydata))
        return xdata, ydata, preamble['no_of_points']


class TektronixTPS2012Channel(InstrumentChannel):
    def __init__(
        self, parent: ""TektronixTPS2012"", name: str, channel: int, **kwargs: Any
    ):
        super().__init__(parent, name, **kwargs)

        self.add_parameter('scale',
                           label=f'Channel {channel} Scale',
                           unit='V/div',
                           get_cmd=f'CH{channel}:SCAle?',
                           set_cmd='CH{}:SCAle {}'.format(channel, '{}'),
                           get_parser=float
                           )
        self.add_parameter('position',
                           label=f'Channel {channel} Position',
                           unit='div',
                           get_cmd=f'CH{channel}:POSition?',
                           set_cmd='CH{}:POSition {}'.format(channel, '{}'),
                           get_parser=float
                           )
        self.add_parameter('curvedata',
                           channel=channel,
                           parameter_class=ScopeArray,
                           )
        self.add_parameter('state',
                           label=f'Channel {channel} display state',
                           set_cmd='SELect:CH{} {}'.format(channel, '{}'),
                           get_cmd=partial(self._get_state, channel),
                           val_mapping={'ON': 1, 'OFF': 0},
                           vals=vals.Enum('ON', 'OFF')
                           )

    def _get_state(self, ch: int) -> int:
        """"""
        get_cmd for the chX_state parameter
        """"""
        # 'SELect?' returns a ';'-separated string of 0s and 1s
        # denoting state display state of ch1, ch2, ?, ?, ?
        # (maybe ch1, ch2, math, ref1, ref2 ..?)
        selected = list(map(int, self.ask('SELect?').split(';')))
        state = selected[ch - 1]
        return state


TPS2012Channel = TektronixTPS2012Channel


class TektronixTPS2012(VisaInstrument):
    """"""
    This is the QCoDeS driver for the Tektronix 2012B oscilloscope.
    """"""

    def __init__(self, name: str, address: str,
                 timeout: float = 20, **kwargs: Any):
        """"""
        Initialises the TPS2012.

        Args:
            name: Name of the instrument used by QCoDeS
            address: Instrument address as used by VISA
            timeout: visa timeout, in secs. long default (180)
              to accommodate large waveforms
        """"""

        super().__init__(name, address, timeout=timeout, **kwargs)
        self.connect_message()

        # Scope trace boolean
        self.trace_ready = False

        # functions

        self.add_function('force_trigger',
                          call_cmd='TRIGger FORce',
                          docstring='Force trigger event')
        self.add_function('run',
                          call_cmd='ACQuire:STATE RUN',
                          docstring='Start acquisition')
        self.add_function('stop',
                          call_cmd='ACQuire:STATE STOP',
                          docstring='Stop acquisition')

        # general parameters
        self.add_parameter('trigger_type',
                           label='Type of the trigger',
                           get_cmd='TRIGger:MAIn:TYPe?',
                           set_cmd='TRIGger:MAIn:TYPe {}',
                           vals=vals.Enum('EDGE', 'VIDEO', 'PULSE')
                           )
        self.add_parameter('trigger_source',
                           label='Source for the trigger',
                           get_cmd='TRIGger:MAIn:EDGE:SOURce?',
                           set_cmd='TRIGger:MAIn:EDGE:SOURce {}',
                           vals=vals.Enum('CH1', 'CH2')
                           )
        self.add_parameter('trigger_edge_slope',
                           label='Slope for edge trigger',
                           get_cmd='TRIGger:MAIn:EDGE:SLOpe?',
                           set_cmd='TRIGger:MAIn:EDGE:SLOpe {}',
                           vals=vals.Enum('FALL', 'RISE')
                           )
        self.add_parameter('trigger_level',
                           label='Trigger level',
                           unit='V',
                           get_cmd='TRIGger:MAIn:LEVel?',
                           set_cmd='TRIGger:MAIn:LEVel {}',
                           vals=vals.Numbers()
                           )
        self.add_parameter('data_source',
                           label='Data source',
                           get_cmd='DATa:SOUrce?',
                           set_cmd='DATa:SOURce {}',
                           vals=vals.Enum('CH1', 'CH2')
                           )
        self.add_parameter('horizontal_scale',
                           label='Horizontal scale',
                           unit='s',
                           get_cmd='HORizontal:SCAle?',
                           set_cmd=self._set_timescale,
                           get_parser=float,
                           vals=vals.Enum(5e-9, 10e-9, 25e-9, 50e-9, 100e-9,
                                          250e-9, 500e-9, 1e-6, 2.5e-6, 5e-6,
                                          10e-6, 25e-6, 50e-6, 100e-6, 250e-6,
                                          500e-6, 1e-3, 2.5e-3, 5e-3, 10e-3,
                                          25e-3, 50e-3, 100e-3, 250e-3, 500e-3,
                                          1, 2.5, 5, 10, 25, 50))

        # channel-specific parameters
        channels = ChannelList(
            self, ""ScopeChannels"", TektronixTPS2012Channel, snapshotable=False
        )
        for ch_num in range(1, 3):
            ch_name = f""ch{ch_num}""
            channel = TektronixTPS2012Channel(self, ch_name, ch_num)
            channels.append(channel)
            self.add_submodule(ch_name, channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        # Necessary settings for parsing the binary curve data
        self.visa_handle.encoding = 'latin-1'
        log.info('Set VISA encoding to latin-1')
        self.write('DATa:ENCdg RPBinary')
        log.info('Set TPS2012 data encoding to RPBinary' +
                 ' (Positive Integer Binary)')
        self.write('DATa:WIDTh 2')
        log.info('Set TPS2012 data width to 2')
        # Note: using data width 2 has been tested to not add
        # significantly to transfer times. The maximal length
        # of an array in one transfer is 2500 points.

    def _set_timescale(self, scale: float) -> None:
        """"""
        set_cmd for the horizontal_scale
        """"""
        self.trace_ready = False
        self.write(f'HORizontal:SCAle {scale}')

    ##################################################
    # METHODS FOR THE USER                           #
    ##################################################

    def clear_message_queue(self, verbose: bool = False) -> None:
        """"""
        Function to clear up (flush) the VISA message queue of the AWG
        instrument. Reads all messages in the queue.

        Args:
            verbose: If True, the read messages are printed.
                Default: False.
        """"""
        original_timeout = self.visa_handle.timeout
        self.visa_handle.timeout = 1000  # 1 second as VISA counts in ms
        gotexception = False
        while not gotexception:
            try:
                message = self.visa_handle.read()
                if verbose:
                    print(message)
            except VisaIOError:
                gotexception = True
        self.visa_handle.timeout = original_timeout


class TPS2012(TektronixTPS2012):
    """"""
    Deprecated alias for ``TektronixTPS2012``
    """"""

    pass
"
390,17.0,USA,The Ithaco 1211 Current Preamplifier measures current with full scale sensitivity ranging from 10-2 to 10-12 amperes,Ithaco 1211,199.0,"Artisan Technology Group ® is a team of top-talent engineers and customer service specialists. We serve organizations that need to maintain and extend the life of their critical industrial, commercial, and military systems beyond obsolescence.
",Qcodes,Ithaco,"[OrderedDict([('id', 'attO5MSSBstxunS3U'), ('width', 488), ('height', 103), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zTpP4oATV1fxfsUITuniUw/jU_OqlKFcnzbGTOMNpPTB1vFLTCNRHMoSTnP3QXpz0AE3DkRNpxYaVBjJjzQZzmGp0sNi6Xae-3dfRrbnyZ1Ag8MGroUwEUlZhVNeeMJxpY/0rvjN4wLyE9zHIdI_LUoUfQkzft7fDTS0daEpDHqHCI'), ('filename', 'téléchargement (1).jpeg'), ('size', 8832), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Ovt9cpIqxT5P5lsb_WztRA/YcwVVX-rsygxRXWDgw5Y1B1PulVUIm71i2qtAiXacJevpuukzq8bH654ulbDBD2RkJUXGDSYYaJPv420BlenWA/DEujZDnaN98nYqFiR0t58TBFvmtx45G-4GebpUY-FwA'), ('width', 171), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0OFElKzm9wA5AZN5FVjUAQ/qfmzwZ0_8eaT6LIgUTLWUY0Gl0bbhFszXnqiO86N5fp09Fnz0xmgDYle3WrCsf5fE2XlGuX7VRkZTAI556HwYg/vDo1q_YTubZzf0NjtU3v2YzqerpKEdB99XR5gnxFqe0'), ('width', 488), ('height', 103)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Q2el7E6LtDm5FqxF_HcXrw/C0Ix9KWHHtmWUOlOmd_EpAaeeTULimIw_fRYFeJnJAQ5UvVWupUEiZyAWSP_30LsXFq1Pjul-AxladmE0YwLAQ/vUs7fzGQ9m0UTnXxlK6VGFAgHpFcNKMO8bIYBZ-AX5U'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/,Write a Python script that uses Qcodes to connect to a Ithaco 1211 Lockin Amplifiers,https://en.wikipedia.org/wiki/Preamplifier,['Lockin Amplifiers'],"A preamplifier, also known as a preamp, is an electronic amplifier that converts a weak electrical signal into an output signal strong enough to be noise-tolerant and strong enough for further processing, or for sending to a power amplifier and a loudspeaker.",Ithaco 1211,https://www.artisantg.com/TestMeasurement/56129-1/DL-Instruments-Ithaco-1211-Current-Preamplifier#,"[OrderedDict([('id', 'attfOb3CrJ0Ln0FFn'), ('width', 600), ('height', 481), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9109AAQOzyocmdffbqw_Ig/_dU_YFWq_0864Qwv7S-E3k9XqaRg91VCcnAzlgaFP5wpRHXIwRjwLDQVjIbdRypIxcoWrwslWb9u6duZEPoWqN8gmYflPXv6q2dT1x9oCcA7_aqFKzSeckYb2GsOsdx9UbNxArB-xqlWKB9M5LaFoQ/JlHFL0xCI-N4-SPdLEisXt6_QInes9S9tImJwycKYCE'), ('filename', 'DL_Instruments_Ithaco_1211_View1_201942143119.jpg'), ('size', 64251), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/mpxTxYh7l69Me-FuirbvyA/grblK3WNd1by1PmFSzBffnRXTxABMzpm2Yp0tA4PYT8LvXb03oXr4B94gwQbDNMlr6l3o9cJ9wfkjvtboDz9Ig/Ie-3Bfi-E8Jfxo9quWkdSooKxE1jfTZHo6Qsk2gTfWw'), ('width', 45), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qSp1rVZDHiNis4eQP9hikA/RY7MDg_xm-TFDJDQ4bdlJaKWu1XXkbWOiUYLx87cKujD-pRCCO6KJc_AdsYxFnzMQ2mID4z8P5fuW9zabrt0Qg/EUErQ45n0vh2CEp5-wo1l8TYkW-48h_yxq3acoOYmh4'), ('width', 600), ('height', 481)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9dXKCC5yqSDiPqWWqRhTJg/5kQUzJgnqt2z5OgzSEhjWqtZVwLC4AtcHZaNz82AYUCzGE1wgzM9E56Znefbqx43jduKo3jTBm4AZxUDnrelAQ/Twg4M4FKB6QSykswbcjcPmjtGdcT7ew6ho8d69tgVlo'), ('width', 3000), ('height', 3000)]))]))])]",https://www.artisantg.com/TestMeasurement/56129-1/DL-Instruments-Ithaco-1211-Current-Preamplifier,https://qcodes.github.io/Qcodes/_modules/qcodes/instrument_drivers/ithaco/Ithaco_1211.html,https://qcodes.github.io/Qcodes/examples/writing_drivers/Creating-Instrument-Drivers.html,200.0,,,,
393,21.4,"Westerville, Ohio, USA","The Model 325 dual-channel cryogenic temperature controller is capable of supporting nearly any diode, RTD, or thermocouple temperature sensor. Two independent PID control loops with heater outputs of 25 W and 2 W are configured to drive either a 50 Ω or 25 Ω load for optimal cryocooler control flexibility. Designed with ease of use, functionality, and value in mind, the Model 325 is ideal for general-purpose laboratory and industrial temperature measurement and control applications.",Lakeshore Model 325,356.0,"Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",Qcodes,Lakeshore,"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/6WgWgYzcnadqtQAsudq-EQ/qBMiciOZubDp7AaEQb1Tv-1U7eOQy4PGJ_AMUo3dTbb-Pm8GYMROAQ5fttNK1jW0qJU0F_aSSOYUidImJnZwIqJCOqvuAe5gHRBm6AHjZ10/F119v_xcdXTD3MkzuV2EejAV_L48lDkINVwOof3RvIk'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/WQmuNgpMl44p6V9XmZ4CyQ/VdzncpNu4Dlldt-i-xrpQM74B3f6bDLTaP0ie7-T7n0hZK37WfnL-v3ss9yYKa0y5lc58Ghyk7omaX-5odAxJNwzaTPatTY72Z-oKOjyfiM/_QAqiUYoQZu56EGbkjlIF-HpunexUq5tQDhy3Tr_ees'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/qB77VOwXqmX7ni1DyoSpdA/C1ho5lb9cSlVTcsONgw9K2Ge-vBjQmxzNmaUhFDgUmH8r2L3uXqv5KBe-nsatdxn3GxAFHK34MBKdCc0wQfoa4ldCEorN3IH5V9DrMzhJWU/wodeRmUKgG9QfZMfQh9drX3ilz8sIWSWqDCXSD_ogqE'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_138iKkNN5kpXaPATAYnsw/oA-4OBF8ojXeHh3X37Mpe3HKE7SCUItHGxgJv5X3ZDhGXNXe1y3Aq1aDhpuQVDsX4WgdMgUUKiWfDUhaANRWCTvATEnw_afgI6F5R89tpdM/tSHU0OcwY60JScIOEF2BOGOKZpsJVHz5m4XQ420dbKk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/home,Write a Python script that uses Qcodes to connect to a {Device name} Temperature Controllers,https://en.wikipedia.org/wiki/Temperature_control,['Temperature Controllers'],"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature.",,https://www.lakeshore.com/docs/default-source/product-downloads/325_manualf0dc89f86bfb4740aedde9dce6cdf807.pdf?sfvrsn=4eb4bc0a_1,"[OrderedDict([('id', 'attJUPJOD1xl9aFGp'), ('width', 505), ('height', 271), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FD2387n9-Gecr6pMDQkSdw/vgjDHbNVVvwWCKqnxVQ3Xs4mdQ9wjFJA8jP8kK_3koC1Sj3W8cXW6r-zPYOLrI45aiVw7uTMthCBJy45bTJz_g/BUbE7MNxtFw7tyoO5X32Nh7msLJeyUFDS04n7LrTZAE'), ('filename', '325.png'), ('size', 167071), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/2eEPc_c7Rfny0s11I2Pcmw/7KaomXYGhqG5kUwezEoJdaT5FIPf0G7iDaCkWuuf4ghXAtxmuIO-K7OJOlvxvevw6vBjb0VZnYhvgbp8a1SsuA/2XHP-TRiesszkQroKSEW7c-pr3HguT1Brmg1Yrn7FnI'), ('width', 67), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RAauu8qHy1QBIr-IuwMT_A/HytEVtUmXjMxgM2l6Zf_vINh56FtgW6c8HOOMTF5n2qF13GgqvYRRCtIrEfbzoLe3cUlxkHjMFDHYY-j75xoQw/ouasoMf3fMflj_fc7CFbqH8b10u6pJ3qQRfpnwhjujs'), ('width', 505), ('height', 271)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4TgZlL9HnC7kdYbhwVbkuw/ZdW4oMZcHGTqAcuS89TsaxY5MbDPC2orU3Btj-1yz1h4-eB5MlZzebWU2dlMKMpc7cLz4QlekM8CIOeDZ8ZtPA/l4dK7vIEitTCei5pj6mvz7b77T5gdf-2sC302fu8qx8'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/temperature-products/cryogenic-temperature-controllers/model-325-cryogenic-temperature-controller,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Lakeshore/Lakeshore_model_325.py,https://qcodes.github.io/Qcodes//drivers_api/Lakeshore.html#qcodes.instrument_drivers.Lakeshore.LakeshoreModel325,,,True,,"from collections.abc import Iterable
from enum import IntFlag
from itertools import takewhile
from typing import Any, Optional, TextIO, cast

from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument
from qcodes.parameters import Group, GroupParameter
from qcodes.validators import Enum, Numbers


def _read_curve_file(curve_file: TextIO) -> dict[Any, Any]:
    """"""
    Read a curve file with extension .330
    The file format of this file is shown in test_lakeshore_file_parser.py
    in the test module

    The output is a dictionary with keys: ""metadata"" and ""data"".
    The metadata dictionary contains the first n lines of the curve file which
    are in the format ""item: value"". The data dictionary contains the actual
    curve data.
    """"""

    def split_data_line(line: str, parser: type = str) -> list[Any]:
        return [parser(i) for i in line.split(""  "") if i != """"]

    def strip(strings: Iterable[str]) -> tuple[str, ...]:
        return tuple(s.strip() for s in strings)

    lines = iter(curve_file.readlines())
    # Meta data lines contain a colon
    metadata_lines = takewhile(lambda s: "":"" in s, lines)
    # Data from the file is collected in the following dict
    file_data: dict[str, dict[str, Any]] = dict()
    # Capture meta data
    parsed_lines = [strip(line.split("":"")) for line in metadata_lines]
    file_data[""metadata""] = {key: value for key, value in parsed_lines}
    # After meta data we have a data header
    header_items = strip(split_data_line(next(lines)))
    # After that we have the curve data
    data: list[list[float]] = [
        split_data_line(line, parser=float) for line in lines if line.strip() != """"
    ]
    file_data[""data""] = dict(zip(header_items, zip(*data)))

    return file_data


def _get_sanitize_data(file_data: dict[Any, Any]) -> dict[Any, Any]:
    """"""
    Data as found in the curve files are slightly different from
    the dictionary as expected by the 'upload_curve' method of the
    driver
    """"""
    data_dict = dict(file_data[""data""])
    # We do not need the index column
    del data_dict[""No.""]
    # Rename the 'Units' column to the appropriate name
    # Look up under the 'Data Format' entry to find what units we have
    data_format = file_data[""metadata""][""Data Format""]
    # This is a string in the form '4      (Log Ohms/Kelvin)'
    data_format_int = int(data_format.split()[0])
    correct_name = LakeshoreModel325Curve.valid_sensor_units[data_format_int - 1]
    # Rename the column
    data_dict[correct_name] = data_dict[""Units""]
    del data_dict[""Units""]

    return data_dict


class LakeshoreModel325Status(IntFlag):
    """"""
    IntFlag that defines status codes for Lakeshore Model 325
    """"""
    sensor_units_overrang = 128
    sensor_units_zero = 64
    temp_overrange = 32
    temp_underrange = 16
    invalid_reading = 1


class LakeshoreModel325Curve(InstrumentChannel):
    """"""
    An InstrumentChannel representing a curve on a Lakeshore Model 325
    """"""

    valid_sensor_units = [""mV"", ""V"", ""Ohm"", ""log Ohm""]
    temperature_key = ""Temperature (K)""

    def __init__(self, parent: ""LakeshoreModel325"", index: int) -> None:

        self._index = index
        name = f""curve_{index}""
        super().__init__(parent, name)

        self.add_parameter(""serial_number"", parameter_class=GroupParameter)

        self.add_parameter(
            ""format"",
            val_mapping={
                f""{unt}/K"": i + 1 for i, unt in enumerate(self.valid_sensor_units)
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(""limit_value"", parameter_class=GroupParameter)

        self.add_parameter(
            ""coefficient"",
            val_mapping={""negative"": 1, ""positive"": 2},
            parameter_class=GroupParameter,
        )

        self.add_parameter(""curve_name"", parameter_class=GroupParameter)

        Group(
            [
                self.curve_name,
                self.serial_number,
                self.format,
                self.limit_value,
                self.coefficient,
            ],
            set_cmd=f""CRVHDR {self._index}, {{curve_name}}, ""
            f""{{serial_number}}, {{format}}, {{limit_value}}, ""
            f""{{coefficient}}"",
            get_cmd=f""CRVHDR? {self._index}"",
        )

    def get_data(self) -> dict[Any, Any]:
        curve = [
            float(a)
            for point_index in range(1, 200)
            for a in self.ask(f""CRVPT? {self._index}, {point_index}"").split("","")
        ]

        d = {self.temperature_key: curve[1::2]}
        sensor_unit = self.format().split(""/"")[0]
        d[sensor_unit] = curve[::2]

        return d

    @classmethod
    def validate_datadict(cls, data_dict: dict[Any, Any]) -> str:
        """"""
        A data dict has two keys, one of which is 'Temperature (K)'. The other
        contains the units in which the curve is defined and must be one of:
        'mV', 'V', 'Ohm' or 'log Ohm'

        This method validates this and returns the sensor unit encountered in
        the data dict
        """"""
        if cls.temperature_key not in data_dict:
            raise ValueError(
                f""At least {cls.temperature_key} needed in the "" f""data dictionary""
            )

        sensor_units = [i for i in data_dict.keys() if i != cls.temperature_key]

        if len(sensor_units) != 1:
            raise ValueError(
                ""Data dictionary should have one other key, other then ""
                ""'Temperature (K)'""
            )

        sensor_unit = sensor_units[0]

        if sensor_unit not in cls.valid_sensor_units:
            raise ValueError(
                f""Sensor unit {sensor_unit} invalid. This needs to be one of ""
                f""{', '.join(cls.valid_sensor_units)}""
            )

        data_size = len(data_dict[cls.temperature_key])
        if data_size != len(data_dict[sensor_unit]) or data_size > 200:
            raise ValueError(
                ""The length of the temperature axis should be ""
                ""the same as the length of the sensor axis and ""
                ""should not exceed 200 in size""
            )

        return sensor_unit

    def set_data(
        self, data_dict: dict[Any, Any], sensor_unit: Optional[str] = None
    ) -> None:
        """"""
        Set the curve data according to the values found the the dictionary.

        Args:
            data_dict (dict): See `validate_datadict` to see the format of this
                                dictionary
            sensor_unit (str): If None, the data dict is validated and the
                                units are extracted.
        """"""
        if sensor_unit is None:
            sensor_unit = self.validate_datadict(data_dict)

        temperature_values = data_dict[self.temperature_key]
        sensor_values = data_dict[sensor_unit]

        for value_index, (temperature_value, sensor_value) in enumerate(
            zip(temperature_values, sensor_values)
        ):

            cmd_str = (
                f""CRVPT {self._index}, {value_index + 1}, ""
                f""{sensor_value:3.3f}, {temperature_value:3.3f}""
            )

            self.write(cmd_str)


class LakeshoreModel325Sensor(InstrumentChannel):
    """"""
    InstrumentChannel for a single sensor of a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        inp (str): Either ""A"" or ""B""
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, inp: str) -> None:

        if inp not in [""A"", ""B""]:
            raise ValueError(""Please either specify input 'A' or 'B'"")

        super().__init__(parent, name)
        self._input = inp

        self.add_parameter(
            ""temperature"",
            get_cmd=f""KRDG? {self._input}"",
            get_parser=float,
            label=""Temperature"",
            unit=""K"",
        )

        self.add_parameter(
            ""status"",
            get_cmd=f""RDGST? {self._input}"",
            get_parser=lambda status: self.decode_sensor_status(int(status)),
            label=""Sensor_Status"",
        )

        self.add_parameter(
            ""type"",
            val_mapping={
                ""Silicon diode"": 0,
                ""GaAlAs diode"": 1,
                ""100 Ohm platinum/250"": 2,
                ""100 Ohm platinum/500"": 3,
                ""1000 Ohm platinum"": 4,
                ""NTC RTD"": 5,
                ""Thermocouple 25mV"": 6,
                ""Thermocouple 50 mV"": 7,
                ""2.5 V, 1 mA"": 8,
                ""7.5 V, 1 mA"": 9,
            },
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""compensation"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        Group(
            [self.type, self.compensation],
            set_cmd=f""INTYPE {self._input}, {{type}}, {{compensation}}"",
            get_cmd=f""INTYPE? {self._input}"",
        )

        self.add_parameter(
            ""curve_index"",
            set_cmd=f""INCRV {self._input}, {{}}"",
            get_cmd=f""INCRV? {self._input}"",
            get_parser=int,
            vals=Numbers(min_value=1, max_value=35),
        )

    @staticmethod
    def decode_sensor_status(sum_of_codes: int) -> str:
        total_status = LakeshoreModel325Status(sum_of_codes)
        if sum_of_codes == 0:
            return ""OK""
        status_messages = [
            st.name.replace(""_"", "" "")
            for st in LakeshoreModel325Status
            if st in total_status and st.name is not None
        ]
        return "", "".join(status_messages)

    @property
    def curve(self) -> LakeshoreModel325Curve:
        parent = cast(LakeshoreModel325, self.parent)
        return LakeshoreModel325Curve(parent, self.curve_index())


class LakeshoreModel325Heater(InstrumentChannel):
    """"""
    InstrumentChannel for heater control on a Lakeshore Model 325.

    Args:
        parent (LakeshoreModel325): The instrument this heater belongs to
        name (str)
        loop (int): Either 1 or 2
    """"""

    def __init__(self, parent: ""LakeshoreModel325"", name: str, loop: int) -> None:

        if loop not in [1, 2]:
            raise ValueError(""Please either specify loop 1 or 2"")

        super().__init__(parent, name)
        self._loop = loop

        self.add_parameter(
            ""control_mode"",
            get_cmd=f""CMODE? {self._loop}"",
            set_cmd=f""CMODE {self._loop},{{}}"",
            val_mapping={
                ""Manual PID"": ""1"",
                ""Zone"": ""2"",
                ""Open Loop"": ""3"",
                ""AutoTune PID"": ""4"",
                ""AutoTune PI"": ""5"",
                ""AutoTune P"": ""6"",
            },
        )

        self.add_parameter(
            ""input_channel"", vals=Enum(""A"", ""B""), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""unit"",
            val_mapping={""Kelvin"": ""1"", ""Celsius"": ""2"", ""Sensor Units"": ""3""},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""powerup_enable"",
            val_mapping={True: 1, False: 0},
            parameter_class=GroupParameter,
        )

        self.add_parameter(
            ""output_metric"",
            val_mapping={
                ""current"": ""1"",
                ""power"": ""2"",
            },
            parameter_class=GroupParameter,
        )

        Group(
            [self.input_channel, self.unit, self.powerup_enable, self.output_metric],
            set_cmd=f""CSET {self._loop}, {{input_channel}}, {{unit}}, ""
            f""{{powerup_enable}}, {{output_metric}}"",
            get_cmd=f""CSET? {self._loop}"",
        )

        self.add_parameter(
            ""P"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""I"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        self.add_parameter(
            ""D"", vals=Numbers(0, 1000), get_parser=float, parameter_class=GroupParameter
        )

        Group(
            [self.P, self.I, self.D],
            set_cmd=f""PID {self._loop}, {{P}}, {{I}}, {{D}}"",
            get_cmd=f""PID? {self._loop}"",
        )

        if self._loop == 1:
            valid_output_ranges = Enum(0, 1, 2)
        else:
            valid_output_ranges = Enum(0, 1)

        self.add_parameter(
            ""output_range"",
            vals=valid_output_ranges,
            set_cmd=f""RANGE {self._loop}, {{}}"",
            get_cmd=f""RANGE? {self._loop}"",
            val_mapping={""Off"": ""0"", ""Low (2.5W)"": ""1"", ""High (25W)"": ""2""},
        )

        self.add_parameter(
            ""setpoint"",
            vals=Numbers(0, 400),
            get_parser=float,
            set_cmd=f""SETP {self._loop}, {{}}"",
            get_cmd=f""SETP? {self._loop}"",
        )

        self.add_parameter(
            ""ramp_state"", vals=Enum(0, 1), parameter_class=GroupParameter
        )

        self.add_parameter(
            ""ramp_rate"",
            vals=Numbers(0, 100 / 60 * 1e3),
            unit=""mK/s"",
            parameter_class=GroupParameter,
            get_parser=lambda v: float(v) / 60 * 1e3,  # We get values in K/min,
            set_parser=lambda v: v * 60 * 1e-3,  # Convert to K/min
        )

        Group(
            [self.ramp_state, self.ramp_rate],
            set_cmd=f""RAMP {self._loop}, {{ramp_state}}, {{ramp_rate}}"",
            get_cmd=f""RAMP? {self._loop}"",
        )

        self.add_parameter(""is_ramping"", get_cmd=f""RAMPST? {self._loop}"")

        self.add_parameter(
            ""resistance"",
            get_cmd=f""HTRRES? {self._loop}"",
            set_cmd=f""HTRRES {self._loop}, {{}}"",
            val_mapping={
                25: 1,
                50: 2,
            },
            label=""Resistance"",
            unit=""Ohm"",
        )

        self.add_parameter(
            ""heater_output"",
            get_cmd=f""HTR? {self._loop}"",
            get_parser=float,
            label=""Heater Output"",
            unit=""%"",
        )


class LakeshoreModel325(VisaInstrument):
    """"""
    QCoDeS driver for Lakeshore Model 325 Temperature Controller.
    """"""

    def __init__(self, name: str, address: str, **kwargs: Any) -> None:
        super().__init__(name, address, terminator=""\r\n"", **kwargs)

        sensors = ChannelList(
            self, ""sensor"", LakeshoreModel325Sensor, snapshotable=False
        )

        for inp in [""A"", ""B""]:
            sensor = LakeshoreModel325Sensor(self, f""sensor_{inp}"", inp)
            sensors.append(sensor)
            self.add_submodule(f""sensor_{inp}"", sensor)

        self.add_submodule(""sensor"", sensors.to_channel_tuple())

        heaters = ChannelList(
            self, ""heater"", LakeshoreModel325Heater, snapshotable=False
        )

        for loop in [1, 2]:
            heater = LakeshoreModel325Heater(self, f""heater_{loop}"", loop)
            heaters.append(heater)
            self.add_submodule(f""heater_{loop}"", heater)

        self.add_submodule(""heater"", heaters.to_channel_tuple())

        curves = ChannelList(self, ""curve"", LakeshoreModel325Curve, snapshotable=False)

        for curve_index in range(1, 35):
            curve = LakeshoreModel325Curve(self, curve_index)
            curves.append(curve)

        self.add_submodule(""curve"", curves)

        self.connect_message()

    def upload_curve(
        self, index: int, name: str, serial_number: str, data_dict: dict[Any, Any]
    ) -> None:
        """"""
        Upload a curve to the given index

        Args:
             index: The index to upload the curve to. We can only use
                            indices reserved for user defined curves, 21-35
             name
             serial_number
             data_dict: A dictionary containing the curve data
        """"""
        if index not in range(21, 36):
            raise ValueError(""index value should be between 21 and 35"")

        sensor_unit = LakeshoreModel325Curve.validate_datadict(data_dict)

        curve = self.curve[index - 1]
        curve.curve_name(name)
        curve.serial_number(serial_number)
        curve.format(f""{sensor_unit}/K"")
        curve.set_data(data_dict, sensor_unit=sensor_unit)

    def upload_curve_from_file(self, index: int, file_path: str) -> None:
        """"""
        Upload a curve from a curve file. Note that we only support
        curve files with extension .330
        """"""
        if not file_path.endswith("".330""):
            raise ValueError(""Only curve files with extension .330 are supported"")

        with open(file_path) as curve_file:
            file_data = _read_curve_file(curve_file)

        data_dict = _get_sanitize_data(file_data)
        name = file_data[""metadata""][""Sensor Model""]
        serial_number = file_data[""metadata""][""Serial Number""]

        self.upload_curve(index, name, serial_number, data_dict)
"
395,2.0,"COPENHAGEN, DENMARK","QDAC is a high-precision, 25-bit resolution, ultra-low-noise computer-controlled DAC with 24 voltage channel generators operating at a sample rate of 1MS/s. It is designed for DC and intermediate-frequency control of quantum devices, including, for example, gate electrodes and flux bias coils in qubits. It is also a very versatile instrument that can be used for many other purposes.

",Qdac Channels,421.0,"Founded in 2016, QDevil is an international quantum technology company focused on developing and manufacturing auxiliary electronics and specialized components, operating from mK to room temperature. The mission is to accelerate research and development in quantum electronics labs. To fulfill the mission QDevil helps customers around the world by supplying world-class auxiliary electronics.
",Qcodes,Qdev,"[OrderedDict([('id', 'attz9erwtKcDDy955'), ('width', 150), ('height', 22), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Iaef-6NIciOWKsa10JxRkQ/2GD5HG7BPockb2ex1jGFrrTiU7BBCn-BUh4yFbVUC5HnbjZi95IkzXzO47AqXvh4ovR1NzYgfo7u3K7F-Iy8CnFqjwnWhHdoP_drQzUgyBk/oOtNVvCMSwDpcFzmES9UhD5dKEVKxrogflaoIXeeec8'), ('filename', 'QM-and-QD-logos4.svg'), ('size', 30131), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/FEuZ28mowNgi5RsJVepsLA/nE8QsdJyxc7HF5HxYg-4FFyeNkCTIKwJqjAwoaeytJ-iQqogaf-JVLfsCMLSML3dXxikZxzR6Rup1FkWKPSsp6TdH_lwDt2uwXfZZObRFaw/Mr8sxOK6ErffdVcGCGd9Noq-q8_R0fFznaYT4z6B90Y'), ('width', 150), ('height', 22)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Bc9p_dlutAJiwDTZk-lRuA/xZRaVdQKhbsxI4GHc1mwsR36JbnSB5oSf8NvVCn4V_nuitBVHtQnG-gO3jON58ALpa1lVZoXLx1CboupbmfRHo3f8f4YYwqAuWrV1agWFVk/kFtddMZcEdyeo4wkQWKEZgqJAOXxNMFF7M0ly33iR-U'), ('width', 150), ('height', 22)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ZWUIK3fC6Wb-Ng9czNLYlA/m5_LISZrGWJewXrhSx_993pJ9dPAO2-JAj8Mg-w58KQZkiDxtbCozX6QJOc4ji80rHiwF-hC-y3R2Iq50RB-K7PdX7GbvFYACEcEIz4kCkg/5N7AzqvO5ZJj-aPr-dLGjU-y_oooID3NX9eRPyvp5zE'), ('width', 3000), ('height', 3000)]))]))])]",https://qdevil.com/,"Write a Python script that uses Qcodes to connect to a QDAC Power Supplies, Digital-Analog Converter",https://en.wikipedia.org/wiki/Digital-to-analog_converter,"['Power Supplies', 'Digital-Analog Converter']","In electronics, a digital-to-analog converter (DAC, D/A, D2A, or D-to-A) is a system that converts a digital signal into an analog signal. An analog-to-digital converter (ADC) performs the reverse function.",QDAC,,,"https://www.quantum-machines.co/products/qdac/#:~:text=QDAC%20is%20a%20high%2Dprecision,flux%20bias%20coils%20in%20qubits.",https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/QDev/QDac_channels.py,https://qcodes.github.io/Qcodes/drivers_api/QDev.html#qcodes.instrument_drivers.QDev.QDevQDac,,,,,"# QCoDeS driver for QDac using channels

import logging
import time
from collections.abc import Sequence
from functools import partial
from typing import Any, Optional, Union

import pyvisa
import pyvisa.constants
from pyvisa.resources.serial import SerialInstrument

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import MultiChannelInstrumentParameter, ParamRawDataType

log = logging.getLogger(__name__)


class QDevQDacChannel(InstrumentChannel):
    """"""
    A single output channel of the QDac.

    Exposes chan.v, chan.vrange, chan.slope, chan.i, chan.irange
    """"""

    _CHANNEL_VALIDATION = vals.Numbers(1, 48)

    def __init__(self, parent: Instrument, name: str, channum: int):
        """"""
        Args:
            parent: The instrument to which the channel is
                attached.
            name: The name of the channel
            channum: The number of the channel in question (1-48)
        """"""
        super().__init__(parent, name)

        # Validate the channel
        self._CHANNEL_VALIDATION.validate(channum)

        # Add the parameters

        self.add_parameter('v',
                           label=f'Channel {channum} voltage',
                           unit='V',
                           set_cmd=partial(self._parent._set_voltage, channum),
                           get_cmd=partial(self._parent._get_voltage, channum),
                           get_parser=float,
                           vals=vals.Numbers(-10, 10)
                           )

        self.add_parameter('vrange',
                           label=f'Channel {channum} atten.',
                           set_cmd=partial(self._parent._set_vrange, channum),
                           get_cmd=partial(self._parent._get_vrange, channum),
                           vals=vals.Enum(0, 1)
                           )

        self.add_parameter('i',
                           label=f'Channel {channum} current',
                           get_cmd=f'get {channum}',
                           unit='A',
                           get_parser=self._parent._current_parser
                           )

        self.add_parameter('irange',
                           label=f'Channel {channum} irange',
                           set_cmd=f'cur {channum} {{}}',
                           get_cmd=f'cur {channum}',
                           get_parser=int
                           )

        self.add_parameter('slope',
                           label=f'Channel {channum} slope',
                           unit='V/s',
                           set_cmd=partial(self._parent._setslope, channum),
                           get_cmd=partial(self._parent._getslope, channum),
                           vals=vals.MultiType(vals.Enum('Inf'),
                                               vals.Numbers(1e-3, 100))
                           )

        self.add_parameter('sync',
                           label=f'Channel {channum} sync output',
                           set_cmd=partial(self._parent._setsync, channum),
                           get_cmd=partial(self._parent._getsync, channum),
                           vals=vals.Ints(0, 5)
                           )

        self.add_parameter(name='sync_delay',
                           label=f'Channel {channum} sync pulse delay',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           initial_value=0
                           )

        self.add_parameter(name='sync_duration',
                           label=f'Channel {channum} sync pulse duration',
                           unit='s',
                           get_cmd=None, set_cmd=None,
                           initial_value=0.01
                           )

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._parent._update_currents and update
        if update and not self._parent._get_status_performed:
            self._parent._update_cache(readcurrents=update_currents)
        # call get_status rather than getting the status individually for
        # each parameter. This is only done if _get_status_performed is False
        # this is used to signal that the parent has already called it and
        # no need to repeat.
        if params_to_skip_update is None:
            params_to_skip_update = ('v', 'i', 'irange', 'vrange')
        snap = super().snapshot_base(update=update,
                                     params_to_skip_update=params_to_skip_update)
        return snap


QDacChannel = QDevQDacChannel


class QDevQDacMultiChannelParameter(MultiChannelInstrumentParameter):
    """"""
    The class to be returned by __getattr__ of the ChannelList. Here customised
    for fast multi-readout of voltages.
    """"""
    def __init__(
            self,
            channels: Sequence[InstrumentChannel],
            param_name: str,
            *args: Any,
            **kwargs: Any):
        super().__init__(channels, param_name, *args, **kwargs)

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        """"""
        Return a tuple containing the data from each of the channels in the
        list.
        """"""
        # For voltages, we can do something slightly faster than the naive
        # approach

        if self._param_name == 'v':
            qdac = self._channels[0]._parent
            qdac._update_cache(readcurrents=False)
            output = tuple(chan.parameters[self._param_name].get_latest()
                           for chan in self._channels)
        else:
            output = tuple(chan.parameters[self._param_name].get()
                           for chan in self._channels)

        return output


QDacMultiChannelParameter = QDevQDacMultiChannelParameter


class QDevQDac(VisaInstrument):
    """"""
    Channelised driver for the QDev digital-analog converter QDac

    Based on ""DAC_commands_v_13.pdf""
    Tested with Software Version: 0.170202

    The driver assumes that the instrument is ALWAYS in verbose mode OFF
    """"""


    # set nonzero value (seconds) to accept older status when reading settings
    max_status_age = 1

    def __init__(self,
                 name: str,
                 address: str,
                 num_chans: int = 48,
                 update_currents: bool = True,
                 **kwargs: Any):
        """"""
        Instantiates the instrument.

        Args:
            name: The instrument name used by qcodes
            address: The VISA name of the resource
            num_chans: Number of channels to assign. Default: 48
            update_currents: Whether to query all channels for their
                current current value on startup. Default: True.

        Returns:
            QDac object
        """"""
        super().__init__(name, address, **kwargs)
        self._output_n_lines = 50
        handle = self.visa_handle
        assert isinstance(handle, SerialInstrument)
        self._get_status_performed = False
        # This is the baud rate on power-up. It can be changed later but
        # you must start out with this value.
        handle.baud_rate = 460800
        handle.parity = pyvisa.constants.Parity(0)
        handle.data_bits = 8
        self.set_terminator('\n')
        # TODO: do we want a method for write termination too?
        handle.write_termination = '\n'
        # TODO: do we need a query delay for robust operation?
        self._write_response = ''

        if self._get_firmware_version() < 0.170202:
            raise RuntimeError('''
                               Obsolete QDAC Software version detected.
                               QCoDeS only supports version 0.170202 or newer.
                               Contact rikke.lutge@nbi.ku.dk for an update.
                               ''')

        self.num_chans = num_chans

        # Assigned slopes. Entries will eventually be [chan, slope]
        self._slopes: list[tuple[int, Union[str, float]]] = []
        # Function generators (used in _set_voltage)
        self._fgs = set(range(1, 9))
        self._assigned_fgs: dict[int, int] = {}  # {chan: fg}
        # Sync channels
        self._syncoutputs: list[tuple[int, int]] = []  # Entries: [chan, syncchannel]

        self.chan_range = range(1, 1 + self.num_chans)
        self.channel_validator = vals.Ints(1, self.num_chans)

        channels = ChannelList(
            self,
            ""Channels"",
            QDevQDacChannel,
            snapshotable=False,
            multichan_paramclass=QDevQDacMultiChannelParameter,
        )

        for i in self.chan_range:
            channel = QDevQDacChannel(self, f""chan{i:02}"", i)
            channels.append(channel)
            # Should raise valueerror if name is invalid (silently fails now)
            self.add_submodule(f""ch{i:02}"", channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        for board in range(6):
            for sensor in range(3):
                label = f'Board {board}, Temperature {sensor}'
                self.add_parameter(name=f'temp{board}_{sensor}',
                                   label=label,
                                   unit='C',
                                   get_cmd=f'tem {board} {sensor}',
                                   get_parser=self._num_verbose)

        self.add_parameter(name='cal',
                           set_cmd='cal {}',
                           vals=self.channel_validator)
        # TO-DO: maybe it's too dangerous to have this settable.
        # And perhaps ON is a better verbose mode default?
        self.add_parameter(name='verbose',
                           set_cmd='ver {}',
                           val_mapping={True: 1, False: 0})

        # Initialise the instrument, all channels DC (unbind func. generators)
        for chan in self.chan_range:
            # Note: this call does NOT change the voltage on the channel
            self.write(f'wav {chan} 0 1 0')

        self.verbose.set(False)
        self.connect_message()
        log.info('[*] Querying all channels for voltages and currents...')
        self.version = self._update_cache(readcurrents=update_currents)
        self._update_currents = update_currents
        log.info('[+] Done')

    def snapshot_base(
            self,
            update: Optional[bool] = False,
            params_to_skip_update: Optional[Sequence[str]] = None
    ) -> dict[Any, Any]:
        update_currents = self._update_currents and update is True
        if update:
            self._update_cache(readcurrents=update_currents)
            self._get_status_performed = True
        # call get_status rather than getting the status individually for
        # each parameter. We set _get_status_performed to True
        # to indicate that each update channel does not need to call this
        # function as opposed to when snapshot is called on an individual
        # channel
        snap = super().snapshot_base(update=update,
                                     params_to_skip_update=params_to_skip_update)
        self._get_status_performed = False
        return snap

    #########################
    # Channel gets/sets
    #########################

    def _set_voltage(
            self,
            chan: int,
            v_set: float) -> None:
        """"""
        set_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
            v_set: The target voltage

        If a finite slope has been assigned, we assign a function generator to
        ramp the voltage.
        """"""
        channel = self.channels[chan-1]

        slopechans = [sl[0] for sl in self._slopes]
        if chan in slopechans:
            slope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            # find and assign fg
            fg = min(self._fgs.difference(set(self._assigned_fgs.values())))
            self._assigned_fgs[chan] = fg
            # We need .get and not get_latest in case a ramp was interrupted
            v_start = channel.v.get()
            time = abs(v_set-v_start)/slope
            log.info(f'Slope: {slope}, time: {time}')
            # Attenuation compensation and syncing
            # happen inside _rampvoltage
            self._rampvoltage(chan, fg, v_start, v_set, time)
        else:
            v_dac = QDevQDac._get_v_dac_from_v_exp(channel, v_set)
            # set the mode back to DC in case it had been changed
            # and then set the voltage
            self.write(f'wav {chan} 0 0 0;set {chan} {v_dac:.6f}')

    def _get_voltage(self, chan: int) -> float:
        """"""
        get_cmd for the chXX_v parameter

        Args:
            chan: The 1-indexed channel number
        """"""
        self._update_cache(readcurrents=False)
        return self.channels[chan - 1].v.cache()


    # In order to get conversions right let us define a vocabulary:
    # v_exp: is the voltage including the attenuation.This is the value
    # we want to store in the cache and the value we interact with as a
    # qcodes user.
    # v_dac: this is the voltage generated by the dac and handled by the VISA
    # commands.
    # Then we have the general relationship`v_exp = v_dac * attenuation`,
    @staticmethod
    def _get_attenuation(channel: QDevQDacChannel) -> float:
        return 0.1 if channel.vrange.cache() == 1 else 1.0

    @staticmethod
    def _get_v_dac_from_v_exp(channel: QDevQDacChannel, v_exp: float) -> float:
        return v_exp / QDevQDac._get_attenuation(channel)

    @staticmethod
    def _get_v_exp_from_v_dac(channel: QDevQDacChannel, v_dac: float) -> float:
        return v_dac * QDevQDac._get_attenuation(channel)

    def _set_vrange(self, chan: int, switchint: int) -> None:
        """"""
        set_cmd for the chXX_vrange parameter

        The switchint is an integer. 1 means attenuation ON.

        Since the vrange is actually a 20 dB attenuator (amplitude factor 0.1)
        immediately applied to the channel output, we must update the voltage
        parameter accordingly
        """"""

        self.write(f'vol {chan} {switchint}')

        # setting v_range preserves v_dac but changes v_exp, see comment above
        # for definitions.
        channel = self.channels[chan-1]
        if channel.vrange.cache() != switchint:
            v_dac = QDevQDac._get_v_dac_from_v_exp(channel, channel.v.cache())
            channel.vrange.cache.set(switchint)
            self._update_v_validator(channel, switchint)
            channel.v.cache.set(QDevQDac._get_v_exp_from_v_dac(channel, v_dac))

    def _get_vrange(self, chan: int) -> float:
        """"""
        get_cmd for the chXX_vrange parameter

        Args:
            chan: The 1-indexed channel number
        """"""
        self._update_cache(readcurrents=False)
        return self.channels[chan - 1].vrange.cache()

    def _num_verbose(self, s: str) -> float:
        """"""
        turn a return value from the QDac into a number.
        If the QDac is in verbose mode, this involves stripping off the
        value descriptor.
        """"""
        if self.verbose.get_latest():
            s = s.split(': ')[-1]
        return float(s)

    def _current_parser(self, s: str) -> float:
        """"""
        parser for chXX_i parameter
        """"""
        return 1e-6*self._num_verbose(s)

    def _update_cache(self, readcurrents: bool = False) -> str:
        r""""""
        Function to query the instrument and get the status of all channels,
        e.g. voltage (``v``), voltage range (``vrange``), and current range (``irange``)
        parameters of all the channels.
        Takes a while to finish.

        The `status` call generates 51 lines of output. Send the command and
        read the first one, which is the software version line
        the full output looks like:
        Software Version: 0.160218\r\n
        Channel\tOut V\t\tVoltage range\tCurrent range\n
        \n
        8\t  0.000000\t\tX 1\t\tpA\n
        7\t  0.000000\t\tX 1\t\tpA\n
        ... (all 48 channels like this in a somewhat peculiar order)
        (no termination afterward besides the \n ending the last channel)
        returns a list of dicts [{v, vrange, irange}]
        NOTE - channels are 1-based, but the return is a list, so of course
        0-based, ie chan1 is out[0]
        """"""

        def validate_version(version_line: str) -> str:
            if version_line.startswith(""Software Version: ""):
                version = version_line.strip().split("": "")[1]
            else:
                self._wait_and_clear()
                raise ValueError('unrecognized version line: ' + version_line)
            return version

        def validate_header(header_line: str) -> None:
            headers = header_line.lower().strip('\r\n').split('\t')
            expected_headers = ['channel', 'out v', '', 'voltage range',
                                'current range']
            if headers != expected_headers:
                raise ValueError('unrecognized header line: ' + header_line)

        def parse_line(line: str) -> tuple[int, int, int, float]:
            i_range_trans = {'hi cur': 1, 'lo cur': 0}
            v_range_trans = {'X 1': 0, 'X 0.1': 1}

            chan_str, v_str, _, v_range_str, _, i_range_str = line.split('\t')
            chan = int(chan_str)
            v_dac = float(v_str)
            v_range = v_range_trans[v_range_str.strip()]
            i_range = i_range_trans[i_range_str.strip()]
            return chan, i_range, v_range, v_dac

        version = validate_version(self.ask(""status""))
        validate_header(self.read())

        chans_left = set(self.chan_range)
        while chans_left:
            line = self.read().strip()
            if not line:
                continue
            chan, i_range, v_range, v_dac = parse_line(line)

            channel = self.channels[chan - 1]
            channel.vrange.cache.set(v_range)
            self._update_v_validator(channel, v_range)
            channel.irange.cache.set(i_range)
            channel.v.cache.set(QDevQDac._get_v_exp_from_v_dac(channel, v_dac))

            chans_left.remove(chan)

        if readcurrents:
            self._read_currents()
        return version

    def _read_currents(self) -> None:
        for chan in range(1, self.num_chans + 1):
            param = self.channels[chan - 1].i
            _ = param.get()

    @staticmethod
    def _update_v_validator(channel: QDevQDacChannel, v_range: int) -> None:
        range = (-10.01, 10.01) if v_range == 0 else (-1.001, 1.001)
        channel.v.vals = vals.Numbers(*range)

    def _setsync(self, chan: int, sync: int) -> None:
        """"""
        set_cmd for the chXX_sync parameter.

        Args:
            chan (int): The channel number (1-48)
            sync (int): The associated sync output. 0 means 'unassign'
        """"""

        if chan not in range(1, 49):
            raise ValueError('Channel number must be 1-48.')

        if sync == 0:
            # try to remove the sync from internal bookkeeping
            try:
                sc = self._syncoutputs
                to_remove = [sc.index(syn) for syn in sc if syn[0] == chan][0]
                self._syncoutputs.remove(sc[to_remove])
            except IndexError:
                pass
            # free the previously assigned sync
            oldsync = self.channels[chan-1].sync.get_latest()
            if oldsync is not None:
                self.write(f'syn {oldsync} 0 0 0')
            return

        if sync in [syn[1] for syn in self._syncoutputs]:
            oldchan = [syn[0] for syn in self._syncoutputs if syn[1] == sync][0]
            self._syncoutputs.remove((oldchan, sync))

        if chan in [syn[0] for syn in self._syncoutputs]:
            oldsyn = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            self._syncoutputs[
                self._syncoutputs.index((chan, oldsyn))
            ] = (chan, sync)
            return

        self._syncoutputs.append((chan, sync))
        return

    def _getsync(self, chan: int) -> float:
        """"""
        get_cmd of the chXX_sync parameter
        """"""
        if chan in [syn[0] for syn in self._syncoutputs]:
            sync = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            return sync
        else:
            return 0

    def _setslope(self, chan: int, slope: Union[float, str]) -> None:
        """"""
        set_cmd for the chXX_slope parameter, the maximum slope of a channel.

        Args:
            chan: The channel number (1-48)
            slope: The slope in V/s. Write 'Inf' to allow
              arbitrary small rise times.
        """"""
        if chan not in range(1, 49):
            raise ValueError('Channel number must be 1-48.')

        if slope == 'Inf':
            self.write(f'wav {chan} 0 0 0')

            # Now clear the assigned slope and function generator (if possible)
            try:
                self._assigned_fgs.pop(chan)
            except KeyError:
                pass
            # Remove a sync output, if one was assigned
            syncchans = [syn[0] for syn in self._syncoutputs]
            if chan in syncchans:
                self.channels[chan-1].sync.set(0)
            try:
                sls = self._slopes
                to_remove = [sls.index(sl) for sl in sls if sl[0] == chan][0]
                self._slopes.remove(sls[to_remove])
                return
            # If the value was already 'Inf', the channel was not
            # in the list and nothing happens
            except IndexError:
                return

        if chan in [sl[0] for sl in self._slopes]:
            oldslope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            self._slopes[self._slopes.index((chan, oldslope))] = (chan, slope)
            return

        if len(self._slopes) >= 8:
            rampchans = "", "".join(str(c[0]) for c in self._slopes)
            raise ValueError(
                ""Can not assign finite slope to more than ""
                + ""8 channels. Assign 'Inf' to at least one of ""
                + f""the following channels: {rampchans}""
            )

        self._slopes.append((chan, slope))
        return

    def _getslope(self, chan: int) -> Union[str, float]:
        """"""
        get_cmd of the chXX_slope parameter
        """"""
        if chan in [sl[0] for sl in self._slopes]:
            slope = [sl[1] for sl in self._slopes if sl[0] == chan][0]
            return slope
        else:
            return 'Inf'

    def printslopes(self) -> None:
        """"""
        Print the finite slopes assigned to channels
        """"""
        for sl in self._slopes:
            print(f""Channel {sl[0]}, slope: {sl[1]} (V/s)"")

    def _rampvoltage(
            self,
            chan: int,
            fg: int,
            v_start: float,
            setvoltage: float,
            ramptime: float
    ) -> None:
        """"""
        Smoothly ramp the voltage of a channel by the means of a function
        generator. Helper function used by _set_voltage.

        Args:
            chan: The channel number (counting from 1)
            fg: The function generator (counting from 1)
            setvoltage: The voltage to ramp to
            ramptime: The ramp time in seconds.
        """"""

        # Crazy stuff happens if the period is too small, e.g. the channel
        # can jump to its max voltage
        if ramptime <= 0.002:
            ramptime = 0
            log.warning('Cancelled a ramp with a ramptime of '
                        '{} s'.format(ramptime) + '. Voltage not changed.')

        offset = v_start
        amplitude = setvoltage-v_start
        if self.channels[chan-1].vrange.get_latest() == 1:
            offset *= 10
            amplitude *= 10

        chanmssg = 'wav {} {} {} {}'.format(chan, fg,
                                            amplitude,
                                            offset)

        if chan in [syn[0] for syn in self._syncoutputs]:
            sync = [syn[1] for syn in self._syncoutputs if syn[0] == chan][0]
            sync_duration = 1000*self.channels[chan-1].sync_duration.get()
            sync_delay = 1000*self.channels[chan-1].sync_delay.get()
            self.write('syn {} {} {} {}'.format(sync, fg,
                                                sync_delay,
                                                sync_duration))

        typedict = {'SINE': 1, 'SQUARE': 2, 'RAMP': 3}

        typeval = typedict['RAMP']
        dutyval = 100
        # s -> ms
        periodval = ramptime*1e3
        repval = 1
        funmssg = 'fun {} {} {} {} {}'.format(fg,
                                              typeval, periodval,
                                              dutyval, repval)
        self.write(chanmssg)
        self.write(funmssg)

    def write(self, cmd: str) -> None:
        """"""
        QDac always returns something even from set commands, even when
        verbose mode is off, so we'll override write to take this out
        if you want to use this response, we put it in self._write_response
        (but only for the very last write call)

        In this method we expect to read one termination char per command. As
        commands are concatenated by `;` we count the number of concatenated
        commands as count(';') + 1 e.g. 'wav 1 1 1 0;fun 2 1 100 1 1' is two
        commands. Note that only the response of the last command will be
        available in `_write_response`

        """"""

        log.debug(f""Writing to instrument {self.name}: {cmd}"")

        self.visa_handle.write(cmd)
        for _ in range(cmd.count(';')+1):
            self._write_response = self.visa_handle.read()

    def read(self) -> str:
        return self.visa_handle.read()

    def _wait_and_clear(self, delay: float = 0.5) -> None:
        time.sleep(delay)
        self.visa_handle.clear()

    def connect_message(self,
                        idn_part: str = ""IDN"",
                        being_time: Optional[float] = None) -> None:
        """"""
        Override of the standard Instrument class connect_message.
        Usually, the response to `*IDN?` is printed. Here, the
        software version is printed.
        """"""
        self.visa_handle.write('status')

        log.info('Connected to QDac on {}, {}'.format(self._address,
                                                      self.visa_handle.read()))

        # take care of the rest of the output
        for _ in range(self._output_n_lines):
            self.visa_handle.read()

    def _get_firmware_version(self) -> float:
        self.write('status')
        FW_str = self._write_response
        FW_version = float(FW_str.replace('Software Version: ', ''))
        for _ in range(self._output_n_lines):
            self.read()
        return FW_version

    def print_overview(self, update_currents: bool = False) -> None:
        """"""
        Pretty-prints the status of the QDac
        """"""

        self._update_cache(readcurrents=update_currents)

        paramstoget = [['i', 'v'], ['irange', 'vrange']]
        printdict = {'i': 'Current', 'v': 'Voltage', 'vrange': 'Voltage range',
                     'irange': 'Current range'}

        returnmap = {'vrange': {1: '-1 V to 1 V', 0: '-10 V to 10 V'},
                     'irange': {0: '0 to 1 muA', 1: '0 to 100 muA'}}

        # Print the channels
        for ii in range(self.num_chans):
            line = f""Channel {ii+1} \n""
            line += ""    ""
            for pp in paramstoget[0]:
                param = getattr(self.channels[ii], pp)
                line += printdict[pp]
                line += f': {param.get_latest()}'
                line += f' ({param.unit})'
                line += '. '
            line += '\n    '
            for pp in paramstoget[1]:
                param = getattr(self.channels[ii], pp)
                line += printdict[pp]
                value = param.get_latest()
                line += f"": {returnmap[pp][value]}""
                line += "". ""
            print(line)


class QDac(QDevQDac):
    """"""
    Backwards compatibility alias for QDevQDac driver
    """"""

    pass
"
396,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34461 A Submodules,273.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34461A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34461A Submodules,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,"[OrderedDict([('id', 'att07IIiNQzMwugAH'), ('width', 1200), ('height', 735), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/-Srkdm4oWM_M6Fg-ebFHnA/b4ztrLFM2ZZpAqh6EjSLQLse4B7HlLiGBnYZ0JoQ4TVx_cZY2RXJ2J59FDs-ZIcBg03bOqWE74cqTu9Jr2rTggpfjGxBnjEWi8H4OnsL4M9zE1Mb_90tF9gH1my5XEMW/OLSC26Tgh707kTAFhO289m2k4URVGwDP8yMaahGwvjA'), ('filename', '34461a-front-black-1200x735-White-b.jpg'), ('size', 201918), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/q25ZwH2BiV83-KfJvzQeXA/j3V3Eu4iWLTNRFSyWzJ-1nlN854DutuI6vmJOr4YxMued1gw9ubxIh4DlXBP5C3POfn4nwkDfr8ftsMVjdV8Mw/SWks3gl1Vpx_CNITXxAGuMjaFPee8wamJVzMnFUaEro'), ('width', 59), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ErEG7yxgGPeMRoHo2t-QdQ/SCcrgUIO33hWPy3OkHb_a9ed0zxR05eUAT53WYqLVROMtn7sXEG4XOtGIEoz2q3MNNeVDZ723n_qTWiUy2GLmg/Sut8FyM5mzIyhQR7ifK74q3KxO0bn278dgqSauQIn4A'), ('width', 836), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BqLhlrXGseJwvZwNqrSdaw/KaN2PBQMLUOgARFUDk4AIc69EOR2CXWAn7D97RgLizRu_Yz5y5hInz26MoUd_9TtfmeUHA5mBWZpHNT34MMkcQ/twXr_QrIhL3SWEduPvj6JtFwGJbpNWd9UID92FZDU8w'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34461A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34461A,1863.0,,,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34461A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34461A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34461A(_Keysight_344xxA):
    """"""
    Alias for backwards compatibility.
    """"""
"
398,2500.0,"Munich, Germany",,ZNB,460.0,"Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",Qcodes,Rohde Schwarz,"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/9cHh-T5DiH-7n6lLjMACLA/bDi2rAgBKKv-UvdRleHzviIH4GcH8AtS2mvdp-g9F5fqCVLRPlAnSBTRQa-Runosj2pUwoAlhqQuz5TbVkWsAPnNM3W2hWam9hmsDAI-rL4/dffvM0sgfAmzoe43t-msnU6e8D0UM-OZGHt_kN6EI98'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/g--_RRN7TAxVYvYfZsfJAQ/7QuUf0QEBkC8SMdK1bmt-YbCN0y4Vh7DjHjVWWAwYMWJee9W1_UqwdojXEJzVUALXPhc6LnhN-lsQmk6w-lHDw/6fec6hnAGzjzj0BDv0TEHJtermLLj4Z3b2m6J6dHT1A'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/oMsz97Tz22aazBF2MmRx0A/qA2gKhQNxFidpSGhEU04F-OoIhF7BfJmWCmPJxKK-IF58k94GMqfn4_xpOfpg48Eyj-YsME_D_oNERlbxBoo6Q/RSM8ZcvfANnn-GXOF96XT_DsItZl0IBVWIuKqbrwXeg'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UFP-LpUBl8Q8A7_iSD2G2w/fk4nHw-_8wbi1zc78qVKGp5QIQa5f6pWrMFe_z4VK3PuoJe9nupme35Ujw9iTJ3dDShi9V7nI3fIVSaUd5ZLfQ/me0jTPIgCb0Zr4R8FOD7PLpLUZFfzzDCdVKiQlrBrqU'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rohde-schwarz.com/ca/home_48230.html,Write a Python script that uses Qcodes to connect to a Series Network Analyzer,https://en.wikipedia.org/wiki/Network_analyzer_(electrical),['Network Analyzer'],"A network analyzer is an instrument that measures the network parameters of electrical networks. Today, network analyzers commonly measure s–parameters because reflection and transmission of electrical networks are easy to measure at high frequencies, but there are other network parameter sets such as y-parameters, z-parameters, and h-parameters. Network analyzers are often used to characterize two-port networks such as amplifiers and filters, but they can be used on networks with an arbitrary number of ports.",Series,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/ZNB_bro_en_3608-3278-12_v0301.pdf,,,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rohde_schwarz/ZNB.py,https://qcodes.github.io/Qcodes/drivers_api/RohdeSchwarz.html#qcodes.instrument_drivers.rohde_schwarz.RohdeSchwarzZNBChannel,,,,,"import logging
from functools import partial
from typing import Any, Optional

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument
from qcodes.parameters import (
    ArrayParameter,
    ManualParameter,
    MultiParameter,
    ParamRawDataType,
    create_on_off_val_mapping,
)
from qcodes.utils import deprecate

log = logging.getLogger(__name__)


class FixedFrequencyTraceIQ(MultiParameter):
    """"""
    Parameter for sweep that returns the real (I) and imaginary (Q) parts of
    the VNA response.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        npts: int,
        bandwidth: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""I"", ""Q""),
            labels=(f""{instrument.short_name} I"", f""{instrument.short_name} Q""),
            units=("""", """"),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            setpoint_units=((""s"",), (""s"",)),
            setpoint_labels=((""time"",), (""time"",)),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_cw_sweep(npts, bandwidth)

    def set_cw_sweep(self, npts: int, bandwidth: int) -> None:
        """"""
        Updates config of the software parameter on sweep change. This is
        needed in order to sync the setpoint shape with the returned data
        shape after a change of sweep settings.

        Sets setpoints to the tuple which are hashable for look up.

        Note: This is similar to the set_sweep functions of the frequency
        sweep parameters. The time setpoints here neglect a small VNA
        overhead. The total time including overhead can be queried with the
        sweep_time function of the vna, but since it is not clear where this
        overhead is spend, we keep the x-axis set to 1/bandwidth. The error
        is only apparent in really fast measurements at 1us and 10us but
        depends on the amount of points you take. More points give less
        overhead.
        """"""
        t = tuple(np.linspace(0, npts / bandwidth, num=npts))
        self.setpoints = ((t,), (t,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[np.ndarray, np.ndarray]:
        """"""
        Gets the raw real and imaginary part of the data. If parameter
        `cw_check_sweep_first` is set to `True` then at the cost of a few ms
        overhead checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        return i, q


class FixedFrequencyPointIQ(MultiParameter):
    """"""
    Parameter for sweep that returns the mean of the real (I) and imaginary (Q)
    parts of the VNA response.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode
    Useful for two-tone and other bigger sweeps where you do not want to
    store all individual I-Q values.

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
    """"""

    def __init__(
        self, name: str, instrument: ""RohdeSchwarzZNBChannel"", **kwargs: Any
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""I"", ""Q""),
            labels=(f""{instrument.short_name} I"", f""{instrument.short_name} Q""),
            units=("""", """"),
            setpoints=((), (),),
            shapes=((), (),),
            **kwargs,
        )

    def get_raw(self) -> tuple[float, float]:
        """"""
        Gets the mean of the raw real and imaginary part of the data. If
        parameter `cw_check_sweep_first` is set to `True` then at the cost of a
        few ms overhead checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        return float(np.mean(i)), float(np.mean(q))


class FixedFrequencyPointMagPhase(MultiParameter):
    """"""
    Parameter for sweep that returns the magnitude of mean of the real (I) and
    imaginary (Q) parts of the VNA response and it's phase.
    Requires the use of the sweep type to be set to continuous wave mode.
    See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
    /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
    -> sweep type tab -> CW mode

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
    """"""

    def __init__(
        self, name: str, instrument: ""RohdeSchwarzZNBChannel"", **kwargs: Any
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=("""", ""rad""),
            setpoints=((), (),),
            shapes=((), (),),
            **kwargs,
        )

    def get_raw(self) -> tuple[float, ...]:
        """"""
        Gets the magnitude and phase of the mean of the raw real and imaginary
        part of the data. If the parameter `cw_check_sweep_first` is set to
        `True` for the instrument then at the cost of a few ms overhead
        checks if the vna is setup correctly.
        """"""
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        i, q = self.instrument._get_cw_data()
        s = np.mean(i) + 1j * np.mean(q)
        return float(np.abs(s)), float(np.angle(s))


class FrequencySweepMagPhase(MultiParameter):
    """"""
    Sweep that return magnitude and phase.
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=("""", ""rad""),
            setpoint_units=((""Hz"",), (""Hz"",)),
            setpoint_labels=(
                (f""{instrument.short_name} frequency"",),
                (f""{instrument.short_name} frequency"",),
            ),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        # Needed to update config of the software parameter on sweep change
        # frequency setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        with self.instrument.format.set_to(""Complex""):
            data = self.instrument._get_sweep_data(force_polar=True)
        return abs(data), np.angle(data)



class FrequencySweepDBPhase(MultiParameter):
    """"""
    Sweep that return magnitude in decibel (dB) and phase in radians.
    """"""

    def __init__(
        self,
        name: str,
        instrument: ""RohdeSchwarzZNBChannel"",
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            instrument=instrument,
            names=(""magnitude"", ""phase""),
            labels=(
                f""{instrument.short_name} magnitude"",
                f""{instrument.short_name} phase"",
            ),
            units=(""dB"", ""rad""),
            setpoint_units=((""Hz"",), (""Hz"",)),
            setpoint_labels=(
                (f""{instrument.short_name} frequency"",),
                (f""{instrument.short_name} frequency"",),
            ),
            setpoint_names=(
                (f""{instrument.short_name}_frequency"",),
                (f""{instrument.short_name}_frequency"",),
            ),
            shapes=((npts,), (npts,),),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        # Needed to update config of the software parameter on sweep change
        # frequency setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = ((f,), (f,))
        self.shapes = ((npts,), (npts,))

    def get_raw(self) -> tuple[ParamRawDataType, ...]:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        with self.instrument.format.set_to(""Complex""):
            data = self.instrument._get_sweep_data(force_polar=True)
        return 20*np.log10(np.abs(data)), np.angle(data)


class FrequencySweep(ArrayParameter):
    """"""
    Hardware controlled parameter class for Rohde Schwarz ZNB trace.

    Instrument returns an array of transmission or reflection data depending
    on the active measurement.

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
        start: starting frequency of sweep
        stop: ending frequency of sweep
        npts: number of points in frequency sweep

    Methods:
          get(): executes a sweep and returns magnitude and phase arrays

    """"""

    def __init__(
        self,
        name: str,
        instrument: Instrument,
        start: float,
        stop: float,
        npts: int,
        channel: int,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            shape=(npts,),
            instrument=instrument,
            unit=""dB"",
            label=f""{instrument.short_name} magnitude"",
            setpoint_units=(""Hz"",),
            setpoint_labels=(f""{instrument.short_name} frequency"",),
            setpoint_names=(f""{instrument.short_name}_frequency"",),
            **kwargs,
        )
        self.set_sweep(start, stop, npts)
        self._channel = channel

    def set_sweep(self, start: float, stop: float, npts: int) -> None:
        """"""
        sets the shapes and setpoint arrays of the parameter to
        correspond with the sweep

        Args:
            start: Starting frequency of the sweep
            stop: Stopping frequency of the sweep
            npts: Number of points in the sweep

        """"""
        # Needed to update config of the software parameter on sweep change
        # freq setpoints tuple as needs to be hashable for look up.
        f = tuple(np.linspace(int(start), int(stop), num=npts))
        self.setpoints = (f,)
        self.shape = (npts,)

    def get_raw(self) -> ParamRawDataType:
        assert isinstance(self.instrument, RohdeSchwarzZNBChannel)
        return self.instrument._get_sweep_data()


class RohdeSchwarzZNBChannel(InstrumentChannel):
    def __init__(
        self,
        parent: ""ZNB"",
        name: str,
        channel: int,
        vna_parameter: Optional[str] = None,
        existing_trace_to_bind_to: Optional[str] = None,
    ) -> None:
        """"""
        Args:
            parent: Instrument that this channel is bound to.
            name: Name to use for this channel.
            channel: channel on the VNA to use
            vna_parameter: Name of parameter on the vna that this should
                measure such as S12. If left empty this will fall back to
                `name`.
            existing_trace_to_bind_to: Name of an existing trace on the VNA.
                If supplied try to bind to an existing trace with this name
                rather than creating a new trace.
        """"""
        n = channel
        self._instrument_channel = channel

        if vna_parameter is None:
            vna_parameter = name
        self._vna_parameter = vna_parameter
        super().__init__(parent, name)

        if existing_trace_to_bind_to is None:
            self._tracename = f""Trc{channel}""
        else:
            traces = self._parent.ask(""CONFigure:TRACe:CATalog?"")
            if existing_trace_to_bind_to not in traces:
                raise RuntimeError(
                    f""Trying to bind to""
                    f"" {existing_trace_to_bind_to} ""
                    f""which is not in {traces}""
                )
            self._tracename = existing_trace_to_bind_to

        # map hardware channel to measurement
        # hardware channels are mapped one to one to QCoDeS channels
        # we are not using sub traces within channels.
        if existing_trace_to_bind_to is None:
            self.write(
                f""CALC{self._instrument_channel}:PAR:SDEF""
                f"" '{self._tracename}', '{self._vna_parameter}'""
            )

        # Source power is dependent on model, but not well documented.
        # Here we assume -60 dBm for ZNB20, the others are set,
        # due to lack of knowledge, to -80 dBm as of before the edit.
        full_modelname = self._parent.get_idn()[""model""]
        if full_modelname is not None:
            model = full_modelname.split(""-"")[0]
        else:
            raise RuntimeError(""Could not determine ZNB model"")
        self._model_min_source_power = {
            ""ZNB4"": -80,
            ""ZNB8"": -80,
            ""ZNB20"": -60,
            ""ZNB40"": -60,
        }
        if model not in self._model_min_source_power.keys():
            raise RuntimeError(f""Unsupported ZNB model: {model}"")
        self._min_source_power: float
        self._min_source_power = self._model_min_source_power[model]

        self.add_parameter(
            name=""vna_parameter"",
            label=""VNA parameter"",
            get_cmd=f""CALC{self._instrument_channel}:PAR:MEAS? ""
                    f""'{self._tracename}'"",
            get_parser=self._strip,
        )
        self.add_parameter(
            name=""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=f""SOUR{n}:POW?"",
            set_cmd=f""SOUR{n}:POW {{:.4f}}"",
            get_parser=float,
            vals=vals.Numbers(self._min_source_power, 25),
        )
        self.add_parameter(
            name=""bandwidth"",
            label=""Bandwidth"",
            unit=""Hz"",
            get_cmd=f""SENS{n}:BAND?"",
            set_cmd=self._set_bandwidth,
            get_parser=int,
            vals=vals.Enum(
                *np.append(10 ** 6,
                           np.kron([1, 1.5, 2, 3, 5, 7], 10 ** np.arange(6)))
            ),
            docstring=""Measurement bandwidth of the IF filter. ""
            ""The inverse of this sets the integration ""
            ""time per point. ""
            ""There is an 'increased bandwidth option' ""
            ""(p. 4 of manual) that does not get taken ""
            ""into account here."",
        )
        self.add_parameter(
            name=""avg"",
            label=""Averages"",
            unit="""",
            get_cmd=f""SENS{n}:AVER:COUN?"",
            set_cmd=f""SENS{n}:AVER:COUN {{:.4f}}"",
            get_parser=int,
            vals=vals.Ints(1, 5000),
        )
        self.add_parameter(
            name=""start"",
            get_cmd=f""SENS{n}:FREQ:START?"",
            set_cmd=self._set_start,
            get_parser=float,
            vals=vals.Numbers(self._parent._min_freq,
                              self._parent._max_freq - 10),
        )
        self.add_parameter(
            name=""stop"",
            get_cmd=f""SENS{n}:FREQ:STOP?"",
            set_cmd=self._set_stop,
            get_parser=float,
            vals=vals.Numbers(self._parent._min_freq + 1,
                              self._parent._max_freq),
        )
        self.add_parameter(
            name=""center"",
            get_cmd=f""SENS{n}:FREQ:CENT?"",
            set_cmd=self._set_center,
            get_parser=float,
            vals=vals.Numbers(
                self._parent._min_freq + 0.5, self._parent._max_freq - 10
            ),
        )
        self.add_parameter(
            name=""span"",
            get_cmd=f""SENS{n}:FREQ:SPAN?"",
            set_cmd=self._set_span,
            get_parser=float,
            vals=vals.Numbers(1,
                              self._parent._max_freq - self._parent._min_freq),
        )
        self.add_parameter(
            name=""npts"",
            get_cmd=f""SENS{n}:SWE:POIN?"",
            set_cmd=self._set_npts,
            get_parser=int,
        )
        self.add_parameter(
            name=""status"",
            get_cmd=f""CONF:CHAN{n}:MEAS?"",
            set_cmd=f""CONF:CHAN{n}:MEAS {{}}"",
            get_parser=int,
        )
        self.add_parameter(
            name=""format"",
            get_cmd=partial(self._get_format, tracename=self._tracename),
            set_cmd=self._set_format,
            val_mapping={
                ""dB"": ""MLOG\n"",
                ""Linear Magnitude"": ""MLIN\n"",
                ""Phase"": ""PHAS\n"",
                ""Unwr Phase"": ""UPH\n"",
                ""Polar"": ""POL\n"",
                ""Smith"": ""SMIT\n"",
                ""Inverse Smith"": ""ISM\n"",
                ""SWR"": ""SWR\n"",
                ""Real"": ""REAL\n"",
                ""Imaginary"": ""IMAG\n"",
                ""Delay"": ""GDEL\n"",
                ""Complex"": ""COMP\n"",
            },
        )

        self.add_parameter(
            name=""trace_mag_phase"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweepMagPhase,
        )

        self.add_parameter(
            name=""trace_db_phase"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweepDBPhase,
        )
        self.add_parameter(
            name=""trace"",
            start=self.start(),
            stop=self.stop(),
            npts=self.npts(),
            channel=n,
            parameter_class=FrequencySweep,
        )
        self.add_parameter(
            name=""electrical_delay"",
            label=""Electrical delay"",
            get_cmd=f""SENS{n}:CORR:EDEL2:TIME?"",
            set_cmd=f""SENS{n}:CORR:EDEL2:TIME {{}}"",
            get_parser=float,
            unit=""s"",
        )
        self.add_parameter(
            name=""sweep_time"",
            label=""Sweep time"",
            get_cmd=f""SENS{n}:SWE:TIME?"",
            get_parser=float,
            unit=""s"",
        )
        self.add_parameter(
            name=""sweep_type"",
            get_cmd=f""SENS{n}:SWE:TYPE?"",
            set_cmd=self._set_sweep_type,
            val_mapping={
                ""Linear"": ""LIN\n"",
                ""Logarithmic"": ""LOG\n"",
                ""Power"": ""POW\n"",
                ""CW_Time"": ""CW\n"",
                ""CW_Point"": ""POIN\n"",
                ""Segmented"": ""SEGM\n"",
            },
            docstring=""The sweep_type parameter is used to set ""
            ""the type of measurement sweeps. It ""
            ""allows switching the default linear ""
            ""VNA sweep type to other types. Note that ""
            ""at the moment only the linear and ""
            ""CW_Point modes have supporting ""
            ""measurement parameters."",
        )
        self.add_parameter(
            name=""cw_frequency"",
            get_cmd=f""SENS{n}:FREQ:CW?"",
            set_cmd=self._set_cw_frequency,
            get_parser=float,
            vals=vals.Numbers(
                self._parent._min_freq + 0.5, self._parent._max_freq - 10
            ),
            docstring=""Parameter for setting frequency and ""
            ""querying for it when VNA sweep type is ""
            ""set to CW_Point mode."",
        )

        self.add_parameter(
            ""cw_check_sweep_first"",
            parameter_class=ManualParameter,
            initial_value=True,
            vals=vals.Bool(),
            docstring=""Parameter that enables a few commands ""
            ""which are called before each get in ""
            ""continuous wave mode checking whether ""
            ""the vna is setup correctly. Is recommended ""
            ""to be turned, but can be turned off if ""
            ""one wants to minimize overhead in fast ""
            ""measurements. "",
        )

        self.add_parameter(
            name=""trace_fixed_frequency"",
            npts=self.npts(),
            bandwidth=self.bandwidth(),
            parameter_class=FixedFrequencyTraceIQ,
        )
        self.add_parameter(
            name=""point_fixed_frequency"", parameter_class=FixedFrequencyPointIQ
        )
        self.add_parameter(
            name=""point_fixed_frequency_mag_phase"",
            parameter_class=FixedFrequencyPointMagPhase,
        )
        self.add_parameter(
            name=""averaging_enabled"",
            initial_value=False,
            get_cmd=None,
            set_cmd=self._enable_averaging,
            vals=vals.Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
        )
        self.add_parameter(
            name=""auto_sweep_time_enabled"",
            initial_value=False,
            get_cmd=None,
            set_cmd=self._enable_auto_sweep_time,
            vals=vals.Bool(),
            val_mapping=create_on_off_val_mapping(on_val=""ON"", off_val=""OFF""),
            docstring=""When enabled, the (minimum) sweep time is ""
            ""calculated internally using the other channel settings ""
            ""and zero delay"",
        )

        self.add_function(
            ""set_electrical_delay_auto"", call_cmd=f""SENS{n}:CORR:EDEL:AUTO ONCE""
        )
        self.add_function(
            ""autoscale"",
            call_cmd=f""DISPlay:TRACe1:Y:SCALe:AUTO ONCE, {self._tracename}"",
        )

    def _get_format(self, tracename: str) -> str:
        n = self._instrument_channel
        self.write(f""CALC{n}:PAR:SEL '{tracename}'"")
        return self.ask(f""CALC{n}:FORM?"")

    def _set_format(self, val: str) -> None:
        unit_mapping = {
            ""MLOG\n"": ""dB"",
            ""MLIN\n"": """",
            ""PHAS\n"": ""rad"",
            ""UPH\n"": ""rad"",
            ""POL\n"": """",
            ""SMIT\n"": """",
            ""ISM\n"": """",
            ""SWR\n"": ""U"",
            ""REAL\n"": ""U"",
            ""IMAG\n"": ""U"",
            ""GDEL\n"": ""S"",
            ""COMP\n"": """",
        }
        label_mapping = {
            ""MLOG\n"": ""Magnitude"",
            ""MLIN\n"": ""Magnitude"",
            ""PHAS\n"": ""Phase"",
            ""UPH\n"": ""Unwrapped phase"",
            ""POL\n"": ""Complex Magnitude"",
            ""SMIT\n"": ""Complex Magnitude"",
            ""ISM\n"": ""Complex Magnitude"",
            ""SWR\n"": ""Standing Wave Ratio"",
            ""REAL\n"": ""Real Magnitude"",
            ""IMAG\n"": ""Imaginary Magnitude"",
            ""GDEL\n"": ""Delay"",
            ""COMP\n"": ""Complex Magnitude"",
        }
        channel = self._instrument_channel
        self.write(f""CALC{channel}:PAR:SEL '{self._tracename}'"")
        self.write(f""CALC{channel}:FORM {val}"")
        self.trace.unit = unit_mapping[val]
        self.trace.label = f""{self.short_name} {label_mapping[val]}""

    @staticmethod
    def _strip(var: str) -> str:
        """"""Strip newline and quotes from instrument reply.""""""
        return var.rstrip()[1:-1]

    def _set_start(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:START {val:.7f}"")
        stop = self.stop()
        if val >= stop:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        # we get start as the vna may not be able to set it to the
        # exact value provided.
        start = self.start()
        if abs(val - start) >= 1:
            log.warning(
                ""Could not set start to {} setting it to ""
                ""{}"".format(val, start)
            )
        self.update_lin_traces()

    def _set_stop(self, val: float) -> None:
        channel = self._instrument_channel
        start = self.start()
        if val <= start:
            raise ValueError(""Stop frequency must be larger than start ""
                             ""frequency."")
        self.write(f""SENS{channel}:FREQ:STOP {val:.7f}"")
        # We get stop as the vna may not be able to set it to the
        # exact value provided.
        stop = self.stop()
        if abs(val - stop) >= 1:
            log.warning(
                ""Could not set stop to {} setting it to ""
                ""{}"".format(val, stop)
            )
        self.update_lin_traces()

    def _set_npts(self, val: int) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:POIN {val:.7f}"")
        if self.sweep_type().startswith(""CW""):
            self.update_cw_traces()
        else:
            self.update_lin_traces()

    def _set_bandwidth(self, val: int) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:BAND {val:.4f}"")
        self.update_cw_traces()

    def _set_span(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:SPAN {val:.7f}"")
        self.update_lin_traces()

    def _set_center(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:CENT {val:.7f}"")
        self.update_lin_traces()

    def _set_sweep_type(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:TYPE {val}"")

    def _set_cw_frequency(self, val: float) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:FREQ:CW {val:.7f}"")

    def _enable_averaging(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:AVER:STAT {val}"")

    def _enable_auto_sweep_time(self, val: str) -> None:
        channel = self._instrument_channel
        self.write(f""SENS{channel}:SWE:TIME:AUTO {val}"")

    @deprecate(reason=""the method has been renamed"",
               alternative=""update_lin_traces"")
    def update_traces(self) -> None:
        """""" updates start, stop and npts of all trace parameters""""""
        self.update_lin_traces()

    def update_lin_traces(self) -> None:
        """"""
        Updates start, stop and npts of all trace parameters
        so that the x-coordinates are updated for the sweep.
        """"""
        start = self.start()
        stop = self.stop()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, (FrequencySweep, FrequencySweepMagPhase, FrequencySweepDBPhase)):
                try:
                    parameter.set_sweep(start, stop, npts)
                except AttributeError:
                    pass

    def update_cw_traces(self) -> None:
        """"""
        Updates the bandwidth and npts of all fixed frequency (CW) traces.
        """"""
        bandwidth = self.bandwidth()
        npts = self.npts()
        for _, parameter in self.parameters.items():
            if isinstance(parameter, FixedFrequencyTraceIQ):
                try:
                    parameter.set_cw_sweep(npts, bandwidth)
                except AttributeError:
                    pass
        self.sweep_time()

    def _get_sweep_data(self, force_polar: bool = False) -> np.ndarray:

        if not self._parent.rf_power():
            log.warning(""RF output is off when getting sweep data"")
        # It is possible that the instrument and QCoDeS disagree about
        # which parameter is measured on this channel.
        instrument_parameter = self.vna_parameter()
        if instrument_parameter != self._vna_parameter:
            raise RuntimeError(
                ""Invalid parameter. Tried to measure ""
                f""{self._vna_parameter} ""
                f""got {instrument_parameter}""
            )
        self.averaging_enabled(True)
        self.write(f""SENS{self._instrument_channel}:AVER:CLE"")

        # preserve original state of the znb
        with self.status.set_to(1):
            self.root_instrument.cont_meas_off()
            try:
                # if force polar is set, the SDAT data format will be used.
                # Here the data will be transferred as a complex number
                # independent of the set format in the instrument.
                if force_polar:
                    data_format_command = ""SDAT""
                else:
                    data_format_command = ""FDAT""

                with self.root_instrument.timeout.set_to(self._get_timeout()):
                    # instrument averages over its last 'avg' number of sweeps
                    # need to ensure averaged result is returned
                    for _ in range(self.avg()):
                        self.write(f""INIT{self._instrument_channel}:IMM; *WAI"")
                    self.write(
                        f""CALC{self._instrument_channel}:PAR:SEL ""
                        f""'{self._tracename}'""
                    )
                    data_str = self.ask(
                        f""CALC{self._instrument_channel}:DATA?""
                        f"" {data_format_command}""
                    )
                data = np.array(data_str.rstrip().split("","")).astype(""float64"")
                if self.format() in [""Polar"",
                                     ""Complex"",
                                     ""Smith"",
                                     ""Inverse Smith""]:
                    data = data[0::2] + 1j * data[1::2]
            finally:
                self.root_instrument.cont_meas_on()
        return data

    def setup_cw_sweep(self) -> None:
        """"""
        This method sets the VNA to CW mode. CW Mode sweeps are performed at
        fixed frequency and allow to perform measurements versus time instead
        of versus frequency.
        See (https://www.rohde-schwarz.com/webhelp/ZNB_ZNBT_HTML_UserManual_en
        /ZNB_ZNBT_HTML_UserManual_en.htm) under GUI reference -> sweep softtool
        -> sweep type tab -> CW mode
        """"""

        # set the channel type to single point msmt
        self.sweep_type(""CW_Point"")
        # turn off average on the VNA since we want single point sweeps.
        self.averaging_enabled(False)
        # This format is required for getting both real and imaginary parts.
        self.format(""Complex"")
        # Set the sweep time to auto such that it sets the delay to zero
        # between each point (e.g msmt speed is optimized). Note that if one
        # would like to do a time sweep with time > npts/bandwidth, this is
        # where the delay would be set, but in general we want to measure as
        # fast as possible without artificial delays.
        self.auto_sweep_time_enabled(True)
        # Set cont measurement off here so we don't have to send that command
        # while measuring later.
        self.root_instrument.cont_meas_off()

    def setup_lin_sweep(self) -> None:
        """"""
        Setup the instrument into linear sweep mode.
        """"""
        self.sweep_type(""Linear"")
        self.averaging_enabled(True)
        self.root_instrument.cont_meas_on()

    def _check_cw_sweep(self) -> None:
        """"""
        Checks if all required settings are met to be able to measure in
        CW_point mode. Similar to what is done in get_sweep_data
        """"""
        if self.sweep_type() != ""CW_Point"":
            raise RuntimeError(
                f""Sweep type is not set to continuous wave ""
                f""mode, instead it is: {self.sweep_type()}""
            )

        if not self.root_instrument.rf_power():
            log.warning(""RF output is off when getting sweep data"")

        # It is possible that the instrument and QCoDeS disagree about
        # which parameter is measured on this channel.
        instrument_parameter = self.vna_parameter()
        if instrument_parameter != self._vna_parameter:
            raise RuntimeError(
                ""Invalid parameter. Tried to measure ""
                f""{self._vna_parameter} ""
                f""got {instrument_parameter}""
            )

        # Turn off average on the VNA since we want single point sweeps.
        self.averaging_enabled(False)
        # Set the format to complex.
        self.format(""Complex"")
        # Set cont measurement off.
        self.root_instrument.cont_meas_off()
        # Cache the sweep time so it is up to date when setting timeouts
        self.sweep_time()

    def _get_cw_data(self) -> tuple[np.ndarray, np.ndarray]:
        # Make the checking optional such that we can do super fast sweeps as
        # well, skipping the overhead of the other commands.
        if self.cw_check_sweep_first():
            self._check_cw_sweep()

        with self.status.set_to(1):
            with self.root_instrument.timeout.set_to(self._get_timeout()):
                self.write(f""INIT{self._instrument_channel}:IMM; *WAI"")
                data_str = self.ask(f""CALC{self._instrument_channel}:DATA? ""
                                    f""SDAT"")
            data = np.array(data_str.rstrip().split("","")).astype(""float64"")
            i = data[0::2]
            q = data[1::2]

        return i, q

    def _get_timeout(self) -> float:
        timeout = self.root_instrument.timeout() or float(""+inf"")
        timeout = max(self.sweep_time.cache.get() * 1.5, timeout)
        return timeout


ZNBChannel = RohdeSchwarzZNBChannel


class ZNB(VisaInstrument):
    """"""
    QCoDeS driver for the Rohde & Schwarz ZNB8 and ZNB20
    virtual network analyser. It can probably be extended to ZNB4 and 40
    without too much work.

    Requires FrequencySweep parameter for taking a trace

    Args:
        name: instrument name
        address: Address of instrument probably in format
            'TCPIP0::192.168.15.100::inst0::INSTR'
        init_s_params: Automatically setup channels for all S parameters on the
            VNA.
        reset_channels: If True any channels defined on the VNA at the time
            of initialization are reset and removed.
        **kwargs: passed to base class

    TODO:
    - check initialisation settings and test functions
    """"""

    CHANNEL_CLASS = ZNBChannel

    def __init__(
        self,
        name: str,
        address: str,
        init_s_params: bool = True,
        reset_channels: bool = True,
        **kwargs: Any,
    ) -> None:

        super().__init__(name=name, address=address, **kwargs)

        # TODO(JHN) I could not find a way to get max and min freq from
        # the API, if that is possible replace below with that
        # See page 1025 in the manual. 7.3.15.10 for details of max/min freq
        # no attempt to support ZNB40, not clear without one how the format
        # is due to variants
        fullmodel = self.get_idn()[""model""]
        if fullmodel is not None:
            model = fullmodel.split(""-"")[0]
        else:
            raise RuntimeError(""Could not determine ZNB model"")
        # format seems to be ZNB8-4Port
        m_frequency = {
            ""ZNB4"": (9e3, 4.5e9),
            ""ZNB8"": (9e3, 8.5e9),
            ""ZNB20"": (100e3, 20e9),
            ""ZNB40"": (10e6, 40e9),
        }
        if model not in m_frequency.keys():
            raise RuntimeError(f""Unsupported ZNB model {model}"")
        self._min_freq: float
        self._max_freq: float
        self._min_freq, self._max_freq = m_frequency[model]

        self.add_parameter(name=""num_ports"",
                           get_cmd=""INST:PORT:COUN?"",
                           get_parser=int)
        num_ports = self.num_ports()

        self.add_parameter(
            name=""rf_power"",
            get_cmd=""OUTP1?"",
            set_cmd=""OUTP1 {}"",
            val_mapping={True: ""1\n"", False: ""0\n""},
        )
        self.add_function(""reset"", call_cmd=""*RST"")
        self.add_function(""tooltip_on"", call_cmd=""SYST:ERR:DISP ON"")
        self.add_function(""tooltip_off"", call_cmd=""SYST:ERR:DISP OFF"")
        self.add_function(""cont_meas_on"", call_cmd=""INIT:CONT:ALL ON"")
        self.add_function(""cont_meas_off"", call_cmd=""INIT:CONT:ALL OFF"")
        self.add_function(""update_display_once"", call_cmd=""SYST:DISP:UPD ONCE"")
        self.add_function(""update_display_on"", call_cmd=""SYST:DISP:UPD ON"")
        self.add_function(""update_display_off"", call_cmd=""SYST:DISP:UPD OFF"")
        self.add_function(
            ""display_sij_split"",
            call_cmd=f""DISP:LAY GRID;:DISP:LAY:GRID {num_ports},{num_ports}"",
        )
        self.add_function(
            ""display_single_window"", call_cmd=""DISP:LAY GRID;:DISP:LAY:GRID 1,1""
        )
        self.add_function(
            ""display_dual_window"", call_cmd=""DISP:LAY GRID;:DISP:LAY:GRID 2,1""
        )
        self.add_function(""rf_off"", call_cmd=""OUTP1 OFF"")
        self.add_function(""rf_on"", call_cmd=""OUTP1 ON"")
        if reset_channels:
            self.reset()
            self.clear_channels()
        channels = ChannelList(
            self, ""VNAChannels"", self.CHANNEL_CLASS, snapshotable=True
        )
        self.add_submodule(""channels"", channels)
        if init_s_params:
            for i in range(1, num_ports + 1):
                for j in range(1, num_ports + 1):
                    ch_name = ""S"" + str(i) + str(j)
                    self.add_channel(ch_name)
            self.display_sij_split()
            self.channels.autoscale()

        self.update_display_on()
        if reset_channels:
            self.rf_off()
        self.connect_message()

    def display_grid(self, rows: int, cols: int) -> None:
        """"""
        Display a grid of channels rows by columns.
        """"""
        self.write(f""DISP:LAY GRID;:DISP:LAY:GRID {rows},{cols}"")

    def add_channel(self, channel_name: str, **kwargs: Any) -> None:
        i_channel = len(self.channels) + 1
        channel = self.CHANNEL_CLASS(self, channel_name, i_channel, **kwargs)
        self.channels.append(channel)
        if i_channel == 1:
            self.display_single_window()
        if i_channel == 2:
            self.display_dual_window()
        # shortcut
        setattr(self, channel_name, channel)
        # initialising channel
        self.write(f""SENS{i_channel}:SWE:TYPE LIN"")
        self.write(f""SENS{i_channel}:SWE:TIME:AUTO ON"")
        self.write(f""TRIG{i_channel}:SEQ:SOUR IMM"")
        self.write(f""SENS{i_channel}:AVER:STAT ON"")

    def clear_channels(self) -> None:
        """"""
        Remove all channels from the instrument and channel list and
        unlock the channel list.
        """"""
        self.write(""CALCulate:PARameter:DELete:ALL"")
        for submodule in self.submodules.values():
            if isinstance(submodule, ChannelList):
                submodule.clear()
"
399,5420.0,USA,"N5183B MXG X-Series microwave analog signal generator offers 9 kHz to 40 GHz frequency coverage and near PSG levels of phase noise performance.

",Keysight N 5183 B,278.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT N5183B MXG RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",KEYSIGHT N5183B MXG,https://www.keysight.com/us/en/assets/7018-04096/data-sheets/5991-3131.pdf,"[OrderedDict([('id', 'attCdDa2jS5fYORnA'), ('width', 1600), ('height', 900), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uwYwdFRaJstmlF-Loj5kQA/k0XEkO5B07ODC66VtTryVCnkP_zpXBK75cclqy3KYa4KLvcdYoRhBvWPp7CAAvfzDxmOl81WoR3rl95XTRarHePwD1JHOPw395qS-_Retr4/_ztZeQeta8uJrksL_cowLysnaj1Kr-8QUQM6MDKS_7w'), ('filename', 'N5183B_2_1600x900.png'), ('size', 738895), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/ay4WtQJ45ghUpc5TU3nH6A/NwW2H0VNLdWFnFQZCKO5bW-67vUA3HW5df75zQnP-L4inRyHQ2fef1rgRhv1cS_AjBw5khJZEfrXtymcFtoh5A/11Uxebrsio97A7CdCngd9KlnfYSzcuuRmKdybAB92c0'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/xijCDNrSJXvs5VmBbvofHQ/XDEcYPMBcoO0pH8rPQgYOKuHQBqz94-T1xSbHJSaMHirLgZGpnL_iDAgnkCCq3rJ6YpMyJWW5RQRfWXTi8GzPA/mq8JdCdLjW4gm4SNjaWawNY5sMCbvPz2S-yag5bSS84'), ('width', 910), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Q0ts7yovuN5db0F6XUVqFg/9R1cVze4FLlyBSgZYZ-3RC915MTS3Qq23f_uSJVNw7Hnd21riznLM4owjTESAJwL_hEcv7MhJ7gkBVwqnGiJGg/02TL0B-Ynqn99adKrSIIqsbbnqzKoVgSkXtWOG5C8xk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/product/N5183B/mxg-x-series-microwave-analog-signal-generator-9-khz-40-ghz.html,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/Keysight/Keysight_N5183B.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.KeysightN5183B,43091.0,,,,"from typing import Any

from qcodes.instrument_drivers.Keysight.N51x1 import N51x1


class KeysightN5183B(N51x1):
    def __init__(self, name: str, address: str, **kwargs: Any):
        super().__init__(name, address, min_power=-20, max_power=19, **kwargs)


class N5183B(KeysightN5183B):
    """""" ""
    Alias for backwards compatiblitly

    """"""
"
402,5800.0,USA,"The AWG70000B Series Arbitrary Waveform Generator represents the cutting edge in sample rate, signal fidelity and waveform memory, making it ideal for design, testing and operations of complex components, systems and experiments. With up to sample rate of 50 GS/s and 10-bit vertical resolution, it delivers the industry's best signal stimulus solution for easy generation of ideal, distorted and “real-life” signals.",Tektronix 70002 B,544.0,"Tektronix, Inc., historically widely known as Tek, is an American company best known for manufacturing test and measurement devices such as [oscilloscopes](https://en.wikipedia.org/wiki/Oscilloscope), [logic analyzers](https://en.wikipedia.org/wiki/Logic_analyzer), and video and mobile test protocol equipment.
",Qcodes,Tektronix,"[OrderedDict([('id', 'attzfMoJltngjLsme'), ('width', 2700), ('height', 487), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Yk4fEYS3Xg6iwQd4rYZnTw/7Zkla4HnvscO18VYF5kzAoEARNa8vsmJ4FgDw0s3WFz3XC3uiSo4Y-tNO4a7Lx3Q8T-u01JdeaNcHAgj_-uthw/GGWzcoJGXu4lukgV27iMaGFDO1ZgnMIO_CUGN7O7rJk'), ('filename', 'tek.jfif'), ('size', 88833), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/h2qL_vjOhZaWUJioVUwfTg/yPEjUaHraXCNuyRFhfVmkUF7uYlChxENVTNI3BPd6LecpsmxmwYkair9LwGP4Bt9AoPnMWLJ1cyq6DHBFozQJg/epibu-T1Te-uMYfpIVGa6Ffj9OhMYrhgGsY6iukjioM'), ('width', 200), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/aaQhd1e3804Uwh6S8RvZRQ/l0HPovgnMh9YIQIbwIQf5yfJP5hH70TcJEbi-H_573m_d2tBL45xhI35idMX3ynREnZmtNCV4A8duWfqRIKJaQ/t74DbaTyCi0Q-gIyx_DIKFemz6pS8VLtp2fX2zYbo4U'), ('width', 2700), ('height', 487)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1qbO_LRtT23qEeaQkpiUyQ/FlzQjfMYno5DLhp3eGZzg5pVuL81DX3ypxZ-DrxvpoWwsEoYXWjjBAsvhRY23xXCOnuoQZSsdXjoDtmW5DnuCg/zpmOx-ced12Bk2CsL2EUFpbLLlIotLiDK-7N2KfqbMA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en,Write a Python script that uses Qcodes to connect to a AWG70002B RF Signal Generator,https://en.wikipedia.org/wiki/Signal_generator,['RF Signal Generator'],"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",AWG70002B,https://download.tek.com/datasheet/AWG70000B-Arbitrary-Waveform-Generator-Datasheet-76W614122.pdf,"[OrderedDict([('id', 'attXtl7MGQfCPYnOG'), ('width', 800), ('height', 800), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SQOfIzboGXw8txxP4bd7cg/60wnzsgyolmoEaH-yiSYy1f6IPXK8atzHvJX2vVMOz8dgdCT0-2r9ijmsx2K1GwD74e43EoZbtUzCGDaS_I8Q7Vn7OMUCZZaxMPCYKNdXvoUi74x48UZoazKPQcxqWe8/RCZictriic3QBuyltsLA9aWkYms1C9sZhmfk_mhDzzs'), ('filename', 'tektronix_awg70002a-1.jpg'), ('size', 47210), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/_YAASZKycJiLePaTJX-mUg/R3mMjaZLvyzWVfXzf_IhGvPMZHsiJpb-ZwxBrdkrQ8RpqHw8IrmpkxY6_dmOWcy5LrC0Vel0xthsoW3yn_MeIg/ThFhhUXDMaXKPX6t87NEXyhid_lAvo6xPsiyAj3tFsE'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/VqviJtQAvT9v87r3UlhEgg/Vq76O9ChlrDKuocKXhtqg2RKoZKOjp61u2af9r36cjgq9lw0JTqIkGoiUZQfH6ro6xJDdkLu9usQMC2qXsG82w/_oQehQAiBfS_71zUZ1XpX_GYna3cCsuJa4ZgGaPd9Ds'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/E5dDFaVVr-JpOOULscpN6A/thLWqGxU-bWFlXJVv88D-UntzrBtAoCWth-7G9DSar3yC-gGnAdJtUQnmfS0g9BhpYjzxHGObAormIkwdW6fYw/5gfYt3uZD67irk-CnR2jVUSb4SVvB2qw3ovIWNsRg7s'), ('width', 3000), ('height', 3000)]))]))])]",https://www.tek.com/en/products/arbitrary-waveform-generators/awg70000,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/tektronix/AWG70000A.py,https://qcodes.github.io/Qcodes/drivers_api/Tektronix.html#qcodes.instrument_drivers.tektronix.TektronixAWG70002B,122000.0,,,,"from __future__ import annotations

import datetime as dt
import io
import logging
import struct
import time
import xml.etree.ElementTree as ET
import zipfile as zf
from collections.abc import Mapping, Sequence
from functools import partial
from typing import Any

import numpy as np
from broadbean.sequence import InvalidForgedSequenceError, fs_schema

from qcodes import validators as vals
from qcodes.instrument import ChannelList, Instrument, InstrumentChannel, VisaInstrument

log = logging.getLogger(__name__)

##################################################
#
# SMALL HELPER FUNCTIONS
#


def _parse_string_response(input_str: str) -> str:
    """"""
    Remove quotation marks from string and return 'N/A'
    if the input is empty
    """"""
    output = input_str.replace('""', '')
    output = output if output else 'N/A'

    return output


##################################################
#
# MODEL DEPENDENT SETTINGS
#
# TODO: it seems that a lot of settings differ between models
# perhaps these dicts should be merged to one

_fg_path_val_map = {'5208': {'DC High BW': ""DCHB"",
                             'DC High Voltage': ""DCHV"",
                             'AC Direct': ""ACD""},
                    '70001A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002A': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70001B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'},
                    '70002B': {'direct': 'DIR',
                               'DCamplified': 'DCAM',
                               'AC': 'AC'}}

# number of markers per channel
_num_of_markers_map = {'5208': 4,
                       '70001A': 2,
                       '70002A': 2,
                       '70001B': 2,
                       '70002B': 2}

# channel resolution
_chan_resolutions = {'5208': [12, 13, 14, 15, 16],
                     '70001A': [8, 9, 10],
                     '70002A': [8, 9, 10],
                     '70001B': [8, 9, 10],
                     '70002B': [8, 9, 10]}

# channel resolution docstrings
_chan_resolution_docstrings = {'5208': ""12 bit resolution allows for four ""
                                       ""markers, 13 bit resolution ""
                                       ""allows for three, etc. with 16 bit ""
                                       ""allowing for ZERO markers"",
                               '70001A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002A': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70001B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers "",
                               '70002B': ""8 bit resolution allows for two ""
                                         ""markers, 9 bit resolution ""
                                         ""allows for one, and 10 bit ""
                                         ""does NOT allow for markers ""}

# channel amplitudes
_chan_amps = {'70001A': 0.5,
              '70002A': 0.5,
              '70001B': 0.5,
              '70002B': 0.5,
              '5208': 1.5}

# marker ranges
_marker_high = {'70001A': (-1.4, 1.4),
                '70002A': (-1.4, 1.4),
                '70001B': (-1.4, 1.4),
                '70002B': (-1.4, 1.4),
                '5208': (-0.5, 1.75)}
_marker_low = {'70001A': (-1.4, 1.4),
               '70002A': (-1.4, 1.4),
               '70001B': (-1.4, 1.4),
               '70002B': (-1.4, 1.4),
               '5208': (-0.3, 1.55)}


class SRValidator(vals.Validator[float]):
    """"""
    Validator to validate the AWG clock sample rate
    """"""

    def __init__(self, awg: AWG70000A) -> None:
        """"""
        Args:
            awg: The parent instrument instance. We need this since sample
                rate validation depends on many clock settings
        """"""
        self.awg = awg
        if self.awg.model in ['70001A', '70001B']:
            self._internal_validator = vals.Numbers(1.49e3, 50e9)
            self._freq_multiplier = 4
        elif self.awg.model in ['70002A', '70002B']:
            self._internal_validator = vals.Numbers(1.49e3, 25e9)
            self._freq_multiplier = 2
        elif self.awg.model == '5208':
            self._internal_validator = vals.Numbers(1.49e3, 2.5e9)
        # no other models are possible, since the __init__ of
        # the AWG70000A raises an error if anything else is given

    def validate(self, value: float, context: str='') -> None:
        if 'Internal' in self.awg.clock_source():
            self._internal_validator.validate(value)
        else:
            ext_freq = self.awg.clock_external_frequency()
            # TODO: I'm not sure what the minimal allowed sample rate is
            # in this case
            validator = vals.Numbers(1.49e3, self._freq_multiplier*ext_freq)
            validator.validate(value)


class Tektronix70000AWGChannel(InstrumentChannel):
    """"""
    Class to hold a channel of the AWG.
    """"""

    def __init__(self,  parent: Instrument, name: str, channel: int) -> None:
        """"""
        Args:
            parent: The Instrument instance to which the channel is
                to be attached.
            name: The name used in the DataSet
            channel: The channel number, either 1 or 2.
        """"""

        super().__init__(parent, name)

        self.channel = channel

        num_channels = self.root_instrument.num_channels
        self.model = self.root_instrument.model

        fg = 'function generator'

        if channel not in list(range(1, num_channels+1)):
            raise ValueError('Illegal channel value.')

        self.add_parameter('state',
                           label=f'Channel {channel} state',
                           get_cmd=f'OUTPut{channel}:STATe?',
                           set_cmd=f'OUTPut{channel}:STATe {{}}',
                           vals=vals.Ints(0, 1),
                           get_parser=int)

        ##################################################
        # FGEN PARAMETERS

        # TODO: Setting high and low will change this parameter's value
        self.add_parameter('fgen_amplitude',
                           label=f'Channel {channel} {fg} amplitude',
                           get_cmd=f'FGEN:CHANnel{channel}:AMPLitude?',
                           set_cmd=f'FGEN:CHANnel{channel}:AMPLitude {{}}',
                           unit='V',
                           vals=vals.Numbers(0, _chan_amps[self.model]),
                           get_parser=float)

        self.add_parameter('fgen_offset',
                           label=f'Channel {channel} {fg} offset',
                           get_cmd=f'FGEN:CHANnel{channel}:OFFSet?',
                           set_cmd=f'FGEN:CHANnel{channel}:OFFSet {{}}',
                           unit='V',
                           vals=vals.Numbers(0, 0.250),  # depends on ampl.
                           get_parser=float)

        self.add_parameter('fgen_frequency',
                           label=f'Channel {channel} {fg} frequency',
                           get_cmd=f'FGEN:CHANnel{channel}:FREQuency?',
                           set_cmd=partial(self._set_fgfreq, channel),
                           unit='Hz',
                           get_parser=float)

        self.add_parameter('fgen_dclevel',
                           label=f'Channel {channel} {fg} DC level',
                           get_cmd=f'FGEN:CHANnel{channel}:DCLevel?',
                           set_cmd=f'FGEN:CHANnel{channel}:DCLevel {{}}',
                           unit='V',
                           vals=vals.Numbers(-0.25, 0.25),
                           get_parser=float)

        self.add_parameter('fgen_signalpath',
                           label=f'Channel {channel} {fg} signal path',
                           set_cmd=f'FGEN:CHANnel{channel}:PATH {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:PATH?',
                           val_mapping=_fg_path_val_map[self.root_instrument.model])

        self.add_parameter('fgen_period',
                           label=f'Channel {channel} {fg} period',
                           get_cmd=f'FGEN:CHANnel{channel}:PERiod?',
                           unit='s',
                           get_parser=float)

        self.add_parameter('fgen_phase',
                           label=f'Channel {channel} {fg} phase',
                           get_cmd=f'FGEN:CHANnel{channel}:PHASe?',
                           set_cmd=f'FGEN:CHANnel{channel}:PHASe {{}}',
                           unit='degrees',
                           vals=vals.Numbers(-180, 180),
                           get_parser=float)

        self.add_parameter('fgen_symmetry',
                           label=f'Channel {channel} {fg} symmetry',
                           set_cmd=f'FGEN:CHANnel{channel}:SYMMetry {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:SYMMetry?',
                           unit='%',
                           vals=vals.Numbers(0, 100),
                           get_parser=float)

        self.add_parameter('fgen_type',
                           label=f'Channel {channel} {fg} type',
                           set_cmd=f'FGEN:CHANnel{channel}:TYPE {{}}',
                           get_cmd=f'FGEN:CHANnel{channel}:TYPE?',
                           val_mapping={'SINE': 'SINE',
                                        'SQUARE': 'SQU',
                                        'TRIANGLE': 'TRI',
                                        'NOISE': 'NOIS',
                                        'DC': 'DC',
                                        'GAUSSIAN': 'GAUSS',
                                        'EXPONENTIALRISE': 'EXPR',
                                        'EXPONENTIALDECAY': 'EXPD',
                                        'NONE': 'NONE'})

        ##################################################
        # AWG PARAMETERS

        # this command internally uses power in dBm
        # the manual claims that this command only works in AC mode
        # (OUTPut[n]:PATH is AC), but I've tested that it does what
        # one would expect in DIR mode.
        self.add_parameter(
            'awg_amplitude',
            label=f'Channel {channel} AWG peak-to-peak amplitude',
            set_cmd=f'SOURCe{channel}:VOLTage {{}}',
            get_cmd=f'SOURce{channel}:VOLTage?',
            unit='V',
            get_parser=float,
            vals=vals.Numbers(0.250, _chan_amps[self.model]))

        self.add_parameter('assigned_asset',
                           label=('Waveform/sequence assigned to '
                                  f' channel {self.channel}'),
                           get_cmd=f""SOURCE{self.channel}:CASSet?"",
                           get_parser=_parse_string_response)

        # markers
        for mrk in range(1, _num_of_markers_map[self.model]+1):

            self.add_parameter(
                f'marker{mrk}_high',
                label=f'Channel {channel} marker {mrk} high level',
                set_cmd=partial(self._set_marker, channel, mrk, True),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:HIGH?',
                unit='V',
                vals=vals.Numbers(*_marker_high[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_low',
                label=f'Channel {channel} marker {mrk} low level',
                set_cmd=partial(self._set_marker, channel, mrk, False),
                get_cmd=f'SOURce{channel}:MARKer{mrk}:VOLTage:LOW?',
                unit='V',
                vals=vals.Numbers(*_marker_low[self.model]),
                get_parser=float)

            self.add_parameter(
                f'marker{mrk}_waitvalue',
                label=f'Channel {channel} marker {mrk} wait state',
                set_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:WVALue:MARKer{mrk}?',
                vals=vals.Enum('FIRST', 'LOW', 'HIGH'))

            self.add_parameter(
                name=f'marker{mrk}_stoppedvalue',
                label=f'Channel {channel} marker {mrk} stopped value',
                set_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk} {{}}',
                get_cmd=f'OUTPut{channel}:SVALue:MARKer{mrk}?',
                vals=vals.Enum('OFF', 'LOW'))

        ##################################################
        # MISC.

        self.add_parameter('resolution',
                           label=f'Channel {channel} bit resolution',
                           get_cmd=f'SOURce{channel}:DAC:RESolution?',
                           set_cmd=f'SOURce{channel}:DAC:RESolution {{}}',
                           vals=vals.Enum(*_chan_resolutions[self.model]),
                           get_parser=int,
                           docstring=_chan_resolution_docstrings[self.model])

    def _set_marker(self, channel: int, marker: int,
                    high: bool, voltage: float) -> None:
        """"""
        Set the marker high/low value and update the low/high value
        """"""
        if high:
            this = 'HIGH'
            other = 'low'
        else:
            this = 'LOW'
            other = 'high'

        self.write(f'SOURce{channel}:MARKer{marker}:VOLTage:{this} {voltage}')
        self.parameters[f'marker{marker}_{other}'].get()

    def _set_fgfreq(self, channel: int, frequency: float) -> None:
        """"""
        Set the function generator frequency
        """"""
        functype = self.fgen_type.get()
        if functype in ['SINE', 'SQUARE']:
            max_freq = 12.5e9
        else:
            max_freq = 6.25e9

        # validate
        if frequency < 1 or frequency > max_freq:
            raise ValueError('Can not set channel {} frequency to {} Hz.'
                             ' Maximum frequency for function type {} is {} '
                             'Hz, minimum is 1 Hz'.format(channel, frequency,
                                                          functype, max_freq))
        else:
            self.root_instrument.write(f'FGEN:CHANnel{channel}:'
                                       f'FREQuency {frequency}')

    def setWaveform(self, name: str) -> None:
        """"""
        Select a waveform from the waveform list to output on this channel

        Args:
            name: The name of the waveform
        """"""
        if name not in self.root_instrument.waveformList:
            raise ValueError('No such waveform in the waveform list')

        self.root_instrument.write(f'SOURce{self.channel}:CASSet:WAVeform ""{name}""')

    def setSequenceTrack(self, seqname: str, tracknr: int) -> None:
        """"""
        Assign a track from a sequence to this channel.

        Args:
            seqname: Name of the sequence in the sequence list
            tracknr: Which track to use (1 or 2)
        """"""

        self.root_instrument.write(f'SOURCE{self.channel}:'
                                   f'CASSet:SEQuence ""{seqname}""'
                                   f', {tracknr}')


AWGChannel = Tektronix70000AWGChannel
""""""
Alias for Tektronix70000AWGChannel for backwards compatibility.
""""""


class AWG70000A(VisaInstrument):
    """"""
    The QCoDeS driver for Tektronix AWG70000A series AWG's.

    The drivers for AWG70001A/AWG70001B and AWG70002A/AWG70002B should be
    subclasses of this general class.
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        num_channels: int,
        timeout: float = 10,
        **kwargs: Any,
    ) -> None:
        """"""
        Args:
            name: The name used internally by QCoDeS in the DataSet
            address: The VISA resource name of the instrument
            timeout: The VISA timeout time (in seconds)
            num_channels: Number of channels on the AWG
        """"""

        self.num_channels = num_channels

        super().__init__(name, address, timeout=timeout, terminator='\n',
                         **kwargs)

        # The 'model' value begins with 'AWG'
        self.model = self.IDN()['model'][3:]

        if self.model not in [""70001A"", ""70002A"", ""70001B"", ""70002B"", ""5208""]:
            raise ValueError(
                f""Unknown model type: {self.model}. Are you using ""
                f""the right driver for your instrument?""
            )

        self.add_parameter('current_directory',
                           label='Current file system directory',
                           set_cmd='MMEMory:CDIRectory ""{}""',
                           get_cmd='MMEMory:CDIRectory?',
                           vals=vals.Strings())

        self.add_parameter('mode',
                           label='Instrument operation mode',
                           set_cmd='INSTrument:MODE {}',
                           get_cmd='INSTrument:MODE?',
                           vals=vals.Enum('AWG', 'FGEN'))

        ##################################################
        # Clock parameters

        self.add_parameter('sample_rate',
                           label='Clock sample rate',
                           set_cmd='CLOCk:SRATe {}',
                           get_cmd='CLOCk:SRATe?',
                           unit='Sa/s',
                           get_parser=float,
                           vals=SRValidator(self))

        self.add_parameter('clock_source',
                           label='Clock source',
                           set_cmd='CLOCk:SOURce {}',
                           get_cmd='CLOCk:SOURce?',
                           val_mapping={'Internal': 'INT',
                                        'Internal, 10 MHZ ref.': 'EFIX',
                                        'Internal, variable ref.': 'EVAR',
                                        'External': 'EXT'})

        self.add_parameter('clock_external_frequency',
                           label='External clock frequency',
                           set_cmd='CLOCk:ECLock:FREQuency {}',
                           get_cmd='CLOCk:ECLock:FREQuency?',
                           get_parser=float,
                           unit='Hz',
                           vals=vals.Numbers(6.25e9, 12.5e9))

        self.add_parameter('run_state',
                           label='Run state',
                           get_cmd='AWGControl:RSTATe?',
                           val_mapping={'Stopped': '0',
                                        'Waiting for trigger': '1',
                                        'Running': '2'})

        add_channel_list = self.num_channels > 2
        # We deem 2 channels too few for a channel list
        if add_channel_list:
            chanlist = ChannelList(
                self, ""Channels"", Tektronix70000AWGChannel, snapshotable=False
            )

        for ch_num in range(1, num_channels+1):
            ch_name = f'ch{ch_num}'
            channel = Tektronix70000AWGChannel(self, ch_name, ch_num)
            self.add_submodule(ch_name, channel)
            if add_channel_list:
                # pyright does not seem to understand
                # that this code can only run iff chanliss is created
                chanlist.append(channel)  # pyright: ignore[reportUnboundVariable]

        if add_channel_list:
            self.add_submodule(
                ""channels"",
                chanlist.to_channel_tuple(),  # pyright: ignore[reportUnboundVariable]
            )

        # Folder on the AWG where to files are uplaoded by default
        self.wfmxFileFolder = ""\\Users\\OEM\\Documents""
        self.seqxFileFolder = ""\\Users\\OEM\\Documents""

        self.current_directory(self.wfmxFileFolder)

        self.connect_message()

    def force_triggerA(self) -> None:
        """"""
        Force a trigger A event
        """"""
        self.write('TRIGger:IMMediate ATRigger')

    def force_triggerB(self) -> None:
        """"""
        Force a trigger B event
        """"""
        self.write('TRIGger:IMMediate BTRigger')

    def wait_for_operation_to_complete(self) -> None:
        """"""
        Waits for the latest issued overlapping command to finish
        """"""
        self.ask('*OPC?')

    def play(self, wait_for_running: bool = True,
             timeout: float = 10) -> None:
        """"""
        Run the AWG/Func. Gen. This command is equivalent to pressing the
        play button on the front panel.

        Args:
            wait_for_running: If True, this command is blocking while the
                instrument is getting ready to play
            timeout: The maximal time to wait for the instrument to play.
                Raises an exception is this time is reached.
        """"""
        self.write('AWGControl:RUN')
        if wait_for_running:
            start_time = time.perf_counter()
            running = False
            while not running:
                time.sleep(0.1)
                running = self.run_state() in ('Running',
                                               'Waiting for trigger')
                waited_for = start_time - time.perf_counter()
                if waited_for > timeout:
                    raise RuntimeError(f'Reached timeout ({timeout} s) '
                                       'while waiting for instrument to play.'
                                       ' Perhaps some waveform or sequence is'
                                       ' corrupt?')

    def stop(self) -> None:
        """"""
        Stop the output of the instrument. This command is equivalent to
        pressing the stop button on the front panel.
        """"""
        self.write('AWGControl:STOP')

    @property
    def sequenceList(self) -> list[str]:
        """"""
        Return the sequence list as a list of strings
        """"""
        # There is no SLISt:LIST command, so we do it slightly differently
        N = int(self.ask(""SLISt:SIZE?""))
        slist = []
        for n in range(1, N+1):
            resp = self.ask(f""SLISt:NAME? {n}"")
            resp = resp.strip()
            resp = resp.replace('""', '')
            slist.append(resp)

        return slist

    @property
    def waveformList(self) -> list[str]:
        """"""
        Return the waveform list as a list of strings
        """"""
        respstr = self.ask(""WLISt:LIST?"")
        respstr = respstr.strip()
        respstr = respstr.replace('""', '')
        resp = respstr.split(',')

        return resp

    def delete_sequence_from_list(self, seqname: str) -> None:
        """"""
        Delete the specified sequence from the sequence list

        Args:
            seqname: The name of the sequence (as it appears in the sequence
                list, not the file name) to delete
        """"""
        self.write(f'SLISt:SEQuence:DELete ""{seqname}""')

    def clearSequenceList(self) -> None:
        """"""
        Clear the sequence list
        """"""
        self.write('SLISt:SEQuence:DELete ALL')

    def clearWaveformList(self) -> None:
        """"""
        Clear the waveform list
        """"""
        self.write('WLISt:WAVeform:DELete ALL')

    @staticmethod
    def makeWFMXFile(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        Compose a WFMX file

        Args:
            data: A numpy array holding the data. Markers can be included.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.

        Returns:
            The binary .wfmx file, ready to be sent to the instrument.
        """"""

        shape = np.shape(data)
        if len(shape) == 1:
            N = shape[0]
            markers_included = False
        elif len(shape) in [2, 3, 4]:
            N = shape[1]
            markers_included = True
        else:
            raise ValueError('Input data has too many dimensions!')

        wfmx_hdr_str = AWG70000A._makeWFMXFileHeader(num_samples=N,
                                                     markers_included=markers_included)
        wfmx_hdr = bytes(wfmx_hdr_str, 'ascii')
        wfmx_data = AWG70000A._makeWFMXFileBinaryData(data, amplitude)

        wfmx = wfmx_hdr

        wfmx += wfmx_data

        return wfmx

    def sendSEQXFile(self, seqx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary seqx file to the AWG's memory

        Args:
            seqx: The binary seqx file, preferably the output of
                makeSEQXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.seqxFileFolder

        self._sendBinaryFile(seqx, filename, path)

    def sendWFMXFile(self, wfmx: bytes, filename: str, path: str | None = None) -> None:
        """"""
        Send a binary wfmx file to the AWG's memory

        Args:
            wfmx: The binary wfmx file, preferably the output of
                makeWFMXFile.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved. If
                omitted, seqxFileFolder will be used.
        """"""
        if not path:
            path = self.wfmxFileFolder

        self._sendBinaryFile(wfmx, filename, path)

    def _sendBinaryFile(self, binfile: bytes, filename: str,
                        path: str, overwrite: bool = True) -> None:
        """"""
        Send a binary file to the AWG's mass memory (disk).

        Args:
            binfile: The binary file to send.
            filename: The name of the file on the AWG disk, including the
                extension.
            path: The path to the directory where the file should be saved.
            overwrite: If true, the file on disk gets overwritten
        """"""

        name_str = f'MMEMory:DATA ""{filename}""'.encode('ascii')
        len_file = len(binfile)
        len_str = len(str(len_file))  # No. of digits needed to write length
        size_str = (f',#{len_str}{len_file}').encode('ascii')

        msg = name_str + size_str + binfile

        # IEEE 488.2 limit on a single write is 999,999,999 bytes
        # TODO: If this happens, we should split the file
        if len(msg) > 1e9-1:
            raise ValueError('File too large to transfer')

        self.current_directory(path)

        if overwrite:
            self.log.debug(f'Pre-deleting file {filename} at {path}')
            self.visa_handle.write(f'MMEMory:DELete ""{filename}""')
            # if the file does not exist,
            # an error code -256 is put in the error queue
            resp = self.visa_handle.query(""SYSTem:ERRor:CODE?"")
            self.log.debug(f""Pre-deletion finished with return code {resp}"")

        self.visa_handle.write_raw(msg)

    def loadWFMXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Loads a wfmx from memory into the waveform list
        Only loading from the C: drive is supported

        Args:
            filename: Name of the file (with extension)
            path: Path to load from. If omitted, the default path
                (self.wfmxFileFolder) is used.
        """"""

        if not path:
            path = self.wfmxFileFolder

        pathstr = 'C:' + path + '\\' + filename

        self.write(f'MMEMory:OPEN ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask(""*OPC?"")

    def loadSEQXFile(self, filename: str, path: str | None = None) -> None:
        """"""
        Load a seqx file from instrument disk memory. All sequences in the file
        are loaded into the sequence list.

        Args:
            filename: The name of the sequence file INCLUDING the extension
            path: Path to load from. If omitted, the default path
                (self.seqxFileFolder) is used.
        """"""
        if not path:
            path = self.seqxFileFolder

        pathstr = f'C:{path}\\{filename}'

        self.write(f'MMEMory:OPEN:SASSet:SEQuence ""{pathstr}""')
        # the above command is overlapping, but we want a blocking command
        self.ask('*OPC?')

    @staticmethod
    def _makeWFMXFileHeader(num_samples: int,
                            markers_included: bool) -> str:
        """"""
        Compiles a valid XML header for a .wfmx file
        There might be behaviour we can't capture

        We always use 9 digits for the number of header character
        """"""
        offsetdigits = 9

        if not isinstance(num_samples, int):
            raise ValueError('num_samples must be of type int.')

        if num_samples < 2400:
            raise ValueError('num_samples must be at least 2400.')

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)  # returns (minutes, seconds)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        hdr = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                             'version': '0.1'})
        dsc = ET.SubElement(hdr, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'NumberSamples')
        temp_elem.text = f'{num_samples:d}'
        temp_elem = ET.SubElement(datadesc, 'SamplesType')
        temp_elem.text = 'AWGWaveformSample'
        temp_elem = ET.SubElement(datadesc, 'MarkersIncluded')
        temp_elem.text = (f'{markers_included}').lower()
        temp_elem = ET.SubElement(datadesc, 'NumberFormat')
        temp_elem.text = 'Single'
        temp_elem = ET.SubElement(datadesc, 'Endian')
        temp_elem.text = 'Little'
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr

        # Product specific information
        prodspec = ET.SubElement(datasets, 'ProductSpecific')
        prodspec.set('name', '')
        temp_elem = ET.SubElement(prodspec, 'ReccSamplingRate')
        temp_elem.set('units', 'Hz')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccAmplitude')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'ReccOffset')
        temp_elem.set('units', 'Volts')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '1.0.0917'
        temp_elem = ET.SubElement(prodspec, 'UserNotes')
        temp_elem = ET.SubElement(prodspec, 'OriginalBitDepth')
        temp_elem.text = 'Floating'
        temp_elem = ET.SubElement(prodspec, 'Thumbnail')
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties',
                          attrib={'name': ''})
        temp_elem = ET.SubElement(hdr, 'Setup')

        xmlstr = ET.tostring(hdr, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr

    @staticmethod
    def _makeWFMXFileBinaryData(data: np.ndarray, amplitude: float) -> bytes:
        """"""
        For the binary part.

        Note that currently only zero markers or two markers are supported;
        one-marker data will break.

        Args:
            data: Either a shape (N,) array with only a waveform or
                a shape (M, N) array with waveform, marker1, marker2, marker3, i.e.
                data = np.array([wfm, m1, ...]). The waveform data is assumed
                to be in V.
            amplitude: The peak-to-peak amplitude (V) assumed to be set on the
                channel that will play this waveform. This information is
                needed as the waveform must be rescaled to (-1, 1) where
                -1 will correspond to the channel's min. voltage and 1 to the
                channel's max. voltage.
        """"""

        channel_max = amplitude/2
        channel_min = -amplitude/2

        shape = np.shape(data)

        if len(shape) == 1:
            N = shape[0]
            binary_marker = b''
            wfm = data
        else:
            N = shape[1]
            M = shape[0]
            wfm = data[0, :]
            markers = data[1, :]
            for i in range(1, M-1):
                markers += data[i+1, :] * (2**i)
            markers = markers.astype(int)
            fmt = N*'B'  # endian-ness doesn't matter for one byte
            binary_marker = struct.pack(fmt, *markers)

        if wfm.max() > channel_max or wfm.min() < channel_min:
            log.warning('Waveform exceeds specified channel range.'
                        ' The resulting waveform will be clipped. '
                        'Waveform min.: {} (V), waveform max.: {} (V),'
                        'Channel min.: {} (V), channel max.: {} (V)'
                        ''.format(wfm.min(), wfm.max(), channel_min,
                                  channel_max))

        # the data must be such that channel_max becomes 1 and
        # channel_min becomes -1
        scale = 2/amplitude
        wfm = wfm*scale

        # TODO: Is this a fast method?
        fmt = '<' + N*'f'
        binary_wfm = struct.pack(fmt, *wfm)
        binary_out = binary_wfm + binary_marker

        return binary_out

    @staticmethod
    def make_SEQX_from_forged_sequence(
        seq: Mapping[int, Mapping[Any, Any]],
        amplitudes: Sequence[float],
        seqname: str,
        channel_mapping: Mapping[str | int, int] | None = None,
    ) -> bytes:
        """"""
        Make a .seqx from a forged broadbean sequence.
        Supports subsequences.

        Args:
            seq: The output of broadbean's Sequence.forge()
            amplitudes: A list of the AWG channels' voltage amplitudes.
                The first entry is ch1 etc.
            channel_mapping: A mapping from what the channel is called
                in the broadbean sequence to the integer describing the
                physical channel it should be assigned to.
            seqname: The name that the sequence will have in the AWG's
                sequence list. Used for loading the sequence.

        Returns:
            The binary .seqx file contents. Can be sent directly to the
                instrument or saved on disk.
        """"""

        try:
            fs_schema.validate(seq)
        except Exception as e:
            raise InvalidForgedSequenceError(e)

        chan_list: list[str | int] = []
        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch in seq[pos1]['content'][pos2]['data'].keys():
                    if ch not in chan_list:
                        chan_list.append(ch)

        if channel_mapping is None:
            channel_mapping = {ch: ch_ind+1
                               for ch_ind, ch in enumerate(chan_list)}

        if len(set(chan_list)) != len(amplitudes):
            raise ValueError('Incorrect number of amplitudes provided.')

        if set(chan_list) != set(channel_mapping.keys()):
            raise ValueError(f'Invalid channel_mapping. The sequence has '
                             f'channels {set(chan_list)}, but the '
                             'channel_mapping maps from the channels '
                             f'{set(channel_mapping.keys())}')

        if set(channel_mapping.values()) != set(range(1, 1+len(chan_list))):
            raise ValueError('Invalid channel_mapping. Must map onto '
                             f'{list(range(1, 1+len(chan_list)))}')

        ##########
        # STEP 1:
        # Make all .wfmx files

        wfmx_files: list[bytes] = []
        wfmx_filenames: list[str] = []

        for pos1 in seq.keys():
            for pos2 in seq[pos1]['content'].keys():
                for ch, data in seq[pos1]['content'][pos2]['data'].items():
                    wfm = data['wfm']

                    markerdata = []
                    for mkey in ['m1', 'm2', 'm3', 'm4']:
                        if mkey in data.keys():
                            markerdata.append(data.get(mkey))
                    wfm_data = np.stack((wfm, *markerdata))

                    awgchan = channel_mapping[ch]
                    wfmx = AWG70000A.makeWFMXFile(wfm_data,
                                                  amplitudes[awgchan-1])
                    wfmx_files.append(wfmx)
                    wfmx_filenames.append(f'wfm_{pos1}_{pos2}_{awgchan}')

        ##########
        # STEP 2:
        # Make all subsequence .sml files

        log.debug(f'Waveforms done: {wfmx_filenames}')

        subseqsml_files: list[str] = []
        subseqsml_filenames: list[str] = []

        for pos1 in seq.keys():
            if seq[pos1]['type'] == 'subsequence':

                ss_wfm_names: list[list[str]] = []

                # we need to ""flatten"" all the individual dicts of element
                # sequence options into one dict of lists of sequencing options
                # and we must also provide default values if nothing
                # is specified
                seqings: list[dict[str, int]] = []
                for pos2 in (seq[pos1]['content'].keys()):
                    pos_seqs = seq[pos1]['content'][pos2]['sequencing']
                    pos_seqs['twait'] = pos_seqs.get('twait', 0)
                    pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
                    pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
                    pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
                    pos_seqs['goto'] = pos_seqs.get('goto', 0)
                    seqings.append(pos_seqs)

                    ss_wfm_names.append([n for n in wfmx_filenames
                                         if f'wfm_{pos1}_{pos2}' in n])

                seqing = {k: [d[k] for d in seqings]
                          for k in seqings[0].keys()}

                subseqname = f'subsequence_{pos1}'

                log.debug(f'Subsequence waveform names: {ss_wfm_names}')

                subseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                                   nreps=seqing['nrep'],
                                                   event_jumps=seqing['jump_input'],
                                                   event_jump_to=seqing['jump_target'],
                                                   go_to=seqing['goto'],
                                                   elem_names=ss_wfm_names,
                                                   seqname=subseqname,
                                                   chans=len(channel_mapping))

                subseqsml_files.append(subseqsml)
                subseqsml_filenames.append(f'{subseqname}')

        ##########
        # STEP 3:
        # Make the main .sml file

        asset_names: list[list[str]] = []
        seqings = []
        subseq_positions: list[int] = []
        for pos1 in seq.keys():
            pos_seqs = seq[pos1]['sequencing']

            pos_seqs['twait'] = pos_seqs.get('twait', 0)
            pos_seqs['nrep'] = pos_seqs.get('nrep', 1)
            pos_seqs['jump_input'] = pos_seqs.get('jump_input', 0)
            pos_seqs['jump_target'] = pos_seqs.get('jump_target', 0)
            pos_seqs['goto'] = pos_seqs.get('goto', 0)
            seqings.append(pos_seqs)
            if seq[pos1]['type'] == 'subsequence':
                subseq_positions.append(pos1)
                asset_names.append([sn for sn in subseqsml_filenames
                                    if f'_{pos1}' in sn])
            else:
                asset_names.append([wn for wn in wfmx_filenames
                                    if f'wfm_{pos1}' in wn])
        seqing = {k: [d[k] for d in seqings] for k in seqings[0].keys()}

        log.debug(f'Assets for SML file: {asset_names}')

        mainseqname = seqname
        mainseqsml = AWG70000A._makeSMLFile(trig_waits=seqing['twait'],
                                            nreps=seqing['nrep'],
                                            event_jumps=seqing['jump_input'],
                                            event_jump_to=seqing['jump_target'],
                                            go_to=seqing['goto'],
                                            elem_names=asset_names,
                                            seqname=mainseqname,
                                            chans=len(channel_mapping),
                                            subseq_positions=subseq_positions)

        ##########
        # STEP 4:
        # Build the .seqx file

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(mainseqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        for ssn, ssf in zip(subseqsml_filenames, subseqsml_files):
            zipfile.writestr(f'Sequences/{ssn}.sml', ssf)
        zipfile.writestr(f'Sequences/{mainseqname}.sml', mainseqsml)

        for (name, wfile) in zip(wfmx_filenames, wfmx_files):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def makeSEQXFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        wfms: Sequence[Sequence[np.ndarray]],
        amplitudes: Sequence[float],
        seqname: str,
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> bytes:
        """"""
        Make a full .seqx file (bundle)
        A .seqx file can presumably hold several sequences, but for now
        we support only packing a single sequence

        For a single sequence, a .seqx file is a bundle of two files and
        two folders:

        /Sequences
            sequence.sml

        /Waveforms
            wfm1.wfmx
            wfm2.wfmx
            ...

        setup.xml
        userNotes.txt

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            wfms: numpy arrays describing each waveform plus two markers,
                packed like np.array([wfm, m1, m2]). These numpy arrays
                are then again packed in lists according to:
                [[wfmch1pos1, wfmch1pos2, ...], [wfmch2pos1, ...], ...]
            amplitudes: The peak-to-peak amplitude in V of the channels, i.e.
                a list [ch1_amp, ch2_amp].
            seqname: The name of the sequence. This name will appear in the
                sequence list. Note that all spaces are converted to '_'
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            The binary .seqx file, ready to be sent to the instrument.
        """"""

        # input sanitising to avoid spaces in filenames
        seqname = seqname.replace(' ', '_')

        (chans, elms) = (len(wfms), len(wfms[0]))
        wfm_names = [[f'wfmch{ch}pos{el}' for ch in range(1, chans+1)]
                     for el in range(1, elms+1)]

        # generate wfmx files for the waveforms
        flat_wfmxs = []
        for amplitude, wfm_lst in zip(amplitudes, wfms):
            flat_wfmxs += [AWG70000A.makeWFMXFile(wfm, amplitude)
                           for wfm in wfm_lst]

        # This unfortunately assumes no subsequences
        flat_wfm_names = list(np.reshape(np.array(wfm_names).transpose(),
                                         (chans*elms,)))

        sml_file = AWG70000A._makeSMLFile(trig_waits, nreps,
                                          event_jumps, event_jump_to,
                                          go_to, wfm_names,
                                          seqname,
                                          chans, flags=flags)

        user_file = b''
        setup_file = AWG70000A._makeSetupFile(seqname)

        buffer = io.BytesIO()

        zipfile = zf.ZipFile(buffer, mode='a')
        zipfile.writestr(f'Sequences/{seqname}.sml', sml_file)

        for (name, wfile) in zip(flat_wfm_names, flat_wfmxs):
            zipfile.writestr(f'Waveforms/{name}.wfmx', wfile)

        zipfile.writestr('setup.xml', setup_file)
        zipfile.writestr('userNotes.txt', user_file)
        zipfile.close()

        buffer.seek(0)
        seqx = buffer.getvalue()
        buffer.close()

        return seqx

    @staticmethod
    def _makeSetupFile(sequence: str) -> str:
        """"""
        Make a setup.xml file.

        Args:
            sequence: The name of the main sequence

        Returns:
            The setup file as a string
        """"""
        head = ET.Element('RSAPersist')
        head.set('version', '0.1')
        temp_elem = ET.SubElement(head, 'Application')
        temp_elem.text = 'Pascal'
        temp_elem = ET.SubElement(head, 'MainSequence')
        temp_elem.text = sequence
        prodspec = ET.SubElement(head, 'ProductSpecific')
        prodspec.set('name', 'AWG70002A')
        temp_elem = ET.SubElement(prodspec, 'SerialNumber')
        temp_elem.text = 'B020397'
        temp_elem = ET.SubElement(prodspec, 'SoftwareVersion')
        temp_elem.text = '5.3.0128.0'
        temp_elem = ET.SubElement(prodspec, 'CreatorProperties')
        temp_elem.set('name', '')

        xmlstr = ET.tostring(head, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        return xmlstr

    @staticmethod
    def _makeSMLFile(
        trig_waits: Sequence[int],
        nreps: Sequence[int],
        event_jumps: Sequence[int],
        event_jump_to: Sequence[int],
        go_to: Sequence[int],
        elem_names: Sequence[Sequence[str]],
        seqname: str,
        chans: int,
        subseq_positions: Sequence[int] = (),
        flags: Sequence[Sequence[Sequence[int]]] | None = None,
    ) -> str:
        """"""
        Make an xml file describing a sequence.

        Args:
            trig_waits: Wait for a trigger? If yes, you must specify the
                trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            nreps: No. of repetitions. 0 corresponds to infinite.
            event_jumps: Jump when event triggered? If yes, you must specify
                the trigger input. 0 for off, 1 for 'TrigA', 2 for 'TrigB',
                3 for 'Internal'.
            event_jump_to: Jump target in case of event. 1-indexed,
                0 means next. Must be specified for all elements.
            go_to: Which element to play next. 1-indexed, 0 means next.
            elem_names: The waveforms/subsequences to use. Should be packed
                like:
                [[wfmpos1ch1, wfmpos1ch2, ...],
                 [subseqpos2],
                 [wfmpos3ch1, wfmpos3ch2, ...], ...]
            seqname: The name of the sequence. This name will appear in
                the sequence list of the instrument.
            chans: The number of channels. Can not be inferred in the case
                of a sequence containing only subsequences, so must be provided
                up front.
            subseq_positions: The positions (step numbers) occupied by
                subsequences
            flags: Flags for the auxiliary outputs. 0 for 'No change', 1 for
                'High', 2 for 'Low', 3 for 'Toggle', or 4 for 'Pulse'. 4 flags
                [A, B, C, D] for every channel in every element, packed like:
                [[ch1pos1, ch1pos2, ...], [ch2pos1, ...], ...]
                If omitted, no flags will be set.

        Returns:
            A str containing the file contents, to be saved as an .sml file
        """"""

        offsetdigits = 9

        waitinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        eventinputs = {0: 'None', 1: 'TrigA', 2: 'TrigB', 3: 'Internal'}
        flaginputs = {0:'NoChange', 1:'High', 2:'Low', 3:'Toggle', 4:'Pulse'}

        inputlsts = [trig_waits, nreps, event_jump_to, go_to]
        lstlens = [len(lst) for lst in inputlsts]
        if lstlens.count(lstlens[0]) != len(lstlens):
            raise ValueError('All input lists must have the same length!')

        if lstlens[0] == 0:
            raise ValueError('Received empty sequence option lengths!')

        if lstlens[0] != len(elem_names):
            raise ValueError('Mismatch between number of waveforms and'
                             ' number of sequencing steps.')

        N = lstlens[0]

        # form the timestamp string
        timezone = time.timezone
        tz_m, _ = divmod(timezone, 60)
        tz_h, tz_m = divmod(tz_m, 60)
        if np.sign(tz_h) == -1:
            signstr = '-'
            tz_h *= -1
        else:
            signstr = '+'
        timestr = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]
        timestr += signstr
        timestr += f'{tz_h:02.0f}:{tz_m:02.0f}'

        datafile = ET.Element('DataFile', attrib={'offset': '0'*offsetdigits,
                                                  'version': '0.1'})
        dsc = ET.SubElement(datafile, 'DataSetsCollection')
        dsc.set(""xmlns"", ""http://www.tektronix.com"")
        dsc.set(""xmlns:xsi"", ""http://www.w3.org/2001/XMLSchema-instance"")
        dsc.set(""xsi:schemaLocation"", (r""http://www.tektronix.com file:///"" +
                                       r""C:\Program%20Files\Tektronix\AWG70000"" +
                                       r""\AWG\Schemas\awgSeqDataSets.xsd""))
        datasets = ET.SubElement(dsc, 'DataSets')
        datasets.set('version', '1')
        datasets.set(""xmlns"", ""http://www.tektronix.com"")

        # Description of the data
        datadesc = ET.SubElement(datasets, 'DataDescription')
        temp_elem = ET.SubElement(datadesc, 'SequenceName')
        temp_elem.text = seqname
        temp_elem = ET.SubElement(datadesc, 'Timestamp')
        temp_elem.text = timestr
        temp_elem = ET.SubElement(datadesc, 'JumpTiming')
        temp_elem.text = 'JumpImmed'  # TODO: What does this control?
        temp_elem = ET.SubElement(datadesc, 'RecSampleRate')
        temp_elem.text = 'NaN'
        temp_elem = ET.SubElement(datadesc, 'RepeatFlag')
        temp_elem.text = 'false'
        temp_elem = ET.SubElement(datadesc, 'PatternJumpTable')
        temp_elem.set('Enabled', 'false')
        temp_elem.set('Count', '65536')
        steps = ET.SubElement(datadesc, 'Steps')
        steps.set('StepCount', f'{N:d}')
        steps.set('TrackCount', f'{chans:d}')

        for n in range(1, N+1):
            step = ET.SubElement(steps, 'Step')
            temp_elem = ET.SubElement(step, 'StepNumber')
            temp_elem.text = f'{n:d}'
            # repetitions
            rep = ET.SubElement(step, 'Repeat')
            repcount = ET.SubElement(step, 'RepeatCount')
            if nreps[n-1] == 0:
                rep.text = 'Infinite'
                repcount.text = '1'
            elif nreps[n-1] == 1:
                rep.text = 'Once'
                repcount.text = '1'
            else:
                rep.text = ""RepeatCount""
                repcount.text = f""{nreps[n-1]:d}""
            # trigger wait
            temp_elem = ET.SubElement(step, 'WaitInput')
            temp_elem.text = waitinputs[trig_waits[n-1]]
            # event jump
            temp_elem = ET.SubElement(step, 'EventJumpInput')
            temp_elem.text = eventinputs[event_jumps[n-1]]
            jumpto = ET.SubElement(step, 'EventJumpTo')
            jumpstep = ET.SubElement(step, 'EventJumpToStep')
            if event_jump_to[n-1] == 0:
                jumpto.text = 'Next'
                jumpstep.text = '1'
            else:
                jumpto.text = ""StepIndex""
                jumpstep.text = f""{event_jump_to[n-1]:d}""
            # Go to
            goto = ET.SubElement(step, 'GoTo')
            gotostep = ET.SubElement(step, 'GoToStep')
            if go_to[n-1] == 0:
                goto.text = 'Next'
                gotostep.text = '1'
            else:
                goto.text = ""StepIndex""
                gotostep.text = f""{go_to[n-1]:d}""

            assets = ET.SubElement(step, 'Assets')
            for assetname in elem_names[n-1]:
                asset = ET.SubElement(assets, 'Asset')
                temp_elem = ET.SubElement(asset, 'AssetName')
                temp_elem.text = assetname
                temp_elem = ET.SubElement(asset, 'AssetType')
                if n in subseq_positions:
                    temp_elem.text = 'Sequence'
                else:
                    temp_elem.text = 'Waveform'

            # convert flag settings to strings
            flags_list = ET.SubElement(step, 'Flags')
            for chan in range(chans):
                flagset = ET.SubElement(flags_list, 'FlagSet')
                for flgind, flg in enumerate(['A', 'B', 'C', 'D']):
                    temp_elem = ET.SubElement(flagset, 'Flag')
                    temp_elem.set('name', flg)
                    if flags is None:
                        # no flags were passed to the function
                        temp_elem.text = 'NoChange'
                    else:
                        temp_elem.text = flaginputs[flags[chan][n-1][flgind]]

        temp_elem = ET.SubElement(datasets, 'ProductSpecific')
        temp_elem.set('name', '')
        temp_elem = ET.SubElement(datafile, 'Setup')

        # the tostring() call takes roughly 75% of the total
        # time spent in this function. Can we speed up things?
        # perhaps we should use lxml?
        xmlstr = ET.tostring(datafile, encoding='unicode')
        xmlstr = xmlstr.replace('><', '>\r\n<')

        # As the final step, count the length of the header and write this
        # in the DataFile tag attribute 'offset'

        xmlstr = xmlstr.replace('0'*offsetdigits,
                                '{num:0{pad}d}'.format(num=len(xmlstr),
                                                       pad=offsetdigits))

        return xmlstr
"
404,23.0,"Beijing, China","The DP800 Series Power Supplies combine the ability to source, analyze, and coordinate over time on a powerful platform. The DP800 Series is a family of linear power supplies systems with 1, 2, or 3 outputs and 140 to 200 Watts in total. With one channel isolated users can reconfigure instruments into any number of systems or applications. Built in V, A, and W measurements make power monitoring easy, but additional wave tracking, timing, and analysis features in the advanced ""A"" models means there are even more ways to use the instruments. Digital triggering between instruments also makes it possible to reliably combine and connect supplies together. Intuitive to use for everything from education labs to the R & D bench, the DP800 family of power supplies provide incredible value for any application. Select the value models for best price performance or upgrade to the ""A"" model to improve resolution and add advanced monitoring, triggering, and programming capabilities.",Private,455.0,"RIGOL Technologies, Inc. specializes in development and production of test and measuring equipment and is one of the fastest growing Chinese companies in this sphere.
RIGOL’s line of products includes [digital storage oscilloscopes](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=227), [function/arbitrary waveform generators](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=230), [digital multimeters](https://www.tmatlantic.com/e-store/index.php?SECTION_ID=233), PC-based devices compatible with LXI standard etc.
",Qcodes,Rigol,"[OrderedDict([('id', 'attivRtPF5u9Jt8zc'), ('width', 600), ('height', 400), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dK_mPGZZbeZp5bcFtkzbxg/5lP9IsicLc-53c57pU09lJq8btShrsIP8oUdQD8g-Riyyl7CgjgCuLxljMo3u7mSmIXTKA_1rOHlzYVZ9sSzLxtBldRCizWNkSc1c3VGOCyAsmZ8HP6hOtPBhLsT_DGV/oOwHd5lFYWPNGu0Q17nAm8QwNC1tHLy_fE5qOLj7tSs'), ('filename', 'rigol-technologies-inc-logo-vector.png'), ('size', 2793), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zLg1x4J0supwCaJ83IL-4A/V-NesMLWPnrBKKPErwXZSINLiLFF25aXtZnMo_kMyeFuWjgTj5V5zEjv57r4fGSxq3VyIPN_4rjf69NIqz8Gzw/pZHIjN5-F-C70IjpD1k3NvdeUOvruDC8BQQZecQyYN8'), ('width', 54), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/TtrY8vWkD6dH3FpegMsnZg/VDR5M5gZRQkV2BrFVjDxcbTNXGQhzU42l5WvrjM-ipcjmlF-7Oq-BO3myo_SOVCkT2wiVPQAjmpQh9cV_64hPQ/5dMGpy23APettmB4rgrzyyIGA_a3a69X1naJ8wxXyDA'), ('width', 600), ('height', 400)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/BLGNhQ0TAAvOaix0UZDcpQ/7lmilKMeJr2Ofwuq_NWkkqdKkoUC_-kSB7azAErsuAjnu-0VYL8ejL_P2ioQYZxF9PzGLPVMxaKtkDVN-tY0Sg/juOPtupWPWQ8JaIQ3AdUWz3xKt51fE8OTZzs7jTwlTk'), ('width', 3000), ('height', 3000)]))]))])]",https://www.rigol.com/,Write a Python script that uses Qcodes to connect to a Rigol DP8xx (xx --> Series) Power Supplies,https://en.wikipedia.org/wiki/Power_supply,['Power Supplies'],"A power supply is an electrical device that supplies electric power to an electrical load. The main purpose of a power supply is to convert electric current from a source to the correct voltage, current, and frequency to power the load. As a result, power supplies are sometimes referred to as electric power converters. Some power supplies are separate standalone pieces of equipment, while others are built into the load appliances that they power.",Rigol DP8xx (xx --> Series),https://www.batronix.com/files/Rigol/Labornetzteile/DP800/DP800_-datasheet-2022.pdf,,https://www.rigolna.com/products/dc-power-loads/dp800/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/rigol/private/DP8xx.py,not on docs,,,,,"from collections.abc import Sequence
from typing import Any

from qcodes import validators as vals
from qcodes.instrument import ChannelList, InstrumentChannel, VisaInstrument


class RigolDP8xxChannel(InstrumentChannel):
    def __init__(
        self,
        parent: ""_RigolDP8xx"",
        name: str,
        channel: int,
        ch_range: tuple[float, float],
        ovp_range: tuple[float, float],
        ocp_range: tuple[float, float],
    ):
        super().__init__(parent, name)

        self.vmax = ch_range[0]
        self.imax = ch_range[1]
        self.ovp_range = ovp_range
        self.ocp_range = ocp_range

        select_cmd = f"":INSTrument:NSELect {channel};""

        def strstrip(s: str) -> str:
            return str(s).strip()

        self.add_parameter(""set_voltage"",
                           label='Target voltage output',
                           set_cmd=""{} :SOURce:VOLTage:LEVel:IMMediate:AMPLitude {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :SOURce:VOLTage:LEVel:IMMediate:AMPLitude?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                           vals=vals.Numbers(min(0, self.vmax), max(0, self.vmax))
                          )
        self.add_parameter(""set_current"",
                           label='Target current output',
                           set_cmd=""{} :SOURce:CURRent:LEVel:IMMediate:AMPLitude {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :SOURce:CURRent:LEVel:IMMediate:AMPLitude?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           vals=vals.Numbers(0, self.imax)
                           )
        self.add_parameter('state',
                           label='Output enabled',
                           set_cmd='{} :OUTPut:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :OUTPut:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )
        self.add_parameter('mode',
                           label='Get the output mode',
                           get_cmd=f'{select_cmd} :OUTPut:MODE?',
                           get_parser=strstrip,
                           val_mapping={'ConstantVoltage': 'CV',
                                        'ConstantCurrent': 'CC',
                                        'Unregulated': 'UR'}
                          )
        self.add_parameter(""voltage"",
                           label='Measured voltage',
                           get_cmd=""{} :MEASure:VOLTage:DC?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                          )
        self.add_parameter(""current"",
                           label='Measured current',
                           get_cmd=""{} :MEASure:CURRent:DC?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           )
        self.add_parameter(""power"",
                           label='Measured power',
                           get_cmd=""{} :MEASure:POWer?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='W',
                           )
        self.add_parameter(""ovp_value"",
                           label='Over Voltage Protection value',
                           set_cmd=""{} :VOLTage:PROTection:LEVel {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :VOLTage:PROTection:LEVel?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='V',
                           vals=vals.Numbers(self.ovp_range[0], self.ovp_range[1])
                           )
        self.add_parameter('ovp_state',
                           label='Over Voltage Protection status',
                           set_cmd='{} :VOLTage:PROTection:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :VOLTage:PROTection:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )
        self.add_parameter(""ocp_value"",
                           label='Over Current Protection value',
                           set_cmd=""{} :CURRent:PROTection:LEVel {}"".format(
                               select_cmd, '{}'),
                           get_cmd=""{} :CURRent:PROTection:LEVel?"".format(
                               select_cmd),
                           get_parser=float,
                           unit='A',
                           vals=vals.Numbers(self.ocp_range[0], self.ocp_range[1])
                           )
        self.add_parameter('ocp_state',
                           label='Over Current Protection status',
                           set_cmd='{} :CURRent:PROTection:STATe {}'.format(select_cmd, '{}'),
                           get_cmd=f'{select_cmd} :CURRent:PROTection:STATe?',
                           get_parser=strstrip,
                           vals=vals.OnOff()
                           )


class _RigolDP8xx(VisaInstrument):
    """"""
    This is the general DP8xx Power Supply driver class that implements shared parameters and functionality
    among all similar power supply from Rigole.

    This driver was written to be inherited from by a specific driver (e.g. DP832).
    """"""

    def __init__(
        self,
        name: str,
        address: str,
        channels_ranges: Sequence[tuple[float, float]],
        ovp_ranges: tuple[Sequence[tuple[float, float]], Sequence[tuple[float, float]]],
        ocp_ranges: tuple[Sequence[tuple[float, float]], Sequence[tuple[float, float]]],
        **kwargs: Any,
    ):
        super().__init__(name, address, **kwargs)

        # Check if precision extension has been installed
        opt = self.installed_options()
        if 'DP8-ACCURACY' in opt:
            ovp_ranges_selected = ovp_ranges[1]
            ocp_ranges_selected = ocp_ranges[1]
        else:
            ovp_ranges_selected = ovp_ranges[0]
            ocp_ranges_selected = ocp_ranges[0]

        # channel-specific parameters
        channels = ChannelList(self, ""SupplyChannel"", RigolDP8xxChannel, snapshotable=False)
        for ch_num, channel_range in enumerate(channels_ranges):
            ch_name = f""ch{ch_num + 1}""
            channel = RigolDP8xxChannel(
                self,
                ch_name,
                ch_num + 1,
                channel_range,
                ovp_ranges_selected[ch_num],
                ocp_ranges_selected[ch_num]
            )
            channels.append(channel)
            self.add_submodule(ch_name, channel)
        self.add_submodule(""channels"", channels.to_channel_tuple())

        self.connect_message()

    def installed_options(self) -> list[str]:
        """"""Return the installed options""""""

        opt = self.ask(""*OPT?"")
        optl = opt.strip().split(',')
        optl_clean = [x for x in optl if x != '0']
        return optl_clean
"
415,9000.0,UK,"Bench/System Linear Regulated DC Power Supply Single Output, 15V/5A, USB, RS232, LAN(LXI) and Analogue Interfaces
",AIM TTI PL 155 P,50.0,"TTi (Thurlby Thandar Instruments) is a leading manufacturer of electronic test and measurement instruments. These products are sold throughout the world via carefully selected distributors and agents in each country. We are located in Huntingdon near to the famous university city of Cambridge, within one of the high technology areas of the United Kingdom.
",Qcodes,Aimtti,"[OrderedDict([('id', 'attCgctBcIcV2zscL'), ('width', 302), ('height', 300), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/uA7_3Qco1fv5gXbxmw7f4g/GnywELjvEHRXukHsavvcUKe6bojiNgAWKATJ9gqghedQl2jHuazmUJsfbbLGFS4ZWBM7xa1c9ONTVnqmeijd1eWQUT-hsicm9Gc9Ao-29tQ/ifAYswOdFeXqWOWd1o69qyh08RCRod6QbGMAJpz42jY'), ('filename', 'Aim-TTi-logo-1k.jpg'), ('size', 20042), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/0MHURwB4GlSRQadMO9DzqQ/nouiJNAp7lAZ2CF3fduEs0QAUkFAKp-sKGKwFb_mS-XHN1iI2vFHtL6O0BM4Y_TEY9UMn1Uz54wcAegKrLztWw/BCV2QXMBSFzGm4yh7EOOVANW7Xi65A_4Y5gu4nObPiY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/UJEOFOR0-klv-cf9IGckUw/YZ9azyUbjCG4f890r72TumInPkxvwo1hFqsFsNTzZKEcrQ5wxLNautqiOgmgJGtN9VMMi7PAcA1AVtTHzwOhrA/xFXLhtX5In99V9U7pLQ4LyrZIaijzrX6DLl5aoQA6Og'), ('width', 302), ('height', 300)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/nidP-NqjPheMHWLr9D_pSw/OAvdBAUtb_fzOpJRRMThKv_9PqQX32a04edYsdAAFcum6dHc6OrU8ZG03cTn2zEitpqP0MJ9lPnCKujc3JZtGQ/rqaLmBiMCjJpLhi8K76lt7i6TZIljxnakzczM3_OL9I'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/,Write a Python script that uses Qcodes to connect to a PL155-P Power Supplies,https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,['Power Supplies'],"Bench/System Linear Regulated DC Power Supply with Smart Analog Controls, Single, Dual or Triple Outputs, 48 to 242 watts, with/without Remote Interfaces
",PL155-P,https://resources.aimtti.com/datasheets/AIM-PL+PL-P_series_DC_power_supplies_data_sheet-Iss5.pdf,"[OrderedDict([('id', 'attSmxnTV0u8N4UA6'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Kk_hKDTjdyYyjck0zJkB5Q/g9XS8yTpOJ7XEQsOppFj5AsPW7zyv59rkJAuGx1gVujc0tahzoWEgyD_YnwpWNpuy2lI1Ytipv9ABlQNJVVQUqrysyUJd8k8lEHQbG9EbnY/TjTNxUS3gXj_ro8QDMRdowHgbY8i8JlTPijixfyCgYE'), ('filename', 'PL155P-1000px.jpg'), ('size', 158529), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7NUjIMMYX4G5vJQmOsvcJQ/w6zZvAZH8hjhsdJNSRGSadwevw_-wdoj_vHQpsHn89oT4lTvWrBGSNaZ9lkIfPYJVZVpEn-gR55NK6e0Ql15iw/q4X5sDM5tUEpIzqgQGgC7EmgivV64BgFgz5FAeDHCLY'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/4kGfvJIYg32AfTo8-gGkQA/uLmE0ozesr_5vhaQ-FGJgFc_jGad_sKO46DIKYFqSverf6L2EpHybRWxbKHHzHzluQdrwQ_sQ2Rc0EhdcHC4Vg/gTdYUGcY452xHcI_2ZcHg4HJ-2WSCGSTHH91FWlJL2M'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/LTb8duM2oaTFXZmACYPMxA/4w0Jmn5y2ubUrXs78gIVLqJDrCqboik8XzVEzmYNRDKNooudF_J6Bjkr-_OD0hCR4rnRkyjSSKmIGEy39NR2fQ/Yg1s58RkJwP6ZfslPSU8UKyWzhsDWqx6TiGF3EM_SGE'), ('width', 3000), ('height', 3000)]))]))])]",https://www.aimtti.com/product-category/dc-power-supplies/aim-plseries,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,https://qcodes.github.io/Qcodes/drivers_api/AimTTi.html,700.0,"
",,,
422,5420.0,USA,"The 34411A offers Temperature and Capacitance capabilities, in addition to those measurements you have come to expect, such as DCV, ACV, DCI, ACI, 2-wire and 4-wire Resistance, Frequency, Period, Continuity and Diode Test.",Keysight 34470 A Submodules,275.0,"Keysight Technologies, or Keysight, is an American company that manufactures electronics test and measurement equipment and software
",Qcodes,Keysight,"[OrderedDict([('id', 'attSixem5KGYQVz77'), ('width', 212), ('height', 75), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/CpwBp96kY5dUnguQiqYpww/J9lJkFD16xSDAPvmgv_d56vj9Lqq6ItNUW_5UoMyN-S0Shnh0JOEO8csLebz7Xu4Z8gE07FUhS-nDKuUnQrjlgGl9TDwvdw0ri8xFYWoqJI/u6-p03gBGsvJDX5pDkq8g03E4crw0PcqBr7jJQHqkOI'), ('filename', 'keysight-logo.svg'), ('size', 2285), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/OHgE-tcyvCBxuFqu2T7t_A/az7HG7f0QS1vnZ52VcX5uXPXMyaXWm0aU0XpvVcbL-iaXMyXmXzrSR-B4rc2L0dd-f6o9qeZB5ZLJwyXF5Ddw0s88QIR6eB5yl5YgvaK938/HNFmDeic35zFTM_Qz4ZdgLI6Ram83KauYXm5s4osP2w'), ('width', 102), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/EXCh0xCs_7MHSTx5Zz4CPA/Vm4LQikWqhLq7BQ4diBo6XQAAS5CLk1cfq9-S4yaTSMKcSuykUmlSiBgLAQSc73c_ggpGgo-k66P49Sg6IvYNQsS9xuXJrGvmuhM7B3ygEQ/9HyBiUmvRW0XEd9GhYUpcS4ZSI2K8DRyjI70MXa9kr4'), ('width', 212), ('height', 75)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/RQAo4UuLDVUF9_USADgP3w/dB55bQeyNGnlF3qRJsUAPWsAKtJnjKtA7XkA6scBhm0AkS5S6u_fVInQqEF-cIPNvke9dKGD1bz6c74uEryk4Ez3lO2dlivDqcW_KnVzMQM/vqKwTVltxdBX1CwxjuFTUNpzJ5R2NnBqC3e7aQx3xzA'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/home.html,Write a Python script that uses Qcodes to connect to a KEYSIGHT 34470A Submodules Multimeters,https://en.wikipedia.org/wiki/Multimeter,['Multimeters'],"A multimeter (also known as a volt-ohm-milliammeter, volt-ohmmeter or VOM) is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current, in which case can be used as a voltmeter, ammeter, and ohmmeter. Some feature the measurement of additional properties such as temperature and capacitance.",KEYSIGHT 34470A Submodules,https://www.keysight.com/us/en/assets/7018-03846/data-sheets/5991-1983.pdf,"[OrderedDict([('id', 'attsytGLFo343EuCO'), ('width', 300), ('height', 225), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/SNmqy_MMAcPYpYfkKoaLaw/FnWPllIq35xRq5dnTAiRzEkn6-kMLa8fUGV4pRtvPZCFmZVz7MZHD1Uk5HW42Qyr3L618bquS5d6QcoN8P0Y6srhBEbODv4i0xGXx-D6Rb9cPRiO5DkXwb5u51Kqsb-I/ytfWHWRQVGfM8CtAwR81NFAlsvMqs4RxWWqCda_u8Vc'), ('filename', 'keysight-34470-multimeter.jpg'), ('size', 37141), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/wzPvoe9qdu44Kl14jyLHUg/_iLAq60PopLvstz67AzoppkY8KMs7Pim04C7_yBYlYTCaOr4qY0PCa5a7VIaxmN9tJxA34537G98a9_D5n98Mw/zphA9PUmOws3O3tW6P-WLUDLvs3i-ywPSvLIeiemV_g'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/7YTZwsaLq-5Tu3Btxl0HwA/ri_KZwOF5oXlINtjZqqvYOXu649cBf8cu_njkm65faFmF8o1QfNyFykdUPo9zS4y825e1aYE8RhxZfLDfL8-Og/_if-Eq_HdI3gZ9OFczVT9Gq1t7CvRp3ilF-RZncbwbE'), ('width', 300), ('height', 225)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/1zwECy2WE_Ue5IKJFEDtJg/atNk4-PMIQ8D1b82oDWJB9S-UyoPNFwc7aNl6fsaKHwm3CgV5c2WuH5eCTmXl7MeB9AjiIpbVZriIqlt3RP0zA/1gHnG0yckRyN01oDo-0B5f8ozZuSc7hOlQp4Cih0SvI'), ('width', 3000), ('height', 3000)]))]))])]",https://www.keysight.com/us/en/assets/7018-01326/data-sheets/5989-3738.pdf,https://github.com/QCoDeS/Qcodes/blob/bf68490b3dd0b2dd9d3a5a1da90cdb157c6a9b89/qcodes/instrument_drivers/Keysight/Keysight_34470A_submodules.py,https://qcodes.github.io/Qcodes//drivers_api/Keysight.html#qcodes.instrument_drivers.Keysight.Keysight34470A,1863.0,,,,"from typing import Any

from .private.Keysight_344xxA_submodules import _Keysight_344xxA


class Keysight34470A(_Keysight_344xxA):
    """"""
    This is the qcodes driver for the Keysight 34470A Multimeter
    """"""
    def __init__(self, name: str, address: str, silent: bool = False,
                 **kwargs: Any):
        super().__init__(name, address, silent, **kwargs)


class Keysight_34470A(Keysight34470A):
    """"""
    Alias for backwards compatibility.
    """"""
"
427,3.6,USA,"The Signal Hound USB-SA44B is a Software Defined Receiver (SDR) optimized as a narrow-band real-time RF spectrum analyzer. It is a compact, simple to use, effective troubleshooting tool for the general lab user, engineering students, and ham radio enthusiast.",USB SA 124 B,506.0,"Signal Hound is a manufacturer of RF spectrum analyzers and signal generators.
",Qcodes,Signal Hound,"[OrderedDict([('id', 'attxALdqBv1g4lMjd'), ('width', 545), ('height', 92), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/IMwrsoDBpbKKaSFCUkS3kA/Ysh8GKh00pzAeipRaV-JTQSkM_usZi_Z8Fc7ttHCkP5HwwCHLEJBTx0FiKDf6p2X-ZQLaUfHmI9Hq0LxHYDzEFHibZfvm7nhj6XboIdfEek/YaGFhS1HY1UvxCa5QdVMoecBC1QSviOWs0DG2sbBllM'), ('filename', 'download.png'), ('size', 4801), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/Z8TdC9TJG8JoaFAsAIWGnA/9gJcfgJ1ufgApS-K4oOOhUMNp-CZG5KOvQ3r14uGVob929KBfBFrjvd8-12UeW21Z7mvNhtW7YlQF0o3Nmm-1Q/UhjTvjjaMtDvndbXDbTuDJENx5y5KMbpM24p69w16tA'), ('width', 213), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/bHBwJOoTAdHk3HiMKu9m2w/pvirjK0U4ON2rdv4dF74y-Px9H8YcrDNsXPtzK5HZGHL57qooVl05cnr7BqW1KEU0hi5srn8rq6YsrO2KOCNTA/h0yUwMPP2yYJrcCuRnhJVZrfFlK5mrdpndILf8fmxog'), ('width', 545), ('height', 92)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/3M9-sQu6fiKw4urHlGt1jg/v2xtNIYEchoo03LC0IKYNIZdL0q6TtJF__eschX_x2QF-lVEWtM6GsF6RKVhlC0_qMZaTIfmt5mHqGO3KwGzyw/fiHYa63r1PAkglla_gX3skC5WedEIAwmLkpoI2aAMJA'), ('width', 3000), ('height', 3000)]))]))])]",https://signalhound.com/,Write a Python script that uses Qcodes to connect to a {Device name} Spectrum Analyzers,https://en.wikipedia.org/wiki/Spectrum_analyzer,['Spectrum Analyzers'],"A spectrum analyzer measures the magnitude of an input signal versus frequency within the full frequency range of the instrument. The primary use is to measure the power of the spectrum of known and unknown signals. The input signal that most common spectrum analyzers measure is electrical; however, spectral compositions of other signals, such as acoustic pressure waves and optical light waves, can be considered through the use of an appropriate transducer. Spectrum analyzers for other types of signals also exist, such as optical spectrum analyzers which use direct optical techniques such as a monochromator to make measurements.",,http://signalhound.com/sigdownloads/datasheets/SA44B_sellsheet-Spring-2021.pdf,"[OrderedDict([('id', 'attUxG81DksxCD0N3'), ('width', 1000), ('height', 1000), ('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/rQh7yNS43E6f-UiWEk7IvQ/57JRCzHv0FWyS3-o91VLzh04p0Jiae9fBgadCZV5yMajjn5HUtVr47bZSZ_BG4cgK772YE-xAV-yOinWwm9b7u8IGbKM0IBMyE-QIdiyOzE/dYbtw7lzU71znJB2p-bArhb2aByfN_aREUd_-UfHYwk'), ('filename', 'SA44B_1.jpg'), ('size', 96905), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/QBjD-nTb-XEU86lQ5YW6IQ/rOGcCt6FeZjxv82IKpGECaBrPFDEf2zxqhRjhjaLomOzt_x7vkjz2pPVfbvNghLRHlbMfQhH3MsT_Vvf7SWQXg/XXfKw_y_fOiMslUmR7vKeZTm2b6wU0iBUcpMUJHIJN0'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/dz1pYtmubP265-KoydwT6Q/GAqCGcwWsoH-UaRoSmEhyNX9jNJD-CZe06LCQc20vVhvBz8_4QOHzcWpXy272n8Lni3pL4htb8sfyw8ERiZ_ug/ajnZtfX6yPwwXvAVuH4Ys-PQu0tJtVh6YkwHEKkCruM'), ('width', 512), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/18/18/1689537600000/zMpx6Sd2O0ANGwPQW4TnXw/r1ft7GB_qgUxfn0nM7Eqe8c46tqJ8SwqFi8U-osbfMaA6SM5fEUYRmZ-mM3ijzcShjeX5s50HqZMsTuf7Gs_QQ/-OMcXnfKhxYFR6qThH0r06x37HBur1Q_2GlkAn-V3yA'), ('width', 3000), ('height', 3000)]))]))])]",https://signalhound.com/products/usb-sa44b/,https://github.com/QCoDeS/Qcodes/blob/master/qcodes/instrument_drivers/signal_hound/SignalHound_USB_SA124B.py,https://qcodes.github.io/Qcodes/drivers_api/SignalHound.html,1195.0,,,,"import ctypes as ct
import logging
from enum import IntEnum
from time import sleep
from typing import Any, Optional

import numpy as np

import qcodes.validators as vals
from qcodes.instrument import Instrument
from qcodes.parameters import ArrayParameter, Parameter, ParameterWithSetpoints

log = logging.getLogger(__name__)


class TraceParameter(Parameter):
    """"""
    A parameter that used a flag on the instrument to keeps track of if it's
    value has been synced to the instrument. It is intended that this
    type of parameter is synced using an external method which resets the flag.

    This is most likely used similar to a ``ManualParameter``
    I.e. calling set/get will not communicate with the instrument.
    """"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

    def set_raw(self, value: Any) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""TraceParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        self.instrument._parameters_synced = False


class ExternalRefParameter(TraceParameter):
    """"""
    Parameter that handles the fact that external reference can only be
    enabled but not disabled.

    From the manual:

    Once a device has successfully switched to an external reference it
    must remain using it until the device is closed, and it is undefined
    behavior to disconnect the reference input from the reference BNC port.
    """"""

    def set_raw(self, value: bool) -> None:  # pylint: disable=method-hidden
        if self.get_latest() is True and value is False:
            raise RuntimeError(
                ""Signal Hound does not support disabling ""
                ""external reference. To switch back to internal ""
                ""reference close the device and start again.""
            )
        super().set_raw(value)


class ScaleParameter(TraceParameter):
    """"""
    Parameter that handles changing the unit when the scale is changed.
    """"""

    def set_raw(self, value: str) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""ScaleParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        if value in (""log-scale"", ""log-full-scale""):
            unit = ""dBm""
        elif value in (""lin-scale"", ""lin-full-scale""):
            unit = ""mV""
        else:
            raise RuntimeError(""Unsupported scale"")
        self.instrument.trace.unit = unit
        self.instrument.power.unit = unit
        super().set_raw(value)


class SweepTraceParameter(TraceParameter):
    """"""
    An extension to TraceParameter that keeps track of the trace setpoints in
    addition to the functionality of `TraceParameter`
    """"""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

    def set_raw(self, value: Any) -> None:  # pylint: disable=method-hidden
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""SweepTraceParameter only works with "" ""'SignalHound_USB_SA124B'""
            )
        self.instrument._trace_updated = False
        super().set_raw(value)


class FrequencySweep(ArrayParameter):
    """"""
    Hardware controlled parameter class for SignalHound_USB_SA124B.

    Instrument returns an array of powers for different frequencies

    Args:
        name: parameter name
        instrument: instrument the parameter belongs to
        sweep_len: Number of steps in sweep
        start_freq: Starting frequency
        stepsize: Size of a frequency step

    Methods:
          get(): executes a sweep and returns magnitude and phase arrays

    """"""

    def __init__(
        self,
        name: str,
        instrument: ""SignalHoundUSBSA124B"",
        sweep_len: int,
        start_freq: float,
        stepsize: float,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            name,
            shape=(sweep_len,),
            instrument=instrument,
            unit=""dBm"",
            label=""Magnitude"",
            setpoint_units=(""Hz"",),
            setpoint_labels=(""Frequency"",),
            setpoint_names=(""frequency"",),
            **kwargs,
        )
        self.set_sweep(sweep_len, start_freq, stepsize)

    def set_sweep(self, sweep_len: int, start_freq: float, stepsize: float) -> None:
        """"""
        Set the setpoints of the Array parameter representing a frequency
        sweep.

        Args:
            sweep_len: Number of points in the sweep
            start_freq: Starting frequency of the sweep
            stepsize: Size of step between individual points

        """"""
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""'FrequencySweep' is only implemented"" ""for 'SignalHound_USB_SA124B'""
            )
        end_freq = start_freq + stepsize * (sweep_len - 1)
        freq_points = tuple(np.linspace(start_freq, end_freq, sweep_len))
        self.setpoints = (freq_points,)
        self.shape = (sweep_len,)
        self.instrument._trace_updated = True

    def get_raw(self) -> np.ndarray:
        if self.instrument is None:
            raise RuntimeError(""No instrument is attached to"" ""'FrequencySweep'"")
        if not isinstance(self.instrument, SignalHoundUSBSA124B):
            raise RuntimeError(
                ""'FrequencySweep' is only implemented"" ""for 'SignalHound_USB_SA124B'""
            )
        if not self.instrument._trace_updated:
            raise RuntimeError(""trace not updated, run configure to update"")
        data = self.instrument._get_sweep_data()
        sleep(2 * self.instrument.sleep_time.get())
        return data


class SignalHoundUSBSA124B(Instrument):
    """"""
    QCoDeS driver for the SignalHound USB SA124B

    The driver needs Signal Hounds software
    `Spike <https://signalhound.com/spike/>`_ installed to function.
    In addition, you may need to install Microsoft Visual Studio C++
    Redistributable for the driver to function within QCoDeS.
    At the time of writing the current version of Spike (3.2.3) uses
    `Microsoft Visual Studio C++ Redistributable 2012
    <https://www.microsoft.com/en-us/download/details.aspx?id=30679>`_

    """"""

    dll_path = ""C:\\Program Files\\Signal Hound\\Spike\\sa_api.dll""

    def __init__(self, name: str, dll_path: Optional[str] = None, **kwargs: Any):
        """"""
        Args:
            name: Name of the instrument.
            dll_path: Path to ``sa_api.dll`` Defaults to the default dll within
                Spike installation
            **kwargs:
        """"""
        super().__init__(name, **kwargs)
        self._parameters_synced = False
        self._trace_updated = False
        log.info(""Initializing instrument SignalHound USB 124B"")
        self.dll = ct.CDLL(dll_path or self.dll_path)

        self._set_ctypes_argtypes()

        self.hf = Constants
        self.add_parameter(
            ""frequency"",
            label=""Frequency"",
            unit=""Hz"",
            initial_value=5e9,
            vals=vals.Numbers(),
            parameter_class=SweepTraceParameter,
            docstring=""Center frequency for sweep.""
            ""This is the set center, the actual ""
            ""center may be subject to round off ""
            ""compared to this value"",
        )
        self.add_parameter(
            ""span"",
            label=""Span"",
            unit=""Hz"",
            initial_value=0.25e6,
            vals=vals.Numbers(),
            parameter_class=SweepTraceParameter,
            docstring=""Width of frequency span""
            ""This is the set span, the actual ""
            ""span may be subject to round off ""
            ""compared to this value"",
        )
        self.add_parameter(
            ""npts"",
            label=""Number of Points"",
            get_cmd=self._get_npts,
            set_cmd=False,
            docstring=""Number of points in frequency sweep."",
        )
        self.add_parameter(
            ""avg"",
            label=""Averages"",
            initial_value=1,
            get_cmd=None,
            set_cmd=None,
            vals=vals.Ints(),
            docstring=""Number of averages to perform. ""
            ""Averages are performed in software by ""
            ""acquiring multiple sweeps"",
        )
        self.add_parameter(
            ""ref_lvl"",
            label=""Reference power"",
            unit=""dBm"",
            initial_value=0,
            vals=vals.Numbers(max_value=20),
            parameter_class=TraceParameter,
            docstring=""Setting reference level will ""
            ""automatically select gain and attenuation""
            ""optimal for measuring at and below ""
            ""this level"",
        )
        self.add_parameter(
            ""external_reference"",
            initial_value=False,
            vals=vals.Bool(),
            parameter_class=ExternalRefParameter,
            docstring=""Use an external 10 MHz reference source. ""
            ""Note that Signal Hound does not support ""
            ""disabling external ref. To disable close ""
            ""the connection and restart."",
        )
        self.add_parameter(""device_type"", set_cmd=False, get_cmd=self._get_device_type)
        self.add_parameter(
            ""device_mode"",
            get_cmd=lambda: ""sweeping"",
            set_cmd=False,
            docstring=""The driver currently only  ""
            ""supports sweeping mode. ""
            ""It is therefor not possible""
            ""to set this parameter to anything else"",
        )
        self.add_parameter(
            ""acquisition_mode"",
            get_cmd=lambda: ""average"",
            set_cmd=False,
            docstring=""The driver only supports averaging ""
            ""mode it is therefor not possible to set""
            ""this parameter to anything else"",
        )
        self.add_parameter(
            ""rbw"",
            label=""Resolution Bandwidth"",
            unit=""Hz"",
            initial_value=1e3,
            vals=vals.Numbers(0.1, 250e3),
            parameter_class=TraceParameter,
            docstring=""Resolution Bandwidth (RBW) is""
            ""the bandwidth of ""
            ""spectral energy represented in each ""
            ""frequency bin"",
        )
        self.add_parameter(
            ""vbw"",
            label=""Video Bandwidth"",
            unit=""Hz"",
            initial_value=1e3,
            vals=vals.Numbers(),
            parameter_class=TraceParameter,
            docstring=""The video bandwidth (VBW) is applied ""
            ""after the signal has been converted to ""
            ""frequency domain as power, voltage, ""
            ""or log units. It is implemented as a ""
            ""simple rectangular window, averaging the ""
            ""amplitude readings for each frequency ""
            ""bin over several overlapping FFTs. ""
            ""For best performance use RBW as the VBW."",
        )

        self.add_parameter(
            ""reject_image"",
            label=""Reject image"",
            unit="""",
            initial_value=True,
            parameter_class=TraceParameter,
            get_cmd=None,
            docstring=""Apply software filter to remove "" ""undersampling mirroring"",
            vals=vals.Bool(),
        )
        self.add_parameter(
            ""sleep_time"",
            label=""Sleep time"",
            unit=""s"",
            initial_value=0.1,
            get_cmd=None,
            set_cmd=None,
            docstring=""Time to sleep before and after ""
            ""getting data from the instrument"",
            vals=vals.Numbers(0),
        )
        # We don't know the correct values of
        # the sweep parameters yet so we supply
        # some defaults. The correct will be set when we call configure below
        self.add_parameter(
            name=""trace"",
            sweep_len=1,
            start_freq=1,
            stepsize=1,
            parameter_class=FrequencySweep,
        )
        self.add_parameter(
            ""power"",
            label=""Power"",
            unit=""dBm"",
            get_cmd=self._get_power_at_freq,
            set_cmd=False,
            docstring=""The maximum power in a window of 250 kHz""
            ""around the specified  frequency with ""
            ""Resolution bandwidth set to 1 kHz.""
            ""The integration window is specified by ""
            ""the VideoBandWidth (set by vbw)"",
        )
        # scale is defined after the trace and power parameter so that
        # it can change the units of those in it's set method when the
        # scale changes
        self.add_parameter(
            ""scale"",
            initial_value=""log-scale"",
            vals=vals.Enum(
                ""log-scale"", ""lin-scale"", ""log-full-scale"", ""lin-full-scale""
            ),
            parameter_class=ScaleParameter,
        )

        self.add_parameter(
            ""frequency_axis"",
            label=""Frequency"",
            unit=""Hz"",
            get_cmd=self._get_freq_axis,
            set_cmd=False,
            vals=vals.Arrays(shape=(self.npts,)),
            snapshot_value=False,
        )
        self.add_parameter(
            ""freq_sweep"",
            label=""Power"",
            unit=""depends on mode"",
            get_cmd=self._get_sweep_data,
            set_cmd=False,
            parameter_class=ParameterWithSetpoints,
            vals=vals.Arrays(shape=(self.npts,)),
            setpoints=(self.frequency_axis,),
            snapshot_value=False,
        )

        self.openDevice()
        self.configure()

        self.connect_message()

    def _set_ctypes_argtypes(self) -> None:
        """"""
        Set the expected argtypes for function calls in the sa_api dll
        These should match the function signatures defined in the sa-api
        header files included with the signal hound sdk
        """"""
        self.dll.saConfigCenterSpan.argtypes = [ct.c_int, ct.c_double, ct.c_double]
        self.dll.saConfigAcquisition.argtypes = [ct.c_int, ct.c_int, ct.c_int]
        self.dll.saConfigLevel.argtypes = [ct.c_int, ct.c_double]
        self.dll.saSetTimebase.argtypes = [ct.c_int, ct.c_int]
        self.dll.saConfigSweepCoupling.argtypes = [
            ct.c_int,
            ct.c_double,
            ct.c_double,
            ct.c_bool,
        ]
        self.dll.saInitiate.argtypes = [ct.c_int, ct.c_int, ct.c_int]
        self.dll.saOpenDevice.argtypes = [ct.POINTER(ct.c_int)]
        self.dll.saCloseDevice.argtypes = [ct.c_int]
        self.dll.saPreset.argtypes = [ct.c_int]
        self.dll.saGetDeviceType.argtypes = [ct.c_int, ct.POINTER(ct.c_int)]
        self.dll.saQuerySweepInfo.argtypes = [
            ct.c_int,
            ct.POINTER(ct.c_int),
            ct.POINTER(ct.c_double),
            ct.POINTER(ct.c_double),
        ]
        self.dll.saGetSweep_32f.argtypes = [
            ct.c_int,
            ct.POINTER(ct.c_float),
            ct.POINTER(ct.c_float),
        ]
        self.dll.saGetSerialNumber.argtypes = [ct.c_int, ct.POINTER(ct.c_int)]
        self.dll.saGetFirmwareString.argtypes = [ct.c_int, ct.c_char_p]

    def _get_npts(self) -> int:
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_info = self.QuerySweep()
        sweep_len = sweep_info[0]
        return sweep_len

    def _update_trace(self) -> None:
        """"""
        Private method to sync changes of the
        frequency axis to the setpoints of the
        trace parameter. This also set the units
        of power and trace.
        """"""
        sweep_info = self.QuerySweep()
        self.npts.cache.set(sweep_info[0])
        self.trace.set_sweep(*sweep_info)

    def sync_parameters(self) -> None:
        """"""
        Sync parameters sets the configuration of the instrument using the
        parameters specified in the Qcodes instrument.

        Sync parameters consists of five parts
            1. Center span configuration (freqs and span)
            2. Acquisition configuration
                lin-scale/log-scale
                avg/max power
            3. Configuring the external 10MHz reference
            4. Configuration of the mode that is being used
            5. Acquisition mode. At the moment only `sweeping` is implemented

        This does not currently implement Configuration of the tracking
        generator used in VNA mode
        """"""

        # 1. CenterSpan Configuration
        center = ct.c_double(self.frequency())
        span = ct.c_double(self.span())
        log.info(""Setting device CenterSpan configuration."")

        err = self.dll.saConfigCenterSpan(self.deviceHandle, center, span)
        self.check_for_error(err, ""saConfigCenterSpan"")

        # 2. Acquisition configuration
        detectorVals = {
            ""min-max"": ct.c_int(self.hf.sa_MIN_MAX),
            ""average"": ct.c_int(self.hf.sa_AVERAGE),
        }
        scaleVals = {
            ""log-scale"": ct.c_int(self.hf.sa_LOG_SCALE),
            ""lin-scale"": ct.c_int(self.hf.sa_LIN_SCALE),
            ""log-full-scale"": ct.c_int(self.hf.sa_LOG_FULL_SCALE),
            ""lin-full-scale"": ct.c_int(self.hf.sa_LIN_FULL_SCALE),
        }
        detector = detectorVals[self.acquisition_mode()]
        scale = scaleVals[self.scale()]

        err = self.dll.saConfigAcquisition(self.deviceHandle, detector, scale)
        self.check_for_error(err, ""saConfigAcquisition"")

        # 3. Reference Level configuration
        log.info(""Setting device reference level configuration."")
        err = self.dll.saConfigLevel(self.deviceHandle, ct.c_double(self.ref_lvl()))
        self.check_for_error(err, ""saConfigLevel"")

        # 4. External Reference configuration
        if self.external_reference():
            external = self.hf.sa_REF_EXTERNAL_IN
            log.info(""Setting reference frequency from external source."")
            err = self.dll.saSetTimebase(self.deviceHandle, external)
            self.check_for_error(err, ""saSetTimebase"")

        reject_var = ct.c_bool(self.reject_image())
        log.info(""Setting device Sweeping configuration."")
        err = self.dll.saConfigSweepCoupling(
            self.deviceHandle,
            ct.c_double(self.rbw()),
            ct.c_double(self.vbw()),
            reject_var,
        )
        self.check_for_error(err, ""saConfigSweepCoupling"")

        modeOpts = {
            ""sweeping"": self.hf.sa_SWEEPING,
            ""real_time"": self.hf.sa_REAL_TIME,  # not implemented
            ""IQ"": self.hf.sa_IQ,  # not implemented
            ""idle"": self.hf.sa_IDLE,
        }
        mode = modeOpts[self.device_mode()]
        # the third argument to saInitiate is a flag that is
        # currently not used
        err = self.dll.saInitiate(self.deviceHandle, mode, 0)
        extrainfo: Optional[str] = None
        if err == saStatus.saInvalidParameterErr:
            extrainfo = """"""
                 In real-time mode, this value may be returned if the span
                 limits defined in the API header are broken. Also in
                 real-time mode, this error will be returned if the
                 resolution bandwidth is outside the limits defined in
                 the API header.
                 In time-gate analysis mode this error will be returned if
                 span limits defined in the API header are broken. Also in
                 time gate analysis, this error is returned if the
                 bandwidth provided require more samples for processing
                 than is allowed in the gate length. To fix this
                 increase rbw/vbw.
             """"""
        elif err == saStatus.saBandwidthErr:
            extrainfo = ""RBW is larger than your span. (Sweep Mode)!""
        self.check_for_error(err, ""saInitiate"", extrainfo)

        self._parameters_synced = True

    def configure(self) -> None:
        """"""
        Syncs parameters to the Instrument and updates the setpoint of the
        trace.
        """"""
        self.sync_parameters()
        self._update_trace()

    def openDevice(self) -> None:
        """"""
        Opens connection to the instrument
        """"""
        log.info(""Opening Device"")
        self.deviceHandle = ct.c_int(0)
        deviceHandlePnt = ct.pointer(self.deviceHandle)
        err = self.dll.saOpenDevice(deviceHandlePnt)
        self.check_for_error(err, ""saOpenDevice"")
        self.device_type()

    def close(self) -> None:
        """"""
        Close connection to the instrument.
        """"""
        log.info(""Closing Device with handle num: "" f""{self.deviceHandle.value}"")

        try:
            self.abort()
            log.info(""Running acquistion aborted."")
        except Exception as e:
            # it's ok to catch any exception here
            # as we are tearing down the instrument we might
            # as well try to continue
            log.warning(f""Could not abort acquisition: {e}"")

        err = self.dll.saCloseDevice(self.deviceHandle)
        self.check_for_error(err, ""saCloseDevice"")
        log.info(f""Closed Device with handle num: {self.deviceHandle.value}"")
        super().close()

    def abort(self) -> None:
        """"""
        Abort any running acquisition.
        """"""
        log.info(""Stopping acquisition"")

        err = self.dll.saAbort(self.deviceHandle)
        extrainfo: Optional[str] = None
        if err == saStatus.saDeviceNotConfiguredErr:
            extrainfo = (
                ""Device was already idle! Did you call abort ""
                ""without ever calling initiate()""
            )

        self.check_for_error(err, ""saAbort"", extrainfo)

    def preset(self) -> None:
        """"""
        Like close but performs a hardware reset before closing the
        connection.
        """"""
        log.warning(""Performing hardware-reset of device!"")

        err = self.dll.saPreset(self.deviceHandle)
        self.check_for_error(err, ""saPreset"")
        super().close()

    def _get_device_type(self) -> str:
        """"""
        Returns the model string of the Spectrum Analyzer.
        """"""
        log.info(""Querying device for model information"")

        devType = ct.c_int32(0)
        devTypePnt = ct.pointer(devType)

        err = self.dll.saGetDeviceType(self.deviceHandle, devTypePnt)
        self.check_for_error(err, ""saGetDeviceType"")

        if devType.value == self.hf.saDeviceTypeNone:
            dev = ""No device""
        elif devType.value == self.hf.saDeviceTypeSA44:
            dev = ""sa44""
        elif devType.value == self.hf.saDeviceTypeSA44B:
            dev = ""sa44B""
        elif devType.value == self.hf.saDeviceTypeSA124A:
            dev = ""sa124A""
        elif devType.value == self.hf.saDeviceTypeSA124B:
            dev = ""sa124B""
        else:
            raise ValueError(""Unknown device type!"")
        return dev

    ########################################################################

    def QuerySweep(self) -> tuple[int, float, float]:
        """"""
        Queries the sweep for information on the parameters that defines the
            x axis of the sweep

        Returns:
            number of points in sweep, start frequency and step size
        """"""

        sweep_len = ct.c_int(0)
        start_freq = ct.c_double(0)
        stepsize = ct.c_double(0)
        err = self.dll.saQuerySweepInfo(
            self.deviceHandle,
            ct.pointer(sweep_len),
            ct.pointer(start_freq),
            ct.pointer(stepsize),
        )
        self.check_for_error(err, ""saQuerySweepInfo"")
        return sweep_len.value, start_freq.value, stepsize.value

    def _get_sweep_data(self) -> np.ndarray:
        """"""
        This function performs a sweep over the configured ranges.
        The result of the sweep is returned along with the sweep points

        returns:
            datamin numpy array
        """"""
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_len, _, _ = self.QuerySweep()

        data = np.zeros(sweep_len)
        Navg = self.avg()
        for i in range(Navg):

            datamin = np.zeros((sweep_len), dtype=np.float32)
            datamax = np.zeros((sweep_len), dtype=np.float32)

            minarr = datamin.ctypes.data_as(ct.POINTER(ct.c_float))
            maxarr = datamax.ctypes.data_as(ct.POINTER(ct.c_float))

            sleep(self.sleep_time.get())  # Added extra sleep for updating issue
            err = self.dll.saGetSweep_32f(self.deviceHandle, minarr, maxarr)
            self.check_for_error(err, ""saGetSweep_32f"")
            data += datamin

        return data / Navg

    def _get_power_at_freq(self) -> float:
        """"""
        Returns the maximum power in a window of 250 kHz
        around the specified  frequency with Resolution bandwidth set to 1 kHz.
        The integration window is specified by the VideoBandWidth (set by vbw)
        """"""
        original_span = self.span()
        original_rbw = self.rbw()
        needs_reset = False
        if not (original_span == 0.25e6 and original_rbw == 1e3):
            needs_reset = True
            self.span(0.25e6)
            self.rbw(1e3)
        if not self._parameters_synced:
            # call configure to update both
            # the parameters on the device and the
            # setpoints and units
            self.configure()
        data = self._get_sweep_data()
        max_power = np.max(data)
        if needs_reset:
            self.span(original_span)
            self.rbw(original_rbw)
            self.configure()
        sleep(2 * self.sleep_time.get())
        return max_power

    @staticmethod
    def check_for_error(err: int, source: str, extrainfo: Optional[str] = None) -> None:
        if err != saStatus.saNoError:
            err_str = saStatus(err).name
            if err > 0:
                msg = (
                    f""During call of {source} the following""
                    f""Warning: {err_str} was raised""
                )
                if extrainfo is not None:
                    msg = msg + f""\n Extra info: {extrainfo}""
                log.warning(msg)
            else:
                msg = (
                    f""During call of {source} the following Error: ""
                    f""{err_str} was raised""
                )
                if extrainfo is not None:
                    msg = msg + f""\n Extra info: {extrainfo}""
                raise OSError(msg)
        else:
            msg = ""Call to {source} was successful""
            if extrainfo is not None:
                msg = msg + f""\n Extra info: {extrainfo}""
            log.info(msg)

    def get_idn(self) -> dict[str, Optional[str]]:
        output: dict[str, Optional[str]] = {}
        output[""vendor""] = ""Signal Hound""
        output[""model""] = self._get_device_type()
        serialnumber = ct.c_int32()
        err = self.dll.saGetSerialNumber(self.deviceHandle, ct.pointer(serialnumber))
        self.check_for_error(err, ""saGetSerialNumber"")
        output[""serial""] = str(serialnumber.value)
        fw_version = (ct.c_char * 17)()
        # the manual says that this must be at least 16 char
        # but not clear if that includes a termination zero so
        # make it 17 just in case
        err = self.dll.saGetFirmwareString(self.deviceHandle, fw_version)
        self.check_for_error(err, ""saGetFirmwareString"")
        output[""firmware""] = fw_version.value.decode(""ascii"")
        return output

    def _get_freq_axis(self) -> np.ndarray:
        if not self._parameters_synced:
            self.sync_parameters()
        sweep_len, start_freq, stepsize = self.QuerySweep()
        end_freq = start_freq + stepsize * (sweep_len - 1)
        freq_points = np.linspace(start_freq, end_freq, sweep_len)
        return freq_points


class Constants:
    """"""
    These constants are defined in sa_api.h as part of the the Signal Hound
    SDK
    """"""

    SA_MAX_DEVICES = 8

    saDeviceTypeNone = 0
    saDeviceTypeSA44 = 1
    saDeviceTypeSA44B = 2
    saDeviceTypeSA124A = 3
    saDeviceTypeSA124B = 4

    sa44_MIN_FREQ = 1.0
    sa124_MIN_FREQ = 100.0e3
    sa44_MAX_FREQ = 4.4e9
    sa124_MAX_FREQ = 13.0e9
    sa_MIN_SPAN = 1.0
    sa_MAX_REF = 20
    sa_MAX_ATTEN = 3
    sa_MAX_GAIN = 2
    sa_MIN_RBW = 0.1
    sa_MAX_RBW = 6.0e6
    sa_MIN_RT_RBW = 100.0
    sa_MAX_RT_RBW = 10000.0
    sa_MIN_IQ_BANDWIDTH = 100.0
    sa_MAX_IQ_DECIMATION = 128

    sa_IQ_SAMPLE_RATE = 486111.111

    sa_IDLE = -1
    sa_SWEEPING = 0x0
    sa_REAL_TIME = 0x1
    sa_IQ = 0x2
    sa_AUDIO = 0x3
    sa_TG_SWEEP = 0x4

    sa_MIN_MAX = 0x0
    sa_AVERAGE = 0x1

    sa_LOG_SCALE = 0x0
    sa_LIN_SCALE = 0x1
    sa_LOG_FULL_SCALE = 0x2
    sa_LIN_FULL_SCALE = 0x3

    sa_AUTO_ATTEN = -1
    sa_AUTO_GAIN = -1

    sa_LOG_UNITS = 0x0
    sa_VOLT_UNITS = 0x1
    sa_POWER_UNITS = 0x2
    sa_BYPASS = 0x3

    sa_AUDIO_AM = 0x0
    sa_AUDIO_FM = 0x1
    sa_AUDIO_USB = 0x2
    sa_AUDIO_LSB = 0x3
    sa_AUDIO_CW = 0x4

    TG_THRU_0DB = 0x1
    TG_THRU_20DB = 0x2

    sa_REF_UNUSED = 0
    sa_REF_INTERNAL_OUT = 1
    sa_REF_EXTERNAL_IN = 2


class saStatus(IntEnum):
    saUnknownErr = -666
    saFrequencyRangeErr = 99
    saInvalidDetectorErr = -95
    saInvalidScaleErr = -94
    saBandwidthErr = -91
    saExternalReferenceNotFound = -89
    # Device specific errors
    saOvenColdErr = -20
    # Data errors
    saInternetErr = -12
    saUSBCommErr = -11
    # General configuration errors
    saTrackingGeneratorNotFound = -10
    saDeviceNotIdleErr = -9
    saDeviceNotFoundErr = -8
    saInvalidModeErr = -7
    saNotConfiguredErr = -6
    saDeviceNotConfiguredErr = -6  # Added because key error raised
    saTooManyDevicesErr = -5
    saInvalidParameterErr = -4
    saDeviceNotOpenErr = -3
    saInvalidDeviceErr = -2
    saNullPtrErr = -1
    # No error
    saNoError = 0
    # Warnings
    saNoCorrections = 1
    saCompressionWarning = 2
    saParameterClamped = 3
    saBandwidthClamped = 4
"
