,Field 1,Vendor,Device,Library,Device Description,Python docs link,GitHub link to Python driver (NOT LINK TO DOCS ON GITHUB),Corrected device name,Device picture,Device Description Link,Device Category,Vendor logo,Vendor wikipedia or cruncbase description,Vendor website,Device datasheet (PDF),Vendor headquarters,"Yearly revenue (millions, USD)",Category Description,Category description link,ChatGPT prompt,Device Price,ChatGPT code,Obsolete,Notes,docstring
50,418.0,Picoquant,PH Photoncounter,Pytango,"The PicoHarp 300 is a high-end, easy to use, plug and play Time-Correlated Single Photon Counting (TCSPC) system. It is connected to a PC through a USB 2.0 interface. The high quality and reliability of the PicoHarp 300 is expressed by a unique 5-year limited warranty.

",https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/PicoHarp300/index.html,https://github.com/PicoQuant/PH300-v3.x-Demos/blob/master/64/python/Standard/dlldemo.py,PicoHarp 300,"[OrderedDict([('id', 'attoIvJqIq4JWowuN'), ('width', 300), ('height', 170), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/dotehmTKP98v-yeGYVn5pg/WUh9ngcGmRqIZAv1BwR_3CMovP8Kq-up6dUFIW31kP4sfFSDBw0_afjko7aTbOtxQQ6ZrfhMhrcbntLDW01fq_VXCh4fz6JnJnAmBJNpDllN0jXYOv_XBjGp3zWIRJbO/Aa21bl71YVMWbRnqfPzMiTcWNVNzuXrBAsAwUjaZXoY'), ('filename', 'picoharp_large__small.jpg'), ('size', 31031), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/sdVkwO_RSXi3_1rqU0HXMA/AtDohef3HHF53UpgWSyAnEkYsn5DVpfecOXxzFVjI1Dq5TnzOnrlYr0E4BSb6BoiJXnERxi4uHfe5i_Zh8BCJg/39bync2mXmtSWAItjnG3AW4_1T7i5-YyCgsokuzRl1U'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Y2VeXdSxC5JHerK9hgxu6Q/H-bO8_mW0l3CfkDt8ZbAUS7MqQTbV-g9pkIzZ4dO5mNY2o2xgsBZSjImjz3pgW0Dd0SpD2NjlutrGAO-L0MEPQ/SH1l6PYufgIyistXjTnWrwjvEKLfhT6W-67Bp1rAEG8'), ('width', 300), ('height', 170)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/H1hRtFGLb_EMUxEU5I84oA/Z459oMyiUzp7FwlKkCcMKKy_2Ll4U8eJEOArXQ_Vw93dZ1oNOZTzosq0-mHZXdy3lnlR44VYIRys0DjCMjlM2w/BxBQLl01L2wNlwFST6tg8f833pUreYUWScG9n-buWNM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.picoquant.com/products/category/tcspc-and-time-tagging-modules/picoharp-300-stand-alone-tcspc-module-with-usb-interface,['Photon Counting System'],"[OrderedDict([('id', 'att3Ffml7HIC1nRMD'), ('width', 177), ('height', 152), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/W5j5kH9fGEOWFAs5QrnddQ/ETFiFuD0PB6e43AfDd0Z5QN6v2_umGvGfGIt7pe2CLJWseOr1vr7cDDQ45uDiCryBopEiKeML-FszNX04WACXmJQXLH6kMuWk27BAuCy_Ls/pIr44PiEr-LZWEr4BhzCrgPPNreFAOo-o-d3Yc3hbgM'), ('filename', 'logo-white.png'), ('size', 58557), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/A4wmcS6xu097Q42WFDRFLw/Jj0jaKak7RtYJoCZE7eSktLKw2g4nBkT9DZE_0NgyRTEs0uIcOuF4T4nrCQEQyIVmV6B4UjZfaLHwHHW53oU8Q/Y3bRVuQjRuU6sVxZil381jRp9zRzl6t3QRNydTVUEEA'), ('width', 42), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/u_LNaR2qCjUL5A3kVHqOQg/ZaGNxG_D3DQIQ-2UBVDHIJwR_NJj0WfOO3rL0_8dpJzKnWiouanbVKc4l82CeSjZDa0PzPo9TapvCbrmpLXTIw/ZtVPcBCiBxrSIaOkq6rbsXBUozX28WLDMiHRSgjmn1o'), ('width', 177), ('height', 152)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/SLQ-6s8y2ID3HfhtBVrjaA/XCxHu5iCMaJQroM15uBRgSA5LpOmWKZ_0lzOAn4_ZOr9sL-D1Yqz_7UArvNRGr-diN6XdNGoJkGxFHq1SFIODg/vj2CrZFrpKAGFbmowYtWe7-AuGSc7yWXJJbsWHiwODM'), ('width', 3000), ('height', 3000)]))]))])]","The PicoQuant group was founded in 1996 to develop robust, compact, and easy to use time-resolved instrumentation and systems. Since April 2008 sales and support in North America is handled by PicoQuant Photonics North America Inc. In January 2010, the PicoQuant group was extended by PicoQuant Innovations, which was founded to support the increasing activities in the field of teaching, customer support, and event organization.
",https://www.picoquant.com/,https://www.picoquant.com/images/uploads/downloads/7304-picoharp300.pdf,"Berlin, Germany",14.7,Photon counting is a technique in which individual photons are counted using a single-photon detector (SPD). A single-photon detector emits a pulse of signal for each detected photon. The counting efficiency is determined by the quantum efficiency and the system's electronic losses.,https://en.wikipedia.org/wiki/Photon_counting,Write a Python script that uses Pytango to connect to a PicoHarp 300 Photon Counting System,,,,,"# Demo for access to PicoHarp 300 Hardware via PHLIB.DLL v 3.0.
# The program performs a measurement based on hard coded settings.
# The resulting histogram (65536 channels) is stored in an ASCII output file.
#
# Keno Goertz, PicoQuant GmbH, February 2018

import time
import ctypes as ct
from ctypes import byref

# From phdefin.h
LIB_VERSION = ""3.0""
HISTCHAN = 65536
MAXDEVNUM = 8
MODE_HIST = 0
FLAG_OVERFLOW = 0x0040

# Measurement parameters, these are hardcoded since this is just a demo
binning = 0 # you can change this
offset = 0
tacq = 1000 # Measurement time in millisec, you can change this
syncDivider = 1 # you can change this 
CFDZeroCross0 = 10 # you can change this (in mV)
CFDLevel0 = 100 # you can change this (in mV)
CFDZeroCross1 = 10 # you can change this (in mV)
CFDLevel1 = 50 # you can change this (in mV)
cmd = 0

# Variables to store information read from DLLs
counts = (ct.c_uint * HISTCHAN)()
dev = []
libVersion = ct.create_string_buffer(b"""", 8)
hwSerial = ct.create_string_buffer(b"""", 8)
hwPartno = ct.create_string_buffer(b"""", 8)
hwVersion = ct.create_string_buffer(b"""", 8)
hwModel = ct.create_string_buffer(b"""", 16)
errorString = ct.create_string_buffer(b"""", 40)
resolution = ct.c_double()
countRate0 = ct.c_int()
countRate1 = ct.c_int()
flags = ct.c_int()

phlib = ct.CDLL(""phlib64.dll"")

def closeDevices():
    for i in range(0, MAXDEVNUM):
        phlib.PH_CloseDevice(ct.c_int(i))
    exit(0)

def tryfunc(retcode, funcName):
    if retcode < 0:
        phlib.PH_GetErrorString(errorString, ct.c_int(retcode))
        print(""PH_%s error %d (%s). Aborted."" % (funcName, retcode,\
              errorString.value.decode(""utf-8"")))
        closeDevices()

phlib.PH_GetLibraryVersion(libVersion)
print(""Library version is %s"" % libVersion.value.decode(""utf-8""))
if libVersion.value.decode(""utf-8"") != LIB_VERSION:
    print(""Warning: The application was built for version %s"" % LIB_VERSION)

outputfile = open(""dlldemo.out"", ""w+"")

outputfile.write(""Binning           : %d\n"" % binning)
outputfile.write(""Offset            : %d\n"" % offset)
outputfile.write(""AcquisitionTime   : %d\n"" % tacq)
outputfile.write(""SyncDivider       : %d\n"" % syncDivider)
outputfile.write(""CFDZeroCross0     : %d\n"" % CFDZeroCross0)
outputfile.write(""CFDLevel0         : %d\n"" % CFDLevel0)
outputfile.write(""CFDZeroCross1     : %d\n"" % CFDZeroCross1)
outputfile.write(""CFDLevel1         : %d\n"" % CFDLevel1)

print(""\nSearching for PicoHarp devices..."")
print(""Devidx     Status"")

for i in range(0, MAXDEVNUM):
    retcode = phlib.PH_OpenDevice(ct.c_int(i), hwSerial)
    if retcode == 0:
        print(""  %1d        S/N %s"" % (i, hwSerial.value.decode(""utf-8"")))
        dev.append(i)
    else:
        if retcode == -1: # ERROR_DEVICE_OPEN_FAIL
            print(""  %1d        no device"" % i)
        else:
            phlib.PH_GetErrorString(errorString, ct.c_int(retcode))
            print(""  %1d        %s"" % (i, errorString.value.decode(""utf8"")))

# In this demo we will use the first PicoHarp device we find, i.e. dev[0].
# You can also use multiple devices in parallel.
# You can also check for specific serial numbers, so that you always know 
# which physical device you are talking to.

if len(dev) < 1:
    print(""No device available."")
    closeDevices()
print(""Using device #%1d"" % dev[0])
print(""\nInitializing the device..."")

tryfunc(phlib.PH_Initialize(ct.c_int(dev[0]), ct.c_int(MODE_HIST)), ""Initialize"")

# Only for information
tryfunc(phlib.PH_GetHardwareInfo(dev[0], hwModel, hwPartno, hwVersion),\
        ""GetHardwareInfo"")
print(""Found Model %s Part no %s Version %s"" % (hwModel.value.decode(""utf-8""),\
    hwPartno.value.decode(""utf-8""), hwVersion.value.decode(""utf-8"")))

print(""\nCalibrating..."")
tryfunc(phlib.PH_Calibrate(ct.c_int(dev[0])), ""Calibrate"")

tryfunc(phlib.PH_SetSyncDiv(ct.c_int(dev[0]), ct.c_int(syncDivider)), ""SetSyncDiv"")

tryfunc(
    phlib.PH_SetInputCFD(ct.c_int(dev[0]), ct.c_int(0), ct.c_int(CFDLevel0),\
                         ct.c_int(CFDZeroCross0)),\
    ""SetInputCFD""
)

tryfunc(
    phlib.PH_SetInputCFD(ct.c_int(dev[0]), ct.c_int(1), ct.c_int(CFDLevel1),\
                         ct.c_int(CFDZeroCross1)),\
    ""SetInputCFD""
)

tryfunc(phlib.PH_SetBinning(ct.c_int(dev[0]), ct.c_int(binning)), ""SetBinning"")
tryfunc(phlib.PH_SetOffset(ct.c_int(dev[0]), ct.c_int(offset)), ""SetOffset"")
tryfunc(phlib.PH_GetResolution(ct.c_int(dev[0]), byref(resolution)), ""GetResolution"")

# Note: after Init or SetSyncDiv you must allow 100 ms for valid count rate readings
time.sleep(0.2)

tryfunc(phlib.PH_GetCountRate(ct.c_int(dev[0]), ct.c_int(0), byref(countRate0)),\
        ""GetCountRate"")
tryfunc(phlib.PH_GetCountRate(ct.c_int(dev[0]), ct.c_int(1), byref(countRate1)),\
        ""GetCountRate"")

print(""Resolution=%lf Countrate0=%d/s Countrate1=%d/s"" % (resolution.value,\
      countRate0.value, countRate1.value))

tryfunc(phlib.PH_SetStopOverflow(ct.c_int(dev[0]), ct.c_int(1), ct.c_int(65535)),\
        ""SetStopOverflow"")

while cmd != ""q"":
    # Always use block 0 if not routing
    tryfunc(phlib.PH_ClearHistMem(ct.c_int(dev[0]), ct.c_int(0)), ""ClearHistMeM"")

    print(""press RETURN to start measurement"")
    input()

    tryfunc(phlib.PH_GetCountRate(ct.c_int(dev[0]), ct.c_int(0), byref(countRate0)),\
            ""GetCountRate"")
    tryfunc(phlib.PH_GetCountRate(ct.c_int(dev[0]), ct.c_int(1), byref(countRate1)),\
            ""GetCountRate"")
    
    print(""Countrate0=%d/s Countrate1=%d/s"" % (countRate0.value, countRate1.value))
    
    tryfunc(phlib.PH_StartMeas(ct.c_int(dev[0]), ct.c_int(tacq)), ""StartMeas"")
        
    print(""\nMeasuring for %d milliseconds..."" % tacq)
    
    waitloop = 0
    ctcstatus = ct.c_int(0)
    while ctcstatus.value == 0:
        tryfunc(phlib.PH_CTCStatus(ct.c_int(dev[0]), byref(ctcstatus)), ""CTCStatus"")
        waitloop+=1
        
    tryfunc(phlib.PH_StopMeas(ct.c_int(dev[0])), ""StopMeas"")
    tryfunc(phlib.PH_GetHistogram(ct.c_int(dev[0]), byref(counts), ct.c_int(0)),\
            ""GetHistogram"")
    tryfunc(phlib.PH_GetFlags(ct.c_int(dev[0]), byref(flags)), ""GetFlags"")
    
    integralCount = 0
    for i in range(0, HISTCHAN):
        integralCount += counts[i]
    
    print(""\nWaitloop=%1d  TotalCount=%1.0lf"" % (waitloop, integralCount))
    
    if flags.value & FLAG_OVERFLOW > 0:
        print(""  Overflow."")

    print(""Enter c to continue or q to quit and save the count data."")
    cmd = input()

for i in range(0, HISTCHAN):
    outputfile.write(""\n%5d "" % counts[i])

closeDevices()
outputfile.close()"
111,212.0,Keithley,Pipekeithley,Pytango,Class For Getting Data From The Keihtley Of The Photon-Ion Spectrometer (Pipe).,https://www.tango-controls.org/developers/dsc/ds/1164/,http://svn.code.sf.net/p/tango-ds/code/DeviceClasses/MeasureInstruments/Keithley/PIPEKeithley/trunk/PIPEKeithley.py,Pipekeithley,,,,"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/g8dQazWWFtzjuY_SfuR2mw/x4Drazo_zJbmXQiu8B-4E7K5tc5YRgHwc0_Id74Y_Jo59o_6f0AIoPr82NqkBETG-pFBV5xTlmYrm3D26bFGbVXKoO3PZoV5JDGpQGRwEVOQRzPOpCNvK4cuHdlrtAsiqqJcYrCJ2dSUYYB4CdfqOw/jKRkUTNDQLrcKtQmrOCEPiiTGOt_bG8fU8UwYuFNmsI'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/sr12ul7hLqFdjXP3_badqA/U6tiJCmGyNLJOHGabD_hSQW6Vlb9IKyDeWS1VGYchCEeCCyBVvIdDwZDqiNoepSI1GaMqKNNgjOrJjmPUvG3FQ/GSVsCs-ZKOcmdM4IjvsPZw3I1IH5XmdtksyKRDKzV3c'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/tOrdNEmYqxicjGs17378WQ/4SLCwfH4AIePCqBSSNsKWU3ovMct49gmcW2Q0RTZItPixIPcGyXtfYZV79pIBova7rAgmELpa-B4Z4GRqAftuQ/WuOEXNISn20M6dluJLUE25L1cgkhtVVvbxM_cWx4TPc'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/yzCrD7tfs8RONmym_XQR5g/s263uLffgFd-9vmowfviMNLO4RzbMWf_n-R929zSVnwifujEBHNkB3AmO7RcN0PTIUQ2nPo11AsYEAN5s1sPhQ/X6vcC1w_lSZS1Rgkx0eqvpsfWXVyInMvm95EqR7nSgk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,,"Cleveland, Ohio, United States",110.6,,,Write a Python script that uses Pytango to connect to a {Device name} ,,,,,
115,344.0,Lakeshore,LKS 425 Gaussmeterctrl,Pytango,Class Connecting To The Lakeshore 425 Gaussmeter,https://github.com/lakeshorecryotronics/python-driver/tree/main/lakeshore,https://github.com/lakeshorecryotronics/python-driver/blob/main/lakeshore/model_425.py,LKS 425 Gaussmeterctrl,,https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-425-gaussmeter,['Multimeters'],"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/t5_PKcjJCYO5FhsE-R1DEQ/Vg0kt2Ai3FT2GFjQ04jf5sB1VmcRqtM5xgsoRmjz1p-VCyhCE9qyqjJ9YjdF06kkNj9BeysK4XT95tu3hWhI-hBazH6gAg6YWlVr78orm8U/9DitSfl0sMOC7VOSMZZ68e7TnbhGVKN26HMqSJTScjE'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/C4mzUdB4lLLO1fef507Egg/LWvbW57bgKW9S7lmWIlThSsJ6A_4ektFk_PF0Jj8AYL49oiG8xXtzpZYRW__AaGTAoM6ibcNNqV3rPAgsFdS5eeNp59ZJ2TG0-BtCmKdQYg/oOJ-zQ9tH9Jvm1Pp0WsAcmO9leUjCFKlUEICLsCgTVk'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/mhTP4mS7q0StLsAsqWYvCA/X-1YPOSh0ulVfM1PZniSw90R6i3cnqVBnyfKCs8A17gyse-uEB4Ik-e5Ihy4kHFmskm03E-q3seFtDtGi4pQP2rGkZ1yFRylZfHoC7p8Om0/9smBV3bkKYzMSCtzCMa0VTbB9YgVJcpJabQbtiW6_aw'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/JLEXW0y4Zbnm4eBmjqVKpQ/bo9ST37pn71_ugm_FSSXCmf9u3rk5tYKkG15j03j5WVhorr-MgJmgbYbI_ImbSOsqt5X76_lGs49wBagk49K9AKR22RGpS7fDjLZ72FhGzU/zbkMdPVEOGGNpLx1C9B3ArZou9Ntj4wrTWDrqsLXUSQ'), ('width', 3000), ('height', 3000)]))]))])]","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://www.lakeshore.com/home,,"Westerville, Ohio, USA",21.4,"Gaussmeter
",https://en.wikipedia.org/wiki/Magnetometer,Write a Python script that uses Pytango to connect to a {Device name} Multimeters,,,,,"""""""Implements functionality unique to the Lake Shore Model 425 Gaussmeter.""""""
import serial

from .generic_instrument import GenericInstrument


class Model425(GenericInstrument):
    """"""A class object representing the Lake Shore Model 425 Gaussmeter.""""""

    vid_pid = [(0x1FB9, 0x0401)]

    def __init__(self,
                 serial_number=None,
                 com_port=None,
                 baud_rate=57600,
                 data_bits=7,
                 stop_bits=1,
                 parity=serial.PARITY_ODD,
                 flow_control=False,
                 handshaking=False,
                 timeout=2.0,
                 ip_address=None,
                 tcp_port=7777,
                 **kwargs):

        # Call the parent init, then fill in values specific to the 121
        GenericInstrument.__init__(self, serial_number, com_port, baud_rate, data_bits, stop_bits, parity, flow_control,
                                   handshaking, timeout, ip_address, tcp_port, **kwargs)
"
118,475.0,Rohdes And Schwarz,Rohdeschwarzsma,Pytango,"This Class Handles Rohdes And Schwarz Sma Signal Generators. Supported Model Is: -Sma100A. Signal quality, speed and flexibility these are the criteria by which signal generators are measured today. The R&S SMA100A perfectly meets these criteria, and thus is a premium-class analog generator that sets standards due to its outstanding characteristics.",https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/RohdeSchwarzSMa/index.html,https://github.com/Rohde-Schwarz/Examples/blob/main/SignalGenerators/Python/RsSmab_ScpiPackage/RsSmab_FileTransferWithProgress_Example.py,SMA100A,"[OrderedDict([('id', 'attnFBdOKF66mG3zi'), ('width', 640), ('height', 360), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/ApcDVdYlNrLzvtJCzERnkg/KcNlWVEN0pzUEAEnvY30dnwPX5gGlgoyAUIZqJuKeUCnmw7xwrRhVcXl_xAybc2zE0leS6x-Sb9hzUElpDA1vHIgNwjeed2GJ-aJUteLd77YvIh56IGClUIdDFV4gh9t1bzonHwZK5vkLaK-xBDbdGos_9gaXuUATDZdpyDQCRGKa1NrJ-0_g_1c9wT-kbBm/RC1hEJS6yD8cMGlheepT3ehzfYy1NvvI_rtwKO1ZhB0'), ('filename', 'sma100a-signal-generator-front-view-rohde-schwarz_200_11643_640_360_1.jpg'), ('size', 27478), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Hfirqv4Tws21rGsnMOVvFg/SSlGy1HdgrTxzGqeVZ_T1-QFVYNrjh4gS9oAgCgr1TEYkYk3CnfVBPIHWlbvEIiqC7JtwyIkWdymXVS6HQU21A/3XxXTWljLJobHnFVAI0zqUui51XeiOTT7rtCP4rPhQI'), ('width', 64), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/z85F_ZisgIwP2OCpL9HUgQ/D8b9CmXqUArii4Y2TxCm34MNvmsc1mdMkGHQCBUz6ytF-GOwTe_8StwYY9heOfMRcQyZ5lCfcGpNVvhWU42nnw/Bti2XuP8WUpBOx23jonpcztOGEmo-H8J3h8XpCXDPH4'), ('width', 640), ('height', 360)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/d5QmSdewBe0pRUYYSlncAg/2b841zzSnpku0b3ZDjXGbzxJsCHmiDpOT-U9azOgqEcnFoMlrXvlRpI0TQFuWQnmb-CEkM6LxxFC-ZDxAAERBA/W4HXo7HZqKtkeWGXTV2J4d0c3qwLk542tuVnd-wFMW4'), ('width', 3000), ('height', 3000)]))]))])]",https://www.trsrentelco.com/products/rohde-schwarz-sma100a?utm_source=google&utm_medium=cpc&utm_campaign={campaign}&utm_agid=149466169157&kwd=&ad_type=659559970489&device=c&placement=&match_type=&gclid=CjwKCAjw-vmkBhBMEiwAlrMeF7nEwWEXPs-pvwkAj_KACe-B9wh-YsMCFtR6IjOqYHd6SGWzf_tTIBoCZgkQAvD_BwE&gad=1,['RF Signal Generator'],"[OrderedDict([('id', 'attgThuQed8Zn1CUa'), ('width', 119), ('height', 31), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Kh_q7iTzLAlq_Hc6O5fGqQ/xxyGDb6V8FRiGTbzWUMpRaDI1FvqC_Vv2j-PdmYwYY6LYi-wSugJLACsHaFD_jamsxOaBsQMinwgsSl_kDBkupDH6OWrYUAJHbO9ybXmPvg/UPCupuBncQjB0d93ETVY_auKz6BsqjHav4FhmYwGDcY'), ('filename', 'download (7).png'), ('size', 735), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/WpL_WA1piQ8jl6XqbbPf_A/A7rzi6pJV0EVxj4yn6_Miz7JM957qGWsFENJSZJYFdEyZ2ajsvFZojH6WSYQhk597tyeUyU3ouuRqGnrb6V1Gg/f91g2LwW5_-rKZE6bQ7yO8YA3ty1R2BuQ2wNNupyktU'), ('width', 119), ('height', 31)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/VrADSX9DPMvnbGyudikoNw/b5jxc7_2LYwpUtNHpHGH6EFYr39EAYX_JblJrs61iUIvAd9Tu82hjcv1u6OJglHTwiITXbojbM_LffCPrD5Kdw/VaHCvzo2wUA0VbIeQrbeGczSNJumzlpsgV4ji0tdUa0'), ('width', 119), ('height', 31)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/prg_FUm4s15Qg9KwS5XJUg/mhsJuFRx_ENjz2Ctwiren99Aate5KvNOxvy1G59ei_8ngGJhDnCTF6v4gioWwOjRQKlqsUtoSKWSJAXnGOSE_A/H3hO-pPs-RkSh4DSczASn4yjCNF5Gi5WgehLYYFbVFw'), ('width', 3000), ('height', 3000)]))]))])]","Rohde & Schwarz GmbH & Co KG is an international electronics group specializing in the fields of electronic test equipment, broadcast & media, cybersecurity, radiomonitoring and radiolocation, and radiocommunication.
",https://www.rohde-schwarz.com/ca/home_48230.html,https://scdn.rohde-schwarz.com/ur/pws/dl_downloads/dl_common_library/dl_brochures_and_datasheets/pdf_1/SMA100A_dat-sw_en_5213-6412-22_v0700.pdf,"Munich, Germany",2500.0,"A signal generator is one of a class of electronic devices that generates electrical signals with set properties of amplitude, frequency, and wave shape. These generated signals are used as a stimulus for electronic measurements, typically used in designing, testing, troubleshooting, and repairing electronic or electroacoustic devices, though it often has artistic uses as well",https://en.wikipedia.org/wiki/Signal_generator,Write a Python script that uses Pytango to connect to a SMA100A RF Signal Generator,,,True,,"""""""Example showing how you can transfer a big file to the instrument and from the instrument with showing the progress.
Since the SMA100B is quite fast on data transfer, we slow it down by waiting for 100ms between each chunk transfer (1MB)
This way we see the transfer progress better and we do not need a file that is so big - let's take cca 20MB.
For big files, use the example without the time.sleep(0.1)""""""

import time
import numpy as np
from RsSmab import *


def my_transfer_handler(args):
    """"""Function called each time a chunk of data is transferred""""""
    total_size = args.total_size if args.total_size is not None else ""unknown""
    print(f""Context: '{args.context}{'with opc' if args.opc_sync else ''}', ""
          f""chunk {args.chunk_ix}, ""
          f""transferred {args.transferred_size} bytes, ""
          f""total size {total_size}, ""
          f""direction {'reading' if args.reading else 'writing'}, ""
          f""data '{args.data}'"")
    if args.end_of_transfer:
        print('End of Transfer')
    # Slow down the transfer by 200ms to see the progress better
    time.sleep(0.1)


RsSmab.assert_minimum_version('4.70.300')
smab = RsSmab('TCPIP::10.112.1.64::HISLIP')
print(smab.utilities.idn_string)
smab.utilities.reset()

pc_file = r'c:\temp\bigFile.bin'
instr_file = '/var/user/bigFileInstr.bin'
pc_file_back = r'c:\temp\bigFileBack.bin'

# Generate a random file of 20MB size
x1mb = 1024 * 1024
with open(pc_file, 'wb') as file:
    for x in range(20):
        file.write(np.random.bytes(x1mb))

# Send the file to the instrument with events
smab.events.on_write_handler = my_transfer_handler
smab.utilities.data_chunk_size = x1mb
print(f'Sending file to the instrument...')
smab.utilities.send_file_from_pc_to_instrument(pc_file, instr_file)
smab.events.on_write_handler = None
print(f'Receiving file from the instrument...')
smab.events.on_read_handler = my_transfer_handler
smab.utilities.read_file_from_instrument_to_pc(instr_file, pc_file_back)
smab.events.on_read_handler = None
smab.close()
"
133,223.0,Keithley,Keithley 6485,Pytango,"The 5½-digit Model 6485 Picoammeter combines Keithley’s expertise in sensitive current measurement instrumentation with enhanced speed and a robust design. With eight current measurement ranges and high speed autoranging, this cost effective instrument can measure currents from 2nA to 20mA, taking measurements at speeds up to 1000 readings per second. The Model 6485’s 10fA resolution and superior sensitivity make it well suited for characterising low current phenomena, while its 20mA range lets it measure currents high enough for applications such as measuring 4-20mA sensor loops.",https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/Keithley6485/index.html,https://sourceforge.net/p/tango-ds/code/HEAD/tree/DeviceClasses/MeasureInstruments/Keithley/Keithley6485/trunk/Keithley6485.py,Keithley 6485,,https://canada.newark.com/keithley/6485/dc-picoammeter-bench-2na-to-20ma/dp/42J5237,['Power Meters'],"[OrderedDict([('id', 'att7PoO6FUHxnCmlK'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/g8dQazWWFtzjuY_SfuR2mw/x4Drazo_zJbmXQiu8B-4E7K5tc5YRgHwc0_Id74Y_Jo59o_6f0AIoPr82NqkBETG-pFBV5xTlmYrm3D26bFGbVXKoO3PZoV5JDGpQGRwEVOQRzPOpCNvK4cuHdlrtAsiqqJcYrCJ2dSUYYB4CdfqOw/jKRkUTNDQLrcKtQmrOCEPiiTGOt_bG8fU8UwYuFNmsI'), ('filename', 'keithley-a-tektronix-company-vector-logo.png'), ('size', 4698), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/sr12ul7hLqFdjXP3_badqA/U6tiJCmGyNLJOHGabD_hSQW6Vlb9IKyDeWS1VGYchCEeCCyBVvIdDwZDqiNoepSI1GaMqKNNgjOrJjmPUvG3FQ/GSVsCs-ZKOcmdM4IjvsPZw3I1IH5XmdtksyKRDKzV3c'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/tOrdNEmYqxicjGs17378WQ/4SLCwfH4AIePCqBSSNsKWU3ovMct49gmcW2Q0RTZItPixIPcGyXtfYZV79pIBova7rAgmELpa-B4Z4GRqAftuQ/WuOEXNISn20M6dluJLUE25L1cgkhtVVvbxM_cWx4TPc'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/yzCrD7tfs8RONmym_XQR5g/s263uLffgFd-9vmowfviMNLO4RzbMWf_n-R929zSVnwifujEBHNkB3AmO7RcN0PTIUQ2nPo11AsYEAN5s1sPhQ/X6vcC1w_lSZS1Rgkx0eqvpsfWXVyInMvm95EqR7nSgk'), ('width', 3000), ('height', 3000)]))]))])]","Keithley Instruments is a measurement and instrument company headquartered in Solon, Ohio, that develops, manufactures, markets, and sells data acquisition products, as well as complete systems for high-volume production and assembly testing.
",https://www.tek.com/en,https://www.testequipmenthq.com/datasheets/KEITHLEY-6485-Datasheet.pdf,"Cleveland, Ohio, United States",110.6,"An ammeter (abbreviation of Ampere meter) is an instrument used to measure the current in a circuit. Electric currents are measured in amperes (A), hence the name. For direct measurement, the ammeter is connected in series with the circuit in which the current is to be measured. An ammeter usually has low resistance so that it does not cause a significant voltage drop in the circuit being measured.",https://en.wikipedia.org/wiki/Ammeter,Write a Python script that uses Pytango to connect to a {Device name} Power Meters,4072.7,,,,
166,389.0,Newport,Newportomega,Pytango,"Device Server To Show The Omega Strain Gage From Newport, In A Tango System.",https://www.tango-controls.org/developers/dsc/ds/142/,http://svn.code.sf.net/p/tango-ds/code/DeviceClasses/MeasureInstruments/NewportOmega/trunk/src/newportomega.py,Newportomega,,,,"[OrderedDict([('id', 'attXej1yb0ZjvVVtv'), ('width', 119), ('height', 119), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/aHvQ0YFZO4B_N8gB1pC9KA/CpbV98JoA5eNfc0KkK54TLprYElRVw41eo0-8r54R1CDxuct__8q69K4JnU0AV6F4EbhmEmi7kZ7R7AKyOtHboPv6i9mhGlxEvV6veEoyRc/M-iyzjzev9swHbZ6-JPM6sH4f_f9jG3MCmMkHXrn0kQ'), ('filename', 'download (4).png'), ('size', 1554), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/8NPYyiMVWzq4fHqsJxoe9w/Olr4cPBJL9FGEv3UCc7l2c7x4eiSahS6cNFvrrXBvHvdwQeHs982ePEtMSSs2sTW-jZRu5eMtwd2_1jLKi1Vnw/POCeuOeRurI5O8gnrvL2uGSIf28Uh-kw-0Bio20Phlc'), ('width', 36), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/PMwYSwppghErbn0UCbRHig/wroBULeNtI5gq7jwOrK2vgYfAZYD4SlnWSn_dipNL0xaBIVWwIGs4pqFoNw22OfdE2dZRAChd_LXr3LIO-r15g/c6s8ysRQucIctAKr148JxynJRzpvh5sOSji5wVm71D0'), ('width', 119), ('height', 119)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/leF3e80zmv_xLL7whTEZvw/OYKmd-Xm5LzPvqQepc0FbVzQeRYmAAL4RCDS26HUIsK3QZze9XKUzWNTzNGqBva7tLEMUxHYdr7hW7k3o94Akw/zmgrWkXDbTDIDmWs-OCLsChmtjgJDxFBG9bllrL5-OA'), ('width', 3000), ('height', 3000)]))]))])]","Newport provides a wide range of photonics technology and products designed to enhance the capabilities and productivity of our customers' applications.
",https://www.newport.com/,,"Irvine, California, United States",3500.0,,,Write a Python script that uses Pytango to connect to a {Device name} ,,,,,
206,395.0,Orbit3,Orbit 3 Sensor,Pytango,"Orbit 3 is a wireless sensor for ambient temperature and humidity monitoring. Install Orbit 3 at a suitable location, and it will wirelessly transmit temperature and humidity readings continuously. It can be used in precast factories, concrete laboratories, on-site – or wherever ambient climate creates value for you.",https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/Orbit3Sensor/index.html,https://sourceforge.net/p/tango-ds/code/HEAD/tree/DeviceClasses/MeasureInstruments/Orbit3Sensor/trunk/Orbit3Sensor.py,Orbit 3 Sensor,"[OrderedDict([('id', 'attzyvS9MbjMwlnPo'), ('width', 1024), ('height', 768), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/3KWSdPeuGj9V-UL90sewFQ/T80dEXjuC3MUyRrd8dX1vUbD1sytXVdLzerFYkssks52FZ1MWpMO7rLteeXsoczVyM1QeUv24x9a-poTCAHEF1lojNG9VkdyJ8wN8mJFgFI/V5llnCiGXggT4keHaHxV7HOPGjXth4cuw4pbsQnoZGs'), ('filename', 'Orbi3_05.webp'), ('size', 16610), ('type', 'image/webp'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/F9d-beHkahQOVpbltNoRZQ/oVVCw0Y3l8vxtjcwvTv5WbZaM0nRoSNk3nd_XmAN30pfBbabuvo6fDIhHu-35PK52IUpmmZ8v_KxC09IlXs0ekO1VE8_F2Zx2DcCLMEYtAY/tigzj0yRei_5BwggkdhYsOBFr0CnNpbM58YTHQ13Rvw'), ('width', 48), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/me7m0vU6jc-Ct2ilTmiH5g/BxUjcApdbuoLe-9gJjeWMeILd01ReRs9_gf0QOyhT5i6KlsyK4vBY_bRRwesdVx4lP4-SaqZ05K_pNhpBSElmNKAXPdsGqQnji72s46jhf0/DOInC3RmUnIUPX-ARGDUX_yw4gisD6qnuFjDjLI_BOo'), ('width', 683), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/FAs61tOK3JJVfVFoUy3SPg/q4AFmSKD1iU1Tm9d-G_yF8dwUAgcxh7A2wW1e-K8LRtC9yIxmY3br6sWk2Af_zTVEaPZWslUKWj1611ZG3DLFIAE0Bb_gc6XwEIpV4FNp8Y/L0ODQCktbY1Tmz9bujA8khbDnszk_kGneRMBBYmjEBQ'), ('width', 3000), ('height', 3000)]))]))])]",https://maturix.com/sensors/orbit-3/,,,,,,,,,,Write a Python script that uses Pytango to connect to a {Device name} ,,,,,
251,367.0,Lecroy,"Lecroydso
",Pytango,"This Class Allows The Acquisition Of A Waveform (The Description And The Data), From A Specific C...",https://lecroydso.readthedocs.io/en/latest/,https://github.com/TeledyneLeCroy/lecroydso/blob/main/lecroydso/lecroydso.py,"Lecroydso
",,https://www.teledynelecroy.com/oscilloscope/?utm_source=google&utm_medium=ppc&utm_term=teledyne%20lecroy%20oscilloscope&utm_content=exact_4b&gclid=Cj0KCQjw8NilBhDOARIsAHzpbLBKqasdcqZBnXZ4CpALjE8D5E6K2ECJLx-mU1xBZ1H20NnLN5TKF0kaAlGWEALw_wcB,['Oscilloscopes'],"[OrderedDict([('id', 'att8OZpUeT43PIZJv'), ('width', 2700), ('height', 438), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/esWj5ayGfHwv7E7eSFfKiA/YPvZSh93I3g2f2TnR3sZlsxUEQmeYnuk-cZ5S7TcJAnMgMCu3coueeuX6N7xvoXYPmEyY0FXJuJvo1ayS4Uhtg/1tTuTm6TIz3DXJwQ26iieKTx58oreyeDg-512Iyet5A'), ('filename', '1.jpeg'), ('size', 127698), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/oPrCxh0BQravFxtorbP7oQ/w7Vhsu8lrUDjAMt927bFEcTCj5tHkoIhl-zsdX-LQnmjrNe-Bgm7vo-M7a75m5755Kzg-PYLIMfc6W-YJu8AIQ/ctZkKLWpNYkvs-EX7ysHfHT1R2yK9NZrizC_A4RDog8'), ('width', 222), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/PD6_uvcgYtA_dwXHSxhGIg/rx8qlGovBtsWk3HNjX619-Ggp9xcEzl5yFKclSuy_iWh6oLjCQUSve2EzhHwaUQ8WkreknmpliU9BG6WQqQn0g/VfA6QWdgX_rtrcJyOBUUQZ1hfhOmQByw7vruk3LEYQ8'), ('width', 2700), ('height', 438)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/EQ8O-W6WY1773HUPcSRDag/2thxFInRbYkVm_HzgwLvTs3OYJrgt0W5-0Ih9vqli5Q5dTOrFfVYUy7neWvD2edUD6QQkCJmAlaX7yRKQyx19g/TwOJmk44Yl62Z1_oiVFjUx0W9592hd7DlqcyCVRM5WA'), ('width', 3000), ('height', 3000)]))]))])]","Teledyne LeCroy, Inc. manufactures and distributes electronic measuring instruments. The Company produces analyzers, measurement, and testing solutions including oscilloscopes, production test digitizers, and electronic components. Teledyne LeCroy serves customers worldwide.


",https://www.teledynelecroy.com/,,"s	Chestnut Ridge, New York, USA",178.0,"An oscilloscope (informally scope or O-scope) is a type of electronic test instrument that graphically displays varying voltages of one or more signals as a function of time. The main purpose is capture information on electrical signals for debugging, analysis, or characterization.",https://en.wikipedia.org/wiki/Oscilloscope,Write a Python script that uses Pytango to connect to a {Device name} Oscilloscopes,,,,,"# -----------------------------------------------------------------------------
# Summary:		Implementation of LeCroyDSO class
# Authors:		Ashok Bruno
# Started:		2/9/2021
# Copyright 2021-2024 Teledyne LeCroy Corporation. All Rights Reserved.
# -----------------------------------------------------------------------------

from lecroydso.errors import ParametersError
from lecroydso import DSOConnection
import time
import re
import logging
from datetime import datetime

verbose = 2     # set 1 (or 2)


# ------------------------------------------------------------------------------------
# Class: LeCroyDSO
class LeCroyDSO:
    """"""Communication interface to a LeCroy Oscilloscope

    Args:
        myConnection (DSOConnection): A connection interface to the oscilloscope like ActiveDSO, LeCroyVISA
        log (bool, optional): creates a log output. Defaults to False.
    """"""

    def __init__(self, connection: DSOConnection, log: bool = False):

        self._conn = connection
        self.connected = True
        self.verbose = verbose
        self.logger = None
        if self.connected is True:
            if log:
                self.__createLogger(self._conn.connection_string)

            self._insert_wait_opc = False
            self.init_vbs()

            # determine what model this scope is
            (self.manufacturer, self.model, self.serial_number, self.firmware_version) = self.query('*IDN?').split(',')

            self.available_channels = []
            self.available_digital_channels = []
            self.available_functions = []
            self.available_parameters = []
            self.available_memories = []
            self.available_zooms = []

            try:
                self.execsAll = self.query_vbs('app.ExecsNameAll').split(',')
                # parse this to get numChannels, numFunctions, numMemories, numParameters
                for exec in self.execsAll:
                    if exec.startswith('C'):
                        self.available_channels.append(exec)
                    elif exec.startswith('D'):
                        self.available_digital_channels.append(exec)
                    elif exec.startswith('F'):
                        self.available_functions.append(exec)
                    elif exec.startswith('P'):
                        self.available_parameters.append(exec)
                    elif exec.startswith('M'):
                        self.available_memories.append(exec)
                    elif exec.startswith('Z'):
                        self.available_zooms.append(exec)
            except ValueError:
                # some default values if unable to read the cvar
                self.available_channels = ['C1', 'C2', 'C3', 'C4']
                self.available_digital_channels = ['D1', 'D2', 'D3', 'D4']
                self.available_functions = ['F1', 'F2', 'F3', 'F4']
                self.available_parameters = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6']
                self.available_memories = ['M1', 'M2', 'M3', 'M4']
                self.available_zooms = ['Z1', 'Z2', 'Z3', 'Z4']

            iNumChannels = len(self.available_channels)
            self.is_attenuator_used = True
            if (iNumChannels == 2):
                self.is_attenuator_used = False
            self.get_instrument_max_bandwidth()

    def __del__(self):
        if self.connected:
            self.disconnect_from_dso()
            self.disconnect()

    def __createLogger(self, suffix: str):
        self.logger = logging.getLogger('LeCroyDSO_' + suffix)
        self.logger.setLevel(logging.INFO)

        # create file handler which logs debug messages
        fh = logging.FileHandler('LeCroyDSO_' + suffix + '_' + datetime.now().strftime('%Y_%m_%d') + '.log')
        fh.setLevel(logging.DEBUG)

        # create console handler with a higher log level
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)

        # create formatter and add it to the handlers
        formatter = logging.Formatter('%(asctime)s [%(levelname)s]: %(message)s', datefmt='%m/%d/%Y %H:%M:%S')
        fh.setFormatter(formatter)
        ch.setFormatter(formatter)

        # add the handlers to the logger
        self.logger.addHandler(fh)
        self.logger.addHandler(ch)

    def init_vbs(self):
        """"""Define some 'standard' variables in scope's VBS context, so commands
        are simpler and more efficient.
        After this function is called you can
        """"""
        self.write_vbs('set acq = app.Acquisition')
        self.write_vbs('set acqHorz = acq.Horizontal')
        self.write_vbs('set chans = acq.channels')
        self.write_vbs('set meas = app.Measure')
        self.write_vbs('set math = app.Math')
        self.write_vbs('set zoom = app.Zoom')
        self.write_vbs('set memory = app.Memory')
        self.write_vbs('set syscon = app.SystemControl')

    def validate_source(self, source: str) -> bool:
        """"""Validate the source against Analog and Digital channels

        Args:
            source (str): source to validate

        Raises:
            ParametersError: on Invalid source

        Returns:
            bool: True, when source is valid
        """"""

        if source.upper() in self.available_channels or source.upper() in self.available_digital_channels:
            return True
        raise ParametersError('source not found')

    def validate_channel_source(self, source: str) -> bool:
        """"""Validate the source against Analog channels

        Args:
            source (str): source to validate

        Raises:
            ParametersError: on Invalid source

        Returns:
            bool: True, when source is valid
        """"""
        if source.upper() in self.available_channels:
            return True
        raise ParametersError('Channel source not found')

    def validate_digital_source(self, source: str) -> bool:
        """"""Validate the source against Digital channels

        Args:
            source (str): source to validate

        Raises:
            ParametersError: on Invalid source

        Returns:
            bool: True, when source is valid
        """"""
        if source.upper() in self.available_digital_channels:
            return True
        raise ParametersError('Digital source not found')

    def validate_parameters_source(self, parameter: str):
        """"""Validate the source against paramter sources

        Args:
            parameter (str): source to validate

        Raises:
            ParametersError: on Invalid source

        Returns:
            bool: True, when source is valid
        """"""
        if parameter.upper() in self.available_parameters:
            return True
        raise ParametersError('Parameter source not found')

    def validate_zoom_source(self, zoom: str):
        """"""Validate the source against zoom sources

        Args:
            zoom (str): source to validate

        Raises:
            ParametersError: on Invalid source

        Returns:
            bool: True, when source is valid
        """"""
        if zoom.upper() in self.available_zooms:
            return True
        raise ParametersError('Zoom source not found')

    def disconnect(self):
        if self.connected:
            self.connected = False

    def disconnect_from_dso(self):
        self._conn.disconnect()

    def get_float_value(self, query_cmd: str) -> float:
        """"""Gets value of the VBS command

        Args:
            query_cmd (str): VBS command

        Returns:
            float: value
        """"""
        val = float(self.query_vbs(query_cmd))
        return val

    def get_string_value(self, query_cmd: str) -> float:
        """"""Gets value of the VBS command

        Args:
            query_cmd (str): VBS command

        Returns:
            str: string value
        """"""
        val = self.query_vbs(query_cmd)
        return val.upper()

    @property
    def num_channels(self) -> int:
        """"""readonly Property for number of channels
        """"""
        return len(self.available_channels)

    @property
    def num_digital_channels(self) -> int:
        """"""readonly Property for number of Digital Channels
        """"""
        return len(self.available_digital_channels)

    @property
    def num_functions(self) -> int:
        """"""readonly Property for number of Functions F1 to Fn
        """"""
        return len(self.available_functions)

    @property
    def num_memories(self) -> int:
        """"""readonly Property for number of Memories M1 to Mn
        """"""
        return len(self.available_memories)

    @property
    def num_parameters(self) -> int:
        """"""readonly Property for number of Parameters P1 to Pn
        """"""
        return len(self.available_parameters)

    @property
    def num_zooms(self) -> int:
        """"""readonly Property for number of Zoom Z1 to Zn
        """"""
        return len(self.available_zooms)

    @property
    def query_response_max_length(self) -> int:
        """"""read max length of response string
        """"""
        return self._conn.query_response_max_length

    @query_response_max_length.setter
    def query_response_max_length(self, val: int):
        """"""set the maximum length of the response string from the instrument
        """"""
        self._conn.query_response_max_length = val

    @property
    def insert_wait_opc(self):
        self._insert_wait_opc = self._conn.insert_wait_opc
        return self._insert_wait_opc

    @insert_wait_opc.setter
    def insert_wait_opc(self, val: bool):
        """"""Inserts a OPC command for reads and writes.
        This ensures that the command will execute sequentially.
        The default value for a connection is false.
        NOTE: There is a performance impact by setting this flag

        Args:
            val (bool): True to insert wait_opc, False otherwise.
        """"""
        self._insert_wait_opc = val
        self._conn.insert_wait_opc = val

    @property
    def hor_scale(self) -> float:
        """"""Reads the horizontal scale from the dso
        """"""
        return self.get_hor_scale()

    @hor_scale.setter
    def hor_scale(self, val: float):
        """"""Sets the horizontal scale of the dso
        """"""
        self.set_hor_scale(val)

    @property
    def hor_offset(self) -> float:
        """"""Reads the horizontal offset from the dso
        """"""
        return self.get_hor_offset()

    @hor_offset.setter
    def hor_offset(self, val: float):
        """"""Sets the horizontal offset of the dso
        """"""
        self.set_hor_offset(val)

    @property
    def sample_mode(self) -> str:
        """"""Reads the sample mode of the dso
        """"""
        return self.query_vbs('acqHorz.samplemode')

    @sample_mode.setter
    def sample_mode(self, val: str):
        """"""Sets the sample mode of the dso
        """"""
        self.set_sample_mode(val)

    @property
    def trigger_mode(self) -> str:
        """"""Reads the trigger mode of the dso
        """"""
        return self.get_string_value('acq.TriggerMode')

    @trigger_mode.setter
    def trigger_mode(self, val: str):
        """"""Sets the trigger mode of the dso
        """"""
        self.set_trigger_mode(val)

    @property
    def triggerType(self) -> str:
        """"""Reads the trigger type of the dso
        """"""
        self.get_string_value('acq.Trigger.Type')

    @triggerType.setter
    def triggerType(self, val: str):
        """"""Sets the trigger type of the dso
        """"""
        self.set_trigger_type(val)

    @property
    def trigger_source(self) -> str:
        """"""Reads the trigger source of the dso
        """"""
        return self.get_string_value('acq.Trigger.Source')

    @trigger_source.setter
    def trigger_source(self, val: str):
        """"""Sets the trigger source of the dso
        """"""
        self.set_trigger_source(val)

    @property
    def trigger_coupling(self) -> str:
        """"""Reads the trigger coupling of the dso
        """"""
        self.get_string_value('acq.Trigger.Coupling')

    @trigger_coupling.setter
    def trigger_coupling(self, val: str):
        """"""Sets the trigger coupling of the dso
        """"""
        self.set_trigger_coupling(val)

    def write(self, strCmd: str):
        """"""Sends the command

        Args:
            message (str): command string
        """"""
        self._conn.write(strCmd)

    def write_vbs(self, strCmd: str):
        """"""Sends the command as a VBS formatted comamnd

        Args:
            message (str): command string
        """"""
        self._conn.write_vbs(strCmd)

    def query(self, message: str, query_delay: float = None) -> str:
        """"""Send the query and returns the response

        Args:
            message (string): command to send
            query_delay (float, optional): delay between the command and response. Defaults to None.

        Returns:
            string: Response from the instrument
        """"""
        return self._conn.query(message, query_delay)

    def query_vbs(self, message: str, query_delay: float = None) -> str:
        """"""Send the query as a VBS formatted string and returns the response

        Args:
            message (string): command to send
            query_delay (float, optional): delay between the command and response. Defaults to None.

        Returns:
            string: Response from the instrument
        """"""
        return self._conn.query_vbs(message, query_delay)

    def vbs(self, vbs_command: str, is_query: bool = False, max_length: int = None) -> str:
        """"""vbs command wrapper for read or write

        Args:
            vbs_command (str): vbs command to send
            is_query (bool, optional): Set to Tue if expecting a return value. Defaults to False.
            max_length (int, optional): maximum length of the expected transfer. Defaults to None.
        Returns:
            str: return value of the response
        """"""
        if not is_query:
            self.write_vbs(vbs_command)
            response = 0
        else:
            if max_length is not None:
                self.query_response_max_length = max_length
            response = self.query_vbs(vbs_command)
        return response

    def set_default_state(self):
        """"""Sets the default state of the DSO
        """"""
        self.write_vbs('app.SystemControl.EnableMessageBox = ' + str(0))
        self.write('CHDR OFF')
        self.query('ALST?')
        self.wait_opc()
        self.write('*RST')
        self.write('CHDR OFF')
        self.write_vbs('app.SaveRecall.Setup.DoRecallDefaultPanelWithTriggerModeAuto')
        self.wait_opc()
        self.wait_opc()

    def restart_app(self):
        """"""Restarts the scope application
        """"""
        self.disconnect()
        self.write_vbs('app.Restart')
        # wait and reconnect
        for _ in range(20):
            time.sleep(5)
            self._conn.reconnect()
            if self._conn.connected:
                break
        self.__init__(self._conn, self.logger)

    def acquire(self, timeout: float = 0.1, force: bool = True) -> bool:
        """"""Acquire a waveform

        Args:
            timeout (float, optional): timeout in seconds for the acquisition to wait. Defaults to 0.1.
            force (bool, optional): Forces an acquisition to complete. Defaults to True.

        Returns:
            bool: True for Triggered, False if not Triggered or unknown state
        """"""
        if force:
            self.write_vbs('acq.acquire ' + str(timeout) + ',' + str(force))
            self.wait_opc()
            return True
        else:
            triggered = self.query_vbs('acq.acquire(' + str(timeout) + ')')
            if triggered == '0':
                return False
            elif triggered == '1':
                return True
            else:
                return False

    def get_scope_setup(self, filename: str = None) -> str:
        """"""Reads the instrument control state into a string

        Returns:
            str: panel file returned as a string, trailing terminator removed
        """"""
        setup = self._conn.get_panel()

        if filename is not None:
            setup = setup[0:-8]
            with open(filename, 'w') as f:
                f.write(setup)
        return setup

    def set_scope_setup(self, setup: str, filename: str = None):
        """"""Set the instrument control state using a panel string, typically from the method get_panel

        Args:
            panel (str): description

        Returns:
            bool: True on success, False on failure
        """"""
        if filename is None:
            theSetup = setup
        else:
            with open(filename, 'r') as f:
                theSetup = f.read() + 'ffffffff'

        return self._conn.set_panel(theSetup)

    def get_waveform(self, source: str) -> bytes:
        """"""Get a waveform from the source specified

        Args:
            source (str): Source string 'C1'

        Returns:
            bytes: return the waveform as bytes, may need to processed further to make sense of it
        """"""
        self.validate_source(source)
        self._conn.write('{}:WF?'.format(source))
        time.sleep(0.1)

        # read the first 11 bytes, this gives us the length of the transfer
        header = self._conn.read_raw(15)
        if 'WARNING' in str(header):
            return ''

        tmp = header[6:15]
        # get number of bytes in the response
        bytes = int(tmp.tobytes().decode('utf-8'))

        # read the amount of data
        wf = self._conn.read_raw(bytes)
        return wf

    def transfer_file_to_dso(self, remoteDevice: str, remoteFileName: str, localFileName: str) -> bool:
        """"""Transfers a file from the PC to the DSO

        Args:
            remoteDevice (str): The device name on the instrument end, typically CARD, HDD
            remoteFileName (str): The name and path of the destination file on the instrument
            localFileName (str): The name and path of the source file on the PC

        Returns:
            bool: True on success, False on failure
        """"""
        response = self._conn.transfer_file_to_dso(remoteDevice, remoteFileName, localFileName)
        return response >= 0.0

    def transfer_file_to_pc(self, remoteDevice: str, remoteFileName: str, localFileName: str) -> bool:
        """"""Transfers a file from the DSO to the PC

        Args:
            remoteDevice (str): The device name on the instrument end, typically CARD, HDD
            remoteFileName (str): The name and path of the destination file on the instrument
            localFileName (str): The name and path of the source file on the PC

        Returns:
            bool: True on success, False on failure
        """"""
        response = self._conn.transfer_file_to_pc(remoteDevice, remoteFileName, localFileName)
        return response >= 0.0

    def pava(self, channel: str, measurement: str) -> tuple:
        """"""Sends a PAVA query to the DSO

        Args:
            channel (str): channel index as a str ('C1')
            measurement (str): specifies the PAVA measurement

        Returns:
            tuple: returns (value, status)
        """"""
        result = self.query(channel + ':PAVA? ' + measurement).split(',')
        status = result[2]

        if status.upper() == 'OK':
            value = float(result[1])
        else:
            value = 0.0

        return value, status

    def set_trigger_source(self, source: str):
        """"""Sets the Trigger Source of the DSO

        Args:
            source (str): C1 to Cn, D1 to Dn, EXT, LINE are possible choices

        Raises:
            ParametersError: if the source is not valid
        """"""
        if (source.upper() in ['EXT', 'LINE'] or self.validate_source(source)):
            self.write_vbs('acq.Trigger.source = ""' + source.upper() + '""')
        else:
            raise ParametersError('source not found')

    def set_trigger_mode(self, mode: str):
        """"""Set Trigger Mode of the DSO

        Args:
            mode (str): Set Trigger Mode to ['AUTO', 'NORMAL', 'SINGLE', 'STOPPED'].

        Raises:
            ParametersError: invalid values
        """"""
        if mode.upper() in ['AUTO', 'NORMAL', 'SINGLE', 'STOPPED']:
            self.write_vbs('acq.triggermode = ""' + mode.upper() + '""')
            self.wait_opc()
        else:
            raise ParametersError('TriggerMode not valid')

    def get_trigger_mode(self) -> str:
        """"""Get the Trigger Mode of the DSO

        Returns:
            str: returns the Trigger Mode
        """"""
        mode = self.query_vbs('acq.TriggerMode')
        return mode.upper()

    def get_trigger_type(self) -> str:
        """"""Gets the trigger type of the DSO

        Returns:
            str: Trigger type value
        """"""
        type = self.query_vbs('acq.Trigger.Type')
        return type.upper()

    def set_trigger_coupling(self, channel: str, coupling: str):
        """"""Set the Trigger Coupling of the DSO

        Args:
            channel (str): Channel Source
            coupling (str): Sets the coupling.

        Raises:
            ParametersError: Invalid channel or coupling
        """"""
        if ((channel.upper() in self.available_channels) and (coupling.upper() in ('DC', 'AC', 'LFREJ', 'HFREJ'))):
            self.write_vbs('acq.Trigger.' + channel.upper() + 'Coupling = ""' + coupling.upper() + '""')
        else:
            raise ParametersError('Trigger Coupling not valid')

    def set_holdoff_type(self, type: str):
        """"""Sets the Trigger Holdoff type

        Args:
            type (str): possible values ['OFF', 'TIME', 'EVENTS']
        """"""
        if type.upper() in ['OFF', 'TIME', 'EVENTS']:
            self.write_vbs('acq.Trigger.HoldoffType = ""' + type.upper() + '""')

    def set_holdoff_events(self, numEvents: int = 1):
        """"""Set Trigger Holdoff events

        Args:
            numEvents (int, optional): Sets the number of holdoff events. Defaults to 1.
        """"""
        if 1 <= numEvents <= 1000000000:
            self.write_vbs('acq.Trigger.HoldoffEvents = ' + str(numEvents))

    def set_average_sweeps(self, channel: str, sweeps: int = 1):
        """"""Set the Average number of sweeps for a channel

        Args:
            channel (str): Channel source
            sweeps (int, optional): Number of sweeps. Defaults to 1.

        Raises:
            ParametersError: on invalid channel or number of sweeps
        """"""
        if (self.validate_channel_source(channel) and 1 <= sweeps <= 1000000):
            self.write_vbs('app.acquisition.' + channel.upper() + '.AverageSweeps = ' + str(sweeps))
        else:
            raise ParametersError('Sweeps invalid')

    def clear_sweeps(self):
        """"""Clear Sweeps
        """"""
        self.write_vbs('app.ClearSweeps.ActNow()')

    def set_trigger_level(self, source: str, level: float = 0.0):
        """"""Set the Trigger Level of the DSO

        Args:
            source (str): Channel source
            level (float, optional): Trigger Level of the trigger source. Defaults to 0.0.

        Raises:
            ParametersError: on invalid Channel source
        """"""
        if (source.upper() in ('EXT') or source.upper() in self.available_channels):
            self.write_vbs('acq.Trigger.' + source.upper() + 'Level = ' + str(level))
        elif (source.upper() in self.available_digital_channels):
            group = int(source.upper().replace('D', '')) / 9
            self.write_vbs('app.LogicAnalyzer.MSxxLogicFamily' + str(group) + ' = ""UserDefined""')
            self.write_vbs('app.LogicAnalyzer.MSxxThreshold' + str(group) + ' = ' + str(level))
        else:
            raise ParametersError('source not found')

    def set_digital_hysteresis_level(self, source: str, level: float = 0.1):
        """"""Set Digital Hysteresis Level

        Args:
            source (str): Digital Channel source
            level (float, optional): Hysteresis. Defaults to 0.1.

        Raises:
            ParametersError: on invalid Digital Channel Source and invalid level
        """"""
        if (self.validate_digital_source(source) and level >= .1 and level <= 1.4):
            group = int(source.upper().replace('D', '')) / 9
            self.write_vbs('app.LogicAnalyzer.MSxxLogicFamily' + str(group) + ' = ""UserDefined""')
            self.write_vbs('app.LogicAnalyzer.MSxxHysteresis' + str(group) + ' = ' + str(level), True)
        else:
            raise ParametersError('source not found')

    def set_trigger_type(self, type: str = 'EDGE'):
        """"""Set Trigger Type

        Args:
            type (str, optional): Type of Triger specified as a string. Defaults to 'EDGE'.

        Raises:
            ParametersError: on invalid Trigger Type
        """"""
        if type.upper() in ['EDGE', 'WIDTH', 'QUALIFIED', 'WINDOW', 'INTERNAL', 'TV', 'PATTERN']:
            self.write_vbs('acq.Trigger.type = ' + type.upper())
        else:
            raise ParametersError('source not found')

    def set_trigger_slope(self, channel: str, slope: str = 'POSITIVE'):
        """"""Sets the trigger slope of the DSO

        Args:
            channel (str): Channel source
            slope (str, optional): Typically 'POSITIVE', 'NEGATIVE', 'EITHER'. Defaults to 'POSITIVE'.

        Raises:
            ParametersError: on invalid source or slope
        """"""
        if (slope.upper() in ['POSITIVE', 'NEGATIVE', 'EITHER']):
            if (channel.upper() in self.available_channels):
                self.write_vbs('acq.Trigger.' + channel.upper() + '.slope = ""' + slope.upper() + '""')
            elif channel.uppper in ['EXT', 'LINE']:
                self.write_vbs('acq.Trigger.' + channel.upper() + '.slope = ""' + slope.upper() + '""')
            else:
                raise ParametersError('source not found')
        else:
            raise ParametersError('slope not found')

    def set_coupling(self, source: str, coupling: str = 'DC50'):
        """"""Set the channel coupling of the source specified

        Args:
            source (str): Channel source
            coupling (str, optional): Coupling is typically 'DC50', 'DC1M', 'AC1M', 'GND','DC100k'. Defaults to 'DC50'.

        Raises:
            ParametersError: on invalid Coupling
        """"""
        if coupling.upper() not in ['DC50', 'DC1M', 'AC1M', 'GND', 'DC100k']:
            raise ParametersError('Invalid Coupling')
        if source.upper() in self.available_channels:
            self.write_vbs('app.acquisition.' + source.upper() + '.Coupling = ""' + coupling.upper() + '""')
        else:
            if source.upper() == 'EXT':
                source = 'AUXIN'
            if source.upper() == 'AUXIN':
                self.write_vbs('app.acquisition.' + source.upper() + '.Coupling = ""' + coupling.upper() + '""')

    def set_ver_offset(self, source: str, offset: float = 0.0):
        """"""Sets the vertical offset of the channel

        Args:
            source (str): Channel source
            offset (float, optional): Vertical offset. Defaults to 0.0.

        Raises:
            ParametersError: on invalid channel source
        """"""
        if source.upper() in self.available_channels:
            self.write_vbs('app.acquisition.' + source.upper() + '.VerOffset = ' + str(offset))
        else:
            raise ParametersError('source not found')

    def set_view(self, channel: str, view: bool = True, digitalGroup: str = 'Digital1'):
        """"""Set view on or off

        Args:
            channel (str): Analog or Digital source
            view (bool, optional): True sets view ON. Defaults to True.
            digitalGroup (str, optional): This is ignored if source is analog. If it is a digital source, specifies the group it belongs to. Defaults to 'Digital1'.

        Raises:
            ParametersError: on invalid source or group
        """"""
        if (channel.upper() in self.available_channels):
            self.write_vbs('app.acquisition.' + channel.upper() + '.view = ' + str(view))
        elif (channel.upper() in self.available_digital_channels and digitalGroup.upper() in ('DIGITAL1', 'DIGITAL2', 'DIGITAL3', 'DIGITAL4')):
            self.write_vbs('app.LogicAnalyzer.' + digitalGroup.upper() + '.Digital' + channel.upper()[1:] + ' = ' + str(view))
        else:
            raise ParametersError('source not found')

    def set_bandwidth_limit(self, channel: str, bandwidth: str = 'FULL'):
        """"""Set bandwidth limit for the channel

        Args:
            channel (str): Channel source
            bandwidth (str, optional): possible values are 'FULL', '350MHZ', '200MHZ', '100MHZ', '20MHZ', 'RAW'. Defaults to 'FULL'.

        Raises:
            ParametersError: on invalid channel source or bandwidth limit
        """"""
        if (self.validate_channel_source(channel) and (bandwidth.upper() in ['FULL', '350MHZ', '200MHZ', '100MHZ', '20MHZ', 'RAW'])):
            self.write_vbs('app.acquisition.' + channel.upper() + '.BandwidthLimit = ""' + bandwidth.upper() + '""')
        else:
            raise ParametersError('Invalid bandwidth limit')

    def set_ver_scale(self, channel: str, ver_scale: float = 0.001):
        """"""Set vertical scale for the channel

        Args:
            channel (str): Channel source
            ver_scale (float, optional): vertical scale. Defaults to 0.001.
        """"""
        self.validate_channel_source(channel)
        self.write_vbs('acq.' + channel.upper() + '.VerScale = ' + str(ver_scale))

    def set_ver_scale_variable(self, channel: str, variable: bool = False):
        """"""Set vertical scale variable flag

        Args:
            channel (str): Channel source
            variable (bool, optional): True sets the variable flag to ON and the step of the vertical scale is variable. Defaults to False.
        """"""
        self.validate_channel_source(channel)
        self.write_vbs('acq.' + channel.upper() + '.VerScaleVariable = ' + '1' if variable else '0')

    def set_sample_mode(self, sample_mode: str = 'REALTIME', segments: int = 10):
        """"""Sets the sample mode of the DSO

        Args:
            sample_mode (str, optional): Typical values for sample mode are REALTIME|RIS|ROLL|SEQUENCE. Defaults to 'REALTIME'.
            segments (int, optional): This is used for Sequence mode to set the number of segments. Defaults to 10.
        """"""
        if sample_mode.upper() in ['REALTIME', 'RIS', 'ROLL', 'SEQUENCE']:
            self.write_vbs('acqHorz.samplemode = ""' + sample_mode.upper() + '""')
            if sample_mode.upper() == 'SEQUENCE' and segments >= 2:
                self.write_vbs('acqHorz.numsegments = ' + str(segments))
        else:
            ParametersError('Invalid Sample mode')

    def set_reference_clock(self, reference: str = 'INTERNAL'):
        """"""Set the reference clock of the DSO

        Args:
            source (str, optional): Possible values are INTERNAL|EXTERNAL. Defaults to 'INTERNAL'.

        Raises:
            ParametersError: on invalid reference
        """"""
        if reference.upper() in ('INTERNAL', 'EXTERNAL'):
            self.write_vbs('acqHorz.referenceclock = ""' + reference.upper() + '""')
        else:
            raise ParametersError('Invalid Reference clock')

    def set_hor_scale(self, hor_scale: float):
        """"""Sets the horizontal scale of the DSO

        Args:
            hor_scale (float): Horizontal scale value
        """"""
        self.write_vbs('acqHorz.horscale = ' + str(hor_scale))

    def set_hor_offset(self, hor_offset: float = 0.0):
        """"""Set the Horizontal offset of the scope

        Args:
            hor_offset (float, optional): Horizontal offset value. Defaults to 0.0.
        """"""
        self.write_vbs('acqHorz.horoffset = ' + str(hor_offset))

    def set_num_points(self, num_points: int):
        """"""Set Number of the points for the acquisition

        Args:
            num_points (int): number of points

        """"""
        self.write_vbs('acqHorz.numpoints = ' + str(num_points))

    def set_max_samples(self, max_samples: int):
        """"""Sets the Max Samples possible in the acquisition

        Args:
            max_samples (int): maximum samples value
        """"""
        self.write_vbs('acqHorz.MaxSamples = ' + str(max_samples))

    def set_sample_rate(self, sample_rate: float):
        """"""Set the sample rate to a specific value. This sets the DSO to FixedSampleRate
        memory mode.

        Args:
            sample_rate (float): sample rate value

        Raises:
            ParametersError: on invalid Sample rate
        """"""
        self.set_memory_mode('FIXEDSAMPLERATE')
        self.write_vbs('acqHorz.samplerate = ' + str(sample_rate))
        if self.get_sample_rate() != float(sample_rate):
            raise ParametersError('Invalid Sample Rate')

    def set_memory_mode(self, maximize: str = 'SetMaximumMemory'):
        """"""Set Memory mode of the DSO

        Args:
            maximize (str, optional): Possible values are SETMAXIMUMMEMORY|FIXEDSAMPLERATE. Defaults to 'SetMaximumMemory'.

        Raises:
            ParametersError: on invalid Memory mode
        """"""
        if maximize.upper() in ['SETMAXIMUMMEMORY', 'FIXEDSAMPLERATE']:
            self.write_vbs('acqHorz.maximize = ""' + maximize.upper() + '""')
        else:
            raise ParametersError('Invalid Memory mode')

    def set_hardcopy(self, filename: str = 'wav000.jpg', destination: str = 'EMAIL',
                     area: str = 'DSOWINDOW', orientation: str = 'LANDSCAPE', color: str = 'BW'):
        """"""Set the hardcopy variables

        Args:
            filename (str, optional): filename on the DSO. Defaults to 'wav000.jpg'.
            destination (str, optional): possible destination are CLIPBOARD|EMAIL|FILE|PRINTER|REMOTE. Defaults to 'EMAIL'.
            area (str, optional): possible area are DSOWINDOW|FULLSCREEN|GRIDAREAONLY. Defaults to 'DSOWINDOW'.
            orientation (str, optional): possible orientation are PORTRAIT|LANDSCAPE. Defaults to 'LANDSCAPE'.
            color (str, optional): possible colors are BW|PRINT|STD. Defaults to 'BW'.
        """"""
        if filename is not None:
            self.write_vbs('app.Hardcopy.PreferredFilename = ""' + filename + '""')
        if destination.upper() in ['CLIPBOARD', 'EMAIL', 'FILE', 'PRINTER', 'REMOTE']:
            self.write_vbs('app.Hardcopy.Destination = ""' + destination.upper() + '""')
        if area.upper() in ['DSOWINDOW', 'FULLSCREEN', 'GRIDAREAONLY']:
            self.write_vbs('app.Hardcopy.HardCopyArea = ""' + area.upper() + '""')
        if orientation.upper() in ['PORTRAIT', 'LANDSCAPE']:
            self.write_vbs('app.Hardcopy.Orientation = ""' + orientation.upper() + '""')
        if color.upper() in ['BW', 'PRINT', 'STD']:
            self.write_vbs('app.Hardcopy.UseColor = ""' + color.upper() + '""')

    def hardcopy_print(self):
        """"""Generates a hardcopy
        """"""
        self.write_vbs('app.Hardopy.Print')

    def get_hor_scale(self) -> float:
        """"""Gets the Horizontal scale

        Returns:
            [float]: horizontal scale value
        """"""
        hor_scale = float(self.query_vbs('acqHorz.horscale'))
        return hor_scale

    def get_hor_offset(self) -> float:
        """"""Gets the Horizontal offset

        Returns:
            [float]: horizontal offset value
        """"""
        hor_offset = float(self.query_vbs('acqHorz.horoffset'))
        return hor_offset

    def get_num_points(self) -> float:
        """"""Gets the number of points

        Returns:
            float: Number of points value
        """"""
        num_points = float(self.query_vbs('acqHorz.numpoints'))
        return num_points

    def get_sample_rate(self) -> float:
        """"""Gets the sample rate of the DSO

        Returns:
            float: Sample rate value
        """"""
        sample_rate = float(self.query_vbs('acqHorz.samplerate'))
        return sample_rate

    def get_num_sweeps(self, channel: str) -> int:
        """"""Gets the number of sweeps of the channel specified

        Args:
            channel (str): Channel source

        Returns:
            int: number of values acquired so far
        """"""
        self.validate_source(channel)
        res = self.query_vbs('app.acquisition.' + channel.upper() + '.Out.Result.Sweeps')
        try:
            numSweeps = int(res)
        except ValueError:
            numSweeps = -100
        return numSweeps

    def get_time_per_point(self) -> float:
        """"""Gets the time per point value of the DSO

        Returns:
            float: Time per point value
        """"""
        time_per_point = float(self.query_vbs('acqHorz.timeperpoint'))
        return time_per_point

    def get_ver_scale(self, channel: str) -> float:
        """"""Get Vertical scale of the DSO

        Args:
            channel (str): Channel source

        Returns:
            float: Vertical scale value
        """"""
        self.validate_channel_source(channel)
        verScale = float(self.query_vbs('app.acquisition.' + channel.upper() + '.VerScale'))
        return verScale

    def get_ver_offset(self, channel: str) -> float:
        """"""Gets the vertical offset of the channel

        Args:
            channel (str): Channel source

        Returns:
            float: Vertical offset value
        """"""
        self.validate_channel_source(channel)
        verScale = float(self.query_vbs('app.acquisition.' + channel.upper() + '.VerOffset'))
        return verScale

    def recall_default_panel(self):
        """"""Recall the default setup of the DSO
        """"""
        self.write_vbs('app.SaveRecall.Setup.DoRecallDefaultPanel')
        self.wait_opc()

    def get_serial_number(self) -> str:
        """"""Get the serial number of the DSO

        Returns:
            str: Serial number as a string
        """"""
        self.scopeSerial = self.query_vbs('app.SerialNumber')
        return self.scopeSerial

    def get_instrument_max_bandwidth(self) -> str:
        """"""Gets the maximum bandwidth of the DSO

        Returns:
            str: Maximum bandwidth value
        """"""
        self.maxBandwidth = self.query_vbs('app.InstrumentMaxBandwidth')
        return self.maxBandwidth

    def get_instrument_model(self) -> str:
        """"""Gets the instrument model of the DSO

        Returns:
            str: Instrument model as a string
        """"""
        self.instrumentModel = self.query_vbs('app.InstrumentModel')
        return self.instrumentModel

    def get_firmware_version(self) -> str:
        """"""Gets the firmware version of the DSO

        Returns:
            str: Firmware version as string
        """"""
        self.firmware_version = self.query_vbs('app.FirmwareVersion')
        return self.firmware_version

    def set_measure_statistics(self, on: bool):
        """"""Set the measure statistics on or off

        Args:
            on (bool): True turns on measurement statistics
        """"""
        self.write_vbs('meas.StatsOn = ' + '1' if on else '0')

    def set_measure(self, parameter: str, source1: str, source2: str = 'None', param_engine: str = 'TimeAtLevel', view: bool = True):
        """"""Setup a parameter measurement

        Args:
            parameter (str): Parameter source P1 to Pn
            source1 (str): possible measurement sources
            source2 (str, optional): possible measurement sources. Defaults to 'None'.
            param_engine (str, optional): measurement engine to use. Defaults to 'TimeAtLevel'.
            view (bool, optional): True turns on measurement view. Defaults to True.

        Raises:
            ParametersError: on invalid paramter source
        """"""
        self.validate_parameters_source(parameter)
        self.write_vbs('meas.' + parameter.upper() + '.ParamEngine = ""' + param_engine.upper() + '""')
        self.write_vbs('meas.' + parameter.upper() + '.Source1 = ""' + source1.upper() + '""')
        self.write_vbs('meas.' + parameter.upper() + '.Source2 = ""' + source2.upper() + '""')
        self.write_vbs('meas.View' + parameter.upper() + ' = 1' if view else ' = 0')

    def get_measure_stats(self, parameter: str) -> tuple:
        """"""Reads the measurement statistics values for a parameter

        Args:
            parameter (str): Parameter name P1 to Pn

        Returns:
            tuple: Returns the values (last, max, mean, min, num, sdev, status)

        Raises:
            ParametersError: on invalid paramter source
        """"""
        self.validate_parameters_source(parameter)
        last = self.query_vbs('meas.' + parameter + '.last.Result.Value')
        max = self.query_vbs('meas.' + parameter + '.max.Result.Value')
        mean = self.query_vbs('meas.' + parameter + '.mean.Result.Value')
        min = self.query_vbs('meas.' + parameter + '.min.Result.Value')
        num = self.query_vbs('meas.' + parameter + '.num.Result.Value')
        sdev = self.query_vbs('meas.' + parameter + '.sdev.Result.Value')
        status = self.query_vbs('meas.' + parameter + '.Out.Result.Status')
        self.wait_opc()

        return (last, max, mean, min, num, sdev, status)

    def get_measure_value(self, parameter: str) -> float:
        """"""Gets the last measurement value of a parameter

        Args:
            parameter (str): Parameter source P1 to Pn

        Returns:
            [float]: Last measurement value of the parameter, -999999.99 on error

        Raises:
            ParametersError: on invalid parameter source
        """"""
        self.validate_parameters_source(parameter)
        last = self.query_vbs('meas.' + parameter + '.last.Result.Value')
        try:
            fLast = float(last)
        except ValueError:
            fLast = -999999.99
        return fLast

    def get_measure_mean(self, parameter: str) -> float:
        """"""Gets the mean value of the parameter

        Args:
            parameter (str): Parameter source P1 to Pn

        Returns:
            [float]: Mean value of the parameter, -999999.99 on error

        Raises:
            ParametersError: on invalid parameter source
        """"""
        self.validate_parameters_source(parameter)
        mean = self.query_vbs('meas.' + parameter + '.mean.Result.Value')
        try:
            fMean = float(mean)
        except TypeError:
            fMean = -999999.99
        return fMean

    def set_zoom(self, zoom: str, source: str):
        """"""Sets the zoom function for a channel source

        Args:
            zoom (str): Zoom Channel Source Z1 to Zn
            source (str): Channel source

        Raises:
            ParametersError: on invalid zoom source
        """"""
        self.validate_source(source)
        self.validate_zoom_source(zoom)
        self.write_vbs('zoom.' + zoom.upper() + '.Source = ""' + source.upper() + '""')
        self.write_vbs('zoom.' + zoom.upper() + '.View = ' + str(-1))

    def show_zoom(self, zoom: str, show: bool = True):
        """"""Set the zoom trace view on or off

        Args:
            zoom (str): Zoom Channel Source Z1 to Zn
            show (bool, optional): True to view the zoom trace. Defaults to True.

        Raises:
            ParametersError: on invalid zoom source
        """"""
        self.validate_zoom_source(zoom)
        self.write_vbs('zoom.' + zoom.upper() + '.View = ' + str(-1) if show else str(0))

    def set_zoom_segment(self, zoom: str, startSeg: int = 1, numToShow: int = 1):
        """"""Set the Zoom segment for sequence mode waveforms

        Args:
            zoom (str): Zoom Channel Source Z1 to Zn
            startSeg (int, optional): Start segment index. Defaults to 1.
            numToShow (int, optional): Number of segments to display. Defaults to 1.

        Raises:
            ParametersError: on invalid zoom source
        """"""
        self.validate_zoom_source(zoom)
        self.write_vbs('zoom.' + zoom.upper() + '.Zoom.SelectedSegment = ""' + str(startSeg) + '""')
        self.write_vbs('zoom.' + zoom.upper() + '.Zoom.NumSelectedSegments = ""' + str(numToShow) + '""')

    def set_aux_mode(self, mode: str):
        """"""Set the Auxilary mode

        Args:
            mode (str): Auxilary mode value, Possible values are: TRIGGERENABLED|TRIGGEROUT|PASSFAIL|FASTEDGE|OFF

        Raises:
            ParametersError: on invalid Auxilary mode values
        """"""
        if mode.upper() in ['TRIGGERENABLED', 'TRIGGEROUT', 'PASSFAIL', 'FASTEDGE', 'OFF']:
            self.write_vbs('app.Acquisition.AuxOutput.AuxMode = ""' + mode.upper() + '""')
        else:
            raise ParametersError('Invalid Auxilary Mode value')

    def set_show_measure(self, show: bool = True):
        """"""Opens the measure dialog

        Args:
            show (bool, optional): True to open and False to close. Defaults to True.
        """"""
        self.write_vbs('meas.ShowMeasure = 1' if show else 'meas.ShowMeasure = 0')

    def set_auxin_attenuation(self, attenuation: str = 'X1'):
        if attenuation.upper() in ['X1', 'DIV10']:
            self.write_vbs('app.acquisition.AuxIn.Attenuation = ""' + attenuation + '""')

    def wait_opc(self):
        """"""Wait for the previous operation to complete
        """"""
        self._conn.wait_opc()

    def sleep(self, tm: float):
        """"""Sends a sleep command to the instrument

        Args:
            tm ([float]): time to sleep in
        """"""
        self.write_vbs('app.Sleep {0}'.format(tm))

    def force_trigger(self):
        """"""Forces a trigger on the instrument
        """"""
        self.write('FRTR')

    def is_popup_dialog_open(self) -> bool:
        """"""Checks if a popup dialog is open

        Returns:
            [bool]: True if a popup dialog is open, False otherwise
        """"""
        response = self.query_vbs('not syscon.dialogontop.widgetpageontop.value is Nothing')
        return re.match('0', response) is None

    def close_popup_dialog(self):
        """"""Closes any popup dialogs that are open
        """"""
        self.write_vbs('syscon.DialogOnTop.ClosePopup')

    def click_popup_dialog(self, popup_action: str):
        """"""Key Action on Popup Dialog

        Args:
            popup_action (str): Popup action string
        """"""
        self.write_vbs('syscon.DialogOnTop.{0}'.format(popup_action))

    def get_docked_dialog_page_names(self, rhs: bool = False) -> list:
        """"""Gets a list of the docked dialog pages

        Args:
            rhs (bool, optional): True to return the right hand side dialogs. Defaults to False.

        Returns:
            list: of page names, None if no docked dialogs are open
        """"""
        response = self.query_vbs('syscon{0}.DialogPageNames'.format('.Right' if rhs else ''))
        return None if 'none' in response.lower() else response.split(',')

    def get_docked_dialog_selected_page(self, rhs: bool = False) -> str:
        """"""Gets docked selected page

        Args:
            rhs (bool, optional): True to return the right hand side selected page. Defaults to False.

        Returns:
            str: returns the page name of the selected page, None if no docked dialogs are open
        """"""
        response = self.query_vbs('syscon{0}' + '.Right' if rhs else '' + 'DialogPage')
        return None if response == '' else response

    def is_docked_dialog_open(self, rhs: bool) -> bool:
        """"""Checks if a docked dialog is open

        Args:
            rhs ([bool]): True to check if right hand side dialog is open

        Returns:
            bool: Returns True if a docked dialog is open else False
        """"""
        strPage = self.get_docked_dialog_selected_page(rhs)
        return strPage.len > 0

    def close_docked_dialog(self):
        """"""Closes the docked dialog page
        """"""
        self.write_vbs('syscon.CloseDialog')

    def is_option_enabled(self, option: str) -> bool:
        """"""Checks if the option specified is enabled

        Args:
            option (str): Option string

        Returns:
            bool: True if option present else False
        """"""
        response = self.query('$$OP_PRE? {0}'.format(option))
        return response != '0'

    def get_automation_items(self, collection_name: str, filter_spec: list = [('name', None)], match_all: bool = True) -> list:
        """"""Gets a list of automation collection items matching the specified criteria.

        Args:
            collection_name (str): must be a valid automation collection name within the scope app's VBS context.
            filter_spec (list, optional): list of 2-tuples, where the first tuple item specifies the name of an
                automation property and the second specifies a matching regex, may be None which matches all. Defaults to [('name', None)].
                filter_spec, by default, causes the returned list to contain the names of all items in the collection.
            match_all (bool, optional): [description]. Defaults to True.

        Returns:
            [list]: list of automation collection items
        """"""

        # build a vbs function in the scope context that will generate the comma-sep properties string for each item in the collection.
        # we'll apply the matching specs in python after parsing the responses, since it's much better at that and developing/maintaining/debugging
        # these scope vbs functions is horrible.
        prop_names = [prop_item[0] for prop_item in filter_spec]
        get_props_script = ['function getProps(o)']
        get_props_script.append('on error resume next')
        get_props_script.append('strProps = \'\'')
        for prop_name in prop_names:
            get_props_script.append('strProps = strProps & \',\'')  # default to comma-sep if property doesn't exist
            get_props_script.append('strProps = strProps & o.{0}'.format(prop_name))
        get_props_script.append('getProps = strProps')
        get_props_script.append('end function')
        script_to_exec = ':'.join(get_props_script)
        self.write_vbs(script_to_exec)

        # build the vbs query that iterates the collection calling the vbs function for each item, semi-colon sep each item's properties.
        if False:
            # at least for now, for-each (IEnumVARIANT) is not correctly supported on CE... seems to be missing marshalling
            response = self.query(""vbs? 'strProps = \""\"": for each obj in {0}: strProps = strProps & \"";\"" & getProps(obj): next: return = strProps'"".format(collection_name))
        else:
            # work-around for bad for-each behavior on CE.
            # painful: need to figure out if collection is 0-based index or not and set the startIndex and stopIndex variables used in query.
            vbs_statements = ['on error resume next']
            vbs_statements.append('set o1 = nothing')
            vbs_statements.append('set o1 = {0}.item(0)'.format(collection_name))
            vbs_statements.append('stopIndex = {0}.count'.format(collection_name))
            vbs_statements.append('startIndex = 1')
            vbs_statements.append('if not o1 is nothing then: startIndex = 0: stopIndex = stopIndex - 1: end if')
            vbs_statements.append('on error goto 0')
            vbs_to_exec = ':'.join(vbs_statements)
            self.write_vbs(vbs_to_exec)
            response = self.query(""vbs? 'strProps = \""\"": for i = startIndex to stopIndex: set obj = {0}(i): strProps = strProps & \"";\"" & getProps(obj): next: return = strProps'"".format(collection_name))

        # parse the response, stripping and splitting on the item and property separators.
        # strip leading semi-colon and split to get list of comma-sep property strings for each object
        props_response = response.lstrip(';').split(';')
        output_items = []
        for props in props_response:

            # strip leading command and split to get list of properties
            list_props = props.lstrip(',').split(',')
            output_props = []
            props_matched = 0
            for idx in range(0, len(list_props)):

                if idx < len(filter_spec):
                    str_prop = list_props[idx]
                    str_output = ''
                    if (filter_spec[idx][1] is None or filter_spec[idx][1].search(str_prop)):
                        props_matched += 1
                        str_output = str_prop

                    # add to output list of properties
                    output_props.append(str_output)

            if (match_all and props_matched == len(filter_spec)) or (not match_all and props_matched > 0):
                # add to output list of objects
                output_items.append(output_props)

        if self.verbose == 3:
            # print to pyconsole if verbose mode 3
            message = 'get_automation_items({0}, {1}):response={2} => {3}'.format(collection_name, filter_spec, response, output_items)
            self.logger.debug(message)

        return output_items

    def get_object_names(self, coll_name: str, matching: str = None) -> list:
        """"""return a list of all matching object names (in specified coll_name collection).

        Args:
            coll_name (str): Collection name
            matching (str, optional): If no match is specified then all are returned. Defaults to None.

        Returns:
            list: matching object names
        """"""
        objects_into = self.get_automation_items(coll_name, [('name', matching)])
        object_names = [obj_info[0] for obj_info in objects_into]
        return object_names

    def does_object_exist(self, coll_name: str, object_name: str) -> bool:
        """"""Tests if the object exists in the collection

        Args:
            coll_name (str): Collection name
            object_name (str): object name

        Returns:
            bool: True if specified coll_name has the specified object, False if it does not.
        """"""
        cvars_info = self.get_automation_items(coll_name, [('name', re.compile('^{0}$'.format(object_name), re.IGNORECASE))])
        return len(cvars_info) > 0

    def does_cvar_exist(self, object_name: str, cvar_name: str) -> bool:
        """"""Tests if the cvar exists in an automation object

        Args:
            object_name (str): Object name
            cvar_name (str): Cvar name

        Returns:
            bool: True if specified object_name has the specified cvar, False if it does not.
        """"""
        cvars_info = self.get_automation_items(object_name, [('name', re.compile('^{0}$'.format(cvar_name), re.IGNORECASE))])
        return len(cvars_info) > 0

    def is_cvar_enum_value_in_range(self, cvar_enum_name: str, enum_value: str, range_property: str = 'RangeStringAutomation') -> bool:
        """"""Tests if Cvar enum value is in range

        Args:
            cvar_enum_name (str): Cvar enum name
            enum_value (str): Value of the enum
            range_property (str, optional): Range property. Defaults to 'RangeStringAutomation'.

        Returns:
            [bool]: True if cvar is in range else False
        """"""
        response = self.query_vbs('{0}.{1}'.format(cvar_enum_name, range_property))
        return re.search(r'(^|,){0}(,|$)'.format(enum_value), response, re.IGNORECASE)

    def get_cvars_info(self, automation_path: str) -> zip:
        """"""Get Cvar Info for the automation path specified

        Args:
            automation_path (str): Automation path

        Returns:
            zip: zip object containing list of cvar names, types and flags (3-tuple) for the specified automation object.
        """"""
        self.write_vbs('s1 = \'\'')     # for some reason, doing this in the query_vbs isn't sufficient... ugh
        response = self.query_vbs('s1 = \'\': for i=0 to {0}.count - 1: set ocv={0}.Item(i): a1 = Array(s1, ocv.name, ocv.type, ocv.flags): s1 = Join(a1, \',\'): next: return = s1'.format(automation_path))
        # convert to list and remove 0th element due to extra comma (this is easier than in the VBS code above)
        lTokens = response.upper().split(',')[1:]
        iterTokens = iter(lTokens)
        return zip(iterTokens, iterTokens, iterTokens)

    def get_panel_cvar_names(self, automation_path: str) -> list:
        """"""Return list of cvar names for cvars that are eligible for save in panel

        Args:
            automation_path ([str]): Automation start path

        Returns:
            [list]: Returns the Cvar names
        """"""
        # CvarsValuesRemote property returns comma-sep list of cvar,name pairs for all cvars
        # that are eligible for the panel
        response = self.query_vbs('{0}.CvarsValuesRemote'.format(automation_path))
        lTokens = response.upper().split(',')
        # slice-spec to create a list containing every other element
        return lTokens[::2]

    def get_automation_cvar_names(self, automation_path: str) -> list:
        """"""Return list of cvar names for cvars that are available to the user

        Args:
            automation_path (str): Automation start path

        Returns:
            [list]: Returns the Cvar names
        """"""
        # these are the panel cvars and any that have cvarflags 16384 (ForcePublic)
        lPanelCvars = self.get_panel_cvar_names(automation_path)
        lCvarsInfo = self.get_cvars_info(automation_path)
        lForcePublic = [cvName for (cvName, cvType, cvFlags) in lCvarsInfo if int(cvFlags) & 16384 == 16384]
        lPanelCvars.extend(lForcePublic)
        return lPanelCvars
"
277,343.0,Lakeshore,LKS 425 Gaussmeter,Pytango,"Lake Shore Model 425 gaussmeter provides high-end functionality and performance in an affordable desktop instrument. Magnet testing and sorting have never been easier. When used in combination with the built-in relay and audible alarm features, the Model 425 takes the guesswork out of pass/fail criteria. Additional features including DC to 10 kHz AC frequency response, max hold and relative measurement make the Model 425 the ideal tool for your manufacturing, quality control and R&D flux density measurement applications. Put the Model 425 gaussmeter to use with confidence knowing it’s supported by industry leading experts in magnet measurement instrument, sensor, and Hall probe technology.",https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/LKS425Gaussmeter/index.html,https://github.com/lakeshorecryotronics/python-driver/blob/main/lakeshore/model_425.py,LKS 425 Gaussmeter,"[OrderedDict([('id', 'attqoQm3frhx3s4le'), ('width', 505), ('height', 268), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Hv_KCFfjqViIR8ra45enFA/Wd1AnNm4TIvt4Y-cXMoUlbxvKvBjr1OIu0hIv6MLEa9e0aDWfvRptNZQHVdMuwRI681NjikTkSPdQJM_NFrP6Q/FeJc-ZJQk78GYotv2shRJi5Lm7tMf86CrlKCu0Tk76U'), ('filename', '425.png'), ('size', 159132), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Jds-XMXNYpuYUk_AvEck5w/mQTMz_guVEd5SN5Jr-5bzUQ9yRu965BJyiSXNIb0K7uulKFecHUdccRyPVcv9sjnkGuDqp4bWGZp_Vb7QYFpQA/JNj39EOP_XGtINBly5NimNDu4cLVNDMGL8HTUBca2Bo'), ('width', 68), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/Qwfamu6GSleGN1jeiRAtJA/DHMda3Qp7-33HKKg3K7tWSwNGWmquycSKrcTGAhlqZXa0ZHtVBckamQx-lhcRIX4pHVEqy0nM-WHH_g912oOCw/cDQr_lj1le027XmTpwEMwGas702M7swZY440M3o7zMI'), ('width', 505), ('height', 268)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/KY0sNgkoCKgM5ujoW3Q2wA/xIUjGtAgm77wgZDlQTcsJ8a1tVNZ0vONp8meXI_1PhUSS3gt8sC9mb58y9VxHU0-ixC9oz5TXbwDd80iznKuwA/o-_LbZOIOSrhdsCnKvLDjOHr2LWqODrre9WI6aHYdUM'), ('width', 3000), ('height', 3000)]))]))])]",https://www.lakeshore.com/products/categories/overview/magnetic-products/gaussmeters-teslameters/model-425-gaussmeter,['Power Meters'],"[OrderedDict([('id', 'attzehTVrrXJAMgad'), ('width', 256), ('height', 72), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/t5_PKcjJCYO5FhsE-R1DEQ/Vg0kt2Ai3FT2GFjQ04jf5sB1VmcRqtM5xgsoRmjz1p-VCyhCE9qyqjJ9YjdF06kkNj9BeysK4XT95tu3hWhI-hBazH6gAg6YWlVr78orm8U/9DitSfl0sMOC7VOSMZZ68e7TnbhGVKN26HMqSJTScjE'), ('filename', 'lake-shore-logo.svg'), ('size', 11991), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/C4mzUdB4lLLO1fef507Egg/LWvbW57bgKW9S7lmWIlThSsJ6A_4ektFk_PF0Jj8AYL49oiG8xXtzpZYRW__AaGTAoM6ibcNNqV3rPAgsFdS5eeNp59ZJ2TG0-BtCmKdQYg/oOJ-zQ9tH9Jvm1Pp0WsAcmO9leUjCFKlUEICLsCgTVk'), ('width', 128), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/mhTP4mS7q0StLsAsqWYvCA/X-1YPOSh0ulVfM1PZniSw90R6i3cnqVBnyfKCs8A17gyse-uEB4Ik-e5Ihy4kHFmskm03E-q3seFtDtGi4pQP2rGkZ1yFRylZfHoC7p8Om0/9smBV3bkKYzMSCtzCMa0VTbB9YgVJcpJabQbtiW6_aw'), ('width', 256), ('height', 72)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/JLEXW0y4Zbnm4eBmjqVKpQ/bo9ST37pn71_ugm_FSSXCmf9u3rk5tYKkG15j03j5WVhorr-MgJmgbYbI_ImbSOsqt5X76_lGs49wBagk49K9AKR22RGpS7fDjLZ72FhGzU/zbkMdPVEOGGNpLx1C9B3ArZou9Ntj4wrTWDrqsLXUSQ'), ('width', 3000), ('height', 3000)]))]))])]","Supporting advanced scientific research, Lake Shore is a leading global innovator in measurement and control solutions.
",https://www.lakeshore.com/home,https://www.lakeshore.com/docs/default-source/product-downloads/catalog/425.pdf?sfvrsn=1581d8be_6,"Westerville, Ohio, USA",21.4,"A magnetometer is a device that measures magnetic field or magnetic dipole moment. Different types of magnetometers measure the direction, strength, or relative change of a magnetic field at a particular location. A compass is one such device, one that measures the direction of an ambient magnetic field, in this case, the Earth's magnetic field. Other magnetometers measure the magnetic dipole moment of a magnetic material such as a ferromagnet, for example by recording the effect of this magnetic dipole on the induced current in a coil.",https://en.wikipedia.org/wiki/Magnetometer,Write a Python script that uses Pytango to connect to a {Device name} Power Meters,2315.0,,,,"""""""Implements functionality unique to the Lake Shore Model 425 Gaussmeter.""""""
import serial

from .generic_instrument import GenericInstrument


class Model425(GenericInstrument):
    """"""A class object representing the Lake Shore Model 425 Gaussmeter.""""""

    vid_pid = [(0x1FB9, 0x0401)]

    def __init__(self,
                 serial_number=None,
                 com_port=None,
                 baud_rate=57600,
                 data_bits=7,
                 stop_bits=1,
                 parity=serial.PARITY_ODD,
                 flow_control=False,
                 handshaking=False,
                 timeout=2.0,
                 ip_address=None,
                 tcp_port=7777,
                 **kwargs):

        # Call the parent init, then fill in values specific to the 121
        GenericInstrument.__init__(self, serial_number, com_port, baud_rate, data_bits, stop_bits, parity, flow_control,
                                   handshaking, timeout, ip_address, tcp_port, **kwargs)
"
297,416.0,Pico Technology ,PT 104 Picoch,Pytango,The PT-104 is a four-channel temperature measuring data logger. It offers the ultimate in resolution (0.001 °C) and accuracy (0.015 °C). Along with temperature it can also be used to measure resistance.,https://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/tango-ds/MeasureInstruments/PT104Pico/index.html,https://github.com/picotech/picosdk-usbpt104-matlab-examples/blob/master/USBPT104Example.m,PT 104 Picoch,"[OrderedDict([('id', 'attiSwWMUoYEaVdb8'), ('width', 350), ('height', 175), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/lLN1dCjoYN8dIJWTQMuaGQ/70tichdSntqS0eu7q8CghXnybecipYWIgmj6QFa9SIWCSs9nKzKSK3OvyW7S_7SGP5OuKKNI3UPKQCqXpSLHJAeg82yBlrrfLlPrwqJN520/HAFqmwqYnPo1i5CvBYV09AUqw7nEliyBQ8fh9jarnik'), ('filename', 'pt104_35.jpg'), ('size', 7263), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/rS2bR8N2dS7LkBnDbYa5ww/PDyL9UMP8zomWQnuQtV8D6RwKVGZGAOcLp0Hvv8sLoKquz_bslAOkksdfVIcMAq0JcyfSofe7CMYHJCSfosM8g/8MHcbhRAiRToSIfmbgfUU7h8zCTqRfTv30yI2G8hR1Q'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/DgIsaGHyS3uggIoT-_FcTQ/K_tE8JFXcEOvfjyddI2w6RNTXqgg1ZmoYQrn2t7PhqBrnl-MPqoYBcqpWm5f9eB-9l2q4gfbbXssSKWkl-b2nw/h0QAerpVv0Iay76EEUoqMxCvclqN4hwRUI70ZqR3PmA'), ('width', 350), ('height', 175)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/rJrIdVeSfvlAAQsVSe2V0g/NNDeX16J_4zaQ-I6fANa15gf3FRqWRtbNUIq02hmcQNBYLFwjW_mr_07B5GCnU408W8F72ZwXeZ2kIdIiTfiQw/z60U6n5TC__B_mIf6F_AR1mA8teMVdpJ5ond1pX0rso'), ('width', 3000), ('height', 3000)]))]))])]",https://www.picotech.com/data-logger/pt-104/high-accuracy-temperature-daq,['Thermometer'],"[OrderedDict([('id', 'attlBZbcdzvNqgFdf'), ('width', 142), ('height', 71), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/vA7xqQ-avFItQ2K1GjFVag/UeBuUIhpMt66g_yOhSusdjWYxXDOJTAEm6XnuISURIbW77vg8nmAtGMBYlTwk8cE2d9eu6FG27aNKZS7K69W3ITst1bJM9p1FRa0lGgK07o/jaFyZ-HKQqsnZHb6tRV80oLoJvW3_2m0elesXDGzgpQ'), ('filename', 'pico-logo.svg'), ('size', 13692), ('type', 'image/svg+xml'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/OT2UZ3dSup2Y_OHR6W5C0w/HPt9SH-aMFaTVFIDdaoKtNuJBYDGNglor49FQJwMZNo0eu0cPMG3283pvrY9rzpxp9jra0iOKndyLYYqMeqOMNH7Codk7L1u-tqzYxrTT9o/DKbai_YUAtS_RFKl3GIaYe_orG1aKiQw0MFTTfsREJ4'), ('width', 72), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/55Afe82E_nH8pxXIqbObkA/bHdQr1OmNi0M0uZIdeeCgyce7a0dafdSWeDC-AO2-PZoHNI-mmNgNkNaTPfDEDJ9xzRyGaJnyAUXZRuWEF5PTwebsAtVIy6eRaJwuKqnx5s/aD7VPaLLENIosYM3a10UYiIRpuizUVKy8elMOeEWPAc'), ('width', 142), ('height', 71)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/jRC7hGJRc0l28xoWI41G9w/wZlKnon-4Rf1drzgSKX54eubA2iOfrbkQQbOIqkpYarn-aot6s4dPFxX2lvoomhAgvbbBJBimEtAZTLBVw--4QcSdXnS4-u2Nyp-3iNZsqY/qrVDl98DVa6cq8WTn7QZyeOq6vR2Qohh54mPbWNHLxA'), ('width', 3000), ('height', 3000)]))]))])]","Pico Technology was established in 1991 and soon became a leader in the field of [PC Oscilloscopes](https://www.picotech.com/products/oscilloscope) and [data loggers](https://www.picotech.com/products/data-logger).
Pico has always been recognized for providing innovative, cost-effective alternatives to traditional test equipment and data acquisition products. In doing so, we have made high-quality instrumentation affordable.
",https://www.picotech.com/,https://www.picotech.com/download/datasheets/usb-pt-104-prt-data-logger-data-sheet.pdf,"Texas, United States",24.0,"A thermometer is a device that measures temperature or a temperature gradient (the degree of hotness or coldness of an object). A thermometer has two important elements: (1) a temperature sensor (e.g. the bulb of a mercury-in-glass thermometer or the pyrometric sensor in an infrared thermometer) in which some change occurs with a change in temperature; and (2) some means of converting this change into a numerical value (e.g. the visible scale that is marked on a mercury-in-glass thermometer or the digital readout on an infrared model). Thermometers are widely used in technology and industry to monitor processes, in meteorology, in medicine, and in scientific research.",https://en.wikipedia.org/wiki/Thermometer,Write a Python script that uses Pytango to connect to a {Device name} Thermometer,600.0,,,,"%% USB PT-104 Platinum Resistance Temperature Data Logger Example
%
% This script demonstrates how to:
%
% * Enumerate devices connected to the PC
% * Open a connection to a USB PT-104 data logger
% * Display unit information
% * Set mains rejection
% * Configure a channel
% * Take readings
% * Plot data
% * Close the connection to the unit
%
% Please refer to the
% <https://www.picotech.com/download/manuals/usb-pt104-rtd-data-logger-programmers-guide.pdf PT-104 USB/Ethernet RTD Data Logger Programmer's Guide> for further information.
% This file can be edited to suit application requirements.
%
% *Copyright:* � 2016-2017 Pico Technology Ltd. See LICENSE file for terms.

%% Close any open figures, clear console window

close all;
clc;
clear;

disp('USB PT-104 Platinum Resistance Data Logger Example')

%% Load configuration information

USBPT104Config;

%% Load shared library

% Indentify architecture and obtain function handle for the correct
% prototype file.
    
archStr = computer('arch');

usbpt104MFile = str2func(strcat('usbpt104MFile_', archStr));

if (ismac())
    
    [usbpt104NotFound, usbpt104Warnings] = loadlibrary('libusbpt104.dylib', usbpt104MFile, 'alias', 'usbpt104');
    
    % Check if the library is loaded
    if ~libisloaded('usbpt104')
    
        error('USBPT104Example:LibaryNotLoaded', 'Library libusbpt104.dylib not loaded.');
    
    end
    
elseif (isunix())
    
    [usbpt104NotFound, usbpt104Warnings] = loadlibrary('libusbpt104.so', usbpt104MFile, 'alias', 'usbpt104');
    
    % Check if the library is loaded
    if ~libisloaded('usbpt104')
    
        error('USBPT104Example:LibaryNotLoaded', 'Library libusbpt104.so not loaded.');
    
    end

elseif (ispc())
    
    [usbpt104NotFound, usbpt104Warnings] = loadlibrary('usbpt104.dll', usbpt104MFile);

    if ~libisloaded('usbpt104')

        error('USBPT104Example:LibaryNotLoaded', 'Library usbpt104.dll not loaded.');

    end
    
else
    
    error('USBPT104Example:OSNotSupported', 'Operating system not supported, please contact support@picotech.com');

end

%% Enumerate units
% Identify any PT-104 units connected via USB and Ethernet

details             = blanks(100);
detailsLth          = length(details);
communicationType   = usbpt104Enuminfo.enCommunicationType.CT_ALL;

fprintf('\nEnumerating units...\n');

[status.enumerateUnits, details, detailsLth] = calllib('usbpt104', 'UsbPt104Enumerate', details, detailsLth, communicationType);

if (status.enumerateUnits == PicoStatus.PICO_OK)
   
    fprintf('Details: %s\n', details);
    
else
    
    error('USBPT104Example:EnumerateUnitsError', 'Enumerate units status code: %d', status.enumerateUnits);
    
end

%% Open communication
% In this example, a connection is opened via USB

handlePtr = libpointer('int16Ptr', 0);
serial    = [];

status.open = calllib('usbpt104', 'UsbPt104OpenUnit', handlePtr, serial);

if (status.open == PicoStatus.PICO_OK)

    handle = get(handlePtr, 'Value');
    
elseif (status.open == PicoStatus.PICO_NOT_FOUND)
   
    error('USBPT104Example:UnitNotFound', 'USB PT-104 Unit not found.');
    
else
    
    error('USBPT104Example:OpenUnitError', 'Open unit status code: %d', status.openUnit);
    
end

%% Display unit information

fprintf('\nUnit information:-\n\n');

information = {'Driver version: ', 'USB Version: ', 'Hardware version: ', 'Variant: ', 'Batch/Serial: ', 'Cal. date: ', 'Kernel driver version: '};

pRequiredSize = libpointer('int16Ptr', 0);

status.unitInfo = zeros(length(information), 1, 'uint32');

% Loop through each information type
for n = 1:length(information)
    
    infoLine = blanks(100);

    [status.unitInfo(n), infoLine1] = calllib('usbpt104', 'UsbPt104GetUnitInfo', handle, infoLine, length(infoLine), pRequiredSize, (n-1));
    
    if (status.unitInfo(n) == PicoStatus.PICO_OK)
    
        disp([information{n} infoLine1]);
    
    end
    
end

fprintf('\n');
    
%% Noise Rejection

status.setMains = calllib('usbpt104', 'UsbPt104SetMains', handle, 0); % 0 for 50 Hz, 1 for 60 Hz

%% Set channel
% Set channel 1 for a PT-100 sensor

channel1    = usbpt104Enuminfo.enUsbPt104Channels.USBPT104_CHANNEL_1;
dataType    = usbpt104Enuminfo.enUsbPt104DataType.USBPT104_PT100; 

status.setChannel = calllib('usbpt104', 'UsbPt104SetChannel', handle, channel1, dataType, 4); %handle, channel, data type, noOfWires

pause(2) % Wait for device to make conversion before going on to get value or no value will show.

%% Get value
% Retrieve filtered data value for channel 1.
% The data value returned will be a scaled value (refer to the function
% definition in the Programmer's Guide).

disp('Collecting data...');

% Define the number of samples to collect
numSamples = 30;
dataValues = zeros(numSamples,1);

for n = 1:numSamples

    valuePtr = libpointer('int32Ptr', 0);

    status.getValue = calllib('usbpt104', 'UsbPt104GetValue', handle, channel1, valuePtr, 1);

    dataValues(n,1) = get(valuePtr, 'Value');
    
    % Convert the data using the appropriate scale
    if (dataType == usbpt104Enuminfo.enUsbPt104DataType.USBPT104_PT100)
       
        dataValues(n,1) = dataValues(n,1) / 1000;
        
    end
    
    % Wait for one second
    pause(1);
    
end

disp('Data collection complete.');

%% Process the data
% In this example, the data is shown on a plot

% Plot the data
figure('Name','USB PT-104 Platinum Resistance Data Logger Example', ...
    'NumberTitle', 'off');

hold on;

plot(1:numSamples, dataValues);

title('Plot of Temperature vs. Sample');
xlabel('Sample')
ylabel('Temperature (�C)')

legend('Channel 1')
grid on;

hold off;

%% Close connection to device

calllib('usbpt104', 'UsbPt104CloseUnit', handle);

%% Unload library

unloadlibrary('usbpt104');"
388,200.0,Jumo,Jumoquantrollc,Pytango,"Control Of The Jumo Quantrol Lc100/Lc200/Lc300, Universal Pid Controller",https://www.tango-controls.org/developers/dsc/ds/1840/,http://svn.code.sf.net/p/tango-ds/code/DeviceClasses/MeasureInstruments/JumoQuantrolLC/trunk/JumoQuantrolLC.py,Jumoquantrollc,"[OrderedDict([('id', 'attkvnF1BwobpzeRv'), ('width', 793), ('height', 619), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/7sWbVIesEGRwcIUG6Bft2w/e_PVSr2dZbriuRQ4OQLIu2hM5wuOKiF7RgsBU1gqyZZHG2XJ5jsAKBC39fImitsBAWy05atWkHj8_h1rr-fcaMYP1JQVcSnIL-B1XMke8GE/QsNJQPJvGhvPAnyr1SaTxu-U882fLqklj-7JDE1yb8o'), ('filename', 'LC100.jpg'), ('size', 54744), ('type', 'image/jpeg'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/TNkrGwJmmlZZqAJvirW-wg/_roKT7yqb6pmEEBbiCPgSaPEL4Hja9bw2DXNNjOIyoMAZYJ-a1SMjX0pRUpFdNPf4uqYlLEoXAhCbae8zEI7Gw/mY6102OtOp1Mmn8YIxQscNuG7AN0BgA4yAZsFca0zJw'), ('width', 46), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/7TkMuUfhr6Zz5elb7TfmOA/4purB_auKBP4NtrnVaiJhkQsviPThS0hsFLHiojQn2vYqXzHGJGcHdVcGArMILdRaLYPe905hnFcGh7Wa5NFAg/uVMTlzz0QfsReU2RwX9pWPtMiWXmDMLYkZ-jMgKZxU8'), ('width', 656), ('height', 512)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/CCOrn83qVvx4U8jEnLPwQQ/bJc8LlGoja2jCle8wHqQZr1DAxMPsP7M9-DWZz_SWbZc4JWKlDyWDLDgRQ09zlZ3lJuuPJ9j4E0hB2dTwwqV7A/I4qcw-9VmECuCXEQBgLDRL59CHGjMyTuT0HFaHjohYg'), ('width', 3000), ('height', 3000)]))]))])]",https://fr.jumo.ca/web/products/apps/productdetailpage?pdpId=702030,['Temperature Controllers'],"[OrderedDict([('id', 'attdbHMNNWuuTTg9v'), ('width', 900), ('height', 500), ('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/9jhIk-YMdy2RajRMAPBNgA/1vesbwg9abUvv6aE4eWtRGFIkl-uT2C7iQemIQ5NrFFba-rxUpabfNQxe4re5ZKpZ1DjXB4_knIXZqnjElt3H7vDXsheIW73b8P2MC_fJ8OjAob790vsrT-rI6BU6Wr4/azRcERz8UrpAqEkn3_zVhkTAZ9dsFRNPcM44-ab3z-U'), ('filename', 'jumo-gmbh-and-co-kg-vector-logo.png'), ('size', 7799), ('type', 'image/png'), ('thumbnails', OrderedDict([('small', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/QdMIyPd7WAwrpCSH7v12eA/MkS_2ai5VoF7pF-lmT36JovZe_H4ZEqpJCyNFPcFJJKIu1SWxSv4Etz9abyAFvFfAXWtWvVfAtN6r5CzNK5jfg/5bh6dT4xRJjQlvL1GITiYy6zQpSoMH10rh48SOzYLDU'), ('width', 65), ('height', 36)])), ('large', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/7_nva17cQkzcoTMUdxoJyQ/hYIanl-vux4cLAmZFsdF7fAwFedOc1FoDM9MA5YDGMgLJzcDlEEe-6gqhVrd3XrdXAF-8OTenH9QgQUSoQNKUw/PA_VhDBhQgwm1S8msCNy8ckTUBtcu4F6s07UpCodcC0'), ('width', 900), ('height', 500)])), ('full', OrderedDict([('url', 'https://v5.airtableusercontent.com/v1/19/19/1690070400000/b0Dv2u75LwWHxGy5nJoojA/k0873LFKBBq5lDBas0gqbBnDmaTK6O1dnCJYt5UEcnXi42-oTVV9uFm6DGnmIzJq9iCr_vWjmlLyicAKGVJf9Q/7OrAkQSiC4CI7YOS44ACjvW9VgGJdp4jbTCg9dKxof0'), ('width', 3000), ('height', 3000)]))]))])]","**JUMO** is your expert partner and manufacturer for industrial sensor technology up to the automation solution for temperature, pressure, and liquids.
",https://jumo.ca/,https://www.jumo.net/attachments/JUMO/attachmentdownload?id=64643,Canada,69.0,"Temperature control is a process in which change of temperature of a space (and objects collectively there within), or of a substance, is measured or otherwise detected, and the passage of heat energy into or out of the space or substance is adjusted to achieve a desired temperature",https://en.wikipedia.org/wiki/Temperature_control,Write a Python script that uses Pytango to connect to a Jumoquantrollc Temperature Controllers,,,,,
